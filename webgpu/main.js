var TAIGPU;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@orillusion/core/dist/orillusion.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/@orillusion/core/dist/orillusion.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccelerateDecelerateInterpolator: () => (/* binding */ Hh),
/* harmony export */   AccelerateInterpolator: () => (/* binding */ Qh),
/* harmony export */   AnimationCurve: () => (/* binding */ aa),
/* harmony export */   AnimationMonitor: () => (/* binding */ _r),
/* harmony export */   AnimatorEventKeyframe: () => (/* binding */ ap),
/* harmony export */   AnticipateInterpolator: () => (/* binding */ Wh),
/* harmony export */   AnticipateOvershootInterpolator: () => (/* binding */ Ss),
/* harmony export */   ArrayHas: () => (/* binding */ Jf),
/* harmony export */   ArrayItemIndex: () => (/* binding */ Zf),
/* harmony export */   AtlasParser: () => (/* binding */ Zo),
/* harmony export */   AtmosphericComponent: () => (/* binding */ ip),
/* harmony export */   AtmosphericScatteringSky: () => (/* binding */ Tc),
/* harmony export */   AtmosphericScatteringSkySetting: () => (/* binding */ Bc),
/* harmony export */   AtmosphericScatteringSky_shader: () => (/* binding */ rn),
/* harmony export */   AttributeAnimCurve: () => (/* binding */ Rc),
/* harmony export */   AudioListener: () => (/* binding */ dp),
/* harmony export */   AxisObject: () => (/* binding */ Fm),
/* harmony export */   B3DMLoader: () => (/* binding */ Pi),
/* harmony export */   B3DMLoaderBase: () => (/* binding */ Uu),
/* harmony export */   B3DMParseUtil: () => (/* binding */ jo),
/* harmony export */   B3DMParser: () => (/* binding */ Xo),
/* harmony export */   BLUR_CsShader: () => (/* binding */ Yg),
/* harmony export */   BRDFLUT: () => (/* binding */ Gu),
/* harmony export */   BRDFLUTGenerate: () => (/* binding */ Qu),
/* harmony export */   BRDF_frag: () => (/* binding */ jn),
/* harmony export */   BatchTable: () => (/* binding */ Ho),
/* harmony export */   Bezier2D: () => (/* binding */ Ia),
/* harmony export */   Bezier3D: () => (/* binding */ Tf),
/* harmony export */   BillboardComponent: () => (/* binding */ ys),
/* harmony export */   BillboardType: () => (/* binding */ xi),
/* harmony export */   BitmapTexture2D: () => (/* binding */ ii),
/* harmony export */   BitmapTexture2DArray: () => (/* binding */ Tl),
/* harmony export */   BitmapTextureCube: () => (/* binding */ ko),
/* harmony export */   Blend: () => (/* binding */ Dl),
/* harmony export */   BlendFactor: () => (/* binding */ no),
/* harmony export */   BlendMode: () => (/* binding */ xe),
/* harmony export */   Bloom_shader: () => (/* binding */ Ci),
/* harmony export */   BlurEffectCreatorBlur_cs: () => (/* binding */ Su),
/* harmony export */   BlurEffectCreatorSample_cs: () => (/* binding */ bu),
/* harmony export */   BlurTexture2DBufferCreator: () => (/* binding */ Iu),
/* harmony export */   BounceInterpolator: () => (/* binding */ At),
/* harmony export */   BoundUtil: () => (/* binding */ Zt),
/* harmony export */   BoundingBox: () => (/* binding */ Be),
/* harmony export */   BoundingSphere: () => (/* binding */ Sa),
/* harmony export */   BoxColliderShape: () => (/* binding */ Dc),
/* harmony export */   BoxGeometry: () => (/* binding */ us),
/* harmony export */   BrdfLut_frag: () => (/* binding */ Fn),
/* harmony export */   BxDF_frag: () => (/* binding */ qn),
/* harmony export */   BxdfDebug_frag: () => (/* binding */ $n),
/* harmony export */   BytesStream: () => (/* binding */ km),
/* harmony export */   CEvent: () => (/* binding */ je),
/* harmony export */   CEventDispatcher: () => (/* binding */ hi),
/* harmony export */   CEventListener: () => (/* binding */ Lr),
/* harmony export */   CResizeEvent: () => (/* binding */ df),
/* harmony export */   CSM: () => (/* binding */ lt),
/* harmony export */   Camera3D: () => (/* binding */ Zi),
/* harmony export */   CameraControllerBase: () => (/* binding */ pp),
/* harmony export */   CameraType: () => (/* binding */ Ie),
/* harmony export */   CameraUtil: () => (/* binding */ Ne),
/* harmony export */   CapsuleColliderShape: () => (/* binding */ Ep),
/* harmony export */   CastPointShadowMaterialPass: () => (/* binding */ bf),
/* harmony export */   CastShadowMaterialPass: () => (/* binding */ Sf),
/* harmony export */   Clearcoat_frag: () => (/* binding */ Kn),
/* harmony export */   ClusterBoundsSource_cs: () => (/* binding */ ih),
/* harmony export */   ClusterConfig: () => (/* binding */ ke),
/* harmony export */   ClusterDebug_frag: () => (/* binding */ En),
/* harmony export */   ClusterLight: () => (/* binding */ _c),
/* harmony export */   ClusterLightingBuffer: () => (/* binding */ th),
/* harmony export */   ClusterLightingRender: () => (/* binding */ wh),
/* harmony export */   ClusterLighting_cs: () => (/* binding */ rh),
/* harmony export */   CollectInfo: () => (/* binding */ Ul),
/* harmony export */   ColliderComponent: () => (/* binding */ rp),
/* harmony export */   ColliderShape: () => (/* binding */ Xe),
/* harmony export */   ColliderShapeType: () => (/* binding */ mr),
/* harmony export */   Color: () => (/* binding */ z),
/* harmony export */   ColorLitMaterial: () => (/* binding */ wf),
/* harmony export */   ColorLitShader: () => (/* binding */ en),
/* harmony export */   ColorPassFragmentOutput: () => (/* binding */ Wa),
/* harmony export */   ColorPassRenderer: () => (/* binding */ eh),
/* harmony export */   ColorUtil: () => (/* binding */ ja),
/* harmony export */   Common_frag: () => (/* binding */ On),
/* harmony export */   Common_vert: () => (/* binding */ Nn),
/* harmony export */   ComponentBase: () => (/* binding */ Ee),
/* harmony export */   ComponentCollect: () => (/* binding */ ae),
/* harmony export */   ComputeGPUBuffer: () => (/* binding */ ir),
/* harmony export */   ComputeShader: () => (/* binding */ be),
/* harmony export */   CubeCamera: () => (/* binding */ Rh),
/* harmony export */   CubeMapFaceEnum: () => (/* binding */ Bu),
/* harmony export */   CubeSky_Shader: () => (/* binding */ Ur),
/* harmony export */   CubicBezierCurve: () => (/* binding */ ca),
/* harmony export */   CubicBezierPath: () => (/* binding */ Am),
/* harmony export */   CubicBezierType: () => (/* binding */ Mf),
/* harmony export */   CycleInterpolator: () => (/* binding */ jh),
/* harmony export */   CylinderGeometry: () => (/* binding */ Pm),
/* harmony export */   DDGIIrradianceComputePass: () => (/* binding */ Oh),
/* harmony export */   DDGIIrradianceGPUBufferReader: () => (/* binding */ Es),
/* harmony export */   DDGIIrradianceVolume: () => (/* binding */ kl),
/* harmony export */   DDGIIrradiance_shader: () => (/* binding */ Uh),
/* harmony export */   DDGILightingPass: () => (/* binding */ zh),
/* harmony export */   DDGILighting_shader: () => (/* binding */ kh),
/* harmony export */   DDGIMultiBouncePass: () => (/* binding */ Fh),
/* harmony export */   DDGIProbeRenderer: () => (/* binding */ Gh),
/* harmony export */   DEGREES_TO_RADIANS: () => (/* binding */ _e),
/* harmony export */   DecelerateInterpolator: () => (/* binding */ Vh),
/* harmony export */   Depth2DTextureArray: () => (/* binding */ Eh),
/* harmony export */   DepthCubeArrayTexture: () => (/* binding */ Sh),
/* harmony export */   DepthCubeTexture: () => (/* binding */ Lm),
/* harmony export */   DepthMaterialPass: () => (/* binding */ If),
/* harmony export */   DepthOfFieldPost: () => (/* binding */ Vp),
/* harmony export */   DepthOfView_cs: () => (/* binding */ Ku),
/* harmony export */   DirectLight: () => (/* binding */ ou),
/* harmony export */   EditorInspector: () => (/* binding */ Vt),
/* harmony export */   Engine3D: () => (/* binding */ A),
/* harmony export */   Entity: () => (/* binding */ bl),
/* harmony export */   EntityBatchCollect: () => (/* binding */ Ol),
/* harmony export */   EntityCollect: () => (/* binding */ Q),
/* harmony export */   EnvMap_frag: () => (/* binding */ kn),
/* harmony export */   ErpImage2CubeMap: () => (/* binding */ Di),
/* harmony export */   ErpImage2CubeMapCreateCube_cs: () => (/* binding */ Tu),
/* harmony export */   ErpImage2CubeMapRgbe2rgba_cs: () => (/* binding */ Mu),
/* harmony export */   ExtrudeGeometry: () => (/* binding */ Pp),
/* harmony export */   FASTFLOOR: () => (/* binding */ zt),
/* harmony export */   FXAAPost: () => (/* binding */ uo),
/* harmony export */   FXAAShader: () => (/* binding */ Ic),
/* harmony export */   FastMathShader: () => (/* binding */ Gn),
/* harmony export */   FeatureTable: () => (/* binding */ ta),
/* harmony export */   FileLoader: () => (/* binding */ ht),
/* harmony export */   FirstPersonCameraController: () => (/* binding */ mp),
/* harmony export */   Float16ArrayTexture: () => (/* binding */ Gf),
/* harmony export */   Float32ArrayTexture: () => (/* binding */ Um),
/* harmony export */   FlyCameraController: () => (/* binding */ Ap),
/* harmony export */   FontChar: () => (/* binding */ Xu),
/* harmony export */   FontInfo: () => (/* binding */ Hu),
/* harmony export */   FontPage: () => (/* binding */ Yu),
/* harmony export */   FontParser: () => (/* binding */ Jo),
/* harmony export */   ForwardRenderJob: () => (/* binding */ wo),
/* harmony export */   FragmentVarying: () => (/* binding */ Vn),
/* harmony export */   FrameCache: () => (/* binding */ an),
/* harmony export */   Frustum: () => (/* binding */ yl),
/* harmony export */   FrustumCSM: () => (/* binding */ Cl),
/* harmony export */   FrustumCulling_cs: () => (/* binding */ Wg),
/* harmony export */   FullQuad_vert_wgsl: () => (/* binding */ el),
/* harmony export */   GBufferFrame: () => (/* binding */ wt),
/* harmony export */   GBufferPass: () => (/* binding */ Ef),
/* harmony export */   GBuffer_pass: () => (/* binding */ $o),
/* harmony export */   GILighting: () => (/* binding */ Xs),
/* harmony export */   GIProbeMaterial: () => (/* binding */ cn),
/* harmony export */   GIProbeMaterialType: () => (/* binding */ un),
/* harmony export */   GIProbeShader: () => (/* binding */ yc),
/* harmony export */   GIRenderCompleteEvent: () => (/* binding */ Co),
/* harmony export */   GIRenderStartEvent: () => (/* binding */ Hs),
/* harmony export */   GLBChunk: () => (/* binding */ gu),
/* harmony export */   GLBHeader: () => (/* binding */ du),
/* harmony export */   GLBParser: () => (/* binding */ qs),
/* harmony export */   GLSLLexer: () => (/* binding */ pu),
/* harmony export */   GLSLLexerToken: () => (/* binding */ as),
/* harmony export */   GLSLPreprocessor: () => (/* binding */ mu),
/* harmony export */   GLSLSyntax: () => (/* binding */ vu),
/* harmony export */   GLTFBinaryExtension: () => (/* binding */ Fu),
/* harmony export */   GLTFParser: () => (/* binding */ Ke),
/* harmony export */   GLTFSubParser: () => (/* binding */ js),
/* harmony export */   GLTFSubParserCamera: () => (/* binding */ Jh),
/* harmony export */   GLTFSubParserConverter: () => (/* binding */ fu),
/* harmony export */   GLTFSubParserMaterial: () => (/* binding */ eu),
/* harmony export */   GLTFSubParserMesh: () => (/* binding */ $h),
/* harmony export */   GLTFSubParserSkeleton: () => (/* binding */ Lo),
/* harmony export */   GLTFSubParserSkin: () => (/* binding */ tu),
/* harmony export */   GLTFType: () => (/* binding */ le),
/* harmony export */   GLTF_Accessors: () => (/* binding */ Cg),
/* harmony export */   GLTF_Info: () => (/* binding */ Ys),
/* harmony export */   GLTF_Light: () => (/* binding */ _g),
/* harmony export */   GLTF_Mesh: () => (/* binding */ yg),
/* harmony export */   GLTF_Node: () => (/* binding */ xg),
/* harmony export */   GLTF_Primitives: () => (/* binding */ vg),
/* harmony export */   GLTF_Scene: () => (/* binding */ Ag),
/* harmony export */   GPUAddressMode: () => (/* binding */ Bt),
/* harmony export */   GPUBlendFactor: () => (/* binding */ Wf),
/* harmony export */   GPUBufferBase: () => (/* binding */ Jt),
/* harmony export */   GPUBufferType: () => (/* binding */ Mt),
/* harmony export */   GPUCompareFunction: () => (/* binding */ vt),
/* harmony export */   GPUContext: () => (/* binding */ w),
/* harmony export */   GPUCullMode: () => (/* binding */ ui),
/* harmony export */   GPUFilterMode: () => (/* binding */ Nr),
/* harmony export */   GPUPrimitiveTopology: () => (/* binding */ Ms),
/* harmony export */   GPUTextureFormat: () => (/* binding */ G),
/* harmony export */   GPUVertexFormat: () => (/* binding */ Fr),
/* harmony export */   GPUVertexStepMode: () => (/* binding */ Kf),
/* harmony export */   GTAOPost: () => (/* binding */ Hp),
/* harmony export */   GTAO_cs: () => (/* binding */ Ju),
/* harmony export */   GUIAtlasTexture: () => (/* binding */ ju),
/* harmony export */   GUICanvas: () => (/* binding */ Cs),
/* harmony export */   GUIConfig: () => (/* binding */ ye),
/* harmony export */   GUIGeometry: () => (/* binding */ Fc),
/* harmony export */   GUIGeometryRebuild: () => (/* binding */ zc),
/* harmony export */   GUIMaterial: () => (/* binding */ Gc),
/* harmony export */   GUIPick: () => (/* binding */ Hc),
/* harmony export */   GUIPickHelper: () => (/* binding */ Ft),
/* harmony export */   GUIQuad: () => (/* binding */ Fi),
/* harmony export */   GUIQuadAttrEnum: () => (/* binding */ Pe),
/* harmony export */   GUIRenderer: () => (/* binding */ Qc),
/* harmony export */   GUIShader: () => (/* binding */ Ni),
/* harmony export */   GUISpace: () => (/* binding */ Nt),
/* harmony export */   GUISprite: () => (/* binding */ fr),
/* harmony export */   GUITexture: () => (/* binding */ dr),
/* harmony export */   GenerayRandomDir: () => (/* binding */ al),
/* harmony export */   GeometryBase: () => (/* binding */ tt),
/* harmony export */   GeometryIndicesBuffer: () => (/* binding */ Kl),
/* harmony export */   GeometryUtil: () => (/* binding */ zm),
/* harmony export */   GeometryVertexBuffer: () => (/* binding */ jl),
/* harmony export */   GeometryVertexType: () => (/* binding */ ti),
/* harmony export */   GetCountInstanceID: () => (/* binding */ qa),
/* harmony export */   GetRepeat: () => (/* binding */ od),
/* harmony export */   GlassMaterial: () => (/* binding */ wn),
/* harmony export */   GlassShader: () => (/* binding */ Cc),
/* harmony export */   GlobalBindGroup: () => (/* binding */ pe),
/* harmony export */   GlobalBindGroupLayout: () => (/* binding */ Hr),
/* harmony export */   GlobalFog: () => (/* binding */ Yp),
/* harmony export */   GlobalFog_shader: () => (/* binding */ Ec),
/* harmony export */   GlobalIlluminationComponent: () => (/* binding */ Sp),
/* harmony export */   GlobalUniform: () => (/* binding */ Ts),
/* harmony export */   GlobalUniformGroup: () => (/* binding */ Sl),
/* harmony export */   GodRayPost: () => (/* binding */ Xp),
/* harmony export */   GodRay_cs: () => (/* binding */ Zu),
/* harmony export */   Graphic3D: () => (/* binding */ af),
/* harmony export */   Graphic3DBatchRenderer: () => (/* binding */ Us),
/* harmony export */   Graphic3DFillRenderer: () => (/* binding */ rf),
/* harmony export */   Graphic3DFixedRenderPipeline: () => (/* binding */ Ll),
/* harmony export */   Graphic3DLineBatchRenderer: () => (/* binding */ sf),
/* harmony export */   Graphic3DShader_fs: () => (/* binding */ Rl),
/* harmony export */   Graphic3DShader_vs: () => (/* binding */ Pl),
/* harmony export */   GraphicConfig: () => (/* binding */ ei),
/* harmony export */   Graphics3DShape: () => (/* binding */ lo),
/* harmony export */   HDRBloomPost: () => (/* binding */ Wp),
/* harmony export */   HDRTexture: () => (/* binding */ Go),
/* harmony export */   HDRTextureCube: () => (/* binding */ ea),
/* harmony export */   HaltonSeq: () => (/* binding */ Ls),
/* harmony export */   Horizontal: () => (/* binding */ Kc),
/* harmony export */   HoverCameraController: () => (/* binding */ _p),
/* harmony export */   I3DMLoader: () => (/* binding */ si),
/* harmony export */   I3DMLoaderBase: () => (/* binding */ ku),
/* harmony export */   I3DMParser: () => (/* binding */ qo),
/* harmony export */   IBLEnvMapCreator: () => (/* binding */ cr),
/* harmony export */   IBLEnvMapCreator_cs: () => (/* binding */ Ru),
/* harmony export */   IESProfiles: () => (/* binding */ Bi),
/* harmony export */   IESProfiles_frag: () => (/* binding */ Yn),
/* harmony export */   IKDTreeUserData: () => (/* binding */ Op),
/* harmony export */   ImageType: () => (/* binding */ pr),
/* harmony export */   IndicesGPUBuffer: () => (/* binding */ ql),
/* harmony export */   Inline_vert: () => (/* binding */ Un),
/* harmony export */   InputSystem: () => (/* binding */ In),
/* harmony export */   InstanceDrawComponent: () => (/* binding */ Ip),
/* harmony export */   InstanceUniform: () => (/* binding */ zn),
/* harmony export */   InstancedMesh: () => (/* binding */ zu),
/* harmony export */   Interpolator: () => (/* binding */ So),
/* harmony export */   InterpolatorEnum: () => (/* binding */ bo),
/* harmony export */   IrradianceDataReaderCompleteEvent: () => (/* binding */ Af),
/* harmony export */   IrradianceVolumeData_frag: () => (/* binding */ Ln),
/* harmony export */   Irradiance_frag: () => (/* binding */ Wn),
/* harmony export */   IsEditorInspector: () => (/* binding */ Qd),
/* harmony export */   IsNonSerialize: () => (/* binding */ Gd),
/* harmony export */   Joint: () => (/* binding */ iu),
/* harmony export */   JointPose: () => (/* binding */ Ro),
/* harmony export */   JumperInterpolator: () => (/* binding */ Xh),
/* harmony export */   KDTreeEntity: () => (/* binding */ Fp),
/* harmony export */   KDTreeNode: () => (/* binding */ fn),
/* harmony export */   KDTreeRange: () => (/* binding */ hf),
/* harmony export */   KDTreeSpace: () => (/* binding */ uf),
/* harmony export */   KDTreeUUID: () => (/* binding */ ha),
/* harmony export */   KHR_draco_mesh_compression: () => (/* binding */ rs),
/* harmony export */   KHR_lights_punctual: () => (/* binding */ $p),
/* harmony export */   KHR_materials_clearcoat: () => (/* binding */ hu),
/* harmony export */   KHR_materials_emissive_strength: () => (/* binding */ uu),
/* harmony export */   KHR_materials_ior: () => (/* binding */ em),
/* harmony export */   KHR_materials_sheen: () => (/* binding */ tm),
/* harmony export */   KHR_materials_specular: () => (/* binding */ im),
/* harmony export */   KHR_materials_transmission: () => (/* binding */ rm),
/* harmony export */   KHR_materials_unlit: () => (/* binding */ cu),
/* harmony export */   KHR_materials_variants: () => (/* binding */ sm),
/* harmony export */   KHR_materials_volume: () => (/* binding */ am),
/* harmony export */   KHR_mesh_quantization: () => (/* binding */ om),
/* harmony export */   KHR_texture_basisu: () => (/* binding */ nm),
/* harmony export */   KHR_texture_transform: () => (/* binding */ lm),
/* harmony export */   KelvinUtil: () => (/* binding */ Gm),
/* harmony export */   KeyCode: () => (/* binding */ Je),
/* harmony export */   KeyEvent: () => (/* binding */ Qt),
/* harmony export */   Keyframe: () => (/* binding */ sn),
/* harmony export */   LDRTextureCube: () => (/* binding */ ra),
/* harmony export */   LUT_glsl: () => (/* binding */ Kg),
/* harmony export */   LambertMaterial: () => (/* binding */ pm),
/* harmony export */   LambertShader: () => (/* binding */ wc),
/* harmony export */   LightBase: () => (/* binding */ Ws),
/* harmony export */   LightData: () => (/* binding */ Gr),
/* harmony export */   LightEntries: () => (/* binding */ zl),
/* harmony export */   LightType: () => (/* binding */ Qe),
/* harmony export */   LightingFunction_frag: () => (/* binding */ Bn),
/* harmony export */   Line: () => (/* binding */ vr),
/* harmony export */   LineClassification: () => (/* binding */ Yc),
/* harmony export */   LinearInterpolator: () => (/* binding */ Yh),
/* harmony export */   LitMaterial: () => (/* binding */ yi),
/* harmony export */   LitShader: () => (/* binding */ Jn),
/* harmony export */   LoaderBase: () => (/* binding */ ji),
/* harmony export */   LoaderEvent: () => (/* binding */ dn),
/* harmony export */   LoaderManager: () => (/* binding */ Cf),
/* harmony export */   MAX_VALUE: () => (/* binding */ td),
/* harmony export */   MIN_VALUE: () => (/* binding */ id),
/* harmony export */   Material: () => (/* binding */ _i),
/* harmony export */   MaterialDataUniformGPUBuffer: () => (/* binding */ wu),
/* harmony export */   MaterialUniform: () => (/* binding */ $g),
/* harmony export */   MathShader: () => (/* binding */ Bs),
/* harmony export */   MathUtil: () => (/* binding */ st),
/* harmony export */   Matrix3: () => (/* binding */ Qi),
/* harmony export */   Matrix4: () => (/* binding */ V),
/* harmony export */   MatrixBindGroup: () => (/* binding */ Vl),
/* harmony export */   MatrixDO: () => (/* binding */ Up),
/* harmony export */   MatrixGPUBuffer: () => (/* binding */ Ql),
/* harmony export */   MatrixShader: () => (/* binding */ Sc),
/* harmony export */   MemoryDO: () => (/* binding */ zr),
/* harmony export */   MemoryInfo: () => (/* binding */ ol),
/* harmony export */   MergeRGBACreator: () => (/* binding */ kp),
/* harmony export */   MergeRGBA_cs: () => (/* binding */ $u),
/* harmony export */   MeshColliderShape: () => (/* binding */ tf),
/* harmony export */   MeshRenderer: () => (/* binding */ ce),
/* harmony export */   MinMaxAnimationCurves: () => (/* binding */ vm),
/* harmony export */   MinMaxCurve: () => (/* binding */ Nf),
/* harmony export */   MinMaxCurveState: () => (/* binding */ Of),
/* harmony export */   MinMaxPolyCurves: () => (/* binding */ ym),
/* harmony export */   MorePassParser: () => (/* binding */ Cr),
/* harmony export */   MorePassShader: () => (/* binding */ pf),
/* harmony export */   MorphTargetBlender: () => (/* binding */ op),
/* harmony export */   MorphTargetData: () => (/* binding */ Yl),
/* harmony export */   MorphTargetFrame: () => (/* binding */ np),
/* harmony export */   MorphTarget_shader: () => (/* binding */ Le),
/* harmony export */   MouseCode: () => (/* binding */ gf),
/* harmony export */   MultiBouncePass_cs: () => (/* binding */ Nh),
/* harmony export */   NonSerialize: () => (/* binding */ zd),
/* harmony export */   NormalMap_frag: () => (/* binding */ Qn),
/* harmony export */   OAnimationEvent: () => (/* binding */ su),
/* harmony export */   OBJParser: () => (/* binding */ Fo),
/* harmony export */   Object3D: () => (/* binding */ te),
/* harmony export */   Object3DEvent: () => (/* binding */ fs),
/* harmony export */   Object3DUtil: () => (/* binding */ pa),
/* harmony export */   ObjectAnimClip: () => (/* binding */ Lc),
/* harmony export */   OcclusionSystem: () => (/* binding */ ks),
/* harmony export */   Octree: () => (/* binding */ er),
/* harmony export */   OctreeEntity: () => (/* binding */ Ml),
/* harmony export */   OrbitController: () => (/* binding */ xp),
/* harmony export */   Orientation3D: () => (/* binding */ yt),
/* harmony export */   OutLineBlendColor_cs: () => (/* binding */ ec),
/* harmony export */   OutlineCalcOutline_cs: () => (/* binding */ tc),
/* harmony export */   OutlinePass: () => (/* binding */ Jg),
/* harmony export */   OutlinePost: () => (/* binding */ jp),
/* harmony export */   OutlinePostData: () => (/* binding */ xf),
/* harmony export */   OutlinePostManager: () => (/* binding */ vf),
/* harmony export */   OutlinePostSlot: () => (/* binding */ _f),
/* harmony export */   Outline_cs: () => (/* binding */ ic),
/* harmony export */   OvershootInterpolator: () => (/* binding */ qh),
/* harmony export */   PBRLItShader: () => (/* binding */ Zn),
/* harmony export */   ParserBase: () => (/* binding */ Xt),
/* harmony export */   ParticleSystemCurveEvalMode: () => (/* binding */ Uf),
/* harmony export */   ParticleSystemRandomnessIds: () => (/* binding */ Df),
/* harmony export */   PassGenerate: () => (/* binding */ Xr),
/* harmony export */   PassShader: () => (/* binding */ mf),
/* harmony export */   PavementShader: () => (/* binding */ Zg),
/* harmony export */   PhysicMaterial: () => (/* binding */ os),
/* harmony export */   PhysicMaterialUniform_frag: () => (/* binding */ Tn),
/* harmony export */   PickCompute: () => (/* binding */ of),
/* harmony export */   PickFire: () => (/* binding */ nf),
/* harmony export */   PickResult: () => (/* binding */ yf),
/* harmony export */   Picker_cs: () => (/* binding */ rc),
/* harmony export */   PingPong: () => (/* binding */ Ja),
/* harmony export */   PipelinePool: () => (/* binding */ Js),
/* harmony export */   Plane: () => (/* binding */ bn),
/* harmony export */   PlaneGeometry: () => (/* binding */ Zl),
/* harmony export */   PointClassification: () => (/* binding */ Xc),
/* harmony export */   PointLight: () => (/* binding */ nu),
/* harmony export */   PointLightShadowRenderer: () => (/* binding */ Ih),
/* harmony export */   PointMaterial: () => (/* binding */ mm),
/* harmony export */   PointShadowCubeCamera: () => (/* binding */ bh),
/* harmony export */   PointShadowDebug: () => (/* binding */ bc),
/* harmony export */   PointerEvent3D: () => (/* binding */ R),
/* harmony export */   Polynomial: () => (/* binding */ jt),
/* harmony export */   PolynomialCurve: () => (/* binding */ da),
/* harmony export */   Polynomials: () => (/* binding */ xm),
/* harmony export */   PoolNode: () => (/* binding */ Vc),
/* harmony export */   PositionAudio: () => (/* binding */ gp),
/* harmony export */   PostBase: () => (/* binding */ Ct),
/* harmony export */   PostProcessingComponent: () => (/* binding */ bp),
/* harmony export */   PostRenderer: () => (/* binding */ Dh),
/* harmony export */   PreDepthPassRenderer: () => (/* binding */ Th),
/* harmony export */   Preprocessor: () => (/* binding */ ut),
/* harmony export */   Probe: () => (/* binding */ ef),
/* harmony export */   ProbeEntries: () => (/* binding */ Gl),
/* harmony export */   ProbeGBufferFrame: () => (/* binding */ Lh),
/* harmony export */   ProfilerUtil: () => (/* binding */ ft),
/* harmony export */   PropertyAnimClip: () => (/* binding */ sp),
/* harmony export */   PropertyAnimTag: () => (/* binding */ Uc),
/* harmony export */   PropertyAnimation: () => (/* binding */ An),
/* harmony export */   PropertyAnimationEvent: () => (/* binding */ Ui),
/* harmony export */   PropertyHelp: () => (/* binding */ Wt),
/* harmony export */   QuadGlsl_fs: () => (/* binding */ vc),
/* harmony export */   QuadGlsl_vs: () => (/* binding */ xc),
/* harmony export */   Quad_depth2dArray_frag_wgsl: () => (/* binding */ Xf),
/* harmony export */   Quad_depth2d_frag_wgsl: () => (/* binding */ rl),
/* harmony export */   Quad_depthCube_frag_wgsl: () => (/* binding */ sl),
/* harmony export */   Quad_frag_wgsl: () => (/* binding */ il),
/* harmony export */   Quad_vert_wgsl: () => (/* binding */ tl),
/* harmony export */   Quaternion: () => (/* binding */ q),
/* harmony export */   RADIANS_TO_DEGREES: () => (/* binding */ qi),
/* harmony export */   RGBEErrorCode: () => (/* binding */ Pu),
/* harmony export */   RGBEHeader: () => (/* binding */ Qo),
/* harmony export */   RGBEParser: () => (/* binding */ $s),
/* harmony export */   RTDescriptor: () => (/* binding */ Ce),
/* harmony export */   RTFrame: () => (/* binding */ Ze),
/* harmony export */   RTResourceConfig: () => (/* binding */ Ae),
/* harmony export */   RTResourceMap: () => (/* binding */ Fe),
/* harmony export */   Rand: () => (/* binding */ As),
/* harmony export */   RandomSeed: () => (/* binding */ nd),
/* harmony export */   Ray: () => (/* binding */ ci),
/* harmony export */   RayCastMeshDetail: () => (/* binding */ zi),
/* harmony export */   Reader: () => (/* binding */ nr),
/* harmony export */   Rect: () => (/* binding */ bs),
/* harmony export */   Reference: () => (/* binding */ se),
/* harmony export */   RegisterComponent: () => (/* binding */ Vd),
/* harmony export */   RenderContext: () => (/* binding */ $l),
/* harmony export */   RenderLayer: () => (/* binding */ Yr),
/* harmony export */   RenderLayerUtil: () => (/* binding */ oo),
/* harmony export */   RenderNode: () => (/* binding */ $t),
/* harmony export */   RenderShader: () => (/* binding */ We),
/* harmony export */   RenderShaderCollect: () => (/* binding */ Nl),
/* harmony export */   RendererBase: () => (/* binding */ di),
/* harmony export */   RendererJob: () => (/* binding */ Ph),
/* harmony export */   RendererMap: () => (/* binding */ Mh),
/* harmony export */   RendererMask: () => (/* binding */ Ue),
/* harmony export */   RendererMaskUtil: () => (/* binding */ Tt),
/* harmony export */   RendererPassState: () => (/* binding */ Wl),
/* harmony export */   RendererType: () => (/* binding */ re),
/* harmony export */   RepeatSE: () => (/* binding */ Za),
/* harmony export */   Res: () => (/* binding */ qu),
/* harmony export */   SN_ArrayConstant: () => (/* binding */ Is),
/* harmony export */   SN_BinaryOperation: () => (/* binding */ Ai),
/* harmony export */   SN_Break: () => (/* binding */ zg),
/* harmony export */   SN_CodeBlock: () => (/* binding */ Gt),
/* harmony export */   SN_Constant: () => (/* binding */ ni),
/* harmony export */   SN_Continue: () => (/* binding */ va),
/* harmony export */   SN_Declaration: () => (/* binding */ Te),
/* harmony export */   SN_Discard: () => (/* binding */ Gg),
/* harmony export */   SN_DoWhileLoop: () => (/* binding */ kg),
/* harmony export */   SN_Expression: () => (/* binding */ ie),
/* harmony export */   SN_ForLoop: () => (/* binding */ Yi),
/* harmony export */   SN_Function: () => (/* binding */ _a),
/* harmony export */   SN_FunctionArgs: () => (/* binding */ xa),
/* harmony export */   SN_FunctionCall: () => (/* binding */ Hi),
/* harmony export */   SN_IFBranch: () => (/* binding */ Gi),
/* harmony export */   SN_Identifier: () => (/* binding */ ri),
/* harmony export */   SN_IndexOperation: () => (/* binding */ Wi),
/* harmony export */   SN_Layout: () => (/* binding */ vs),
/* harmony export */   SN_ParenExpression: () => (/* binding */ _u),
/* harmony export */   SN_Precision: () => (/* binding */ ya),
/* harmony export */   SN_Return: () => (/* binding */ _s),
/* harmony export */   SN_SelectOperation: () => (/* binding */ xs),
/* harmony export */   SN_Struct: () => (/* binding */ oi),
/* harmony export */   SN_TernaryOperation: () => (/* binding */ xu),
/* harmony export */   SN_UnaryOperation: () => (/* binding */ lr),
/* harmony export */   SN_WhileLoop: () => (/* binding */ Xi),
/* harmony export */   SSAO_cs: () => (/* binding */ Xg),
/* harmony export */   SSRPost: () => (/* binding */ qp),
/* harmony export */   SSR_BlendColor_cs: () => (/* binding */ sc),
/* harmony export */   SSR_IS_Kernel: () => (/* binding */ Kp),
/* harmony export */   SSR_IS_cs: () => (/* binding */ ac),
/* harmony export */   SSR_RayTrace_cs: () => (/* binding */ oc),
/* harmony export */   Scene3D: () => (/* binding */ Tp),
/* harmony export */   ShaderAttributeInfo: () => (/* binding */ No),
/* harmony export */   ShaderBase: () => (/* binding */ Ka),
/* harmony export */   ShaderConverter: () => (/* binding */ Ks),
/* harmony export */   ShaderConverterResult: () => (/* binding */ yu),
/* harmony export */   ShaderLib: () => (/* binding */ N),
/* harmony export */   ShaderReflection: () => (/* binding */ ct),
/* harmony export */   ShaderStage: () => (/* binding */ Ut),
/* harmony export */   ShaderState: () => (/* binding */ Cu),
/* harmony export */   ShaderUniformInfo: () => (/* binding */ Oo),
/* harmony export */   ShaderUtil: () => (/* binding */ Ot),
/* harmony export */   ShadingInput: () => (/* binding */ Hn),
/* harmony export */   ShadowLightsCollect: () => (/* binding */ Ve),
/* harmony export */   ShadowMapPassRenderer: () => (/* binding */ Bh),
/* harmony export */   ShadowMapping_frag: () => (/* binding */ Xn),
/* harmony export */   Skeleton: () => (/* binding */ ru),
/* harmony export */   SkeletonAnimationClip: () => (/* binding */ ma),
/* harmony export */   SkeletonAnimationClipState: () => (/* binding */ au),
/* harmony export */   SkeletonAnimationComponent: () => (/* binding */ vi),
/* harmony export */   SkeletonAnimationCompute: () => (/* binding */ lp),
/* harmony export */   SkeletonAnimation_shader: () => (/* binding */ Or),
/* harmony export */   SkeletonBlendComputeArgs: () => (/* binding */ hp),
/* harmony export */   SkeletonPose: () => (/* binding */ ss),
/* harmony export */   SkeletonTransformComputeArgs: () => (/* binding */ up),
/* harmony export */   SkinnedMeshRenderer: () => (/* binding */ Aa),
/* harmony export */   SkyGBufferPass: () => (/* binding */ Bf),
/* harmony export */   SkyGBuffer_pass: () => (/* binding */ gc),
/* harmony export */   SkyMaterial: () => (/* binding */ Mc),
/* harmony export */   SkyRenderer: () => (/* binding */ sa),
/* harmony export */   Sky_glsl_fs: () => (/* binding */ qg),
/* harmony export */   Sky_glsl_vs: () => (/* binding */ jg),
/* harmony export */   SolidColorSky: () => (/* binding */ Om),
/* harmony export */   SphereColliderShape: () => (/* binding */ Bp),
/* harmony export */   SphereGeometry: () => (/* binding */ ls),
/* harmony export */   SpotLight: () => (/* binding */ lu),
/* harmony export */   StatementNode: () => (/* binding */ me),
/* harmony export */   StaticAudio: () => (/* binding */ Oc),
/* harmony export */   StorageGPUBuffer: () => (/* binding */ ge),
/* harmony export */   StringUtil: () => (/* binding */ it),
/* harmony export */   Struct: () => (/* binding */ wi),
/* harmony export */   StructStorageGPUBuffer: () => (/* binding */ zp),
/* harmony export */   SubGeometry: () => (/* binding */ Jl),
/* harmony export */   TAACopyTex_cs: () => (/* binding */ nc),
/* harmony export */   TAAPost: () => (/* binding */ Jp),
/* harmony export */   TAASharpTex_cs: () => (/* binding */ lc),
/* harmony export */   TAA_cs: () => (/* binding */ hc),
/* harmony export */   TextAnchor: () => (/* binding */ jc),
/* harmony export */   TextFieldLayout: () => (/* binding */ Zc),
/* harmony export */   TextFieldLine: () => (/* binding */ Jc),
/* harmony export */   Texture: () => (/* binding */ at),
/* harmony export */   TextureCube: () => (/* binding */ Zs),
/* harmony export */   TextureCubeFaceData: () => (/* binding */ Vo),
/* harmony export */   TextureCubeStdCreator: () => (/* binding */ hr),
/* harmony export */   TextureCubeUtils: () => (/* binding */ zo),
/* harmony export */   TextureMipmapCompute: () => (/* binding */ ds),
/* harmony export */   TextureMipmapGenerator: () => (/* binding */ Ht),
/* harmony export */   ThirdPersonCameraController: () => (/* binding */ yp),
/* harmony export */   TileSet: () => (/* binding */ hm),
/* harmony export */   TileSetChild: () => (/* binding */ cm),
/* harmony export */   TileSetChildContent: () => (/* binding */ fm),
/* harmony export */   TileSetChildContentMetaData: () => (/* binding */ dm),
/* harmony export */   TileSetRoot: () => (/* binding */ um),
/* harmony export */   TilesRenderer: () => (/* binding */ Cn),
/* harmony export */   Time: () => (/* binding */ he),
/* harmony export */   TokenType: () => (/* binding */ x),
/* harmony export */   TorusGeometry: () => (/* binding */ Rm),
/* harmony export */   TouchData: () => (/* binding */ Sn),
/* harmony export */   Transform: () => (/* binding */ Oe),
/* harmony export */   TranslatorContext: () => (/* binding */ Uo),
/* harmony export */   Triangle: () => (/* binding */ na),
/* harmony export */   UIButton: () => (/* binding */ _n),
/* harmony export */   UIButtonTransition: () => (/* binding */ $c),
/* harmony export */   UIComponentBase: () => (/* binding */ ln),
/* harmony export */   UIEvent: () => (/* binding */ ua),
/* harmony export */   UIImage: () => (/* binding */ Vi),
/* harmony export */   UIImageGroup: () => (/* binding */ xn),
/* harmony export */   UIInteractive: () => (/* binding */ ba),
/* harmony export */   UIInteractiveStyle: () => (/* binding */ De),
/* harmony export */   UIPanel: () => (/* binding */ ws),
/* harmony export */   UIRenderAble: () => (/* binding */ cs),
/* harmony export */   UIShadow: () => (/* binding */ vn),
/* harmony export */   UITextField: () => (/* binding */ yn),
/* harmony export */   UITransform: () => (/* binding */ li),
/* harmony export */   UUID: () => (/* binding */ Pt),
/* harmony export */   UV: () => (/* binding */ zf),
/* harmony export */   Uint16Texture: () => (/* binding */ Nm),
/* harmony export */   Uint8ArrayTexture: () => (/* binding */ Vu),
/* harmony export */   UnLit: () => (/* binding */ tn),
/* harmony export */   UnLitMaterial: () => (/* binding */ hs),
/* harmony export */   UnLitMaterialUniform_frag: () => (/* binding */ Mn),
/* harmony export */   UnLit_frag: () => (/* binding */ Dn),
/* harmony export */   UniformGPUBuffer: () => (/* binding */ Dt),
/* harmony export */   UniformNode: () => (/* binding */ $),
/* harmony export */   UniformType: () => (/* binding */ $e),
/* harmony export */   ValueSpread: () => (/* binding */ Cm),
/* harmony export */   Vector2: () => (/* binding */ Z),
/* harmony export */   Vector3: () => (/* binding */ g),
/* harmony export */   Vector3Ex: () => (/* binding */ Oi),
/* harmony export */   Vector3Struct: () => (/* binding */ Ym),
/* harmony export */   Vector4: () => (/* binding */ j),
/* harmony export */   VertexAttribute: () => (/* binding */ Lp),
/* harmony export */   VertexAttributeName: () => (/* binding */ Y),
/* harmony export */   VertexAttributeSize: () => (/* binding */ bi),
/* harmony export */   VertexAttributeStride: () => (/* binding */ lf),
/* harmony export */   VertexAttributes: () => (/* binding */ Pn),
/* harmony export */   VertexBufferLayout: () => (/* binding */ Rp),
/* harmony export */   VertexFormat: () => (/* binding */ ll),
/* harmony export */   VertexGPUBuffer: () => (/* binding */ ho),
/* harmony export */   Vertical: () => (/* binding */ qc),
/* harmony export */   VideoUniform_frag: () => (/* binding */ Rn),
/* harmony export */   View3D: () => (/* binding */ Mp),
/* harmony export */   ViewPanel: () => (/* binding */ Ca),
/* harmony export */   ViewQuad: () => (/* binding */ Ns),
/* harmony export */   VirtualTexture: () => (/* binding */ oe),
/* harmony export */   WGSLTranslator: () => (/* binding */ Au),
/* harmony export */   WebGPUDescriptorCreator: () => (/* binding */ He),
/* harmony export */   WorldMatrixUniform: () => (/* binding */ Xa),
/* harmony export */   WorldPanel: () => (/* binding */ wa),
/* harmony export */   WrapMode: () => (/* binding */ Ar),
/* harmony export */   WrapTimeMode: () => (/* binding */ Pc),
/* harmony export */   ZCullingCompute: () => (/* binding */ Qp),
/* harmony export */   ZPassShader_cs: () => (/* binding */ pc),
/* harmony export */   ZPassShader_fs: () => (/* binding */ mc),
/* harmony export */   ZPassShader_vs: () => (/* binding */ Ac),
/* harmony export */   ZSorterUtil: () => (/* binding */ Il),
/* harmony export */   append: () => (/* binding */ xl),
/* harmony export */   arrayToString: () => (/* binding */ Lu),
/* harmony export */   blendComponent: () => (/* binding */ jf),
/* harmony export */   buildCurves: () => (/* binding */ bm),
/* harmony export */   calculateCurveRangesValue: () => (/* binding */ Sm),
/* harmony export */   calculateMinMax: () => (/* binding */ ps),
/* harmony export */   castPointShadowMap_vert: () => (/* binding */ cc),
/* harmony export */   clamp: () => (/* binding */ K),
/* harmony export */   clampRepeat: () => (/* binding */ Td),
/* harmony export */   compute_skeleton_blend: () => (/* binding */ cp),
/* harmony export */   compute_skeleton_transform: () => (/* binding */ fp),
/* harmony export */   cos: () => (/* binding */ vd),
/* harmony export */   crossProduct: () => (/* binding */ Id),
/* harmony export */   cubicPolynomialRoot: () => (/* binding */ Pf),
/* harmony export */   cubicPolynomialRootsGeneric: () => (/* binding */ Rf),
/* harmony export */   curvesSupportProcedural: () => (/* binding */ wm),
/* harmony export */   deg2Rad: () => (/* binding */ Ad),
/* harmony export */   directionShadowCastMap_frag: () => (/* binding */ dc),
/* harmony export */   dot: () => (/* binding */ et),
/* harmony export */   doubleIntegrateSegment: () => (/* binding */ Lf),
/* harmony export */   f32: () => (/* binding */ Qm),
/* harmony export */   fastInvSqrt: () => (/* binding */ Al),
/* harmony export */   floorfToIntPos: () => (/* binding */ ml),
/* harmony export */   fonts: () => (/* binding */ gr),
/* harmony export */   generateRandom: () => (/* binding */ Ed),
/* harmony export */   generateRandom3: () => (/* binding */ Bd),
/* harmony export */   getFloatFromInt: () => (/* binding */ fl),
/* harmony export */   getGLTypeFromTypedArray: () => (/* binding */ Lg),
/* harmony export */   getGLTypeFromTypedArrayType: () => (/* binding */ Rg),
/* harmony export */   getGlobalRandomSeed: () => (/* binding */ yd),
/* harmony export */   getTypedArray: () => (/* binding */ Ug),
/* harmony export */   getTypedArrayTypeFromGLType: () => (/* binding */ Po),
/* harmony export */   grad1: () => (/* binding */ mn),
/* harmony export */   grad2: () => (/* binding */ ga),
/* harmony export */   grad3: () => (/* binding */ ms),
/* harmony export */   grad4: () => (/* binding */ br),
/* harmony export */   i32: () => (/* binding */ Vm),
/* harmony export */   integrateSegment: () => (/* binding */ pn),
/* harmony export */   irradianceDataReader: () => (/* binding */ Gp),
/* harmony export */   kPI: () => (/* binding */ _m),
/* harmony export */   lerp: () => (/* binding */ Ii),
/* harmony export */   lerpByte: () => (/* binding */ ad),
/* harmony export */   lerpColor: () => (/* binding */ sd),
/* harmony export */   lerpVector3: () => (/* binding */ rd),
/* harmony export */   magnitude: () => (/* binding */ eo),
/* harmony export */   makeAloneSprite: () => (/* binding */ Hg),
/* harmony export */   makeGUISprite: () => (/* binding */ Wu),
/* harmony export */   makeMatrix44: () => (/* binding */ Rs),
/* harmony export */   matrixMultiply: () => (/* binding */ so),
/* harmony export */   matrixRotate: () => (/* binding */ Rd),
/* harmony export */   matrixRotateY: () => (/* binding */ Pd),
/* harmony export */   multiplyMatrices4x4REF: () => (/* binding */ _l),
/* harmony export */   normal_distribution: () => (/* binding */ Ff),
/* harmony export */   normalizeFast: () => (/* binding */ Sd),
/* harmony export */   normalizeSafe: () => (/* binding */ cl),
/* harmony export */   normalizedToByte: () => (/* binding */ bd),
/* harmony export */   normalizedToWord: () => (/* binding */ wd),
/* harmony export */   outlinePostData: () => (/* binding */ kt),
/* harmony export */   outlinePostManager: () => (/* binding */ Zp),
/* harmony export */   perm: () => (/* binding */ J),
/* harmony export */   quadraticPolynomialRootsGeneric: () => (/* binding */ fa),
/* harmony export */   rad2Deg: () => (/* binding */ _d),
/* harmony export */   random01: () => (/* binding */ Ki),
/* harmony export */   randomBarycentricCoord: () => (/* binding */ md),
/* harmony export */   randomPointBetweenEllipsoid: () => (/* binding */ pd),
/* harmony export */   randomPointBetweenSphere: () => (/* binding */ dd),
/* harmony export */   randomPointInsideCube: () => (/* binding */ cd),
/* harmony export */   randomPointInsideEllipsoid: () => (/* binding */ fd),
/* harmony export */   randomPointInsideUnitCircle: () => (/* binding */ gd),
/* harmony export */   randomPointInsideUnitSphere: () => (/* binding */ gl),
/* harmony export */   randomQuaternion: () => (/* binding */ hd),
/* harmony export */   randomQuaternionUniformDistribution: () => (/* binding */ ud),
/* harmony export */   randomSeed: () => (/* binding */ pl),
/* harmony export */   randomUnitVector: () => (/* binding */ Ps),
/* harmony export */   randomUnitVector2: () => (/* binding */ dl),
/* harmony export */   rangedRandomFloat: () => (/* binding */ qe),
/* harmony export */   rangedRandomInt: () => (/* binding */ ld),
/* harmony export */   readMagicBytes: () => (/* binding */ Yo),
/* harmony export */   registerMaterial: () => (/* binding */ gm),
/* harmony export */   repeat: () => (/* binding */ ro),
/* harmony export */   rotMatrix: () => (/* binding */ Dd),
/* harmony export */   rotateVectorByQuat: () => (/* binding */ ed),
/* harmony export */   roundfToIntPos: () => (/* binding */ to),
/* harmony export */   scale: () => (/* binding */ $a),
/* harmony export */   shadowCastMap_frag: () => (/* binding */ fc),
/* harmony export */   shadowCastMap_vert: () => (/* binding */ uc),
/* harmony export */   simplex: () => (/* binding */ mt),
/* harmony export */   sin: () => (/* binding */ xd),
/* harmony export */   snoise1: () => (/* binding */ Bm),
/* harmony export */   snoise2: () => (/* binding */ Tm),
/* harmony export */   snoise3: () => (/* binding */ Mm),
/* harmony export */   snoise4: () => (/* binding */ Dm),
/* harmony export */   sqrMagnitude: () => (/* binding */ io),
/* harmony export */   sqrtImpl: () => (/* binding */ ul),
/* harmony export */   stencilStateFace: () => (/* binding */ qf),
/* harmony export */   swap: () => (/* binding */ Cd),
/* harmony export */   toHalfFloat: () => (/* binding */ ur),
/* harmony export */   u32: () => (/* binding */ Hm),
/* harmony export */   uniform_real_distribution: () => (/* binding */ Im),
/* harmony export */   uniform_real_distribution2: () => (/* binding */ Em),
/* harmony export */   webGPUContext: () => (/* binding */ S),
/* harmony export */   zSorterUtil: () => (/* binding */ El)
/* harmony export */ });
var Qf=Object.defineProperty,Vf=(i,e,t)=>e in i?Qf(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,o=(i,e,t)=>(Vf(i,typeof e!="symbol"?e+"":e,t),t),b;let z=(b=class{constructor(i=1,e=1,t=1,r=1){o(this,"r",0),o(this,"g",0),o(this,"b",0),o(this,"a",0),this.setTo(i,e,t,r)}convertToHDRRGB(){return this.r=this.r*Math.pow(2.4,this.a),this.g=this.g*Math.pow(2.4,this.a),this.b=this.b*Math.pow(2.4,this.a),this}unSerialized(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}hexToRGB(i){return this.r=(i>>16&255)/255,this.g=(i>>8&255)/255,this.b=(i&255)/255,this}hexToRGBA(i){return this.a=(i>>24&255)/255,this.r=(i>>16&255)/255,this.g=(i>>8&255)/255,this.b=(i&255)/255,this}static random(i=1){let e=new b;return e.a=i,e.r=i*Math.random(),e.g=i*Math.random(),e.b=i*Math.random(),e}setTo(i,e,t,r){this.r=Math.max(i,0),this.g=Math.max(e,0),this.b=Math.max(t,0),this.a=Math.max(r,0)}setHex(i){if(typeof i!="string"||b.NON_HEX_CHARS.test(i)||!b.VALID_HEX_SIZE.test(i))throw new TypeError("Expected a valid hex string");i=i.replace(/^#/,"");let e=1;i.length===8&&(e=Number.parseInt(i.slice(6,8),16)/255,i=i.slice(0,6)),i.length===4&&(e=Number.parseInt(i.slice(3,4).repeat(2),16)/255,i=i.slice(0,3)),i.length===3&&(i=i[0]+i[0]+i[1]+i[1]+i[2]+i[2]);const t=Number.parseInt(i,16),r=t>>16,s=t>>8&255,a=t&255,n=e;this.a=n,this.r=r/255,this.g=s/255,this.b=a/255}getHex(){let i=t=>{t*=255;let r=t.toString(16);return r.length===1&&(r="0"+r),r};return i(this.r)+i(this.g)+i(this.b)+i(this.a)}get rgb(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0]}set rgb(i){this.setTo(i[0]/255,i[1]/255,i[2]/255,this.a)}get rgba(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0,this.a*255>>>0]}set rgba(i){this.setTo(i[0]/255,i[1]/255,i[2]/255,i[3]/255)}clone(){return new b().copyFrom(this)}copyFrom(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}copyFromArray(i,e=255){return this.r=i[0]/e,this.g=i[1]/e,this.b=i[2]/e,this.a=i[3]/e,this}copyFromVector(i){return this.r=i.x,this.g=i.y,this.b=i.z,this.a=i.w,this}static hexRGBColor(i,e=null){return e=e||new b,e.hexToRGB(i),e}},o(b,"COLOR_RED",new b(1,0,0,1)),o(b,"COLOR_GREEN",new b(0,1,0,1)),o(b,"COLOR_BLUE",new b(0,0,1,1)),o(b,"COLOR_WHITE",new b(1,1,1,1)),o(b,"COLOR_0",new b),o(b,"COLOR_1",new b),o(b,"COLOR_2",new b),o(b,"HEX_CHARACTERS","a-f\\d"),o(b,"MATCH_3OR4_HEX",`#?[${b.HEX_CHARACTERS}]{3}[${b.HEX_CHARACTERS}]?`),o(b,"MATCH_6OR8_HEX",`#?[${b.HEX_CHARACTERS}]{6}([${b.HEX_CHARACTERS}]{2})?`),o(b,"NON_HEX_CHARS",new RegExp(`[^#${b.HEX_CHARACTERS}]`,"gi")),o(b,"VALID_HEX_SIZE",new RegExp(`^${b.MATCH_3OR4_HEX}$|^${b.MATCH_6OR8_HEX}$`,"i")),o(b,"PRIMARY",4149685),o(b,"PRIMARYDARK",3162015),o(b,"ACCENT",16728193),o(b,"WHITE",16777215),o(b,"IVORY",16777200),o(b,"LIGHTYELLOW",16777184),o(b,"YELLOW",16776960),o(b,"SNOW",16775930),o(b,"FLORALWHITE",16775920),o(b,"LEMONCHIFFON",16775885),o(b,"CORNSILK",16775388),o(b,"SEASHELL",16774638),o(b,"LAVENDERBLUSH",16773365),o(b,"PAPAYAWHIP",16773077),o(b,"BLANCHEDALMOND",16772045),o(b,"MISTYROSE",16770273),o(b,"BISQUE",16770244),o(b,"MOCCASIN",16770229),o(b,"NAVAJOWHITE",16768685),o(b,"PEACHPUFF",16767673),o(b,"GOLD",16766720),o(b,"PINK",16761035),o(b,"LIGHTPINK",16758465),o(b,"ORANGE",16753920),o(b,"LIGHTSALMON",16752762),o(b,"DARKORANGE",16747520),o(b,"CORAL",16744272),o(b,"HOTPINK",16738740),o(b,"TOMATO",16737095),o(b,"ORANGERED",16729344),o(b,"DEEPPINK",16716947),o(b,"FUCHSIA",16711935),o(b,"MAGENTA",16711935),o(b,"RED",16711680),o(b,"OLDLACE",16643558),o(b,"LIGHTGOLDENRODYELLOW",16448210),o(b,"LINEN",16445670),o(b,"ANTIQUEWHITE",16444375),o(b,"SALMON",16416882),o(b,"GHOSTWHITE",16316671),o(b,"MINTCREAM",16121850),o(b,"WHITESMOKE",16119285),o(b,"BEIGE",16119260),o(b,"WHEAT",16113331),o(b,"SANDYBROWN",16032864),o(b,"AZURE",15794175),o(b,"HONEYDEW",15794160),o(b,"ALICEBLUE",15792383),o(b,"KHAKI",15787660),o(b,"LIGHTCORAL",15761536),o(b,"PALEGOLDENROD",15657130),o(b,"VIOLET",15631086),o(b,"DARKSALMON",15308410),o(b,"LAVENDER",15132410),o(b,"LIGHTCYAN",14745599),o(b,"BURLYWOOD",14596231),o(b,"PLUM",14524637),o(b,"GAINSBORO",14474460),o(b,"CRIMSON",14423100),o(b,"PALEVIOLETRED",14381203),o(b,"GOLDENROD",14329120),o(b,"ORCHID",14315734),o(b,"THISTLE",14204888),o(b,"LIGHTGREY",13882323),o(b,"TAN",13808780),o(b,"CHOCOLATE",13789470),o(b,"PERU",13468991),o(b,"INDIANRED",13458524),o(b,"MEDIUMVIOLETRED",13047173),o(b,"SILVER",12632256),o(b,"DARKKHAKI",12433259),o(b,"ROSYBROWN",12357519),o(b,"MEDIUMORCHID",12211667),o(b,"DARKGOLDENROD",12092939),o(b,"FIREBRICK",11674146),o(b,"POWDERBLUE",11591910),o(b,"LIGHTSTEELBLUE",11584734),o(b,"PALETURQUOISE",11529966),o(b,"GREENYELLOW",11403055),o(b,"LIGHTBLUE",11393254),o(b,"DARKGRAY",11119017),o(b,"BROWN",10824234),o(b,"SIENNA",10506797),o(b,"DARKORCHID",10040012),o(b,"PALEGREEN",10025880),o(b,"DARKVIOLET",9699539),o(b,"MEDIUMPURPLE",9662683),o(b,"LIGHTGREEN",9498256),o(b,"DARKSEAGREEN",9419919),o(b,"SADDLEBROWN",9127187),o(b,"DARKMAGENTA",9109643),o(b,"DARKRED",9109504),o(b,"BLUEVIOLET",9055202),o(b,"LIGHTSKYBLUE",8900346),o(b,"SKYBLUE",8900331),o(b,"GRAY",8421504),o(b,"OLIVE",8421376),o(b,"PURPLE",8388736),o(b,"MAROON",8388608),o(b,"AQUAMARINE",8388564),o(b,"CHARTREUSE",8388352),o(b,"LAWNGREEN",8190976),o(b,"MEDIUMSLATEBLUE",8087790),o(b,"LIGHTSLATEGRAY",7833753),o(b,"SLATEGRAY",7372944),o(b,"OLIVEDRAB",7048739),o(b,"SLATEBLUE",6970061),o(b,"DIMGRAY",6908265),o(b,"MEDIUMAQUAMARINE",6737322),o(b,"CORNFLOWERBLUE",6591981),o(b,"CADETBLUE",6266528),o(b,"DARKOLIVEGREEN",5597999),o(b,"INDIGO",4915330),o(b,"MEDIUMTURQUOISE",4772300),o(b,"DARKSLATEBLUE",4734347),o(b,"STEELBLUE",4620980),o(b,"ROYALBLUE",4286945),o(b,"TURQUOISE",4251856),o(b,"MEDIUMSEAGREEN",3978097),o(b,"LIMEGREEN",3329330),o(b,"DARKSLATEGRAY",3100495),o(b,"SEAGREEN",3050327),o(b,"FORESTGREEN",2263842),o(b,"LIGHTSEAGREEN",2142890),o(b,"DODGERBLUE",2003199),o(b,"MIDNIGHTBLUE",1644912),o(b,"AQUA",65535),o(b,"CYAN",65535),o(b,"SPRINGGREEN",65407),o(b,"LIME",65280),o(b,"MEDIUMSPRINGGREEN",64154),o(b,"DARKTURQUOISE",52945),o(b,"DEEPSKYBLUE",49151),o(b,"DARKCYAN",35723),o(b,"TEAL",32896),o(b,"GREEN",32768),o(b,"DARKGREEN",25600),o(b,"BLUE",255),o(b,"MEDIUMBLUE",205),o(b,"DARKBLUE",139),o(b,"NAVY",128),o(b,"BLACK",0),b);class he{static start(e){this._startTime=performance.now(),this._timeLabel=e}static end(){console.log(this._timeLabel,performance.now()-this._startTime)}}o(he,"time",0),o(he,"frame",0),o(he,"delta",0),o(he,"_startTime",0),o(he,"_timeLabel","");class je{constructor(e=null,t=null){o(this,"target"),o(this,"currentTarget"),o(this,"type"),o(this,"data"),o(this,"param"),o(this,"time",0),o(this,"delay",0),o(this,"mouseCode",0),o(this,"ctrlKey"),o(this,"altKey"),o(this,"shiftKey"),o(this,"targetTouches"),o(this,"changedTouches"),o(this,"touches"),o(this,"_stopImmediatePropagation",!1),o(this,"view"),this.type=e,this.data=t}stopImmediatePropagation(){this._stopImmediatePropagation=!0}reset(){this._stopImmediatePropagation=!1}get isStopImmediatePropagation(){return this._stopImmediatePropagation}}class Lr{constructor(e=null,t=null,r=null,s=null,a=0){o(this,"id",0),o(this,"current"),this.type=e,this.thisObject=t,this.handler=r,this.param=s,this.priority=a}equalCurrentListener(e,t,r,s){return this.type==e&&this.thisObject==r&&this.handler==t&&this.param==s}dispose(){this.handler=null,this.thisObject=null,this.param=null,this.priority=0}}o(Lr,"event_id_count",0);class hi{constructor(){o(this,"listeners",{}),o(this,"data")}dispatchEvent(e){var t=this.listeners[e.type];if(t!=null){t=t.slice();for(var r=0;r<t.length;r++){var s=t[r];if(s.handler){try{e.param=s.param,e.currentTarget=s,s.thisObject,s.handler.call(s.thisObject,e)}catch{}if(e.isStopImmediatePropagation)break}}}}destroy(){for(var e in this.listeners)for(var t=this.listeners[e];t.length>0;){var r=t[0];r.handler=null,r.thisObject=null,t.splice(0,1)}}addEventListener(e,t,r,s=null,a=0){if(this.listeners[e]==null&&(this.listeners[e]=[]),!this.hasEventListener(e,t,r)){var n=new Lr(e,r,t,s,a);return n.id=++Lr.event_id_count,n.current=this,this.listeners[e].push(n),this.listeners[e].sort(function(l,h){return h.priority-l.priority}),n.id}for(let l=0;l<this.listeners[e].length;l++){let h=this.listeners[e][l];if(h.equalCurrentListener(e,t,r,s))return h.id}return 0}removeEventListener(e,t,r){if(this.hasEventListener(e,t,r))for(var s=0;s<this.listeners[e].length;s++){var a=this.listeners[e][s];if(a.equalCurrentListener(e,t,r,a.param)){a.handler=null,a.thisObject=null,this.listeners[e].splice(s,1);return}}}removeEventListenerAt(e){for(var t in this.listeners)for(var r=0;r<this.listeners[t].length;r++){var s=this.listeners[t][r];if(s.id==e)return s.handler=null,s.thisObject=null,this.listeners[t].splice(r,1),!0}return!1}removeAllEventListener(e=null){let t;if(e){if(this.listeners[e]){for(var r=0;r<this.listeners[e].length;r++)t=this.listeners[e][r],t.dispose(),this.listeners[e].splice(r,1);delete this.listeners[e]}}else for(let s in this.listeners){for(var r=0;r<this.listeners[s].length;r++)t=this.listeners[s][r],t.dispose(),this.listeners[s].splice(r,1);delete this.listeners[s]}}containEventListener(e){return this.listeners[e]==null?!1:this.listeners[e].length>0}hasEventListener(e,t=null,r=null){if(this.listeners[e]==null)return!1;if(r&&t)for(var s=0;s<this.listeners[e].length;s++){var a=this.listeners[e][s];if(a.equalCurrentListener(e,t,r,a.param))return!0}return!1}}class Qt extends je{constructor(){super(...arguments),o(this,"keyCode",0)}}o(Qt,"KEY_DOWN","onKeyDown"),o(Qt,"KEY_UP","onKeyUp");class R extends je{constructor(){super(...arguments),o(this,"pointerId"),o(this,"pointerType"),o(this,"isPrimary"),o(this,"pressure"),o(this,"mouseX"),o(this,"mouseY"),o(this,"movementX"),o(this,"movementY"),o(this,"deltaX"),o(this,"deltaY"),o(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}o(R,"PICK_OVER","onPickOver"),o(R,"PICK_OVER_GUI","onPickOverGUI"),o(R,"PICK_CLICK","onPickClick"),o(R,"PICK_CLICK_GUI","onPickClickGUI"),o(R,"PICK_OUT","onPickOut"),o(R,"PICK_OUT_GUI","onPickOutGUI"),o(R,"PICK_MOVE","onPickMove"),o(R,"PICK_UP","onPickUp"),o(R,"PICK_UP_GUI","onPickUpGUI"),o(R,"PICK_DOWN","onPickDown"),o(R,"PICK_DOWN_GUI","onPickDownGUI"),o(R,"POINTER_RIGHT_CLICK","onPointerRightClick"),o(R,"POINTER_MID_UP","onPointerMidUp"),o(R,"POINTER_MID_DOWN","onPointerMidDown"),o(R,"POINTER_CLICK","onPointerClick"),o(R,"POINTER_MOVE","onPointerMove"),o(R,"POINTER_DOWN","onPointerDown"),o(R,"POINTER_UP","onPointerUp"),o(R,"POINTER_OUT","onPointerOut"),o(R,"POINTER_OVER","onPointerOver"),o(R,"POINTER_WHEEL","onPointerWheel");const X=class{constructor(i=0,e=0,t=0,r=0){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",1),o(this,"index",0),this.set(i,e,t,r),this.index=X._index++}static get ZERO(){return new X(0,0,0)}static get ONE(){return new X(1,1,1)}static get LEFT(){return new X(-1,0,0)}static get RIGHT(){return new X(1,0,0)}static get UP(){return new X(0,1,0)}static get DOWN(){return new X(0,-1,0)}static get BACK(){return new X(0,0,-1)}static get FORWARD(){return new X(0,0,1)}set a(i){this.w=i}set r(i){this.x=i}set g(i){this.y=i}set b(i){this.z=i}get a(){return this.w}get r(){return this.x}get g(){return this.y}get b(){return this.z}get length(){return Math.sqrt(this.lengthSquared)}get lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}get position(){return this}static getTowPointbyDir(i,e,t,r,s){s==X.Z_AXIS?(e.x=i.y,e.y=-i.x,t.x=-i.y,t.y=i.x,e.scaleBy(r*.5),t.scaleBy(r*.5)):s==X.Y_AXIS&&(e.x=i.z,e.z=-i.x,t.x=-i.z,t.z=i.x,e.scaleBy(r*.5),t.scaleBy(r*.5))}static pointToLine(i,e,t){let r=0,s,a,n;if(s=X.distance(i,e),a=X.distance(i,t),n=X.distance(e,t),n<=1e-6||a<=1e-6)return r=0,r;if(s<=1e-6||n*n>=s*s+a*a)return r=a,r;if(a*a>=s*s+n*n)return r=n,r;let l=(s+a+n)/2;return r=2*Math.sqrt(l*(l-s)*(l-a)*(l-n))/s,r}static dot(i,e){return i.x*e.x+i.y*e.y+i.z*e.z}static getPoints(i,e){let t=[];for(let r=0;r<i;r++){const s=new X(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);t.push(s)}return t}static getPointNumbers(i,e){let t=[];for(let r=0;r<i;r++)t.push(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);return t}static getAngle(i,e){let t=i.dotProduct(e)/(i.length*e.length);return Math.acos(t)*180/Math.PI}static sqrMagnitude(i){return i.x*i.x+i.y*i.y+i.z*i.z}static getZYAngle(i,e){return this.calAngle(i.y,i.z,e.y,e.z)}static sub(i,e,t=null){return t=t||new X,t.x=i.x-e.x,t.y=i.y-e.y,t.z=i.z-e.z,t}static add(i,e,t=null){return t=t||new X,t.x=i.x+e.x,t.y=i.y+e.y,t.z=i.z+e.z,t}static smoothDamp(i,e,t,r,s,a){return null}static distance(i,e){var t=i.x-e.x,r=i.y-e.y,s=i.z-e.z;return Math.sqrt(t*t+r*r+s*s)}static squareDistance(i,e){var t=i.x-e.x,r=i.y-e.y,s=i.z-e.z;return t*t+r*r+s*s}static distanceXZ(i,e){var t=i.x-e.x,r=0,s=i.z-e.z;return Math.sqrt(t*t+r*r+s*s)}set(i,e,t,r=1){return this.x=i,this.y=e,this.z=t,this.w=r,this}add(i,e=null){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=this.w,n=i.x,l=i.y,h=i.z,u=i.w;return e.setTo(t+n,r+l,s+h,a+u),e}subVectors(i,e){return this.x=i.x-e.x,this.y=i.y-e.y,this.z=i.z-e.z,this}distanceToSquared(i){let e=this.x-i.x,t=this.y-i.y,r=this.z-i.z;return e*e+t*t+r*r}addXYZW(i,e,t,r,s=null){s||(s=new X);var a=this.x,n=this.y,l=this.z,h=this.w,u=i,c=e,f=t,d=r;return s.setTo(a+u,n+c,l+f,h+d),s}clone(){return new X(this.x,this.y,this.z,this.w)}copyFrom(i){var e=this;return e.x=i.x,e.y=i.y,e.z=i.z,e.w=i.w,e}decrementBy(i){this.x-=i.x,this.y-=i.y,this.z-=i.z}dotProduct(i){return this.x*i.x+this.y*i.y+this.z*i.z}equals(i,e=!1){return this.x==i.x&&this.y==i.y&&this.z==i.z&&(!e||this.w==i.w)}incrementBy(i){this.x+=i.x,this.y+=i.y,this.z+=i.z}divide(i){return i instanceof X?new X(this.x/i.x,this.y/i.y,this.z/i.z):(this.x=this.x/i,this.y=this.y/i,this.z=this.z/i,this)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}normalize(i=1){let e=this;if(this.length!=0){var t=i/this.length;return this.x*=t,this.y*=t,this.z*=t,e}return e}applyQuaternion(i){const e=this.x,t=this.y,r=this.z,s=i.x,a=i.y,n=i.z,l=i.w,h=l*e+a*r-n*t,u=l*t+n*e-s*r,c=l*r+s*t-a*e,f=-s*e-a*t-n*r;return this.x=h*l+f*-s+u*-n-c*-a,this.y=u*l+f*-a+c*-s-h*-n,this.z=c*l+f*-n+h*-a-u*-s,this}scaleBy(i){return this.x*=i,this.y*=i,this.z*=i,this}mul(i){let e=new X;return e.x=this.x*i,e.y=this.y*i,e.z=this.z*i,e}scale(i){return this.x*=i.x,this.y*=i.y,this.z*=i.z,this}scaleToRef(i,e){return e||(e=new X),e.x=this.x*i,e.y=this.y*i,e.z=this.z*i,e}setTo(i,e,t,r=1){this.x=i,this.y=e,this.z=t,this.w=r}copy(i){return this.x=i.x,this.y=i.y,this.z=i.z,this.w=i.w,this}subtract(i,e=null){return e||(e=new X),e.setTo(this.x-i.x,this.y-i.y,this.z-i.z),e}multiply(i,e=null){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=i.x,n=i.y,l=i.z;return e.setTo(t*a,r*n,s*l),e}divided(i,e=null){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=i.x,n=i.y,l=i.z;return e.setTo(t/a,r/n,s/l),e}div(i,e){e||(e=new X);var t=this.x,r=this.y,s=this.z,a=this.w;return e.setTo(t/i,r/i,s/i,a/i),e}lerp(i,e,t){var r=i.x,s=i.y,a=i.z,n=i.w,l=e.x,h=e.y,u=e.z,c=e.w;this.x=(l-r)*t+r,this.y=(h-s)*t+s,this.z=(u-a)*t+a,this.w=(c-n)*t+n}clamp(i,e){return this.x=Math.max(i.x,Math.min(e.x,this.x)),this.y=Math.max(i.y,Math.min(e.y,this.y)),this.z=Math.max(i.z,Math.min(e.z,this.z)),this}toString(){return"<"+this.x+", "+this.y+", "+this.z+">"}normalizeToWay2D_XY(){let i=Math.abs(this.x),e=Math.abs(this.y);i>e?this.x>0?this.copyFrom(X.RIGHT):this.copyFrom(X.LEFT):this.y>0?this.copyFrom(X.DOWN):this.copyFrom(X.UP)}toArray(){return[this.x,this.y,this.z]}copyToBytes(i){i.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this.x,!0),i.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,this.y,!0),i.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,this.z,!0)}crossProduct(i,e=null){return e=e||new X,e.x=this.y*i.z-this.z*i.y,e.y=this.z*i.x-this.x*i.z,e.z=this.x*i.y-this.y*i.x,e.w=1,e}crossVectors(i,e){return i.crossProduct(e,this),this}multiplyScalar(i){return this.x*=i,this.y*=i,this.z*=i,this}setFromArray(i,e=0){this.x=i[e],this.y=i[e+1],this.z=i[e+2]}divideScalar(i){return this.multiplyScalar(1/i)}clampLength(i,e){let t=this.length;return this.divideScalar(t||1).multiplyScalar(Math.max(i,Math.min(e,t)))}setScalar(i){return this.x=i,this.y=i,this.z=i,this}static calAngle(i,e,t,r){const s=n(t,r,i,e);let a=Math.acos(s)*180/Math.PI;return t<i&&(a=-a),a;function n(h,u,c,f){let d=[h-c,u-f];return l(d,[0,-1])}function l(h,u){let c=h[0]*u[0]+h[1]*u[1],f=Math.sqrt(h[0]*h[0]+h[1]*h[1])*Math.sqrt(u[0]*u[0]+u[1]*u[1]);return c/f}}};let g=X;o(g,"MAX",new X(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)),o(g,"MIN",new X(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE)),o(g,"SAFE_MAX",new X(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),o(g,"SAFE_MIN",new X(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)),o(g,"X_AXIS",new X(1,0,0)),o(g,"neg_X_AXIS",new X(-1,0,0)),o(g,"Y_AXIS",new X(0,1,0)),o(g,"Z_AXIS",new X(0,0,1)),o(g,"HELP_0",new X),o(g,"HELP_1",new X),o(g,"HELP_2",new X),o(g,"EPSILON",1e-5),o(g,"HELP_3",new X),o(g,"HELP_4",new X),o(g,"HELP_5",new X),o(g,"HELP_6",new X),o(g,"_index",0);class Sn{constructor(e){o(this,"canvasX"),o(this,"canvasY"),o(this,"identifier"),o(this,"clientX"),o(this,"clientY"),o(this,"pageX"),o(this,"pageY"),o(this,"screenX"),o(this,"screenY"),this.canvasX=e.clientX,this.canvasY=e.clientY,this.identifier=e.identifier,this.clientX=e.clientX,this.clientY=e.clientY,this.pageX=e.pageX,this.pageY=e.pageY,this.screenX=e.screenX,this.screenY=e.screenY}}class In extends hi{constructor(){super(...arguments),o(this,"canvasX",0),o(this,"canvasY",0),o(this,"isMouseDown",!1),o(this,"isRightMouseDown",!1),o(this,"canvas"),o(this,"mouseX",0),o(this,"mouseY",0),o(this,"wheelDelta",0),o(this,"mouseOffsetX",0),o(this,"mouseOffsetY",0),o(this,"mouseLastX",0),o(this,"mouseLastY",0),o(this,"_time",0),o(this,"_keyStatus"),o(this,"_mouseStatus"),o(this,"_isTouchStart"),o(this,"_keyEvent3d"),o(this,"_pointerEvent3D"),o(this,"_windowsEvent3d"),o(this,"_gp",!1),o(this,"_oldPosition1",null),o(this,"_oldPosition2",null),o(this,"_downTime",0)}initCanvas(e){this.canvas=e,e.onpointerdown=r=>{r.button==0?this.mouseStart(r):r.button==1?this.middleDown(r):r.button==2&&this.mouseStart(r)},e.onpointerup=r=>{r.button==0?this.mouseEnd(r):r.button==1?this.middleUp(r):r.button==2&&this.mouseEnd(r)},e.onpointerenter=r=>{this.mouseOver(r)},e.onpointermove=r=>{this.mouseMove(r)},e.onpointercancel=r=>{this.mouseEnd(r)},e.onpointerleave=r=>{this.mouseEnd(r)},e.onpointerout=r=>{this.mouseEnd(r)},e.addEventListener("click",r=>{r.button==2?(this.isRightMouseDown=!1,this.rightClick(r)):r.button==0&&(this.isMouseDown=!1,this.mouseClick(r))},!0),e.addEventListener("wheel",r=>this.mouseWheel(r),{passive:!1}),window.addEventListener("keydown",r=>this.keyDown(r),!0),window.addEventListener("keyup",r=>this.keyUp(r),!0),e.oncontextmenu=function(){return!1};let t=this.canvas.getBoundingClientRect();this.canvasX=t.left,this.canvasY=t.top,this._keyStatus={},this._mouseStatus={},this._isTouchStart=!1,this._keyEvent3d=new Qt,this._pointerEvent3D=new R,this._windowsEvent3d=new je}onPinch(e,t,r,s){this._oldPosition1=new g(e,t),this._oldPosition2=new g(r,s)}onSwipe(e,t){this.mouseX=e,this.mouseY=t,this._oldPosition1=null,this._oldPosition2=null,this._time=new Date().getTime()}GetTargetTouches(e){for(var t=new Array,r=0;r<e.length;r++){var s=new Sn(e[r]);t.push(s)}return t}rightClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_RIGHT_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}middleDown(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_MID_DOWN,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}middleUp(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_MID_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}mouseClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=R.POINTER_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseEnd(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._mouseStatus[this._pointerEvent3D.mouseCode]=!1,this._pointerEvent3D.type=R.POINTER_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseStart(e){this.isMouseDown=!0,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.type=R.POINTER_DOWN,this.dispatchEvent(this._pointerEvent3D)}mouseMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=R.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}mouseOver(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=R.POINTER_OVER,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseWheel(e){e.preventDefault(),this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,"wheelDelta"in e?(this._pointerEvent3D.delay=e.wheelDelta,this.wheelDelta=e.wheelDelta):"delta"in e&&(this.wheelDelta=e.delta),this._pointerEvent3D.reset(),this._pointerEvent3D.type=R.POINTER_WHEEL,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.deltaX=e.deltaX,this._pointerEvent3D.deltaY=e.deltaY,this._pointerEvent3D.deltaZ=e.deltaZ,this.dispatchEvent(this._pointerEvent3D)}keyDown(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyEvent3d.ctrlKey=e.ctrlKey,this._keyEvent3d.altKey=e.altKey,this._keyEvent3d.shiftKey=e.shiftKey,this._keyStatus[e.keyCode]||(this._keyStatus[e.keyCode]=!0,this._keyEvent3d.type=Qt.KEY_DOWN,this.dispatchEvent(this._keyEvent3d))}keyUp(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyStatus[e.keyCode]=!1,this._keyEvent3d.type=Qt.KEY_UP,this.dispatchEvent(this._keyEvent3d)}GetSlideAngle(e,t){return Math.atan2(t,e)*180/Math.PI}GetSlideDirection(e,t,r,s){var a=t-s,n=r-e,l=0;if(Math.abs(n)<2&&Math.abs(a)<2)return l;var h=this.GetSlideAngle(n,a);return h>=-45&&h<45?l=4:h>=45&&h<135?l=1:h>=-135&&h<-45?l=2:(h>=135&&h<=180||h>=-180&&h<-135)&&(l=3),l}}const Hf="0.6.9";class Yf{constructor(){o(this,"adapter"),o(this,"device"),o(this,"context"),o(this,"aspect"),o(this,"presentationSize",[0,0]),o(this,"presentationFormat"),o(this,"canvas"),o(this,"windowWidth"),o(this,"windowHeight"),o(this,"canvasConfig"),o(this,"super",1),o(this,"_pixelRatio",1)}get pixelRatio(){return this._pixelRatio}async init(e){var t;if(this.canvasConfig=e,e&&e.canvas){if(this.canvas=e.canvas,this.canvas===null)throw new Error("no Canvas");const a=this.canvas.clientWidth,n=this.canvas.clientHeight;this.resize(this.canvas.clientWidth,this.canvas.clientHeight),a!=this.canvas.clientWidth&&(this.canvas.style.width=a+"px"),n!=this.canvas.clientHeight&&(this.canvas.style.height=n+"px")}else this.canvas=document.createElement("canvas"),this.canvas.style.position="absolute",this.canvas.style.top="0px",this.canvas.style.left="0px",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.zIndex=e?.zIndex?e.zIndex.toString():"0",document.body.appendChild(this.canvas);if(e&&e.backgroundImage?(this.canvas.style.background=`url(${e.backgroundImage})`,this.canvas.style["background-size"]="cover",this.canvas.style["background-position"]="center"):this.canvas.style.background="transparent",this.canvas.style["touch-action"]="none",this.canvas.style["object-fit"]="cover",navigator.gpu===void 0)throw new Error("Your browser does not support WebGPU!");if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),this.adapter==null)throw new Error("Your browser does not support WebGPU!");if(this.device=await this.adapter.requestDevice({requiredFeatures:["bgra8unorm-storage","depth-clip-control","depth32float-stencil8","indirect-first-instance","rg11b10ufloat-renderable"],requiredLimits:{minUniformBufferOffsetAlignment:256,maxStorageBufferBindingSize:this.adapter.limits.maxStorageBufferBindingSize}}),this.device==null)throw new Error("Your browser does not support WebGPU!");this._pixelRatio=((t=this.canvasConfig)==null?void 0:t.devicePixelRatio)||window.devicePixelRatio||1,this._pixelRatio=Math.min(this._pixelRatio,2),this.device.label="device",this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"premultiplied",colorSpace:"display-p3"}),this.resize(this.canvas.clientWidth,this.canvas.clientHeight);let r;return new ResizeObserver(()=>{clearTimeout(r),r=setTimeout(()=>{this.resize(this.canvas.clientWidth,this.canvas.clientHeight)},50)}).observe(this.canvas),!0}resize(e,t){this.canvas.width=this.windowWidth=Math.floor(e*this.pixelRatio*this.super),this.canvas.height=this.windowHeight=Math.floor(t*this.pixelRatio*this.super),this.presentationSize[0]=this.windowWidth,this.presentationSize[1]=this.windowHeight,this.aspect=this.windowWidth/this.windowHeight}}let S=new Yf;class Ci{}o(Ci,"Bloom_Brightness_frag_wgsl",`
    struct uniformData {
        luminosityThreshold: f32
    };

    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;
    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn Brightness(c: vec3<f32>) -> f32 {
        var c1: vec3<f32>;

        c1 = c;
        let e8: vec3<f32> = c1;
        let e10: vec3<f32> = c1;
        let e12: vec3<f32> = c1;
        let e14: vec3<f32> = c1;
        let e17: vec3<f32> = c1;
        let e19: vec3<f32> = c1;
        let e21: vec3<f32> = c1;
        let e23: vec3<f32> = c1;
        let e25: vec3<f32> = c1;
        let e28: vec3<f32> = c1;
        return max(max(e23.x, e25.y), e28.z);
    }

    fn main1() {
        var uv: vec2<f32>;
        var LinearColor: vec4<f32>;
        var TotalLuminance: f32;
        var BloomLuminance: f32;
        var BloomAmount: f32;

        let e6: vec2<f32> = fragUV1;
        uv = e6.xy;
        let e11: vec2<f32> = uv;
        uv.y = (1.0 - e11.y);
        let e15: vec2<f32> = uv;
        let e16: vec4<f32> = textureSample(baseMap, baseMapSampler, e15);
        LinearColor = e16;
        let e18: vec4<f32> = LinearColor;
        let e27: vec4<f32> = LinearColor;
        let e36: vec4<f32> = LinearColor;
        let e38: vec3<f32> = min(vec3<f32>(f32(65000), f32(65000), f32(65000)), e36.xyz);
        LinearColor.x = e38.x;
        LinearColor.y = e38.y;
        LinearColor.z = e38.z;
        let e45: vec4<f32> = LinearColor;
        let e47: vec4<f32> = LinearColor;
        let e49: f32 = Brightness(e47.xyz);
        TotalLuminance = e49;
        let e51: f32 = TotalLuminance;
        let e52: f32 = global.luminosityThreshold;
        BloomLuminance = (e51 - e52);
        let e55: f32 = BloomLuminance;
        let e60: f32 = BloomLuminance;
        BloomAmount = clamp((e60 * 0.5), 0.0, 1.0);
        let e67: f32 = BloomAmount;
        let e68: vec4<f32> = LinearColor;
        o_Target = vec4<f32>((e67 * e68.xyz), f32(0));
        return;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        fragUV1 = fragUV;
        main1();
        let e13: vec4<f32> = o_Target;
        return FragmentOutput(e13);
    }
    `),o(Ci,"Bloom_blur_frag_wgsl",`
      struct uniformData {
          texSize: vec2<f32>,
          hScale: f32,
          vScale: f32,
          horizontal: f32
      };

      struct FragmentOutput {
          @location(0) o_Target: vec4<f32>
      };

      var<private> fragUV1: vec2<f32>;
      var<private> o_Target: vec4<f32>;
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
      @group(2) @binding(0)
      var<uniform> global: uniformData;

      fn main1() {
       
          return;
      }

      const buffer1: array<f32,5> = array<f32,5>(0.22702699899673462, 0.194594606757164, 0.12162160128355026, 0.05405399948358536, 0.01621600054204464);

      @fragment
      fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
          var result: vec3<f32>;
          var i: i32 = 1;
          var j: i32 = 1;
          var uv: vec2<f32> = fragUV;
          uv.y = (1.0 - uv.y);
          var tex_offset: vec2<f32> = (vec2<f32>(1.0) / vec2<f32>(global.texSize));
          let color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv);
          result = (color.xyz * buffer1[0]);
        
          if ((global.horizontal > 1.0)) {
              {
                  loop {
                      if (!((i < 5))) {
                          break;
                      }
                      {
                          let c1: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv + vec2<f32>(((tex_offset.x * f32(i)) * global.hScale), 0.0)));
                          result = (result + (c1.xyz * buffer1[i]));
                          let e101: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv - vec2<f32>(((tex_offset.x * f32(i)) * global.hScale), 0.0)));
                          result = (result + (e101.xyz * buffer1[i]));
                      }
                      continuing {
                          i = (i + 1);
                      }
                  }
              }
          }
          if ((global.horizontal < 1.0)) {
              {
                  loop {
                      let e114: i32 = j;
                      if (!((e114 < 5))) {
                          break;
                      }
                      {
                          let e144: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv + vec2<f32>(0.0, ((tex_offset.y * f32(j)) * global.vScale))));
                          result = (result + (e144.xyz * buffer1[j]));
                          let e175: vec4<f32> = textureSample(baseMap, baseMapSampler, (uv - vec2<f32>(0.0, ((tex_offset.y * f32(j)) * global.vScale))));
                          result = (result + (e175.xyz *  buffer1[j]));
                      }
                      continuing {
                          j = (j + 1);
                      }
                  }
              }
          }
          o_Target = vec4<f32>(result, 1.0);
          return FragmentOutput(o_Target);
      }
    `),o(Ci,"Bloom_composite_frag_wgsl",`
    #include "ColorUtil"
      struct UniformData {
          tintColor:vec4<f32>,
          bloomStrength: f32,
          exposure: f32,
          bloomRadius: f32,
      };

      struct FragmentOutput {
          @location(0) o_Target: vec4<f32>
      };

      var<private> fragUV1: vec2<f32>;
      var<private> o_Target: vec4<f32>;
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
      @group(1) @binding(2)
      var blurTex1Sampler: sampler;
      @group(1) @binding(3)
      var blurTex1: texture_2d<f32>;
      @group(1) @binding(4)
      var blurTex2Sampler: sampler;
      @group(1) @binding(5)
      var blurTex2: texture_2d<f32>;
      @group(1) @binding(6)
      var blurTex3Sampler: sampler;
      @group(1) @binding(7)
      var blurTex3: texture_2d<f32>;
      @group(1) @binding(8)
      var blurTex4Sampler: sampler;
      @group(1) @binding(9)
      var blurTex4: texture_2d<f32>;
      @group(1) @binding(10)
      var blurTex5Sampler: sampler;
      @group(1) @binding(11)
      var blurTex5: texture_2d<f32>;
      @group(2) @binding(0)
      var<uniform> global: UniformData;

      const bloomFactors = array<f32,5>(1.0, 0.800000011920929, 0.6000000238418579, 0.4000000059604645, 0.20000000298023224);
     
      fn lerpBloomFactor(factor: f32) -> f32 {
          var mirrorFactor: f32 = (1.2000000476837158 - factor);
          return mix(factor, mirrorFactor, global.bloomRadius);
      }

      fn main1() {
    
          return;
      } 

      @fragment
      fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
          var uv: vec2<f32> = fragUV;
          uv.y = (1.0 - uv.y);
        
          let e38: f32 = lerpBloomFactor(bloomFactors[0]);
          let e46: vec4<f32> = textureSample(blurTex1, blurTex1Sampler, uv);
          let e52: f32 = lerpBloomFactor(bloomFactors[1]);
          let e60: vec4<f32> = textureSample(blurTex2, blurTex2Sampler, uv);
          let e67: f32 = lerpBloomFactor(bloomFactors[2]);
          let e75: vec4<f32> = textureSample(blurTex3, blurTex3Sampler, uv);
          let e82: f32 = lerpBloomFactor(bloomFactors[3]);
          let e90: vec4<f32> = textureSample(blurTex4, blurTex4Sampler, uv);
          let e97: f32 = lerpBloomFactor(bloomFactors[4]);
          let e105: vec4<f32> = textureSample(blurTex5, blurTex5Sampler, uv);
          o_Target = ((((((((e38 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[0], 1.0)) * e46) + ((e52 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[1], 1.0)) * e60)) + ((e67 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[2], 1.0)) * e75)) + ((e82 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[3], 1.0)) * e90)) + ((e97 * vec4<f32>(array<vec3<f32>,5>(vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, 1.0, 1.0))[4], 1.0)) * e105))));
          
          let baseColor: vec4<f32> = textureSample(baseMap, baseMapSampler, uv);
          
          var bloomLight = global.bloomStrength * o_Target.rgb;

          bloomLight = getHDRColor(bloomLight.rgb,global.exposure);
          bloomLight = LinearToGammaSpace(bloomLight);

          o_Target =  baseColor + vec4<f32>(bloomLight * global.tintColor.rgb, baseColor.a) ;
          o_Target.a = min(o_Target.a,1.0);
          return FragmentOutput(o_Target);
      }
  `);let En=`
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;class Ur{}o(Ur,"sky_vs_frag_wgsl",`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(0) fragUV: vec2<f32>,
      @location(1) vWorldPos: vec4<f32>,
      @location(2) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(0) position: vec3<f32>,
      @location(1) normal: vec3<f32>,
      @location(2) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = globalUniform.viewMat * modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;

      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `),o(Ur,"sky_fs_frag_wgsl",`
    #include "GlobalUniform"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        #if USE_WORLDPOS
          @location(1) o_Position: vec4<f32>,
        #endif
        #if USEGBUFFER
          @location(2) o_Normal: vec4<f32>,
          @location(3) o_Material: vec4<f32>
        #endif
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
        textureColor = LinearToGammaSpace(textureColor);
        #endif
        let o_Target: vec4<f32> =vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        var normal_rgba8unorm = (vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));

        return FragmentOutput(
          o_Target,
          #if USE_WORLDPOS
              vWorldPos,
          #endif
          #if USEGBUFFER
              vec4<f32>(normal_rgba8unorm,0.0),
              vec4<f32>(0.0,1.0,0.0,0.0)
          #endif
        );
    }
    `);let Bn=`
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const LUMEN = 10.764;



fn calcAttenuation( d : f32 ,  falloffStart : f32 ,  falloffEnd : f32)-> f32
{
    // Linear falloff.
    return saturate((falloffEnd-d) / (falloffEnd - falloffStart));
}

fn directLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = -normalize(light.direction.xyz) ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var att = light.intensity / LUMEN ;
      if(light.castShadow>=0){
          #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  att *= shadowStrut.directShadowVisibility[j] ; 
                }
            }
          #endif
      }

      #if USE_LAMBERT
        color = vec3<f32>(1.0,1.0,1.0) ;
      #endif 

      #if USE_BRDF
        color = simpleBRDF(albedo,N,V,L,att,lightColor,roughness,metallic) ;
      #endif 
    #endif 
    return color;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) * light.intensity / LUMEN;
        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
              // atten *= shadowStrut.pointShadows[light.castShadow] ; 
              for (var j: i32 = 0; j < 8; j += 1) {
                  if(j == light.castShadow){
                    atten *= shadowStrut.pointShadows[j] ; 
                  }
              }
            #endif
        }

        #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
        #endif

        var lightColor = light.lightColor.rgb  ;
        lightColor = getHDRColor(lightColor , light.linear )  ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,1.0,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic))  ;
        #endif 
    } 
    return color ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.1) * light.intensity / LUMEN;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  atten *= shadowStrut.pointShadows[j] ; 
                }
            }
          #endif
        }

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        lightColor = getHDRColor(lightColor , light.linear ) ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,0.5,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic)) ;
        #endif 
    }
    return  color ;
}
`,Bs=`
var<private> PI: f32 = 3.14159265359;


fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2<f32>
  {
    var dir = vec3<f32>(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2(u, v);
  }

    // Returns \xB11
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth : f32, near:f32, far:f32) -> f32 {
      let pt = pow((far / near),depth);
      return near * pt / (far / near);
    }

   


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }
`,Tn=`
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,
          ao: f32,

          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,
          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,
          clearcoatColor: vec4<f32>,
          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `,Mn=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Dn=`
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;

        #if USE_WORLDPOS
            ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
        #endif

        #if USEGBUFFER
            var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
            normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
            ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
            ORI_FragmentOutput.material = vec4<f32>(1.0,1.0,0.0,1.0);
        #endif
    }

    fn debugFragmentOut(){

    }
`;class Or{static groupBindingAndFunctions(e,t){return`
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${e}) @binding(${t})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${e}) @binding(${t+1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${e}) @binding(${t+2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `}}class Le{static getMorphTargetShaderBinding(e,t){return`
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${e}) @binding(${t})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${e}) @binding(${t+1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${e}) @binding(${t+2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`}static getMorphTargetAttr(e){return`@location(${e}) vIndex: f32,`}static getMorphTargetCalcVertex(){return`
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `}}o(Le,"CsMain",`
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`);let Pn=`
    #if USE_MORPHTARGETS
    ${Le.getMorphTargetShaderBinding(3,0)}
    #endif

    #if USE_SKELETON
    ${Or.groupBindingAndFunctions(3,0)} 
    #endif

    struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
            @location(7) joints1: vec4<f32>,
            @location(8) weights1: vec4<f32>,
        #endif
        #elseif USE_MORPHTARGETS
            ${Le.getMorphTargetAttr(5)}
        #endif
    #elseif USE_SKELETON
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
        @location(6) joints1: vec4<f32>,
        @location(7) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        ${Le.getMorphTargetAttr(4)}
    #endif
    }

    struct VertexOutput {
    @location(0) varying_UV0: vec2<f32>,
    @location(1) varying_UV1: vec2<f32>,
    @location(2) varying_ViewPos: vec4<f32>,
    @location(3) varying_Clip: vec4<f32>,
    @location(4) varying_WPos: vec4<f32>,
    @location(5) varying_WNormal: vec3<f32>,
    @location(6) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(7) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(8) varying_Tangent: vec4<f32>,
    #endif

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_MORPHTARGETS
    ${Le.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #endif

    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
    #endif

    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`,Rn=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Ln=`
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`,Un=`
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    var<private> TIME: vec4<f32>;
    var<private> MOUSE: vec4<f32>;
    var<private> SCREEN: vec4<f32>;

    var<private> ProjectionParams: vec4<f32>;

    fn vertex_inline(vertex:VertexAttributes){
        TIME.x = globalUniform.frame;
        TIME.y = globalUniform.time;
        TIME.z = globalUniform.delta;

        MOUSE.x = globalUniform.mouseX;
        MOUSE.y = globalUniform.mouseY;

        SCREEN.x = globalUniform.windowWidth;
        SCREEN.y = globalUniform.windowHeight;

        ProjectionParams.x = globalUniform.near;
        ProjectionParams.y = globalUniform.far;
        ProjectionParams.z = 1.0 + 1.0 / globalUniform.far;

        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`,On=`
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "ColorPassFragmentOutput"
  #include "ShadingInput"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
    #if USE_WORLDPOS
      ORI_FragmentOutput.worldPos = ORI_VertexVarying.vWorldPos;
    #endif
    #if USEGBUFFER
      ORI_FragmentOutput.worldNormal = vec4<f32>(ORI_ShadingInput.Normal.rgb ,1.0); 
      ORI_FragmentOutput.material = vec4<f32>(0.0,1.0,0.0,0.0);
    #endif
    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    // var d1 = logDepth( ORI_VertexVarying.fragCoord.w , globalUniform.far);
    // ORI_FragmentOutput.out_depth = d1 ;

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2Depth(ORI_VertexVarying.fragCoord.z,globalUniform.near,globalUniform.far) ;
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    // var d1 = log2(ORI_VertexVarying.fragCoord.w + 1.0) * 2.0 / (log(f + 1.0) / 0.6931471805599453) * 0.5 ;
    // 2.0 / (Math.log(camera.far + 1.0) / Math.LN2)
    // ORI_FragmentOutput.out_depth = d1 ;

    return ORI_FragmentOutput ;
  }


`,Nn=`
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`,Fn=`
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`,kn=`
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;class lt{}o(lt,"Cascades",4);let Ts=`

  struct GlobalUniform {
    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,
    csmShadowBias: vec4<f32>,
    csmMatrix: array<mat4x4<f32>,${lt.Cascades}>,

    CameraPos: vec3<f32>,
    frame: f32,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,

    csmMargin:f32,
    notUsed1:f32,
    notUsed2:f32,
    notUsed3:f32
    
  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;
`,zn=`
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`,Xa=`
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`,Gn=`
  fn Pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn Pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }
`,Qn=`
    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q1perp = cross( q1, N );
        var q0perp = cross( N, q0 );

        #if USE_TANGENT
            var T = ORI_VertexVarying.TANGENT.xyz ;
        #else
            var T = q1perp * st0.x + q0perp * st1.x;
        #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }
        #if USE_TANGENT
            scale = scale * ORI_VertexVarying.TANGENT.w ;
        #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`,Vn=`
    struct FragmentVarying {
        @location(0) fragUV0: vec2<f32>,
        @location(1) fragUV1: vec2<f32>,
        @location(2) viewPosition: vec4<f32>,
        @location(3) fragPosition: vec4<f32>,
        @location(4) vWorldPos: vec4<f32>,
        @location(5) vWorldNormal: vec3<f32>,
        @location(6) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(7) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(8) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`,Wa=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        #endif
        #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        #endif

        #if USE_OUTDEPTH
            @builtin(frag_depth) out_depth: f32
        #endif
    };
`,Hn=`
    struct ShadingInput{
        BaseColor:vec4<f32>,
        Roughness:f32,
        Metallic:f32,
        Specular:f32,
        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,
        Normal:vec3<f32>,
        Tangent:vec4<f32>,
        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,
        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32
    }
`,Yn=`
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`,Xn=`
    #if USE_SHADOWMAPING
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    #endif

    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    struct ShadowStruct{
      directShadowVisibility: array<f32, 8>,
      pointShadows: array<f32, 8>,
    }

    var<private>shadowStrut: ShadowStruct;

    struct ShadowBuffer{
      nDirShadowStart: i32,
      nDirShadowEnd: i32,
      nPointShadowStart: i32,
      nPointShadowEnd: i32,
      shadowLights:array<u32,16>
    }

    #if DEBUG_CLUSTER
        @group(2) @binding(6) var<storage,read> shadowBuffer: ShadowBuffer;
    #else
        @group(2) @binding(5) var<storage,read> shadowBuffer: ShadowBuffer;
    #endif

    fn useShadow(){
        shadowStrut.directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        shadowStrut.pointShadows = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        directShadowMaping(globalUniform.shadowBias);
        pointShadowMapCompare(globalUniform.pointShadowBias);
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${lt.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {
      #if USE_SHADOWMAPING
        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= shadowBuffer.nDirShadowStart && i < shadowBuffer.nDirShadowEnd ){
            let ldx = shadowBuffer.shadowLights[i];
            var light = lightBuffer[ldx];
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm];
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            shadowStrut.directShadowVisibility[i] = visibility;
          }
        }
      #endif
    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      #if USE_SHADOWMAPING
        var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
        var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
        varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
        if (varying_shadowUV.x <= 1.0
          && varying_shadowUV.x >= 0.0
          && varying_shadowUV.y <= 1.0
          && varying_shadowUV.y >= 0.0
          && shadowPosTmp.z <= 1.0
          && shadowPosTmp.z >= 0.0)
        {
          visibility = 0.0;
          isOutSideArea = 0.0;
          var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
          var totalWeight = 0.0;
          var NoL = abs(dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(light.direction)));
          var bias = shadowBias / max(NoL, 0.000001);
          for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
              var offset = vec2<f32>(f32(x), f32(y)) * uvOnePixel;
              
              // visibility += textureSampleCompare(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, shadowPos.z - bias);
              var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, 0);
              if ((shadowPos.z - bias ) < depth) {
                visibility += 1.0 ;//* dot(offsetDir, dir.xyz);
              }
              totalWeight += 1.0;
            }
          }
          visibility /= totalWeight;
          visibility += 0.001;
        }
      #endif
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= shadowBuffer.nPointShadowStart && i < shadowBuffer.nPointShadowEnd ){
          let ldx = shadowBuffer.shadowLights[i];
          let light = lightBuffer[ldx] ;

          #if USE_SHADOWMAPING
          let lightPos = light.position.xyz;
          var shadow = 0.0;
          let frgToLight = worldPos - lightPos.xyz;
          var dir: vec3<f32> = normalize(frgToLight);
          var len = length(frgToLight);
          var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
          let samples = 4.0;
          for (var x: f32 = -offset; x < offset; x += offset / (samples * 0.5)) {
            for (var y: f32 = -offset; y < offset; y += offset / (samples * 0.5)) {
              for (var z: f32 = -offset; z < offset; z += offset / (samples * 0.5)) {
                let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
            }
          }
          shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
          #endif
  
          #if USE_SOFT_SHADOW
          let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
          let sampleRadies = globalUniform.shadowSoft;
          let samples = 20;
          for (var j: i32 = 0; j < samples; j += 1) {
            let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
            var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
            depth *= globalUniform.far;
            if ((len - bias) > depth) {
              shadow += 1.0 * dot(offsetDir, dir.xyz);
            }
          }
          shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
          var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
          depth *= globalUniform.far;
          if ((len - bias) > depth) {
            shadow = 1.0;
          }
          #endif
  
          for (var j = 0; j < pointCount ; j+=1 ) {
              if(i32(light.castShadow) == j){
                shadowStrut.pointShadows[j] = 1.0 - shadow ;
              }
          }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
    var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
      vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
      vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
      vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
      vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
      vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
    );
    #endif
`,Wn=`
#include "IrradianceVolumeData_frag"
    fn pow3(  x : f32 ) -> f32
    {
        return x*x*x;
    }

    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<storage,read> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`,jn=`
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>,
        TangentChannel: vec3<f32>,
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L))  ;
        Context.NoV = saturate(dot(N, V))  ;
        Context.VoL = saturate(dot(V, L)) ;
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));

        // Context.NoL = max(dot(N, L),0.0);
        // Context.NoV = max(dot(N, V),0.0);
        // Context.VoL = max(dot(V, L),0.0) ;
        // Context.NoH = saturate(dot(N, H));
        // Context.VoH = max(dot(V, H),0.0);
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);

        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo , metallic);
        let D = DistributionGGX( Context.NoH , roughness);
        let G = GeometrySmith(Context.NoV,Context.NoL, roughness );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        let kS = F;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;
        var diffuse = kd * (albedo.rgb / PI ) ;
        let ambient = specular.rgb ;

        fragData.KD += kd;
        fragData.KS += F;

        var col = (diffuse + ambient) * Context.NoL * lightColor * att ;
        // var col = (diffuse + ambient) * Context.NoL * lightColor ;
        return (col.rgb ) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        var prefilteredColor: vec3<f32> = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        prefilteredColor = globalUniform.skyExposure * (prefilteredColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return prefilteredColor * (specularColor.rgb * envBRDF.x + saturate( 50.0 * specularColor.g ) * envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity / LUMEN ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   
`,qn=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor * ORI_ShadingInput.BaseColor.a ;
      fragData.Ao = ORI_ShadingInput.AmbientOcclusion ; 
      fragData.Roughness = clamp(ORI_ShadingInput.Roughness,0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
    //   fragData.V = normalize(globalUniform.cameraWorldMatrix[3].xyz - ORI_VertexVarying.vWorldPos.xyz) ;

      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

      #if USE_TANGENT
        fragData.TangentChannel = vec3<f32>(ORI_VertexVarying.TANGENT.w);// ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
        let light = getLight(i32(i));

        switch (light.lightType) {
          case PointLightType: {
            specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
            specColor += directLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
          }
          case SpotLightType: {
            specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
      }
      fragData.LightChannel = specColor ;


      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let env =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = env ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   //Reduce the reflection coefficient of non-metallic materials     
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );// materialUniform.materialF0.a - materialUniform.materialF0.a * fragData.Metallic ;
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   //Controlling Fresnel and metallic reflections
      var iblSpecularResult = surfaceReduction*env*fresnelLerp ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);     //Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb ;
      //***********indirect-ambient part********* 
      let sunLight = lightBuffer[0] ;
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05) ;
      // let test = indirectResult ;

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
      #endif
      
      // ORI_FragmentOutput.color = vec4<f32>(ORI_FragmentOutput.color.xyz,fragData.Albedo.a) ;
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif

      #if USEGBUFFER
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      ORI_FragmentOutput.color = vec4<f32>(LinearToGammaSpace(color.rgb),fragData.Albedo.a) ;

      // var iblSpecularResult = surfaceReduction*env*fresnelLerp ;
      // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(test),fragData.Albedo.a) ;
  }

  `,Kn=`
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatRoughness;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , ior:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatStrength:f32, clearCoatPerceptualRoughness:f32 , att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor * factor;

        let H = normalize(-V + L);
        let R = 2.0 * dot( -V , N ) * N + V ;
        let LoH = dot(L,H);
        let NoV = max(dot(N,-V),0.0);
        let NoL = max(dot(N,L),0.0);
        let NoH = max(dot(N,H),0.00001);

        let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(0.0) , clearCoatRoughness ) ;
        var Fd = clearCoatColor / 3.1415926 ;
        let F0 = IORToF0(ior) ;
        // clear coat BRDF
        var Dc = D_GGX(NoH,clearCoatRoughness);
        var Vc = V_Kelemen(LoH) * NoL;
        var Fc = F_Schlick( vec3<f32>(F0) , 1.0, NoV) * materialUniform.clearcoatFactor;
        var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        let oneMinusFc  = 1.0 - Fc;
        let brdfSpecular = ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att ; 
        var iblSpecular = vec3<f32>(brdfSpecular);
        iblSpecular += approximateSpecularIBL(vec3<f32>(1.0),clearCoatRoughness,R, NoV) * Fc ;
        return vec3<f32>(mix(baseColor,iblSpecular,materialUniform.clearcoatWeight));
    }
    #endif
`,Jn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`,Zn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_ARMC
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    #endif

    #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aomapMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv ) ;
        ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb*ORI_ShadingInput.BaseColor.w ) * materialUniform.baseColor.rgb,ORI_ShadingInput.BaseColor.w*materialUniform.baseColor.a)  ;
        #if USE_ALPHACUT
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        #if USE_SHADOWMAPING
            useShadow();
        #endif

        #if USE_ARMC
            var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;

            ORI_ShadingInput.AmbientOcclusion = maskTex.r * materialUniform.ao ; 

            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #endif

            ORI_ShadingInput.Roughness = maskTex.g * materialUniform.roughness ;
            ORI_ShadingInput.Metallic =  maskTex.b * materialUniform.metallic ;

        #elseif USE_MR
            var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #else
                ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ; 
            #endif

            ORI_ShadingInput.Roughness = maskTex.g * materialUniform.roughness ;
            ORI_ShadingInput.Metallic =  maskTex.b * materialUniform.metallic;
        #else
            ORI_ShadingInput.Roughness = materialUniform.roughness ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.AmbientOcclusion =  materialUniform.ao ;
            #if USE_AOTEX
                var aoMap = textureSample(aomapMap, aoMapSampler, uv );
                ORI_ShadingInput.AmbientOcclusion = mix(0.0,aoMap.r,materialUniform.ao) ;
            #endif
        #endif

        ORI_ShadingInput.Roughness = clamp(ORI_ShadingInput.Roughness,0.084,1.0);
        ORI_ShadingInput.Specular = 0.5 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;
        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);
        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;
        // Normal.y = 1.0 - Normal.y ;
        // let normal = unPackNormal(Normal,1.0,materialUniform.normalScale) ;
        let normal = unPackNormal(Normal,materialUniform.normalScale) ;  
        ORI_ShadingInput.Normal = normal ;

        BxDFShading();
    }
`,$n=`
#include "ClusterDebug_frag" 

        fn debugPosition(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(ORI_VertexVarying.vWorldPos.w ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
            // ORI_FragmentOutput.color = vec4<f32>(0.2,0.2,0.2,1.0);
        }

        fn debugAmbient(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Irradiance * fragData.Albedo.rgb,1.0);
        }
        
        fn debugEmissive(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.TangentChannel),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`,el=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`,tl=`
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(0) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
          let id = u32(index) ;
          let worldMatrix = models.matrix[id];

          let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;

        //   let pos = worldMatrix[3].xy ;

          let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;

          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0)))  ;// / windowSize * size - offset ;

          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`,il=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`,rl=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,sl=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Xf=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array ;

    struct MaterialData{
        index:f32;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
    
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,ja=`
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        // var newColor = color * (  1.0 / 255.0 ) ;
        return color * pow(2.4, exposure) ;
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r, 0.416666667);
        linRGB.g = pow(linRGB.g, 0.416666667);
        linRGB.b = pow(linRGB.b, 0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }
`,al=`
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`;class N{static init(){N.register("MathShader",Bs),N.register("FastMathShader",Gn),N.register("MatrixShader",Sc),N.register("GlobalUniform",Ts),N.register("WorldMatrixUniform",Xa),N.register("NormalMap_frag",Qn),N.register("LightingFunction_frag",Bn),N.register("PhysicMaterialUniform_frag",Tn),N.register("UnLitMaterialUniform_frag",Mn),N.register("VideoUniform_frag",Rn),N.register("InstanceUniform",zn),N.register("Inline_vert",Un),N.register("VertexAttributes_vert",Pn),N.register("Common_vert",Nn),N.register("Common_frag",On),N.register("FragmentVarying",Vn),N.register("ColorPassFragmentOutput",Wa),N.register("ClusterLight",_c),N.register("ShadingInput",Hn),N.register("IESProfiles_frag",Yn),N.register("ShadowMapping_frag",Xn),N.register("Irradiance_frag",Wn),N.register("IrradianceVolumeData_frag",Ln),N.register("BrdfLut_frag",Fn),N.register("EnvMap_frag",kn),N.register("ColorUtil_frag",ja),N.register("ColorUtil",ja),N.register("BRDF_frag",jn),N.register("BxDF_frag",qn),N.register("UnLit_frag",Dn),N.register("UnLit",tn),N.register("Clearcoat_frag",Kn),N.register("LitShader",Jn),N.register("PBRLItShader",Zn),N.register("ClusterDebug_frag",En),N.register("BxdfDebug_frag",$n),N.register("GenerayRandomDir",al),N.register("Quad_vert_wgsl",tl),N.register("Quad_frag_wgsl",il),N.register("Quad_depth2d_frag_wgsl",rl),N.register("Quad_depthCube_frag_wgsl",sl),N.register("sky_vs_frag_wgsl",Ur.sky_vs_frag_wgsl),N.register("sky_fs_frag_wgsl",Ur.sky_fs_frag_wgsl),N.register("Bloom_Brightness_frag_wgsl",Ci.Bloom_Brightness_frag_wgsl),N.register("Bloom_blur_frag_wgsl",Ci.Bloom_blur_frag_wgsl),N.register("Bloom_composite_frag_wgsl",Ci.Bloom_composite_frag_wgsl),N.register("LambertShader",wc),N.register("QuadGlsl_vs",xc),N.register("QuadGlsl_fs",vc),N.register("SkyGBuffer_fs",gc),N.register("gbuffer_vs",$o),N.register("gbuffer_fs",$o),N.register("castPointShadowMap_vert",cc),N.register("shadowCastMap_frag",fc),N.register("shadowCastMap_vert",uc),N.register("directionShadowCastMap_frag",dc),N.register("ZPass_shader_vs",Ac),N.register("ZPass_shader_fs",mc)}static register(e,t){N[e.toLowerCase()]||(N[e.toLowerCase()]=t)}static getShader(e){return N[e.toLowerCase()],N[e.toLowerCase()]}}const Se=class{constructor(i=0,e=0){o(this,"x",0),o(this,"y",0),this.x=i,this.y=e}static getAngle(i,e){return Math.atan2(e.y-i.y,e.x-i.x)}static slerp(i,e,t){let r=new Se,s=i.dot(e);if(s<0&&(e.x=-e.x,e.y=-e.y,s=-s),s>.9995)return r.x=i.x+t*(e.x-i.x),r.y=i.y+t*(e.y-i.y),r;let a=Math.acos(s),n=Math.sin(a),l=Math.sin((1-t)*a)/n,h=Math.sin(t*a)/n;return r.x=l*i.x+h*e.x,r.y=l*i.y+h*e.y,r}static lerp(i,e,t){return Se.HELP_0.copyFrom(i),Se.HELP_1.copyFrom(e),Se.HELP_0.scale(t),Se.HELP_1.scale(1-t),new Se(Se.HELP_0.x+Se.HELP_1.x,Se.HELP_0.y+Se.HELP_1.y)}set(i=0,e=0){return this.x=i,this.y=e,this}distance(i){return Math.sqrt(Math.pow(this.x-i.x,2)+Math.pow(this.y-i.y,2))}add(i,e){return e=e||new Se,e.x=this.x+i.x,e.y=this.y+i.y,e}sub(i,e){return e=e||new Se,e.x=this.x-i.x,e.y=this.y-i.y,e}scale(i){return this.x=this.x*i,this.y=this.y*i,this}multiply(i,e){return e=e||new Se,e.x=this.x*i,e.y=this.y*i,e}multiplyScaler(i){return this.x*=i,this.y*=i,this}divide(i,e){return e=e||new Se,e.x=this.x/i,e.y=this.y/i,e}neg(i){return i||(i=new Se),i.x=-i.x,i.y=-i.y,i}abs(){return Math.sqrt(this.x*this.x+this.y*this.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}getAngle(i){return Math.atan2(i.y-this.y,i.x-this.x)}unt(i){i=i||new Se;let e=this.abs();return i.x=this.x/e,i.y=this.y/e,i}angleTo(i){let e=i.x-this.x,t=i.y-this.y;return Math.atan2(t,e)}equals(i){return Math.abs(this.x-i.x)<1e-6&&Math.abs(this.y-i.y)<1e-6}pal(i){let e=this.unt(),t=i.unt();return e.equals(t)?1:e.equals(t.neg())?-1:0}clone(){return new Se(this.x,this.y)}copyFrom(i){return this.x=i.x,this.y=i.y,this}dot(i){return this.x*i.x+this.y*i.y}normalize(){let i=this.abs();return this.x=this.x/i,this.y=this.y/i,this}addInPlace(i){return this.x+=i.x,this.y+=i.y,this}addScalar(i){return this.x+=i,this.y+=i,this}clampScalar(i,e){return this.x=Math.max(i,Math.min(e,this.x)),this.y=Math.max(i,Math.min(e,this.y)),this}};let Z=Se;o(Z,"HELP_0",new Se),o(Z,"HELP_1",new Se),o(Z,"ZERO",new Se(0,0)),o(Z,"SAFE_MAX",new Se(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),o(Z,"SAFE_MIN",new Se(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER));const Me=class{constructor(i=0,e=0,t=0,r=0){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",1),this.x=i,this.y=e,this.z=t,this.w=r}get width(){return this.z}get height(){return this.w}static crossVectors(i,e,t){t=t||new Me;var r=i.x,s=i.y,a=i.z,n=e.x,l=e.y,h=e.z;return t.x=s*h-a*l,t.y=a*n-r*h,t.z=r*l-s*n,t}static distance(i,e){let t=i.x-e.x,r=i.y-e.y,s=i.z-e.z,a=i.w-e.w;return Math.sqrt(t*t+r*r+s*s+a*a)}set(i,e,t,r){return this.x=i,this.y=e,this.z=t,this.w=r,this}multiplyScalar(i){return this.x*=i,this.y*=i,this.z*=i,this.w*=i,this}copyFrom(i){return this.x=i.x,this.y=i.y,this.z=i.z,this.w=i.w,this}clone(){return new Me(this.x,this.y,this.z,this.w)}};let j=Me;o(j,"X_AXIS",new Me(1,0,0)),o(j,"Y_AXIS",new Me(0,1,0)),o(j,"Z_AXIS",new Me(0,0,1)),o(j,"HELP_0",new Me),o(j,"HELP_1",new Me),o(j,"HELP_2",new Me),o(j,"EPSILON",1e-5),o(j,"HELP_3",new Me),o(j,"HELP_4",new Me),o(j,"HELP_5",new Me),o(j,"HELP_6",new Me),o(j,"ZERO",new Me),o(j,"ONE",new Me(1,1,1,1)),o(j,"LEFT",new Me(-1,0,0)),o(j,"RIGHT",new Me(1,0,0)),o(j,"UP",new Me(0,-1,0)),o(j,"DOWN",new Me(0,1,0)),o(j,"BACK",new Me(0,0,-1)),o(j,"FORWARD",new Me(0,0,1));var $e=(i=>(i[i.Number=0]="Number",i[i.Vector2=1]="Vector2",i[i.Vector3=2]="Vector3",i[i.Vector4=3]="Vector4",i[i.Color=4]="Color",i[i.Float32Array=5]="Float32Array",i))($e||{});class ${constructor(e){o(this,"size"),o(this,"memoryInfo"),o(this,"bindOnChange"),o(this,"_data"),o(this,"_type",$e.Number),o(this,"_x",0),o(this,"_y",0),o(this,"_z",0),o(this,"_w",0),this.data=e}get data(){return this._data}set data(e){this._data=e,this._type=$e.Number,e instanceof Z?(this.size=2,this._x=e.x,this._y=e.y,this._type=$e.Vector2):e instanceof g?(this.size=3,this._x=e.x,this._y=e.y,this._z=e.z,this._type=$e.Vector3):e instanceof j?(this.size=4,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._type=$e.Vector4):e instanceof z?(this.size=4,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this._type=$e.Color):e instanceof Float32Array?(this.size=e.length,this._type=$e.Float32Array):(this.size=1,this._x=e,this._data=e,this._type=$e.Number)}getColor(e){return e?e.copyFrom(this._data):e=this._data,e}get color(){return new z(this._data.r,this._data.g,this._data.b,this._data.a)}set color(e){(this._x!=e.r||this._y!=e.g||this._z!=e.b||this._w!=e.a)&&(this._data.r=e.r,this._data.g=e.g,this._data.b=e.b,this._data.a=e.a,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this.onChange())}get value(){return this._x}set value(e){this._x!=e&&(this._data=e,this._x=e,this.onChange())}get vector2(){return this._data}set vector2(e){(this._x!=e.x||this._y!=e.y)&&(this._data.x=e.x,this._data.y=e.y,this._x=e.x,this._y=e.y,this.onChange())}get vector3(){return this._data}set vector3(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._x=e.x,this._y=e.y,this._z=e.z,this.onChange())}get vector4(){return this._data}set vector4(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z||this._w!=e.w)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._data.w=e.w,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this.onChange())}onChange(){this.bindOnChange&&this.bindOnChange()}float32Array(e){this._data.set(e),this.onChange()}update(){switch(this._type){case $e.Number:this.memoryInfo.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this._data,!0);break;case $e.Vector2:this.memoryInfo.setVector2(0,this._data);break;case $e.Vector3:this.memoryInfo.setVector3(0,this._data);break;case $e.Vector4:this.memoryInfo.setVector4(0,this._data);break;case $e.Color:this.memoryInfo.setColor(0,this._data);break;case $e.Float32Array:this.memoryInfo.setFloat32Array(0,this._data);break}}}let Bt={clamp_to_edge:"clamp-to-edge",repeat:"repeat",mirror_repeat:"mirror-repeat"},Wf={zero:"zero",one:"one",src:"src",one_minus_src:"one-minus-src",src_alpha:"src-alpha",one_minus_src_alpha:"one-minus-src-alpha",dst:"dst",one_minus_dst:"one-minus-dst",dst_alpha:"dst-alpha",one_minus_dst_alpha:"one-minus-dst-alpha",src_alpha_saturated:"src-alpha-saturated",constant:"constant",one_minus_constant:"one-minus-constant"};const jf={srcFactor:"one",dstFactor:"zero",operation:"add"},qf={compare:"always",failOp:"keep",depthFailOp:"keep",passOp:"keep"};let vt={never:"never",less:"less",equal:"equal",less_equal:"less-equal",greater:"greater",not_equal:"not-equal",greater_equal:"greater-equal",always:"always"},ui={none:"none",front:"front",back:"back"},Nr={nearest:"nearest",linear:"linear"},Ms={point_list:"point-list",line_list:"line-list",line_strip:"line-strip",triangle_list:"triangle-list",triangle_strip:"triangle-strip"},G={r8unorm:"r8unorm",r8snorm:"r8snorm",r8uint:"r8uint",r8sint:"r8sint",r16uint:"r16uint",r16sint:"r16sint",r16float:"r16float",rg8unorm:"rg8unorm",rg8snorm:"rg8snorm",rg8uint:"rg8uint",rg8sint:"rg8sint",r32uint:"r32uint",r32sint:"r32sint",r32float:"r32float",rg16uint:"rg16uint",rg16sint:"rg16sint",rg16float:"rg16float",rgba8unorm:"rgba8unorm",rgba8unorm_srgb:"rgba8unorm-srgb",rgba8snorm:"rgba8snorm",rgba8uint:"rgba8uint",rgba8sint:"rgba8sint",bgra8unorm:"bgra8unorm",bgra8unorm_srgb:"bgra8unorm-srgb",rgb9e5ufloat:"rgb9e5ufloat",rgb10a2unorm:"rgb10a2unorm",rg11b10ufloat:"rg11b10ufloat",rg32uint:"rg32uint",rg32sint:"rg32sint",rg32float:"rg32float",rgba16uint:"rgba16uint",rgba16sint:"rgba16sint",rgba16float:"rgba16float",rgba32uint:"rgba32uint",rgba32sint:"rgba32sint",rgba32float:"rgba32float",stencil8:"stencil8",depth16unorm:"depth16unorm",depth24plus:"depth24plus",depth24plus_stencil8:"depth24plus-stencil8",depth32float:"depth32float",bc1_rgba_unorm:"bc1-rgba-unorm",bc1_rgba_unorm_srgb:"bc1-rgba-unorm-srgb",bc2_rgba_unorm:"bc2-rgba-unorm",bc2_rgba_unorm_srgb:"bc2-rgba-unorm-srgb",bc3_rgba_unorm:"bc3-rgba-unorm",bc3_rgba_unorm_srgb:"bc3-rgba-unorm-srgb",bc4_r_unorm:"bc4-r-unorm",bc4_r_snorm:"bc4-r-snorm",bc5_rg_unorm:"bc5-rg-unorm",bc5_rg_snorm:"bc5-rg-snorm",bc6h_rgb_ufloat:"bc6h-rgb-ufloat",bc6h_rgb_float:"bc6h-rgb-float",bc7_rgba_unorm:"bc7-rgba-unorm",bc7_rgba_unorm_srgb:"bc7-rgba-unorm-srgb",depth24unorm_stencil8:"depth24unorm-stencil8",depth32float_stencil8:"depth32float-stencil8"},Fr={uint8x2:"uint8x2",uint8x4:"uint8x4",sint8x2:"sint8x2",sint8x4:"sint8x4",unorm8x2:"unorm8x2",unorm8x4:"unorm8x4",snorm8x2:"snorm8x2",snorm8x4:"snorm8x4",uint16x2:"uint16x2",uint16x4:"uint16x4",sint16x2:"sint16x2",sint16x4:"sint16x4",unorm16x2:"unorm16x2",unorm16x4:"unorm16x4",snorm16x2:"snorm16x2",snorm16x4:"snorm16x4",float16x2:"float16x2",float16x4:"float16x4",float32:"float32",float32x2:"float32x2",float32x3:"float32x3",float32x4:"float32x4",uint32:"uint32",uint32x2:"uint32x2",uint32x3:"uint32x3",uint32x4:"uint32x4",sint32:"sint32",sint32x2:"sint32x2",sint32x3:"sint32x3",sint32x4:"sint32x4"},Kf={vertex:"vertex",instance:"instance"};class Ae{}o(Ae,"colorBufferTex_NAME","colorBufferTex"),o(Ae,"positionBufferTex_NAME","positionBufferTex"),o(Ae,"normalBufferTex_NAME","normalBufferTex"),o(Ae,"materialBufferTex_NAME","materialBufferTex"),o(Ae,"zBufferTexture_NAME","zBufferTexture"),o(Ae,"zPreDepthTexture_NAME","zPreDepthTexture"),o(Ae,"outTex_NAME","outTex");var Ue=(i=>(i[i.Default=1]="Default",i[i.IgnoreDepthPass=2]="IgnoreDepthPass",i[i.Sky=6]="Sky",i[i.Particle=10]="Particle",i[i.SkinnedMesh=16]="SkinnedMesh",i[i.MorphTarget=32]="MorphTarget",i[i.Terrain=64]="Terrain",i[i.UI=128]="UI",i))(Ue||{});class Tt{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)==t}}const kr=class{constructor(){o(this,"__refection"),o(this,"__size",0)}getValueType(){if(!this.__refection){let i=this;this.__refection=[];for(const e in i)if(!e.includes("__")){const t=i[e];let r={name:e,type:t.constructor.name};this.__refection.push(r)}}return this.__refection}static getValueSize(i){switch(i.constructor.name){case"Boolean":return 1*4;case"Number":return 1*4;case"f32":return 1*4;case"i32":return 1*4;case"u32":return 1*4;case"Float32Array":return i.byteLength*4;case"Vector2":return 2*4;case"Vector3":return 4*4;case"Vector4":return 4*4;case"Color":return 4*4;case"Array":let t=0;for(let r=0,s=i.length;r<s;r++)t+=kr.getValueSize(i[r]);return t}return 0}static Ref(i){return this.Get(i).getValueType()}static Get(i){let e=kr.__cacheStruct.get(i.prototype);return e||(e=new i,kr.__cacheStruct.set(i.prototype,e)),e}static GetSize(i){let e=this.Get(i);if(e.__size==0){for(const t in e)if(t.indexOf("__")==-1){const r=e[t];e.__size+=kr.getValueSize(r)}e.__size>4&&(e.__size=Math.ceil(e.__size/4)*4)}return e.__size}};let wi=kr;o(wi,"__cacheStruct",new Map);class ol{constructor(){o(this,"byteOffset"),o(this,"byteSize"),o(this,"offset",0),o(this,"dataBytes")}get x(){return this.dataBytes.getFloat32(0*Float32Array.BYTES_PER_ELEMENT,!0)}set x(e){this.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,e,!0)}get y(){return this.dataBytes.getFloat32(1*Float32Array.BYTES_PER_ELEMENT,!0)}set y(e){this.dataBytes.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,e,!0)}get z(){return this.dataBytes.getFloat32(2*Float32Array.BYTES_PER_ELEMENT,!0)}set z(e){this.dataBytes.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,e,!0)}get w(){return this.dataBytes.getFloat32(3*Float32Array.BYTES_PER_ELEMENT,!0)}set w(e){this.dataBytes.setFloat32(3*Float32Array.BYTES_PER_ELEMENT,e,!0)}setX(e){this.x=e}setXY(e,t){this.x=e,this.y=t}setXYZ(e,t,r){this.x=e,this.y=t,this.z=r}setXYZW(e,t,r,s){this.x=e,this.y=t,this.z=r,this.w=s}setVector2Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*2+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*2+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0)}}setVector3Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*3+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*3+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*3+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0)}}setVector4Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.w,!0)}}setColorArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.r,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.g,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.b,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.a,!0)}}setInt8(e,t=0){this.dataBytes.setInt8(t*Int8Array.BYTES_PER_ELEMENT,e)}getInt8(e=0){return this.dataBytes.getInt8(e*Int8Array.BYTES_PER_ELEMENT)}setInt16(e,t=0){this.dataBytes.setInt16(t*Int16Array.BYTES_PER_ELEMENT,e,!0)}getInt16(e=0){return this.dataBytes.getInt16(e*Int16Array.BYTES_PER_ELEMENT,!0)}setInt32(e,t=0){this.dataBytes.setInt32(t*Int32Array.BYTES_PER_ELEMENT,e,!0)}getInt32(e=0){return this.dataBytes.getInt32(e*Int32Array.BYTES_PER_ELEMENT,!0)}setFloat(e,t=0){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e,!0)}getFloat(e=0){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}setUint8(e,t=0){this.dataBytes.setUint8(t*Uint8Array.BYTES_PER_ELEMENT,e)}getUint8(e=0){return this.dataBytes.getUint8(e*Uint8Array.BYTES_PER_ELEMENT)}setUint16(e,t=0){this.dataBytes.setUint16(t*Uint16Array.BYTES_PER_ELEMENT,e,!0)}getUint16(e=0){return this.dataBytes.getUint16(e*Uint16Array.BYTES_PER_ELEMENT,!0)}setUint32(e,t=0){this.dataBytes.setUint32(t*Uint32Array.BYTES_PER_ELEMENT,e,!0)}getUint32(e=0){return this.dataBytes.getUint32(e*Uint32Array.BYTES_PER_ELEMENT,!0)}setArray(e,t){for(let r=0;r<t.length;r++){const s=t[r];this.dataBytes.setFloat32((e+r)*Float32Array.BYTES_PER_ELEMENT,s,!0)}}setFloat32Array(e,t){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Float32Array.BYTES_PER_ELEMENT,t.length).set(t)}setArrayBuffer(e,t){t instanceof Uint8Array?this.setUint8Array(e,t):t instanceof Uint16Array?this.setUint16Array(e,t):t instanceof Uint32Array?this.setUint32Array(e,t):t instanceof Int8Array?this.setInt8Array(e,t):t instanceof Int16Array?this.setInt16Array(e,t):t instanceof Int32Array?this.setInt32Array(e,t):t instanceof Float32Array&&this.setFloat32Array(e,t)}setInt8Array(e,t){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int8Array.BYTES_PER_ELEMENT).set(t)}setInt16Array(e,t){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int16Array.BYTES_PER_ELEMENT).set(t)}setInt32Array(e,t){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int32Array.BYTES_PER_ELEMENT).set(t)}setUint8Array(e,t){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint8Array.BYTES_PER_ELEMENT).set(t)}setUint16Array(e,t){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint16Array.BYTES_PER_ELEMENT).set(t)}setUint32Array(e,t){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint32Array.BYTES_PER_ELEMENT).set(t)}setData(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t,!0)}setVector2(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0)}setVector3(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0)}setVector4(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.w,!0)}setColor(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.r,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.g,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.b,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.a,!0)}getData(e){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}writeFloat(e){this.dataBytes.setFloat32(this.offset,e,!0),this.offset+=Float32Array.BYTES_PER_ELEMENT}writeInt8(e){this.dataBytes.setInt8(this.offset,e),this.offset+=Int8Array.BYTES_PER_ELEMENT}writeInt16(e){this.dataBytes.setInt16(this.offset,e,!0),this.offset+=Int16Array.BYTES_PER_ELEMENT}writeInt32(e){this.dataBytes.setInt32(this.offset,e,!0),this.offset+=Int32Array.BYTES_PER_ELEMENT}writeUint8(e){this.dataBytes.setUint8(this.offset,e),this.offset+=Uint8Array.BYTES_PER_ELEMENT}writeUint16(e){this.dataBytes.setUint16(this.offset,e,!0),this.offset+=Uint16Array.BYTES_PER_ELEMENT}writeUint32(e){this.dataBytes.setUint32(this.offset,e,!0),this.offset+=Uint32Array.BYTES_PER_ELEMENT}writeVector2(e){this.writeFloat(e.x),this.writeFloat(e.y)}writeVector3(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z)}writeVector4(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z),this.writeFloat(e.w)}writeRGBColor(e){this.writeFloat(e.r),this.writeFloat(e.g),this.writeFloat(e.b)}writeArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.writeFloat(r)}}writeFloat32Array(e){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt8Array(e){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt16Array(e){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt32Array(e){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint8Array(e){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint16Array(e){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint32Array(e){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}reset(){this.offset=0}destroy(){this.byteOffset=null,this.byteSize=null,this.offset=null,this.dataBytes=null}}class zr{constructor(){o(this,"shareDataBuffer"),o(this,"_byteOffset",0)}allocation(e){this.shareDataBuffer&&this.shareDataBuffer.byteLength<e?this._byteOffset=0:this.shareDataBuffer=new ArrayBuffer(e)}allocation_node(e){if(this._byteOffset+e>this.shareDataBuffer.byteLength)return console.error("memory not enough!",this._byteOffset,e,this.shareDataBuffer.byteLength),null;let t=new ol;return t.byteOffset=this._byteOffset,t.byteSize=e,t.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,t.byteSize),this._byteOffset+=t.byteSize,t}allocation_memory(e){return this._byteOffset+e.byteSize>this.shareDataBuffer.byteLength?(console.error("memory not enough!",this._byteOffset,e.byteSize,this.shareDataBuffer.byteLength),null):(e.byteOffset=this._byteOffset,e.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,e.byteSize),this._byteOffset+=e.byteSize,e)}reset(){this._byteOffset=0}destroy(e){this.shareDataBuffer=null,this._byteOffset=0}}class Jt{constructor(){o(this,"bufferType"),o(this,"buffer"),o(this,"memory"),o(this,"memoryNodes"),o(this,"seek"),o(this,"outFloat32Array"),o(this,"byteSize"),o(this,"usage"),o(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),o(this,"mapAsyncBuffersOutstanding",0),o(this,"mapAsyncReady"),o(this,"_readBuffer"),o(this,"_dataView"),o(this,"_readFlag",!1),this.mapAsyncReady=[],this.memory=new zr,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer)}debug(){}reset(e=!1,t=0,r){this.seek=0,this.memory.reset(),e&&this.createBuffer(this.usage,t,r)}setBoolean(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t?1:0)}setFloat(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t)}setInt8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setInt8(t)}setInt16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setInt16(t)}setInt32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setInt32(t)}setUint8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setUint8(t)}setUint16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setUint16(t)}setUint32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setUint32(t)}setVector2(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(2*4),this.memoryNodes.set(e,r)),r.setXY(t.x,t.y)}setVector3(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(3*4),this.memoryNodes.set(e,r)),r.setXYZ(t.x,t.y,t.z)}setVector4(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.x,t.y,t.z,t.w)}setVector4Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setVector4Array(t)}setColor(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.r,t.g,t.b,t.a)}setColorArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setColorArray(t)}setMatrix(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t.rawData)}setMatrixArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4*t.length),this.memoryNodes.set(e,r));for(let s=0;s<t.length;s++){const a=t[s];r.setFloat32Array(s*16,a.rawData)}}setArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setArray(0,t)}setFloat32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t)}setInt32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setInt32Array(0,t)}setUint32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setUint32Array(0,t)}setStruct(e,t,r,s){let a=wi.Ref(e);wi.GetSize(e);let n=t,l=this.memoryNodes.get(n);l.reset();let h=r;s&&(h=h[s]);for(let u=0;u<a.length;u++){const c=a[u];let f=h[c.name];switch(c.type){case"Boolean":l.writeFloat(f);break;case"Number":l.writeFloat(f);break;case"Float32Array":l.writeFloat32Array(f);break;case"Vector2":l.writeVector2(f);break;case"Vector3":l.writeVector3(f);break;case"Vector4":l.writeVector4(f);break;case"Color":l.writeRGBColor(f);break;case"Array":l.writeArray(f);break}}}setStructArray(e,t,r){let s=t.length;for(let a=0;a<s;a++){const n=t[a];this.setStruct(e,a,n,r)}}clean(){this._dataView.fill(0,0,this._dataView.length)}apply(){S.device.queue.writeBuffer(this.buffer,0,this.memory.shareDataBuffer)}applyMapAsync(){this.mapAsyncWrite(new Float32Array(this.memory.shareDataBuffer),this.memory.shareDataBuffer.byteLength/4)}mapAsyncWrite(e,t){let r=S.device;if(e.length>0){let s=null;for(;this.mapAsyncReady.length&&(s=this.mapAsyncReady.shift(),s.usedSize!=e.byteLength);)s.destroy(),this.mapAsyncBuffersOutstanding--,s=null;s||(s=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),s.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(s.getMappedRange(0,t*4)).set(a),s.unmap();const l=r.createCommandEncoder();l.copyBufferToBuffer(s,0,this.buffer,0,t*4),r.queue.submit([l.finish()]),s.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(s))}}destroy(e){this.memoryNodes&&this.memoryNodes.forEach(t=>{t.destroy()}),this.bufferType=null,this.seek=null,this.byteSize=null,this.usage=null,this.visibility=null,this.outFloat32Array=null,this.buffer&&this.buffer.destroy(),this.buffer=null,this.memory&&this.memory.destroy(),this.memory=null,this._readBuffer&&this._readBuffer.destroy()}createBuffer(e,t,r){let s=S.device;this.byteSize=t*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=s.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),r&&(this.memory.allocation_node(r.length*4).setArrayBuffer(0,r),this.apply())}createNewBuffer(e,t){let r=S.device,s=t*4,a=e;return this.buffer&&this.destroy(),r.createBuffer({size:s,usage:a,mappedAtCreation:!1})}createBufferByStruct(e,t,r){let s=wi.GetSize(t),a=s*r,n=S.device;this.buffer=n.createBuffer({size:a,usage:e,mappedAtCreation:!1}),this.memory.allocation(a);for(let l=0;l<r;l++){let h=l,u=this.memoryNodes.get(h);u||(u=this.memory.allocation_node(s),this.memoryNodes.set(h,u))}}readBuffer(){return this.outFloat32Array||(this.outFloat32Array=new Float32Array(this.memory.shareDataBuffer.byteLength/4)),this._readBuffer||(this._readBuffer=S.device.createBuffer({size:this.memory.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1})),this._readFlag||this.read(),this.outFloat32Array}async read(){this._readFlag=!0;let e=S.device.createCommandEncoder();e.copyBufferToBuffer(this.buffer,0,this._readBuffer,0,this.memory.shareDataBuffer.byteLength),S.device.queue.submit([e.finish()]),await this._readBuffer.mapAsync(GPUMapMode.READ);const t=this._readBuffer.getMappedRange();this.outFloat32Array.set(new Float32Array(t),0),this._readBuffer.unmap(),this._readFlag=!1}}var Mt=(i=>(i[i.IndicesGPUBuffer=0]="IndicesGPUBuffer",i[i.VertexGPUBuffer=1]="VertexGPUBuffer",i[i.UniformGPUBuffer=2]="UniformGPUBuffer",i[i.StorageGPUBuffer=3]="StorageGPUBuffer",i[i.ComputeGPUBuffer=4]="ComputeGPUBuffer",i[i.MaterialDataUniformGPUBuffer=5]="MaterialDataUniformGPUBuffer",i[i.StructStorageGPUBuffer=6]="StructStorageGPUBuffer",i))(Mt||{});class ge extends Jt{constructor(e,t=0,r){super(),this.bufferType=Mt.StorageGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r)}}class Dt extends Jt{constructor(e,t){super(),this.bufferType=Mt.UniformGPUBuffer,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,e,t)}genUniformNodes(){}}let Pt=function(i=16,e=16){var t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),r=[],s;if(e=e||t.length,i)for(s=0;s<i;s++)r[s]=t[0|Math.random()*e];else{var a;for(r[8]=r[13]=r[18]=r[23]="-",r[14]="4",s=0;s<36;s++)r[s]||(a=0|Math.random()*16,r[s]=t[s==19?a&3|8:a])}return r.join("")},nl=1e6,qa=function(){return nl++,nl},Jf=function(i,e){let t=0,r=i.length;for(t=0;t<r;t++)if(i[t]==e)return!0;return!1},Zf=function(i,e){let t=0,r=i.length;for(t=0;t<r;t++)if(i[t]==e)return t;return-1};class Ka{constructor(){o(this,"instanceID"),o(this,"shaderVariant"),o(this,"vsEntryPoint","main"),o(this,"fsEntryPoint","main"),o(this,"bindGroups"),o(this,"shaderReflection"),o(this,"defineValue"),o(this,"constValues"),o(this,"uniforms"),o(this,"_bufferDic"),o(this,"_shaderChange",!0),o(this,"_valueChange",!1),this.instanceID=Pt(),this.defineValue={},this.constValues={},this.uniforms={},this._bufferDic=new Map}noticeShaderChange(){this._shaderChange=!0}noticeValueChange(){this._valueChange=!0}setStorageBuffer(e,t){this._bufferDic.has(e)?this._bufferDic.set(e,t):(this._bufferDic.set(e,t),this.noticeBufferChange(e))}setStructStorageBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setUniformBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setDefine(e,t){(this.defineValue[e]==null||this.defineValue[e]!=t)&&(this.defineValue[e]=t,this.noticeValueChange(),this.noticeShaderChange()),this.defineValue[e]=t}hasDefine(e){return this.defineValue[e]!=null}deleteDefine(e){delete this.defineValue[e],this.noticeShaderChange()}setUniformFloat(e,t){this.uniforms[e]?this.uniforms[e].value=t:(this.uniforms[e]=new $(t),this.noticeValueChange())}setUniformVector2(e,t){this.uniforms[e]?this.uniforms[e].vector2=t:(this.uniforms[e]=new $(t),this.noticeValueChange())}setUniformVector3(e,t){this.uniforms[e]?this.uniforms[e].vector3=t:this.uniforms[e]=new $(t)}setUniformVector4(e,t){this.uniforms[e]?this.uniforms[e].vector4=t:this.uniforms[e]=new $(t)}setUniformColor(e,t){this.uniforms[e]?this.uniforms[e].color=t:this.uniforms[e]=new $(t)}setUniformArray(e,t){this.uniforms[e]?this.uniforms[e].float32Array(t):this.uniforms[e]=new $(t)}setUniform(e,t){this.uniforms[e]?this.uniforms[e].data=t:this.uniforms[e]=new $(t)}getUniform(e){return this.uniforms[e].data}noticeBufferChange(e){}destroy(e){}}var bi=(i=>(i[i.u32=1]="u32",i[i.f32=1]="f32",i[i["vec2<f32>"]=2]="vec2<f32>",i[i["vec3<f32>"]=3]="vec3<f32>",i[i["vec4<f32>"]=4]="vec4<f32>",i[i.float32=1]="float32",i[i.float32x2=2]="float32x2",i[i.float32x3=3]="float32x3",i[i.float32x4=4]="float32x4",i))(bi||{});let ll=[null,Fr.float32,Fr.float32x2,Fr.float32x3,Fr.float32x4];class ut{static parse(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new hl,e,t),e=this.parseAutoBindingForGroupX(e,1),e}static parseComputeShader(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new hl,e,t),e}static parsePreprocess(e,t,r){let s=t.indexOf("#");if(s==-1)return t;let a=t.substring(0,s),n=t.indexOf(`
`,t.lastIndexOf("#")),l=t.substring(s,n),h=t.substring(n);return a+this.parsePreprocessCommand(e,l,r)+h}static parseAutoBindingForGroupX(e,t){let r=0,s="",a=new Map;for(;r<e.length;){let n=e.indexOf("@group(",r);if(n==-1){s+=e.substring(r);break}let l=e.indexOf(")",n),h=Number.parseInt(e.substring(n+7,l));if(n=e.indexOf("@binding(",l),l=e.indexOf(")",n),s+=e.substring(r,n),h==t)if(a.has(h)){let u=a.get(h)+1;s+=`@binding(${u})`,a.set(h,u)}else s+="@binding(0)",a.set(h,0);else s+=e.substring(n,l+1);r=l+1}return s}static parsePreprocessCommand(e,t,r){let s="",a=t.split(`
`),n=[!1],l=[!1];for(let h=0;h<a.length;h++){let u=a[h],c=n[n.length-1];if(u.trim().indexOf("#")!=0){c||(s+=u+`
`);continue}let f=u.trim();if(f.indexOf("#if")!=-1){if(c&&n.length>1){n.push(c);continue}let d=f.substring(3).trim();c=!this.parseCondition(d,r),n.push(c),l.push(!c);continue}else if(f.indexOf("#elseif")!=-1||f.indexOf("#else")!=-1&&f.indexOf(" if")!=-1){if(l[l.length-1]){n.pop(),c=!0,n.push(c);continue}if(n.pop(),c=n[n.length-1],c&&n.length>1){n.push(c);continue}let p=f.substring(f.indexOf("if")+2).trim();p==""&&console.error(`preprocess command error, conditions missing: ${f}`),c=!this.parseCondition(p,r),n.push(c),l.push(!c);continue}else if(f.indexOf("#else")!=-1){n.pop(),c&&n.length>1&&n[n.length-1]?n.push(c):n.push(!c);continue}else if(f.indexOf("#endif")!=-1){n.pop(),l.pop();continue}else if(f.indexOf("#include")!=-1){let d="",p=f.charAt(f.length-1);if(p==">"?d=this.extract(f,"<",">"):d=this.extract(f,p,p),!e.includeMap.has(d)){e.includeMap.set(d,!0);let m=N.getShader(d);if(!m)throw`${f} error: '${d}' not found`;m=this.filterComment(m),m=this.parsePreprocess(e,m,r),s+=m+`\r
`}continue}else if(f.indexOf("#define ")!=-1){let d=f.substring(f.indexOf("#define ")+8).trim(),p=d.indexOf(" "),m=d,_="";p!=-1&&(m=d.substring(0,p).trim(),_=d.substring(p+1).trim()),r[m]=_;continue}else throw"nonsupport: "+f}return s}static parseCondition(e,t){let r=t[e];return r==null?!1:r==!0||r!=0}static filterComment(e){let t="",r=!0,s=!0;for(let a=0;a<e.length;){let n=r?e.indexOf("//",a):-1,l=s?e.indexOf("/*",a):-1;if(n==-1&&l==-1){t+=e.substring(a);break}r=n!=-1,s=l!=-1,n!=-1&&l!=-1&&(n<l?l=-1:n=-1),n!=-1?(l=e.indexOf(`
`,n),t+=e.substring(a,n),a=l!=-1?l:e.length):l!=-1&&(n=e.indexOf("*/",l),t+=e.substring(a,l),a=n+2)}return t}static extract(e,t,r){let s=e.indexOf(t)+t.length,a=e.indexOf(r,s);return e.substring(s,a).trim()}}class hl{constructor(){o(this,"includeMap",new Map)}}const Ds=class{constructor(){o(this,"attributes",[]),o(this,"vs_variables",[]),o(this,"fs_variables",[]),o(this,"cs_variables",[]),o(this,"groups",[]),o(this,"variables",{}),o(this,"useSplit",!1)}static parser(i,e){e.shaderReflection||(e.shaderReflection=new Ds),i.indexOf("@vertex")!=-1?(e.shaderReflection.attributes=this.parserVertexOld(i),e.shaderReflection.vs_variables=this.parserVariables(i)):i.indexOf("@fragment")!=-1?e.shaderReflection.fs_variables=this.parserVariables(i):i.indexOf("@compute")!=-1&&(e.shaderReflection.cs_variables=this.parserVariables(i))}static parser2(i,e){e.shaderReflection||(e.shaderReflection=new Ds);let t=e.shaderReflection;i.indexOf("@vertex")!=-1?(t.attributes=this.parserVertex(e.vsEntryPoint,i),t.vs_variables=this.parserVariables(i)):i.indexOf("@fragment")!=-1?t.fs_variables=this.parserVariables(i):i.indexOf("@compute")!=-1&&(t.cs_variables=this.parserVariables(i)),i.indexOf("splitTexture")!=-1&&(t.useSplit=!0)}static combineShaderReflectionVarInfo(i,e){for(const t of e){i.groups[t.group]||(i.groups[t.group]=[]);let r=t;if(i.groups[t.group][t.binding]){let s=i.groups[t.group][t.binding],a=t;if(s.dataFields)for(let n=0;n<s.dataFields.length;n++)s.dataFields[n];if(a.dataFields)for(let n=0;n<a.dataFields.length;n++)a.dataFields[n]}i.groups[t.group][t.binding]=r,i.variables[t.varName]=r}}static final(i){let e=i.shaderReflection;this._shaderReflectionMap.set(i.shaderVariant,e),this.combineShaderReflectionVarInfo(e,e.vs_variables),this.combineShaderReflectionVarInfo(e,e.fs_variables)}static getShaderReflection2(i,e){if(e.shaderVariant!=null){let t=ut.parse(i,e.defineValue);Ds.parser2(t,e)}}static poolGetReflection(i){return this._shaderReflectionMap.get(i)}static genShaderVar(i){let e=`${i.vs}${i.fs}${i.compute}`;e+="|";for(const t in i.uniforms)e+=t+":";e+="|";for(const t in i.constValues)e+=t+":",e+=i.constValues[t];e+="|";for(const t in i.defines)e+=t+":",e+=i.defines[t];e+="|";for(const t in i.shaderState)e+=t+":",e+=i.shaderState[t]+";";return e}static genShaderVariant(i){let e="";for(const t in i.uniforms)e+=t+":";e+="|";for(const t in i.constValues)e+=t+":",e+=i.constValues[t];e+="|";for(const t in i.defineValue)e+=t+":",e+=i.defineValue[t];return e}static genRenderShaderVariant(i){let e=`RenderShader(${i.vsName},${i.fsName})`;e+="|",e+=this.genShaderVariant(i),e+="|";for(const t in i.shaderState)e+=t+":",e+=i.shaderState[t]+";";return e}static genComputeShaderVariant(i){let e=`ComputeShader(${i.instanceID})`;return e+="|",e+=this.genShaderVariant(i),e}combine(i){let e=i.shaderReflection,t=i.defines,r={};for(let a=0;a<this.attributes.length;a++){let n=this.attributes[a];t[n.name]&&(r[n.name]=n)}let s=e.attributes.length;for(let a=0;a<s;a++){const n=e.attributes[a];if(!r[n.name])this.attributes.push(n);else{let l=r[n.name];l.location==n.location&&l.name!=n.name&&console.log("location must same!")}}}static parserVariables(i){let e=0,t=[];for(;e<i.length;){let r=i.indexOf("@group(",e);if(r<0)break;let s=i.indexOf(";",r);e=s;let a=i.substring(r,s),n=this.extract(a,"@group(",")"),l=this.extract(a,"@binding(",")"),h="",u="var";a.indexOf("var<")!=-1?(h=this.extract(a,">",":"),u=this.extract(a,"var<",">").replace(",","-").replaceAll(" ","")):h=this.extract(a,"var",":");let c=a.substring(a.lastIndexOf(":")+1).trim(),f={group:0,binding:0,varType:"",varName:"",dataType:"",dataIsBuiltinType:!0,dataFields:null};f.group=Number.parseInt(n),f.binding=Number.parseInt(l),f.varType=u,f.varName=h,f.dataType=c,f.dataIsBuiltinType=this.isBuiltinTypes(f.dataType),f.dataIsBuiltinType||(f.dataFields=this.parserStructFields(i,f.dataType)),t.push(f)}return t}static extract(i,e,t){let r=i.indexOf(e)+e.length,s=i.indexOf(t,r);return i.substring(r,s).trim()}static isBuiltinTypes(i){switch(i){case"i32":return!0;case"u32":return!0;case"f32":return!0;default:let e=i.indexOf("<");if(e!=-1)switch(i.substring(0,e)){case"vec2":return!0;case"vec3":return!0;case"vec4":return!0;case"mat3":return!0;case"mat4":return!0;case"array":return this.isBuiltinTypes(i.substring(e+1,i.lastIndexOf(">")))}break}return!1}static parserStructFields(i,e){let t=[],r=0;for(;r<i.length;){let s=i.indexOf("struct ",r);if(s<0)break;let a=i.indexOf("{",s);if(r=a,i.substring(s+6,a).trim()===e){s=i.indexOf("{",s),a=i.indexOf("}",s);let h=i.substring(s+1,a).split(",");for(let u of h){let c=u.indexOf(":");if(c!=-1){let f={name:u.substring(0,c).trim(),type:u.substring(c+1).trim()};t.push(f)}}break}}return t}static parserVertexOld(i){let e=[],r=i.split("fn main(")[1].split("->")[0],s=r.split("@");if(s&&s.length>1)for(let n=1;n<s.length;n++){let h=s[n].replace(/\s*$/g,"");h=h.replaceAll(",",""),h=h.replaceAll(`
`,""),h=h.replaceAll("  "," "),this.parserAttribute(h,e)}else{var a=r.split(":")[1];a=a.replaceAll("  ",""),a=a.replaceAll(" ",""),a=a.replaceAll(")",""),a=i.split(`struct ${a}`)[1];let l=a.indexOf("{"),h=a.indexOf("}");a=a.slice(l,h),s=a.split("@");for(let u=1;u<s.length;u++){let f=s[u].replace(/\s*$/g,"");f=f.replaceAll(`
`,""),f=f.split(",")[0],f=f.replaceAll("  "," "),this.parserAttribute(f,e)}}return e}static parserVertex(i,e){let t=[],s=e.split(`fn ${i}(`)[1].split("->")[0],a=s.split("@");if(a&&a.length>1)for(let l=1;l<a.length;l++){let u=a[l].replace(/\s*$/g,"");u=u.replaceAll(",",""),u=u.replaceAll(`
`,""),u=u.replaceAll("  "," "),this.parserAttribute(u,t)}else{var n=s.split(":")[1];n=n.replaceAll("  ",""),n=n.replaceAll(" ",""),n=n.replaceAll(")",""),n=e.split(`struct ${n}`)[1];let h=n.indexOf("{"),u=n.indexOf("}");n=n.slice(h,u),a=n.split("@");for(let c=1;c<a.length;c++){let d=a[c].replace(/\s*$/g,"");d=d.replaceAll(`
`,""),d=d.split(",")[0],d=d.replaceAll("  "," "),this.parserAttribute(d,t)}}return t}static parserAttribute(i,e){let t={name:"",group:0,location:0,type:"",valueType:"",value:0,size:0,format:"float32"};if(i.indexOf("builtin")!=-1){t.type="builtin";var r=i.match(/\((.+?)\)/g)[0];r=i.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),t.location=parseInt(r);let s=i.split(":");t.name=s[0].split(" ")[1],t.name=t.name.replaceAll("  "," "),t.name=t.name.replaceAll(" ",""),t.valueType=s[1],t.valueType=t.valueType.replaceAll("  "," "),t.valueType=t.valueType.replaceAll(" ",""),t.valueType=t.valueType.replaceAll("\r",""),t.valueType=t.valueType.replaceAll(")",""),t.valueType=t.valueType.replaceAll(")",""),t.size=bi[t.valueType],e.push(t)}else if(i.indexOf("location")!=-1){t.type="location";var r=i.match(/\((.+?)\)/g)[0];r=i.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),t.location=parseInt(r);let a=i.split(":");t.name=a[0].split(" ")[1],t.name=t.name.replaceAll("  "," "),t.name=t.name.replaceAll(" ",""),t.valueType=a[1],t.valueType=t.valueType.replaceAll("  "," "),t.valueType=t.valueType.replaceAll(" ",""),t.valueType=t.valueType.replaceAll("\r",""),t.valueType=t.valueType.replaceAll(")",""),t.valueType=t.valueType.replaceAll(")",""),t.size=bi[t.valueType],e.push(t)}t.format=ll[bi[t.valueType]]}};let ct=Ds;o(ct,"_shaderReflectionMap",new Map);class be extends Ka{constructor(e){super(),o(this,"entryPoint","CsMain"),o(this,"workerSizeX",1),o(this,"workerSizeY",0),o(this,"workerSizeZ",0),o(this,"_computePipeline"),o(this,"_csShaderModule"),o(this,"_destCS"),o(this,"_sourceCS"),o(this,"_storageTextureDic"),o(this,"_sampleTextureDic"),o(this,"_groupsShaderReflectionVarInfos"),o(this,"_groupCache",{}),this._sourceCS=e,ct.getShaderReflection2(e,this),this._storageTextureDic=new Map,this._sampleTextureDic=new Map}setStorageTexture(e,t){this._storageTextureDic.has(e)||this._storageTextureDic.set(e,t)}setSamplerTexture(e,t){this._sampleTextureDic.set(e,t)}compute(e){this._computePipeline||this.genComputePipeline(),e.setPipeline(this._computePipeline);for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,this.bindGroups[t]);this.workerSizeX&&this.workerSizeY&&this.workerSizeZ?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY,this.workerSizeZ):this.workerSizeX&&this.workerSizeY?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY):e.dispatchWorkgroups(this.workerSizeX)}createBufferBindGroup(e,t,r,s){let a=this._bufferDic.get(t);if(a){let n={binding:r,resource:{buffer:a.buffer,offset:0,size:a.memory.shareDataBuffer.byteLength}};s.push(n)}else console.error(`ComputeShader(${this.instanceID})`,`buffer ${t} is missing!`)}noticeBufferChange(e){let t=this._groupCache[e];t&&this.genGroups(t.groupIndex,t.infos,!0)}genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const s=t[e];let a=[];for(let l=0;l<s.length;++l){const h=s[l];if(h)switch(h.varType){case"uniform":case"storage-read":case"storage-read_write":this.createBufferBindGroup(e,h.varName,h.binding,a),this._groupCache[h.varName]={groupIndex:e,infos:t};break;case"var":if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let f={binding:h.binding,resource:c.gpuSampler};a.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let f={binding:h.binding,resource:c.gpuSampler_comparison};a.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture_storage")!=-1){let u=this._storageTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c),se.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture")!=-1){let u=this._sampleTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c),se.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}break;default:console.error("unprocessed type:",h.varType);break}}let n=S.device.createBindGroup({layout:this._computePipeline.getBindGroupLayout(e),entries:a});this.bindGroups[e]=n}}genComputePipeline(){this.preCompileShader(this._sourceCS),this.genReflection(),this._computePipeline=S.device.createComputePipeline({layout:"auto",compute:{module:this.compileShader(),entryPoint:this.entryPoint}}),this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroups=[];for(let t=0;t<e.groups.length;++t){let r=e.groups[t];this._groupsShaderReflectionVarInfos[t]=r,this.genGroups(t,this._groupsShaderReflectionVarInfos)}}preCompileShader(e){for(const t in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,t)){const r=this.constValues[t];e=e.replaceAll(`&${t}`,r.toString())}this._destCS=ut.parseComputeShader(e,this.defineValue)}compileShader(){let e=S.device.createShaderModule({label:`ComputeShader(${this.instanceID})`,code:this._destCS});return e.getCompilationInfo().then(t=>{t.messages.length>0&&console.log(this._destCS)}),this._csShaderModule=e,e}genReflection(){this.shaderVariant+=ct.genComputeShaderVariant(this);let e=ct.poolGetReflection(this.shaderVariant);e?this.shaderReflection=e:(ct.getShaderReflection2(this._destCS,this),ct.combineShaderReflectionVarInfo(this.shaderReflection,this.shaderReflection.cs_variables))}}class ft{static start(e){let t=this.profilerLabelMap.get(e);t||(t={lable:e,start:0,end:0,total:0,count:0,child:new Map},this.profilerLabelMap.set(e,t)),t.start=performance.now(),t.end=performance.now(),t.count=0,t.child.clear()}static end(e){let t=this.profilerLabelMap.get(e);t&&(t.end=performance.now(),t.total=t.end-t.start)}static countStart(e,t=""){let r=this.profilerLabelMap.get(e);if(r&&(r.count++,t!="")){let s=r.child.get(t);s||(s={lable:t,start:0,end:0,total:0,count:0}),s.start=performance.now(),s.end=performance.now(),s.count=0,r.child.set(t,s)}}static countEnd(e,t){let r=this.profilerLabelMap.get(e);if(r&&t!=""){let s=r.child.get(t);s||(s={lable:t,start:0,end:0,total:0,count:0}),s.end=performance.now(),s.total=s.end-s.start,s.count++}}static print(e){let t=this.profilerLabelMap.get(e);t&&console.log("performance",e,t.total+" ms")}}o(ft,"profilerLabelMap",new Map);const $f=`var Module=typeof Module!="undefined"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_NODE){var fs=require("fs");var nodePath=require("path");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:"utf8",((err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)}))};if(!Module["thisProgram"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\/g,"/")}arguments_=process.argv.slice(2);if(typeof module!="undefined"){module["exports"]=Module}process.on("uncaughtException",(ex=>{if(ex!=="unwind"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}}));quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};Module["inspect"]=()=>"[Emscripten Module object]"}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b)}var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="data:application/octet-stream;base64,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IAZBAmsiCiAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HgI2otAAAgDXI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgDEEQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAsgESAKayIGaiINayADSA0AIABBICACIA0gA0ECaiAHIAxBEGoiB2siBSAFQQJrIANIGyAFIAMbIglqIgMgBBAGIAAgCCALEAUgAEEwIAIgAyAEQYCABHMQBiAAIAcgBRAFIABBMCAJIAVrQQBBABAGIAAgCiAGEAUgAEEgIAIgAyAEQYDAAHMQBiADIAIgAiADSBshCQsgDEGwBGokACAJC7QCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsACw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtyAQN/IAAoAgAsAABBMGtBCk8EQEEADwsDQCAAKAIAIQNBfyEBIAJBzJmz5gBNBEBBfyADLAAAQTBrIgEgAkEKbCICaiABIAJB/////wdzShshAQsgACADQQFqNgIAIAEhAiADLAABQTBrQQpJDQALIAILkRQCE38BfkGHCSELIwBB0ABrIgUkACAFQYcJNgJMIAVBN2ohFSAFQThqIRACQAJAAkACQANAIAshCiAEIAxB/////wdzSg0BIAQgDGohDAJAAkACQCAKIgQtAAAiBgRAA0ACQAJAIAZB/wFxIgtFBEAgBCELDAELIAtBJUcNASAEIQYDQCAGLQABQSVHBEAgBiELDAILIARBAWohBCAGLQACIQcgBkECaiILIQYgB0ElRg0ACwsgBCAKayIEIAxB/////wdzIhZKDQcgAARAIAAgCiAEEAULIAQNBiAFIAs2AkwgC0EBaiEEQX8hDQJAIAssAAFBMGtBCk8NACALLQACQSRHDQAgC0EDaiEEIAssAAFBMGshDUEBIRELIAUgBDYCTEEAIQgCQCAELAAAIgZBIGsiC0EfSwRAIAQhBwwBCyAEIQdBASALdCILQYnRBHFFDQADQCAFIARBAWoiBzYCTCAIIAtyIQggBCwAASIGQSBrIgtBIE8NASAHIQRBASALdCILQYnRBHENAAsLAkAgBkEqRgRAAn8CQCAHLAABQTBrQQpPDQAgBy0AAkEkRw0AIAcsAAFBAnQgA2pBwAFrQQo2AgAgB0EDaiEGQQEhESAHLAABQQN0IAJqQYADaygCAAwBCyARDQYgB0EBaiEGIABFBEAgBSAGNgJMQQAhEUEAIQ4MAwsgASABKAIAIgRBBGo2AgBBACERIAQoAgALIQ4gBSAGNgJMIA5BAE4NAUEAIA5rIQ4gCEGAwAByIQgMAQsgBUHMAGoQKCIOQQBIDQggBSgCTCEGC0EAIQRBfyEJAn8gBi0AAEEuRwRAIAYhC0EADAELIAYtAAFBKkYEQAJ/AkAgBiwAAkEwa0EKTw0AIAYtAANBJEcNACAGLAACQQJ0IANqQcABa0EKNgIAIAZBBGohCyAGLAACQQN0IAJqQYADaygCAAwBCyARDQYgBkECaiELQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCSAFIAs2AkwgCUF/c0EfdgwBCyAFIAZBAWo2AkwgBUHMAGoQKCEJIAUoAkwhC0EBCyESA0AgBCEPQRwhByALIhQsAAAiBEH7AGtBRkkNCSAUQQFqIQsgBCAPQTpsakHPH2otAAAiBEEBa0EISQ0ACyAFIAs2AkwCQAJAIARBG0cEQCAERQ0LIA1BAE4EQCADIA1BAnRqIAQ2AgAgBSACIA1BA3RqKQMANwNADAILIABFDQggBUFAayAEIAEQJwwCCyANQQBODQoLQQAhBCAARQ0HCyAIQf//e3EiBiAIIAhBgMAAcRshCEEAIQ1BgAghEyAQIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAULAAAIgRBX3EgBCAEQQ9xQQNGGyAEIA8bIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAFKQNAIRdBgAgMBQtBACEEAkACQAJAAkACQAJAAkAgD0H/AXEOCAABAgMEGgUGGgsgBSgCQCAMNgIADBkLIAUoAkAgDDYCAAwYCyAFKAJAIAysNwMADBcLIAUoAkAgDDsBAAwWCyAFKAJAIAw6AAAMFQsgBSgCQCAMNgIADBQLIAUoAkAgDKw3AwAMEwtBCCAJIAlBCE0bIQkgCEEIciEIQfgAIQQLIBAhCiAFKQNAIhdCAFIEQCAEQSBxIQYDQCAKQQFrIgogF6dBD3FB4CNqLQAAIAZyOgAAIBdCD1YhDyAXQgSIIRcgDw0ACwsgBSkDQFANAyAIQQhxRQ0DIARBBHZBgAhqIRNBAiENDAMLIBAhBCAFKQNAIhdCAFIEQANAIARBAWsiBCAXp0EHcUEwcjoAACAXQgdWIQogF0IDiCEXIAoNAAsLIAQhCiAIQQhxRQ0CIAkgECAKayIEQQFqIAQgCUgbIQkMAgsgBSkDQCIXQgBTBEAgBUIAIBd9Ihc3A0BBASENQYAIDAELIAhBgBBxBEBBASENQYEIDAELQYIIQYAIIAhBAXEiDRsLIRMgFyAQEAwhCgsgEkEAIAlBAEgbDQ4gCEH//3txIAggEhshCAJAIAUpA0AiF0IAUg0AIAkNACAQIQpBACEJDAwLIAkgF1AgECAKa2oiBCAEIAlIGyEJDAsLAn9B/////wcgCSAJQf////8HTxsiDyIHQQBHIQgCQAJAAkAgBSgCQCIEQYAJIAQbIgoiBEEDcUUNACAHRQ0AA0AgBC0AAEUNAiAHQQFrIgdBAEchCCAEQQFqIgRBA3FFDQEgBw0ACwsgCEUNAQJAIAQtAABFDQAgB0EESQ0AA0AgBCgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0CIARBBGohBCAHQQRrIgdBA0sNAAsLIAdFDQELA0AgBCAELQAARQ0CGiAEQQFqIQQgB0EBayIHDQALC0EACyIEIAprIA8gBBsiBCAKaiEHIAlBAE4EQCAGIQggBCEJDAsLIAYhCCAEIQkgBy0AAA0NDAoLIAkEQCAFKAJADAILQQAhBCAAQSAgDkEAIAgQBgwCCyAFQQA2AgwgBSAFKQNAPgIIIAUgBUEIaiIENgJAQX8hCSAECyEGQQAhBAJAA0AgBigCACIKRQ0BAkAgBUEEaiAKECUiCkEASCIHDQAgCiAJIARrSw0AIAZBBGohBiAEIApqIgQgCUkNAQwCCwsgBw0NC0E9IQcgBEEASA0LIABBICAOIAQgCBAGIARFBEBBACEEDAELQQAhByAFKAJAIQYDQCAGKAIAIgpFDQEgBUEEaiAKECUiCiAHaiIHIARLDQEgACAFQQRqIAoQBSAGQQRqIQYgBCAHSw0ACwsgAEEgIA4gBCAIQYDAAHMQBiAOIAQgBCAOSBshBAwICyASQQAgCUEASBsNCEE9IQcgACAFKwNAIA4gCSAIIAQQJiIEQQBODQcMCQsgBSAFKQNAPAA3QQEhCSAVIQogBiEIDAQLIAQtAAEhBiAEQQFqIQQMAAsACyAADQcgEUUNAkEBIQQDQCADIARBAnRqKAIAIgAEQCACIARBA3RqIAAgARAnQQEhDCAEQQFqIgRBCkcNAQwJCwtBASEMIARBCk8NBwNAIAMgBEECdGooAgANASAEQQFqIgRBCkcNAAsMBwtBHCEHDAQLIAkgByAKayIPIAkgD0obIgkgDUH/////B3NKDQJBPSEHIA4gCSANaiIGIAYgDkgbIgQgFkoNAyAAQSAgBCAGIAgQBiAAIBMgDRAFIABBMCAEIAYgCEGAgARzEAYgAEEwIAkgD0EAEAYgACAKIA8QBSAAQSAgBCAGIAhBgMAAcxAGDAELC0EAIQwMAwtBPSEHC0GoMiAHNgIAC0F/IQwLIAVB0ABqJAAgDAt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAqIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLegEDfwJAAkAgACIBQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLgAQBA38gAkGABE8EQCAAIAEgAhAEIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACwMAAQv4DwIUfwN8IwBBEGsiCyQAAkAgALwiEUH/////B3EiA0Han6TuBE0EQCABIAC7IhcgF0SDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIWRAAAAFD7Ifm/oqAgFkRjYhphtBBRvqKgIhg5AwAgGEQAAABg+yHpv2MhAgJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyEDIAIEQCABIBcgFkQAAAAAAADwv6AiFkQAAABQ+yH5v6KgIBZEY2IaYbQQUb6ioDkDACADQQFrIQMMAgsgGEQAAABg+yHpP2RFDQEgASAXIBZEAAAAAAAA8D+gIhZEAAAAUPsh+b+ioCAWRGNiGmG0EFG+oqA5AwAgA0EBaiEDDAELIANBgICA/AdPBEAgASAAIACTuzkDAEEAIQMMAQsgCyADIANBF3ZBlgFrIgNBF3Rrvrs5AwggC0EIaiEOIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJBAEobIg1BaGxqIQZB8AkoAgAiB0EATgRAIAdBAWohAyANIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBgApqKAIAtws5AwAgAkEBaiECIARBAWoiBCADRw0ACwsgBkEYayEIQQAhAyAHQQAgB0EAShshBANAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEYhAiADQQFqIQMgAkUNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgByEDAkADQCAFIANBA3RqKwMAIRZBACECIAMhBCADQQBMIglFBEADQCAFQeADaiACQQJ0agJ/An8gFkQAAAAAAABwPqIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLtyIXRAAAAAAAAHDBoiAWoCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBegIRYgAkEBaiICIANHDQALCwJ/IBYgCBAPIhYgFkQAAAAAAADAP6KcRAAAAAAAACDAoqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLIQogFiAKt6EhFgJAAkACQAJ/IAhBAEwiFEUEQCADQQJ0IAVqIgIgAigC3AMiAiACIA91IgIgD3RrIgQ2AtwDIAIgCmohCiAEIBJ1DAELIAgNASADQQJ0IAVqKALcA0EXdQsiDEEATA0CDAELQQIhDCAWRAAAAAAAAOA/Zg0AQQAhDAwBC0EAIQJBACEEIAlFBEADQCAFQeADaiACQQJ0aiIVKAIAIQlB////ByEQAn8CQCAEDQBBgICACCEQIAkNAEEADAELIBUgECAJazYCAEEBCyEEIAJBAWoiAiADRw0ACwsCQCAUDQBB////AyECAkACQCATDgIBAAILQf///wEhAgsgA0ECdCAFaiIJIAkoAtwDIAJxNgLcAwsgCkEBaiEKIAxBAkcNAEQAAAAAAADwPyAWoSEWQQIhDCAERQ0AIBZEAAAAAAAA8D8gCBAPoSEWCyAWRAAAAAAAAAAAYQRAQQAhBAJAIAcgAyICTg0AA0AgBUHgA2ogAkEBayICQQJ0aigCACAEciEEIAIgB0oNAAsgBEUNACAIIQYDQCAGQRhrIQYgBUHgA2ogA0EBayIDQQJ0aigCAEUNAAsMAwtBASECA0AgAiIEQQFqIQIgBUHgA2ogByAEa0ECdGooAgBFDQALIAMgBGohBANAIAVBwAJqIANBAWoiA0EDdGogAyANakECdEGACmooAgC3OQMAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEgNAAsgBCEDDAELCwJAIBZBGCAGaxAPIhZEAAAAAAAAcEFmBEAgBUHgA2ogA0ECdGoCfwJ/IBZEAAAAAAAAcD6iIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyICt0QAAAAAAABwwaIgFqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLNgIAIANBAWohAwwBCwJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyECIAghBgsgBUHgA2ogA0ECdGogAjYCAAtEAAAAAAAA8D8gBhAPIRYCQCADQQBIDQAgAyECA0AgBSACIgRBA3RqIBYgBUHgA2ogAkECdGooAgC3ojkDACACQQFrIQIgFkQAAAAAAABwPqIhFiAEDQALIANBAEgNACADIQQDQEQAAAAAAAAAACEWQQAhAiAHIAMgBGsiBiAGIAdKGyIIQQBOBEADQCACQQN0QdAfaisDACAFIAIgBGpBA3RqKwMAoiAWoCEWIAIgCEchDSACQQFqIQIgDQ0ACwsgBUGgAWogBkEDdGogFjkDACAEQQBKIQIgBEEBayEEIAINAAsLRAAAAAAAAAAAIRYgA0EATgRAA0AgAyICQQFrIQMgFiAFQaABaiACQQN0aisDAKAhFiACDQALCyALIBaaIBYgDBs5AwAgBUGwBGokACAKQQdxIQMgCysDACEWIBFBAEgEQCABIBaaOQMAQQAgA2shAwwBCyABIBY5AwALIAtBEGokACADC/YEAQh/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAiABQSRsaiEAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgAEcNAAsgAAUgAgs2AgQPCwJAIAIgACgCACICa0EkbSIGIAFqIgNByOPxOEkEQEHH4/E4IAQgAmtBJG0iAkEBdCIEIAMgAyAESRsgAkHj8bgcTxsiBARAIARByOPxOE8NAiAEQSRsEA4hBQsgBSAGQSRsaiIDIAFBJGxqIQYgAyECA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgBkcNAAsgBSAEQSRsaiEIAkAgACgCBCICIAAoAgAiCUYEQCADIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIAUgASoCBDgCBCAFIAEqAgg4AgggA0EYayIEIAJBGGsiByoCADgCACAEIAcqAgQ4AgQgBCAHKgIIOAIIIANBDGsiAyACQQxrIgIqAgA4AgAgAyACKgIEOAIEIAMgAioCCDgCCCAFIQMgASICIAlHDQALIAAoAgAhAgsgACAINgIIIAAgBjYCBCAAIAU2AgAgAgRAIAIQCgsPCxAZAAsQGAALrgoBCH8CQEHoKSgCAEHkKSgCACICa0EGdSIBIABJBEAgACABayIDQewpKAIAIgRB6CkoAgAiAWtBBnVNBEBB6CkgAwR/IAEgA0EGdGohAgNAIAEQGkFAayIBIAJHDQALIAIFIAELNgIADAILAkAgAUHkKSgCACICa0EGdSIGIANqIgVBgICAIEkEQEH///8fIAQgAmsiAUEFdSICIAUgAiAFSxsgAUHA////B08bIgcEfyAHQYCAgCBPDQIgB0EGdBAOBUEACyIEIAZBBnRqIgIgA0EGdGohBSACIQEDQCABEBpBQGsiASAFRw0AC0HoKSgCACIBQeQpKAIAIgZHBEADQCACQUBqIgMgAUFAaiIBIgL9AAIA/QsCACADIAL9AAIw/QsCMCADIAL9AAIg/QsCICADIAL9AAIQ/QsCECADIQIgASAGRw0AC0HkKSgCACEBC0HsKSAEIAdBBnRqNgIAQegpIAU2AgBB5CkgAjYCACABBEAgARAQCwwDCxAZAAsQGAALIAAgAU8NAEHoKSACIABBBnRqNgIACwJAQfQpKAIAQfApKAIAIgJrQSRtIgEgAEkEQEHwKSAAIAFrEC8MAQsgACABTw0AQfQpIAIgAEEkbGo2AgALAkBBgCooAgBB/CkoAgAiAmtBBHUiASAASQRAQQAhBEEAIQcgACABayIDQYQqKAIAIgZBgCooAgAiAmtBBHVNBEACQCADRQ0AIAIhASADQQdxIggEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAEQQFqIgQgCEcNAAsLIANBBHQgAmohAiADQQFrQf////8AcUEHSQ0AA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASACRw0ACwtBgCogAjYCAAwCCwJAIAJB/CkoAgAiAWtBBHUiBCADaiIFQYCAgIABSQRAQf////8AIAYgAWsiBkEDdSIBIAUgASAFSxsgBkHw////B08bIgUEQCAFQYCAgIABTw0CIAVBBHQQDiEHCyAHIARBBHRqIgQhASADQQdxIgYEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAIQQFqIgggBkcNAAsLIANBBHQgBGohCCADQQFrQf////8AcUEHTwRAA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASAIRw0ACwtB/CkoAgAiASACRwRAA0AgBEEQayIEIAJBEGsiAv0AAgD9CwIAIAEgAkcNAAtB/CkoAgAhAgtBhCogByAFQQR0ajYCAEGAKiAINgIAQfwpIAQ2AgAgAgRAIAIQEAsMAwsQGQALEBgACyAAIAFPDQBBgCogAiAAQQR0ajYCAAtBjCooAgBBiCooAgAiAmtBJG0i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";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{if(!response["ok"]){throw"failed to load wasm binary file at '"+binaryFile+"'"}return response["arrayBuffer"]()})).catch((()=>getBinarySync(binaryFile)))}else if(readAsync){return new Promise(((resolve,reject)=>{readAsync(binaryFile,(response=>resolve(new Uint8Array(response))),reject)}))}}return Promise.resolve().then((()=>getBinarySync(binaryFile)))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then((binary=>WebAssembly.instantiate(binary,imports))).then((instance=>instance)).then(receiver,(reason=>{err("failed to asynchronously prepare wasm: "+reason);abort(reason)}))}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,(function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)}))}))}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["f"];updateMemoryViews();wasmTable=Module["asm"]["h"];addOnInit(Module["asm"]["g"]);removeRunDependency("wasm-instantiate");return exports}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}function ExitStatus(status){this.name="ExitStatus";this.message=\`Program terminated with exit(\${status})\`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var _abort=()=>{abort("")};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=size-b.byteLength+65535>>>16;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var printCharBuffers=[null,[],[]];var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var SYSCALLS={varargs:undefined,get(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr(ptr){var ret=UTF8ToString(ptr);return ret}};var _fd_write=(fd,iov,iovcnt,pnum)=>{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0};var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var handleException=e=>{if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var wasmImports={b:___cxa_throw,d:_abort,e:_emscripten_memcpy_big,c:_emscripten_resize_heap,a:_fd_write};var asm=createWasm();var ___wasm_call_ctors=function(){return(___wasm_call_ctors=Module["asm"]["g"]).apply(null,arguments)};var _allocation=Module["_allocation"]=function(){return(_allocation=Module["_allocation"]=Module["asm"]["i"]).apply(null,arguments)};var _getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=function(){return(_getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=Module["asm"]["j"]).apply(null,arguments)};var _getSRTPtr=Module["_getSRTPtr"]=function(){return(_getSRTPtr=Module["_getSRTPtr"]=Module["asm"]["k"]).apply(null,arguments)};var _getInfoPtr=Module["_getInfoPtr"]=function(){return(_getInfoPtr=Module["_getInfoPtr"]=Module["asm"]["l"]).apply(null,arguments)};var _getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=function(){return(_getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=Module["asm"]["m"]).apply(null,arguments)};var _printMatrix=Module["_printMatrix"]=function(){return(_printMatrix=Module["_printMatrix"]=Module["asm"]["n"]).apply(null,arguments)};var _updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=function(){return(_updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=Module["asm"]["o"]).apply(null,arguments)};var _main=Module["_main"]=function(){return(_main=Module["_main"]=Module["asm"]["p"]).apply(null,arguments)};var ___errno_location=function(){return(___errno_location=Module["asm"]["__errno_location"]).apply(null,arguments)};var stackAlloc=function(){return(stackAlloc=Module["asm"]["q"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return(___cxa_is_pointer_type=Module["asm"]["r"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args=[]){var entryFunction=_main;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv>>2;args.forEach((arg=>{HEAP32[argv_ptr++]=stringToUTF8OnStack(arg)}));HEAP32[argv_ptr]=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args=arguments_){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(shouldRunNow)callMain(args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();

if (!Module['ENVIRONMENT_IS_PTHREAD']) {
    // console.log("is main");
    window['wasmMatrix'] = Module;
}
        `,Si=class{static async init(i){await new Promise(e=>{const t=document.createElement("script");t.async=!0,t.type="text/javascript",t.src=URL.createObjectURL(new Blob([$f])),document.head.appendChild(t),t.onload=()=>{let r=()=>{this.wasm=window.wasmMatrix,this.wasm&&this.wasm.calledRun?e(!0):setTimeout(r,20)};r()}}),this.allocMatrix(i)}static allocMatrix(i){i>V.maxCount&&console.error(`The maximum allocation size is exceeded! current:${i}, limit:${V.maxCount}`),this.wasm._allocation(i),this.matrixBufferPtr=this.wasm._getMatrixBufferPtr(),this.matrixSRTBufferPtr=this.wasm._getSRTPtr(),this.matrixStateBufferPtr=this.wasm._getInfoPtr(),this.matrixContinuedSRTBufferPtr=this.wasm._getContinuedSRTPtr(),this.matrixBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixBufferPtr,16*i),this.matrixSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixSRTBufferPtr,3*3*i),this.matrixContinuedSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixContinuedSRTBufferPtr,3*3*i),this.matrixStateBuffer=new Int32Array(this.wasm.HEAP32.buffer,this.matrixStateBufferPtr,Si.stateStruct*i),V.allocMatrix(i)}static updateAllContinueTransform(i,e,t){this.wasm._updateAllMatrixContinueTransform(i,e,t)}static setParent(i,e,t){this.matrixStateBuffer[i*Si.stateStruct+2]=e>=0?e:-1,this.matrixStateBuffer[i*Si.stateStruct+3]=t}static setTranslate(i,e,t,r){this.matrixSRTBuffer[i*9+6]=e,this.matrixSRTBuffer[i*9+7]=t,this.matrixSRTBuffer[i*9+8]=r}static setRotation(i,e,t,r){this.matrixSRTBuffer[i*9+3]=e%360,this.matrixSRTBuffer[i*9+4]=t%360,this.matrixSRTBuffer[i*9+5]=r%360}static setScale(i,e,t,r){this.matrixSRTBuffer[i*9+0]=e,this.matrixSRTBuffer[i*9+1]=t,this.matrixSRTBuffer[i*9+2]=r}static setContinueTranslate(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+6]=e,this.matrixContinuedSRTBuffer[i*9+7]=t,this.matrixContinuedSRTBuffer[i*9+8]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}static setContinueRotation(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+3]=e,this.matrixContinuedSRTBuffer[i*9+4]=t,this.matrixContinuedSRTBuffer[i*9+5]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}static setContinueScale(i,e,t,r){(e!=0||t!=0||r!=0)&&(this.matrixContinuedSRTBuffer[i*9+0]=e,this.matrixContinuedSRTBuffer[i*9+1]=t,this.matrixContinuedSRTBuffer[i*9+2]=r,this.matrixStateBuffer[i*Si.stateStruct+1]=1)}};let ee=Si;o(ee,"matrixBuffer"),o(ee,"matrixSRTBuffer"),o(ee,"matrixContinuedSRTBuffer"),o(ee,"matrixStateBuffer"),o(ee,"matrixBufferPtr"),o(ee,"matrixSRTBufferPtr"),o(ee,"matrixContinuedSRTBufferPtr"),o(ee,"matrixStateBufferPtr"),o(ee,"wasm"),o(ee,"stateStruct",4);class yt{}o(yt,"AXIS_ANGLE","axisAngle"),o(yt,"EULER_ANGLES","eulerAngles"),o(yt,"QUATERNION","quaternion");const dt=class{constructor(i=0,e=0,t=0,r=1){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",1),this.x=i,this.y=e,this.z=t,this.w=r}static identity(){return dt._zero}static quaternionToMatrix(i,e){let t=i.x*2,r=i.y*2,s=i.z*2,a=i.x*t,n=i.y*r,l=i.z*s,h=i.x*r,u=i.x*s,c=i.y*s,f=i.w*t,d=i.w*r,p=i.w*s;e.rawData[0]=1-(n+l),e.rawData[1]=h+p,e.rawData[2]=u-d,e.rawData[3]=0,e.rawData[4]=h-p,e.rawData[5]=1-(a+l),e.rawData[6]=c+f,e.rawData[7]=0,e.rawData[8]=u+d,e.rawData[9]=c-f,e.rawData[10]=1-(a+n),e.rawData[11]=0,e.rawData[12]=0,e.rawData[13]=0,e.rawData[14]=0,e.rawData[15]=1}get magnitude(){return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z)}set(i=0,e=0,t=0,r=1){this.x=i,this.y=e,this.z=t,this.w=r}divide(i){return i instanceof dt?new dt(this.x/i.x,this.y/i.y,this.z/i.z):(this.x=this.x/i,this.y=this.y/i,this.z=this.z/i,this)}setFromArray(i){return this.x=i[0],this.y=i[1],this.z=i[2],this.w=i[3],this}multiply(i,e){var t=i.w,r=i.x,s=i.y,a=i.z,n=e.w,l=e.x,h=e.y,u=e.z;this.w=t*n-r*l-s*h-a*u,this.x=t*l+r*n+s*u-a*h,this.y=t*h-r*u+s*n+a*l,this.z=t*u+r*h-s*l+a*n}multiplyVector(i,e=null){e||(e=new dt);var t=i.x,r=i.y,s=i.z;return e.w=-this.x*t-this.y*r-this.z*s,e.x=this.w*t+this.y*s-this.z*r,e.y=this.w*r-this.x*s+this.z*t,e.z=this.w*s+this.x*r-this.y*t,e}fromAxisAngle(i,e){e*=Math.PI/180;var t=e*.5,r=Math.sin(t);this.w=Math.cos(t),this.x=i.x*r,this.y=i.y*r,this.z=i.z*r,this.normalize()}toAxisAngle(i){var e=this.x*this.x+this.y*this.y+this.z*this.z,t=0;return e>0?(t=2*Math.acos(this.w),e=1/Math.sqrt(e),i.x=this.x*e,i.y=this.y*e,i.z=this.z*e):(t=0,i.x=1,i.y=0,i.z=0),t}slerp(i,e,t){var r=i.w,s=i.x,a=i.y,n=i.z,l=e.w,h=e.x,u=e.y,c=e.z,f=r*l+s*h+a*u+n*c;if(f<0&&(f=-f,l=-l,h=-h,u=-u,c=-c),f<.95){var d=Math.acos(f),p=1/Math.sin(d),m=Math.sin(d*(1-t))*p,_=Math.sin(d*t)*p;this.w=r*m+l*_,this.x=s*m+h*_,this.y=a*m+u*_,this.z=n*m+c*_}else{this.w=r+t*(l-r),this.x=s+t*(h-s),this.y=a+t*(u-a),this.z=n+t*(c-n);var v=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);this.w*=v,this.x*=v,this.y*=v,this.z*=v}}lerp(i,e,t){var r=i.w,s=i.x,a=i.y,n=i.z,l=e.w,h=e.x,u=e.y,c=e.z,f;r*l+s*h+a*u+n*c<0&&(l=-l,h=-h,u=-u,c=-c),this.w=r+t*(l-r),this.x=s+t*(h-s),this.y=a+t*(u-a),this.z=n+t*(c-n),f=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z),this.w*=f,this.x*=f,this.y*=f,this.z*=f}fromEulerAngles(i,e,t){i*=_e,e*=_e,t*=_e;var r=i*.5,s=e*.5,a=t*.5,n=Math.cos(r),l=Math.sin(r),h=Math.cos(s),u=Math.sin(s),c=Math.cos(a),f=Math.sin(a);return this.w=n*h*c+l*u*f,this.x=l*h*c-n*u*f,this.y=n*u*c+l*h*f,this.z=n*h*f-l*u*c,this}setFromRotationMatrix(i){const e=i.rawData,t=e[0],r=e[4],s=e[8],a=e[1],n=e[5],l=e[9],h=e[2],u=e[6],c=e[10],f=t+n+c;if(f>0){const d=.5/Math.sqrt(f+1);this.w=.25/d,this.x=(u-l)*d,this.y=(s-h)*d,this.z=(a-r)*d}else if(t>n&&t>c){const d=2*Math.sqrt(1+t-n-c);this.w=(u-l)/d,this.x=.25*d,this.y=(r+a)/d,this.z=(s+h)/d}else if(n>c){const d=2*Math.sqrt(1+n-t-c);this.w=(s-h)/d,this.x=(r+a)/d,this.y=.25*d,this.z=(l+u)/d}else{const d=2*Math.sqrt(1+c-t-n);this.w=(a-r)/d,this.x=(s+h)/d,this.y=(l+u)/d,this.z=.25*d}return this}getEulerAngles(i){var e,t,r,s,a,n,l,h;return i||(i=new g),s=this.x,a=this.y,n=this.z,l=this.w,h=2*(l*a-s*n),h<=-.99999?(e=2*Math.atan2(s,l),t=-Math.PI/2,r=0):h>=.99999?(e=2*Math.atan2(s,l),t=Math.PI/2,r=0):(e=Math.atan2(2*(l*s+a*n),1-2*(s*s+a*a)),t=Math.asin(h),r=Math.atan2(2*(l*n+s*a),1-2*(a*a+n*n))),i.set(e,t,r).scaleBy(qi)}normalize(i=1){var e=i/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=e,this.y*=e,this.z*=e,this.w*=e}toString(){return"{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}"}fromMatrix(i){var e=i.decompose(yt.QUATERNION)[1];this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w}inverse(i=null){i||(i=new dt);var e=this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z;if(e>0){var t=1/e;i.w=this.w*t,i.x=-this.x*t,i.y=-this.y*t,i.z=-this.z*t}return i}clone(){return new dt(this.x,this.y,this.z,this.w)}transformVector(i,e=null){var t,r,s,a,n=i.x,l=i.y,h=i.z;return e||(e=new g),a=-this.x*n-this.y*l-this.z*h,t=this.w*n+this.y*h-this.z*l,r=this.w*l-this.x*h+this.z*n,s=this.w*h+this.x*l-this.y*n,e.x=-a*this.x+t*this.w-r*this.z+s*this.y,e.y=-a*this.y+t*this.z+r*this.w-s*this.x,e.z=-a*this.z-t*this.y+r*this.x+s*this.w,e}copyFrom(i){var e=this;return e.x=i.x,e.y=i.y,e.z=i.z,e.w=i.w,this}mul(i,e,t){let r=t||new dt;return r.x=i.w*e.x+i.x*e.w+i.y*e.z-i.z*e.y,r.y=i.w*e.y+i.y*e.w+i.z*e.x-i.x*e.z,r.z=i.w*e.z+i.z*e.w+i.x*e.y-i.y*e.x,r.w=i.w*e.w-i.x*e.x-i.y*e.y-i.z*e.z,r}clampf(i,e,t){if(e>t){var r=e;e=t,t=r}return i<e?e:i<t?i:t}};let q=dt;o(q,"HELP_0",new dt(0,0,0,1)),o(q,"HELP_1",new dt(0,0,0,1)),o(q,"HELP_2",new dt(0,0,0,1)),o(q,"_zero",new dt(0,0,0,1)),o(q,"CALCULATION_QUATERNION",new dt);function ed(i,e,t){let r=i.x*2,s=i.y*2,a=i.z*2,n=i.x*r,l=i.y*s,h=i.z*a,u=i.x*s,c=i.x*a,f=i.y*a,d=i.w*r,p=i.w*s,m=i.w*a,_=t||new g;return _.x=(1-(l+h))*e.x+(u-m)*e.y+(c+p)*e.z,_.y=(u+m)*e.x+(1-(n+h))*e.y+(f-d)*e.z,_.z=(c-p)*e.x+(f+d)*e.y+(1-(n+l))*e.z,_}class As{constructor(e=0){o(this,"_x",0),o(this,"_y",0),o(this,"_z",0),o(this,"_w",0),this.seed=e}get seed(){return this._x}set seed(e){this._x=e,this._y=this._x*1812433253+1,this._z=this._y*1812433253+1,this._w=this._z*1812433253+1}static getFloatFromInt(e){return Math.floor((e&8388607)*(1/8388607))}static getByteFromInt(e){return e>>23-8}clone(){let e=new As;return e._x=this._x,e._y=this._y,e._z=this._z,e._w=this._w,e}get(){let e=this._x^this._x<<11;return this._x=this._y,this._y=this._z,this._z=this._w,this._w=this._w^this._w>>19^(e^e>>8)}getFloat(){return fl(this.get())}getSignedFloat(){return this.getFloat()*2-1}}let qi=180/Math.PI,_e=Math.PI/180,td=2147483647,id=-2147483647;function K(i,e,t){return Math.max(e,Math.min(t,i))}class st{static gaussFunction(e,t,r,s){let a=Math.pow(e-r,2),n=2*Math.pow(s,2),l=-1*(a/n),h=Math.pow(Math.E,l);return Math.round(h*t)}static computeGaussian(e,t){return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(e*e)/(2*t*t))}static gaussCoef(e){e<.5&&(e=.5);let t=Math.exp(.726*.726)/e,r=Math.exp(-t),s=Math.exp(-2*t),a=(1-r)*(1-r)/(1+2*t*r-s),n=a,l=a*(t-1)*r,h=a*(t+1)*r,u=-a*s,c=2*r,f=-s,d=(n+l)/(1-c-f),p=(h+u)/(1-c-f);return new Float32Array([n,l,h,u,c,f,d,p])}static clampf(e,t,r){if(t>r){let s=t;t=r,r=s}return e<t?t:e<r?e:r}static normalizeAngle(e){for(;e>180;)e-=360;for(;e<-180;)e+=360;return e}static fract(e){return e-Math.floor(e)}static getRandDirXZ(e){let t=e*Math.random(),r=360*Math.random()*_e,s=Math.cos(r)*t,a=Math.sin(r)*t;return{x:s,z:a}}static getRandDirXYZ(e){let t=e*Math.random(),r=360*Math.random()*_e,s=Math.cos(r)*t,a=Math.tan(r)*t,n=Math.sin(r)*t;return new g(s,a,n)}static getCycleXYZ(e){let t=e*Math.random(),r=360*Math.random()*_e,s=Math.cos(r)*t,a=e*Math.random()-e*.5,n=Math.sin(r)*t;return new g(s,a,n)}static angle(e,t){let r=Z.HELP_0,s=Z.HELP_1;return r.set(e.x,e.z),s.set(t.x,t.z),Math.acos((r.x*s.x+r.y*s.y)/(r.abs()*s.abs()))}static angle_360(e,t){let r=g.HELP_0;return e.crossProduct(t,r),r.z>0?st.angle(e,t):360-st.angle(e,t)}getRotationY(e){return st.normalizeAngle(Math.atan2(e.z,e.x)*qi)}static fromToRotation(e,t,r=null){r||(r=new q);let s=V.help_matrix_2;return V.fromToRotation(e,t,s),r.fromMatrix(s),r}static getEularDir_yUp(e){let t=q.HELP_0;return t.fromEulerAngles(0,e,0),t.transformVector(g.Z_AXIS,g.HELP_5),g.HELP_5}static transformVector(e,t,r=null){r||(r=new g);let s=e.rawData,a=s[0],n=s[1],l=s[2],h=s[3],u=s[4],c=s[5],f=s[6],d=s[7],p=s[8],m=s[9],_=s[10],v=s[11],y=s[12],C=s[13],B=s[14],T=s[15],M=t.x,D=t.y,P=t.z;return r.x=a*M+u*D+p*P+y,r.y=n*M+c*D+m*P+C,r.z=l*M+f*D+_*P+B,r.w=h*M+d*D+v*P+T,r}}let Ii=function(i,e,t){return i*(1-t)+e*t};function rd(i,e,t){let r=new g,s=i.x,a=i.y,n=i.z,l=i.w,h=e.x,u=e.y,c=e.z,f=e.w;return r.x=(h-s)*t+s,r.y=(u-a)*t+a,r.z=(c-n)*t+n,r.w=(f-l)*t+l,r}function sd(i,e,t){let r=new z;return r.r=(1-t)*i.r+t*e.r,r.g=(1-t)*i.g+t*e.g,r.b=(1-t)*i.b+t*e.b,r.a=(1-t)*i.a+t*e.a,r}function ad(i,e,t){return i+((e-i)*t>>8)&255}let Ja=function(i,e,t){let r=t-e;return Math.floor(i/r)%2==0?i%r+e:t-i%r+e},Za=function(i,e,t){let r=t-e;return i%r+e},od=function(i,e){let t=0;for(let r in i)r==e&&t++;return t};class nd{constructor(){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",0),o(this,"randSeedList"),this.randSeedList=[]}reset(){this.x=Math.random()*1,this.y=Math.random()*1,this.z=Math.random()*1,this.w=Math.random()*1,this.randSeedList.length=0;for(let e=0;e<20;e++)this.randSeedList.push(Math.random()*1)}}function et(i,e){return i instanceof g&&e instanceof g||i instanceof q&&e instanceof q?i.x*e.x+i.y*e.y+i.z*e.z:i.x*e.x+i.y*e.y}function $a(i,e){return new g(i.x*e.x,i.y*e.y,i.z*e.z)}function ul(i){return Math.sqrt(i)}function eo(i){return ul(et(i,i))}function cl(i,e){if(eo(i)>g.EPSILON)return i.divide(eo(i));if(i instanceof Z)return new Z;if(i instanceof g)return new g;if(i instanceof q)return new q}function fl(i){return(i&8388607)*(1/8388607)}function Ki(i){return i.getFloat()}function qe(i,e,t){let r=i.getFloat();return r=e*r+(1-r)*t,r}function ld(i,e,t){let r;if(e<t){r=t-e;let s=i.get()%r;return s+=e,s}else if(e>t){r=e-t;let s=i.get()%r;return s=e-s,s}else return e}function Ps(i){let e=qe(i,-1,1),t=qe(i,0,2*Math.PI),r=Math.sqrt(1-e*e),s=r*Math.cos(t),a=r*Math.sin(t);return new g(s,a,e)}function dl(i){let e=qe(i,0,2*Math.PI),t=Math.cos(e),r=Math.sin(e);return new Z(t,r)}function hd(i){let e=new q;return e.x=qe(i,-1,1),e.y=qe(i,-1,1),e.z=qe(i,-1,1),e.w=qe(i,-1,1),e=cl(e),et(e,q.identity())<0?-e:e}function ud(i){const e=2*Math.PI;let t=qe(i,0,1),r=qe(i,0,e),s=qe(i,0,e),a=Math.sqrt(1-t),n=Math.sqrt(t),l=new q(a*Math.sin(r),a*Math.cos(r),n*Math.sin(s),n*Math.cos(s));return et(l,q.identity())<0?-l:l}function cd(i,e){return new g(qe(i,-e.x,e.x),qe(i,-e.y,e.y),qe(i,-e.z,e.z))}function gl(i){let e=Ps(i);return e.scaleBy(Math.pow(Ki(i),1/3)),e}function fd(i,e){return $a(gl(i),e)}function dd(i,e,t){let r=Ps(i),s=Math.pow(qe(i,0,1),1/3);return r.scaleBy(e+(t-e)*s),r}function gd(i){let e=dl(i);return e.multiply(Math.pow(qe(i,0,1),1/2),e),e}function pd(i,e,t){let r=$a(Ps(i),e),s=Math.pow(qe(i,t,1),1/3);return r.scaleBy(s),r}function md(i){let e=i.getFloat(),t=i.getFloat();e+t>1&&(e=1-e,t=1-t);let r=1-e-t;return new g(e,t,r)}function Ad(i){return i/360*2*Math.PI}function _d(i){return 180*i/Math.PI}function xd(i){return Math.sin(i)}function vd(i){return Math.cos(i)}let pl=4919;function yd(){return++pl}function Cd(i,e,t){let r=i[e],s=i[t];i[e]=s,i[t]=r}function ml(i){return Math.floor(i)}function to(i){return ml(i+.5)}function wd(i){return i=Math.max(i,0),i=Math.min(i,1),to(i*65535)}function bd(i){return i=Math.max(i,0),i=Math.min(i,1),to(i*255)}function Al(i){return Math.abs(i)==0?i:1/Math.sqrt(i)}function Sd(i){let e=io(i);return i.scaleBy(Al(e))}function Id(i,e){return i.crossProduct(e)}function io(i){return et(i,i)}function Ed(i){let e=new As(i);return Ki(e)}function Bd(i,e){let t=new As(e);i.x=Ki(t),i.y=Ki(t),i.z=Ki(t)}function Td(i,e,t){return i<e?t:i>t?e:i}function ro(i,e){return i-Math.floor(i/e)*e}const Md=1e-6,F=class{constructor(i=!1){if(o(this,"index",0),o(this,"offset",0),o(this,"rawData"),o(this,"_position"),F.useCount>=F.allocCount){let e=F.allocCount+F.allocOnceCount;ee.allocMatrix(e)}this.index=F.useCount,this.offset=F.wasmMatrixPtr+this.index*F.blockBytes,F.dynamicGlobalMatrixRef[this.index]=this,F.useCount++,this.rawData=new Float32Array(F.dynamicMatrixBytes.buffer,this.offset,16),this._position=new g,this.identity()}static allocMatrix(i){this.allocCount=i,F.dynamicMatrixBytes=ee.matrixBuffer,F.buffer=F.dynamicMatrixBytes.buffer,F.wasmMatrixPtr=ee.matrixBufferPtr,this.dynamicGlobalMatrixRef||(this.dynamicGlobalMatrixRef=[]),this.dynamicGlobalMatrixRef.forEach(e=>{e.offset=F.wasmMatrixPtr+e.index*F.blockBytes,e.rawData=new Float32Array(F.dynamicMatrixBytes.buffer,e.offset,16)}),F.help_matrix_0||(F.help_matrix_0=new F),F.help_matrix_1||(F.help_matrix_1=new F),F.help_matrix_2||(F.help_matrix_2=new F),F.helpMatrix||(F.helpMatrix=new F),F.helpMatrix2||(F.helpMatrix2=new F),F._getEulerMatrix||(F._getEulerMatrix=new F),F._getEulerMatrix.identity()}static fromToRotation(i,e,t){return t||(t=new F),t.transformDir(i,e),t}static getAxisRotation(i,e,t,r){let s=new F,a=r*(Math.PI/180),n=Math.cos(a),l=Math.sin(a),h=1-n,u,c;return s.rawData[0]=n+i*i*h,s.rawData[5]=n+e*e*h,s.rawData[10]=n+t*t*h,u=i*e*h,c=t*l,s.rawData[1]=u+c,s.rawData[4]=u-c,u=i*t*h,c=e*l,s.rawData[8]=u+c,s.rawData[2]=u-c,u=e*t*h,c=i*l,s.rawData[9]=u-c,s.rawData[6]=u+c,s}static sanitizeEuler(i){F.makePositive(i)}static makePositive(i){let e=-1e-4,t=Math.PI*2-1e-4;i.x<e?i.x+=2*Math.PI:i.x>t&&(i.x-=2*Math.PI),i.y<e?i.y+=2*Math.PI:i.y>t&&(i.y-=2*Math.PI),i.z<e?i.z+=2*Math.PI:i.z>t&&(i.z-=2*Math.PI)}static matrixToEuler(i,e){return i.get(1,2)<.999?i.get(1,2)>-.999?(e.x=Math.asin(-i.get(1,2)),e.y=Math.atan2(i.get(0,2),i.get(2,2)),e.z=Math.atan2(i.get(1,0),i.get(1,1)),F.sanitizeEuler(e),!0):(e.x=Math.PI*.5,e.y=Math.atan2(i.get(0,1),i.get(0,0)),e.z=0,F.sanitizeEuler(e),!1):(e.x=-Math.PI*.5,e.y=Math.atan2(-i.get(0,1),i.get(0,0)),e.z=0,F.sanitizeEuler(e),!1)}static matrixMultiply(i,e,t){F.wasm.Matrix_Multiply(i.index,e.index,t.index)}static matrixAppend(i,e,t){F.wasm.Matrix_Append(i.index,e.index,t.index)}static matrixRotateY(i,e){F.wasm.Matrix_Append(i,e.index)}static matrixRotate(i,e,t){F.wasm.Matrix_Rotate(i,e,t.index)}lookAt(i,e,t=g.Y_AXIS){let r=this.rawData,s=e.subtract(i,g.HELP_0);s.length<1e-4&&(s.z=1),s.normalize();let a=t.crossProduct(s,g.HELP_1);a.length<1e-4&&(Math.abs(t.z)>.9999?s.x+=1e-4:s.z+=1e-4,s.normalize()),a=t.crossProduct(s,a).normalize();let n=s.crossProduct(a,g.HELP_2).normalize();r[0]=a.x,r[1]=n.x,r[2]=s.x,r[3]=0,r[4]=a.y,r[5]=n.y,r[6]=s.y,r[7]=0,r[8]=a.z,r[9]=n.z,r[10]=s.z,r[11]=0,r[12]=-a.dotProduct(i),r[13]=-n.dotProduct(i),r[14]=-s.dotProduct(i),r[15]=1}multiply(i){let e=this.rawData,t=i.rawData,r=F.float32Array;r[0]=e[0]*t[0]+e[1]*t[4]+e[2]*t[8]+e[3]*t[12],r[1]=e[0]*t[1]+e[1]*t[5]+e[2]*t[9]+e[3]*t[13],r[2]=e[0]*t[2]+e[1]*t[6]+e[2]*t[10]+e[3]*t[14],r[3]=e[0]*t[3]+e[1]*t[7]+e[2]*t[11]+e[3]*t[15],r[4]=e[4]*t[0]+e[5]*t[4]+e[6]*t[8]+e[7]*t[12],r[5]=e[4]*t[1]+e[5]*t[5]+e[6]*t[9]+e[7]*t[13],r[6]=e[4]*t[2]+e[5]*t[6]+e[6]*t[10]+e[7]*t[14],r[7]=e[4]*t[3]+e[5]*t[7]+e[6]*t[11]+e[7]*t[15],r[8]=e[8]*t[0]+e[9]*t[4]+e[10]*t[8]+e[11]*t[12],r[9]=e[8]*t[1]+e[9]*t[5]+e[10]*t[9]+e[11]*t[13],r[10]=e[8]*t[2]+e[9]*t[6]+e[10]*t[10]+e[11]*t[14],r[11]=e[8]*t[3]+e[9]*t[7]+e[10]*t[11]+e[11]*t[15],r[12]=e[12]*t[0]+e[13]*t[4]+e[14]*t[8]+e[15]*t[12],r[13]=e[12]*t[1]+e[13]*t[5]+e[14]*t[9]+e[15]*t[13],r[14]=e[12]*t[2]+e[13]*t[6]+e[14]*t[10]+e[15]*t[14],r[15]=e[12]*t[3]+e[13]*t[7]+e[14]*t[11]+e[15]*t[15],e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15]}multiplyMatrices(i,e){const t=i.rawData,r=e.rawData,s=this.rawData,a=t[0],n=t[4],l=t[8],h=t[12],u=t[1],c=t[5],f=t[9],d=t[13],p=t[2],m=t[6],_=t[10],v=t[14],y=t[3],C=t[7],B=t[11],T=t[15],M=r[0],D=r[4],P=r[8],L=r[12],I=r[1],O=r[5],k=r[9],H=r[13],W=r[2],ne=r[6],fe=r[10],we=r[14],ze=r[3],Re=r[7],ue=r[11],de=r[15];return s[0]=a*M+n*I+l*W+h*ze,s[4]=a*D+n*O+l*ne+h*Re,s[8]=a*P+n*k+l*fe+h*ue,s[12]=a*L+n*H+l*we+h*de,s[1]=u*M+c*I+f*W+d*ze,s[5]=u*D+c*O+f*ne+d*Re,s[9]=u*P+c*k+f*fe+d*ue,s[13]=u*L+c*H+f*we+d*de,s[2]=p*M+m*I+_*W+v*ze,s[6]=p*D+m*O+_*ne+v*Re,s[10]=p*P+m*k+_*fe+v*ue,s[14]=p*L+m*H+_*we+v*de,s[3]=y*M+C*I+B*W+T*ze,s[7]=y*D+C*O+B*ne+T*Re,s[11]=y*P+C*k+B*fe+T*ue,s[15]=y*L+C*H+B*we+T*de,this}multiplyPoint3(i,e){e||(e=new g);let t=this.rawData;return e.x=t[0]*i.x+t[4]*i.y+t[8]*i.z+t[12],e.y=t[1]*i.x+t[5]*i.y+t[9]*i.z+t[13],e.z=t[2]*i.x+t[6]*i.y+t[10]*i.z+t[14],e}multiplyVector4(i,e){e||(e=new g);let t=this.rawData,r=i.x,s=i.y,a=i.z,n=t[3]*r+t[7]*s+t[11]*a+t[15];return n=n||1,e.x=(t[0]*r+t[4]*s+t[8]*a+t[12])/n,e.y=(t[1]*r+t[5]*s+t[9]*a+t[13])/n,e.z=(t[2]*r+t[6]*s+t[10]*a+t[14])/n,e.w=1,e}transformVector4(i,e){let t=this.rawData;e||(e=new g);let r=i.x,s=i.y,a=i.z,n=i.w;return e.x=r*t[0]+s*t[4]+a*t[8]+n*t[12],e.y=r*t[1]+s*t[5]+a*t[9]+n*t[13],e.z=r*t[2]+s*t[6]+a*t[10]+n*t[14],e.w=r*t[3]+s*t[7]+a*t[11]+n*t[15],e}perspectiveMultiplyPoint3(i,e){let t=g.HELP_2,r,s=this.rawData;if(t.x=s[0]*i.x+s[4]*i.y+s[8]*i.z+s[12],t.y=s[1]*i.x+s[5]*i.y+s[9]*i.z+s[13],t.z=s[2]*i.x+s[6]*i.y+s[10]*i.z+s[14],r=s[3]*i.x+s[7]*i.y+s[11]*i.z+s[15],Math.abs(r)>1e-7){let a=1/r;return e.x=t.x*a,e.y=t.y*a,e.z=t.z*a,!0}else return e.x=0,e.y=0,e.z=0,!1}perspective(i,e,t,r){let s=this.rawData,a=i*_e/2,n=Math.cos(a)/Math.sin(a);s[0]=-n/e,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=n,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=r/(r-t),s[11]=1,s[12]=0,s[13]=0,s[14]=-t*r/(r-t),s[15]=0}perspective3(i,e,t,r){var s=Math.tan(i*Math.PI/360)*t,a=s*e;this.frustum(-a,a,-s,s,t,r)}frustum(i,e,t,r,s,a){var n=this.rawData;n[0]=-2*s/(e-i),n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2*s/(r-t),n[6]=0,n[7]=0,n[8]=(e+i)/(e-i),n[9]=(r+t)/(r-t),n[10]=a/(a-s),n[11]=1,n[12]=0,n[13]=0,n[14]=-a*s/(a-s),n[15]=0}ortho(i,e,t,r){let s=this.rawData;return s[0]=2/i,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2/e,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=1/(r-t),s[11]=0,s[12]=0,s[13]=0,s[14]=t/(t-r),s[15]=1,this}orthoZO(i,e,t,r,s,a){let n=this.rawData,l=1/(i-e),h=1/(t-r),u=1/(s-a);return n[0]=-2*l,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=-2*h,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=u,n[11]=0,n[12]=(i+e)*l,n[13]=(r+t)*h,n[14]=s*u,n[15]=1,this}orthoOffCenter(i,e,t,r,s,a){let n=this.rawData;n[0]=2/(e-i),n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2/(r-t),n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1/(a-s),n[11]=0,n[12]=(i+e)/(i-e),n[13]=(r+t)/(t-r),n[14]=s/(s-a),n[15]=1}transformDir(i,e){let t=this.rawData,r=1e-6,s=g.ZERO;e.crossProduct(i,s);let a=e.dotProduct(i);if(a>1-r)this.identity();else{let n,l,h,u,c,f=s.dotProduct(s),d=(1-a)/f;n=d*s.x,l=d*s.z,h=n*s.y,u=n*s.z,c=l*s.y,t[0]=a+n*s.x,t[1]=h-s.z,t[2]=u+s.y,t[4]=h+s.z,t[5]=a+d*s.y*s.y,t[6]=c-s.x,t[8]=u-s.y,t[9]=c+s.x,t[10]=a+l*s.z,t[3]=0,t[7]=0,t[11]=0,t[15]=1}}append(i){let e=this.rawData,t=e[0],r=e[4],s=e[8],a=e[12],n=e[1],l=e[5],h=e[9],u=e[13],c=e[2],f=e[6],d=e[10],p=e[14],m=e[3],_=e[7],v=e[11],y=e[15];e[0]=t*i.rawData[0]+n*i.rawData[4]+c*i.rawData[8]+m*i.rawData[12],e[1]=t*i.rawData[1]+n*i.rawData[5]+c*i.rawData[9]+m*i.rawData[13],e[2]=t*i.rawData[2]+n*i.rawData[6]+c*i.rawData[10]+m*i.rawData[14],e[3]=t*i.rawData[3]+n*i.rawData[7]+c*i.rawData[11]+m*i.rawData[15],e[4]=r*i.rawData[0]+l*i.rawData[4]+f*i.rawData[8]+_*i.rawData[12],e[5]=r*i.rawData[1]+l*i.rawData[5]+f*i.rawData[9]+_*i.rawData[13],e[6]=r*i.rawData[2]+l*i.rawData[6]+f*i.rawData[10]+_*i.rawData[14],e[7]=r*i.rawData[3]+l*i.rawData[7]+f*i.rawData[11]+_*i.rawData[15],e[8]=s*i.rawData[0]+h*i.rawData[4]+d*i.rawData[8]+v*i.rawData[12],e[9]=s*i.rawData[1]+h*i.rawData[5]+d*i.rawData[9]+v*i.rawData[13],e[10]=s*i.rawData[2]+h*i.rawData[6]+d*i.rawData[10]+v*i.rawData[14],e[11]=s*i.rawData[3]+h*i.rawData[7]+d*i.rawData[11]+v*i.rawData[15],e[12]=a*i.rawData[0]+u*i.rawData[4]+p*i.rawData[8]+y*i.rawData[12],e[13]=a*i.rawData[1]+u*i.rawData[5]+p*i.rawData[9]+y*i.rawData[13],e[14]=a*i.rawData[2]+u*i.rawData[6]+p*i.rawData[10]+y*i.rawData[14],e[15]=a*i.rawData[3]+u*i.rawData[7]+p*i.rawData[11]+y*i.rawData[15]}add(i){let e=this.rawData,t=e[0],r=e[4],s=e[8],a=e[12],n=e[1],l=e[5],h=e[9],u=e[13],c=e[2],f=e[6],d=e[10],p=e[14],m=e[3],_=e[7],v=e[11],y=e[15],C=i.rawData[0],B=i.rawData[4],T=i.rawData[8],M=i.rawData[12],D=i.rawData[1],P=i.rawData[5],L=i.rawData[9],I=i.rawData[13],O=i.rawData[2],k=i.rawData[6],H=i.rawData[10],W=i.rawData[14],ne=i.rawData[3],fe=i.rawData[7],we=i.rawData[11],ze=i.rawData[15];return e[0]=t+C,e[1]=n+D,e[2]=c+O,e[3]=m+ne,e[4]=r+B,e[5]=l+P,e[6]=f+k,e[7]=_+fe,e[8]=s+T,e[9]=h+L,e[10]=d+H,e[11]=v+we,e[12]=a+M,e[13]=u+I,e[14]=p+W,e[15]=y+ze,this}sub(i){let e=this.rawData,t=e[0],r=e[4],s=e[8],a=e[12],n=e[1],l=e[5],h=e[9],u=e[13],c=e[2],f=e[6],d=e[10],p=e[14],m=e[3],_=e[7],v=e[11],y=e[15],C=i.rawData[0],B=i.rawData[4],T=i.rawData[8],M=i.rawData[12],D=i.rawData[1],P=i.rawData[5],L=i.rawData[9],I=i.rawData[13],O=i.rawData[2],k=i.rawData[6],H=i.rawData[10],W=i.rawData[14],ne=i.rawData[3],fe=i.rawData[7],we=i.rawData[11],ze=i.rawData[15];return e[0]=t-C,e[1]=n-D,e[2]=c-O,e[3]=m-ne,e[4]=r-B,e[5]=l-P,e[6]=f-k,e[7]=_-fe,e[8]=s-T,e[9]=h-L,e[10]=d-H,e[11]=v-we,e[12]=a-M,e[13]=u-I,e[14]=p-W,e[15]=y-ze,this}mult(i){let e=this.rawData;return e[0]*=i,e[1]*=i,e[2]*=i,e[3]*=i,e[4]*=i,e[5]*=i,e[6]*=i,e[7]*=i,e[8]*=i,e[9]*=i,e[10]*=i,e[11]*=i,e[12]*=i,e[13]*=i,e[14]*=i,e[15]*=i,this}appendRotation(i,e){let t=F.getAxisRotation(e.x,e.y,e.z,i);this.append(t)}createByRotation(i,e){let t=F.helpMatrix,r,s,a=i*_e;r=Math.sin(a),s=Math.cos(a),e.x==1&&(t.rawData[0]=1,t.rawData[1]=0,t.rawData[2]=0,t.rawData[3]=0,t.rawData[4]=0,t.rawData[5]=s,t.rawData[6]=r,t.rawData[7]=0,t.rawData[8]=0,t.rawData[9]=-r,t.rawData[10]=s,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),e.y==1&&(t.rawData[0]=s,t.rawData[1]=0,t.rawData[2]=-r,t.rawData[3]=0,t.rawData[4]=0,t.rawData[5]=1,t.rawData[6]=0,t.rawData[7]=0,t.rawData[8]=r,t.rawData[9]=0,t.rawData[10]=s,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),e.z==1&&(t.rawData[0]=s,t.rawData[1]=r,t.rawData[2]=0,t.rawData[3]=0,t.rawData[4]=-r,t.rawData[5]=s,t.rawData[6]=0,t.rawData[7]=0,t.rawData[8]=0,t.rawData[9]=0,t.rawData[10]=1,t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1),this.append(t)}appendScale(i,e,t){F.helpMatrix.createByScale(i,e,t),this.append(F.helpMatrix)}createByScale(i,e,t){let r=this.rawData;r[0]=i,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=t,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1}appendTranslation(i,e,t){let r=this.rawData;r[12]+=i,r[13]+=e,r[14]+=t}clone(){let i=new F;return i.copyFrom(this),i}copyRowFrom(i,e){let t=this.rawData;switch(i){case 0:t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w;break;case 1:t[4]=e.x,t[5]=e.y,t[6]=e.z,t[7]=e.w;break;case 2:t[8]=e.x,t[9]=e.y,t[10]=e.z,t[11]=e.w;break;case 3:t[12]=e.x,t[13]=e.y,t[14]=e.z,t[15]=e.w;break}}copyRowTo(i,e){let t=this.rawData;switch(i){case 0:e.x=t[0],e.y=t[1],e.z=t[2],e.w=t[3];break;case 1:e.x=t[4],e.y=t[5],e.z=t[6],e.w=t[7];break;case 2:e.x=t[8],e.y=t[9],e.z=t[10],e.w=t[11];break;case 3:e.x=t[12],e.y=t[13],e.z=t[14],e.w=t[15];break}}copyFrom(i){let e=this.rawData;return e[0]=i.rawData[0],e[1]=i.rawData[1],e[2]=i.rawData[2],e[3]=i.rawData[3],e[4]=i.rawData[4],e[5]=i.rawData[5],e[6]=i.rawData[6],e[7]=i.rawData[7],e[8]=i.rawData[8],e[9]=i.rawData[9],e[10]=i.rawData[10],e[11]=i.rawData[11],e[12]=i.rawData[12],e[13]=i.rawData[13],e[14]=i.rawData[14],e[15]=i.rawData[15],this}copyRawDataTo(i,e=0,t=!1){let r=this.rawData;i[0+e]=r[0],i[1+e]=r[1],i[2+e]=r[2],i[3+e]=r[3],i[4+e]=r[4],i[5+e]=r[5],i[6+e]=r[6],i[7+e]=r[7],i[8+e]=r[8],i[9+e]=r[9],i[10+e]=r[10],i[11+e]=r[11],i[12+e]=r[12],i[13+e]=r[13],i[14+e]=r[14],i[15+e]=r[15]}copyColFrom(i,e){let t=this.rawData;switch(i){case 0:t[0]=e.x,t[4]=e.y,t[8]=e.z,t[12]=e.w;break;case 1:t[1]=e.x,t[5]=e.y,t[9]=e.z,t[13]=e.w;break;case 2:t[2]=e.x,t[6]=e.y,t[10]=e.z,t[14]=e.w;break;case 3:t[3]=e.x,t[7]=e.y,t[11]=e.z,t[15]=e.w;break}}copyColTo(i,e){let t=this.rawData;switch(i){case 0:e.x=t[0],e.y=t[4],e.z=t[8],e.w=t[12];break;case 1:e.x=t[1],e.y=t[5],e.z=t[9],e.w=t[13];break;case 2:e.x=t[2],e.y=t[6],e.z=t[10],e.w=t[14];break;case 3:e.x=t[3],e.y=t[7],e.z=t[11],e.w=t[15];break}}copyToMatrix3D(i){i.rawData=this.rawData.slice(0)}makeRotationFromQuaternion(i){return this.compose(F._zero,i,F._one),this}decompose(i="eulerAngles",e){let t=q.CALCULATION_QUATERNION,r=e||F._prs;this.copyRawDataTo(F.decomposeRawData);let s=F.decomposeRawData,a=r[0];a.x=s[12],a.y=s[13],a.z=s[14],s[12]=0,s[13]=0,s[14]=0;let n=r[2];n.x=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]),n.y=Math.sqrt(s[4]*s[4]+s[5]*s[5]+s[6]*s[6]),n.z=Math.sqrt(s[8]*s[8]+s[9]*s[9]+s[10]*s[10]),s[0]*(s[5]*s[10]-s[6]*s[9])-s[1]*(s[4]*s[10]-s[6]*s[8])+s[2]*(s[4]*s[9]-s[5]*s[8])<0&&(n.z=-n.z),s[0]/=n.x,s[1]/=n.x,s[2]/=n.x,s[4]/=n.y,s[5]/=n.y,s[6]/=n.y,s[8]/=n.z,s[9]/=n.z,s[10]/=n.z;let l=r[1],h;switch(i){case yt.AXIS_ANGLE:l.w=Math.acos((s[0]+s[5]+s[10]-1)/2);let u=Math.sqrt((s[6]-s[9])*(s[6]-s[9])+(s[8]-s[2])*(s[8]-s[2])+(s[1]-s[4])*(s[1]-s[4]));l.x=(s[6]-s[9])/u,l.y=(s[8]-s[2])/u,l.z=(s[1]-s[4])/u;break;case yt.QUATERNION:h=s[0]+s[5]+s[10],h>0?(l.w=Math.sqrt(1+h)/2,l.x=(s[6]-s[9])/(4*l.w),l.y=(s[8]-s[2])/(4*l.w),l.z=(s[1]-s[4])/(4*l.w)):s[0]>s[5]&&s[0]>s[10]?(l.x=Math.sqrt(1+s[0]-s[5]-s[10])/2,l.w=(s[6]-s[9])/(4*l.x),l.y=(s[1]+s[4])/(4*l.x),l.z=(s[8]+s[2])/(4*l.x)):s[5]>s[10]?(l.y=Math.sqrt(1+s[5]-s[0]-s[10])/2,l.x=(s[1]+s[4])/(4*l.y),l.w=(s[8]-s[2])/(4*l.y),l.z=(s[6]+s[9])/(4*l.y)):(l.z=Math.sqrt(1+s[10]-s[0]-s[5])/2,l.x=(s[8]+s[2])/(4*l.z),l.y=(s[6]+s[9])/(4*l.z),l.w=(s[1]-s[4])/(4*l.z));break;case yt.EULER_ANGLES:h=s[0]+s[5]+s[10],h>0?(t.w=Math.sqrt(1+h)/2,t.x=(s[6]-s[9])/(4*t.w),t.y=(s[8]-s[2])/(4*t.w),t.z=(s[1]-s[4])/(4*t.w)):s[0]>s[5]&&s[0]>s[10]?(t.x=Math.sqrt(1+s[0]-s[5]-s[10])/2,t.w=(s[6]-s[9])/(4*t.x),t.y=(s[1]+s[4])/(4*t.x),t.z=(s[8]+s[2])/(4*t.x)):s[5]>s[10]?(l.y=Math.sqrt(1+s[5]-s[0]-s[10])/2,t.x=(s[1]+s[4])/(4*t.y),t.w=(s[8]-s[2])/(4*t.y),t.z=(s[6]+s[9])/(4*t.y)):(t.z=Math.sqrt(1+s[10]-s[0]-s[5])/2,t.x=(s[8]+s[2])/(4*t.z),t.y=(s[6]+s[9])/(4*t.z),t.w=(s[1]-s[4])/(4*t.z)),t.getEulerAngles(l);break}return r[0]=a,r[1]=l,r[2]=n,r}static getEuler(i,e,t=!0,r){return i||(i=new g),F._getEulerMatrix.makeRotationFromQuaternion(e).makeEuler(i,t,r),i}compose(i,e,t){const r=this.rawData,s=e.x,a=e.y,n=e.z,l=e.w,h=s+s,u=a+a,c=n+n,f=s*h,d=s*u,p=s*c,m=a*u,_=a*c,v=n*c,y=l*h,C=l*u,B=l*c,T=t.x,M=t.y,D=t.z;return r[0]=(1-(m+v))*T,r[1]=(d+B)*T,r[2]=(p-C)*T,r[3]=0,r[4]=(d-B)*M,r[5]=(1-(f+v))*M,r[6]=(_+y)*M,r[7]=0,r[8]=(p+C)*D,r[9]=(_-y)*D,r[10]=(1-(f+m))*D,r[11]=0,r[12]=i.x,r[13]=i.y,r[14]=i.z,r[15]=1,this}deltaTransformVector(i,e){e||(e=new g);let t=this.rawData,r=i.x,s=i.y,a=i.z;return e.x=r*t[0]+s*t[4]+a*t[8],e.y=r*t[1]+s*t[5]+a*t[9],e.z=r*t[2]+s*t[6]+a*t[10],e.w=r*t[3]+s*t[7]+a*t[11],e}identity(){let i=this.rawData;return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}fill(i){let e=this.rawData;e[1]=i,e[2]=i,e[3]=i,e[4]=i,e[6]=i,e[7]=i,e[8]=i,e[9]=i,e[11]=i,e[12]=i,e[13]=i,e[14]=i,e[0]=i,e[5]=i,e[10]=i,e[15]=i}invers33(){let i=this.rawData,e=i[5]*i[10]-i[9]*i[6],t=i[8]*i[6]-i[4]*i[10],r=i[4]*i[9]-i[8]*i[5],s=i[9]*i[2]-i[1]*i[10],a=i[0]*i[10]-i[8]*i[2],n=i[8]*i[1]-i[0]*i[9],l=i[1]*i[6]-i[5]*i[2],h=i[4]*i[2]-i[0]*i[6],u=i[0]*i[5]-i[4]*i[1],c=i[0]*e+i[4]*s+i[8]*l;if(Math.abs(c)>1e-11){let f=1/c;i[0]=f*e,i[4]=f*t,i[8]=f*r,i[1]=f*s,i[5]=f*a,i[9]=f*n,i[2]=f*l,i[6]=f*h,i[10]=f*u}}invert(){let i=this.determinant,e=Math.abs(i)>1e-11,t=this.rawData;if(e){i=1/i;let r=t[0],s=t[4],a=t[8],n=t[12],l=t[1],h=t[5],u=t[9],c=t[13],f=t[2],d=t[6],p=t[10],m=t[14],_=t[3],v=t[7],y=t[11],C=t[15];t[0]=i*(h*(p*C-m*y)-u*(d*C-m*v)+c*(d*y-p*v)),t[1]=-i*(l*(p*C-m*y)-u*(f*C-m*_)+c*(f*y-p*_)),t[2]=i*(l*(d*C-m*v)-h*(f*C-m*_)+c*(f*v-d*_)),t[3]=-i*(l*(d*y-p*v)-h*(f*y-p*_)+u*(f*v-d*_)),t[4]=-i*(s*(p*C-m*y)-a*(d*C-m*v)+n*(d*y-p*v)),t[5]=i*(r*(p*C-m*y)-a*(f*C-m*_)+n*(f*y-p*_)),t[6]=-i*(r*(d*C-m*v)-s*(f*C-m*_)+n*(f*v-d*_)),t[7]=i*(r*(d*y-p*v)-s*(f*y-p*_)+a*(f*v-d*_)),t[8]=i*(s*(u*C-c*y)-a*(h*C-c*v)+n*(h*y-u*v)),t[9]=-i*(r*(u*C-c*y)-a*(l*C-c*_)+n*(l*y-u*_)),t[10]=i*(r*(h*C-c*v)-s*(l*C-c*_)+n*(l*v-h*_)),t[11]=-i*(r*(h*y-u*v)-s*(l*y-u*_)+a*(l*v-h*_)),t[12]=-i*(s*(u*m-c*p)-a*(h*m-c*d)+n*(h*p-u*d)),t[13]=i*(r*(u*m-c*p)-a*(l*m-c*f)+n*(l*p-u*f)),t[14]=-i*(r*(h*m-c*d)-s*(l*m-c*f)+n*(l*d-h*f)),t[15]=i*(r*(h*p-u*d)-s*(l*p-u*f)+a*(l*d-h*f))}return e}transformPoint(i,e){let t=this.rawData;e||(e=new g);let r=i.x,s=i.y,a=i.z;return e.x=r*t[0]+s*t[4]+a*t[8]+t[12],e.y=r*t[1]+s*t[5]+a*t[9]+t[13],e.z=r*t[2]+s*t[6]+a*t[10]+t[14],e}transformVector(i,e){let t=this.rawData;e||(e=new g);let r=i.x,s=i.y,a=i.z;return e.x=r*t[0]+s*t[4]+a*t[8],e.y=r*t[1]+s*t[5]+a*t[9],e.z=r*t[2]+s*t[6]+a*t[10],e}transpose(){let i=this.rawData;for(let e=0;e<F.helpMatrix.rawData.length;e++)F.helpMatrix.rawData[e]=i[e];i[1]=F.helpMatrix.rawData[4],i[2]=F.helpMatrix.rawData[8],i[3]=F.helpMatrix.rawData[12],i[4]=F.helpMatrix.rawData[1],i[6]=F.helpMatrix.rawData[9],i[7]=F.helpMatrix.rawData[13],i[8]=F.helpMatrix.rawData[2],i[9]=F.helpMatrix.rawData[6],i[11]=F.helpMatrix.rawData[14],i[12]=F.helpMatrix.rawData[3],i[13]=F.helpMatrix.rawData[7],i[14]=F.helpMatrix.rawData[11]}get determinant(){let i=this.rawData;return(i[0]*i[5]-i[4]*i[1])*(i[10]*i[15]-i[14]*i[11])-(i[0]*i[9]-i[8]*i[1])*(i[6]*i[15]-i[14]*i[7])+(i[0]*i[13]-i[12]*i[1])*(i[6]*i[11]-i[10]*i[7])+(i[4]*i[9]-i[8]*i[5])*(i[2]*i[15]-i[14]*i[3])-(i[4]*i[13]-i[12]*i[5])*(i[2]*i[11]-i[10]*i[3])+(i[8]*i[13]-i[12]*i[9])*(i[2]*i[7]-i[6]*i[3])}getPosition(i){i||(i=new g);let e=this.rawData;return i.x=e[12],i.y=e[13],i.z=e[14],i}get position(){return this._position.set(this.rawData[12],this.rawData[13],this.rawData[14]),this._position}set position(i){let e=this.rawData;e[12]=i.x,e[13]=i.y,e[14]=i.z}get scale(){let i=this.rawData;return new g(i[0],i[5],i[10])}set scale(i){let e=this.rawData;e[0]=i.x,e[5]=i.y,e[10]=i.z}toString(){let i=this.rawData;return"matrix3d("+Math.round(i[0]*1e3)/1e3+","+Math.round(i[1]*1e3)/1e3+","+Math.round(i[2]*1e3)/1e3+","+Math.round(i[3]*1e3)/1e3+","+Math.round(i[4]*1e3)/1e3+","+Math.round(i[5]*1e3)/1e3+","+Math.round(i[6]*1e3)/1e3+","+Math.round(i[7]*1e3)/1e3+","+Math.round(i[8]*1e3)/1e3+","+Math.round(i[9]*1e3)/1e3+","+Math.round(i[10]*1e3)/1e3+","+Math.round(i[11]*1e3)/1e3+","+Math.round(i[12]*1e3)/1e3+","+Math.round(i[13]*1e3)/1e3+","+Math.round(i[14]*1e3)/1e3+","+Math.round(i[15]*1e3)/1e3+")"}lerp(i,e,t){this.copyFrom(e).sub(i).mult(t).add(i)}get(i,e){return this.rawData[i+e*4]}set(i,e,t){this.rawData[i+e*4]=t}getMaxScaleOnAxis(){let i=this.rawData,e=i[0]*i[0]+i[1]*i[1]+i[2]*i[2],t=i[4]*i[4]+i[5]*i[5]+i[6]*i[6],r=i[8]*i[8]+i[9]*i[9]+i[10]*i[10];return Math.sqrt(Math.max(e,t,r))}translate(i){let e=this.get(0,0)*i.x+this.get(0,1)*i.y+this.get(0,2)*i.z+this.get(0,3),t=this.get(1,0)*i.x+this.get(1,1)*i.y+this.get(1,2)*i.z+this.get(1,3),r=this.get(2,0)*i.x+this.get(2,1)*i.y+this.get(2,2)*i.z+this.get(2,3),s=this.get(3,0)*i.x+this.get(3,1)*i.y+this.get(3,2)*i.z+this.get(3,3);return this.set(0,3,e),this.set(1,3,t),this.set(2,3,r),this.set(3,3,s),this}setTRInverse(i,e){e=e.inverse(),q.quaternionToMatrix(e,this),this.translate(new g(-i.x,-i.y,-i.z))}setScale(i){return this.set(0,0,i.x),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,i.y),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,i.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}makeBasis(i,e,t){return this.setElements(i.x,e.x,t.x,0,i.y,e.y,t.y,0,i.z,e.z,t.z,0,0,0,0,1),this}makeRotationAxis(i,e){const t=Math.cos(e),r=Math.sin(e),s=1-t,a=i.x,n=i.y,l=i.z,h=s*a,u=s*n;return this.setElements(h*a+t,h*n-r*l,h*l+r*n,0,h*n+r*l,u*n+t,u*l-r*a,0,h*l-r*n,u*l+r*a,s*l*l+t,0,0,0,0,1),this}static transpose(i,e){e||(e=new F);let t=i.rawData,r=e.rawData;return r[0]=t[0],r[1]=t[4],r[2]=t[8],r[3]=t[12],r[4]=t[1],r[5]=t[5],r[6]=t[9],r[7]=t[13],r[8]=t[2],r[9]=t[6],r[10]=t[10],r[11]=t[14],r[12]=t[3],r[13]=t[7],r[14]=t[11],r[15]=t[15],e}static inverse(i,e){e||(e=new F);let t=i.rawData,r=e.rawData;r[0]=t[5]*t[10]*t[15]-t[5]*t[14]*t[11]-t[6]*t[9]*t[15]+t[6]*t[13]*t[11]+t[7]*t[9]*t[14]-t[7]*t[13]*t[10],r[1]=-t[1]*t[10]*t[15]+t[1]*t[14]*t[11]+t[2]*t[9]*t[15]-t[2]*t[13]*t[11]-t[3]*t[9]*t[14]+t[3]*t[13]*t[10],r[2]=t[1]*t[6]*t[15]-t[1]*t[14]*t[7]-t[2]*t[5]*t[15]+t[2]*t[13]*t[7]+t[3]*t[5]*t[14]-t[3]*t[13]*t[6],r[3]=-t[1]*t[6]*t[11]+t[1]*t[10]*t[7]+t[2]*t[5]*t[11]-t[2]*t[9]*t[7]-t[3]*t[5]*t[10]+t[3]*t[9]*t[6],r[4]=-t[4]*t[10]*t[15]+t[4]*t[14]*t[11]+t[6]*t[8]*t[15]-t[6]*t[12]*t[11]-t[7]*t[8]*t[14]+t[7]*t[12]*t[10],r[5]=t[0]*t[10]*t[15]-t[0]*t[14]*t[11]-t[2]*t[8]*t[15]+t[2]*t[12]*t[11]+t[3]*t[8]*t[14]-t[3]*t[12]*t[10],r[6]=-t[0]*t[6]*t[15]+t[0]*t[14]*t[7]+t[2]*t[4]*t[15]-t[2]*t[12]*t[7]-t[3]*t[4]*t[14]+t[3]*t[12]*t[6],r[7]=t[0]*t[6]*t[11]-t[0]*t[10]*t[7]-t[2]*t[4]*t[11]+t[2]*t[8]*t[7]+t[3]*t[4]*t[10]-t[3]*t[8]*t[6],r[8]=t[4]*t[9]*t[15]-t[4]*t[13]*t[11]-t[5]*t[8]*t[15]+t[5]*t[12]*t[11]+t[7]*t[8]*t[13]-t[7]*t[12]*t[9],r[9]=-t[0]*t[9]*t[15]+t[0]*t[13]*t[11]+t[1]*t[8]*t[15]-t[1]*t[12]*t[11]-t[3]*t[8]*t[13]+t[3]*t[12]*t[9],r[10]=t[0]*t[5]*t[15]-t[0]*t[13]*t[7]-t[1]*t[4]*t[15]+t[1]*t[12]*t[7]+t[3]*t[4]*t[13]-t[3]*t[12]*t[5],r[11]=-t[0]*t[5]*t[11]+t[0]*t[9]*t[7]+t[1]*t[4]*t[11]-t[1]*t[8]*t[7]-t[3]*t[4]*t[9]+t[3]*t[8]*t[5],r[12]=-t[4]*t[9]*t[14]+t[4]*t[13]*t[10]+t[5]*t[8]*t[14]-t[5]*t[12]*t[10]-t[6]*t[8]*t[13]+t[6]*t[12]*t[9],r[13]=t[0]*t[9]*t[14]-t[0]*t[13]*t[10]-t[1]*t[8]*t[14]+t[1]*t[12]*t[10]+t[2]*t[8]*t[13]-t[2]*t[12]*t[9],r[14]=-t[0]*t[5]*t[14]+t[0]*t[13]*t[6]+t[1]*t[4]*t[14]-t[1]*t[12]*t[6]-t[2]*t[4]*t[13]+t[2]*t[12]*t[5],r[15]=t[0]*t[5]*t[10]-t[0]*t[9]*t[6]-t[1]*t[4]*t[10]+t[1]*t[8]*t[6]+t[2]*t[4]*t[9]-t[2]*t[8]*t[5];let s=t[0]*r[0]+t[1]*r[4]+t[2]*r[8]+t[3]*r[12];for(let a=0;a<16;a++)r[a]/=s;return e}makeEuler(i,e,t="XYZ"){const r=this.rawData,s=r[0],a=r[4],n=r[8],l=r[1],h=r[5],u=r[9],c=r[2],f=r[6],d=r[10];switch(t){case"XYZ":i.y=Math.asin(K(n,-1,1)),Math.abs(n)<.9999999?(i.x=Math.atan2(-u,d),i.z=Math.atan2(-a,s)):(i.x=Math.atan2(f,h),i.z=0);break;case"YXZ":i.x=Math.asin(-K(u,-1,1)),Math.abs(u)<.9999999?(i.y=Math.atan2(n,d),i.z=Math.atan2(l,h)):(i.y=Math.atan2(-c,s),i.z=0);break;case"ZXY":i.x=Math.asin(K(f,-1,1)),Math.abs(f)<.9999999?(i.y=Math.atan2(-c,d),i.z=Math.atan2(-a,h)):(i.y=0,i.z=Math.atan2(l,s));break;case"ZYX":i.y=Math.asin(-K(c,-1,1)),Math.abs(c)<.9999999?(i.x=Math.atan2(f,d),i.z=Math.atan2(l,s)):(i.x=0,i.z=Math.atan2(-a,h));break;case"YZX":i.z=Math.asin(K(l,-1,1)),Math.abs(l)<.9999999?(i.x=Math.atan2(-u,h),i.y=Math.atan2(-c,s)):(i.x=0,i.y=Math.atan2(n,d));break;case"XZY":i.z=Math.asin(-K(a,-1,1)),Math.abs(a)<.9999999?(i.x=Math.atan2(f,h),i.y=Math.atan2(n,s)):(i.x=Math.atan2(-u,d),i.y=0);break}return e&&i.multiplyScalar(qi),i}setElements(i,e,t,r,s,a,n,l,h,u,c,f,d,p,m,_){const v=this.rawData;return v[0]=i,v[4]=e,v[8]=t,v[12]=r,v[1]=s,v[5]=a,v[9]=n,v[13]=l,v[2]=h,v[6]=u,v[10]=c,v[14]=f,v[3]=d,v[7]=p,v[11]=m,v[15]=_,this}makeMatrix44ByQuaternion(i,e,t){this.identity(),q.quaternionToMatrix(t,this),this.appendTranslation(i.x,i.y,i.z),this.appendScale(e.x,e.y,e.z)}};let V=F;o(V,"blockBytes",16*4),o(V,"block",16),o(V,"allocCount",1e3),o(V,"allocOnceCount",1e3),o(V,"maxCount",50*1e4),o(V,"useCount",0),o(V,"buffer"),o(V,"wasmMatrixPtr",0),o(V,"dynamicMatrixBytes"),o(V,"dynamicGlobalMatrixRef"),o(V,"wasm"),o(V,"help_matrix_0"),o(V,"help_matrix_1"),o(V,"help_matrix_2"),o(V,"helpMatrix"),o(V,"helpMatrix2"),o(V,"_getEulerMatrix"),o(V,"_zero",new g(0,0,0)),o(V,"_one",new g(1,1,1)),o(V,"_prs",[new g,new g,new g]),o(V,"float32Array",new Float32Array(16).fill(0)),o(V,"decomposeRawData",new Float32Array(16).fill(0));function _l(i,e,t){for(let r=0;r<4;r++)t.rawData[r]=i.rawData[r]*e.rawData[0]+i.rawData[r+4]*e.rawData[1]+i.rawData[r+8]*e.rawData[2]+i.rawData[r+12]*e.rawData[3],t.rawData[r+4]=i.rawData[r]*e.rawData[4]+i.rawData[r+4]*e.rawData[5]+i.rawData[r+8]*e.rawData[6]+i.rawData[r+12]*e.rawData[7],t.rawData[r+8]=i.rawData[r]*e.rawData[8]+i.rawData[r+4]*e.rawData[9]+i.rawData[r+8]*e.rawData[10]+i.rawData[r+12]*e.rawData[11],t.rawData[r+12]=i.rawData[r]*e.rawData[12]+i.rawData[r+4]*e.rawData[13]+i.rawData[r+8]*e.rawData[14]+i.rawData[r+12]*e.rawData[15]}function Rs(i,e,t,r){let s=r.rawData,a=i.x*_e,n=i.y*_e,l=i.z*_e,h=0,u=a*.5,c=n*.5,f=l*.5,d=Math.cos(u),p=Math.sin(u),m=Math.cos(c),_=Math.sin(c),v=Math.cos(f),y=Math.sin(f);h=d*m*v+p*_*y,a=p*m*v-d*_*y,n=d*_*v+p*m*y,l=d*m*y-p*_*v;let C=a+a,B=n+n,T=l+l,M=a*C,D=a*B,P=a*T,L=n*B,I=n*T,O=l*T,k=h*C,H=h*B,W=h*T,ne=t.x,fe=t.y,we=t.z;s[0]=(1-(L+O))*ne,s[1]=(D+W)*ne,s[2]=(P-H)*ne,s[3]=0,s[4]=(D-W)*fe,s[5]=(1-(M+O))*fe,s[6]=(I+k)*fe,s[7]=0,s[8]=(P+H)*we,s[9]=(I-k)*we,s[10]=(1-(M+L))*we,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1}function xl(i,e,t){let r=i.rawData,s=t.rawData,a=r[0],n=r[4],l=r[8],h=r[12],u=r[1],c=r[5],f=r[9],d=r[13],p=r[2],m=r[6],_=r[10],v=r[14],y=r[3],C=r[7],B=r[11],T=r[15];s[0]=a*e.rawData[0]+u*e.rawData[4]+p*e.rawData[8]+y*e.rawData[12],s[1]=a*e.rawData[1]+u*e.rawData[5]+p*e.rawData[9]+y*e.rawData[13],s[2]=a*e.rawData[2]+u*e.rawData[6]+p*e.rawData[10]+y*e.rawData[14],s[3]=a*e.rawData[3]+u*e.rawData[7]+p*e.rawData[11]+y*e.rawData[15],s[4]=n*e.rawData[0]+c*e.rawData[4]+m*e.rawData[8]+C*e.rawData[12],s[5]=n*e.rawData[1]+c*e.rawData[5]+m*e.rawData[9]+C*e.rawData[13],s[6]=n*e.rawData[2]+c*e.rawData[6]+m*e.rawData[10]+C*e.rawData[14],s[7]=n*e.rawData[3]+c*e.rawData[7]+m*e.rawData[11]+C*e.rawData[15],s[8]=l*e.rawData[0]+f*e.rawData[4]+_*e.rawData[8]+B*e.rawData[12],s[9]=l*e.rawData[1]+f*e.rawData[5]+_*e.rawData[9]+B*e.rawData[13],s[10]=l*e.rawData[2]+f*e.rawData[6]+_*e.rawData[10]+B*e.rawData[14],s[11]=l*e.rawData[3]+f*e.rawData[7]+_*e.rawData[11]+B*e.rawData[15],s[12]=h*e.rawData[0]+d*e.rawData[4]+v*e.rawData[8]+T*e.rawData[12],s[13]=h*e.rawData[1]+d*e.rawData[5]+v*e.rawData[9]+T*e.rawData[13],s[14]=h*e.rawData[2]+d*e.rawData[6]+v*e.rawData[10]+T*e.rawData[14],s[15]=h*e.rawData[3]+d*e.rawData[7]+v*e.rawData[11]+T*e.rawData[15]}function Dd(i,e){let t=e.x,r=e.y,s=e.z,a=e.w,n=i.rawData,l=2*t*r,h=2*t*s,u=2*t*a,c=2*r*s,f=2*r*a,d=2*s*a,p=t*t,m=r*r,_=s*s,v=a*a;return n[0]=p-m-_+v,n[4]=l-d,n[8]=h+f,n[12]=0,n[1]=l+d,n[5]=-p+m-_+v,n[9]=c-u,n[13]=0,n[2]=h-f,n[6]=c+u,n[10]=-p-m+_+v,n[14]=0,n[3]=0,n[7]=0,n[11]=0,n[15]=1,i}function Pd(i,e){let t=e.rawData,r=Math.sin(i),s=Math.cos(i);return t[0]=s,t[1]=0,t[2]=-r,t[3]=0,t[8]=r,t[9]=0,t[10]=s,t[11]=0,t}function Rd(i,e,t){let r=e.x,s=e.y,a=e.z,n=Math.hypot(r,s,a),l,h,u,c,f,d,p,m,_,v,y,C;if(n<Md)return null;n=1/n,r*=n,s*=n,a*=n,l=Math.sin(i),h=Math.cos(i),u=1-h,c=r*r*u+h,f=s*r*u+a*l,d=a*r*u-s*l,p=r*s*u-a*l,m=s*s*u+h,_=a*s*u+r*l,v=r*a*u+s*l,y=s*a*u-r*l,C=a*a*u+h;let B=t.rawData;return B[0]=c,B[1]=f,B[2]=d,B[3]=0,B[4]=p,B[5]=m,B[6]=_,B[7]=0,B[8]=v,B[9]=y,B[10]=C,B[11]=0,B[12]=0,B[13]=0,B[14]=0,B[15]=1,B}function so(i,e,t){let r=i.rawData,s=r[0],a=r[1],n=r[2],l=r[3],h=r[4],u=r[5],c=r[6],f=r[7],d=r[8],p=r[9],m=r[10],_=r[11],v=r[12],y=r[13],C=r[14],B=r[15],T=e.rawData,M=t.rawData,D=T[0],P=T[1],L=T[2],I=T[3];return M[0]=D*s+P*h+L*d+I*v,M[1]=D*a+P*u+L*p+I*y,M[2]=D*n+P*c+L*m+I*C,M[3]=D*l+P*f+L*_+I*B,D=T[4],P=T[5],L=T[6],I=T[7],M[4]=D*s+P*h+L*d+I*v,M[5]=D*a+P*u+L*p+I*y,M[6]=D*n+P*c+L*m+I*C,M[7]=D*l+P*f+L*_+I*B,D=T[8],P=T[9],L=T[10],I=T[11],M[8]=D*s+P*h+L*d+I*v,M[9]=D*a+P*u+L*p+I*y,M[10]=D*n+P*c+L*m+I*C,M[11]=D*l+P*f+L*_+I*B,D=T[12],P=T[13],L=T[14],I=T[15],M[12]=D*s+P*h+L*d+I*v,M[13]=D*a+P*u+L*p+I*y,M[14]=D*n+P*c+L*m+I*C,M[15]=D*l+P*f+L*_+I*B,M}var Qe=(i=>(i[i.None=0]="None",i[i.PointLight=1]="PointLight",i[i.DirectionLight=2]="DirectionLight",i[i.SpotLight=3]="SpotLight",i[i.SkyLight=4]="SkyLight",i))(Qe||{});class Gr extends wi{constructor(){super(...arguments),o(this,"index",-1),o(this,"lightType",-1),o(this,"radius",.5),o(this,"linear",1),o(this,"lightPosition",new g),o(this,"lightMatrixIndex",-1),o(this,"direction",new g),o(this,"quadratic",.032),o(this,"lightColor",new z(1,1,1,1)),o(this,"intensity",1),o(this,"innerAngle",0),o(this,"outerAngle",1),o(this,"range",100),o(this,"castShadowIndex",-1),o(this,"lightTangent",g.FORWARD),o(this,"iesIndex",-1)}}o(Gr,"lightSize",24);const vl=class{static init(){this._init||(this._init=!0,this.componentsUpdateList=new Map,this.componentsLateUpdateList=new Map,this.componentsBeforeUpdateList=new Map,this.componentsComputeList=new Map,this.componentsEnablePickerList=new Map,this.graphicComponent=new Map,this.waitStartComponent=new Map)}static bindUpdate(i,e,t){this.init();let r=this.componentsUpdateList.get(i);r||(r=new Map,this.componentsUpdateList.set(i,r)),r.set(e,t)}static unBindUpdate(i,e){this.init();let t=this.componentsUpdateList.get(i);t&&t.delete(e)}static bindLateUpdate(i,e,t){this.init();let r=this.componentsLateUpdateList.get(i);r||(r=new Map,this.componentsLateUpdateList.set(i,r)),r.set(e,t)}static unBindLateUpdate(i,e){this.init();let t=this.componentsLateUpdateList.get(i);t&&t.delete(e)}static bindBeforeUpdate(i,e,t){this.init();let r=this.componentsBeforeUpdateList.get(i);r||(r=new Map,this.componentsBeforeUpdateList.set(i,r)),r.set(e,t)}static unBindBeforeUpdate(i,e){this.init();let t=this.componentsBeforeUpdateList.get(i);t&&t.delete(e)}static bindCompute(i,e,t){this.init();let r=this.componentsComputeList.get(i);r||(r=new Map,this.componentsComputeList.set(i,r)),r.set(e,t)}static unBindCompute(i,e){this.init();let t=this.componentsComputeList.get(i);t&&t.delete(e)}static bindGraphic(i,e,t){this.init();let r=this.graphicComponent.get(i);r||(r=new Map,this.graphicComponent.set(i,r)),r.set(e,t)}static unBindGraphic(i,e){this.init();let t=this.graphicComponent.get(i);t&&t.delete(e)}static appendWaitStart(i){this.init();let e=this.waitStartComponent.get(i.object3D);e?e.indexOf(i)==-1&&e.push(i):this.waitStartComponent.set(i.object3D,[i])}static removeWaitStart(i,e){this.init();let t=vl.waitStartComponent.get(i);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r)}}static bindEnablePick(i,e,t){this.init();let r=this.componentsEnablePickerList.get(i);r||(r=new Map,this.componentsEnablePickerList.set(i,r)),r.set(e,t)}static unBindEnablePick(i,e){this.init();let t=this.componentsEnablePickerList.get(i);t&&t.delete(e)}};let ae=vl;o(ae,"componentsUpdateList"),o(ae,"componentsLateUpdateList"),o(ae,"componentsBeforeUpdateList"),o(ae,"componentsComputeList"),o(ae,"componentsEnablePickerList"),o(ae,"graphicComponent"),o(ae,"waitStartComponent"),o(ae,"_init",!1);class Ee{constructor(){o(this,"object3D",null),o(this,"_eventDispatcher"),o(this,"_enable",!0),o(this,"__isStart",!1),o(this,"isDestroyed")}get eventDispatcher(){return this._eventDispatcher||(this._eventDispatcher=new hi),this._eventDispatcher}set eventDispatcher(e){console.error("The eventDispatcher should not be set externally!")}get isStart(){return this.__isStart}get transform(){return this.object3D.transform}set enable(e){var t,r;this._enable!=e&&(this._enable=e,this._enable?(t=this.onEnable)==null||t.call(this,this.transform.view3D):(r=this.onDisable)==null||r.call(this,this.transform.view3D))}get enable(){return this._enable}__init(e){this.init(e)}__start(){var e,t;this.transform&&this.transform.scene3D&&this._enable&&((e=this.onEnable)==null||e.call(this,this.transform.view3D)),this.transform&&this.transform.scene3D&&this.__isStart==!1&&((t=this.start)==null||t.call(this),this.__isStart=!0),this.onUpdate&&this._onUpdate(this.onUpdate.bind(this)),this.onLateUpdate&&this._onLateUpdate(this.onLateUpdate.bind(this)),this.onBeforeUpdate&&this._onBeforeUpdate(this.onBeforeUpdate.bind(this)),this.onCompute&&this._onCompute(this.onCompute.bind(this)),this.onGraphic&&this._onGraphic(this.onGraphic.bind(this))}__stop(){var e;this.transform&&this.transform.scene3D&&((e=this.onDisable)==null||e.call(this,this.transform.view3D)),this._onUpdate(null),this._onLateUpdate(null),this._onBeforeUpdate(null),this._onCompute(null),this._onGraphic(null)}init(e){}start(){}stop(){}cloneTo(e){}copyComponent(e){return this}_onUpdate(e){e!=null?ae.bindUpdate(this.transform.view3D,this,e):ae.unBindUpdate(this.transform.view3D,this)}_onLateUpdate(e){e!=null?ae.bindLateUpdate(this.transform.view3D,this,e):ae.unBindLateUpdate(this.transform.view3D,this)}_onBeforeUpdate(e){e!=null?ae.bindBeforeUpdate(this.transform.view3D,this,e):ae.unBindBeforeUpdate(this.transform.view3D,this)}_onCompute(e){e!=null?ae.bindCompute(this.transform.view3D,this,e):ae.unBindCompute(this.transform.view3D,this)}_onGraphic(e){e!=null?ae.bindGraphic(this.transform.view3D,this,e):ae.unBindGraphic(this.transform.view3D,this)}beforeDestroy(e){ae.removeWaitStart(this.object3D,this)}destroy(e){this.isDestroyed||(this.isDestroyed=!0,this.enable=!1,this.stop(),this._onBeforeUpdate(null),this._onUpdate(null),this._onLateUpdate(null),this.onEnable=null,this.onDisable=null,this.onUpdate=null,this.onLateUpdate=null,this.onBeforeUpdate=null,this.onCompute=null,this.onGraphic=null)}}class Ls{constructor(){o(this,"value",0),o(this,"inv_base",0)}static get(e,t){let r=0,s=1/t;for(;e>0;)r+=e%t*s,e/=t,s/=t;return r}getBase(e,t){let r=this.inv_base=1/t;for(;e>0;)this.value+=r*(e%t),e/=t,r*=this.inv_base}next(){let e=1-this.value-1e-7;if(this.inv_base<e)this.value+=this.inv_base;else{let t=this.inv_base,r;do r=t,t*=this.inv_base;while(t>=e);this.value+=r+t-1}}get(){return this.value}}const Ji=class{constructor(i,e){o(this,"origin",new g),o(this,"length",Number.MAX_VALUE),o(this,"_vector",new g),o(this,"_dir",new g),o(this,"_v0",new g),o(this,"_v1",new g),o(this,"_v2",new g),o(this,"_E1",new g),o(this,"_E2",new g),o(this,"_P",new g),o(this,"_T",new g),o(this,"_Q",new g),this.origin.copyFrom(i||new g),this._dir.copyFrom(e||new g),this._dir.normalize()}get direction(){return this._dir}set direction(i){this._dir.copyFrom(i),this._dir.normalize()}clone(){return new Ji(this.origin,this.direction)}intersectBox(i,e){let t=this.direction,r=this.origin,s,a,n,l,h,u;const c=1/t.x,f=1/t.y,d=1/t.z,p=i.min,m=i.max;return s=((c>=0?p.x:m.x)-r.x)*c,a=((c>=0?m.x:p.x)-r.x)*c,n=((f>=0?p.y:m.y)-r.y)*f,l=((f>=0?m.y:p.y)-r.y)*f,s>l||n>a||(n>s&&(s=n),l<a&&(a=l),h=((d>=0?p.z:m.z)-r.z)*d,u=((d>=0?m.z:p.z)-r.z)*d,s>u||h>a)||(h>s&&(s=h),u<a&&(a=u),a<0)?null:(e||(e=new g),this.pointAt(s>=0?s:a,e))}pointAt(i,e){return e||(e=new g),e.copy(this.direction),e.multiplyScalar(i),e.add(this.origin,e),e}copy(i){return this.origin.copy(i.origin),this.direction.copy(i.direction),this._dir.copy(i._dir),this.length=i.length,this}setApproxDirection(i){this._dir=i.normalize()}setOrigin(i){this.origin.copyFrom(i)}getOrigin(){return this.origin}getPoint(i){return this._dir.scaleBy(i),this.origin.add(this._dir)}sqrDistToPoint(i){let e=this._dir,t=i.subtract(this.origin),r=et(t,e),s=et(e,e),a=r/s,n=this.getPoint(a);return io(i.subtract(n))}applyMatrix(i){this.origin=i.transformPoint(this.origin),this._dir=i.transformVector(this._dir)}pointInTriangle(i,e,t,r){let s=this._v0,a=this._v1,n=this._v2;r.subtract(e,s),t.subtract(e,a),i.subtract(e,n);let l=g.dot(s,s),h=g.dot(s,a),u=g.dot(s,n),c=g.dot(a,a),f=g.dot(a,n),d=1/(l*c-h*h),p=(c*u-h*f)*d,m=(l*f-h*u)*d;return p>=0&&m>=0&&p+m<1}intersectTriangle(i,e,t){let r=t.v1,s=t.v2,a=t.v3;s.subtract(r,this._E1),a.subtract(r,this._E2),e.crossProduct(this._E2,this._P);let n=this._E1.dotProduct(this._P);if(n>0?i.subtract(r,this._T):(r.subtract(i,this._T),n=-n),n<1e-4||(t.u=this._T.dotProduct(this._P),t.u<0||t.u>n)||(this._T.crossProduct(this._E1,this._Q),t.v=e.dotProduct(this._Q),t.v<0||t.u+t.v>n))return null;let l=new g;t.t0=t.t=this._E2.dotProduct(this._Q);let h=1/n;return t.t*=h,t.u*=h,t.v*=h,l.x=i.x+t.t*e.x,l.y=i.y+t.t*e.y,l.z=i.z+t.t*e.z,l}intersectSphere(i,e,t,r){let s=i.subtract(t),a=g.dot(e,e),n=2*g.dot(s,e),l=g.dot(s,s)-r*r,h=n*n-4*a*l,u=g.HELP_3;if(h<0)return null;{let c=(-n-Math.sqrt(h))/(a*2);return c<0?null:(u.x=i.x+c*e.x,u.y=i.y+c*e.y,u.z=i.z+c*e.z,u)}}intersectionSegment(i,e,t){const r=this.origin,s=g.HELP_0,a=g.HELP_1,n=g.HELP_2,l=g.HELP_3;e.subtract(i,s),this._dir.scaleToRef(Ji._rayl,n),r.add(n,a),i.subtract(r,l);var h=g.dot(s,s),u=g.dot(s,n),c=g.dot(n,n),f=g.dot(s,l),d=g.dot(n,l),p=h*c-u*u,m,_,v=p,y,C,B=p;p<Ji._smallnum?(_=0,v=1,C=d,B=c):(_=u*d-c*f,C=h*d-u*f,_<0?(_=0,C=d,B=c):_>v&&(_=v,C=d+u,B=c)),C<0?(C=0,-f<0?_=0:-f>h?_=v:(_=-f,v=h)):C>B&&(C=B,-f+u<0?_=0:-f+u>h?_=v:(_=-f+u,v=h)),m=Math.abs(_)<Ji._smallnum?0:_/v,y=Math.abs(C)<Ji._smallnum?0:C/B;const T=g.HELP_4;n.scaleToRef(y,T);const M=g.HELP_5;s.scaleToRef(m,M),M.add(l,M);const D=g.HELP_6;M.subtract(T,D);var P=y>0&&y<=this._dir.length&&D.lengthSquared<t*t;if(P){let L=new g;return L.copyFrom(e.subtract(i)),L.scaleBy(m),L.add(i,L),{out:L,length:M.length}}return{out:null,length:-1}}get_vec(i,e){let t=g.HELP_1;return t.x=i.x-e.x,t.y=i.y-e.y,t.z=i.z-e.z,t}};let ci=Ji;o(ci,"_rayl",1e9),o(ci,"_smallnum",1e-8);class bs{constructor(e=0,t=0,r=0,s=0){o(this,"x"),o(this,"y"),o(this,"w"),o(this,"h"),this.x=e,this.y=t,this.w=r,this.h=s}get width(){return this.w}set width(e){this.w=e}get height(){return this.h}set height(e){this.h=e}static pointInRect(e,t,r,s,a,n){return!(e<r||e>a||t<s||t>n)}clone(){return new bs(this.x,this.y,this.w,this.h)}copyFrom(e){this.x=e.x,this.y=e.y,this.w=e.w,this.h=e.h}copyTo(e){e.copyFrom(this)}inner(e,t){return!(e<this.x||e>this.x+this.width||t<this.y||t>this.y+this.height)}equal(e){return!(this.x!=e.x||this.y!=e.y||this.width!=e.width||this.height!=e.height)}equalArea(e,t,r,s){return!(this.x!=e||this.y!=t||this.width!=r||this.height!=s)}equalInnerArea(e){var t=this.x,r=this.y,s=this.x+this.width,a=this.y+this.height,n=e.x,l=e.y,h=e.x+e.width,u=e.y+e.height;return Math.max(t,n)<=Math.min(s,h)&&Math.max(r,l)<=Math.min(a,u)}innerArea(e,t){t=t||new bs;var r=this.x,s=this.y,a=this.x+this.width,n=this.y+this.height,l=e.x,h=e.y,u=e.x+e.width,c=e.y+e.height,f=Math.max(s,h),d=Math.min(n,c),p=Math.max(r,l),m=Math.min(u,a);return f>=0&&d>=0&&d-f>=0&&m-p>0?(t.x=p,t.y=f,t.width=m-p,t.height=d-f):(t.x=0,t.y=0,t.width=0,t.height=0),t}setTo(e,t,r,s){this.x=e,this.y=t,this.width=r,this.height=s}}const Qr=class{constructor(i,e){o(this,"center"),o(this,"extents"),o(this,"max"),o(this,"min"),o(this,"size"),i||(i=g.ZERO.clone()),e||(e=g.ZERO.clone()),this.setFromCenterAndSize(i,e)}makeEmpty(){return this.setFromMinMax(Qr.maxVector3,Qr.minVector3),this}setFromMinMax(i,e){return this.init(),e.subtract(i,this.size),i.add(e,this.center).multiplyScalar(.5),this.extents.copyFrom(this.size).multiplyScalar(.5),this.min.copyFrom(i),this.max.copyFrom(e),this}init(){return this.min||(this.min=new g),this.max||(this.max=new g),this.size||(this.size=new g),this.center||(this.center=new g),this.extents||(this.extents=new g),this}setFromCenterAndSize(i,e){return this.size=e,this.center=i,this.init(),this.extents.copy(e).multiplyScalar(.5),this.center.subtract(this.extents,this.min),this.center.add(this.extents,this.max),this}inFrustum(i,e){return e.containsBox(i.bound)}merge(i){i.min.x<this.min.x&&(this.min.x=i.min.x),i.min.y<this.min.y&&(this.min.y=i.min.y),i.min.z<this.min.z&&(this.min.z=i.min.z),i.max.x>this.max.x&&(this.max.x=i.max.x),i.max.y>this.max.y&&(this.max.y=i.max.y),i.max.z>this.max.z&&(this.max.z=i.max.z),this.size.x=i.max.x-i.min.x,this.size.y=i.max.y-i.min.y,this.size.z=i.max.z-i.min.z,this.extents.x=this.size.x*.5,this.extents.y=this.size.y*.5,this.extents.z=this.size.z*.5,this.center.x=this.extents.x+i.min.x,this.center.y=this.extents.y+i.min.y,this.center.z=this.extents.z+i.min.z}intersects(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}intersectsSphere(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}intersectsBox(i){return this.min.x<=i.max.x&&this.max.x>=i.min.x&&this.min.y<=i.max.y&&this.max.y>=i.min.y&&this.min.z<=i.max.z&&this.max.z>=i.min.z}equals(i){return this.center.equals(i.center)&&this.extents.equals(i.extents)}expandByPoint(i){i.x<this.min.x&&(this.min.x=i.x),i.x>this.max.x&&(this.max.x=i.x),i.y<this.min.y&&(this.min.y=i.y),i.y>this.max.y&&(this.max.y=i.y),i.z<this.min.z&&(this.min.z=i.z),i.z>this.max.z&&(this.max.z=i.z)}static fromPoints(i){for(var e=new Qr(new g,new g),t=0;t<i.length;t++)e.expandByPoint(i[t]);return e}calculateTransform(i){}clone(){var i=new Qr(this.center.clone(),this.size.clone());return i}intersectsRay(i,e){throw new Error("Method not implemented.")}containsPoint(i){return this.min.x<=i.x&&this.max.x>=i.x&&this.min.y<=i.y&&this.max.y>=i.y&&this.min.z<=i.z&&this.max.z>=i.z}containsBox(i){let e=this.min,t=this.max;return e.x<=i.min.x&&e.y<=i.min.y&&e.z<=i.min.z&&t.x>=i.max.x&&t.y>=i.max.y&&t.z>=i.max.z}updateBound(){}destroy(i){this.center=null,this.extents=null,this.min=null,this.max=null,this.size=null}};let Be=Qr;o(Be,"maxVector3",new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1)),o(Be,"minVector3",new g(1,1,1).multiplyScalar(-Number.MAX_VALUE*.1));class yl{constructor(){o(this,"planes"),o(this,"corners"),o(this,"boundingBox",new Be),this.planes=[],this.corners=[];for(var e=0;e<6;e++)this.planes[e]=new g;for(var e=0;e<2*2*2;e++)this.corners[e]=new g}updateBoundBox(e){this.boundingBox.makeEmpty();let t=this.boundingBox.min,r=this.boundingBox.max,s=0;for(let a=0;a<2;++a)for(let n=0;n<2;++n)for(let l=0;l<2;++l){let h=this.corners[s];s++,h.set(2*a-1,2*n-1,l,1),e.transformVector4(h,h),h.div(h.w,h),t.x=Math.min(h.x,t.x),t.y=Math.min(h.y,t.y),t.z=Math.min(h.z,t.z),r.x=Math.max(h.x,r.x),r.y=Math.max(h.y,r.y),r.z=Math.max(h.z,r.z)}return this.boundingBox.setFromMinMax(t,r),this}setFrustumCorners(e){let t=0;for(let r=0;r<2;++r)for(let s=0;s<2;++s)for(let a=0;a<2;++a){let n=this.corners[t];n.set(2*r-1,2*s-1,a,1),e.transformVector4(n,n),n.div(n.w,n),t++}}update(e){var t=e.rawData;this.planes[0].x=t[3]-t[0],this.planes[0].y=t[7]-t[4],this.planes[0].z=t[11]-t[8],this.planes[0].w=t[15]-t[12];var r=Math.sqrt(this.planes[0].x*this.planes[0].x+this.planes[0].y*this.planes[0].y+this.planes[0].z*this.planes[0].z);this.planes[0].x/=r,this.planes[0].y/=r,this.planes[0].z/=r,this.planes[0].w/=r,this.planes[1].x=t[3]+t[0],this.planes[1].y=t[7]+t[4],this.planes[1].z=t[11]+t[8],this.planes[1].w=t[15]+t[12],r=Math.sqrt(this.planes[1].x*this.planes[1].x+this.planes[1].y*this.planes[1].y+this.planes[1].z*this.planes[1].z),this.planes[1].x/=r,this.planes[1].y/=r,this.planes[1].z/=r,this.planes[1].w/=r,this.planes[2].x=t[3]+t[1],this.planes[2].y=t[7]+t[5],this.planes[2].z=t[11]+t[9],this.planes[2].w=t[15]+t[13],r=Math.sqrt(this.planes[2].x*this.planes[2].x+this.planes[2].y*this.planes[2].y+this.planes[2].z*this.planes[2].z),this.planes[2].x/=r,this.planes[2].y/=r,this.planes[2].z/=r,this.planes[2].w/=r,this.planes[3].x=t[3]-t[1],this.planes[3].y=t[7]-t[5],this.planes[3].z=t[11]-t[9],this.planes[3].w=t[15]-t[13],r=Math.sqrt(this.planes[3].x*this.planes[3].x+this.planes[3].y*this.planes[3].y+this.planes[3].z*this.planes[3].z),this.planes[3].x/=r,this.planes[3].y/=r,this.planes[3].z/=r,this.planes[3].w/=r,this.planes[4].x=t[3]-t[2],this.planes[4].y=t[7]-t[6],this.planes[4].z=t[11]-t[10],this.planes[4].w=t[15]-t[14],r=Math.sqrt(this.planes[4].x*this.planes[4].x+this.planes[4].y*this.planes[4].y+this.planes[4].z*this.planes[4].z),this.planes[4].x/=r,this.planes[4].y/=r,this.planes[4].z/=r,this.planes[4].w/=r,this.planes[5].x=t[3]+t[2],this.planes[5].y=t[7]+t[6],this.planes[5].z=t[11]+t[10],this.planes[5].w=t[15]+t[14],r=Math.sqrt(this.planes[5].x*this.planes[5].x+this.planes[5].y*this.planes[5].y+this.planes[5].z*this.planes[5].z),this.planes[5].x/=r,this.planes[5].y/=r,this.planes[5].z/=r,this.planes[5].w/=r}containsPoint(e){for(var t=0;t<6;t++)if(this.planes[t].x*e.x+this.planes[t].y*e.y+this.planes[t].z*e.z+this.planes[t].w<=0)return!1;return!0}containsSphere(e){let t=e.bound,r=0,s,a=e.transform.worldPosition,n=t.radius,l=t.center.x+a.x,h=t.center.y+a.y,u=t.center.z+a.z;for(let c of this.planes){if(s=c.x*l+c.y*h+c.z*u+c.w,s<=-n)return 0;s>n&&r++}return r===6?2:1}containsBox(e){let t=0,r,a=Math.max(e.size.x,e.size.y,e.size.z)*2,n=e.center.x,l=e.center.y,h=e.center.z;for(let u of this.planes){if(r=u.x*n+u.y*l+u.z*h+u.w,r<=-a)return 0;r>a&&t++}return t===6?2:1}containsBox2(e){let t=0,r,s=1.74*Math.max(e.extents.x,e.extents.y,e.extents.z);for(let a of this.planes){if(r=a.x*e.center.x+a.y*e.center.y+a.z*e.center.z+a.w,r<=-s)return 0;r>s&&t++}return t===6?2:1}}var Ie=(i=>(i[i.ortho=0]="ortho",i[i.perspective=1]="perspective",i[i.shadow=2]="shadow",i))(Ie||{});class Ld{constructor(e){o(this,"corners"),o(this,"index"),this.index=e,this.corners=[];for(let t=0;t<4;t++)this.corners.push(new g)}}class Ud{constructor(e,t,r){o(this,"bound"),o(this,"twoSections"),o(this,"name"),o(this,"color"),o(this,"shadowCamera"),o(this,"index"),this.bound=new Be,this.shadowCamera=Ne.createCamera3DObject(null,"csmShadowCamera_"+r),this.shadowCamera.isShadowCamera=!0,this.shadowCamera.orthoOffCenter(100,-100,100,-100,1,1e4),this.twoSections=[e,t],this.index=r,r==0?this.color=new z(1,0,0,1):r==1?this.color=new z(0,1,0,1):r==2?this.color=new z(0,0,1,1):r==3&&(this.color=new z(0,1,1,1)),this.name="child_"+r}updateBound(){this.bound.makeEmpty();let e=this.bound.min,t=this.bound.max;for(let r of this.twoSections)for(let s of r.corners)e.x=Math.min(s.x,e.x),e.y=Math.min(s.y,e.y),e.z=Math.min(s.z,e.z),t.x=Math.max(s.x,t.x),t.y=Math.max(s.y,t.y),t.z=Math.max(s.z,t.z);return this.bound.setFromMinMax(e,t),this}}class Cl{constructor(e){o(this,"sections"),o(this,"children"),o(this,"name"),this.sections=[];let t=e+1;for(let r=0;r<t;r++)this.sections.push(new Ld(r));this.children=[];for(let r=0;r<e;r++)this.children.push(new Ud(this.sections[r],this.sections[r+1],r))}update(e,t,r,s,a){let n=this.sections.length-1;for(let l=0;l<=n;++l){let h=this.sections[l],u=0,c=this.logSplit(r,s,l,this.sections.length);{let d=(c-r)/s;d=d**a.csmScatteringExp,c=(s-r)*d+r}c*=a.csmAreaScale;let f=(e.rawData[10]*c+e.rawData[14])/c;for(let d=0;d<2;++d)for(let p=0;p<2;++p){let m=h.corners[u];u++,m.set(2*d-1,2*p-1,f,1),t.transformVector4(m,m),m.div(m.w,m)}}for(let l of this.children)l.updateBound();return this}squareSplit(e,t,r,s){return(r/(s-1))**4*(t-e)+e}uniformSplit(e,t,r,s){return r/(s-1)*(t-e)+e}logSplit(e,t,r,s){return e*(t/e)**(r/(s-1))}}class Zi extends Ee{constructor(){super(),o(this,"fov",1),o(this,"name"),o(this,"aspect",1),o(this,"near",1),o(this,"far",5e3),o(this,"viewPort",new bs),o(this,"frustum"),o(this,"isShadowCamera",!1),o(this,"_projectionMatrixInv",new V),o(this,"_projectionMatrix",new V),o(this,"_viewMatrix",new V),o(this,"_unprojection",new V),o(this,"_pvMatrixInv",new V),o(this,"_pvMatrix",new V),o(this,"_halfw"),o(this,"_halfh"),o(this,"_ray"),o(this,"_enableCSM",!1),o(this,"lookTarget"),o(this,"type",Ie.perspective),o(this,"csm"),o(this,"cubeShadowCameras",[]),o(this,"_haltonSeq"),o(this,"_jitterOffsetList"),o(this,"_useJitterProjection",!1),o(this,"_jitterFrameIndex",0),o(this,"_sampleIndex",0),o(this,"_jitterX",0),o(this,"_jitterY",0)}get projectionMatrix(){return this._projectionMatrix}get enableCSM(){return this._enableCSM}set enableCSM(e){e&&!this.csm&&(this.csm=new Cl(lt.Cascades)),this._enableCSM=e}init(){super.init(),this._ray=new ci,this.frustum=new yl,this.viewPort.x=0,this.viewPort.y=0,this.viewPort.w=S.presentationSize[0],this.viewPort.h=S.presentationSize[1],this.lookTarget=new g(0,0,0)}getShadowBias(e){let t=2*this.getShadowWorldExtents()/e,r=this.far-this.near;return t/r}getShadowWorldExtents(){let e=A.setting.shadow.shadowBound;return e?e*=.5:e=Math.round(.05*this.frustum.boundingBox.extents.length),e}getCSMShadowBias(e,t){let r=2*this.getCSMShadowWorldExtents(e)/t,s=this.far-this.near;return r/s}getCSMShadowWorldExtents(e){return Math.round(this.csm.children[e].bound.extents.length)}perspective(e,t,r,s){this.fov=e,this.aspect=t,this.near=r,this.far=s,this._projectionMatrix.perspective(e,t,r,s),this.type=Ie.perspective}resetPerspective(e){this.type==Ie.perspective&&this._projectionMatrix.perspective(this.fov,e,this.near,this.far)}ortho(e,t,r,s){this.near=Math.max(r,.1),this.far=s,this._projectionMatrix.ortho(e,t,r,s),this.type=Ie.ortho}orthoOffCenter(e,t,r,s,a,n){this.near=Math.max(a,.01),this.far=n,this._projectionMatrix.orthoOffCenter(e,t,r,s,a,n),this.type=Ie.ortho}orthoZo(e,t,r,s,a,n){this.near=Math.max(a,.01),this.far=n,this._projectionMatrix.orthoZO(e,t,r,s,a,n),this.type=Ie.ortho}get viewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.invert(),this._viewMatrix}get shadowViewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.appendScale(1,1,1),this._viewMatrix.invert(),this._viewMatrix}object3DToScreenRay(e,t=null){return t||(t=new g(0,0,0,1)),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5,st.transformVector(this.viewMatrix,e,t),this.project(t,t),t.x=this._halfw+t.x*this._halfw,t.y=this.viewPort.height-(this._halfh-t.y*this._halfh),t}screenRayToObject3D(e,t=null){t||(t=new g),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5;let r=e.x,s=e.y;return t.x=r/this.viewPort.width-.25,t.y=s/this.viewPort.height-.25,this.unProject(t.x,t.y,e.z,t),t}get pvMatrix(){return so(this._projectionMatrix,this.viewMatrix,this._pvMatrix),this._pvMatrix}get pvMatrix2(){so(this._projectionMatrix,this.transform.worldMatrix,this._pvMatrix);let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get pvMatrixInv(){let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get projectionMatrixInv(){return this._projectionMatrixInv.copyFrom(this._projectionMatrix),this._projectionMatrixInv.invert(),this._projectionMatrixInv}unProject(e,t,r,s){return s||(s=new g),s.x=e,s.y=-t,s.z=r,s.w=1,s.x*=r,s.y*=r,this._unprojection.copyFrom(this._projectionMatrix),this._unprojection.invert(),st.transformVector(this._unprojection,s,s),s.z=r,s}project(e,t){return this._projectionMatrix.perspectiveMultiplyPoint3(e,t),t.x=t.x/t.w,t.y=-t.y/t.w,t.z=e.z,t}screenPointToRay(e,t){let r=this._ray,s=Ne.UnProjection(e,t,.01,this),a=Ne.UnProjection(e,t,1,this);return a=a.subtract(s).normalize(),r.origin.copyFrom(s),r.direction=a,r}screenPointToWorld(e,t,r){return Ne.UnProjection(e,t,r,this)}worldToScreenPoint(e,t){return Ne.Projection(e,this,t)}lookAt(e,t,r=g.Y_AXIS){this.transform.lookAt(e,t,r),t&&this.lookTarget.copyFrom(t)}resetProjectMatrix(){this.perspective(this.fov,this.aspect,this.near,this.far)}onUpdate(){var e;this.type==Ie.perspective&&(this.aspect=S.aspect,this.resetProjectMatrix()),this._useJitterProjection&&this.getJitteredProjectionMatrix(),this.frustum.update(this.pvMatrix),this.frustum.updateBoundBox(this.pvMatrixInv);let t=A.setting.shadow;this.enableCSM&&((e=this.csm)==null||e.update(this._projectionMatrix,this._pvMatrixInv,this.near,this.far,t))}get jitterFrameIndex(){return this._jitterFrameIndex}get jitterX(){return this._jitterX}get jitterY(){return this._jitterY}enableJitterProjection(e){this._jitterFrameIndex=0,this._useJitterProjection=e,this._haltonSeq||(this._haltonSeq=new Ls),this._jitterOffsetList=[];for(let t=0;t<8;t++){let r=this.generateRandomOffset();this._jitterOffsetList.push(r)}this._jitterOffsetList.reverse()}generateRandomOffset(){let e=new Z(Ls.get((this._sampleIndex&1023)+1,2)-.5,Ls.get((this._sampleIndex&1023)+1,3)-.5);const t=8;return++this._sampleIndex>=t&&(this._sampleIndex=0),e}getJitteredProjectionMatrix(){let e=A.setting.render.postProcessing.taa,t=this._projectionMatrix,r=e.temporalJitterScale,s=this._jitterFrameIndex%e.jitterSeedCount,a=this._jitterOffsetList[s].x*r,n=this._jitterOffsetList[s].y*r,l=t.get(0,2),h=t.get(1,2);this._jitterX=a/this.viewPort.width,this._jitterY=n/this.viewPort.height,l+=this._jitterX,h+=this._jitterY,t.set(0,2,l),t.set(1,2,h),this._jitterFrameIndex++}getWorldDirection(e){e||(e=new g);const t=this.transform._worldMatrix.rawData;return e.set(-t[8],-t[9],-t[10]).normalize()}}const Vr=class extends Ee{constructor(){super(),o(this,"eventPositionChange",new je(Vr.POSITION_ONCHANGE)),o(this,"eventRotationChange",new je(Vr.ROTATION_ONCHANGE)),o(this,"eventScaleChange",new je(Vr.SCALE_ONCHANGE)),o(this,"eventLocalChange",new je(Vr.LOCAL_ONCHANGE)),o(this,"onPositionChange"),o(this,"onRotationChange"),o(this,"onScaleChange"),o(this,"_scene3d"),o(this,"_parent"),o(this,"_localPos"),o(this,"_localRot"),o(this,"_localRotQuat"),o(this,"_localScale"),o(this,"_localDetailPos"),o(this,"_localDetailRot"),o(this,"_localDetailScale"),o(this,"index"),o(this,"index2"),o(this,"_forward",new g),o(this,"_back",new g),o(this,"_right",new g),o(this,"_left",new g),o(this,"_up",new g),o(this,"_down",new g),o(this,"_worldMatrix"),o(this,"_targetPos"),o(this,"static",!1),o(this,"depthOrder",0),this._worldMatrix=new V(!0),this.index=this._worldMatrix.index,this.index2=this._worldMatrix.index*ee.stateStruct,this._localPos=new g,this._localRot=new g,this._localRotQuat=new q,this._localScale=new g(1,1,1),ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z)}get localChange(){return ee.matrixStateBuffer[this.index2]!=0}set localChange(i){ee.matrixStateBuffer[this.index2]=i?1:0}get targetPos(){return this._targetPos}set targetPos(i){this._targetPos=i}get parent(){return this._parent}set parent(i){var e;let t=(e=this._parent)==null?void 0:e.object3D;if(this._parent=i,this.depthOrder=i?i.depthOrder+1:0,ee.setParent(this.index,i?i.worldMatrix.index:-1,this.depthOrder),this.localChange=!0,this.object3D){let r=i?i.scene3D:null;r?(this._scene3d=r,this.object3D.components.forEach(s=>{ae.appendWaitStart(s)})):this.object3D.components.forEach(s=>{s.__stop()});for(let s of this.object3D.entityChildren)s.transform.parent=i?this:null;this.object3D.components.forEach(s=>{var a,n;(n=s.onParentChange)==null||n.call(s,t,(a=this._parent)==null?void 0:a.object3D)})}this.notifyLocalChange()}set enable(i){this.transform._scene3d&&i?super.enable=!0:super.enable=!1;for(let e of this.object3D.entityChildren)e.transform.enable=i}get enable(){return this._enable}get scene3D(){return this._scene3d}set scene3D(i){this._scene3d=i}get view3D(){return this._scene3d&&this._scene3d.view?this._scene3d.view:null}awake(){}start(){}stop(){}notifyLocalChange(){if(this.localChange=!0,this.object3D){let i=this.object3D.entityChildren,e=0,t=i.length;for(e=0;e<t;e++)i[e].transform.notifyLocalChange()}this.eventDispatcher.dispatchEvent(this.eventLocalChange)}get up(){return this.worldMatrix.transformVector(g.UP,this._up),this._up}set up(i){this._up.copyFrom(i),st.fromToRotation(g.UP,this._up,q.HELP_0),this.transform.localRotQuat=q.HELP_0}get down(){return this.worldMatrix.transformVector(g.DOWN,this._down),this._down}set down(i){var e;this._down.copyFrom(i),st.fromToRotation(g.DOWN,this._down,q.HELP_0),this.transform.localRotQuat=q.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get forward(){return this.worldMatrix.transformVector(g.FORWARD,this._forward),this._forward}set forward(i){var e;this._forward.copyFrom(i),st.fromToRotation(g.FORWARD,this._forward,q.HELP_0),this.transform.localRotQuat=q.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get back(){return this.worldMatrix.transformVector(g.BACK,this._back),this._back}set back(i){this._back.copyFrom(i),st.fromToRotation(g.BACK,this._back,q.HELP_0),this.transform.localRotQuat=q.HELP_0}get left(){return this.worldMatrix.transformVector(g.neg_X_AXIS,this._left),this._left}set left(i){this._left.copyFrom(i),st.fromToRotation(g.LEFT,this._left,q.HELP_0),this.transform.localRotQuat=q.HELP_0}get right(){return this.worldMatrix.transformVector(g.X_AXIS,this._right),this._right}set right(i){var e;this._right.copyFrom(i),st.fromToRotation(g.RIGHT,this._right,q.HELP_0),this.transform.localRotQuat=q.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotQuat(){return this._localRotQuat}set localRotQuat(i){var e;(i.x!=this._localRotQuat.x||i.y!=this._localRotQuat.y||i.z!=this._localRotQuat.z||i.w!=this._localRotQuat.w)&&(this._localRotQuat.copyFrom(i),this._localRotQuat.getEulerAngles(this._localRot),ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}notifyChange(){var i,e,t;this.notifyLocalChange(),(i=this.onRotationChange)==null||i.call(this),(e=this.onScaleChange)==null||e.call(this),(t=this.onPositionChange)==null||t.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get worldMatrix(){return this.updateWorldMatrix(),this._worldMatrix}updateWorldMatrix(i=!1){(this.localChange||i)&&(this.parent?(Rs(this._localRot,this._localPos,this._localScale,this._worldMatrix),xl(this._worldMatrix,this.parent.worldMatrix,this._worldMatrix)):Rs(this._localRot,this._localPos,this._localScale,this._worldMatrix),this.localChange=!1)}updateChildTransform(){let i=this;if(i.localChange&&i.updateWorldMatrix(),i.object3D.numChildren>0)for(const e of i.object3D.entityChildren)e.transform.updateChildTransform()}lookTarget(i,e=g.UP){this.lookAt(this.transform.worldPosition,i,e)}lookAt(i,e,t=g.UP){this._targetPos||(this._targetPos=new g),this._targetPos.copyFrom(e),this.localPosition=i,V.helpMatrix.lookAt(i,e,t),V.helpMatrix.invert();var r=V.helpMatrix.decompose(yt.QUATERNION);this.localRotQuat=q.CALCULATION_QUATERNION.copyFrom(r[1])}decomposeFromMatrix(i,e="eulerAngles"){let t=i.decompose(e),r=this.transform;return r.localRotQuat.copyFrom(t[1]),r.localRotQuat=r.localRotQuat,r.localPosition.copyFrom(t[0]),r.localPosition=r.localPosition,r.localScale.copyFrom(t[2]),r.localScale=r.localScale,this}cloneTo(i){i.transform.localPosition=this.localPosition,i.transform.localRotation=this.localRotation,i.transform.localScale=this.localScale}set x(i){var e;this._localPos.x!=i&&(this._localPos.x=i,ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get x(){return this._localPos.x}set y(i){var e;this._localPos.y!=i&&(this._localPos.y=i,ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get y(){return this._localPos.y}set z(i){var e;this._localPos.z!=i&&(this._localPos.z=i,ee.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get z(){return this._localPos.z}set scaleX(i){var e;this._localScale.x!=i&&(this._localScale.x=i,ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleX(){return this._localScale.x}set scaleY(i){var e;this._localScale.y!=i&&(this._localScale.y=i,ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleY(){return this._localScale.y}set scaleZ(i){var e;this._localScale.z!=i&&(this._localScale.z=i,ee.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleZ(){return this._localScale.z}set rotationX(i){var e;this._localRot.x!=i&&(this._localRot.x=i,ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationX(){return this._localRot.x}set rotationY(i){var e;this._localRot.y!=i&&(this._localRot.y=i,ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationY(){return this._localRot.y}set rotationZ(i){var e;this._localRot.z!=i&&(this._localRot.z=i,ee.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationZ(){return this._localRot.z}get worldPosition(){return this.localChange&&this.updateWorldMatrix(),this._worldMatrix.position}set localPosition(i){var e;this._localPos.copyFrom(i),ee.setTranslate(this.index,i.x,i.y,i.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange)}get localPosition(){return this._localPos}set localRotation(i){var e;ee.setRotation(this.index,i.x,i.y,i.z),this._localRot.copyFrom(i),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotation(){return this._localRot}set localScale(i){var e;ee.setScale(this.index,i.x,i.y,i.z),this._localScale.copyFrom(i),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get localScale(){return this._localScale}get localDetailScale(){return this._localDetailScale}set localDetailScale(i){this._localDetailScale=i,ee.setContinueScale(this.index,i.x,i.y,i.z)}get localDetailRot(){return this._localDetailRot}set localDetailRot(i){this._localDetailRot=i,ee.setContinueRotation(this.index,i.x,i.y,i.z)}get localDetailPos(){return this._localDetailPos}set localDetailPos(i){this._localDetailPos=i,ee.setContinueTranslate(this.index,i.x,i.y,i.z)}beforeDestroy(i){this.parent&&this.parent.object3D&&this.parent.object3D.removeChild(this.object3D),super.beforeDestroy(i)}destroy(){super.destroy(),this.scene3D=null,this.eventPositionChange=null,this.eventRotationChange=null,this.eventScaleChange=null,this.onPositionChange=null,this.onRotationChange=null,this.onScaleChange=null,this._scene3d=null,this._parent=null,this._localPos=null,this._localRot=null,this._localRotQuat=null,this._localScale=null,this._forward=null,this._back=null,this._right=null,this._left=null,this._up=null,this._down=null,this.localChange=null,this._targetPos=null}};let Oe=Vr;o(Oe,"LIMIT",1),o(Oe,"COMPONENT_NAME","UUTransform"),o(Oe,"COMPONENT_TYPE","Transform"),o(Oe,"POSITION_ONCHANGE","POSITION_ONCHANGE"),o(Oe,"ROTATION_ONCHANGE","ROTATION_ONCHANGE"),o(Oe,"SCALE_ONCHANGE","SCALE_ONCHANGE"),o(Oe,"PARENT_ONCHANGE","PARENT_ONCHANGE"),o(Oe,"CHILDREN_ONCHANGE","CHILDREN_ONCHANGE"),o(Oe,"ADD_ONCHANGE","ADD_ONCHANGE"),o(Oe,"LOCAL_ONCHANGE","LOCAL_ONCHANGE");const wl=class{static genMeshBounds(i,e){let t=this.genMeshMinVector,r=this.genMeshMaxVector,s=this.genMeshVectorList8;e||(e=new Be(g.ZERO,g.ZERO)),e.setFromMinMax(this.maxVector,this.minVector);let a=i.getComponents(ce);for(const n of a)if(n&&n.geometry){let l=n.object3D.transform.worldMatrix;t.copy(n.geometry.bounds.min),r.copy(n.geometry.bounds.max),s[0].set(t.x,t.y,t.z),s[1].set(t.x,t.y,r.z),s[2].set(t.x,r.y,t.z),s[3].set(t.x,r.y,r.z),s[4].set(r.x,t.y,t.z),s[5].set(r.x,t.y,r.z),s[6].set(r.x,r.y,t.z),s[7].set(r.x,r.y,r.z);for(const h of s)l.transformPoint(h,h),e.expandByPoint(h)}return r.copyFrom(e.max),t.copyFrom(e.min),e.setFromMinMax(t,r),e}static transformBound(i,e,t){let r=this.genMeshMinVector.copyFrom(e.min),s=this.genMeshMaxVector.copyFrom(e.max),a=this.genMeshVectorList8;t||(t=new Be(g.ZERO,g.ZERO)),t.setFromMinMax(this.maxVector,this.minVector),a[0].set(r.x,r.y,r.z),a[1].set(r.x,r.y,s.z),a[2].set(r.x,s.y,r.z),a[3].set(r.x,s.y,s.z),a[4].set(s.x,r.y,r.z),a[5].set(s.x,r.y,s.z),a[6].set(s.x,s.y,r.z),a[7].set(s.x,s.y,s.z);for(const n of a)i.transformPoint(n,n),t.expandByPoint(n);return s.copyFrom(t.max),r.copyFrom(t.min),t.setFromMinMax(r,s),t}};let Zt=wl;o(Zt,"maxVector",new g(Number.MAX_VALUE*.1,Number.MAX_VALUE*.1,Number.MAX_VALUE*.1)),o(Zt,"minVector",wl.maxVector.clone().multiplyScalar(-1)),o(Zt,"genMeshMaxVector",g.ZERO.clone()),o(Zt,"genMeshMinVector",g.ZERO.clone()),o(Zt,"genMeshVectorList8",[new g,new g,new g,new g,new g,new g,new g,new g]);class bl extends hi{constructor(){super(),o(this,"name",""),o(this,"_instanceID",""),o(this,"_numChildren"),o(this,"transform"),o(this,"renderNode"),o(this,"entityChildren"),o(this,"components"),o(this,"waitDisposeComponents"),o(this,"_bound"),o(this,"_boundWorld"),o(this,"_isBoundChange",!0),o(this,"_dispose",!1),this.entityChildren=[],this.components=new Map,this._instanceID=qa().toString(),this.waitDisposeComponents=[]}get instanceID(){return this._instanceID}getObjectByName(e){if(e.indexOf("/")>=0){let r=e.split("/"),s=this;for(;r.length>0&&s;){let a=r.shift();if(s=s.getChildByName(a,!1),!s)return null}return s}else return this.getChildByName(e,!1)}get numChildren(){return this._numChildren}addChild(e){return e==null?new console.error("child is null!"):e===this?new console.error("child is self!"):this.entityChildren.indexOf(e)==-1?(e.removeFromParent(),e.transform.parent=this.transform,this.entityChildren.push(e),this._numChildren=this.entityChildren.length,e):null}removeChild(e){if(e===null)return new console.error("remove child is null!");if(e===this)return new console.error("add child is self!");let t=this.entityChildren.indexOf(e);t!=-1&&(this.entityChildren.splice(t,1),e.transform.parent=null,this._numChildren=this.entityChildren.length)}removeAllChild(){for(;this.numChildren>0;)this.removeChild(this.entityChildren[0])}removeSelf(){return this.removeFromParent()}removeChildByIndex(e){e>=0&&e<this.entityChildren.length?this.removeChild(this.entityChildren[e]):console.error("remove child by index , index out of range")}hasChild(e){return this.entityChildren.indexOf(e)!=-1}removeFromParent(){let e=this.transform.parent;return e&&e.object3D&&e.object3D.removeChild(this),this}getChildByIndex(e){let t=null;return e<this.entityChildren.length&&(t=this.entityChildren[e]),t}getChildByName(e,t=!0){let r=null;for(const s of this.entityChildren){if(s.name==e)return r=s,r;if(t&&(r=s.getChildByName(e,t),r))return r}return r}update(){}instantiate(){return null}onTransformLocalChange(e){this._isBoundChange=!0}get bound(){return(this._isBoundChange||!this._bound)&&this.updateBound(),this._boundWorld}set bound(e){this._bound=e,this._boundWorld=this._bound.clone(),this._isBoundChange=!0}updateBound(){return this._bound||(this._bound=new Be,this._boundWorld=this._bound.clone(),this._isBoundChange=!0),this._isBoundChange&&(Zt.transformBound(this.transform.worldMatrix,this._bound,this._boundWorld),this._isBoundChange=!1),this._boundWorld}waitUpdate(){this._dispose?(this.transform.parent&&this.transform.parent.object3D.removeChild(this),this.components.forEach((e,t)=>{e.enable=!1,e.destroy()}),this.components.clear()):ae.waitStartComponent.forEach((e,t)=>{for(;e.length>0;)e.shift().__start();ae.waitStartComponent.delete(t)})}destroy(e){this._dispose||(this.components.forEach(t=>{t.beforeDestroy(e)}),this.components.forEach(t=>{t.destroy(e)}),this.components.clear(),this.entityChildren.forEach(t=>{t.destroy(e)}),this.removeAllChild(),this.transform.parent=null,this._dispose=!0,super.destroy())}}var Od=Object.defineProperty,Nd=Object.getOwnPropertyDescriptor,Fd=(i,e,t,r)=>{for(var s=r>1?void 0:r?Nd(e,t):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(r?n(e,t,s):n(s))||s);return r&&s&&Od(e,t,s),s};let te=class extends bl{constructor(){super(),o(this,"_isScene3D"),o(this,"prefabRef"),o(this,"serializeTag"),this.transform=this.addComponent(Oe),this.transform.eventDispatcher.addEventListener(Oe.LOCAL_ONCHANGE,this.onTransformLocalChange,this)}get isScene3D(){return this._isScene3D}forChild(i){this.entityChildren.forEach(e=>{i(e),e.forChild(i)})}addComponent(i,e){let t=i.name;if(!this.components.has(t)){let r=new i;return r.object3D=this,this.components.set(t,r),r.__init(e),ae.appendWaitStart(r),r}return null}getOrAddComponent(i){let e=i.name,t=this.components.get(e);return t||(t=this.addComponent(i)),t}removeComponent(i){let e=i.name;if(this.components.has(e)){let t=this.components.get(e);ae.removeWaitStart(this,t),this.components.delete(e),t.__stop(),t.beforeDestroy(),t.destroy()}}hasComponent(i){let e=i.name;return this.components.has(e)}getComponent(i){let e=i.name;return this.components.get(e)}getComponentFromParent(i){if(!this.parent)return null;let e=this.parent.object3D.getComponent(i);return e||this.parent.object3D.getComponentFromParent(i)}getComponentsInChild(i){let e=[],t=i.name,r=this.components.get(t);r&&e.push(r);for(let s=0;s<this.entityChildren.length;s++){let n=this.entityChildren[s].getComponentsInChild(i);e.push(...n)}return e}getComponents(i,e,t){e||(e=[]);let r=this.getComponent(i);r&&(r.enable||t)&&e.push(r);for(let s=0,a=this.entityChildren.length;s<a;s++){let n=this.entityChildren[s];n&&n instanceof te&&n.getComponents(i,e,t)}return e}getComponentsExt(i,e,t){e||(e=[]);let r=this.components.get(i.name);if(r&&(r.enable||t))e.push(r);else for(const s of this.entityChildren)s instanceof te&&s.getComponentsExt(i,e,t);return e}getComponentsByProperty(i,e,t=!0,r,s){r||(r=[]);let a;for(const n of this.components.values())n&&(n.enable||s)&&n[i]==e&&(r.push(n),a=!0);if(!(a&&t))for(const n of this.entityChildren)n instanceof te&&n.getComponentsByProperty(i,e,t,r,s);return r}clone(){return this.instantiate()}instantiate(){let i=new te;return i.name=this.name,i.serializeTag=this.serializeTag,i.prefabRef=this.prefabRef,this.entityChildren.forEach((e,t)=>{let r=e.instantiate();i.addChild(r)}),this.components.forEach((e,t)=>{e.cloneTo(i)}),i}get localPosition(){return this.transform.localPosition}set localPosition(i){this.transform.localPosition=i}get localRotation(){return this.transform.localRotation}set localRotation(i){this.transform.localRotation=i}get localScale(){return this.transform.localScale}set localScale(i){this.transform.localScale=i}get localQuaternion(){return this.transform.localRotQuat}set localQuaternion(i){this.transform.localRotQuat=i}notifyChange(){this.transform.notifyChange()}get parent(){return this.transform.parent}get parentObject(){return this.transform.parent.object3D}set x(i){this.transform.x=i}get x(){return this.transform.x}set y(i){this.transform.y=i}get y(){return this.transform.y}set z(i){this.transform.z=i}get z(){return this.transform.z}set scaleX(i){this.transform.scaleX=i}get scaleX(){return this.transform.scaleX}set scaleY(i){this.transform.scaleY=i}get scaleY(){return this.transform.scaleY}set scaleZ(i){this.transform.scaleZ=i}get scaleZ(){return this.transform.scaleZ}set rotationX(i){this.transform.rotationX=i}get rotationX(){return this.transform.rotationX}set rotationY(i){this.transform.rotationY=i}get rotationY(){return this.transform.rotationY}set rotationZ(i){this.transform.rotationZ=i}get rotationZ(){return this.transform.rotationZ}fixedUpdate(){}lateUpdate(){}traverse(i){i(this);for(let e=0,t=this.entityChildren.length;e<t;e++){let r=this.entityChildren[e];r instanceof te&&r.traverse(i)}}destroy(i){this.transform.eventDispatcher.removeEventListener(Oe.LOCAL_ONCHANGE,this.onTransformLocalChange,this),super.destroy(i)}};te=Fd([kd],te);function kd(i,e){return class extends te{set active(t){this.transform.enable=t>0}get active(){return this.transform.enable?1:0}get materialColor(){var t;let r=this.getComponent(ce);return(t=r?.material)==null?void 0:t.defaultPass.baseColor}set materialColor(t){var r;let s=(r=this.getComponent(ce))==null?void 0:r.material;s&&(s.defaultPass.baseColor=t)}notifyMaterialColorChange(t,r){var s;let a=this.getComponent(ce).materials;(s=a?.[t])==null||s.defaultPass.uniforms[r].onChange()}}}class Ne{static createCamera3DObject(e,t){return this.createCamera3D(null,e,t)}static createCamera3D(e,t,r){return e||(e=new te),t&&t.addChild(e),r&&(e.name=r),e.getOrAddComponent(Zi)}static UnProjection(e,t,r=1,s){let a=new g(e,t,0),n=1,l=g.HELP_0,h=S.canvas.offsetLeft,u=S.canvas.offsetTop,c=S.canvas.clientWidth,f=S.canvas.clientHeight;l.x=((a.x-h)*n/c-.5)*2,l.y=-((a.y-u)*n/f-.5)*2,l.z=r;let d=new g(0,0,0),p=V.helpMatrix2;p.copyFrom(s.projectionMatrix),p.invert();let m=V.helpMatrix;return m.identity(),m.multiply(p),m.multiply(s.transform.worldMatrix),m.perspectiveMultiplyPoint3(l,d),d}static Projection(e,t,r){let s=r||new g(0,0,0),a=V.helpMatrix;a.copyFrom(t.viewMatrix),a.multiply(t.projectionMatrix),a.perspectiveMultiplyPoint3(e,s);let n=S.canvas.clientWidth/2,l=S.canvas.clientHeight/2;return s.x=s.x*n+n,s.y=l-s.y*l,s}static UnProjection2(e,t,r,s,a){let n=a||new g(0,0,0),l=V.helpMatrix;l.copyFrom(s.pvMatrixInv);let h=S.canvas.clientWidth/2,u=S.canvas.clientHeight/2;return n.x=(e-h)/h,n.y=(u-t)/u,n.z=r,l.perspectiveMultiplyPoint3(n,n),n}}const ao=class{static init(){this.directionLightList=new Map,this.pointLightList=new Map,this.shadowBuffer=new Map,this.shadowLights=new Map}static createBuffer(i){if(!this.shadowBuffer.has(i)){let e=new ge(20);e.visibility=GPUShaderStage.FRAGMENT,this.shadowBuffer.set(i,e),e.setInt32("nDirShadowStart",0),e.setInt32("nDirShadowEnd",1),e.setInt32("nPointShadowStart",0),e.setInt32("nPointShadowEnd",0);let t=new Uint32Array(16);this.shadowLights.set(i,t),e.setUint32Array("shadowLights",t),e.apply()}}static getShadowLightList(i){if(!i.transform.view3D)return null;if(i.lightData.lightType==Qe.DirectionLight){let e=this.directionLightList.get(i.transform.view3D.scene);return e||(e=[],this.directionLightList.set(i.transform.view3D.scene,e)),e}else if(i.lightData.lightType==Qe.PointLight){let e=this.pointLightList.get(i.transform.view3D.scene);return e||(e=[],this.pointLightList.set(i.transform.view3D.scene,e)),e}else if(i.lightData.lightType==Qe.SpotLight){let e=this.pointLightList.get(i.transform.view3D.scene);return e||(e=[],this.pointLightList.set(i.transform.view3D.scene,e)),e}}static getShadowLightWhichScene(i,e){if(e==Qe.DirectionLight){let t=this.directionLightList.get(i);return t||(t=[],this.directionLightList.set(i,t)),t}else if(e==Qe.PointLight){let t=this.pointLightList.get(i);return t||(t=[],this.pointLightList.set(i,t)),t}}static getDirectShadowLightWhichScene(i){let e=this.directionLightList.get(i);return e||(e=[],this.directionLightList.set(i,e)),e}static getPointShadowLightWhichScene(i){let e=this.pointLightList.get(i);return e||(e=[],this.pointLightList.set(i,e)),e}static addShadowLight(i){if(!i.transform.view3D)return null;let e=i.transform.view3D.scene;if(i.lightData.lightType==Qe.DirectionLight){let t=this.directionLightList.get(e);if(t||(t=[],this.directionLightList.set(e,t)),!i.shadowCamera){i.shadowCamera=Ne.createCamera3DObject(null,"shadowCamera"),i.shadowCamera.isShadowCamera=!0;let r=-1e3;i.shadowCamera.orthoOffCenter(r,-r,r,-r,1,1e4)}return t.indexOf(i)==-1&&t.push(i),t}else if(i.lightData.lightType==Qe.PointLight||i.lightData.lightType==Qe.SpotLight){let t=this.pointLightList.get(e);return t&&t.length>=8||(t||(t=[],this.pointLightList.set(e,t)),t.indexOf(i)==-1&&t.push(i)),t}}static removeShadowLight(i){if(i.lightData.castShadowIndex=-1,!i.transform.view3D)return null;if(i.lightData.lightType==Qe.DirectionLight){let e=this.directionLightList.get(i.transform.view3D.scene);if(e){let t=e.indexOf(i);t!=-1&&e.splice(t,1)}return i.lightData.castShadowIndex=-1,e}else if(i.lightData.lightType==Qe.PointLight||i.lightData.lightType==Qe.SpotLight){let e=this.pointLightList.get(i.transform.view3D.scene);if(e){let t=e.indexOf(i);t!=-1&&e.splice(t,1)}return i.lightData.castShadowIndex=-1,e}}static update(i){let e=this.shadowBuffer.get(i),t=this.shadowLights.get(i),r=ao.directionLightList.get(i),s=ao.pointLightList.get(i),a=0,n=0,l=0,h=0;if(t.fill(0),r){let u=0;for(let c=0;c<r.length;c++){const f=r[c];t[c]=f.lightData.index,f.lightData.castShadowIndex=u++}n=r.length}if(e.setInt32("nDirShadowStart",a),e.setInt32("nDirShadowEnd",n),s){l=n;let u=0;for(let c=l;c<s.length;c++){const f=s[c];t[c]=f.lightData.index,f.lightData.castShadowIndex=u++}h=l+s.length}e.setInt32("nPointShadowStart",l),e.setInt32("nPointShadowEnd",h),e.setUint32Array("shadowLights",t),e.apply()}};let Ve=ao;o(Ve,"maxNumDirectionShadow",8),o(Ve,"maxNumPointShadow",8),o(Ve,"directionLightList"),o(Ve,"pointLightList"),o(Ve,"shadowBuffer"),o(Ve,"shadowLights");class Hr{static getGlobalDataBindGroupLayout(){if(this._globalDataBindGroupLayout)return this._globalDataBindGroupLayout;let e=[];return e.push({binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),e.push({binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),this._globalDataBindGroupLayout=S.device.createBindGroupLayout({entries:e}),this._globalDataBindGroupLayout}}o(Hr,"_globalDataBindGroupLayout");class Sl{constructor(e){o(this,"uuid"),o(this,"usage"),o(this,"globalBindGroup"),o(this,"uniformGPUBuffer"),o(this,"matrixBindGroup"),o(this,"uniformByteLength"),o(this,"matrixesByteLength"),o(this,"shadowMatrixRaw",new Float32Array(8*16)),o(this,"csmMatrixRaw",new Float32Array(lt.Cascades*16)),o(this,"csmShadowBias",new Float32Array(4)),this.uuid=Pt(),this.usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.uniformGPUBuffer=new Dt(32*4*4+3*4*4+8*16+lt.Cascades*16+4+4),this.uniformGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBindGroup=e,this.createBindGroup()}createBindGroup(){this.uniformByteLength=this.uniformGPUBuffer.memory.shareDataBuffer.byteLength,this.matrixesByteLength=V.blockBytes*V.maxCount,this.globalBindGroup=S.device.createBindGroup({label:"global_bindGroupLayout",layout:Hr.getGlobalDataBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.uniformGPUBuffer.buffer,offset:0,size:this.uniformByteLength}},{binding:1,resource:{buffer:this.matrixBindGroup.matrixBufferDst.buffer,offset:0,size:this.matrixesByteLength}}]})}setCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix",e.transform.worldMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv);let t=Ve.getDirectShadowLightWhichScene(e.transform.scene3D);this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0);for(let n=0;n<8;n++)if(n<t.length){let l=t[n].shadowCamera;this.shadowMatrixRaw.set(l.pvMatrix.rawData,n*16)}else this.shadowMatrixRaw.set(e.transform.worldMatrix.rawData,n*16);this.uniformGPUBuffer.setFloat32Array("shadowMatrix",this.shadowMatrixRaw);let r=A.setting.shadow.shadowSize;if(lt.Cascades>1&&e.enableCSM&&t[0])for(let n=0;n<lt.Cascades;n++){let l=e.csm.children[n].shadowCamera;this.csmMatrixRaw.set(l.pvMatrix.rawData,n*16),this.csmShadowBias[n]=e.getCSMShadowBias(n,r)}this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",he.frame),this.uniformGPUBuffer.setFloat("time",he.frame),this.uniformGPUBuffer.setFloat("delta",he.delta),this.uniformGPUBuffer.setFloat("shadowBias",e.getShadowBias(r)),this.uniformGPUBuffer.setFloat("skyExposure",A.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",A.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",A.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",A.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",A.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",A.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",A.setting.render.renderState_split);let s=A.inputSystem.mouseX*S.pixelRatio,a=A.inputSystem.mouseY*S.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",s),this.uniformGPUBuffer.setFloat("mouseY",a),this.uniformGPUBuffer.setFloat("windowWidth",S.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",S.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",A.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",r),this.uniformGPUBuffer.setFloat("shadowSoft",A.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",e.enableCSM?1:0),this.uniformGPUBuffer.setFloat("csmMargin",A.setting.shadow.csmMargin),this.uniformGPUBuffer.apply()}setShadowCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_pvMatrix",e.pvMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv),this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0),this.uniformGPUBuffer.setFloat32Array("shadowCamera",this.shadowMatrixRaw),this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",he.frame),this.uniformGPUBuffer.setFloat("time",he.frame),this.uniformGPUBuffer.setFloat("delta",he.delta),this.uniformGPUBuffer.setFloat("shadowBias",1e-4),this.uniformGPUBuffer.setFloat("skyExposure",A.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",A.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",A.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",A.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",A.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",A.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",A.setting.render.renderState_split);let t=A.inputSystem.mouseX*S.pixelRatio,r=A.inputSystem.mouseY*S.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",t),this.uniformGPUBuffer.setFloat("mouseY",r),this.uniformGPUBuffer.setFloat("windowWidth",S.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",S.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",A.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",A.setting.shadow.shadowSize),this.uniformGPUBuffer.setFloat("shadowSoft",A.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",0),this.uniformGPUBuffer.setFloat("csmMargin",A.setting.shadow.csmMargin),this.uniformGPUBuffer.apply()}addUniformNode(){}}const $i=class{constructor(i,e=0,t=null,r=0){o(this,"entities"),o(this,"box"),o(this,"subTrees",[]),o(this,"parent"),o(this,"level"),o(this,"index"),o(this,"uuid"),o(this,"__rayCastTempVector",new g),this.parent=t,this.box=i.clone(),this.level=r,this.index=e,this.uuid=r+"_"+e,this.entities=new Map}tryInsertEntity(i){let e=i.renderer.object3D.bound;if(this.level==0||this.box.containsBox(e)){this.subTrees.length==0&&this.level<$i.maxSplitLevel&&this.splitTree();let t;if(this.subTrees.length>0){for(let r of this.subTrees)if(r.tryInsertEntity(i)){t=!0;break}}return t||i.enterNode(this),!0}return!1}splitTree(){if(this.subTrees.length==0){const i=$i._v1,e=this.box.extents.clone();let t=this.level+1,r=0;for(let s=0;s<2;s++)for(let a=0;a<2;a++)for(let n=0;n<2;n++){const l=new Be;this.box.min.add(i.set(s,a,n).multiply(e),l.min),l.min.add(e,l.max),l.setFromMinMax(l.min,l.max);let h=new $i(l,r++,this,t);this.subTrees.push(h)}}}rayCasts(i,e){if(this.level==0||i.intersectBox(this.box,this.__rayCastTempVector)){this.entities.size>0&&e.push(...this.entities.values());for(let t of this.subTrees)t.rayCasts(i,e);return!0}return!1}frustumCasts(i,e){if(this.level==0||i.containsBox2(this.box)>0){if(this.entities.size>0)for(const t of this.entities.values())(this.level>$i.autoSplitLevel||i.containsBox2(t.renderer.object3D.bound)>0)&&e.push(t);for(let t of this.subTrees)t.frustumCasts(i,e);return!0}return!1}getRenderNode(i,e){if(this.level==0||i.containsBox2(this.box)>0){if(this.entities.size>0)for(const t of this.entities.values())(this.level>$i.autoSplitLevel||i.containsBox2(t.renderer.object3D.bound)>0)&&(t.renderer.renderOrder<3e3?e.opaqueList.push(t.renderer):t.renderer.renderOrder>=3e3&&e.transparentList.push(t.renderer));for(let t of this.subTrees)t.getRenderNode(i,e);return!0}return!1}boxCasts(i,e){if(i.intersectsBox(this.box)){this.entities.size>0&&e.push(...this.entities.values());for(let t of this.subTrees)t.boxCasts(i,e);return!0}return!1}clean(){for(let i of this.entities.values())i.leaveNode();return this.entities.clear(),this}};let er=$i;o(er,"_v1",new g),o(er,"_v2",new g),o(er,"maxSplitLevel",6),o(er,"autoSplitLevel",3);class Il{constructor(){o(this,"_pool",[]),o(this,"_worldPosition",new g),o(this,"_viewPosition",new g),o(this,"_zSortList",[])}pop(){return this._pool.pop()||{}}recycle(){for(let e of this._zSortList)e.z=0,e.userData=null,e.obj3d=null,this._pool.push(e);this._zSortList.length=0}sort(e,t,r,s){this._zSortList=[];for(let a of t){let n=this.pop();n.userData=a,n.obj3d=r(a),n.z=this.worldToCameraDepth(n.obj3d,e),this._zSortList.push(n)}this._zSortList.sort((a,n)=>a.z-n.z>0?1:-1),s||(s=[]);for(let a of this._zSortList)s.push(a.userData);return this.recycle(),s}worldToCameraDepth(e,t){t||(t=e.transform.view3D.camera);let r=0;return t&&(this._worldPosition.copyFrom(e.transform.worldPosition),t.worldToScreenPoint(this._worldPosition,this._viewPosition),r=this._viewPosition.z),r}}let El=new Il;var Yr=(i=>(i[i.None=2]="None",i[i.StaticBatch=4]="StaticBatch",i[i.DynamicBatch=8]="DynamicBatch",i))(Yr||{});class oo{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)!=0}}function zd(i,e){let t=i.__NonSerialize__;t||(t=i.__NonSerialize__={},t.__NonSerialize__=!0),t[e]=!0}function Gd(i,e){let t;for(;i&&(i=i.__proto__,i&&(t=i.__NonSerialize__),!t););return t&&t[e]}function Vt(i,e,t,r,s){let a=i.__EditorInspector__;a||(a=i.__EditorInspector__=new Map);let n=a.get(i.constructor.name);n||(n=new Map,a.set(i.constructor.name,n)),n.set(e,{p1:t,p2:r,p3:s})}function Qd(i){let e,t=i,r=[];for(;t;){if(r.indexOf(t.constructor.name)!=-1){t=t.__proto__;continue}r.push(t.constructor.name),t=t.__proto__}for(r=r.reverse(),t=i;t&&(t=t.__proto__,t&&(e=t.__EditorInspector__),!e););let s=new Map;if(e)for(let a=0;a<r.length;a++){const n=r[a];let l=e.get(n);l&&l.forEach((h,u)=>{s.set(u,h)})}return s}function Vd(i,e,t,r,s){let a=window.__Component__;a||(a=window.__Component__={}),a[i.name]=i}var re=(i=>(i[i.COLOR=1]="COLOR",i[i.NORMAL=2]="NORMAL",i[i.POSITION=4]="POSITION",i[i.GRAPHIC=8]="GRAPHIC",i[i.GI=16]="GI",i[i.Cluster=32]="Cluster",i[i.SHADOW=64]="SHADOW",i[i.POINT_SHADOW=128]="POINT_SHADOW",i[i.POST=256]="POST",i[i.DEPTH=512]="DEPTH",i[i.REFLECTION=1024]="REFLECTION",i))(re||{});class le{}o(le,"GLTF_NODE_INDEX_PROPERTY"),o(le,"BASE_COLOR_UNIFORM","u_baseColorFactor"),o(le,"BASE_COLOR_TEXTURE_UNIFORM","u_baseColorSampler"),o(le,"METALROUGHNESS_UNIFORM","u_metallicRoughnessValues"),o(le,"METALROUGHNESS_TEXTURE_UNIFORM","u_metallicRoughnessSampler"),o(le,"NORMAL_TEXTURE_UNIFORM","u_normalSampler"),o(le,"NORMAL_SCALE_UNIFORM","u_normalScale"),o(le,"EMISSIVE_TEXTURE_UNIFORM","u_emissiveSampler"),o(le,"EMISSIVE_FACTOR_UNIFORM","u_emissiveFactor"),o(le,"OCCLUSION_TEXTURE_UNIFORM","u_occlusionSampler"),o(le,"OCCLUSION_FACTOR_UNIFORM","u_occlusionFactor"),o(le,"MAX_MORPH_TARGETS",8),o(le,"MORPH_POSITION_PREFIX","a_morphPositions_"),o(le,"MORPH_NORMAL_PREFIX","a_morphNormals_"),o(le,"MORPH_TANGENT_PREFIX","a_morphTangents_"),o(le,"MORPH_WEIGHT_UNIFORM","u_morphWeights"),o(le,"SCENE_ROOT_SKELETON","SCENE_ROOT"),o(le,"IDENTITY_INVERSE_BIND_MATRICES","IDENTITY_IBM"),o(le,"JOINT_MATRICES_UNIFORM","u_jointMatrix"),o(le,"ALPHA_CUTOFF_UNIFORM","u_alphaCutoff");class Xr{static createGIPass(e,t){if(Tt.hasMask(e.rendererMask,Ue.Sky)){let r=t.getPass(re.COLOR)[0],s=new Bf;s.setTexture("baseMap",r.getTexture("baseMap")),s.cullMode=r.cullMode,s.frontFace=r.frontFace,t.addPass(re.GI,s,0),s.preCompile(e.geometry)}else this.castGBufferPass(e,t)}static castGBufferPass(e,t){let r=t.getPass(re.COLOR);for(let s=0;s<r.length;s++){const a=r[s];let n=t.getPass(re.GI);if(!n||n.length<s){let l=new Ef;l.setTexture("baseMap",a.getTexture("baseMap")),l.setTexture("normalMap",a.getTexture("normalMap")),l.setTexture("emissiveMap",a.getTexture("emissiveMap")),l.setUniform("baseColor",a.getUniform("baseColor")),l.setUniform("envIntensity",a.getUniform("envIntensity")),l.setUniform("emissiveColor",a.getUniform("emissiveColor")),l.setUniform("emissiveIntensity",a.getUniform("emissiveIntensity")),l.setUniform("alphaCutoff",a.getUniform("alphaCutoff")),l.cullMode=a.cullMode,l.frontFace=a.frontFace,l.preCompile(e.geometry),t.addPass(re.GI,l)}}}static createShadowPass(e,t){let r=Tt.hasMask(e.rendererMask,Ue.SkinnedMesh),s=e.geometry.hasAttribute("TANGENT"),a=e.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),n=e.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=t.getPass(re.COLOR);for(let h=0;h<l.length;h++){const u=l[h];let c=t.getPass(re.SHADOW);if(!c||c.length<h){let d=new Sf;d.setTexture("baseMap",u.getTexture("baseMap")),d.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),s&&d.setDefine("USE_TANGENT",s),r&&d.setDefine("USE_SKELETON",r),a&&d.setDefine("USE_MORPHTARGETS",a),n&&d.setDefine("USE_MORPHNORMALS",n),u.cullMode=="none"?d.shaderState.cullMode="none":u.cullMode=="back"?d.shaderState.cullMode="front":u.cullMode=="front"&&(d.shaderState.cullMode="back"),d.preCompile(e.geometry),t.addPass(re.SHADOW,d)}if(!t.getPass(re.POINT_SHADOW)){let d=new bf;d.setTexture("baseMap",u.getTexture("baseMap")),d.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),d.setDefine("USE_ALPHACUT",1);for(let p=0;p<1;p++)s&&d.setDefine("USE_TANGENT",s),r&&d.setDefine("USE_SKELETON",r),a&&d.setDefine("USE_MORPHTARGETS",a),n&&d.setDefine("USE_MORPHNORMALS",n),d.shaderState.cullMode="front",d.preCompile(e.geometry);t.addPass(re.POINT_SHADOW,d)}}}static createReflectionPass(e,t){}static createDepthPass(e,t){let r=t.getPass(re.COLOR),s=e.geometry.hasAttribute("TANGENT"),a=e.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),n=e.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=Tt.hasMask(e.rendererMask,Ue.SkinnedMesh);for(let h=0;h<r.length;h++){const u=r[h];let c=t.getPass(re.DEPTH);if(!c&&u.shaderState.useZ&&(!c||c.length<h)){let f=new If;f.setTexture("baseMap",u.getTexture("baseMap")),s||f.setDefine("USE_TANGENT",s),l&&f.setDefine("USE_SKELETON",l),a&&f.setDefine("USE_MORPHTARGETS",a),n&&f.setDefine("USE_MORPHNORMALS",n),f.cullMode=u.cullMode,f.frontFace=u.frontFace,f.preCompile(e.geometry),t.addPass(re.DEPTH,f)}}}}const Bl=class{constructor(){o(this,"reference")}static getInstance(){return this._ins||(this._ins=new Bl),this._ins}attached(i,e){this.reference||(this.reference=new Map);let t=this.reference.get(i);t||(t=new Map),t.set(e,i),this.reference.set(i,t)}detached(i,e){let t=this.reference.get(i);t&&t.delete(e)}hasReference(i){let e=this.reference.get(i);return e?e.size>0:!1}getReferenceCount(i){let e=this.reference.get(i);return e?e.size:0}getReference(i){let e=this.reference.get(i);return e||null}};let se=Bl;o(se,"_ins");const fi=class{static getMipmapPipeline(i){let e=i.format,t=S.device,r=fi.pipelineCache[i.format],s;if(!r){s=t.createShaderModule({code:fi.mipmapShader});let a=t.createBindGroupLayout({entries:[{binding:0,visibility:i.visibility,sampler:i.samplerBindingLayout},{binding:1,visibility:i.visibility,texture:i.textureBindingLayout}]}),n=S.device.createPipelineLayout({bindGroupLayouts:[a]});r=w.createPipeline({layout:n,vertex:{module:s,entryPoint:"vertexMain"},fragment:{module:s,entryPoint:"fragmentMain",targets:[{format:e}]}}),fi.pipelineCache[e]=r}return r}static webGPUGenerateMipmap(i){let e=S.device,t=i.textureDescriptor;if(!fi.pipeline){const n=e.createShaderModule({code:`
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
          @builtin(position) position : vec4<f32>,
          @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
          var output : VertexOutput;
          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
          return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
          var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
          return outColor;
        }
      `});fi.pipeline=e.createRenderPipeline({layout:"auto",vertex:{module:n,entryPoint:"vertexMain"},fragment:{module:n,entryPoint:"fragmentMain",targets:[{format:t.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}})}let r;i.format=="rgba16float"?r=e.createSampler({minFilter:"nearest",magFilter:"linear"}):r=e.createSampler({minFilter:"linear",magFilter:"linear"});let s=i.getGPUTexture().createView({baseMipLevel:0,mipLevelCount:1});const a=w.beginCommandEncoder();for(let n=1;n<t.mipLevelCount;++n){const l=i.getGPUTexture().createView({baseMipLevel:n,mipLevelCount:1}),h=a.beginRenderPass({colorAttachments:[{view:l,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),u=e.createBindGroup({layout:fi.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:r},{binding:1,resource:s}]});h.setPipeline(fi.pipeline),h.setBindGroup(0,u),h.draw(4),h.end(),s=l}w.endCommandEncoder(a)}};let Ht=fi;o(Ht,"mipmapShader",`
    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));
      struct VertexOutput {
        @builtin(position) position : vec4<f32>;
        @location(0) texCoord : vec2<f32>;
      };
      @vertex
      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
      }
      @binding(0) @group(0) var imgSampler : sampler;
      @binding(1) @group(0) var img : texture_2d<f32>;
      @fragment
      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
        return outColor ;
      }`),o(Ht,"pipelineCache",{}),o(Ht,"pipeline");class at{constructor(e=32,t=32,r=1){o(this,"name"),o(this,"url"),o(this,"gpuTexture"),o(this,"pid"),o(this,"view"),o(this,"gpuSampler"),o(this,"gpuSampler_comparison"),o(this,"format"),o(this,"usage"),o(this,"width",4),o(this,"height",4),o(this,"depthOrArrayLayers",1),o(this,"numberLayer",1),o(this,"viewDescriptor"),o(this,"textureDescriptor"),o(this,"visibility",GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT),o(this,"textureBindingLayout",{viewDimension:"2d",multisampled:!1}),o(this,"samplerBindingLayout",{type:"filtering"}),o(this,"sampler_comparisonBindingLayout",{type:"comparison"}),o(this,"flipY"),o(this,"isVideoTexture"),o(this,"isHDRTexture"),o(this,"_useMipmap",!1),o(this,"_sourceImageData"),o(this,"_addressModeU"),o(this,"_addressModeV"),o(this,"_addressModeW"),o(this,"_magFilter"),o(this,"_minFilter"),o(this,"_mipmapFilter"),o(this,"_lodMinClamp"),o(this,"_lodMaxClamp"),o(this,"_compare"),o(this,"_maxAnisotropy"),o(this,"mipmapCount",1),o(this,"_textureChange",!1),o(this,"_stateChangeRef",new Map),this.width=e,this.height=t,this.numberLayer=r,this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.addressModeU=Bt.repeat,this.addressModeV=Bt.repeat}init(){let e=this;return e.internalCreateBindingLayoutDesc&&e.internalCreateBindingLayoutDesc(),e.internalCreateTexture&&e.internalCreateTexture(),e.internalCreateView&&e.internalCreateView(),e.internalCreateSampler&&e.internalCreateSampler(),this}createTextureDescriptor(e,t,r,s,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,n=1,l=0){this.width=e,this.height=t,this.format=s,this.usage=a,this.textureDescriptor={size:[e,t,n],mipLevelCount:r,format:s,usage:a,label:`${this.name+this.width+this.height+this.format}`},l>0&&(this.textureDescriptor.sampleCount=l),n>1?this.viewDescriptor={dimension:"2d-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}generate(e){let t=32,r=32;"width"in e&&(t=e.width,r=e.height),(t<32||r<32)&&console.log(e.name+"Size must be greater than 32!"),this.width=t,this.height=r,this.createTexture(e)}createTexture(e){this._sourceImageData=e,this.updateTextureDescription(),this.updateGPUTexture();let t=S.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),this.useMipmap&&Ht.webGPUGenerateMipmap(this)}get useMipmap(){return this._useMipmap}set useMipmap(e){if(e){if(this.samplerBindingLayout.type="filtering",this._useMipmap==!1&&this._sourceImageData){this._useMipmap=!0,this.updateTextureDescription(),this.updateGPUTexture();let t=S.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),Ht.webGPUGenerateMipmap(this)}}else if(this.samplerBindingLayout.type="non-filtering",this._useMipmap==!0&&this._sourceImageData){this._useMipmap=!1,this.updateTextureDescription(),this.updateGPUTexture();let t=S.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height])}this._textureChange=!0,this._useMipmap=e,this.noticeChange()}get sourceImageData(){return this._sourceImageData}updateTextureDescription(){this.mipmapCount=Math.floor(this.useMipmap?Math.log2(Math.min(this.width,this.height)):1),this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format)}updateGPUTexture(){this.gpuTexture&&this.gpuTexture instanceof GPUTexture&&this.gpuTexture.destroy(),this.gpuTexture=null,this.view=null,this.gpuTexture=this.getGPUTexture()}getGPUTexture(){return this.gpuTexture||(this.gpuTexture=S.device.createTexture(this.textureDescriptor)),this.gpuTexture}getGPUView(e=0){return this.view||(this.gpuTexture=this.getGPUTexture(),this.gpuTexture instanceof GPUTexture&&(this.view=this.gpuTexture.createView(this.viewDescriptor),this.view.label=this.name)),this.view}bindStateChange(e,t){this._stateChangeRef.set(t,e)}unBindStateChange(e){this._stateChangeRef.delete(e)}noticeChange(){this.gpuSampler=S.device.createSampler(this),this._stateChangeRef.forEach((e,t)=>{e()})}destroy(e){e&&this.gpuTexture instanceof GPUTexture&&(this.gpuSampler=null,this.gpuSampler_comparison=null,this.textureBindingLayout=null,this.textureDescriptor=null,this.gpuTexture.destroy(),this.gpuTexture=null),this._stateChangeRef.clear()}get addressModeU(){return this._addressModeU}set addressModeU(e){this._addressModeU!=e&&(this._addressModeU=e,this.noticeChange())}get addressModeV(){return this._addressModeV}set addressModeV(e){this._addressModeV!=e&&(this._addressModeV=e,this.noticeChange())}get addressModeW(){return this._addressModeW}set addressModeW(e){this._addressModeW!=e&&(this._addressModeW=e,this.noticeChange())}get magFilter(){return this._magFilter}set magFilter(e){this._magFilter!=e&&(this._magFilter=e,this.noticeChange())}get minFilter(){return this._minFilter}set minFilter(e){this._minFilter!=e&&(this._minFilter=e,this.noticeChange())}get mipmapFilter(){return this._mipmapFilter}set mipmapFilter(e){this._mipmapFilter!=e&&(this._mipmapFilter=e,this.noticeChange())}get lodMinClamp(){return this._lodMinClamp}set lodMinClamp(e){this._lodMinClamp!=e&&(this._lodMinClamp=e,this.noticeChange())}get lodMaxClamp(){return this._lodMaxClamp}set lodMaxClamp(e){this._lodMaxClamp!=e&&(this._lodMaxClamp=e,this.noticeChange())}get compare(){return this._compare}set compare(e){this._compare!=e&&(this._compare=e,this.noticeChange())}get maxAnisotropy(){return this._maxAnisotropy}set maxAnisotropy(e){this._maxAnisotropy!=e&&(this._maxAnisotropy=e,this.noticeChange())}}class Tl extends at{constructor(e,t,r){super(e,t,r),o(this,"_bitmapTextures"),this.format=G.rgba8unorm,this.mipmapCount=1,this._bitmapTextures=[],this.init()}setTextures(e){this._bitmapTextures.length=0;for(let t=0;t<e.length;t++){const r=e[t];this.addTexture(r)}}addTexture(e){(e.width!=this.width||e.height!=this.height)&&console.error("bitmap texture muse match bitmapTextureArray size!"),this._bitmapTextures.indexOf(e)==-1&&(e.pid=this._bitmapTextures.length,this._bitmapTextures.push(e),this.updateTexture())}removeTexture(e){let t=this._bitmapTextures.indexOf(e);if(t!=-1){this._bitmapTextures.splice(t,1);for(let r=0;r<this._bitmapTextures.length;r++){const s=this._bitmapTextures[r];s.pid=r}}}updateTexture(){let e=w.beginCommandEncoder();for(let t=0;t<this._bitmapTextures.length;t++){let r=this._bitmapTextures[t];e.copyTextureToTexture({texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:t}},{width:this.width,height:this.height,depthOrArrayLayers:1})}w.endCommandEncoder(e)}internalCreateBindingLayoutDesc(){this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.minFilter=Nr.linear,this.magFilter=Nr.linear}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler(this)}}const Ei=class{constructor(){o(this,"_iesTexture"),o(this,"index",0)}generateIES(i){}set IESTexture(i){this._iesTexture=i,i.addressModeU=Bt.repeat,i.addressModeV=Bt.repeat,i.addressModeW=Bt.repeat,Ei.ies_list.indexOf(this)==-1&&(this.index=Ei.ies_list.length,Ei.ies_list.push(this),Ei.iesTexture||Ei.create(i.width,i.height),Ei.iesTexture.addTexture(i))}get IESTexture(){return this._iesTexture}static create(i,e){let t=48;this.iesTexture=new Tl(i,e,t)}};let Bi=Ei;o(Bi,"use",!1),o(Bi,"iesTexture"),o(Bi,"ies_list",[]);class Ml{constructor(e){o(this,"renderer"),o(this,"owner"),o(this,"uuid"),this.renderer=e,this.uuid=e.object3D.instanceID}leaveNode(){this.owner&&(this.owner.entities.delete(this.uuid),this.owner=null)}enterNode(e){this.owner&&this.leaveNode(),this.owner=e,e.entities.set(this.uuid,this)}update(e){var t;return((t=this.owner)==null?void 0:t.tryInsertEntity(this))||(this.leaveNode(),e.tryInsertEntity(this)),this.owner}}var Hd=Object.defineProperty,Yd=Object.getOwnPropertyDescriptor,Wr=(i,e,t,r)=>{for(var s=r>1?void 0:r?Yd(e,t):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(r?n(e,t,s):n(s))||s);return r&&s&&Hd(e,t,s),s};class $t extends Ee{constructor(){super(...arguments),o(this,"instanceCount",0),o(this,"lodLevel",0),o(this,"alwaysRender",!1),o(this,"instanceID"),o(this,"drawType",0),o(this,"_geometry"),o(this,"_materials",[]),o(this,"_castShadow",!0),o(this,"_castReflection",!1),o(this,"_castGI",!1),o(this,"_rendererMask",Ue.Default),o(this,"_inRenderer",!1),o(this,"_readyPipeline",!1),o(this,"_combineShaderRefection"),o(this,"_ignoreEnvMap"),o(this,"_ignorePrefilterMap"),o(this,"__renderOrder",0),o(this,"_renderOrder",0),o(this,"isRenderOrderChange"),o(this,"needSortOnCameraZ"),o(this,"_octreeBinder"),o(this,"preInit",!1),o(this,"_renderLayer",Yr.None)}init(){this.renderOrder=0,this.rendererMask=Ue.Default,this.instanceID=qa().toString()}attachSceneOctree(e){this._octreeBinder={octree:e,entity:new Ml(this)},this.transform.eventDispatcher.addEventListener(Oe.LOCAL_ONCHANGE,this.updateOctreeEntity,this)}detachSceneOctree(){var e;this._octreeBinder&&((e=this._octreeBinder.entity)==null||e.leaveNode(),this.transform.eventDispatcher.removeEventListener(Oe.LOCAL_ONCHANGE,this.updateOctreeEntity,this),this._octreeBinder=null)}updateOctreeEntity(e){var t,r;(r=(t=this._octreeBinder)==null?void 0:t.entity)==null||r.update(this._octreeBinder.octree)}copyComponent(e){return super.copyComponent(e),this.geometry=e._geometry,this.materials=e._materials.slice(),this.drawType=e.drawType,this.alwaysRender=e.alwaysRender,this.needSortOnCameraZ=e.needSortOnCameraZ,this.isRenderOrderChange=e.isRenderOrderChange,this.castShadow=e.castShadow,this.castGI=e.castGI,this.rendererMask=e.rendererMask,this}get renderLayer(){return this._renderLayer}set renderLayer(e){this._renderLayer=e}get geometry(){return this._geometry}set geometry(e){this._geometry!=e&&(this._geometry&&se.getInstance().detached(this._geometry,this),se.getInstance().attached(e,this)),this._geometry=e}addMask(e){this._rendererMask=Tt.addMask(this.rendererMask,e)}removeMask(e){this._rendererMask=Tt.removeMask(this.rendererMask,e)}hasMask(e){return Tt.hasMask(this.rendererMask,e)}get rendererMask(){return this._rendererMask}set rendererMask(e){this._rendererMask=e}get renderOrder(){return this._renderOrder}set renderOrder(e){e!=this._renderOrder&&(this.isRenderOrderChange=!0,this.__renderOrder=e),this._renderOrder=e}get materials(){return this._materials}set materials(e){this._readyPipeline=!1;for(let r=0;r<this._materials.length;r++){let s=this._materials[r];se.getInstance().detached(s,this)}for(let r=0;r<e.length;r++){let s=e[r];se.getInstance().attached(s,this)}this._materials=e;let t=0;for(let r=0;r<e.length;r++){const n=e[r].getPass(re.COLOR)[0];n.shaderState.transparent&&(t=t>n.renderOrder?t:n.renderOrder)}this.renderOrder=t,this._readyPipeline||this.initPipeline()}addRendererMask(e){this._rendererMask=Tt.addMask(this._rendererMask,e)}removeRendererMask(e){this._rendererMask=Tt.removeMask(this._rendererMask,e)}onEnable(){this._readyPipeline||this.initPipeline(),Q.instance.addRenderNode(this.transform.scene3D,this),this.updateOctreeEntity()}onDisable(){Q.instance.removeRenderNode(this.transform.scene3D,this)}selfCloneMaterials(e){let t=[];for(let r=0,s=this.materials.length;r<s;r++){const a=this.materials[r].clone();t.push(a)}return this.materials=t,this._readyPipeline=!1,this.initPipeline(),this}initPipeline(){if(this._geometry&&this._materials.length>0){for(let t=0;t<this._materials.length;t++){let s=this._materials[t].getPass(re.COLOR);for(let a=0;a<s.length;a++){const n=s[a];n.shaderReflection||n.preCompile(this._geometry),this._geometry.generate(n.shaderReflection)}this.object3D.bound=this._geometry.bounds.clone()}this._readyPipeline=!0;let e=0;for(let t=0;t<this.materials.length;t++){const a=this.materials[t].getPass(re.COLOR)[0];a.renderOrder>=3e3?e=e>a.renderOrder?e:a.renderOrder:e=Math.max(e-3e3,0),this.castNeedPass()}this.renderOrder=e,this.enable&&this.transform&&this.transform.scene3D&&Q.instance.addRenderNode(this.transform.scene3D,this)}}castNeedPass(){if(this.castGI)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];Xr.createGIPass(this,r)}for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&Xr.createShadowPass(this,r)}if(this.castReflection)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&Xr.createShadowPass(this,r)}if(!Tt.hasMask(this.rendererMask,Ue.IgnoreDepthPass)&&A.setting.render.zPrePass)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];Xr.createDepthPass(this,r)}else for(let t=0;t<this.materials.length;t++)this.materials[t].removePass(re.DEPTH,0)}get castShadow(){return this._castShadow}set castShadow(e){this._castShadow=e}get castGI(){return this._castGI}set castGI(e){this._castGI=e}get castReflection(){return this._castReflection}set castReflection(e){this._castReflection=e}renderPass(e,t,r){let s=this,a=s.transform._worldMatrix;for(let n=0;n<s.materials.length;n++){const l=s.materials[n];if(!l||!l.enable)continue;let h=l.getPass(t);if(!(!h||h.length==0)){w.bindGeometryBuffer(r.encoder,s._geometry);for(let u=0;u<h.length;u++){if(!h||h.length==0)continue;const f=h[u];if(f.pipeline){f.shaderState.splitTexture&&(r.endRenderPass(),Fe.WriteSplitColorTexture(s.instanceID),r.beginRenderPass(),w.bindCamera(r.encoder,e.camera),w.bindGeometryBuffer(r.encoder,s._geometry)),w.bindPipeline(r.encoder,f);let _=s._geometry.subGeometries[n].lodLevels[s.lodLevel];s.instanceCount>0?w.drawIndexed(r.encoder,_.indexCount,s.instanceCount,_.indexStart,0,0):w.drawIndexed(r.encoder,_.indexCount,1,_.indexStart,0,a.index)}}}}}renderPass2(e,t,r,s,a,n=!1){if(!this.enable)return;let l=this,h=l.object3D.transform._worldMatrix;for(let u=0;u<this.materials.length;u++){let f=this.materials[u].getPass(t);if(!f||f.length==0)return;if(this.drawType==2)for(let d of f)d.pipeline&&(w.bindPipeline(a,d),w.draw(a,6,1,0,h.index));else{w.bindGeometryBuffer(a,l._geometry);for(let d of f)if(d.pipeline){w.bindPipeline(a,d);let v=l._geometry.subGeometries[u].lodLevels[l.lodLevel];w.drawIndexed(a,v.indexCount,1,v.indexStart,0,h.index)}}}}recordRenderPass2(e,t,r,s,a,n=!1){if(!this.enable)return;let l=this;for(let h=0;h<this.materials.length;h++){let c=this.materials[h].getPass(t);if(!c||c.length==0)return;let f=l.object3D.transform._worldMatrix;for(let d=0;d<c.length;d++){const p=c[d];w.bindPipeline(a,p);let y=l._geometry.subGeometries[h].lodLevels[l.lodLevel];w.drawIndexed(a,y.indexCount,1,y.indexStart,0,f.index)}}}noticeShaderChange(){this.enable&&(this.onEnable(),this.preInit=!1)}nodeUpdate(e,t,r,s){this.preInit=!0;let a=this,n=e.scene.envMap;for(let l=0;l<a.materials.length;l++){let u=a.materials[l].getPass(t);if(u)for(let c=0;c<u.length;c++){const d=u[c];if(d.shaderState.splitTexture){let C=Fe.CreateSplitTexture(a.instanceID);d.setTexture("splitTexture_Map",C)}if(!a._ignoreEnvMap&&d.envMap!=n&&d.setTexture("envMap",n),d.setTexture("prefilterMap",n),d.pipeline){d.apply(a._geometry,r,()=>a.noticeShaderChange());continue}let p=A.res.getTexture("BRDFLUT");d.setTexture("brdflutMap",p);let m=A.getRenderJob(e).shadowMapPassRenderer;m&&m.depth2DArrayTexture&&(d.setTexture("shadowMap",A.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture),d.setStorageBuffer("shadowBuffer",Ve.shadowBuffer.get(e.scene)));let _=A.getRenderJob(e).pointLightShadowRenderer;_&&_.cubeArrayTexture&&d.setTexture("pointShadowMap",_.cubeArrayTexture);let v=Bi.iesTexture;v&&d.setTexture("iesTextureArrayMap",v),r.irradianceBuffer&&r.irradianceBuffer.length>0&&(d.setTexture("irradianceMap",r.irradianceBuffer[0]),d.setTexture("irradianceDepthMap",r.irradianceBuffer[1]));let y=pe.getLightEntries(e.scene);y&&(d.setStorageBuffer("lightBuffer",y.storageGPUBuffer),y.irradianceVolume&&d.setStructStorageBuffer("irradianceData",y.irradianceVolume.irradianceVolumeBuffer)),s&&(d.setStorageBuffer("clustersUniform",s.clustersUniformBuffer),d.setStorageBuffer("lightAssignBuffer",s.lightAssignBuffer),d.setStorageBuffer("assignTable",s.assignTableBuffer),d.setStorageBuffer("clusterBuffer",s.clusterBuffer)),d.apply(a._geometry,r)}}}beforeDestroy(e){se.getInstance().detached(this._geometry,this),se.getInstance().hasReference(this._geometry)||this._geometry.destroy(e);for(let t=0;t<this._materials.length;t++){const r=this._materials[t];se.getInstance().detached(r,this),se.getInstance().hasReference(r)||r.destroy(e)}super.beforeDestroy(e)}destroy(e){super.destroy(e),this._geometry=null,this._materials=null,this._combineShaderRefection=null}}Wr([Vt],$t.prototype,"materials",1),Wr([Vt],$t.prototype,"castShadow",1),Wr([Vt],$t.prototype,"castShadow",1),Wr([Vt],$t.prototype,"castGI",1),Wr([Vt],$t.prototype,"castGI",1);var xe=(i=>(i[i.NONE=0]="NONE",i[i.ABOVE=1]="ABOVE",i[i.ALPHA=2]="ALPHA",i[i.NORMAL=3]="NORMAL",i[i.ADD=4]="ADD",i[i.BELOW=5]="BELOW",i[i.ERASE=6]="ERASE",i[i.MUL=7]="MUL",i[i.SCREEN=8]="SCREEN",i[i.DIVD=9]="DIVD",i[i.SOFT_ADD=10]="SOFT_ADD",i))(xe||{}),Dl=(i=>(i[i.src_a=0]="src_a",i[i.dest_a=1]="dest_a",i))(Dl||{});class no{static getBlend(e){let t={color:{srcFactor:"src-alpha",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}};switch(e){case 0:t.color.srcFactor="one",t.color.dstFactor="zero",t.color.operation="add";break;case 1:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="dst-alpha",t.color.operation="add";break;case 4:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="add",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 2:t.color.srcFactor="src-alpha",t.color.dstFactor="one-minus-src-alpha";break;case 5:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="one",t.color.operation="add";break;case 6:t.color.srcFactor="zero",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 7:t.color.srcFactor="dst",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 3:t.color.srcFactor="one",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 10:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="max",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 8:t.color.srcFactor="one",t.color.dstFactor="one-minus-src",t.color.operation="add";break}return t}}let Pl=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexAttributes {
        @location(0) position: vec4<f32>,
        @location(1) color: vec4<f32>,
    }

    struct VertexOutput {
        @location(0) varying_WPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main( vertex:VertexAttributes ) -> VertexOutput {
        var worldMatrix = models.matrix[u32(vertex.position.w)];
        var worldPos = (worldMatrix * vec4<f32>(vertex.position.xyz, 1.0));
        var viewPosition = ((globalUniform.viewMat) * worldPos);
        var clipPosition = globalUniform.projMat * viewPosition;

        var ORI_VertexOut: VertexOutput; 
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_Color = vertex.color;
        ORI_VertexOut.member = clipPosition;
        return ORI_VertexOut;
    }
`,Rl=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        // #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        // #endif
        // #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        // #endif
        @builtin(frag_depth) out_depth: f32
    };

    @fragment
    fn main(  
        @location(0) vWorldPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
    ) -> FragmentOutput {
        var result: FragmentOutput;

        // #if USE_WORLDPOS
            result.worldPos = vWorldPos;
        // #endif

        // #if USEGBUFFER
            // result.worldNormal = vec4<f32>(0.0, 0.0, 0.0, 1.0); 
            result.material = vec4<f32>(0.0, 1.0, 0.0, 0.0);
        // #endif

        result.color = varying_Color;

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // let pt = pow((f / n),z);
        // let ratio = n * pt / (f / n);
        // result.out_depth =  ratio ;
        return result;
    }
`;class Ll{constructor(e,t){o(this,"mCount"),o(this,"mBatchSize"),o(this,"mBatchCount"),o(this,"mMinIndexCount"),o(this,"mOffset"),o(this,"mIndexBuffer"),o(this,"mDataBuffer"),o(this,"mBatchBuffers"),o(this,"mVertexShader"),o(this,"mFragmentShader"),o(this,"mRenderPipeline"),o(this,"mRenderPipelineLayout"),o(this,"mVertexBufferLayout"),o(this,"mGPUPrimitiveTopology"),this.mMinIndexCount=e,this.mGPUPrimitiveTopology=t,this.mBatchSize=Math.trunc(65536/this.mMinIndexCount),this.init()}reset(){this.mCount=0,this.mOffset=0,this.mBatchCount=0}addShapeData(e){let t=e.shapeData;for(;t.length>0;){if(this.mOffset>=this.mDataBuffer.length&&this.flush(),this.mOffset+t.length<=this.mDataBuffer.length){this.mDataBuffer.set(t,this.mOffset),this.mOffset+=t.length;break}let r=this.mDataBuffer.length-this.mOffset;this.mDataBuffer.set(t.slice(0,r),this.mOffset),this.mOffset+=r,t=t.slice(r)}}flush(){if(this.mOffset>0){let e;this.mBatchCount<this.mBatchBuffers.length?e=this.mBatchBuffers[this.mBatchCount]:(e=S.device.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.mBatchBuffers.push(e)),S.device.queue.writeBuffer(e,0,this.mDataBuffer,0,this.mOffset),this.mCount+=this.mOffset/8,this.mBatchCount++,this.mOffset=0}}render(e,t){const r=S.device;if(!this.mRenderPipeline){let s=e.outAttachments;if(e.outColor!=-1){let n=s[e.outColor];n.blend=no.getBlend(xe.NONE)}this.mRenderPipelineLayout=r.createPipelineLayout({bindGroupLayouts:[Hr.getGlobalDataBindGroupLayout()]});let a={label:"Graphic3DFixedRenderPipeline",layout:this.mRenderPipelineLayout,vertex:{module:this.mVertexShader,entryPoint:"main",buffers:[this.mVertexBufferLayout]},fragment:{module:this.mFragmentShader,entryPoint:"main",targets:s},primitive:{topology:this.mGPUPrimitiveTopology,cullMode:ui.back,frontFace:"ccw"}};e.depthTexture&&(a.depthStencil={depthWriteEnabled:!0,depthCompare:vt.less_equal,format:e.depthTexture.format}),this.mRenderPipeline=w.createPipeline(a)}if(this.flush(),this.mBatchCount>0){t.setPipeline(this.mRenderPipeline),t.setIndexBuffer(this.mIndexBuffer,"uint16");let s=this.mCount/this.mMinIndexCount;for(let a=Math.trunc(s/this.mBatchSize)-1;a>=0;a--)t.setVertexBuffer(0,this.mBatchBuffers[a]),t.drawIndexed(this.mMinIndexCount*this.mBatchSize,1,0,0,0);s=s%this.mBatchSize,s!=0&&(t.setVertexBuffer(0,this.mBatchBuffers[this.mBatchCount-1]),t.drawIndexed(this.mMinIndexCount*s,1,0,0,0))}}init(){const e=S.device;let t=new Uint16Array((Math.trunc(this.mMinIndexCount*this.mBatchSize/4)+1)*4);for(let r=0;r<t.length;r++)t[r]=r;this.mIndexBuffer=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.mIndexBuffer,0,t),this.mVertexBufferLayout={arrayStride:(4+4)*4,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x4"}]},this.mBatchBuffers=[],this.mDataBuffer=new Float32Array((4+4)*t.length),this.mBatchBuffers.push(e.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})),this.mVertexShader=this.createShaderModule("Graphic3DFixedRenderPipeline.vs",ut.parse(Pl,{})),this.mFragmentShader=this.createShaderModule("Graphic3DFixedRenderPipeline.fs",ut.parse(Rl,{})),this.reset()}createShaderModule(e,t){let r=S.device.createShaderModule({label:e,code:t});return r.getCompilationInfo().then(s=>{s.messages.length>0&&(console.log(t),console.log(s))}),r}}class ei{}o(ei,"ShapeVertexSize",8);class lo{constructor(e){o(this,"uuid"),o(this,"type"),o(this,"color"),o(this,"count",0),o(this,"shapeData"),o(this,"dirtyData",!1),o(this,"memoryDataIndex",-1),o(this,"transformIndex"),this.transformIndex=e}buildAxis(e=new g(0,0,0),t=10){this.buildLines([e,new g(e.x+t,e.y,e.z)],z.hexRGBColor(z.RED)),this.buildLines([e,new g(e.x,e.y+t,e.z)],z.hexRGBColor(z.GREEN)),this.buildLines([e,new g(e.x,e.y,e.z+t)],z.hexRGBColor(z.BLUE))}buildLines(e,t=z.COLOR_WHITE){if(!(e.length<2)){if(e.length==2){this.fillShapeData(e,t);return}var r=new Array(e.length+e.length-2);for(let s=1,a=0;s<e.length;++s)r[a++]=e[s-1],r[a++]=e[s];this.fillShapeData(r,t)}}buildArcLine(e,t,r,s,a=16,n=g.Y_AXIS,l=z.COLOR_WHITE){const h=(s-r)*_e;r*=_e;var u=[];for(let p=0;p<=a;++p){p>1&&u.push(u[u.length-1]);var c=h*(p/a)+r,f=t*Math.cos(c),d=t*Math.sin(c);switch(n){case g.X_AXIS:u.push(e.add(new g(0,f,d)));break;case g.Y_AXIS:u.push(e.add(new g(f,0,d)));break;case g.Z_AXIS:u.push(e.add(new g(f,d,0)));break;default:u.push(e.add(new g(f,d,0)));break}}this.fillShapeData(u,l)}buildCircle(e,t,r=32,s=g.Y_AXIS,a=z.COLOR_WHITE){var n=[];for(let c=0;c<=r;++c){var l=2*Math.PI*c/r,h=t*Math.cos(l),u=t*Math.sin(l);switch(s){case g.X_AXIS:n.push(e.add(new g(0,h,u)));break;case g.Y_AXIS:n.push(e.add(new g(h,0,u)));break;case g.Z_AXIS:n.push(e.add(new g(h,u,0)));break;default:n.push(e.add(new g(h,u,0)));break}c>0&&n.push(n[n.length-1])}n.push(n[0]),this.fillShapeData(n,a)}fillShapeData(e,t){if(!this.shapeData)this.shapeData=new Float32Array(ei.ShapeVertexSize*e.length);else if(this.count+ei.ShapeVertexSize*e.length>=this.shapeData.length){let s=new Float32Array(this.shapeData.length+ei.ShapeVertexSize*e.length);s.set(this.shapeData),this.shapeData=s}const r=this.shapeData;for(let s=0;s<e.length;++s){const a=e[s];if(r[this.count++]=a.x,r[this.count++]=a.y,r[this.count++]=a.z,r[this.count++]=this.transformIndex,t instanceof z)r[this.count++]=t.r,r[this.count++]=t.g,r[this.count++]=t.b,r[this.count++]=t.a;else{const n=t[s];r[this.count++]=n.r,r[this.count++]=n.g,r[this.count++]=n.b,r[this.count++]=n.a}}this.dirtyData=!0}reset(){this.count=0}}class Us extends $t{constructor(e,t){super(),o(this,"shapes"),o(this,"mDirtyData",!1),o(this,"mMinIndexCount"),o(this,"mGPUPrimitiveTopology"),o(this,"mRenderPipeline"),this.alwaysRender=!0,this.mMinIndexCount=e,this.mGPUPrimitiveTopology=t,this.shapes=new Map,this.addRendererMask(Ue.Particle)}fillShapeData(e,t,r,s){this.mDirtyData=!0;var a;this.shapes.has(e)?(a=this.shapes.get(e),a.shapeData.length<ei.ShapeVertexSize*s.length&&(a.shapeData=new Float32Array(ei.ShapeVertexSize*s.length))):(a=new lo(this.transform._worldMatrix.index),a.type=t,a.color=r,a.shapeData=new Float32Array(ei.ShapeVertexSize*s.length));const n=a.shapeData,l=this.transform._worldMatrix.index;for(let h=0,u=0;h<s.length;++h){const c=s[h];n[u++]=c.x,n[u++]=c.y,n[u++]=c.z,n[u++]=l,n[u++]=r.r,n[u++]=r.g,n[u++]=r.b,n[u++]=r.a}this.shapes.set(e,a)}init(){super.init(),this.castGI=!1,this.castShadow=!1,this.mRenderPipeline=new Ll(this.mMinIndexCount,this.mGPUPrimitiveTopology)}removeShape(e){this.shapes.has(e)&&(this.mDirtyData=!0,this.shapes.delete(e))}initPipeline(){this.object3D.bound=new Be(g.ZERO,g.MAX),this._readyPipeline=!0}nodeUpdate(e,t,r,s){this.mDirtyData&&(this.mRenderPipeline.reset(),this.shapes.forEach((a,n)=>{this.mRenderPipeline.addShapeData(a)}),this.mDirtyData=!1)}renderPass2(e,t,r,s,a,n=!1){this.mRenderPipeline.render(r,a)}allocGraphics3DShape(e,t){let r;return this.shapes.has(e)?(r=this.shapes.get(e),r.reset()):(r=new lo(t),r.uuid=e,r.type="line",r.color=z.COLOR_WHITE,this.shapes.set(r.uuid,r)),this.mDirtyData=!0,r}}class Ul{constructor(){o(this,"opaqueList",[]),o(this,"transparentList",[]),o(this,"sky")}clean(){this.opaqueList.length=0,this.transparentList.length=0}}class Ol{constructor(){o(this,"renderGroup"),this.renderGroup=new Map}collect_add(e){let t="",r="";t+=e.geometry.instanceID;for(let a=0;a<e.materials.length;a++){const n=e.materials[a];r+=n.defaultPass.shaderVariant}let s=t+r;this.renderGroup.has(s)||this.renderGroup.set(s,{bundleMap:new Map,key:s,renderNodes:[]}),this.renderGroup.get(s).renderNodes.indexOf(e)==-1&&this.renderGroup.get(s).renderNodes.push(e)}}class Nl{constructor(){o(this,"renderShaderUpdateList",new Map),o(this,"renderNodeList",new Map)}collect_add(e){let t=e.transform.view3D;t&&e.materials&&e.materials.forEach(r=>{let s=this.renderShaderUpdateList.get(t);s||(s=new Map,this.renderShaderUpdateList.set(t,s));let a=this.renderNodeList.get(t);a||(a=new Map,this.renderNodeList.set(t,a)),a.set(e.instanceID,e);let n=r.getAllPass();for(let l=0;l<n.length;l++){const h=n[l];let u=`${e.geometry.instanceID+h.instanceID}`,c=s.get(u);c||(c=new Map,s.set(u,c)),c.set(e.instanceID,e)}})}collect_remove(e){let t=e.transform.view3D;if(t&&e.materials){let r=this.renderShaderUpdateList.get(t);r&&e.materials.forEach(s=>{let a=s.getAllPass();for(let n=0;n<a.length;n++){const l=a[n];let h=`${e.geometry.instanceID+l.instanceID}`;r.delete(h)}})}}}const Fl=class{constructor(){o(this,"_sceneLights"),o(this,"_sceneGIProbes"),o(this,"_op_RenderNodes"),o(this,"_tr_RenderNodes"),o(this,"_octreeRenderNodes"),o(this,"_graphics"),o(this,"_op_renderGroup"),o(this,"_tr_renderGroup"),o(this,"_renderShaderCollect"),o(this,"state",{giLightingChange:!0}),o(this,"sky"),o(this,"_collectInfo"),o(this,"rendererOctree"),this._sceneLights=new Map,this._sceneGIProbes=new Map,this._op_RenderNodes=new Map,this._tr_RenderNodes=new Map,this._graphics=[],this._op_renderGroup=new Map,this._tr_renderGroup=new Map,this._collectInfo=new Ul,this._renderShaderCollect=new Nl,this._octreeRenderNodes=new Map}static get instance(){return this._instance||(this._instance=new Fl),this._instance}getPashList(i,e){if(e.renderOrder<3e3)return this._op_RenderNodes.get(i);if(e.renderOrder>=3e3)return this._tr_RenderNodes.get(i)}sortRenderNode(i,e){for(let t=i.length-1;t>0;t--)if(i[t].renderOrder<e.renderOrder){i.push(e);return}i.push(e)}addRenderNode(i,e){if(!i)return;let t=e.renderOrder>=3e3;if(e.hasMask(Ue.Sky))this.sky=e;else if(e instanceof Us)this._graphics.indexOf(e)==-1&&this._graphics.push(e);else if(oo.hasMask(e.renderLayer,Yr.None)){this.removeRenderNode(i,e);let r=t?this._tr_RenderNodes:this._op_RenderNodes;r.has(i)||r.set(i,[]),r.get(i).push(e),A.setting.occlusionQuery.octree&&e.attachSceneOctree(this.getOctree(i));let s=this.getPashList(i,e);s.indexOf(e)==-1&&this.sortRenderNode(s,e)}else{this.removeRenderNode(i,e);let r=t?this._tr_renderGroup:this._op_renderGroup;r.has(i)||r.set(i,new Ol),r.get(i).collect_add(e)}e.object3D.renderNode=e,this._renderShaderCollect.collect_add(e)}getOctree(i){let e,t=A.setting.occlusionQuery.octree;if(t&&(e=this._octreeRenderNodes.get(i),!e)){let r=new g(t.x,t.y,t.z),s=new g(t.width,t.height,t.depth),a=new Be(r,s);e=new er(a),this._octreeRenderNodes.set(i,e)}return e}removeRenderNode(i,e){if(e.detachSceneOctree(),e.hasMask(Ue.Sky))this.sky=null;else if(oo.hasMask(e.renderLayer,Yr.None)){let t=this.getPashList(i,e);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r,1)}}this._renderShaderCollect.collect_remove(e)}addLight(i,e){if(!this._sceneLights.has(i))this._sceneLights.set(i,[e]);else{let t=this._sceneLights.get(i);if(t.length>=A.setting.light.maxLight){console.warn("Alreay meet maxmium light number:",A.setting.light.maxLight);return}t.indexOf(e)!=-1||t.push(e)}}removeLight(i,e){if(this._sceneLights.has(i)){let t=this._sceneLights.get(i),r=t.indexOf(e);r!=-1&&t.splice(r,1)}}getLights(i){let e=this._sceneLights.get(i);return e||[]}addGIProbe(i,e){this._sceneGIProbes.has(i)?this._sceneGIProbes.get(i).push(e):this._sceneGIProbes.set(i,[e])}removeGIProbe(i,e){if(this._sceneGIProbes.has(i)){let t=this._sceneGIProbes.get(i),r=t.indexOf(e);r!=-1&&t.splice(r,1)}}getProbes(i){let e=this._sceneGIProbes.get(i);return e||[]}autoSortRenderNodes(i){let e=this._tr_RenderNodes.get(i);if(!e)return;let t=!1;for(const r of e)if(r.isRenderOrderChange||r.needSortOnCameraZ){t=!0;break}if(t){for(const r of e){let s=r.renderOrder;if(r.needSortOnCameraZ){let a=El.worldToCameraDepth(r.object3D);a=1-Math.max(0,Math.min(1,a)),s+=a}r.__renderOrder=s,r.isRenderOrderChange=!1}e.sort((r,s)=>r.__renderOrder>s.__renderOrder?1:-1)}return this}getRenderNodes(i,e){if(this._collectInfo.clean(),this._collectInfo.sky=this.sky,A.setting.occlusionQuery.octree)this.rendererOctree=this.getOctree(i),this.rendererOctree.getRenderNode(e.frustum,this._collectInfo);else{let t=this._op_RenderNodes.get(i);t&&(this._collectInfo.opaqueList=t.concat());let r=this._tr_RenderNodes.get(i);r&&(this._collectInfo.transparentList=r.concat())}return this._collectInfo}getOpRenderGroup(i){return this._op_renderGroup.get(i)}getTrRenderGroup(i){return this._tr_renderGroup.get(i)}getGraphicList(){return this._graphics}getRenderShaderCollect(i){return this._renderShaderCollect.renderShaderUpdateList.get(i)||[]}};let Q=Fl;o(Q,"_instance");class kl{constructor(){o(this,"setting"),o(this,"probesBufferData"),o(this,"probesBuffer"),o(this,"isVolumeFrameChange",!0),o(this,"randomOrientation"),o(this,"startPosition",new g),o(this,"isVolumeChange",!0),o(this,"irradianceVolumeBuffer"),o(this,"directionDistance",20),o(this,"randomSeedCount",3),o(this,"useRandomIndex",0),o(this,"centerDirection",new g(0,0,this.directionDistance).normalize(1)),o(this,"arroundPositions",[]),o(this,"debugX",0),o(this,"debugY",0),o(this,"debugZ",0)}updateOrientation(){return this.useRandomIndex++,this.useRandomIndex>=this.arroundPositions.length&&(this.useRandomIndex=0),V.fromToRotation(this.centerDirection,this.arroundPositions[this.useRandomIndex],this.randomOrientation),this.randomOrientation}init(e){this.setting=e,this.randomOrientation=new V(!1),this.randomOrientation.identity(),this.irradianceVolumeBuffer=new ge(80),this.createFramesBuffer(),this.arroundPositions.push(this.centerDirection.clone());for(let t=0;t<this.randomSeedCount;t++){let r=Math.PI*2*t/this.randomSeedCount,s=new g(Math.sin(r),Math.cos(r),this.directionDistance).normalize(1);this.arroundPositions.push(s)}}setVolumeDataChange(){this.isVolumeChange=!0}updateProbes(e){let t=this.probesBufferData;for(let r of e){let s=r.index*4;t[s+3]=r.drawCallFrame}}createFramesBuffer(){if(!this.probesBufferData){let e=this.setting.probeXCount*this.setting.probeYCount*this.setting.probeZCount;this.probesBufferData=new Float32Array(e*4),this.probesBufferData.fill(-1),this.probesBuffer=new ge(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}}uploadBuffer(){this.isVolumeChange&&(this.fillIrradianceData(),this.isVolumeChange=!1,this.isVolumeFrameChange=!0),this.probesBuffer.setFloat32Array("uniformFramesBuffer",this.probesBufferData)}calcPosition(e,t,r,s){let a=this.setting,n=this.setting.probeSpace;return s=s||new g,s.x=e*n-n*(a.probeXCount-1)*.5+a.offsetX,s.y=t*n-n*(a.probeYCount-1)*.5+a.offsetY,s.z=r*n-n*(a.probeZCount-1)*.5+a.offsetZ,s}fillIrradianceData(){let e=this.setting,t=this.calcPosition(0,0,0,this.startPosition);this.irradianceVolumeBuffer.setFloat("orientationIndex",this.randomOrientation.index),this.irradianceVolumeBuffer.setFloat("hysteresis",e.hysteresis),this.irradianceVolumeBuffer.setFloat("OctRTSideSize",e.octRTSideSize),this.irradianceVolumeBuffer.setFloat("OctRTMaxSize",e.octRTMaxSize),this.irradianceVolumeBuffer.setFloat("startX",t.x),this.irradianceVolumeBuffer.setFloat("startY",t.y),this.irradianceVolumeBuffer.setFloat("startZ",t.z),this.irradianceVolumeBuffer.setFloat("ProbeSpace",e.probeSpace),this.irradianceVolumeBuffer.setFloat("probeXCount",e.probeXCount),this.irradianceVolumeBuffer.setFloat("probeYCount",e.probeYCount),this.irradianceVolumeBuffer.setFloat("probeZCount",e.probeZCount),this.irradianceVolumeBuffer.setFloat("maxDistance",e.probeSpace*1.732),this.irradianceVolumeBuffer.setFloat("depthSharpness",e.depthSharpness),this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize",e.probeSourceTextureSize),this.irradianceVolumeBuffer.setFloat("ProbeSize",e.probeSize),this.irradianceVolumeBuffer.setFloat("bounceIntensity",e.bounceIntensity),this.irradianceVolumeBuffer.setFloat("probeRoughness",e.probeRoughness),this.irradianceVolumeBuffer.setFloat("normalBias",e.normalBias),this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias",e.irradianceChebyshevBias),this.irradianceVolumeBuffer.setFloat("rayNumber",e.rayNumber),this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias",e.irradianceDistanceBias),this.irradianceVolumeBuffer.setFloat("indirectIntensity",e.indirectIntensity),this.irradianceVolumeBuffer.setFloat("ddgiGamma",e.ddgiGamma),this.irradianceVolumeBuffer.setFloat("lerpHysteresis",e.lerpHysteresis),this.irradianceVolumeBuffer.setFloat("debugX",this.debugX),this.irradianceVolumeBuffer.setFloat("debugY",this.debugY),this.irradianceVolumeBuffer.setFloat("debugZ",this.debugZ),this.irradianceVolumeBuffer.apply()}}class zl{constructor(){o(this,"storageGPUBuffer"),o(this,"irradianceVolume"),o(this,"_lightList",[]),this.storageGPUBuffer=new ge(Gr.lightSize*A.setting.light.maxLight,GPUBufferUsage.COPY_SRC),this.irradianceVolume=new kl,this.irradianceVolume.init(A.setting.gi);for(let e=0;e<A.setting.light.maxLight;e++){let t=this.storageGPUBuffer.memory.allocation_node(Gr.lightSize*4);this._lightList.push(t)}this.storageGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e){this.storageGPUBuffer.clean();let t=Q.instance.getLights(e.scene);for(let r=0;r<t.length;r++){const s=t[r].lightData;s.index=r,this.writeLightBytes(s,this._lightList[r])}this.storageGPUBuffer.apply()}writeLightBytes(e,t){t.offset=0,t.writeFloat(e.index),t.writeInt32(e.lightType),t.writeFloat(e.radius),t.writeFloat(e.linear),t.writeVector3(e.lightPosition),t.writeFloat(e.lightMatrixIndex),t.writeVector3(e.direction),t.writeFloat(e.quadratic),t.writeRGBColor(e.lightColor),t.writeFloat(e.intensity),t.writeFloat(e.innerAngle),t.writeFloat(e.outerAngle),t.writeFloat(e.range),t.writeInt32(e.castShadowIndex),t.writeVector3(e.lightTangent),t.writeFloat(e.iesIndex)}}class Gl{constructor(){o(this,"gpuBuffer"),o(this,"probes"),o(this,"memoryDo"),o(this,"_probeInfoList")}initDataUniform(e){this.memoryDo=new zr,this.probes=e,this._probeInfoList=[],this.memoryDo.destroy(),this.memoryDo.allocation(e.length*17*4);for(let r=0;r<e.length;r++){var t=17;let s=this.memoryDo.allocation_node(t*4);this._probeInfoList.push(s);let a=e[r].transform.worldPosition;s.setArray(0,[a.x,a.y,a.z])}this.gpuBuffer=S.device.createBuffer({size:this.memoryDo.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,label:"ProbeBuffer",mappedAtCreation:!1})}updateGPUBuffer(){const e=this.memoryDo.shareDataBuffer;let t=this.memoryDo.shareDataBuffer.byteLength,r=0;const s=5e3*64;for(;r<t;)S.device.queue.writeBuffer(this.gpuBuffer,r,e,r,Math.floor(Math.min(s,t-r))),r+=s}}class Ql extends Jt{constructor(e,t=0,r){super(),o(this,"size"),this.bufferType=Mt.StorageGPUBuffer,this.size=e,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r)}writeBufferByHeap(e,t){let r=S.device;if(e.length>0){let s=null;for(;this.mapAsyncReady.length&&(s=this.mapAsyncReady.shift(),s.usedSize!=e.byteLength);)s.destroy(),this.mapAsyncBuffersOutstanding--,s=null;s||(s=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),s.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(s.getMappedRange(0,t*4)).set(a),s.unmap();const l=r.createCommandEncoder();l.copyBufferToBuffer(s,0,this.buffer,0,t*4),r.queue.submit([l.finish()]),s.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(s))}}}class Vl{constructor(){o(this,"uuid"),o(this,"index"),o(this,"usage"),o(this,"groupBufferSize"),o(this,"matrixBufferDst"),this.uuid=Pt(),this.groupBufferSize=0,this.usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.cacheWorldMatrix()}cacheWorldMatrix(){this.groupBufferSize=V.maxCount*V.blockBytes,this.matrixBufferDst=new Ql(this.groupBufferSize/4),this.matrixBufferDst.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBufferDst.buffer.label=this.groupBufferSize.toString()}writeBuffer(e){const t=V.dynamicMatrixBytes;this.matrixBufferDst.mapAsyncWrite(t,e)}}class pe{static init(){this.modelMatrixBindGroup=new Vl,this._cameraBindGroups=new Map,this._lightEntriesMap=new Map}static getCameraGroup(e){let t=this._cameraBindGroups.get(e);return t||(t=new Sl(this.modelMatrixBindGroup),this._cameraBindGroups.set(e,t)),e.isShadowCamera?t.setShadowCamera(e):t.setCamera(e),t}static getLightEntries(e){e||console.log("getLightEntries scene is null");let t=this._lightEntriesMap.get(e);return t||(t=new zl,this._lightEntriesMap.set(e,t)),this._lightEntriesMap.get(e)}static updateProbes(e){this._probeEntries||(this._probeEntries=new Gl,this._probeEntries.initDataUniform(e))}}o(pe,"_cameraBindGroups"),o(pe,"_lightEntriesMap"),o(pe,"_probeEntries"),o(pe,"modelMatrixBindGroup");const jr=class{static bindPipeline(i,e){if(jr.lastShader!=e)jr.lastShader=e;else return;jr.lastPipeline!=e.pipeline&&(jr.lastPipeline=e.pipeline,i.setPipeline(e.pipeline));for(let t=1;t<e.bindGroups.length;t++){const r=e.bindGroups[t];r&&i.setBindGroup(t,r)}}static bindCamera(i,e){let t=pe.getCameraGroup(e);i.setBindGroup(0,t.globalBindGroup)}static bindGeometryBuffer(i,e){if(this.lastGeometry!=e){this.lastGeometry=e,e.indicesBuffer&&i.setIndexBuffer(e.indicesBuffer.indicesGPUBuffer.buffer,e.indicesBuffer.indicesFormat);let t=e.vertexBuffer.vertexGPUBuffer,r=e.vertexBuffer.vertexBufferLayouts;for(let s=0;s<r.length;s++){const a=r[s];i.setVertexBuffer(s,t.buffer,a.offset,a.size)}}}static cleanCache(){this.lastGeometry=null,this.lastPipeline=null,this.lastShader=null}static createPipeline(i){return ft.countStart("GPUContext","pipeline"),S.device.createRenderPipeline(i)}static beginCommandEncoder(){return ft.countStart("GPUContext","beginCommandEncoder"),this.LastCommand&&S.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=S.device.createCommandEncoder(),this.LastCommand}static endCommandEncoder(i){this.LastCommand==i&&(S.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=null,ft.countStart("GPUContext","endCommandEncoder"))}static recordBundleEncoder(i){return S.device.createRenderBundleEncoder(i)}static beginRenderPass(i,e){if(this.cleanCache(),this.renderPassCount++,this.lastRenderPassState=e,e.renderTargets&&e.renderTargets.length>0){for(let t=0;t<e.renderTargets.length;++t){const r=e.renderTargets[t];let s=e.renderPassDescriptor.colorAttachments[t];e.multisample>0&&e.renderTargets.length==1?(s.view=e.multiTexture.createView(),s.resolveTarget=r.getGPUView()):s.view=r.getGPUTexture().createView()}return i.beginRenderPass(e.renderPassDescriptor)}else{let t=e.renderPassDescriptor.colorAttachments[0];return t&&(e.multisample>0?(t.view=e.multiTexture.createView(),t.resolveTarget=S.context.getCurrentTexture().createView()):t.view=S.context.getCurrentTexture().createView()),i.beginRenderPass(e.renderPassDescriptor)}}static drawIndexed(i,e,t,r,s,a){i.drawIndexed(e,t,r,s,a),this.drawCount++}static draw(i,e,t,r,s){i.draw(e,t,r,s),this.drawCount++}static endPass(i){i.insertDebugMarker("end"),i.end()}static computeCommand(i,e){let t=i.beginComputePass();for(let r=0;r<e.length;r++)e[r].compute(t);t.end()}};let w=jr;o(w,"lastGeometry"),o(w,"lastPipeline"),o(w,"lastShader"),o(w,"drawCount",0),o(w,"renderPassCount",0),o(w,"geometryCount",0),o(w,"pipelineCount",0),o(w,"matrixCount",0),o(w,"lastRenderPassState"),o(w,"LastCommand");class Hl{constructor(){o(this,"source"),o(this,"input"),o(this,"output")}reset(e){this.input&&this.input.destroy(),this.output&&this.output.destroy(),this.input=this.output=null,this.source=e}apply(e){if(this.source){if(!this.input){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this.input=new ge(this.source.length,t,this.source),this.input.apply()}if(!this.output){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;this.output=new ge(e*3,t),this.output.apply()}}}}class Yl{constructor(){o(this,"enable"),o(this,"morphTargetsRelative"),o(this,"MaxMorphTargetCount",64),o(this,"_computeConfigArray"),o(this,"_computeConfigBuffer"),o(this,"_morphInfluenceArray"),o(this,"_morphInfluenceBuffer"),o(this,"_positionAttrDataGroup"),o(this,"_normalAttrDataGroup"),o(this,"_isInfluenceDirty"),o(this,"_morphTargetCount"),o(this,"_totalVertexCount"),o(this,"_computeShader"),o(this,"_computeShaders"),o(this,"_computeWorkGroupXY",1),o(this,"_collectMorphTargetData"),this._isInfluenceDirty=!0,this.generateGPUBuffer(),this._positionAttrDataGroup=new Hl,this._normalAttrDataGroup=new Hl}initMorphTarget(e){this._collectMorphTargetData=this.collectMorphTargetList(e),this._computeShader&&this._computeShader.destroy();let t=Le.CsMain;this._computeShader=new be(t),this._collectMorphTargetData.mergedNormal?this._computeShader.setDefine("USE_MORPHNORMALS",!0):this._computeShader.deleteDefine("USE_MORPHNORMALS"),this._computeShaders=[this._computeShader],this._isInfluenceDirty=!0,this._morphTargetCount=this._collectMorphTargetData.mtCount,this._totalVertexCount=this._collectMorphTargetData.vCount,this._morphInfluenceArray.fill(0),this._computeWorkGroupXY=this.calcWorkGroup(this._totalVertexCount),this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos),this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal)}applyRenderShader(e){this.uploadMorphTargetBuffer(),this.uploadConfigGBuffer(),e.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),e.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&e.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)}computeMorphTarget(e){this.uploadConfigGBuffer(),this.uploadMorphTargetBuffer(),this._computeShader.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),this._computeShader.setStorageBuffer("morphTargetInfluence",this._morphInfluenceBuffer),this._computeShader.setStorageBuffer("morphTargetPositions",this._positionAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&(this._computeShader.setStorageBuffer("morphTargetNormals",this._normalAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)),this._computeShader.workerSizeX=this._computeWorkGroupXY,this._computeShader.workerSizeY=this._computeWorkGroupXY,this._computeShader.workerSizeZ=1,w.computeCommand(e,this._computeShaders)}updateInfluence(e,t){this._isInfluenceDirty=!0,this._morphInfluenceArray[e]=t}collectMorphTargetList(e){let t=this.collectAttribute("a_morphPositions_",e),r=t.length,s=t[0].data.length/3,a=new Float32Array(s*r*3);{let h=0;for(let u=0;u<r;u++){let c=t[u];a.set(c.data,h),h+=c.data.length}}let n=this.collectAttribute("a_morphNormals_",e),l;if(n&&n.length>0){let h=0;l=new Float32Array(s*r*3);for(let u=0;u<r;u++){let c=n[u];l.set(c.data,h),h+=c.data.length}}return{mtCount:r,vCount:s,mergedPos:a,mergedNormal:l}}collectAttribute(e,t){let r=[];for(let s=0;s<this.MaxMorphTargetCount;s++){let a=e+s,n=t.getAttribute(a);if(n)r[s]=n;else break}return r}uploadConfigGBuffer(){if(this._isInfluenceDirty){let e=0;for(let t=0;t<this._morphTargetCount;t++)e+=this._morphInfluenceArray[t];this._morphInfluenceBuffer.setFloat32Array("data",this._morphInfluenceArray),this._morphInfluenceBuffer.apply(),this._computeConfigArray[0]=this.morphTargetsRelative?1:1-e,this._computeConfigArray[1]=this._morphTargetCount,this._computeConfigArray[2]=this._totalVertexCount,this._computeConfigArray[3]=this._computeWorkGroupXY,this._computeConfigBuffer.setFloat32Array("data",this._computeConfigArray),this._computeConfigBuffer.apply(),this._isInfluenceDirty=!1}}calcWorkGroup(e){let t=Math.ceil(Math.sqrt(e)),r=Math.ceil(Math.log2(t));return t=Math.pow(2,r),t}uploadMorphTargetBuffer(){this._positionAttrDataGroup.output||this._positionAttrDataGroup.apply(this._totalVertexCount),this._normalAttrDataGroup.output||this._normalAttrDataGroup.apply(this._totalVertexCount)}generateGPUBuffer(){this._computeConfigArray=new Float32Array(4),this._computeConfigBuffer=new Dt(4),this._morphInfluenceArray=new Float32Array(this.MaxMorphTargetCount);let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this._morphInfluenceBuffer=new ge(this.MaxMorphTargetCount,e)}}var Xd=Object.defineProperty,Wd=Object.getOwnPropertyDescriptor,Os=(i,e,t,r)=>{for(var s=r>1?void 0:r?Wd(e,t):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(r?n(e,t,s):n(s))||s);return r&&s&&Xd(e,t,s),s};const Xl=class extends $t{constructor(){super(),o(this,"receiveShadow"),o(this,"morphData")}onEnable(){super.onEnable()}onDisable(){super.onDisable()}cloneTo(i){i.addComponent(Xl).copyComponent(this)}copyComponent(i){return super.copyComponent(i),this.receiveShadow=i.receiveShadow,this}get geometry(){return this._geometry}set geometry(i){super.geometry=i;let e=i.morphTargetDictionary!=null;e&&(this.morphData||(this.morphData=new Yl),this.morphData.morphTargetsRelative=i.morphTargetsRelative,this.morphData.initMorphTarget(i)),this.morphData&&(this.morphData.enable=e),this.morphData&&this.morphData.enable?this.addRendererMask(Ue.MorphTarget):this.removeRendererMask(Ue.MorphTarget),this.object3D.bound=this._geometry.bounds.clone(),this._readyPipeline&&this.initPipeline()}get material(){return this._materials[0]}set material(i){this.materials=[i]}setMorphInfluence(i,e){if(this.morphData&&this.morphData.enable){let t=this._geometry.morphTargetDictionary[i];t>=0&&this.morphData.updateInfluence(t,e)}}setMorphInfluenceIndex(i,e){this.morphData&&this.morphData.enable&&i>=0&&this.morphData.updateInfluence(i,e)}onCompute(i,e){this.morphData&&this.morphData.enable&&this.morphData.computeMorphTarget(e)}nodeUpdate(i,e,t,r){if(this.morphData&&this.morphData.enable)for(let s=0;s<this.materials.length;s++){let n=this.materials[s].getPass(e);if(n)for(let l=0;l<n.length;l++)this.morphData.applyRenderShader(n[l])}super.nodeUpdate(i,e,t,r)}destroy(i){super.destroy(i)}};let ce=Xl;Os([Vt],ce.prototype,"geometry",1),Os([Vt],ce.prototype,"geometry",1),Os([Vt],ce.prototype,"material",1),Os([Vt],ce.prototype,"material",1);class Wl{constructor(){o(this,"label",""),o(this,"customSize",!1),o(this,"zPreTexture",null),o(this,"depthTexture",null),o(this,"outAttachments"),o(this,"outColor",-1),o(this,"renderTargets"),o(this,"rtTextureDescripts"),o(this,"irradianceBuffer"),o(this,"multisample",0),o(this,"multiTexture"),o(this,"depthViewIndex",0),o(this,"depthCleanValue",0),o(this,"isOutTarget",!0),o(this,"camera3D"),o(this,"rtFrame"),o(this,"renderPassDescriptor"),o(this,"renderBundleEncoderDescriptor"),o(this,"depthLoadOp")}getLastRenderTexture(){return this.renderTargets&&this.renderTargets.length>0?this.renderTargets[0]:A.res.redTexture}}const qr=class{static createRendererPassState(i,e=null){let t=new Wl;if(t.label=i.label,t.customSize=i.customSize,t.rtFrame=i,t.zPreTexture=i.zPreTexture,t.depthTexture=i.depthTexture,t.depthViewIndex=i.depthViewIndex,t.isOutTarget=i.isOutTarget,t.depthCleanValue=i.depthCleanValue,t.depthLoadOp=i.depthLoadOp,i&&i.attachments.length>0){t.renderTargets=i.attachments,t.rtTextureDescripts=i.rtDescriptors,t.renderPassDescriptor=qr.getRenderPassDescriptor(t),t.renderBundleEncoderDescriptor=qr.getRenderBundleDescriptor(t),t.outAttachments=[];for(let r=0;r<i.attachments.length;r++){const s=i.attachments[r];t.outAttachments[r]={format:s.format},s.name.indexOf(Ae.colorBufferTex_NAME)!=-1&&(t.outColor=r)}}else t.renderPassDescriptor=qr.getRenderPassDescriptor(t,e),t.renderBundleEncoderDescriptor=qr.getRenderBundleDescriptor(t),t.outAttachments=[{format:S.presentationFormat}],t.outColor=0;return t}static getRenderPassDescriptor(i,e=null){S.device,S.presentationSize;let t=[];if(i.renderTargets&&i.renderTargets.length>0){i.renderTargets[0].width,i.renderTargets[0].height;for(let s=0;s<i.renderTargets.length;s++){const a=i.renderTargets[s],n=i.rtTextureDescripts[s];t.push({view:a.getGPUView(),resolveTarget:void 0,loadOp:n.loadOp,clearValue:n.clearValue,storeOp:n.storeOp})}}else if(!i.customSize){let s=S.canvasConfig&&S.canvasConfig.alpha?[1,1,1,0]:[0,0,0,1];i.isOutTarget==!0&&t.push({view:void 0,resolveTarget:void 0,loadOp:S.canvasConfig&&S.canvasConfig.alpha||e!=null?"load":"clear",clearValue:s,storeOp:"store"})}let r=null;return i.depthTexture||i.zPreTexture?(i.zPreTexture&&(i.depthTexture=i.zPreTexture),r={label:`${i.label} renderPassDescriptor zPreTexture${i.zPreTexture?"load":"clear"}`,colorAttachments:t,depthStencilAttachment:{view:i.depthTexture.getGPUView(),depthLoadOp:i.zPreTexture?"load":i.depthLoadOp,depthClearValue:i.zPreTexture?1:i.depthCleanValue,depthStoreOp:"store"}}):r={colorAttachments:t,label:"renderPassDescriptor not writeDepth"},this.renderPassDescriptorCount++,r}static getRenderBundleDescriptor(i){S.presentationSize;let e=[];if(i.renderTargets&&i.renderTargets.length>0){i.renderTargets[0].width,i.renderTargets[0].height;for(let r=0;r<i.renderTargets.length;r++){const s=i.renderTargets[r];e.push(s.format)}}let t=null;return i.depthTexture?t={colorFormats:e,depthStencilFormat:i.depthTexture.format}:t={colorFormats:e},this.renderPassDescriptorCount++,t}};let He=qr;o(He,"bindGroupDescriptorCount",0),o(He,"bindTextureDescriptorCount",0),o(He,"renderPassDescriptorCount",0),o(He,"pipelineDescriptorCount",0);var Y=(i=>(i.position="position",i.normal="normal",i.uv="uv",i.TANGENT="TANGENT",i.TEXCOORD_1="TEXCOORD_1",i.TEXCOORD_2="TEXCOORD_2",i.color="color",i.joints0="joints0",i.joints1="joints1",i.weights0="weights0",i.weights1="weights1",i.weight="weight",i.indices="indices",i.vIndex="vIndex",i.a_morphPositions_0="a_morphPositions_0",i))(Y||{});class ho extends Jt{constructor(e){super(),o(this,"node"),this.bufferType=Mt.VertexGPUBuffer,this.createVertexBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,e)}createVertexBuffer(e,t){let r=S.device;this.byteSize=t*Float32Array.BYTES_PER_ELEMENT,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),this.node=this.memory.allocation_node(this.byteSize)}}var ti=(i=>(i[i.split=0]="split",i[i.compose=1]="compose",i))(ti||{});class jl{constructor(){o(this,"vertexCount",0),o(this,"vertexGPUBuffer"),o(this,"geometryType",ti.compose),o(this,"_vertexBufferLayouts"),o(this,"_attributeSlotLayouts"),o(this,"_attributeLocation"),this._vertexBufferLayouts=[],this._attributeLocation={},this._attributeSlotLayouts=[]}get vertexBufferLayouts(){return this._vertexBufferLayouts}createVertexBuffer(e,t){switch(this.geometryType){case ti.split:this.createSplitVertexBuffer(e,t);break;case ti.compose:this.createComposeVertexBuffer(e,t);break}}createSplitVertexBuffer(e,t){let r=0;for(let s=0;s<t.attributes.length;s++){const a=t.attributes[s];if(a.name=="index")continue;this._attributeLocation[a.name]=a.location;let n={name:a.name,format:a.format,offset:0,shaderLocation:a.location,stride:bi[a.format]};this._attributeSlotLayouts[a.location]=[n];let l=e.get(a.name);l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,l));let h=l.data.length/n.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,this._vertexBufferLayouts[a.location]={name:a.name,arrayStride:a.size*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[a.location],offset:r*4,size:this.vertexCount*a.size*4},r+=this.vertexCount*a.size}this.vertexGPUBuffer=new ho(r)}createComposeVertexBuffer(e,t){this._attributeSlotLayouts[0]=[];let r=0;for(let s=0;s<t.attributes.length;s++){const a=t.attributes[s];if(a.name=="index"||a.type=="builtin")continue;this._attributeLocation[a.name]=a.location;let n={name:a.name,format:a.format,offset:r*4,shaderLocation:a.location,stride:bi[a.format]};this._attributeSlotLayouts[0][a.location]=n;let l=e.get(a.name);l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,l));let h=l.data.length/n.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,r+=a.size}this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new ho(this.vertexCount*r)}upload(e,t){var r;if(this.vertexGPUBuffer){switch(this.geometryType){case ti.split:{let s=this._attributeLocation[e],a=this._vertexBufferLayouts[s];this.vertexGPUBuffer.node.setFloat32Array(a.offset/4,t.data)}break;case ti.compose:for(let s=0;s<this.vertexCount;s++){const a=this._attributeSlotLayouts[0][this._attributeLocation[e]];for(let n=0;n<a.stride;n++){let l=t.data[s*a.stride+n],h=s*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+n;this.vertexGPUBuffer.node.setFloat(l,h)}}break}(r=this.vertexGPUBuffer)==null||r.apply()}}updateAttributes(e){switch(this.geometryType){case ti.split:for(let t=0;t<this._vertexBufferLayouts.length;t++){const r=this._vertexBufferLayouts[t];let s=e.get(r.name);this.vertexGPUBuffer.node.setFloat32Array(r.offset/4,s.data)}break;case ti.compose:for(let t=0;t<this.vertexCount;t++)this._attributeSlotLayouts.forEach(r=>{for(let s=0;s<r.length;s++){const a=r[s];let n=e.get(a.name);for(let l=0;l<a.stride;l++){let h=n.data[t*a.stride+l],u=t*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+l;this.vertexGPUBuffer.node.setFloat(h,u)}}});break}this.vertexGPUBuffer.apply()}compute(){}destroy(e){this.vertexCount=null,this.geometryType=null,this._vertexBufferLayouts=null,this._attributeSlotLayouts=null,this._attributeLocation=null,this.vertexGPUBuffer&&this.vertexGPUBuffer.destroy(e),this.vertexGPUBuffer=null}}class ql extends Jt{constructor(e){super(),o(this,"indicesNode"),this.bufferType=Mt.IndicesGPUBuffer,this.createIndicesBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDEX|GPUBufferUsage.INDIRECT,e)}createIndicesBuffer(e,t){let r=S.device;this.byteSize=t.length*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory.allocation(this.byteSize),t&&(this.indicesNode=this.memory.allocation_node(t.length*4),this.indicesNode.setArrayBuffer(0,t),this.apply())}}class Kl{constructor(){o(this,"uuid",""),o(this,"name"),o(this,"indicesGPUBuffer"),o(this,"indicesFormat","uint16"),o(this,"indicesCount",0)}createIndicesBuffer(e){e.data instanceof Uint16Array?this.indicesFormat="uint16":e.data instanceof Uint32Array&&(this.indicesFormat="uint32"),this.indicesCount=e.data.length,this.indicesGPUBuffer=new ql(e.data)}upload(e){this.indicesGPUBuffer.indicesNode.setArrayBuffer(0,e),this.indicesGPUBuffer.apply()}compute(){}destroy(){this.uuid=null,this.name=null,this.indicesFormat=null,this.indicesCount=null,this.indicesGPUBuffer.destroy(),this.indicesGPUBuffer=null}}class Jl{constructor(){o(this,"lodLevels")}}const Ti=class{constructor(){o(this,"instanceID"),o(this,"name"),o(this,"subGeometries",[]),o(this,"morphTargetsRelative"),o(this,"morphTargetDictionary"),o(this,"_bounds"),o(this,"_attributeMap"),o(this,"_attributes"),o(this,"_indicesBuffer"),o(this,"_vertexBuffer"),o(this,"_onChange",!0),this.instanceID=Pt(),this._attributeMap=new Map,this._attributes=[],this._vertexBuffer=new jl}get indicesBuffer(){return this._indicesBuffer}get vertexBuffer(){return this._vertexBuffer}get vertexAttributes(){return this._attributes}get vertexAttributeMap(){return this._attributeMap}get geometryType(){return this._vertexBuffer.geometryType}set geometryType(i){this._vertexBuffer.geometryType=i}get bounds(){if(!this._bounds){this._bounds=new Be(new g,new g(1,1,1)),this._bounds.min.x=Number.MAX_VALUE,this._bounds.min.y=Number.MAX_VALUE,this._bounds.min.z=Number.MAX_VALUE,this._bounds.max.x=-Number.MAX_VALUE,this._bounds.max.y=-Number.MAX_VALUE,this._bounds.max.z=-Number.MAX_VALUE;let i=this.getAttribute(Y.position);if(i)for(let e=0;e<i.data.length/3;e++){const t=i.data[e*3+0],r=i.data[e*3+1],s=i.data[e*3+2];this._bounds.min.x>t&&(this._bounds.min.x=t),this._bounds.min.y>r&&(this._bounds.min.y=r),this._bounds.min.z>s&&(this._bounds.min.z=s),this._bounds.max.x<t&&(this._bounds.max.x=t),this._bounds.max.y<r&&(this._bounds.max.y=r),this._bounds.max.z<s&&(this._bounds.max.z=s)}this._bounds.setFromMinMax(this._bounds.min,this._bounds.max)}return this._bounds}set bounds(i){this._bounds=i}addSubGeometry(...i){let e=new Jl;e.lodLevels=i,this.subGeometries.push(e)}generate(i){this._onChange&&(this._onChange=!1,this._indicesBuffer.upload(this.getAttribute(Y.indices).data),this._vertexBuffer.createVertexBuffer(this._attributeMap,i),this._vertexBuffer.updateAttributes(this._attributeMap))}setIndices(i){if(!this._attributeMap.has(Y.indices)){let e={attribute:Y.indices,data:i};this._attributeMap.set(Y.indices,e),this._indicesBuffer=new Kl,this._indicesBuffer.createIndicesBuffer(e)}}setAttribute(i,e){if(i==Y.indices)this.setIndices(e);else{let t={attribute:i,data:e};this._attributeMap.set(i,t),this._attributes.push(i)}}getAttribute(i){return this._attributeMap.get(i)}hasAttribute(i){return this._attributeMap.has(i)}genWireframe(){let i=this.getAttribute("position"),e=this.getAttribute("indices");if(e&&i&&e.data.length>0){let t=i.data,r=[];for(let s=0;s<e.data.length/3;s++){const a=e.data[s*3+0],n=e.data[s*3+1],l=e.data[s*3+2];let h=new g(t[a*3+0],t[a*3+1],t[a*3+2]),u=new g(t[n*3+0],t[n*3+1],t[n*3+2]),c=new g(t[l*3+0],t[l*3+1],t[l*3+2]);r.push(h,u),r.push(u,c),r.push(c,h)}return r}return null}compute(){this._indicesBuffer&&this._indicesBuffer.compute(),this._vertexBuffer&&this._vertexBuffer.compute()}computeNormals(){let i=this.getAttribute(Y.position),e=this.getAttribute(Y.normal),t=this.getAttribute(Y.indices);if(!i||!e||!t)return this;let r=t.data.length/3,s=Ti.point1,a=Ti.point2,n=Ti.point3,l=Ti.crossA,h=Ti.crossB,u=Ti.crossRet;for(let c=0;c<r;c++){let f=t.data[c*3],d=t.data[c*3+1],p=t.data[c*3+2];s.set(i.data[f*3],i.data[f*3+1],i.data[f*3+2]),a.set(i.data[d*3],i.data[d*3+1],i.data[d*3+2]),n.set(i.data[p*3],i.data[p*3+1],i.data[p*3+2]),g.sub(s,a,l).normalize(),g.sub(s,n,h).normalize();let m=l.crossProduct(h,u).normalize();e.data[f*3]=e.data[d*3]=e.data[p*3]=m.x,e.data[f*3+1]=e.data[d*3+1]=e.data[p*3+1]=m.y,e.data[f*3+2]=e.data[d*3+2]=e.data[p*3+2]=m.z}return this._vertexBuffer.upload(Y.normal,e),this}isPrimitive(){return!1}destroy(i){this.instanceID=null,this.name=null,this.subGeometries=null,this.morphTargetDictionary=null,this._bounds.destroy(),this._bounds=null,this._attributeMap=null,this._attributes=null,this._indicesBuffer.destroy(),this._vertexBuffer.destroy(),this._indicesBuffer=null,this._vertexBuffer=null}};let tt=Ti;o(tt,"crossA",g.UP.clone()),o(tt,"crossB",g.UP.clone()),o(tt,"crossRet",g.UP.clone()),o(tt,"point1",g.UP.clone()),o(tt,"point2",g.UP.clone()),o(tt,"point3",g.UP.clone());class Zl extends tt{constructor(e,t,r=1,s=1,a=g.Y_AXIS){super(),o(this,"width"),o(this,"height"),o(this,"segmentW"),o(this,"segmentH"),o(this,"up"),this.width=e,this.height=t,this.segmentW=r,this.segmentH=s,this.up=a,this.buildGeometry(this.up)}buildGeometry(e){var t,r,s,a,n=this.segmentW+1;(this.segmentH+1)*n,this.bounds=new Be(g.ZERO.clone(),new g(this.width,1,this.height)),s=this.segmentH*this.segmentW*6;let l=(this.segmentW+1)*(this.segmentH+1),h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),f;this.segmentW*this.segmentH*2*3>=Uint16Array.length?f=new Uint32Array(this.segmentW*this.segmentH*2*3):f=new Uint16Array(this.segmentW*this.segmentH*2*3),s=0;for(var p=0,m=0,_=0,v=0;v<=this.segmentH;++v)for(var y=0;y<=this.segmentW;++y){switch(t=(y/this.segmentW-.5)*this.width,r=(v/this.segmentH-.5)*this.height,e){case g.Y_AXIS:h[p++]=t,h[p++]=0,h[p++]=r,u[m++]=0,u[m++]=1,u[m++]=0;break;case g.Z_AXIS:h[p++]=t,h[p++]=-r,h[p++]=0,u[m++]=0,u[m++]=0,u[m++]=1;break;case g.X_AXIS:h[p++]=0,h[p++]=t,h[p++]=r,u[m++]=1,u[m++]=0,u[m++]=0;break;default:h[p++]=t,h[p++]=0,h[p++]=r,u[m++]=0,u[m++]=1,u[m++]=0;break}c[_++]=y/this.segmentW,c[_++]=v/this.segmentH,y!=this.segmentW&&v!=this.segmentH&&(a=y+v*n,f[s++]=a+1,f[s++]=a,f[s++]=a+n,f[s++]=a+1,f[s++]=a+n,f[s++]=a+n+1)}this.setIndices(f),this.setAttribute(Y.position,h),this.setAttribute(Y.normal,u),this.setAttribute(Y.uv,c),this.setAttribute(Y.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,index:0})}}class Ns extends te{constructor(e="QuadGlsl_vs",t="QuadGlsl_fs",r,s,a=0,n=!1){super(),o(this,"width",128),o(this,"height",128),o(this,"quadRenderer"),o(this,"material"),o(this,"uniforms"),o(this,"rendererPassState"),o(this,"pass");let l=r?r.attachments:[];this.material=new _i,this.pass=new We(e,t),this.material.addPass(re.COLOR,this.pass),this.pass.blendMode=xe.NONE;let h=this.pass.shaderState;h.frontFace="cw",h.depthWriteEnabled=!1,h.depthCompare=vt.always,h.multisample=a,this.uniforms=this.pass.uniforms=s||{color:new $(new z)},this.quadRenderer=this.addComponent(ce),this.quadRenderer.material=this.material,this.quadRenderer.castGI=!1,this.quadRenderer.castShadow=!1,this.quadRenderer.drawType=n?2:0,this.quadRenderer.geometry=new Zl(100,100,1,1),this.colorTexture=A.res.blackTexture,this.pass.setUniformFloat("x",0),this.pass.setUniformFloat("y",0),this.pass.setUniformFloat("width",100),this.pass.setUniformFloat("height",100),this.quadRenderer.material=this.material,this.quadRenderer.__start(),this.quadRenderer._enable=!0,this.quadRenderer.onEnable(),this.rendererPassState=He.createRendererPassState(r,"load"),h.multisample>0&&(this.rendererPassState.multisample=h.multisample,this.rendererPassState.multiTexture=S.device.createTexture({size:{width:S.presentationSize[0],height:S.presentationSize[1]},sampleCount:h.multisample,format:l.length>0?l[0].format:S.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}))}set colorTexture(e){this.material.getPass(re.COLOR)[0].setTexture("baseMap",e)}renderTarget(e,t,r){let s=e.camera,a=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(a,s),t.quadRenderer.nodeUpdate(e,re.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,re.COLOR,t.rendererPassState,null,a),w.endPass(a)}renderToViewQuad(e,t,r,s){let a=e.camera;t.colorTexture=s;let n=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(n,a),t.quadRenderer.nodeUpdate(e,re.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,re.COLOR,t.rendererPassState,null,n),w.endPass(n)}}class oe extends at{constructor(e,t,r=G.rgba8unorm,s=!1,a,n=1,l=0,h=!0){super(e,t,n),o(this,"resolveTarget");let u=S.device;this.name=Pt(),a!=null?this.usage=a:this.usage=GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.createTextureDescriptor(e,t,1,r,this.usage,n,l),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,r==G.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=u.createSampler({})):r==G.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})):r==G.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",l>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.maxAnisotropy=16,this.addressModeU=Bt.clamp_to_edge,this.addressModeV=Bt.clamp_to_edge,this.gpuSampler=u.createSampler(this))}create(e,t,r=!0){let s=S.device;const a=e*4;let n=new Float32Array(e*t*4);const l=s.createBuffer({size:n.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(l,0,n);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h)}readTextureToImage(){let e=S.device,t=S.windowWidth,r=S.windowHeight,s=new Float32Array(t*r*4);const a=e.createBuffer({size:s.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return w.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:a},[t,r]),a.getMappedRange(0,s.byteLength)}}class Ce{constructor(){o(this,"storeOp","store"),o(this,"loadOp","clear"),o(this,"clearValue",[0,0,0,0])}}class Ze{constructor(e,t,r,s,a=!0){o(this,"label"),o(this,"customSize",!1),o(this,"attachments"),o(this,"rtDescriptors"),o(this,"zPreTexture"),o(this,"depthTexture"),o(this,"depthViewIndex",0),o(this,"depthCleanValue",1),o(this,"depthLoadOp","clear"),o(this,"isOutTarget",!0),this.attachments=e,this.rtDescriptors=t,this.depthTexture=r,this.zPreTexture=s,this.isOutTarget=a}clone2Frame(e){e.attachments.push(...this.attachments.concat());for(let t=0;t<this.rtDescriptors.length;t++){const r=this.rtDescriptors[t];let s=new Ce;s.loadOp=r.loadOp,s.storeOp=r.storeOp,s.clearValue=r.clearValue,e.rtDescriptors.push(s)}e.depthTexture=this.depthTexture,e.zPreTexture=this.zPreTexture,e.customSize=this.customSize}clone(){let e=new Ze([],[]);return this.clone2Frame(e),e}}const Fs=class{static init(){this.rtTextureMap=new Map,this.rtViewQuad=new Map}static createRTTexture(i,e,t,r,s=!1,a=0){let n=this.rtTextureMap.get(i);return n||(i==Ae.colorBufferTex_NAME?n=new oe(e,t,r,s,void 0,1,a,!1):n=new oe(e,t,r,s,void 0,1,a,!0),n.name=i,Fs.rtTextureMap.set(i,n)),n}static createRTTextureArray(i,e,t,r,s=1,a=!1,n=0){let l=this.rtTextureMap.get(i);return l||(l=new oe(e,t,r,a,void 0,s,n),l.name=i,Fs.rtTextureMap.set(i,l)),l}static createViewQuad(i,e,t,r,s,a=0){let n=new Ze([r],[new Ce]),l=new Ns(e,t,n,s,a);return Fs.rtViewQuad.set(i,l),l}static getTexture(i){return this.rtTextureMap.get(i)}static CreateSplitTexture(i){let e=this.getTexture(Ae.colorBufferTex_NAME),t=this.getTexture(i+"_split");return t||(t=this.createRTTexture(i+"_split",e.width,e.height,e.format,!1)),t}static WriteSplitColorTexture(i){let e=this.getTexture(Ae.colorBufferTex_NAME),t=this.getTexture(i+"_split");const r=w.beginCommandEncoder();r.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:t.width,height:t.height,depthOrArrayLayers:1}),w.endCommandEncoder(r)}};let Fe=Fs;o(Fe,"rtTextureMap"),o(Fe,"rtViewQuad");class Ct{constructor(){o(this,"enable",!0),o(this,"postRenderer"),o(this,"rtViewQuad"),o(this,"virtualTexture"),this.rtViewQuad=new Map,this.virtualTexture=new Map}createRTTexture(e,t,r,s,a=!1,n=0){let l=Fe.createRTTexture(e,t,r,s,a,n);return l.name=e,this.virtualTexture.set(e,l),se.getInstance().attached(l,this),l}createViewQuad(e,t,r,s,a=0){let n=Fe.createViewQuad(e,"Quad_vert_wgsl",t,r,s,a);return this.rtViewQuad.set(e,n),n}getOutTexture(){let e,t=w.lastRenderPassState.renderTargets;return t.length>0?e=t[0]:e=Fe.getTexture(Ae.colorBufferTex_NAME),e}autoSetColorTexture(e,t){let r=this.getOutTexture();t.setSamplerTexture(e,r)}compute(e){}onAttach(e){}onDetach(e){}render(e,t){this.compute(e),this.rtViewQuad.forEach((r,s)=>{let a=w.lastRenderPassState.getLastRenderTexture();r.renderToViewQuad(e,r,t,a)})}destroy(e){this.postRenderer=null;for(let t=0;t<this.rtViewQuad.size;t++)this.rtViewQuad.values[t].destroy(e);this.rtViewQuad.clear(),this.rtViewQuad=null;for(let t=0;t<this.virtualTexture.size;t++){const r=this.virtualTexture.values[t];se.getInstance().detached(r,this),r.destroy(e)}}}class uo extends Ct{constructor(){super();let e=S.presentationSize;Fe.createRTTexture(Ae.colorBufferTex_NAME,e[0],e[1],G.rgba16float,!1),N.register("FXAA_Shader",Ic);let t={u_texel:new $(new Z(1/e[0],1/e[1])),u_strength:new $(4)},r=this.createRTTexture("FXAAPost",e[0],e[1],G.rgba16float);this.createViewQuad("fxaa","FXAA_Shader",r,t)}onAttach(e){A.setting.render.postProcessing.fxaa.enable=!0}onDetach(e){A.setting.render.postProcessing.fxaa.enable=!1}}class $l{constructor(e){o(this,"command"),o(this,"encoder"),o(this,"rendererPassStates"),o(this,"rtFrame"),this.rtFrame=e,this.rendererPassStates=[]}clean(){this.rendererPassStates.length=0,w.cleanCache()}beginContinueRendererPassState(){if(this.rendererPassStates.length>0){let e=this.rtFrame.clone();for(const r of e.rtDescriptors)r.loadOp="load";e.depthLoadOp="load";let t=He.createRendererPassState(e);return this.rendererPassStates.push(t),t}else{let e=He.createRendererPassState(this.rtFrame);return this.rendererPassStates.push(e),e}}get rendererPassState(){return this.rendererPassStates[this.rendererPassStates.length-1]}beginRenderPass(){this.beginContinueRendererPassState(),this.begineNewCommand(),this.beginNewEncoder()}endRenderPass(){this.endEncoder(),this.endCommand()}begineNewCommand(){return this.command=w.beginCommandEncoder(),this.command}endCommand(){w.endCommandEncoder(this.command),this.command=null}beginNewEncoder(){return this.encoder=w.beginRenderPass(this.command,this.rendererPassState),this.encoder}endEncoder(){w.endPass(this.encoder),this.encoder=null}}class di extends hi{constructor(){super(),o(this,"rendererPassState"),o(this,"splitRendererPassState"),o(this,"useRenderBundle",!1),o(this,"debugViewQuads"),o(this,"debugTextures"),o(this,"renderContext"),o(this,"_rendererType"),o(this,"_rtFrame"),this.debugTextures=[],this.debugViewQuads=[]}get passType(){return this._rendererType}set passType(e){this._rendererType=e}setRenderStates(e){if(this._rtFrame=e,e){this.rendererPassState=He.createRendererPassState(e);let t=e.clone();t.depthLoadOp="load";for(const r of t.rtDescriptors)r.loadOp="load";this.splitRendererPassState=He.createRendererPassState(t)}this.renderContext=new $l(e)}setIrradiance(e,t){this.rendererPassState.irradianceBuffer=[e,t]}compute(e,t){}render(e,t,r,s=!1){w.cleanCache();let a=e.camera,n=e.scene;this.rendererPassState.camera3D=a;let l=Q.instance.getRenderNodes(n,a),h=this.renderBundleOp(e,l,t,r),u=s?[]:this.renderBundleTr(e,l,t,r);{let c=w.beginCommandEncoder(),f=w.beginRenderPass(c,this.rendererPassState);h.length>0&&f.executeBundles(h),!s&&Q.instance.sky&&(w.bindCamera(f,a),Q.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,f)),this.drawRenderNodes(e,f,c,l.opaqueList,t),w.endPass(f),w.endCommandEncoder(c)}{let c=w.beginCommandEncoder(),f=w.beginRenderPass(c,this.rendererPassState);u.length>0&&f.executeBundles(u),s||(w.bindCamera(f,a),this.drawRenderNodes(e,f,c,l.transparentList,t)),w.endPass(f),w.endCommandEncoder(c)}}nodeUpload(e,t,r){}occlusionRenderNodeTest(e,t,r){return r?r.occlusionRenderNodeTest(e)>0:!0}renderOp(e,t,r,s,a){}renderTr(e,t,r,s,a){}renderBundleOp(e,t,r,s){let a=Q.instance.getOpRenderGroup(e.scene);if(a){let n=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))n.push(l.bundleMap.get(this._rendererType));else{let h=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,s);let u=h.finish();l.bundleMap.set(this._rendererType,u),n.push(u)}}),n}return[]}renderBundleTr(e,t,r,s){let a=Q.instance.getTrRenderGroup(e.scene);if(a){let n=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))n.push(l.bundleMap.get(this._rendererType));else{let h=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,s);let u=h.finish();l.bundleMap.set(this._rendererType,u),n.push(u)}}),n}return[]}recordRenderBundleNode(e,t,r,s){w.bindCamera(t,e.camera),w.bindGeometryBuffer(t,r[0].geometry);for(let a=0;a<r.length;++a){let n=r[a];n.transform.worldMatrix.index,n.transform.enable&&n.recordRenderPass2(e,this._rendererType,this.rendererPassState,s,t)}}drawRenderNodes(e,t,r,s,a,n){w.bindCamera(t,e.camera);for(let l=A.setting.render.drawOpMin;l<Math.min(s.length,A.setting.render.drawOpMax);++l){let h=s[l];h.transform.enable&&h.enable&&h.renderPass2(e,this._rendererType,this.rendererPassState,n,t)}}setDebugTexture(e){for(let t=0;t<e.length;t++){let r=e[t],s="Quad_vert_wgsl",a="Quad_frag_wgsl";switch(r.format){case G.rgba8sint:case G.rgba8uint:case G.rgba8unorm:case G.rgba16float:case G.rgba32float:a="Quad_frag_wgsl";break;case G.depth24plus:case G.depth32float:a="Quad_depth2d_frag_wgsl",r.textureBindingLayout.viewDimension=="cube"&&(a="Quad_depthCube_frag_wgsl");break}let n=new Ns(s,a,new Ze([],[]));this.debugTextures.push(e[t]),this.debugViewQuads.push(n)}}}class eh extends di{constructor(){super(),this.passType=re.COLOR}render(e,t,r,s=!1){this.renderContext.clean();let a=e.scene,n=e.camera;this.rendererPassState.camera3D=n;let l=Q.instance.getRenderNodes(a,n),h=this.renderBundleOp(e,l,t,r),u=s?[]:this.renderBundleTr(e,l,t,r);ft.start("colorPass Renderer");{ft.start("ColorPass Draw Opaque"),this.renderContext.beginRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;w.bindCamera(c,n),h.length>0&&(Q.instance.getOpRenderGroup(a),c.executeBundles(h)),!s&&Q.instance.sky&&(w.bindCamera(c,n),Q.instance.sky.preInit||Q.instance.sky.nodeUpdate(e,this._rendererType,this.rendererPassState,r),Q.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,c)),l.opaqueList&&(w.bindCamera(c,n),this.drawNodes(e,this.renderContext,l.opaqueList,t,r),this.renderContext.endRenderPass(),ft.end("ColorPass Draw Opaque"))}{ft.start("ColorPass Draw Transparent"),this.renderContext.beginRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;u.length>0&&c.executeBundles(u),!s&&l.transparentList&&(w.bindCamera(c,n),this.drawNodes(e,this.renderContext,l.transparentList,t,r));let f=Q.instance.getGraphicList();for(let d=0;d<f.length;d++){const p=f[d];p.transform.worldMatrix.index,p.nodeUpdate(e,this._rendererType,this.splitRendererPassState,r),p.renderPass2(e,this._rendererType,this.splitRendererPassState,r,c)}this.renderContext.endRenderPass(),ft.end("ColorPass Draw Transparent")}ft.end("colorPass Renderer")}drawNodes(e,t,r,s,a){{let n=Q.instance.getRenderShaderCollect(e);for(const l of n){let h=l[1];for(const u of h){let c=u[1];if(c.preInit){c.nodeUpdate(e,this._rendererType,this.rendererPassState,a);break}}}for(let l=A.setting.render.drawOpMin;l<Math.min(r.length,A.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState,a),h.renderPass(e,this.passType,this.renderContext))}}}occlusionRenderNodeTest(e,t,r){return r.zDepthRenderNodeTest(t)>0}}const tr=class extends Ze{constructor(){super([],[])}crateGBuffer(i,e,t){let r=this.attachments,s=this.rtDescriptors,a=Fe.createRTTexture(i+Ae.colorBufferTex_NAME,e,t,G.rgba16float,!1),n=Fe.createRTTexture(i+Ae.positionBufferTex_NAME,e,t,G.rgba16float,!1),l=Fe.createRTTexture(i+Ae.normalBufferTex_NAME,e,t,G.rgba8unorm,!1),h=Fe.createRTTexture(i+Ae.materialBufferTex_NAME,e,t,G.rgba8unorm,!1);r.push(a),r.push(n),r.push(l),r.push(h);let u=new Ce;u.loadOp="clear";let c=new oe(e,t,G.depth32float,!1);c.name="depthTexture";let f=new Ce;f.loadOp="load",this.depthTexture=c,s.push(u),s.push(new Ce),s.push(new Ce),s.push(new Ce)}getColorMap(){return this.attachments[0]}getPositionMap(){return this.attachments[1]}getNormalMap(){return this.attachments[2]}getMaterialMap(){return this.attachments[3]}static getGBufferFrame(i){let e;if(tr.gBufferMap.has(i))e=tr.gBufferMap.get(i);else{e=new tr;let t=S.presentationSize;e.crateGBuffer(i,t[0],t[1]),tr.gBufferMap.set(i,e)}return e}clone(){let i=new tr;return this.clone2Frame(i),i}};let wt=tr;o(wt,"gBufferMap",new Map);class ks{constructor(){o(this,"frustumCullingList"),o(this,"zVisibleList"),o(this,"_renderList"),this._renderList=new Map}occlusionRenderNodeTest(e){return A.setting.occlusionQuery.enable?this.frustumCullingList?this.frustumCullingList[e]:0:1}zDepthRenderNodeTest(e){return this.zVisibleList?this.zVisibleList[e]:0}update(e,t){}collect(e,t){}renderCommitTesting(e,t){return!0}}o(ks,"enable",!0);class ir extends Jt{constructor(e,t){super(),this.bufferType=Mt.ComputeGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,e,t)}}class th{constructor(e,t){o(this,"clusterBuffer"),o(this,"lightAssignBuffer"),o(this,"assignTableBuffer"),o(this,"clustersUniformBuffer"),this.clusterBuffer=new ir(e*2*4),this.clustersUniformBuffer=new Dt(10),this.clustersUniformBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.lightAssignBuffer=new ir(e*t),this.lightAssignBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.assignTableBuffer=new ir(e*4),this.assignTableBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e,t,r,s,a,n,l,h,u,c){this.clustersUniformBuffer.setFloat("clusterTileX",s),this.clustersUniformBuffer.setFloat("clusterTileY",a),this.clustersUniformBuffer.setFloat("clusterTileZ",n),this.clustersUniformBuffer.setFloat("numLights",l),this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster",h),this.clustersUniformBuffer.setFloat("near",u),this.clustersUniformBuffer.setFloat("far",c),this.clustersUniformBuffer.setFloat("screenWidth",e),this.clustersUniformBuffer.setFloat("screenHeight",t),this.clustersUniformBuffer.setFloat("clusterPix",r),this.clustersUniformBuffer.apply()}}class ke{}o(ke,"clusterTileX",16),o(ke,"clusterTileY",16),o(ke,"clusterTileZ",32);let ih=`
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
          }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${ke.clusterTileX},${ke.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`,rh=`
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${ke.clusterTileX},${ke.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;function jd(i){if(i&&!(typeof window>"u")){var e=document.createElement("style");return e.setAttribute("type","text/css"),e.innerHTML=i,document.head.appendChild(e),i}}function rr(i,e){var t=i.__state.conversionName.toString(),r=Math.round(i.r),s=Math.round(i.g),a=Math.round(i.b),n=i.a,l=Math.round(i.h),h=i.s.toFixed(1),u=i.v.toFixed(1);if(e||t==="THREE_CHAR_HEX"||t==="SIX_CHAR_HEX"){for(var c=i.hex.toString(16);c.length<6;)c="0"+c;return"#"+c}else{if(t==="CSS_RGB")return"rgb("+r+","+s+","+a+")";if(t==="CSS_RGBA")return"rgba("+r+","+s+","+a+","+n+")";if(t==="HEX")return"0x"+i.hex.toString(16);if(t==="RGB_ARRAY")return"["+r+","+s+","+a+"]";if(t==="RGBA_ARRAY")return"["+r+","+s+","+a+","+n+"]";if(t==="RGB_OBJ")return"{r:"+r+",g:"+s+",b:"+a+"}";if(t==="RGBA_OBJ")return"{r:"+r+",g:"+s+",b:"+a+",a:"+n+"}";if(t==="HSV_OBJ")return"{h:"+l+",s:"+h+",v:"+u+"}";if(t==="HSVA_OBJ")return"{h:"+l+",s:"+h+",v:"+u+",a:"+n+"}"}return"unknown format"}var sh=Array.prototype.forEach,Kr=Array.prototype.slice,U={BREAK:{},extend:function(e){return this.each(Kr.call(arguments,1),function(t){var r=this.isObject(t)?Object.keys(t):[];r.forEach(function(s){this.isUndefined(t[s])||(e[s]=t[s])}.bind(this))},this),e},defaults:function(e){return this.each(Kr.call(arguments,1),function(t){var r=this.isObject(t)?Object.keys(t):[];r.forEach(function(s){this.isUndefined(e[s])&&(e[s]=t[s])}.bind(this))},this),e},compose:function(){var e=Kr.call(arguments);return function(){for(var t=Kr.call(arguments),r=e.length-1;r>=0;r--)t=[e[r].apply(this,t)];return t[0]}},each:function(e,t,r){if(e){if(sh&&e.forEach&&e.forEach===sh)e.forEach(t,r);else if(e.length===e.length+0){var s=void 0,a=void 0;for(s=0,a=e.length;s<a;s++)if(s in e&&t.call(r,e[s],s)===this.BREAK)return}else for(var n in e)if(t.call(r,e[n],n)===this.BREAK)return}},defer:function(e){setTimeout(e,0)},debounce:function(e,t,r){var s=void 0;return function(){var a=this,n=arguments;function l(){s=null,r||e.apply(a,n)}var h=r||!s;clearTimeout(s),s=setTimeout(l,t),h&&e.apply(a,n)}},toArray:function(e){return e.toArray?e.toArray():Kr.call(e)},isUndefined:function(e){return e===void 0},isNull:function(e){return e===null},isNaN:function(i){function e(t){return i.apply(this,arguments)}return e.toString=function(){return i.toString()},e}(function(i){return isNaN(i)}),isArray:Array.isArray||function(i){return i.constructor===Array},isObject:function(e){return e===Object(e)},isNumber:function(e){return e===e+0},isString:function(e){return e===e+""},isBoolean:function(e){return e===!1||e===!0},isFunction:function(e){return e instanceof Function}},qd=[{litmus:U.isString,conversions:{THREE_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return t===null?!1:{space:"HEX",hex:parseInt("0x"+t[1].toString()+t[1].toString()+t[2].toString()+t[2].toString()+t[3].toString()+t[3].toString(),0)}},write:rr},SIX_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9]{6})$/i);return t===null?!1:{space:"HEX",hex:parseInt("0x"+t[1].toString(),0)}},write:rr},CSS_RGB:{read:function(e){var t=e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return t===null?!1:{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3])}},write:rr},CSS_RGBA:{read:function(e){var t=e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return t===null?!1:{space:"RGB",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3]),a:parseFloat(t[4])}},write:rr}}},{litmus:U.isNumber,conversions:{HEX:{read:function(e){return{space:"HEX",hex:e,conversionName:"HEX"}},write:function(e){return e.hex}}}},{litmus:U.isArray,conversions:{RGB_ARRAY:{read:function(e){return e.length!==3?!1:{space:"RGB",r:e[0],g:e[1],b:e[2]}},write:function(e){return[e.r,e.g,e.b]}},RGBA_ARRAY:{read:function(e){return e.length!==4?!1:{space:"RGB",r:e[0],g:e[1],b:e[2],a:e[3]}},write:function(e){return[e.r,e.g,e.b,e.a]}}}},{litmus:U.isObject,conversions:{RGBA_OBJ:{read:function(e){return U.isNumber(e.r)&&U.isNumber(e.g)&&U.isNumber(e.b)&&U.isNumber(e.a)?{space:"RGB",r:e.r,g:e.g,b:e.b,a:e.a}:!1},write:function(e){return{r:e.r,g:e.g,b:e.b,a:e.a}}},RGB_OBJ:{read:function(e){return U.isNumber(e.r)&&U.isNumber(e.g)&&U.isNumber(e.b)?{space:"RGB",r:e.r,g:e.g,b:e.b}:!1},write:function(e){return{r:e.r,g:e.g,b:e.b}}},HSVA_OBJ:{read:function(e){return U.isNumber(e.h)&&U.isNumber(e.s)&&U.isNumber(e.v)&&U.isNumber(e.a)?{space:"HSV",h:e.h,s:e.s,v:e.v,a:e.a}:!1},write:function(e){return{h:e.h,s:e.s,v:e.v,a:e.a}}},HSV_OBJ:{read:function(e){return U.isNumber(e.h)&&U.isNumber(e.s)&&U.isNumber(e.v)?{space:"HSV",h:e.h,s:e.s,v:e.v}:!1},write:function(e){return{h:e.h,s:e.s,v:e.v}}}}}],Jr=void 0,zs=void 0,co=function(){zs=!1;var e=arguments.length>1?U.toArray(arguments):arguments[0];return U.each(qd,function(t){if(t.litmus(e))return U.each(t.conversions,function(r,s){if(Jr=r.read(e),zs===!1&&Jr!==!1)return zs=Jr,Jr.conversionName=s,Jr.conversion=r,U.BREAK}),U.BREAK}),zs},ah=void 0,Gs={hsv_to_rgb:function(e,t,r){var s=Math.floor(e/60)%6,a=e/60-Math.floor(e/60),n=r*(1-t),l=r*(1-a*t),h=r*(1-(1-a)*t),u=[[r,h,n],[l,r,n],[n,r,h],[n,l,r],[h,n,r],[r,n,l]][s];return{r:u[0]*255,g:u[1]*255,b:u[2]*255}},rgb_to_hsv:function(e,t,r){var s=Math.min(e,t,r),a=Math.max(e,t,r),n=a-s,l=void 0,h=void 0;if(a!==0)h=n/a;else return{h:NaN,s:0,v:0};return e===a?l=(t-r)/n:t===a?l=2+(r-e)/n:l=4+(e-t)/n,l/=6,l<0&&(l+=1),{h:l*360,s:h,v:a/255}},rgb_to_hex:function(e,t,r){var s=this.hex_with_component(0,2,e);return s=this.hex_with_component(s,1,t),s=this.hex_with_component(s,0,r),s},component_from_hex:function(e,t){return e>>t*8&255},hex_with_component:function(e,t,r){return r<<(ah=t*8)|e&~(255<<ah)}},Kd=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(i){return typeof i}:function(i){return i&&typeof Symbol=="function"&&i.constructor===Symbol&&i!==Symbol.prototype?"symbol":typeof i},Rt=function(i,e){if(!(i instanceof e))throw new TypeError("Cannot call a class as a function")},Lt=function(){function i(e,t){for(var r=0;r<t.length;r++){var s=t[r];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}return function(e,t,r){return t&&i(e.prototype,t),r&&i(e,r),e}}(),gi=function i(e,t,r){e===null&&(e=Function.prototype);var s=Object.getOwnPropertyDescriptor(e,t);if(s===void 0){var a=Object.getPrototypeOf(e);return a===null?void 0:i(a,t,r)}else{if("value"in s)return s.value;var n=s.get;return n===void 0?void 0:n.call(r)}},pi=function(i,e){if(typeof e!="function"&&e!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof e);i.prototype=Object.create(e&&e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(i,e):i.__proto__=e)},mi=function(i,e){if(!i)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e&&(typeof e=="object"||typeof e=="function")?e:i},Ye=function(){function i(){if(Rt(this,i),this.__state=co.apply(this,arguments),this.__state===!1)throw new Error("Failed to interpret color arguments");this.__state.a=this.__state.a||1}return Lt(i,[{key:"toString",value:function(){return rr(this)}},{key:"toHexString",value:function(){return rr(this,!0)}},{key:"toOriginal",value:function(){return this.__state.conversion.write(this)}}]),i}();function fo(i,e,t){Object.defineProperty(i,e,{get:function(){return this.__state.space==="RGB"?this.__state[e]:(Ye.recalculateRGB(this,e,t),this.__state[e])},set:function(s){this.__state.space!=="RGB"&&(Ye.recalculateRGB(this,e,t),this.__state.space="RGB"),this.__state[e]=s}})}function go(i,e){Object.defineProperty(i,e,{get:function(){return this.__state.space==="HSV"?this.__state[e]:(Ye.recalculateHSV(this),this.__state[e])},set:function(r){this.__state.space!=="HSV"&&(Ye.recalculateHSV(this),this.__state.space="HSV"),this.__state[e]=r}})}Ye.recalculateRGB=function(i,e,t){if(i.__state.space==="HEX")i.__state[e]=Gs.component_from_hex(i.__state.hex,t);else if(i.__state.space==="HSV")U.extend(i.__state,Gs.hsv_to_rgb(i.__state.h,i.__state.s,i.__state.v));else throw new Error("Corrupted color state")},Ye.recalculateHSV=function(i){var e=Gs.rgb_to_hsv(i.r,i.g,i.b);U.extend(i.__state,{s:e.s,v:e.v}),U.isNaN(e.h)?U.isUndefined(i.__state.h)&&(i.__state.h=0):i.__state.h=e.h},Ye.COMPONENTS=["r","g","b","h","s","v","hex","a"],fo(Ye.prototype,"r",2),fo(Ye.prototype,"g",1),fo(Ye.prototype,"b",0),go(Ye.prototype,"h"),go(Ye.prototype,"s"),go(Ye.prototype,"v"),Object.defineProperty(Ye.prototype,"a",{get:function(){return this.__state.a},set:function(e){this.__state.a=e}}),Object.defineProperty(Ye.prototype,"hex",{get:function(){return this.__state.space!=="HEX"&&(this.__state.hex=Gs.rgb_to_hex(this.r,this.g,this.b),this.__state.space="HEX"),this.__state.hex},set:function(e){this.__state.space="HEX",this.__state.hex=e}});var Mi=function(){function i(e,t){Rt(this,i),this.initialValue=e[t],this.domElement=document.createElement("div"),this.object=e,this.property=t,this.__onChange=void 0,this.__onFinishChange=void 0}return Lt(i,[{key:"onChange",value:function(t){return this.__onChange=t,this}},{key:"onFinishChange",value:function(t){return this.__onFinishChange=t,this}},{key:"setValue",value:function(t){return this.object[this.property]=t,this.__onChange&&this.__onChange.call(this,t),this.updateDisplay(),this}},{key:"getValue",value:function(){return this.object[this.property]}},{key:"updateDisplay",value:function(){return this}},{key:"isModified",value:function(){return this.initialValue!==this.getValue()}}]),i}(),Jd={HTMLEvents:["change"],MouseEvents:["click","mousemove","mousedown","mouseup","mouseover"],KeyboardEvents:["keydown"]},oh={};U.each(Jd,function(i,e){U.each(i,function(t){oh[t]=e})});var Zd=/(\d+(\.\d+)?)px/;function Yt(i){if(i==="0"||U.isUndefined(i))return 0;var e=i.match(Zd);return U.isNull(e)?0:parseFloat(e[1])}var E={makeSelectable:function(e,t){e===void 0||e.style===void 0||(e.onselectstart=t?function(){return!1}:function(){},e.style.MozUserSelect=t?"auto":"none",e.style.KhtmlUserSelect=t?"auto":"none",e.unselectable=t?"on":"off")},makeFullscreen:function(e,t,r){var s=r,a=t;U.isUndefined(a)&&(a=!0),U.isUndefined(s)&&(s=!0),e.style.position="absolute",a&&(e.style.left=0,e.style.right=0),s&&(e.style.top=0,e.style.bottom=0)},fakeEvent:function(e,t,r,s){var a=r||{},n=oh[t];if(!n)throw new Error("Event type "+t+" not supported.");var l=document.createEvent(n);switch(n){case"MouseEvents":{var h=a.x||a.clientX||0,u=a.y||a.clientY||0;l.initMouseEvent(t,a.bubbles||!1,a.cancelable||!0,window,a.clickCount||1,0,0,h,u,!1,!1,!1,!1,0,null);break}case"KeyboardEvents":{var c=l.initKeyboardEvent||l.initKeyEvent;U.defaults(a,{cancelable:!0,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,keyCode:void 0,charCode:void 0}),c(t,a.bubbles||!1,a.cancelable,window,a.ctrlKey,a.altKey,a.shiftKey,a.metaKey,a.keyCode,a.charCode);break}default:{l.initEvent(t,a.bubbles||!1,a.cancelable||!0);break}}U.defaults(l,s),e.dispatchEvent(l)},bind:function(e,t,r,s){var a=s||!1;return e.addEventListener?e.addEventListener(t,r,a):e.attachEvent&&e.attachEvent("on"+t,r),E},unbind:function(e,t,r,s){var a=s||!1;return e.removeEventListener?e.removeEventListener(t,r,a):e.detachEvent&&e.detachEvent("on"+t,r),E},addClass:function(e,t){if(e.className===void 0)e.className=t;else if(e.className!==t){var r=e.className.split(/ +/);r.indexOf(t)===-1&&(r.push(t),e.className=r.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return E},removeClass:function(e,t){if(t)if(e.className===t)e.removeAttribute("class");else{var r=e.className.split(/ +/),s=r.indexOf(t);s!==-1&&(r.splice(s,1),e.className=r.join(" "))}else e.className=void 0;return E},hasClass:function(e,t){return new RegExp("(?:^|\\s+)"+t+"(?:\\s+|$)").test(e.className)||!1},getWidth:function(e){var t=getComputedStyle(e);return Yt(t["border-left-width"])+Yt(t["border-right-width"])+Yt(t["padding-left"])+Yt(t["padding-right"])+Yt(t.width)},getHeight:function(e){var t=getComputedStyle(e);return Yt(t["border-top-width"])+Yt(t["border-bottom-width"])+Yt(t["padding-top"])+Yt(t["padding-bottom"])+Yt(t.height)},getOffset:function(e){var t=e,r={left:0,top:0};if(t.offsetParent)do r.left+=t.offsetLeft,r.top+=t.offsetTop,t=t.offsetParent;while(t);return r},isActive:function(e){return e===document.activeElement&&(e.type||e.href)}},nh=function(i){pi(e,i);function e(t,r){Rt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),a=s;s.__prev=s.getValue(),s.__checkbox=document.createElement("input"),s.__checkbox.setAttribute("type","checkbox");function n(){a.setValue(!a.__prev)}return E.bind(s.__checkbox,"change",n,!1),s.domElement.appendChild(s.__checkbox),s.updateDisplay(),s}return Lt(e,[{key:"setValue",value:function(r){var s=gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,r);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),this.__prev=this.getValue(),s}},{key:"updateDisplay",value:function(){return this.getValue()===!0?(this.__checkbox.setAttribute("checked","checked"),this.__checkbox.checked=!0,this.__prev=!0):(this.__checkbox.checked=!1,this.__prev=!1),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(Mi),$d=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),n=s,l=a;if(a.__select=document.createElement("select"),U.isArray(n)){var h={};U.each(n,function(u){h[u]=u}),n=h}return U.each(n,function(u,c){var f=document.createElement("option");f.innerHTML=c,f.setAttribute("value",u),l.__select.appendChild(f)}),a.updateDisplay(),E.bind(a.__select,"change",function(){var u=this.options[this.selectedIndex].value;l.setValue(u)}),a.domElement.appendChild(a.__select),a}return Lt(e,[{key:"setValue",value:function(r){var s=gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,r);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),s}},{key:"updateDisplay",value:function(){return E.isActive(this.__select)?this:(this.__select.value=this.getValue(),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this))}}]),e}(Mi),eg=function(i){pi(e,i);function e(t,r){Rt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),a=s;function n(){a.setValue(a.__input.value)}function l(){a.__onFinishChange&&a.__onFinishChange.call(a,a.getValue())}return s.__input=document.createElement("input"),s.__input.setAttribute("type","text"),E.bind(s.__input,"keyup",n),E.bind(s.__input,"change",n),E.bind(s.__input,"blur",l),E.bind(s.__input,"keydown",function(h){h.keyCode===13&&this.blur()}),s.updateDisplay(),s.domElement.appendChild(s.__input),s}return Lt(e,[{key:"updateDisplay",value:function(){return E.isActive(this.__input)||(this.__input.value=this.getValue()),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(Mi);function lh(i){var e=i.toString();return e.indexOf(".")>-1?e.length-e.indexOf(".")-1:0}var hh=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),n=s||{};return a.__min=n.min,a.__max=n.max,a.__step=n.step,U.isUndefined(a.__step)?a.initialValue===0?a.__impliedStep=1:a.__impliedStep=Math.pow(10,Math.floor(Math.log(Math.abs(a.initialValue))/Math.LN10))/10:a.__impliedStep=a.__step,a.__precision=lh(a.__impliedStep),a}return Lt(e,[{key:"setValue",value:function(r){var s=r;return this.__min!==void 0&&s<this.__min?s=this.__min:this.__max!==void 0&&s>this.__max&&(s=this.__max),this.__step!==void 0&&s%this.__step!==0&&(s=Math.round(s/this.__step)*this.__step),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,s)}},{key:"min",value:function(r){return this.__min=r,this}},{key:"max",value:function(r){return this.__max=r,this}},{key:"step",value:function(r){return this.__step=r,this.__impliedStep=r,this.__precision=lh(r),this}}]),e}(Mi);function tg(i,e){var t=Math.pow(10,e);return Math.round(i*t)/t}var Qs=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r,s));a.__truncationSuspended=!1;var n=a,l=void 0;function h(){var m=parseFloat(n.__input.value);U.isNaN(m)||n.setValue(m)}function u(){n.__onFinishChange&&n.__onFinishChange.call(n,n.getValue())}function c(){u()}function f(m){var _=l-m.clientY;n.setValue(n.getValue()+_*n.__impliedStep),l=m.clientY}function d(){E.unbind(window,"mousemove",f),E.unbind(window,"mouseup",d),u()}function p(m){E.bind(window,"mousemove",f),E.bind(window,"mouseup",d),l=m.clientY}return a.__input=document.createElement("input"),a.__input.setAttribute("type","text"),E.bind(a.__input,"change",h),E.bind(a.__input,"blur",c),E.bind(a.__input,"mousedown",p),E.bind(a.__input,"keydown",function(m){m.keyCode===13&&(n.__truncationSuspended=!0,this.blur(),n.__truncationSuspended=!1,u())}),a.updateDisplay(),a.domElement.appendChild(a.__input),a}return Lt(e,[{key:"updateDisplay",value:function(){return this.__input.value=this.__truncationSuspended?this.getValue():tg(this.getValue(),this.__precision),gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(hh);function uh(i,e,t,r,s){return r+(s-r)*((i-e)/(t-e))}var po=function(i){pi(e,i);function e(t,r,s,a,n){Rt(this,e);var l=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r,{min:s,max:a,step:n})),h=l;l.__background=document.createElement("div"),l.__foreground=document.createElement("div"),E.bind(l.__background,"mousedown",u),E.bind(l.__background,"touchstart",d),E.addClass(l.__background,"slider"),E.addClass(l.__foreground,"slider-fg");function u(_){document.activeElement.blur(),E.bind(window,"mousemove",c),E.bind(window,"mouseup",f),c(_)}function c(_){_.preventDefault();var v=h.__background.getBoundingClientRect();return h.setValue(uh(_.clientX,v.left,v.right,h.__min,h.__max)),!1}function f(){E.unbind(window,"mousemove",c),E.unbind(window,"mouseup",f),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}function d(_){_.touches.length===1&&(E.bind(window,"touchmove",p),E.bind(window,"touchend",m),p(_))}function p(_){var v=_.touches[0].clientX,y=h.__background.getBoundingClientRect();h.setValue(uh(v,y.left,y.right,h.__min,h.__max))}function m(){E.unbind(window,"touchmove",p),E.unbind(window,"touchend",m),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}return l.updateDisplay(),l.__background.appendChild(l.__foreground),l.domElement.appendChild(l.__background),l}return Lt(e,[{key:"updateDisplay",value:function(){var r=(this.getValue()-this.__min)/(this.__max-this.__min);return this.__foreground.style.width=r*100+"%",gi(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(hh),ch=function(i){pi(e,i);function e(t,r,s){Rt(this,e);var a=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r)),n=a;return a.__button=document.createElement("div"),a.__button.innerHTML=s===void 0?"Fire":s,E.bind(a.__button,"click",function(l){return l.preventDefault(),n.fire(),!1}),E.addClass(a.__button,"button"),a.domElement.appendChild(a.__button),a}return Lt(e,[{key:"fire",value:function(){this.__onChange&&this.__onChange.call(this),this.getValue().call(this.object),this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue())}}]),e}(Mi),mo=function(i){pi(e,i);function e(t,r){Rt(this,e);var s=mi(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,r));s.__color=new Ye(s.getValue()),s.__temp=new Ye(0);var a=s;s.domElement=document.createElement("div"),E.makeSelectable(s.domElement,!1),s.__selector=document.createElement("div"),s.__selector.className="selector",s.__saturation_field=document.createElement("div"),s.__saturation_field.className="saturation-field",s.__field_knob=document.createElement("div"),s.__field_knob.className="field-knob",s.__field_knob_border="2px solid ",s.__hue_knob=document.createElement("div"),s.__hue_knob.className="hue-knob",s.__hue_field=document.createElement("div"),s.__hue_field.className="hue-field",s.__input=document.createElement("input"),s.__input.type="text",s.__input_textShadow="0 1px 1px ",E.bind(s.__input,"keydown",function(_){_.keyCode===13&&f.call(this)}),E.bind(s.__input,"blur",f),E.bind(s.__selector,"mousedown",function(){E.addClass(this,"drag").bind(window,"mouseup",function(){E.removeClass(a.__selector,"drag")})}),E.bind(s.__selector,"touchstart",function(){E.addClass(this,"drag").bind(window,"touchend",function(){E.removeClass(a.__selector,"drag")})});var n=document.createElement("div");U.extend(s.__selector.style,{width:"122px",height:"102px",padding:"3px",backgroundColor:"#222",boxShadow:"0px 1px 3px rgba(0,0,0,0.3)"}),U.extend(s.__field_knob.style,{position:"absolute",width:"12px",height:"12px",border:s.__field_knob_border+(s.__color.v<.5?"#fff":"#000"),boxShadow:"0px 1px 3px rgba(0,0,0,0.5)",borderRadius:"12px",zIndex:1}),U.extend(s.__hue_knob.style,{position:"absolute",width:"15px",height:"2px",borderRight:"4px solid #fff",zIndex:1}),U.extend(s.__saturation_field.style,{width:"100px",height:"100px",border:"1px solid #555",marginRight:"3px",display:"inline-block",cursor:"pointer"}),U.extend(n.style,{width:"100%",height:"100%",background:"none"}),fh(n,"top","rgba(0,0,0,0)","#000"),U.extend(s.__hue_field.style,{width:"15px",height:"100px",border:"1px solid #555",cursor:"ns-resize",position:"absolute",top:"3px",right:"3px"}),rg(s.__hue_field),U.extend(s.__input.style,{outline:"none",textAlign:"center",color:"#fff",border:0,fontWeight:"bold",textShadow:s.__input_textShadow+"rgba(0,0,0,0.7)"}),E.bind(s.__saturation_field,"mousedown",l),E.bind(s.__saturation_field,"touchstart",l),E.bind(s.__field_knob,"mousedown",l),E.bind(s.__field_knob,"touchstart",l),E.bind(s.__hue_field,"mousedown",h),E.bind(s.__hue_field,"touchstart",h);function l(_){p(_),E.bind(window,"mousemove",p),E.bind(window,"touchmove",p),E.bind(window,"mouseup",u),E.bind(window,"touchend",u)}function h(_){m(_),E.bind(window,"mousemove",m),E.bind(window,"touchmove",m),E.bind(window,"mouseup",c),E.bind(window,"touchend",c)}function u(){E.unbind(window,"mousemove",p),E.unbind(window,"touchmove",p),E.unbind(window,"mouseup",u),E.unbind(window,"touchend",u),d()}function c(){E.unbind(window,"mousemove",m),E.unbind(window,"touchmove",m),E.unbind(window,"mouseup",c),E.unbind(window,"touchend",c),d()}function f(){var _=co(this.value);_!==!1?(a.__color.__state=_,a.setValue(a.__color.toOriginal())):this.value=a.__color.toString()}function d(){a.__onFinishChange&&a.__onFinishChange.call(a,a.__color.toOriginal())}s.__saturation_field.appendChild(n),s.__selector.appendChild(s.__field_knob),s.__selector.appendChild(s.__saturation_field),s.__selector.appendChild(s.__hue_field),s.__hue_field.appendChild(s.__hue_knob),s.domElement.appendChild(s.__input),s.domElement.appendChild(s.__selector),s.updateDisplay();function p(_){_.type.indexOf("touch")===-1&&_.preventDefault();var v=a.__saturation_field.getBoundingClientRect(),y=_.touches&&_.touches[0]||_,C=y.clientX,B=y.clientY,T=(C-v.left)/(v.right-v.left),M=1-(B-v.top)/(v.bottom-v.top);return M>1?M=1:M<0&&(M=0),T>1?T=1:T<0&&(T=0),a.__color.v=M,a.__color.s=T,a.setValue(a.__color.toOriginal()),!1}function m(_){_.type.indexOf("touch")===-1&&_.preventDefault();var v=a.__hue_field.getBoundingClientRect(),y=_.touches&&_.touches[0]||_,C=y.clientY,B=1-(C-v.top)/(v.bottom-v.top);return B>1?B=1:B<0&&(B=0),a.__color.h=B*360,a.setValue(a.__color.toOriginal()),!1}return s}return Lt(e,[{key:"updateDisplay",value:function(){var r=co(this.getValue());if(r!==!1){var s=!1;U.each(Ye.COMPONENTS,function(l){if(!U.isUndefined(r[l])&&!U.isUndefined(this.__color.__state[l])&&r[l]!==this.__color.__state[l])return s=!0,{}},this),s&&U.extend(this.__color.__state,r)}U.extend(this.__temp.__state,this.__color.__state),this.__temp.a=1;var a=this.__color.v<.5||this.__color.s>.5?255:0,n=255-a;U.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+"px",marginTop:100*(1-this.__color.v)-7+"px",backgroundColor:this.__temp.toHexString(),border:this.__field_knob_border+"rgb("+a+","+a+","+a+")"}),this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+"px",this.__temp.s=1,this.__temp.v=1,fh(this.__saturation_field,"left","#fff",this.__temp.toHexString()),this.__input.value=this.__color.toString(),U.extend(this.__input.style,{backgroundColor:this.__color.toHexString(),color:"rgb("+a+","+a+","+a+")",textShadow:this.__input_textShadow+"rgba("+n+","+n+","+n+",.7)"})}}]),e}(Mi),ig=["-moz-","-o-","-webkit-","-ms-",""];function fh(i,e,t,r){i.style.background="",U.each(ig,function(s){i.style.cssText+="background: "+s+"linear-gradient("+e+", "+t+" 0%, "+r+" 100%); "})}function rg(i){i.style.background="",i.style.cssText+="background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",i.style.cssText+="background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",i.style.cssText+="background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"}var sg={load:function(e,t){var r=t||document,s=r.createElement("link");s.type="text/css",s.rel="stylesheet",s.href=e,r.getElementsByTagName("head")[0].appendChild(s)},inject:function(e,t){var r=t||document,s=document.createElement("style");s.type="text/css",s.innerHTML=e;var a=r.getElementsByTagName("head")[0];try{a.appendChild(s)}catch{}}},ag=`<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`,og=function(e,t){var r=e[t];return U.isArray(arguments[2])||U.isObject(arguments[2])?new $d(e,t,arguments[2]):U.isNumber(r)?U.isNumber(arguments[2])&&U.isNumber(arguments[3])?U.isNumber(arguments[4])?new po(e,t,arguments[2],arguments[3],arguments[4]):new po(e,t,arguments[2],arguments[3]):U.isNumber(arguments[4])?new Qs(e,t,{min:arguments[2],max:arguments[3],step:arguments[4]}):new Qs(e,t,{min:arguments[2],max:arguments[3]}):U.isString(r)?new eg(e,t):U.isFunction(r)?new ch(e,t,""):U.isBoolean(r)?new nh(e,t):null};function ng(i){setTimeout(i,1e3/60)}var lg=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||ng,hg=function(){function i(){Rt(this,i),this.backgroundElement=document.createElement("div"),U.extend(this.backgroundElement.style,{backgroundColor:"rgba(0,0,0,0.8)",top:0,left:0,display:"none",zIndex:"1000",opacity:0,WebkitTransition:"opacity 0.2s linear",transition:"opacity 0.2s linear"}),E.makeFullscreen(this.backgroundElement),this.backgroundElement.style.position="fixed",this.domElement=document.createElement("div"),U.extend(this.domElement.style,{position:"fixed",display:"none",zIndex:"1001",opacity:0,WebkitTransition:"-webkit-transform 0.2s ease-out, opacity 0.2s linear",transition:"transform 0.2s ease-out, opacity 0.2s linear"}),document.body.appendChild(this.backgroundElement),document.body.appendChild(this.domElement);var e=this;E.bind(this.backgroundElement,"click",function(){e.hide()})}return Lt(i,[{key:"show",value:function(){var t=this;this.backgroundElement.style.display="block",this.domElement.style.display="block",this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)",this.layout(),U.defer(function(){t.backgroundElement.style.opacity=1,t.domElement.style.opacity=1,t.domElement.style.webkitTransform="scale(1)"})}},{key:"hide",value:function(){var t=this,r=function s(){t.domElement.style.display="none",t.backgroundElement.style.display="none",E.unbind(t.domElement,"webkitTransitionEnd",s),E.unbind(t.domElement,"transitionend",s),E.unbind(t.domElement,"oTransitionEnd",s)};E.bind(this.domElement,"webkitTransitionEnd",r),E.bind(this.domElement,"transitionend",r),E.bind(this.domElement,"oTransitionEnd",r),this.backgroundElement.style.opacity=0,this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)"}},{key:"layout",value:function(){this.domElement.style.left=window.innerWidth/2-E.getWidth(this.domElement)/2+"px",this.domElement.style.top=window.innerHeight/2-E.getHeight(this.domElement)/2+"px"}}]),i}(),ug=jd(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);sg.inject(ug);var dh="dg",gh=72,ph=20,Zr="Default",$r=function(){try{return!!window.localStorage}catch{return!1}}(),es=void 0,mh=!0,sr=void 0,Ao=!1,Ah=[],ve=function i(e){var t=this,r=e||{};this.domElement=document.createElement("div"),this.__ul=document.createElement("ul"),this.domElement.appendChild(this.__ul),E.addClass(this.domElement,dh),this.__folders={},this.__controllers=[],this.__rememberedObjects=[],this.__rememberedObjectIndecesToControllers=[],this.__listening=[],r=U.defaults(r,{closeOnTop:!1,autoPlace:!0,width:i.DEFAULT_WIDTH}),r=U.defaults(r,{resizable:r.autoPlace,hideable:r.autoPlace}),U.isUndefined(r.load)?r.load={preset:Zr}:r.preset&&(r.load.preset=r.preset),U.isUndefined(r.parent)&&r.hideable&&Ah.push(this),r.resizable=U.isUndefined(r.parent)&&r.resizable,r.autoPlace&&U.isUndefined(r.scrollable)&&(r.scrollable=!0);var s=$r&&localStorage.getItem(ar(this,"isLocal"))==="true",a=void 0,n=void 0;if(Object.defineProperties(this,{parent:{get:function(){return r.parent}},scrollable:{get:function(){return r.scrollable}},autoPlace:{get:function(){return r.autoPlace}},closeOnTop:{get:function(){return r.closeOnTop}},preset:{get:function(){return t.parent?t.getRoot().preset:r.load.preset},set:function(d){t.parent?t.getRoot().preset=d:r.load.preset=d,gg(this),t.revert()}},width:{get:function(){return r.width},set:function(d){r.width=d,yo(t,d)}},name:{get:function(){return r.name},set:function(d){r.name=d,n&&(n.innerHTML=r.name)}},closed:{get:function(){return r.closed},set:function(d){r.closed=d,r.closed?E.addClass(t.__ul,i.CLASS_CLOSED):E.removeClass(t.__ul,i.CLASS_CLOSED),this.onResize(),t.__closeButton&&(t.__closeButton.innerHTML=d?i.TEXT_OPEN:i.TEXT_CLOSED)}},load:{get:function(){return r.load}},useLocalStorage:{get:function(){return s},set:function(d){$r&&(s=d,d?E.bind(window,"unload",a):E.unbind(window,"unload",a),localStorage.setItem(ar(t,"isLocal"),d))}}}),U.isUndefined(r.parent)){if(this.closed=r.closed||!1,E.addClass(this.domElement,i.CLASS_MAIN),E.makeSelectable(this.domElement,!1),$r&&s){t.useLocalStorage=!0;var l=localStorage.getItem(ar(this,"gui"));l&&(r.load=JSON.parse(l))}this.__closeButton=document.createElement("div"),this.__closeButton.innerHTML=i.TEXT_CLOSED,E.addClass(this.__closeButton,i.CLASS_CLOSE_BUTTON),r.closeOnTop?(E.addClass(this.__closeButton,i.CLASS_CLOSE_TOP),this.domElement.insertBefore(this.__closeButton,this.domElement.childNodes[0])):(E.addClass(this.__closeButton,i.CLASS_CLOSE_BOTTOM),this.domElement.appendChild(this.__closeButton)),E.bind(this.__closeButton,"click",function(){t.closed=!t.closed})}else{r.closed===void 0&&(r.closed=!0);var h=document.createTextNode(r.name);E.addClass(h,"controller-name"),n=_o(t,h);var u=function(d){return d.preventDefault(),t.closed=!t.closed,!1};E.addClass(this.__ul,i.CLASS_CLOSED),E.addClass(n,"title"),E.bind(n,"click",u),r.closed||(this.closed=!1)}r.autoPlace&&(U.isUndefined(r.parent)&&(mh&&(sr=document.createElement("div"),E.addClass(sr,dh),E.addClass(sr,i.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(sr),mh=!1),sr.appendChild(this.domElement),E.addClass(this.domElement,i.CLASS_AUTO_PLACE)),this.parent||yo(t,r.width)),this.__resizeHandler=function(){t.onResizeDebounced()},E.bind(window,"resize",this.__resizeHandler),E.bind(this.__ul,"webkitTransitionEnd",this.__resizeHandler),E.bind(this.__ul,"transitionend",this.__resizeHandler),E.bind(this.__ul,"oTransitionEnd",this.__resizeHandler),this.onResize(),r.resizable&&dg(this),a=function(){$r&&localStorage.getItem(ar(t,"isLocal"))==="true"&&localStorage.setItem(ar(t,"gui"),JSON.stringify(t.getSaveObject()))},this.saveToLocalStorageIfPossible=a;function c(){var f=t.getRoot();f.width+=1,U.defer(function(){f.width-=1})}r.parent||c()};ve.toggleHide=function(){Ao=!Ao,U.each(Ah,function(i){i.domElement.style.display=Ao?"none":""})},ve.CLASS_AUTO_PLACE="a",ve.CLASS_AUTO_PLACE_CONTAINER="ac",ve.CLASS_MAIN="main",ve.CLASS_CONTROLLER_ROW="cr",ve.CLASS_TOO_TALL="taller-than-window",ve.CLASS_CLOSED="closed",ve.CLASS_CLOSE_BUTTON="close-button",ve.CLASS_CLOSE_TOP="close-top",ve.CLASS_CLOSE_BOTTOM="close-bottom",ve.CLASS_DRAG="drag",ve.DEFAULT_WIDTH=245,ve.TEXT_CLOSED="Close Controls",ve.TEXT_OPEN="Open Controls",ve._keydownHandler=function(i){document.activeElement.type!=="text"&&(i.which===gh||i.keyCode===gh)&&ve.toggleHide()},E.bind(window,"keydown",ve._keydownHandler,!1),U.extend(ve.prototype,{add:function(e,t){return ts(this,e,t,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(e,t){return ts(this,e,t,{color:!0})},remove:function(e){this.__ul.removeChild(e.__li),this.__controllers.splice(this.__controllers.indexOf(e),1);var t=this;U.defer(function(){t.onResize()})},destroy:function(){if(this.parent)throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");this.autoPlace&&sr.removeChild(this.domElement);var e=this;U.each(this.__folders,function(t){e.removeFolder(t)}),E.unbind(window,"keydown",ve._keydownHandler,!1),_h(this)},addFolder:function(e){if(this.__folders[e]!==void 0)throw new Error('You already have a folder in this GUI by the name "'+e+'"');var t={name:e,parent:this};t.autoPlace=this.autoPlace,this.load&&this.load.folders&&this.load.folders[e]&&(t.closed=this.load.folders[e].closed,t.load=this.load.folders[e]);var r=new ve(t);this.__folders[e]=r;var s=_o(this,r.domElement);return E.addClass(s,"folder"),r},removeFolder:function(e){this.__ul.removeChild(e.domElement.parentElement),delete this.__folders[e.name],this.load&&this.load.folders&&this.load.folders[e.name]&&delete this.load.folders[e.name],_h(e);var t=this;U.each(e.__folders,function(r){e.removeFolder(r)}),U.defer(function(){t.onResize()})},open:function(){this.closed=!1},close:function(){this.closed=!0},hide:function(){this.domElement.style.display="none"},show:function(){this.domElement.style.display=""},onResize:function(){var e=this.getRoot();if(e.scrollable){var t=E.getOffset(e.__ul).top,r=0;U.each(e.__ul.childNodes,function(s){e.autoPlace&&s===e.__save_row||(r+=E.getHeight(s))}),window.innerHeight-t-ph<r?(E.addClass(e.domElement,ve.CLASS_TOO_TALL),e.__ul.style.height=window.innerHeight-t-ph+"px"):(E.removeClass(e.domElement,ve.CLASS_TOO_TALL),e.__ul.style.height="auto")}e.__resize_handle&&U.defer(function(){e.__resize_handle.style.height=e.__ul.offsetHeight+"px"}),e.__closeButton&&(e.__closeButton.style.width=e.width+"px")},onResizeDebounced:U.debounce(function(){this.onResize()},50),remember:function(){if(U.isUndefined(es)&&(es=new hg,es.domElement.innerHTML=ag),this.parent)throw new Error("You can only call remember on a top level GUI.");var e=this;U.each(Array.prototype.slice.call(arguments),function(t){e.__rememberedObjects.length===0&&fg(e),e.__rememberedObjects.indexOf(t)===-1&&e.__rememberedObjects.push(t)}),this.autoPlace&&yo(this,this.width)},getRoot:function(){for(var e=this;e.parent;)e=e.parent;return e},getSaveObject:function(){var e=this.load;return e.closed=this.closed,this.__rememberedObjects.length>0&&(e.preset=this.preset,e.remembered||(e.remembered={}),e.remembered[this.preset]=Vs(this)),e.folders={},U.each(this.__folders,function(t,r){e.folders[r]=t.getSaveObject()}),e},save:function(){this.load.remembered||(this.load.remembered={}),this.load.remembered[this.preset]=Vs(this),xo(this,!1),this.saveToLocalStorageIfPossible()},saveAs:function(e){this.load.remembered||(this.load.remembered={},this.load.remembered[Zr]=Vs(this,!0)),this.load.remembered[e]=Vs(this),this.preset=e,vo(this,e,!0),this.saveToLocalStorageIfPossible()},revert:function(e){U.each(this.__controllers,function(t){this.getRoot().load.remembered?xh(e||this.getRoot(),t):t.setValue(t.initialValue),t.__onFinishChange&&t.__onFinishChange.call(t,t.getValue())},this),U.each(this.__folders,function(t){t.revert(t)}),e||xo(this.getRoot(),!1)},listen:function(e){var t=this.__listening.length===0;this.__listening.push(e),t&&yh(this.__listening)},updateDisplay:function(){U.each(this.__controllers,function(e){e.updateDisplay()}),U.each(this.__folders,function(e){e.updateDisplay()})}});function _o(i,e,t){var r=document.createElement("li");return e&&r.appendChild(e),t?i.__ul.insertBefore(r,t):i.__ul.appendChild(r),i.onResize(),r}function _h(i){E.unbind(window,"resize",i.__resizeHandler),i.saveToLocalStorageIfPossible&&E.unbind(window,"unload",i.saveToLocalStorageIfPossible)}function xo(i,e){var t=i.__preset_select[i.__preset_select.selectedIndex];e?t.innerHTML=t.value+"*":t.innerHTML=t.value}function cg(i,e,t){if(t.__li=e,t.__gui=i,U.extend(t,{options:function(n){if(arguments.length>1){var l=t.__li.nextElementSibling;return t.remove(),ts(i,t.object,t.property,{before:l,factoryArgs:[U.toArray(arguments)]})}if(U.isArray(n)||U.isObject(n)){var h=t.__li.nextElementSibling;return t.remove(),ts(i,t.object,t.property,{before:h,factoryArgs:[n]})}},name:function(n){return t.__li.firstElementChild.firstElementChild.innerHTML=n,t},listen:function(){return t.__gui.listen(t),t},remove:function(){return t.__gui.remove(t),t}}),t instanceof po){var r=new Qs(t.object,t.property,{min:t.__min,max:t.__max,step:t.__step});U.each(["updateDisplay","onChange","onFinishChange","step","min","max"],function(a){var n=t[a],l=r[a];t[a]=r[a]=function(){var h=Array.prototype.slice.call(arguments);return l.apply(r,h),n.apply(t,h)}}),E.addClass(e,"has-slider"),t.domElement.insertBefore(r.domElement,t.domElement.firstElementChild)}else if(t instanceof Qs){var s=function(n){if(U.isNumber(t.__min)&&U.isNumber(t.__max)){var l=t.__li.firstElementChild.firstElementChild.innerHTML,h=t.__gui.__listening.indexOf(t)>-1;t.remove();var u=ts(i,t.object,t.property,{before:t.__li.nextElementSibling,factoryArgs:[t.__min,t.__max,t.__step]});return u.name(l),h&&u.listen(),u}return n};t.min=U.compose(s,t.min),t.max=U.compose(s,t.max)}else t instanceof nh?(E.bind(e,"click",function(){E.fakeEvent(t.__checkbox,"click")}),E.bind(t.__checkbox,"click",function(a){a.stopPropagation()})):t instanceof ch?(E.bind(e,"click",function(){E.fakeEvent(t.__button,"click")}),E.bind(e,"mouseover",function(){E.addClass(t.__button,"hover")}),E.bind(e,"mouseout",function(){E.removeClass(t.__button,"hover")})):t instanceof mo&&(E.addClass(e,"color"),t.updateDisplay=U.compose(function(a){return e.style.borderLeftColor=t.__color.toString(),a},t.updateDisplay),t.updateDisplay());t.setValue=U.compose(function(a){return i.getRoot().__preset_select&&t.isModified()&&xo(i.getRoot(),!0),a},t.setValue)}function xh(i,e){var t=i.getRoot(),r=t.__rememberedObjects.indexOf(e.object);if(r!==-1){var s=t.__rememberedObjectIndecesToControllers[r];if(s===void 0&&(s={},t.__rememberedObjectIndecesToControllers[r]=s),s[e.property]=e,t.load&&t.load.remembered){var a=t.load.remembered,n=void 0;if(a[i.preset])n=a[i.preset];else if(a[Zr])n=a[Zr];else return;if(n[r]&&n[r][e.property]!==void 0){var l=n[r][e.property];e.initialValue=l,e.setValue(l)}}}}function ts(i,e,t,r){if(e[t]===void 0)throw new Error('Object "'+e+'" has no property "'+t+'"');var s=void 0;if(r.color)s=new mo(e,t);else{var a=[e,t].concat(r.factoryArgs);s=og.apply(i,a)}r.before instanceof Mi&&(r.before=r.before.__li),xh(i,s),E.addClass(s.domElement,"c");var n=document.createElement("span");E.addClass(n,"property-name"),n.innerHTML=s.property;var l=document.createElement("div");l.appendChild(n),l.appendChild(s.domElement);var h=_o(i,l,r.before);return E.addClass(h,ve.CLASS_CONTROLLER_ROW),s instanceof mo?E.addClass(h,"color"):E.addClass(h,Kd(s.getValue())),cg(i,h,s),i.__controllers.push(s),s}function ar(i,e){return document.location.href+"."+e}function vo(i,e,t){var r=document.createElement("option");r.innerHTML=e,r.value=e,i.__preset_select.appendChild(r),t&&(i.__preset_select.selectedIndex=i.__preset_select.length-1)}function vh(i,e){e.style.display=i.useLocalStorage?"block":"none"}function fg(i){var e=i.__save_row=document.createElement("li");E.addClass(i.domElement,"has-save"),i.__ul.insertBefore(e,i.__ul.firstChild),E.addClass(e,"save-row");var t=document.createElement("span");t.innerHTML="&nbsp;",E.addClass(t,"button gears");var r=document.createElement("span");r.innerHTML="Save",E.addClass(r,"button"),E.addClass(r,"save");var s=document.createElement("span");s.innerHTML="New",E.addClass(s,"button"),E.addClass(s,"save-as");var a=document.createElement("span");a.innerHTML="Revert",E.addClass(a,"button"),E.addClass(a,"revert");var n=i.__preset_select=document.createElement("select");if(i.load&&i.load.remembered?U.each(i.load.remembered,function(f,d){vo(i,d,d===i.preset)}):vo(i,Zr,!1),E.bind(n,"change",function(){for(var f=0;f<i.__preset_select.length;f++)i.__preset_select[f].innerHTML=i.__preset_select[f].value;i.preset=this.value}),e.appendChild(n),e.appendChild(t),e.appendChild(r),e.appendChild(s),e.appendChild(a),$r){var l=document.getElementById("dg-local-explain"),h=document.getElementById("dg-local-storage"),u=document.getElementById("dg-save-locally");u.style.display="block",localStorage.getItem(ar(i,"isLocal"))==="true"&&h.setAttribute("checked","checked"),vh(i,l),E.bind(h,"change",function(){i.useLocalStorage=!i.useLocalStorage,vh(i,l)})}var c=document.getElementById("dg-new-constructor");E.bind(c,"keydown",function(f){f.metaKey&&(f.which===67||f.keyCode===67)&&es.hide()}),E.bind(t,"click",function(){c.innerHTML=JSON.stringify(i.getSaveObject(),void 0,2),es.show(),c.focus(),c.select()}),E.bind(r,"click",function(){i.save()}),E.bind(s,"click",function(){var f=prompt("Enter a new preset name.");f&&i.saveAs(f)}),E.bind(a,"click",function(){i.revert()})}function dg(i){var e=void 0;i.__resize_handle=document.createElement("div"),U.extend(i.__resize_handle.style,{width:"6px",marginLeft:"-3px",height:"200px",cursor:"ew-resize",position:"absolute"});function t(a){return a.preventDefault(),i.width+=e-a.clientX,i.onResize(),e=a.clientX,!1}function r(){E.removeClass(i.__closeButton,ve.CLASS_DRAG),E.unbind(window,"mousemove",t),E.unbind(window,"mouseup",r)}function s(a){return a.preventDefault(),e=a.clientX,E.addClass(i.__closeButton,ve.CLASS_DRAG),E.bind(window,"mousemove",t),E.bind(window,"mouseup",r),!1}E.bind(i.__resize_handle,"mousedown",s),E.bind(i.__closeButton,"mousedown",s),i.domElement.insertBefore(i.__resize_handle,i.domElement.firstElementChild)}function yo(i,e){i.domElement.style.width=e+"px",i.__save_row&&i.autoPlace&&(i.__save_row.style.width=e+"px"),i.__closeButton&&(i.__closeButton.style.width=e+"px")}function Vs(i,e){var t={};return U.each(i.__rememberedObjects,function(r,s){var a={},n=i.__rememberedObjectIndecesToControllers[s];U.each(n,function(l,h){a[h]=e?l.initialValue:l.getValue()}),t[s]=a}),t}function gg(i){for(var e=0;e<i.__preset_select.length;e++)i.__preset_select[e].value===i.preset&&(i.__preset_select.selectedIndex=e)}function yh(i){i.length!==0&&lg.call(window,function(){yh(i)}),U.each(i,function(e){e.updateDisplay()})}var Ch=ve;class pg{constructor(){o(this,"debug",!1),o(this,"data"),o(this,"gui"),o(this,"bind"),o(this,"_current"),o(this,"_nullBind",{}),o(this,"folders",{}),this.data={},this.bind={},this._nullBind={},this._nullBind.onChange=()=>{}}init(e=10){this.debug=!0,this.gui=new Ch,this.gui.domElement.style.zIndex=`${e}`,this.gui.domElement.parentElement.style.zIndex=`${e}`,this.addFolder("Orillusion")}addCustom(e,t,r,s,a,n){if(!this.debug)return this._nullBind;let l=this._current?this._current:this.gui,h={[e]:t[r]};l.add(h,e,s,a,n).onChange(u=>{t[r]=u})}add(e,t,r,s,a){return this.debug?(this._current?this._current:this.gui).add(e,t,r,s,a):this._nullBind}addLabel(e){if(!this.debug)return this._nullBind;bt.add({label:e},"label")}addInfo(e,t){if(!this.debug)return this._nullBind;let r={};r[e]=t.toString(),bt.add(r,e)}addColor(e,t){if(!this.debug)return this._nullBind;let s=(this._current?this._current:this.gui).addColor(e[t],"rgba").name(t);return s.onChange(a=>{console.log(a);let n=e[t];n.rgba=a,e[t]=n}),s}addButton(e,t){if(!this.debug)return this._nullBind;var r=new function(){this[e]=t};(this._current?this._current:this.gui).add(r,e)}open(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).open()}close(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).close()}addFolder(e){return this.debug?(this.folders[e]?this._current=this.folders[e]:(this._current=this.gui.addFolder(e),this.folders[e]=this._current),this._current):this._nullBind}removeFolder(e){if(!this.debug)return this._nullBind;let t=this.folders[e];t&&(this.gui.removeFolder(t),this._current=null,delete this.folders[e])}endFolder(){if(!this.debug)return this._nullBind;this._current=null}_creatPanel(){let e=new Ch;return e.domElement.style.zIndex="10",e.domElement.parentElement.style.zIndex="10",e}_add(e,t,r,s,a,n){return e.add(t,r,s,a,n)}_addLabel(e,t){bt._add(e,{label:t},"label")}_addButton(e,t,r){var s=new function(){this[t]=r};e.add(s,t)}_addColor(e,t,r){return e.addColor(t[r],"rgb").name(r)}_addFolder(e,t){e.Folder==null&&(e.Folder={});let r=e.addFolder(t);return e.Folder[t]=r,r}_removeFolder(e,t){e.Folder&&e.Folder[t]&&e.removeFolder(e.Folder[t])}}let bt=new pg;class wh extends di{constructor(e){super(),o(this,"maxNumLightsPerCluster",64),o(this,"clusterPix",1),o(this,"clusterLightingBuffer"),o(this,"_currentLightCount",0),o(this,"_clusterGenerateCompute"),o(this,"_clusterLightingCompute"),o(this,"_useCamera"),o(this,"resize",!1),this.passType=re.Cluster,this.initCompute(e)}initCompute(e){this._clusterGenerateCompute=new be(ih),this._clusterLightingCompute=new be(rh);let t=S.presentationSize,r=ke.clusterTileX*ke.clusterTileY*ke.clusterTileZ,s=e.camera,a=s.near,n=s.far;this.clusterLightingBuffer=new th(r,this.maxNumLightsPerCluster),this.clusterLightingBuffer.update(t[0],t[1],this.clusterPix,ke.clusterTileX,ke.clusterTileY,ke.clusterTileZ,0,this.maxNumLightsPerCluster,a,n),this._clusterGenerateCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterGenerateCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer);let l=pe.getLightEntries(e.scene);this._clusterLightingCompute.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst),this._clusterLightingCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterLightingCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer),this._clusterLightingCompute.setStorageBuffer("lightBuffer",l.storageGPUBuffer),this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer",this.clusterLightingBuffer.lightAssignBuffer),this._clusterLightingCompute.setStorageBuffer("assignTable",this.clusterLightingBuffer.assignTableBuffer),this.resize=!0,bt.addButton("clusterBuffer",()=>{let h=this.clusterLightingBuffer.clusterBuffer.readBuffer();console.log(h);let u=2*4;for(let c=0;c<r;c++){const f=new Float32Array(h.buffer,c*u*4,u);let d=new g(f[0],f[1],f[2],f[3]),p=new g(f[4],f[5],f[6],f[7]);e.graphic3D.drawBox(c+"-box",d,p,z.random())}}),bt.addButton("assignTable",()=>{let h=this.clusterLightingBuffer.assignTableBuffer.readBuffer();for(let u=0;u<h.length/4;u++){const c=h[u*4+0],f=h[u*4+1],d=h[u*4+2],p=h[u*4+3];c>=1&&console.log(c),f+c>f+1&&console.log(c,f,d,p)}console.log(h)}),bt.addButton("clustersUniformBuffer",()=>{let h=this.clusterLightingBuffer.clustersUniformBuffer.readBuffer();console.log(h)})}render(e,t){let r=e.scene,s=Q.instance.getLights(r);if(this._useCamera!=e.camera){this._useCamera=e.camera;let l=pe.getCameraGroup(this._useCamera);this._clusterGenerateCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer),this._clusterLightingCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer)}this._currentLightCount!=s.length&&(this._currentLightCount=s.length,this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights",s.length),this.clusterLightingBuffer.clustersUniformBuffer.apply(),this._clusterGenerateCompute.workerSizeX=ke.clusterTileZ,this._clusterLightingCompute.workerSizeX=ke.clusterTileZ);let a=S.presentationSize;this.clusterLightingBuffer.update(a[0],a[1],this.clusterPix,ke.clusterTileX,ke.clusterTileY,ke.clusterTileZ,s.length,this.maxNumLightsPerCluster,e.camera.near,e.camera.far),this.resize=!1;let n=w.beginCommandEncoder();w.computeCommand(n,[this._clusterGenerateCompute,this._clusterLightingCompute]),w.endCommandEncoder(n)}}class bh extends te{constructor(e=.001,t=1e4,r=90,s=!1){super(),o(this,"up_camera"),o(this,"down_camera"),o(this,"left_camera"),o(this,"right_camera"),o(this,"front_camera"),o(this,"back_camera"),this.initCubeCamera(e,t,r,s)}set label(e){this.up_camera.name=e+"up",this.down_camera.name=e+"down",this.left_camera.name=e+"left",this.right_camera.name=e+"right",this.front_camera.name=e+"front",this.back_camera.name=e+"back"}initCubeCamera(e,t,r=90,s=!1){this.up_camera=Ne.createCamera3DObject(this,"up"),this.down_camera=Ne.createCamera3DObject(this,"down"),this.left_camera=Ne.createCamera3DObject(this,"left"),this.right_camera=Ne.createCamera3DObject(this,"right"),this.front_camera=Ne.createCamera3DObject(this,"front"),this.back_camera=Ne.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=s,this.down_camera.isShadowCamera=s,this.left_camera.isShadowCamera=s,this.right_camera.isShadowCamera=s,this.front_camera.isShadowCamera=s,this.back_camera.isShadowCamera=s;let a=1;this.up_camera.perspective(r,a,e,t),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.up_camera.object3D.scaleX=-1,this.up_camera.object3D.rotationY=180,this.down_camera.perspective(r,a,e,t),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.down_camera.object3D.scaleX=-1,this.down_camera.object3D.rotationY=180,this.left_camera.perspective(r,a,e,t),this.left_camera.lookAt(g.ZERO,g.LEFT),this.left_camera.object3D.scaleX=-1,this.right_camera.perspective(r,a,e,t),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.right_camera.object3D.scaleX=-1,this.front_camera.perspective(r,a,e,t),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.front_camera.object3D.scaleX=-1,this.back_camera.perspective(r,a,e,t),this.back_camera.lookAt(g.ZERO,g.BACK),this.back_camera.object3D.scaleX=-1,this.up_camera.type=Ie.shadow,this.down_camera.type=Ie.shadow,this.left_camera.type=Ie.shadow,this.right_camera.type=Ie.shadow,this.front_camera.type=Ie.shadow,this.back_camera.type=Ie.shadow}}class Sh extends at{constructor(e,t,r){super(e,t,r),this.format=G.depth32float,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="cube-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:6*this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"cube-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler({minFilter:Nr.linear,magFilter:Nr.linear}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Ih extends di{constructor(){super(),o(this,"shadowPassCount"),o(this,"_forceUpdate",!1),o(this,"_shadowCameraDic"),o(this,"shadowCamera"),o(this,"cubeArrayTexture"),o(this,"colorTexture"),o(this,"shadowSize",1024),this.passType=re.POINT_SHADOW,this._shadowCameraDic=new Map,this.cubeArrayTexture=new Sh(this.shadowSize,this.shadowSize,8),this.colorTexture=new oe(this.shadowSize,this.shadowSize,G.bgra8unorm,!1),se.getInstance().attached(this.cubeArrayTexture,this)}getShadowCamera(e,t){let r;if(this._shadowCameraDic.has(t))r=this._shadowCameraDic.get(t);else{let s=new bh(e.camera.near,e.camera.far,90,!0);s.label=t.name;let a=[],n=[];for(let l=0;l<6;l++){let h=new oe(this.shadowSize,this.shadowSize,this.cubeArrayTexture.format,!1),u=new Ze([this.colorTexture],[new Ce]);h.name="shadowDepthTexture_"+t.name+l+"_face",u.depthTexture=h,u.label="shadowRender",u.customSize=!0;let c=He.createRendererPassState(u);n[l]=c,a[l]=h,A.getRenderJob(e).postRenderer.setDebugTexture([h]),A.getRenderJob(e).debug()}r={cubeCamera:s,depthTexture:a,rendererPassState:n},this._shadowCameraDic.set(t,r)}return r}render(e,t){if(!A.setting.shadow.enable)return;this.shadowPassCount=0,e.camera;let r=e.scene,s=Ve.getPointShadowLightWhichScene(r),a=s.length;for(let n=0;n<a;n++){let l=s[n];if(l.lightData.lightType!=Qe.DirectionLight&&l.lightData.castShadowIndex>-1&&(l.needUpdateShadow||this._forceUpdate||he.frame<5||l.realTimeShadow)){l.needUpdateShadow=!1;let h=this.getShadowCamera(e,l),u=l.transform.worldPosition;h.cubeCamera.x=u.x,h.cubeCamera.y=u.y,h.cubeCamera.z=u.z;let c;h.cubeCamera.transform.updateWorldMatrix(!0),t.update(h.cubeCamera.right_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.right_camera),this.renderSceneOnce(0,h,e,h.cubeCamera.right_camera,c,t),t.update(h.cubeCamera.left_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.left_camera),this.renderSceneOnce(1,h,e,h.cubeCamera.left_camera,c,t),t.update(h.cubeCamera.up_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.up_camera),this.renderSceneOnce(2,h,e,h.cubeCamera.up_camera,c,t),t.update(h.cubeCamera.down_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.down_camera),this.renderSceneOnce(3,h,e,h.cubeCamera.down_camera,c,t),t.update(h.cubeCamera.front_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.front_camera),this.renderSceneOnce(4,h,e,h.cubeCamera.front_camera,c,t),t.update(h.cubeCamera.back_camera,r),c=Q.instance.getRenderNodes(r,h.cubeCamera.back_camera),this.renderSceneOnce(5,h,e,h.cubeCamera.back_camera,c,t);let f=w.beginCommandEncoder();for(let d=0;d<6;d++)f.copyTextureToTexture({texture:h.depthTexture[d].getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.cubeArrayTexture.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:l.shadowIndex*6+d}},{width:this.shadowSize,height:this.shadowSize,depthOrArrayLayers:1});w.endCommandEncoder(f)}}this._forceUpdate=!1}renderSceneOnce(e,t,r,s,a,n){this.rendererPassState=t.rendererPassState[e];let l=w.beginCommandEncoder(),h=w.beginRenderPass(l,this.rendererPassState);h.setViewport(0,0,this.shadowSize,this.shadowSize,0,1),h.setScissorRect(0,0,this.shadowSize,this.shadowSize),s.onUpdate(),s.transform.updateWorldMatrix(!0);let u=Q.instance.getRenderShaderCollect(r);for(const c of u){let f=c[1];for(const d of f){let p=d[1];if(p.preInit){p.nodeUpdate(r,this._rendererType,this.rendererPassState,null);break}}}this.drawShadowRenderNodes(r,s,h,a.opaqueList,n),this.drawShadowRenderNodes(r,s,h,a.transparentList,n),w.endPass(h),w.endCommandEncoder(l)}drawShadowRenderNodes(e,t,r,s,a){if(w.bindCamera(r,t),s)for(let n=A.setting.render.drawOpMin;n<Math.min(s.length,A.setting.render.drawOpMax);++n){let l=s[n];if(l.transform.worldMatrix.index,!!l.transform.enable&&l.enable){l.preInit||l.nodeUpdate(e,this._rendererType,this.rendererPassState);for(let h of l.materials){let u=h.getPass(this._rendererType);if(!u||u.length==0)continue;w.bindGeometryBuffer(r,l.geometry);let c=l.object3D.transform._worldMatrix;for(let f of u){const d=f;if(d.pipeline){d.setUniformFloat("cameraFar",t.far),d.setUniformVector3("lightWorldPos",t.transform.worldPosition),d.materialDataUniformBuffer.apply(),w.bindPipeline(r,d);let p=l.geometry.subGeometries;for(const m of p){let v=m.lodLevels[l.lodLevel];w.drawIndexed(r,v.indexCount,1,v.indexStart,0,c.index)}}}}}}}}class Eh extends at{constructor(e,t,r=G.depth32float,s=4){super(e,t,s),this.format=r,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Bh extends di{constructor(){super(),o(this,"shadowPassCount"),o(this,"depth2DArrayTexture"),o(this,"rendererPassStates"),o(this,"_forceUpdate",!1),o(this,"_shadowPos",new g),o(this,"_shadowCameraTarget",new g),this.setShadowMap(A.setting.shadow.shadowSize,lt.Cascades),this.passType=re.SHADOW}setShadowMap(e,t){this.rendererPassStates=[],this.depth2DArrayTexture=new Eh(e,e,G.depth32float,8),se.getInstance().attached(this.depth2DArrayTexture,this);for(let r=0;r<8;r++){let s=new Ze([],[]);const a=new oe(e,e,G.depth32float,!1);a.name=`shadowDepthTexture_${r}`,s.depthTexture=a,s.label="shadowRender",s.customSize=!0,s.depthCleanValue=1;let n=He.createRendererPassState(s);this.rendererPassStates[r]=n}}render(e,t){let r=A.setting.shadow;if(!r.enable)return;let s=e.camera,a=e.scene;if(this.shadowPassCount=0,!r.needUpdate||he.frame%r.updateFrameRate!=0)return;let n=Ve.getDirectShadowLightWhichScene(a),l=r.shadowSize;const h=lt.Cascades;for(let u of n){const c=u;let f=c.shadowIndex;this.rendererPassState=this.rendererPassStates[f];let d=Q.instance.getRenderShaderCollect(e);for(const p of d){let m=p[1];for(const _ of m){let v=_[1];if(v.preInit){v.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}if(c.castShadow&&c.needUpdateShadow||this._forceUpdate||c.castShadow&&r.autoUpdate)if(c.needUpdateShadow=!1,s.enableCSM&&f==0)for(let p=0;p<h;p++){this.rendererPassState=this.rendererPassStates[p];let m=s.csm.children[p],_=s.getCSMShadowWorldExtents(p);this.poseShadowCamera(s,c.direction,m.shadowCamera,_,m.bound.center),this.renderShadow(e,m.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,p,l)}else{s.enableCSM&&(f+=h-1);let p=s.getShadowWorldExtents();this.rendererPassState=this.rendererPassStates[f],this.poseShadowCamera(s,c.direction,c.shadowCamera,p,s.lookTarget),this.renderShadow(e,c.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,f,l)}}this._forceUpdate=!1}copyDepthTexture(e,t,r,s){let a=w.beginCommandEncoder();a.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:r}},{width:s,height:s,depthOrArrayLayers:1}),w.endCommandEncoder(a)}poseShadowCamera(e,t,r,s,a){this._shadowPos.copy(t).normalize(e.far),a.add(this._shadowPos,this._shadowCameraTarget),a.subtract(this._shadowPos,this._shadowPos),r.transform.lookAt(this._shadowPos,this._shadowCameraTarget),r.orthoOffCenter(-s,s,-s,s,e.near,e.far*2)}compute(){}renderShadow(e,t,r,s){let a=Q.instance.getRenderNodes(e.scene,t),n=w.beginCommandEncoder(),l=w.beginRenderPass(n,s);t.transform.updateWorldMatrix(),ks.enable&&(r.update(t,e.scene),r.collect(a,t)),w.bindCamera(l,t);let h=this.renderShadowBundleOp(e,t,s),u=this.renderShadowBundleTr(e,t,s);h.length>0&&l.executeBundles(h),this.drawShadowRenderNodes(e,t,l,a.opaqueList),u.length>0&&l.executeBundles(u),this.drawShadowRenderNodes(e,t,l,a.transparentList),w.endPass(l),w.endCommandEncoder(n)}renderShadowBundleOp(e,t,r){let s=Q.instance.getOpRenderGroup(e.scene);if(s){let a=[];return s.renderGroup.forEach(n=>{if(n.bundleMap.has(this._rendererType))a.push(n.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,l,n.renderNodes);let h=l.finish();n.bundleMap.set(this._rendererType,h),a.push(h)}}),a}return[]}renderShadowBundleTr(e,t,r){let s=Q.instance.getTrRenderGroup(e.scene);if(s){let a=[];return s.renderGroup.forEach(n=>{if(n.bundleMap.has(this._rendererType))a.push(n.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,l,n.renderNodes);let h=l.finish();n.bundleMap.set(this._rendererType,h),a.push(h)}}),a}return[]}recordShadowRenderBundleNode(e,t,r,s,a){if(w.bindCamera(r,t),s){w.bindGeometryBuffer(r,s[0].geometry);for(let n=0;n<s.length;++n){let l=s[n];l.transform.enable&&l.recordRenderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}drawShadowRenderNodes(e,t,r,s,a){if(w.bindCamera(r,t),s)for(let n=A.setting.render.drawOpMin;n<Math.min(s.length,A.setting.render.drawOpMax);++n){let l=s[n];l.transform.enable&&l.enable&&l.renderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}class Th extends di{constructor(){super(),o(this,"zBufferTexture"),o(this,"useRenderBundle",!1),o(this,"shadowPassCount"),o(this,"zCullingCompute"),this.passType=re.DEPTH;let e=S.presentationSize,t=1;this.zBufferTexture=Fe.createRTTexture(Ae.zBufferTexture_NAME,Math.floor(e[0]*t),Math.floor(e[1]*t),G.rgba16float,!1);let r=new Ce;r.clearValue=[0,0,0,0],r.loadOp="clear";let s=new Ze([],[],Fe.createRTTexture(Ae.zPreDepthTexture_NAME,Math.floor(e[0]),Math.floor(e[1]),G.depth32float,!1),null,!1);this.setRenderStates(s)}render(e,t){let r=e.camera,s=e.scene;w.cleanCache(),ft.start("DepthPass Renderer");let a=s;this.rendererPassState.camera3D=r;let n=Q.instance.getRenderNodes(a,r);this.compute(e,t);let l=this.renderBundleOp(e,n,t),h=[],u=w.beginCommandEncoder(),c=w.beginRenderPass(u,this.rendererPassState);l.length>0&&c.executeBundles(l);let f=Q.instance.getRenderShaderCollect(e);for(const d of f){let p=d[1];for(const m of p){let _=m[1];if(_.preInit){_.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}this.drawRenderNodes(e,c,u,n.opaqueList,t),h.length>0&&c.executeBundles(h),w.endPass(c),w.endCommandEncoder(u),ft.end("DepthPass Renderer")}drawRenderNodes(e,t,r,s,a,n){w.bindCamera(t,e.camera);for(let l=A.setting.render.drawOpMin;l<Math.min(s.length,A.setting.render.drawOpMax);++l){let h=s[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState),h.renderPass2(e,this._rendererType,this.rendererPassState,n,t))}}}class Mh{constructor(){o(this,"map"),o(this,"passRendererList"),this.map=new Map,this.passRendererList=[]}addRenderer(e){this.map.has(e.passType)?console.error("same renderer pass repeat!"):(this.map.set(e.passType,e),e.passType<=8&&this.addPassRenderer(e))}getRenderer(e){return this.map.get(e)}addPassRenderer(e){this.passRendererList.push(e)}getAllRenderer(){return this.map}getAllPassRenderer(){return this.passRendererList}}class Dh extends di{constructor(){super(),o(this,"finalQuadView"),o(this,"postList"),this._rendererType=re.POST,this.postList=[],this.initRenderer()}initRenderer(){N.register("FullQuad_vert_wgsl",el),this.finalQuadView=new Ns("Quad_vert_wgsl","Quad_frag_wgsl",new Ze([],[]),null,null,!1)}attachPost(e,t){t.postRenderer=this,this.postList.indexOf(t)!=-1||(this.postList.push(t),t.onAttach(e))}detachPost(e,t){let r=this.postList.indexOf(t);return r>=0&&(this.postList.splice(r,1),t.onDetach(e),t.postRenderer=null),r>=0}render(e){let t=w.beginCommandEncoder();for(let s=0;s<this.postList.length;s++){const a=this.postList[s];a.enable&&a.render(e,t)}let r=w.lastRenderPassState.getLastRenderTexture();if(this.finalQuadView.renderToViewQuad(e,this.finalQuadView,t,r),this.debugViewQuads.length){let s=A.setting.render.debugQuad;s>=0&&this.debugViewQuads[s].renderToViewQuad(e,this.debugViewQuads[s],t,this.debugTextures[s])}w.endCommandEncoder(t)}}class Ph{constructor(e){o(this,"rendererMap"),o(this,"shadowMapPassRenderer"),o(this,"pointLightShadowRenderer"),o(this,"ddgiProbeRenderer"),o(this,"postRenderer"),o(this,"clusterLightingRender"),o(this,"occlusionSystem"),o(this,"depthPassRenderer"),o(this,"colorPassRenderer"),o(this,"pauseRender",!1),o(this,"pickFire"),o(this,"_view"),this._view=e,this.rendererMap=new Mh,this.occlusionSystem=new ks,this.clusterLightingRender=this.addRenderer(wh,e),A.setting.render.zPrePass&&(this.depthPassRenderer=this.addRenderer(Th)),this.shadowMapPassRenderer=new Bh,this.pointLightShadowRenderer=new Ih}addRenderer(e,t){let r;return t?r=new e(t):r=new e,this.rendererMap.addRenderer(r),r}get view(){return this._view}set view(e){this._view=e}start(){}stop(){}pause(){this.pauseRender=!0}resume(){this.pauseRender=!1}enablePost(e){this.postRenderer=this.addRenderer(Dh),this.postRenderer.setRenderStates(e)}addPost(e){return this.postRenderer||this.enablePost(wt.getGBufferFrame("ColorPassGBuffer")),e instanceof Ct&&this.postRenderer.attachPost(this.view,e),e}removePost(e){if(e instanceof Ct)this.postRenderer.detachPost(this.view,e);else for(let t=0;t<e.length;t++)this.postRenderer.detachPost(this.view,e[t])}renderFrame(){let e=this._view;pe.getLightEntries(e.scene).update(e),this.occlusionSystem.update(e.camera,e.scene),this.clusterLightingRender.render(e,this.occlusionSystem),this.shadowMapPassRenderer&&(Ve.update(e.scene),this.shadowMapPassRenderer.render(e,this.occlusionSystem)),this.pointLightShadowRenderer&&this.pointLightShadowRenderer.render(e,this.occlusionSystem),this.depthPassRenderer&&(this.depthPassRenderer.compute(e,this.occlusionSystem),this.depthPassRenderer.render(e,this.occlusionSystem)),A.setting.gi.enable&&this.ddgiProbeRenderer&&(this.ddgiProbeRenderer.compute(e,this.occlusionSystem),this.ddgiProbeRenderer.render(e,this.occlusionSystem));let t=this.rendererMap.getAllPassRenderer();for(let r=0;r<t.length;r++){const s=t[r];s.compute(e,this.occlusionSystem),s.render(e,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer)}this.postRenderer&&this.postRenderer.postList.length>0&&this.postRenderer.render(e)}debug(){}}class Rh extends te{constructor(e=.001,t=1e4,r=90,s=!1){super(),o(this,"up_camera"),o(this,"down_camera"),o(this,"left_camera"),o(this,"right_camera"),o(this,"front_camera"),o(this,"back_camera"),this.initCubeCamera(e,t,r,s)}initCubeCamera(e,t,r=90,s=!1){this.up_camera=Ne.createCamera3DObject(this,"up"),this.down_camera=Ne.createCamera3DObject(this,"down"),this.left_camera=Ne.createCamera3DObject(this,"left"),this.right_camera=Ne.createCamera3DObject(this,"right"),this.front_camera=Ne.createCamera3DObject(this,"front"),this.back_camera=Ne.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=s,this.down_camera.isShadowCamera=s,this.left_camera.isShadowCamera=s,this.right_camera.isShadowCamera=s,this.front_camera.isShadowCamera=s,this.back_camera.isShadowCamera=s;let a=1;this.up_camera.perspective(r,a,e,t),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.down_camera.perspective(r,a,e,t),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.left_camera.perspective(r,a,e,t),this.left_camera.lookAt(g.ZERO,g.LEFT),this.right_camera.perspective(r,a,e,t),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.front_camera.perspective(r,a,e,t),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.back_camera.perspective(r,a,e,t),this.back_camera.lookAt(g.ZERO,g.BACK),this.up_camera.type=Ie.shadow,this.down_camera.type=Ie.shadow,this.left_camera.type=Ie.shadow,this.right_camera.type=Ie.shadow,this.front_camera.type=Ie.shadow,this.back_camera.type=Ie.shadow}}class Lh extends Ze{constructor(e,t){super([],[]),this.crateGBuffer(e,t)}crateGBuffer(e,t){let r=this.attachments,s=this.rtDescriptors,a=new oe(e,t,G.rgba16float,!1);a.name="positionMap";let n=new Ce;n.loadOp="load";let l=new oe(e,t,G.rgba16float,!1);l.name="normalMap";let h=new Ce;h.loadOp="load";let u=new oe(e,t,G.rgba16float,!1);u.name="colorMap";let c=new Ce;c.loadOp="load";let f=new oe(e,t,G.depth24plus,!1);f.name="depthTexture";let d=new Ce;d.loadOp="load",r.push(a),r.push(l),r.push(u),s.push(n),s.push(h),s.push(c),this.depthTexture=f}}let Uh=`
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<storage, read> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //\u5DE6\u53F3
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u4E0A\u4E0B
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u8865\u89D2
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;class Oh{constructor(e){o(this,"irradianceBuffer"),o(this,"depthBuffer"),o(this,"probeIrradianceMap"),o(this,"probeDepthMap"),o(this,"volume"),o(this,"computeShader"),o(this,"depthRaysBuffer"),this.volume=e,this.initPipeline()}initPipeline(){this.computeShader=new be(Uh);let e=A.setting.gi,t=e.octRTMaxSize*e.octRTMaxSize;this.irradianceBuffer=new ge(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("irradianceBuffer",this.irradianceBuffer),this.depthBuffer=new ge(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("depthBuffer",this.depthBuffer),this.depthRaysBuffer=new ge(4096*4*2*2*2,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.computeShader.setStorageBuffer("depthRaysBuffer",this.depthRaysBuffer),this.computeShader.setStorageBuffer("probes",this.volume.probesBuffer),this.computeShader.setStorageBuffer("uniformData",this.volume.irradianceVolumeBuffer),this.computeShader.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst)}setTextures(e,t,r){this.probeIrradianceMap=t,this.probeDepthMap=r;let s=e[0],a=e[1],n=e[2];this.computeShader.setStorageTexture("probeIrradianceMap",this.probeIrradianceMap),this.computeShader.setStorageTexture("probeDepthMap",this.probeDepthMap),this.computeShader.setSamplerTexture("positionMap",s),this.computeShader.setSamplerTexture("normalMap",a),this.computeShader.setSamplerTexture("colorMap",n)}readBuffer(){return this.depthRaysBuffer.readBuffer()}compute(e,t){let r=this.volume.setting,s=w.beginCommandEncoder(),a=Q.instance.getProbes(e.scene);this.computeShader.workerSizeX=r.octRTSideSize/8,this.computeShader.workerSizeY=r.octRTSideSize/8,this.computeShader.workerSizeZ=a.length,w.computeCommand(s,[this.computeShader])}}let Nh=`
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<storage,read> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;class Fh{constructor(e){o(this,"blendTexture"),o(this,"volume"),o(this,"computerShader"),this.volume=e,this.initPipeline()}initPipeline(){let e=A.setting.gi;this.blendTexture=new oe(e.probeSourceTextureSize,e.probeSourceTextureSize,G.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING),this.computerShader=new be(Nh),this.computerShader.setStorageTexture("outputBuffer",this.blendTexture),this.computerShader.setStorageBuffer("uniformData",this.volume.irradianceVolumeBuffer)}setInputs(e){let t=e[0],r=e[1],s=e[2],a=e[3];this.computerShader.setSamplerTexture("normalMap",t),this.computerShader.setSamplerTexture("colorMap",r),this.computerShader.setSamplerTexture("litMap",s),this.computerShader.setSamplerTexture("irradianceMap",a)}compute(e,t){let r=w.beginCommandEncoder(),s=this.volume.setting,a=s.probeXCount*s.probeYCount*s.probeZCount,n=s.probeSize;this.computerShader.workerSizeX=n*6/8,this.computerShader.workerSizeY=n/8,this.computerShader.workerSizeZ=a,w.computeCommand(r,[this.computerShader])}}let kh=`

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(1) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(2) var prefilterMapSampler: sampler;
@group(0) @binding(3) var prefilterMap: texture_cube<f32>;

@group(1) @binding(0) var positionMapSampler : sampler;
@group(1) @binding(1) var positionMap : texture_2d<f32>;

@group(1) @binding(2) var normalMapSampler : sampler;
@group(1) @binding(3) var normalMap : texture_2d<f32>;

@group(1) @binding(4) var colorMapSampler : sampler;
@group(1) @binding(5) var colorMap : texture_2d<f32>;

@group(1) @binding(6) var shadowMapSampler : sampler_comparison;
@group(1) @binding(7) var shadowMap : texture_depth_2d_array;

@group(1) @binding(8) var pointShadowMapSampler: sampler;
@group(1) @binding(9) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(positionMap, positionMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(positionMap, uv, 0) ;
   return oc;
}

fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
   return oc;
}

fn sampleColor(uv:vec2<i32>) -> vec4<f32>
{
   var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
   var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${lt.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
  var shadowIndex = i32(light.castShadow);
  if (shadowIndex >= 0 ) {
    var shadowMatrix:mat4x4<f32>;
    if(enableCSM && csmCount > 1){
      for(var csm:i32 = 0; csm < csmCount; csm ++){
        var csmShadowBias = globalUniform.csmShadowBias[csm];
        shadowMatrix = globalUniform.csmMatrix[csm];
        let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
        if(csmShadowResult.y < 0.5){
          visibility = csmShadowResult.x;
          break;
        }
      }
    }else{
      shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
      visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
    }
  }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn coordFun(fragCoord:vec2<u32>)-> vec4<f32>{
 var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;
 var pos = samplePosition(uv);

 var normalMap = sampleNormal(uv);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
   var color = coordFun(fragCoord);
   
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, vec2<i32>(fragCoord),color);
}

`;class zh{constructor(){o(this,"computeShader"),o(this,"worldPosMap"),o(this,"worldNormalMap"),o(this,"colorMap"),o(this,"shadowMap"),o(this,"pointShadowMap"),o(this,"lightingTexture");let e=A.setting.gi;this.lightingTexture=new oe(e.probeSourceTextureSize,e.probeSourceTextureSize,G.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING)}create(e){let t=pe.getLightEntries(e.scene);this.computeShader=new be(kh);let r=pe.getCameraGroup(e.camera);this.computeShader.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.computeShader.setStorageTexture("outputBuffer",this.lightingTexture),this.computeShader.setStorageBuffer("lightBuffer",t.storageGPUBuffer),this.computeShader.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst),this.computeShader.setSamplerTexture("positionMap",this.worldPosMap),this.computeShader.setSamplerTexture("normalMap",this.worldNormalMap),this.computeShader.setSamplerTexture("colorMap",this.colorMap),this.computeShader.setSamplerTexture("shadowMap",this.shadowMap),this.computeShader.setSamplerTexture("pointShadowMap",this.pointShadowMap),this.computeShader.setSamplerTexture("prefilterMap",A.res.defaultSky)}setInputs(e){this.worldPosMap=e[0],this.worldNormalMap=e[1],this.colorMap=e[2],this.shadowMap=e[3],this.pointShadowMap=e[4]}compute(e,t){this.computeShader||this.create(e);let r=w.beginCommandEncoder(),s=A.setting.gi;this.computeShader.workerSizeX=s.probeSourceTextureSize/8,this.computeShader.workerSizeY=s.probeSourceTextureSize/8,this.computeShader.workerSizeZ=1,w.computeCommand(r,[this.computeShader])}}let Hs=new je("GIRenderStartEvent"),Co=new je("GIRenderCompleteEvent");class mg{constructor(){o(this,"count"),o(this,"complete")}}class Gh extends di{constructor(e){super(),o(this,"cubeCamera"),o(this,"volume"),o(this,"probeCountPerFrame",1),o(this,"nextProbeIndex",-1),o(this,"tempProbeList",[]),o(this,"isRenderCloudGI"),o(this,"probeRenderResult"),o(this,"renderStatus","none"),o(this,"positionMap"),o(this,"normalMap"),o(this,"colorMap"),o(this,"probeNext",128),o(this,"sizeW"),o(this,"sizeH"),o(this,"lightingPass"),o(this,"bouncePass"),o(this,"irradianceComputePass"),o(this,"irradianceDepthMap"),o(this,"irradianceColorMap"),this.passType=re.GI,this.volume=e;let t=e.setting;this.cubeCamera=new Rh(.01,5e3),this.sizeW=t.probeSourceTextureSize,this.sizeH=t.probeSourceTextureSize,this.probeNext=t.probeSourceTextureSize/t.probeSize,this.initIrradianceMap(e),this.probeRenderResult=new mg;let r=new Lh(this.sizeW,this.sizeH);this.positionMap=r.attachments[0],this.normalMap=r.attachments[1],this.colorMap=r.attachments[2],this.setRenderStates(r)}setInputTexture(e){this.lightingPass=new zh,this.bouncePass=new Fh(this.volume),this.irradianceComputePass=new Oh(this.volume),this.lightingPass.setInputs([this.positionMap,this.normalMap,this.colorMap,e[0],e[1]]),this.bouncePass.setInputs([this.normalMap,this.colorMap,this.lightingPass.lightingTexture,this.irradianceColorMap]),this.irradianceComputePass.setTextures([this.positionMap,this.normalMap,this.bouncePass.blendTexture],this.irradianceColorMap,this.irradianceDepthMap)}setIrradianceData(e,t,r,s){if(r!=this.irradianceColorMap.width||s!=this.irradianceColorMap.height){console.error("irradiance image size not match !");return}this.writeToTexture(this.irradianceColorMap,e,r,s),this.writeToTexture(this.irradianceDepthMap,t,r,s)}updateProbe(e,t,r){let s=Q.instance.getLights(e.scene),a=this.volume.setting.probeSize;t.drawCallFrame+=1,this.cubeCamera.x=t.x,this.cubeCamera.y=t.y,this.cubeCamera.z=t.z,this.volume.setting.debugCamera?(this.cubeCamera.x=e.camera.transform.x,this.cubeCamera.y=e.camera.transform.y,this.cubeCamera.z=e.camera.transform.z,this.cubeCamera.rotationX=e.camera.transform.rotationX,this.cubeCamera.rotationY=e.camera.transform.rotationY,this.cubeCamera.rotationZ=e.camera.transform.rotationZ):(this.cubeCamera.rotationX=t.rotationX,this.cubeCamera.rotationY=t.rotationY,this.cubeCamera.rotationZ=t.rotationZ);let n=this.cubeCamera,l=Math.floor(t.index/this.probeNext)*(a*6),h=Math.floor(t.index%this.probeNext)*a;r.setViewport(0+l,h,a,a,0,1),this.renderSceneOnce(e,n.right_camera,r,s),r.setViewport(a+l,h,a,a,0,1),this.renderSceneOnce(e,n.left_camera,r,s),r.setViewport(a*2+l,h,a,a,0,1),this.renderSceneOnce(e,n.up_camera,r,s),r.setViewport(a*3+l,h,a,a,0,1),this.renderSceneOnce(e,n.down_camera,r,s),r.setViewport(a*4+l,h,a,a,0,1),this.renderSceneOnce(e,n.front_camera,r,s),r.setViewport(a*5+l,h,a,a,0,1),this.renderSceneOnce(e,n.back_camera,r,s)}renderSceneOnce(e,t,r,s){this.volume.uploadBuffer();let a=Q.instance.getRenderNodes(e.scene,t);w.bindCamera(r,t);let n=Math.max(0,A.setting.render.drawOpMin),l=Math.min(A.setting.render.drawOpMax,a.opaqueList.length),h=Q.instance.getRenderShaderCollect(e);for(const u of h){let c=u[1];for(const f of c){let d=f[1];if(d.preInit){d.nodeUpdate(e,this.passType,this.rendererPassState,null);break}}}for(let u=n;u<l;++u){let c=a.opaqueList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}Q.instance.sky&&(Q.instance.sky.preInit||Q.instance.sky.nodeUpdate(e,this.passType,this.rendererPassState,null),Q.instance.sky.renderPass2(e,this.passType,this.rendererPassState,null,r)),n=Math.max(0,A.setting.render.drawTrMin),l=Math.min(A.setting.render.drawTrMax,a.transparentList.length);for(let u=n;u<l;++u){let c=a.transparentList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}}render(e,t){if(!A.setting.gi.enable)return;this.volume.updateOrientation(),this.volume.isVolumeFrameChange=!1,this.volume.uploadBuffer(),this.rendProbe(e);let r=this.probeRenderResult.count>0;(Q.instance.state.giLightingChange||r||A.setting.gi.realTimeGI)&&(Q.instance.state.giLightingChange=!1,this.lightingPass.compute(e,this.rendererPassState),this.bouncePass.compute(e,this.rendererPassState),this.irradianceComputePass.compute(e,this.rendererPassState)),this.probeRenderResult.complete&&this.dispatchEvent(Co)}startRenderGI(e=0){this.nextProbeIndex==-1&&e==0&&this.dispatchEvent(Hs),this.nextProbeIndex=e,this.renderStatus="rendering"}startRenderCloudGI(){this.dispatchEvent(Hs),this.nextProbeIndex=0,this.renderStatus="rendering",this.isRenderCloudGI=!0}rendProbe(e){let t=A.setting.gi.autoRenderProbe,r=!1;if(t?(this.nextProbeIndex==-1&&this.startRenderGI(),r=!0):r=this.renderStatus=="rendering",this.probeRenderResult.count=0,this.probeRenderResult.complete=!1,r){let s=Q.instance.getProbes(e.scene);this.renderContext.clean(),this.renderContext.beginRenderPass(),this.tempProbeList.length=0;let a=Math.min(this.probeCountPerFrame,s.length);for(this.probeRenderResult.count=a;a>0;){const l=s[this.nextProbeIndex];this.updateProbe(e,l,this.renderContext.encoder),a--,this.nextProbeIndex++,l.drawCallFrame<3&&this.tempProbeList.push(l)}this.tempProbeList.length>0&&this.volume.updateProbes(this.tempProbeList);let n=this.nextProbeIndex>=s.length;this.nextProbeIndex>=s.length&&this.isRenderCloudGI&&this.updateProbe(e,s[0],this.renderContext.encoder),this.renderContext.endRenderPass(),n&&(this.nextProbeIndex=-1,this.renderStatus="complete",this.probeRenderResult.complete=!0)}}initIrradianceMap(e){let t=e.setting,r=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST;this.irradianceDepthMap=new oe(t.octRTMaxSize,t.octRTMaxSize,G.rgba16float,!1,r),this.irradianceDepthMap.name="irradianceDepthMap",this.irradianceColorMap=new oe(t.octRTMaxSize,t.octRTMaxSize,G.rgba16float,!1,r),this.irradianceColorMap.name="irradianceColorMap"}writeToTexture(e,t,r,s){console.log(e.name);const a=S.device.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});S.device.queue.writeBuffer(a,0,t);const n=w.beginCommandEncoder();n.copyBufferToTexture({buffer:a,bytesPerRow:r*16},{texture:e.getGPUTexture()},{width:r,height:s,depthOrArrayLayers:1}),w.endCommandEncoder(n)}}class wo extends Ph{constructor(e){super(e)}start(){super.start();let e=wt.getGBufferFrame("ColorPassGBuffer");{let t=[],r=new eh;if(A.setting.render.zPrePass&&(e.zPreTexture=this.depthPassRenderer.rendererPassState.depthTexture),r.setRenderStates(e),A.setting.gi.enable){let s=pe.getLightEntries(this.view.scene);this.ddgiProbeRenderer=new Gh(s.irradianceVolume),this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture,this.pointLightShadowRenderer.cubeArrayTexture]),r.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap),this.rendererMap.addRenderer(this.ddgiProbeRenderer),t.push(this.ddgiProbeRenderer.positionMap,this.ddgiProbeRenderer.normalMap,this.ddgiProbeRenderer.colorMap,this.ddgiProbeRenderer.lightingPass.lightingTexture,this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap)}this.postRenderer&&this.postRenderer.setDebugTexture(t),this.rendererMap.addRenderer(r)}A.setting.render.debug&&this.debug()}debug(){}}class Qh{constructor(){o(this,"_factor"),o(this,"_doubleFactor"),this._factor=1,this._doubleFactor=2}get accelerateInterpolator(){return this._factor}set accelerateInterpolator(e){this._factor=e,this._doubleFactor=2*this._factor}getInterpolation(e){return this._factor==1?e*e:Math.pow(e,this._doubleFactor)}}class Vh{constructor(){o(this,"_factor",1)}get decelerateInterpolator(){return this._factor}set decelerateInterpolator(e){this._factor=e}getInterpolation(e){let t;return this._factor==1?t=1-(1-e)*(1-e):t=1-Math.pow(1-e,2*this._factor),t}}class Hh{constructor(){o(this,"_factor",1)}getInterpolation(e){return Math.cos((e+1)*Math.PI)/2+.5}}class Yh{getInterpolation(e){return e}}class Xh{getInterpolation(e){return 4.9*e+4.9*e}}class At{constructor(){}static bounce(e){return e*e*9.8}getInterpolation(e){return e*=1.1226,e<.3535?At.bounce(e):e<.7408?At.bounce(e-.54719)+.7:e<.9644?At.bounce(e-.8526)+.9:At.bounce(e-1.0435)+.95}getBounceInterpolation(e){return e<.5?At.bounce(e):At.bounce(e-1)}geJumpUp(e,t){return t<.5?(t=t/.5,e*t-At.bounce(t)):t<.8?(t=(t-.5)/(.8-.5),(e*t-At.bounce(t))*.3):t<1?(t=(t-.8)/(1-.8),(e*t-At.bounce(t))*.15):e*t-At.bounce(t)}}class Wh{constructor(){o(this,"_tension"),this._tension=2}get anticipateInterpolator(){return this._tension}set anticipateInterpolator(e){this._tension=e}getInterpolation(e){return e*e*((this._tension+1)*e-this._tension)}}class Ss{constructor(){o(this,"_tension"),this._tension=1*1.5}anticipateOvershootInterpolator(e){this._tension=e*1.5}anticipateOvershootInterpolator2(e,t){this._tension=e*t}getInterpolation(e){return e<.5?.5*Ss.a(e*2,this._tension):.5*(Ss.o(e*2-2,this._tension)+2)}static a(e,t){return e*e*((t+1)*e-t)}static o(e,t){return e*e*((t+1)*e+t)}}class jh{constructor(e){o(this,"_cycles"),this._cycles=e}getInterpolation(e){return Math.sin(2*this._cycles*Math.PI*e)}}class qh{constructor(){o(this,"_tension"),this._tension=2}getInterpolation(e){return e-=1,e*e*((this._tension+1)*e+this._tension)+1}}var bo=(i=>(i[i.AccelerateInterpolator=0]="AccelerateInterpolator",i[i.DecelerateInterpolator=1]="DecelerateInterpolator",i[i.AccelerateDecelerateInterpolator=2]="AccelerateDecelerateInterpolator",i[i.LinearInterpolator=3]="LinearInterpolator",i[i.BounceInterpolator=4]="BounceInterpolator",i[i.AnticipateInterpolator=5]="AnticipateInterpolator",i[i.AnticipateOvershootInterpolator=6]="AnticipateOvershootInterpolator",i[i.CycleInterpolator=7]="CycleInterpolator",i[i.OvershootInterpolator=8]="OvershootInterpolator",i[i.JumperInterpolator=9]="JumperInterpolator",i))(bo||{});const or=class{constructor(){o(this,"complete",!1),o(this,"onComplete"),o(this,"onProgress"),o(this,"target"),o(this,"property"),o(this,"targetProperty"),o(this,"durtion"),o(this,"interpolatorEnum"),o(this,"delayTime",0),o(this,"_interpolator"),o(this,"_ct",0),o(this,"_p",0)}static to(i,e,t,r=0){var s=new or;return s.target=i,s.property=e,s.durtion=t,s.interpolatorEnum=r,s.start(),s.delayTime=e.delayTime?e.delayTime:0,e.onComplete&&(s.onComplete=e.onComplete),e.onProgress&&(s.onProgress=e.onProgress),this.interpolators.push(s),s}static tick(i){let e=or.interpolators;for(let t of e)t.complete?or.remove(t,!0):t.tick(i)}static remove(i,e){let t=or.interpolators,r=t.indexOf(i);r!=-1&&t.splice(r,1),e&&i.dispose()}static removeList(i,e){i.forEach(t=>{this.remove(t,e)})}start(){window.AccelerateInterpolator=Qh,window.DecelerateInterpolator=Vh,window.AccelerateDecelerateInterpolator=Hh,window.LinearInterpolator=Yh,window.BounceInterpolator=At,window.AnticipateInterpolator=Wh,window.AnticipateOvershootInterpolator=Ss,window.CycleInterpolator=jh,window.OvershootInterpolator=qh,window.JumperInterpolator=Xh,this._interpolator=new window[bo[this.interpolatorEnum]],this.targetProperty={};for(let i in this.property)this.targetProperty[i]=this.target[i]}tick(i){if(this.delayTime<=0){this._p=Math.min(this._ct/this.durtion,1);let e=this._interpolator.getInterpolation(this._p),t=this.property,r=this.target,s=this.targetProperty,a,n;for(let l in t)n=t[l],a=s[l],r[l]=a+(n-a)*e;this.onProgress!=null&&this.onProgress(this._p),this._ct>=this.durtion&&(this.complete=!0,this.onComplete!=null&&this.onComplete(this.target)),this._ct+=i}else this.delayTime-=i}dispose(){this.onComplete=null,this.onProgress=null,this.target=null,this.property=null,this.targetProperty=null,this.interpolatorEnum=null,this._interpolator=null,or.remove(this)}};let So=or;o(So,"interpolators",[]);class it{static hasString(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}static getEllipsis(e,t=4){let r=e;return r.length>t&&(r=r.slice(0,t)+"..."),r}static getURLName(e){var t;t=e.split("/");let r=t[t.length-1];return r=r.split(".")[0],r}static getFileFormat(e){var t=e.lastIndexOf(".");t++;var r=e.length;e.indexOf("?",t)!==-1&&(r=e.indexOf("?",t));var s=e.substr(t,r-t);return s=s.toLowerCase(),s}static readLineProperty(e,t){e.trim().split(" ").forEach((r,s)=>{let a=r.split("=");if(a.length>1){let n=a[0],l=a[1];Object.prototype.hasOwnProperty.call(t,n)&&(l.indexOf('"')==-1?t[n]=parseFloat(a[1]):t[n]=l.replace('"',"").replace('"',""))}})}static getPath(e){var t=e.lastIndexOf("/");return t++,e.substring(0,t)}static normalizePath(e){var t=e.replaceAll("//","/");return t=t.replaceAll("\\","/"),t}static getStringList(e,t=";"){return e.split(t)}static formatTime(e){let r=e/1e3/60,s=Math.floor(r),a=Math.floor(r-s);return[s.toString(),a.toString()]}static trim(e){return e.replace(/^\s+/g,"").replace(/\s+$/g,"")}static isEmpty(e){return!e||typeof e>"u"||e==null||typeof e=="string"&&this.trim(e)===""||e==="null"}static strCut(e,t){if(e.length*2<=t)return e;for(var r=0,s="",a=0;a<e.length;a++)if(s=s+e.charAt(a),e.charCodeAt(a)>128){if(r=r+2,r>=t)return s.substring(0,s.length-1)+"..."}else if(r=r+1,r>=t)return s.substring(0,s.length-2)+"...";return s}static toQueryPair(e,t,r=!1){return e+"="+(r?encodeURIComponent(t):t)}static stringFormat(e,...t){if(arguments.length===0)throw new Error("please give arg at least one !");if(arguments.length===2&&typeof arguments[1]=="object")for(let r in arguments[1]){let s=new RegExp("({"+r+"})","g");e=e.replace(s,arguments[1][r])}else for(let r=0;r<t.length;r++){if(t[r]==null)return e;{let s=new RegExp("({["+r+"]})","g");e=e.replace(s,t[r])}}return e}static parseJson2String(e,t){let r=null,s="",a=0,n="    ";return t=t||{},t.newlineAfterColonIfBeforeBraceOrBracket=t.newlineAfterColonIfBeforeBraceOrBracket===!0,t.spaceAfterColon=t.spaceAfterColon!==!1,typeof e!="string"||(e=JSON.parse(e)),e=JSON.stringify(e),r=/([\{\}])/g,e=e.replace(r,`\r
$1\r
`),r=/([\[\]])/g,e=e.replace(r,`\r
$1\r
`),r=/(\,)/g,e=e.replace(r,`$1\r
`),r=/(\r\n\r\n)/g,e=e.replace(r,`\r
`),r=/\r\n\,/g,e=e.replace(r,","),t.newlineAfterColonIfBeforeBraceOrBracket||(r=/\:\r\n\{/g,e=e.replace(r,":{"),r=/\:\r\n\[/g,e=e.replace(r,":[")),t.spaceAfterColon&&(r=/\:/g,e=e.replace(r,":")),e.split(`\r
`).forEach(function(l,h){let u=0,c=0,f="";for(l.match(/\{$/)||l.match(/\[$/)?c=1:l.match(/\}/)||l.match(/\]/)?a!==0&&(a-=1):c=0,u=0;u<a;u++)f+=n;s+=f+l+`\r
`,a+=c}),s}static compareVersion(e,t){e=e.split("."),t=t.split(".");let r=Math.max(e.length,t.length);for(;e.length<r;)e.push("0");for(;t.length<r;)t.push("0");for(let s=0;s<r;s++){let a=parseInt(e[s]),n=parseInt(t[s]);if(a>n)return 1;if(a<n)return-1}return 0}static buildRandomCode(){let e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",t=e.length,r="";for(let a=0;a<26;a++){let n=Math.floor(Math.random()*t);r+=e.charAt(n)}return`${new Date().getTime()}-${r}`}static UUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=Math.random()*16|0,r=e=="x"?t:t&3|8;return r.toString(16)})}static stringToHash(e){let t=0;if(e.length==0)return t;for(let r=0;r<e.length;r++){const s=e.charCodeAt(r);t=(t<<5)-t+s,t=t&t}return t}static parseUrl(e,t){return t.match(/^(blob|http|https):/)?t:e+t}}o(it,"_filterChar",[" ","  ",";",`
`,"\r","	",`
`,"\r","	"]);class ii extends at{constructor(e=!0){super(),o(this,"_source"),o(this,"imageData"),this.useMipmap=e}get source(){return this._source}set source(e){this._source=e,this._source instanceof HTMLImageElement?this._source.decode().then(async()=>{if(this._source instanceof HTMLImageElement){const t=await createImageBitmap(this._source,{imageOrientation:this.flipY?"flipY":"from-image"});this.generate(t)}}):(this._source instanceof HTMLCanvasElement||this._source instanceof ImageBitmap)&&this.generate(this._source)}async load(e,t){if(e.indexOf(";base64")!=-1){const r=document.createElement("img");let s=e.indexOf("data:image"),a=e.substring(s,e.length);r.src=a,await r.decode(),r.width=Math.max(r.width,32),r.height=Math.max(r.height,32);const n=await createImageBitmap(r,{resizeWidth:r.width,resizeHeight:r.height,imageOrientation:this.flipY?"flipY":"from-image"});this.format=G.rgba8unorm,this.generate(n)}else{const r=await fetch(e,{headers:Object.assign({Accept:"image/avif,image/webp,*/*"},t?.headers)});let s=await ji.read(e,r,t),a=new Blob([s],{type:"image/jpeg"});s=null,await this.loadFromBlob(a)}return this.name=it.getURLName(e),!0}async loadFromBlob(e){this.imageData=e;let t=await createImageBitmap(e,{imageOrientation:this.flipY?"flipY":"from-image"});if(t.width<32||t.height<32){let r=Math.max(t.width,32),s=Math.max(t.height,32);t=await createImageBitmap(t,{resizeWidth:r,resizeHeight:s,imageOrientation:this.flipY?"flipY":"from-image"})}return this.format=G.rgba8unorm,this.generate(t),!0}}class ji{constructor(){o(this,"baseUrl",""),o(this,"initUrl"),o(this,"_progress",0)}async loadBinData(e,t){return this.baseUrl=it.getPath(e),this.initUrl=e,new Promise(async(r,s)=>{fetch(e,{headers:t?.headers}).then(async a=>{if(a.ok){let n=await ji.read(e,a,t),l=n.buffer;n=null,r(l)}else throw Error("request rejected with status "+a.status)}).catch(a=>{t.onError&&t.onError(a),s(a)})})}async loadAsyncBitmapTexture(e,t){this.baseUrl=it.getPath(e),this.initUrl=e;let r=new ii;return r.url=e,r.name=it.getURLName(e),await r.load(e,t),A.res.addTexture(e,r),r}async loadJson(e,t){return this.baseUrl=it.getPath(e),this.initUrl=e,new Promise(async(r,s)=>{fetch(e,{headers:t?.headers}).then(async a=>{if(a.ok){let n=await ji.read(e,a,t);const h=new TextDecoder("utf-8").decode(n);n=null,r(JSON.parse(h))}else throw Error("request rejected with status"+a.status)}).catch(a=>{t.onError&&t.onError(a),s(a)})})}async loadTxt(e,t){return this.baseUrl=it.getPath(e),new Promise(async(r,s)=>{fetch(e).then(async a=>{if(a.ok){let n=await ji.read(e,a,t);const h=new TextDecoder("utf-8").decode(n);n=null,r({data:h})}else throw Error("request rejected with status"+a.status)}).catch(a=>{t.onError&&t.onError(a),s(a)})})}static async read(e,t,r){const s=t.body.getReader(),a=+t.headers.get("Content-Length");let n=0,l=[],h=[];for(;;){const{done:f,value:d}=await s.read();if(f){a>0&&r&&r.onComplete&&r.onComplete.call(this,e);break}l.push(d),n+=d.length,a>0?r&&r.onProgress&&r.onProgress.call(this,n,a,e):h.push(d.length)}if(h.length>0)for(let f=0;f<l.length;f++)console.log(h[f]),r&&r.onProgress&&r.onProgress.call(this,h[f],n,e),h[f]==n&&r&&r.onComplete&&r.onComplete.call(this,e);let u=new Uint8Array(n),c=0;for(let f of l)u.set(f,c),c+=f.length;return u}}class ht extends ji{async load(e,t,r,s){switch(t.format){case"bin":return new Promise(async(a,n)=>{this.loadBinData(e,r).then(async l=>{let h=new t;if(h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,await h.parseBuffer(l),h.verification())a(h);else throw new Error("parser error")}).catch(l=>{n(l)})});case"json":return new Promise((a,n)=>{this.loadJson(e,r).then(async l=>{let h=new t;h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,await h.parseJson(l),a(h)}).catch(l=>{n(l)})});case"text":return new Promise((a,n)=>{this.loadTxt(e,r).then(async l=>{let h=new t;h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,l.data?(await h.parseString(l.data),a(h)):n("text load is empty!")}).catch(l=>{n(l)})})}}}class Xt{constructor(){o(this,"baseUrl"),o(this,"initUrl"),o(this,"loaderFunctions"),o(this,"userData"),o(this,"data")}parseString(e){}parseJson(e){}parseBuffer(e){}parseTexture(e){throw this.parserError("Method not implemented.",-1)}parse(e){}verification(e){throw this.parserError("Method not implemented.",-1)}parserError(e,t){console.error(`error id:${t} ${e}`)}}o(Xt,"format","bin");class Ys{constructor(){o(this,"asset"),o(this,"accessors"),o(this,"buffers"),o(this,"bufferViews"),o(this,"materials"),o(this,"meshes"),o(this,"nodes"),o(this,"scene",0),o(this,"scenes"),o(this,"textures"),o(this,"cameras"),o(this,"skins"),o(this,"resources"),o(this,"images"),o(this,"samplers"),o(this,"animations"),o(this,"extensions")}}class Ag{constructor(){o(this,"nodes")}}class _g{constructor(){o(this,"name"),o(this,"type"),o(this,"color"),o(this,"intensity"),o(this,"range"),o(this,"spot"),o(this,"isParsed")}}class xg{constructor(){o(this,"name"),o(this,"rotation"),o(this,"scale"),o(this,"translation"),o(this,"children"),o(this,"matrix"),o(this,"mesh",-1),o(this,"isParsed"),o(this,"dnode"),o(this,"camera"),o(this,"skin"),o(this,"nodeId"),o(this,"primitives"),o(this,"extensions"),o(this,"light")}}class vg{constructor(){o(this,"attributes"),o(this,"indices"),o(this,"material"),o(this,"mode"),o(this,"name"),o(this,"targets"),o(this,"extensions"),o(this,"morphTargetsRelative")}}class yg{constructor(){o(this,"name"),o(this,"primitives"),o(this,"isParsed"),o(this,"dprimitives"),o(this,"weights"),o(this,"extras")}}class Cg{constructor(){o(this,"bufferView"),o(this,"componentType"),o(this,"count"),o(this,"type"),o(this,"max"),o(this,"min"),o(this,"isParsed"),o(this,"daccessor"),o(this,"normalized"),o(this,"sparse"),o(this,"byteOffset"),o(this,"computeResult")}}const wg=window.SharedArrayBuffer?function(e){return e&&e.buffer&&(e.buffer instanceof ArrayBuffer||e.buffer instanceof window.SharedArrayBuffer)}:function(e){return e&&e.buffer&&e.buffer instanceof ArrayBuffer},Io=5120,is=5121,Eo=5122,Bo=5123,To=5124,Mo=5125,Do=5126,bg=32819,Sg=32820,Ig=33635,Eg=5131,Bg=33640,Tg=35899,Mg=35902,Dg=36269,Pg=34042,Kh={};{const i=Kh;i[Io]=Int8Array,i[is]=Uint8Array,i[Eo]=Int16Array,i[Bo]=Uint16Array,i[To]=Int32Array,i[Mo]=Uint32Array,i[Do]=Float32Array,i[bg]=Uint16Array,i[Sg]=Uint16Array,i[Ig]=Uint16Array,i[Eg]=Uint16Array,i[Bg]=Uint32Array,i[Tg]=Uint32Array,i[Mg]=Uint32Array,i[Dg]=Uint32Array,i[Pg]=Uint32Array}function Rg(i){switch(i){case Int8Array:return Io;case Uint8Array:return is;case Uint8ClampedArray:return is;case Int16Array:return Eo;case Uint16Array:return Bo;case Int32Array:return To;case Uint32Array:return Mo;case Float32Array:return Do;default:throw new Error("unsupported typed array type")}}function Lg(i){if(i instanceof Int8Array)return Io;if(i instanceof Uint8Array||i instanceof Uint8ClampedArray)return is;if(i instanceof Int16Array)return Eo;if(i instanceof Uint16Array)return Bo;if(i instanceof Int32Array)return To;if(i instanceof Uint32Array)return Mo;if(i instanceof Float32Array)return Do;throw new Error("unsupported typed array type")}function Po(i){const e=Kh[i];if(!e)throw new Error("unkonw gl type");return e}function Ug(i,e=Float32Array){return wg(i)?i:new e(i)}class rs{static async apply(e,t){if(!t.extensions)return;const r=t.extensions.KHR_draco_mesh_compression;if(!r)return;let s=this._workers.get(e.gltf);s||(s=new Worker(await this.initDecoder()),this._workers.set(e.gltf,s)),s.postMessage({type:"init",decoderConfig:{}});let a=e.parseBufferView(r.bufferView);if(!a.result){let n=await new Promise((l,h)=>{s.onmessage=u=>{const c=u.data;c.type=="decode"?l(c.result):c.type=="error"&&h(c.error)},s.postMessage({type:"decoder",buffer:a,attributes:r.attributes},[a])});a.result=n}return a.result}static unload(e){let t=this._workers.get(e);t&&(t.terminate(),this._workers.delete(e))}static async initDecoder(){if(!this._workerCode){let e=await new ht().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");const t=new Blob([e.data,"",`(${Og})()`],{type:"application/javascript"});this._workerCode=URL.createObjectURL(t)}return this._workerCode}}o(rs,"_workerCode"),o(rs,"_workers",new Map);function Og(){let i,e;onmessage=t=>{const r=t.data;switch(r.type){case"init":i=r.decoderConfig,e=new Promise((n,l)=>{i.onModuleLoaded=h=>{n({draco:h})},DracoDecoderModule(i)});break;case"decoder":const s=r.buffer,a=r.attributes;e.then(n=>{const l=n.draco;let h=new l.Decoder,u=new l.DecoderBuffer;u.Init(new Int8Array(s),s.byteLength);let c,f;try{const d=h.GetEncodedGeometryType(u);d==l.TRIANGULAR_MESH?(f=new l.Mesh,c=h.DecodeBufferToMesh(u,f)):self.postMessage(new Error("INVALID_GEOMETRY_TYPE:"+d)),c.ok()||self.postMessage(new Error("DracoDecode:"+c.error_msg()));let p={};for(const m in a){let _=h.GetAttributeByUniqueId(f,a[m]);const v=_.num_components(),C=f.num_points()*v,B=C*Float32Array.BYTES_PER_ELEMENT,T=l.DT_FLOAT32,M=l._malloc(B);h.GetAttributeDataArrayForAllPoints(f,_,T,B,M);const D=new Float32Array(l.HEAPF32.buffer,M,C).slice();l._free(M),p[m]={data:D,numComponents:v,normalize:!1}}{const _=f.num_faces()*3,v=_*4,y=l._malloc(v);h.GetTrianglesUInt32Array(f,v,y);const C=new Uint32Array(l.HEAPF32.buffer,y,_).slice();l._free(y),p.indices={data:C,numComponents:1,normalize:!1}}self.postMessage({type:"decode",result:p})}catch(d){self.postMessage({type:"error",error:d.message})}finally{l.destroy(f),l.destroy(h),l.destroy(u)}});break}}}class Jh{constructor(e){o(this,"gltf"),this.gltf=e}parse(e){const t=this.gltf.cameras[e];if(!t)return this.errorMiss("camera",e);if(t.isParsed)return t.dcamera;t.isParsed=!0,t.dcamera=!1;const{name:r,type:s,perspective:a,orthographic:n}=t;if(s==="perspective"&&a){const{aspectRatio:l,yfov:h,zfar:u,znear:c}=a;t.dcamera=Object.assign({},{name:r,type:s,yfov:h,znear:c,aspectRatio:l,zfar:u})}else if(s==="orthographic"&&n){const{xmag:l,ymag:h,zfar:u,znear:c}=n;t.dcamera=Object.assign({},{name:r,type:s,xmag:l,ymag:h,zfar:u,znear:c})}return t.dcamera}errorMiss(e,t){throw new Error(e+t)}}const Zh=class extends Xt{constructor(){super(...arguments),o(this,"_gltf")}async parseJson(i){this._gltf=new Ys,this._gltf={...this._gltf,...i},this._gltf.resources={},await Promise.all([this.load_gltf_bin(),this.load_gltf_textures()]);let e=new js,t=await e.parse(this.initUrl,this._gltf,this._gltf.scene);return e.destory(),e=null,t?(this.data=t.rootNode,t.rootNode):(this._gltf=null,null)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}static getMeshNameCounter(){return function(){return`GLTF_NO_NAME_PRIMITIVE_${Zh._counter++}`}}static getModelNameCounter(){let i=0;return function(){return`GLTF_NO_NAME_MESH_${i++}`}}static getTexCoordDefine(i){return`UV_NUM ${i}`}static getVertexColorDefine(i){return`HAS_VERTEXCOLOR ${i}`}static getBaseColorTextureDefine(){return"HAS_BASECOLORMAP"}static getMetalRoughnessDefine(){return"HAS_METALROUGHNESSMAP"}static getNormalMapDefine(){return"HAS_NORMALMAP"}static getEmissiveMapDefine(){return"HAS_EMISSIVEMAP"}static getOcclusionMapDefine(){return"HAS_OCCLUSIONMAP"}static getMorphTargetsDefine(i){return`MORPH_TARGET_NUM ${i}`}static getMorphtargetPositionDefine(){return"HAS_MORPH_POSITION"}static getMorphtargetNormalDefine(){return"HAS_MORPH_NORMAL"}static getMorphtargetTangentDefine(){return"HAS_MORPH_TANGENT"}static getJointsNumDefine(i){return`JOINTS_NUM ${i}`}static getJointVec8Define(){return"JOINT_VEC8"}static getHasNormalDefine(){return"HAS_NORMAL"}static getHasTangentDefine(){return"HAS_TANGENT"}static getHasNormalMapDefine(){return"HAS_NORMAL_MAP"}static getAlphaMaskDefine(){return"ALPHA_MASK"}static getAlphaBlendDefine(){return"ALPHA_BLEND"}async load_gltf_bin(){var i;if(this._gltf.buffers&&this._gltf.buffers.length>0){let e=[];for(let t=0;t<this._gltf.buffers.length;t++){const r=this._gltf.buffers[t];if(r.uri.substring(0,5)!=="data:"){let s=it.parseUrl(this.baseUrl,r.uri);(i=this.loaderFunctions)!=null&&i.onUrl&&(s=await this.loaderFunctions.onUrl(s));let a=new ht().loadBinData(s,this.loaderFunctions).then(n=>{this._gltf.resources[r.uri]=n});e.push(a)}}await Promise.all(e)}}async load_gltf_textures(){var i;if(this._gltf,this._gltf.images){let e=[];for(let t=0;t<this._gltf.images.length;t++){const r=this._gltf.images[t];if(r.uri){let s=it.parseUrl(this.baseUrl,r.uri);(i=this.loaderFunctions)!=null&&i.onUrl&&(s=await this.loaderFunctions.onUrl(s));let a=new ht().loadAsyncBitmapTexture(s,this.loaderFunctions).then(n=>{n.name=it.getURLName(r.uri),this._gltf.resources[n.name]=n});e.push(a)}}await Promise.all(e)}}};let Ke=Zh;o(Ke,"format","json"),o(Ke,"_counter",0),o(Ke,"defaultMaterial",{name:"GLTF_DEFAULT_MATERIAL",alphaCutoff:.33,alphaMode:"MASK",pbrMetallicRoughness:{name:"GLTF_DEFAULT_MATERIAL",defines:[],doubleSided:!1,baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1,emissiveFactor:[0,0,0]}});class $h{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){const t=this.gltf.meshes[e];if(!t)return this.errorMiss("mesh",e);if(t.isParsed)return t.dprimitives;const r=t.primitives,s=t.extras,a=[];for(let n=0;n<r.length;n++){const l=r[n],{attributes:h,indices:u,material:c,mode:f,name:d,targets:p,morphTargetsRelative:m,extensions:_}=l;let v=t.name;for(let P in h)v+=P;v+=`indices:${u}`,v+=`material:${c}`;const y={attribArrays:{indices:[]},weights:[],defines:[],material:null,drawMode:null,meshName:null,modelName:null,morphTargetsRelative:!1,targetNames:s?s.targetNames:null};let C=!1,B=0,T=!1,M;_&&_.KHR_draco_mesh_compression&&(M=await rs.apply(this.subParser,l));for(const P in h){const L=M?M[P]:this.parseAccessor(h[P]);if(L){let I;switch(P){case"POSITION":I=Y.position;break;case"NORMAL":I=Y.normal,C=!0;break;case"TEXCOORD_0":I=Y.uv,B++;break;case"JOINTS_0":I=Y.joints0;break;case"JOINTS_1":I=Y.joints1,T=!0;break;case"WEIGHTS_0":I=Y.weights0;break;case"WEIGHTS_1":I=Y.weights1;break;default:I=P}y.attribArrays[I]=L}}if(C&&y.defines.push(Ke.getHasNormalDefine()),B&&y.defines.push(Ke.getTexCoordDefine(B)),T&&y.defines.push(Ke.getJointVec8Define()),u!==void 0){const P=M?M.indices:this.parseAccessor(u);P&&(y.attribArrays.indices=P)}const D=await this.parseMaterial(c);if(D&&(y.material=D,y.defines=y.defines.concat(D.defines)),y.drawMode=f===void 0?4:f,y.meshName=()=>v,y.modelName=t.name||Ke.getModelNameCounter(),p){y.defines.push(Ke.getMorphTargetsDefine(p.length)),y.morphTargetsRelative=!0;let P=!1,L=!1,I=!1;for(let O=0;O<p.length;O++){const k=p[O];Object.keys(k).forEach(H=>{const W=this.parseAccessor(k[H]);if(W){let ne;switch(H){case"POSITION":ne=le.MORPH_POSITION_PREFIX+O,P=!0;break;case"NORMAL":ne=le.MORPH_NORMAL_PREFIX+O,L=!0;break;case"TANGENT":ne=le.MORPH_TANGENT_PREFIX+O,I=!0;break;default:ne=!1}ne?y.attribArrays[ne]=W:console.error(`glTF has unsupported morph target attribute ${H}`)}})}P&&y.defines.push(Ke.getMorphtargetPositionDefine()),L&&y.defines.push(Ke.getMorphtargetNormalDefine()),I&&y.defines.push(Ke.getMorphtargetTangentDefine()),y.weights=t.weights||new Array(p.length).fill(0)}a.push(y)}return t.dprimitives=a,t.isParsed=!0,t.dprimitives}parseAccessor(e){return this.subParser.parseAccessor(e)}parseMaterial(e){return this.subParser.parseMaterial(e)}errorMiss(e,t){throw new Error(e+t)}}class eu{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){let t;if(e==null?t=Ke.defaultMaterial:t=this.gltf.materials[e],!t)return this.errorMiss("material",e);if(t.isParsed)return t.dmaterial;let{name:r,pbrMetallicRoughness:s,normalTexture:a,occlusionTexture:n,emissiveTexture:l,emissiveFactor:h,alphaMode:u,alphaCutoff:c,doubleSided:f,extensions:d}=t;const p={name:r,defines:[],doubleSided:!!f,baseColorFactor:[1,1,1,1],emissiveFactor:null,alphaCutoff:0,enableBlend:!1,baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null,transformUV1:null,transformUV2:null,extensions:null};if(s){const{baseColorFactor:m,metallicFactor:_,roughnessFactor:v,baseColorTexture:y,metallicRoughnessTexture:C}=s;if(Object.assign(p,{baseColorFactor:m||[1,1,1,1],metallicFactor:_===void 0?1:_,roughnessFactor:v===void 0?.5:v}),y){let B=y.extensions;if(B){let M=B.KHR_texture_transform;M&&(p.transformUV1=new j(M.offset?M.offset[0]:0,M.offset?M.offset[1]:0,M.scale?M.scale[0]:1,M.scale?M.scale[1]:1))}const T=await this.parseTexture(y.index);T?p.baseColorTexture=T:p.baseColorTexture=A.res.redTexture}if(C){const B=await this.parseTexture(C.index);B?p.metallicRoughnessTexture=B:p.metallicRoughnessTexture=A.res.blackTexture}}else Object.assign(p,{baseColorFactor:[1,1,1,1],metallicFactor:0,roughnessFactor:.5});if(p.baseColorFactor&&p.baseColorFactor[3]<1&&(u=u==="MASK"?"MASK":"BLEND"),u&&u!=="OPAQUE"&&(u==="MASK"&&(p.defines.push(Ke.getAlphaMaskDefine()),p.alphaCutoff=c===void 0?.5:c),u==="BLEND"&&(p.defines.push(Ke.getAlphaBlendDefine()),p.enableBlend=!0)),a){const m=await this.parseTexture(a.index);m?p.normalTexture=m:p.normalTexture=A.res.normalTexture}if(n){const m=await this.parseTexture(n.index);m&&(p.occlusionTexture=m)}if(h&&(p.emissiveFactor=h),l){const m=await this.parseTexture(l.index);m?p.emissiveTexture=m:p.emissiveTexture=A.res.blackTexture}return d&&(p.extensions=d),t.isParsed=!0,t.dmaterial=p,p}async parseTexture(e){return this.subParser.parseTexture(e)}errorMiss(e,t){throw new Error(e+t)}}class tu{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){const t=this.gltf.skins[e];if(!t)return this.errorMiss("skin",e);if(t.isParsed)return t.dskin;const{name:r,joints:s,inverseBindMatrices:a,skeleton:n}=t;if(!s)return this.errorMiss("skin.joints",e);t.isParsed=!0,t.dskin=!1;let l={name:r,skeleton:null,inverseBindMatrices:null,joints:s,defines:[Ke.getJointsNumDefine(s.length)]};if(n)l.skeleton=n;else{var h=-1;for(let u=0;u<this.gltf.nodes.length;u++)if(this.gltf.nodes[u].name=="root"){h=u;break}if(h==-1){let u=this.gltf.scenes[this.gltf.scene];h=u.nodes[u.nodes.length-1]}l.skeleton=h}if(l.inverseBindMatrices=le.IDENTITY_INVERSE_BIND_MATRICES,a!==void 0){const u=this.parseAccessor(a);if(u){const c=u.data,f=[];for(let d=0;d<c.length;d+=16)f.push(c.slice(d,d+16));l.inverseBindMatrices=f}else l=null}return t.dskin=l,t.dskin}parseAccessor(e){return this.subParser.parseAccessor(e)}errorMiss(e,t){throw new Error(e+t)}}class iu{constructor(e=""){o(this,"name",""),o(this,"index",0),o(this,"parent",null),o(this,"children",[]),o(this,"scale",new g),o(this,"rotation",new q),o(this,"translation",new g),this.name=e}}class ru{constructor(e=[]){o(this,"joints"),this.joints=e}get numJoint(){return this.joints.length}addJoint(e){e.index=this.joints.push(e)-1}getJointName(e){return this.joints[e].name}getJointParentIndex(e){let t=this.joints[e];return t.parent?t.parent.index:-1}getJointByName(e){for(let t of this.joints)if(t.name==e)return t;return null}}class Ro{constructor(e,t=!1){o(this,"index"),o(this,"worldMatrix"),this.index=e,this.worldMatrix=new V(!t)}}class ss{constructor(e,t=!1){o(this,"time"),o(this,"_skeleton"),o(this,"_jointsPose"),o(this,"mJointMatrixIndexTable"),this._skeleton=e,this._jointsPose=new Array(e.numJoint),this.mJointMatrixIndexTable=new Array(e.numJoint);for(let r=0;r<e.numJoint;r++){let s=new Ro(r,t);this._jointsPose[r]=s,this.mJointMatrixIndexTable[r]=s.worldMatrix.index}}buildSkeletonPose(e){let t=new g,r=new q,s=new g,a=new Array(this._skeleton.numJoint);this.time=e[11]>0?e[11]:e[24];for(let n=0;n<this._skeleton.numJoint;n++){let l=12*n*4,h=new Float32Array(e.buffer,e.byteOffset+l,12),u=new V;t.set(h[0],h[1],h[2]),r.set(h[4],h[5],h[6],h[7]),s.set(h[8],h[9],h[10]),Rs(r.getEulerAngles(),s,t,u),a[n]=u;let c=new Ro(n);const f=this._skeleton.getJointParentIndex(n);if(f<0)c.worldMatrix.copyFrom(u);else{let d=this._jointsPose[f];_l(d.worldMatrix,u,c.worldMatrix)}this._jointsPose[n]=c}}get numJoint(){return this._skeleton.numJoint}get joints(){return this._jointsPose}get jointMatrixIndexTable(){return this.mJointMatrixIndexTable}lerp(e,t,r){for(let s=0;s<this._jointsPose.length;s++){let a=e._jointsPose[s],n=t._jointsPose[s];this._jointsPose[s].worldMatrix.lerp(a.worldMatrix,n.worldMatrix,r)}}copyFrom(e){for(let t=0;t<this._jointsPose.length;t++)this._jointsPose[t].worldMatrix.copyFrom(e._jointsPose[t].worldMatrix)}reset(){for(let e=0;e<this._jointsPose.length;e++)this._jointsPose[e].worldMatrix.identity()}}class su extends je{constructor(e,t){super(),o(this,"skeletonAnimation"),this.type=e,this.time=t}}class ma{constructor(e,t,r,s){if(o(this,"name",""),o(this,"_skeleton"),o(this,"_skeletonPoses"),o(this,"_animationClipData"),o(this,"_events"),this.name=e,this._skeleton=t,this._animationClipData=s,r>0&&s){this._skeletonPoses=new Array(r);let a=12*t.numJoint;for(let n=0;n<r;n++){let l=a*n*4,h=new Float32Array(s.buffer,l,a),u=new ss(t);u.buildSkeletonPose(h),this._skeletonPoses[n]=u}}}get totalTime(){return this._skeletonPoses[this._skeletonPoses.length-1].time}get frameRate(){return this.totalTime/this._skeletonPoses.length}get skeleton(){return this._skeleton}get numFrame(){return this._skeletonPoses.length-1}get animationClipData(){return this._animationClipData}getSkeletonPose(e){return this._skeletonPoses[e]}getLerpSkeletonPose(e,t,r,s){let a=this.getSkeletonPose(e),n=this.getSkeletonPose(t);return s.lerp(a,n,r),s}createSubClip(e,t,r){var s=new ma(e,this._skeleton,0,null);const a=Math.max(Math.floor(t/this.frameRate),0),n=Math.min(Math.floor(r/this.frameRate),this._skeletonPoses.length-1);s._skeletonPoses=this._skeletonPoses.slice(a,n);const l=12*this._skeleton.numJoint*4;return this._animationClipData=new Float32Array(this._animationClipData,a*l,(n-a)*l),s}addEvent(e,t){this._events||(this._events=new Array),this._events.push(new su(e,t))}removeEvent(e){this._events&&(this._events=this._events.filter(t=>t.type!=e))}getEvents(){return this._events}}class Lo{constructor(e){o(this,"gltf"),o(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){let t=new ru;return this.buildSkeleton(t,void 0,e),t}parseSkeletonAnimation(e,t){let r=this.subParser.parseAccessor(t.samplers[0].input).data.length,s=12*e.numJoint,a=new Float32Array(s*r);for(var n=0;n<e.numJoint;n++)for(var l=0;l<r;l++){var h=s*l+12*n;a[h+0]=1,a[h+1]=1,a[h+2]=1,a[h+3]=1}for(let f of t.channels){let d=t.samplers[f.sampler];const p=this.subParser.parseAccessor(d.input),m=this.subParser.parseAccessor(d.output);let _=f.target.node,v=f.target.path,y=this.gltf.nodes[_];if(!y)continue;let C=e.getJointByName(y.name);switch(v){case"scale":for(var l=0;l<r;l++){var u=l*m.numComponents,h=s*l+12*C.index;a[h+0]=m.data[u+0],a[h+1]=m.data[u+1],a[h+2]=m.data[u+2],a[h+3]=1}break;case"rotation":for(var l=0;l<r;l++){var u=l*m.numComponents,h=s*l+12*C.index+4;a[h+0]=m.data[u+0],a[h+1]=m.data[u+1],a[h+2]=m.data[u+2],a[h+3]=m.data[u+3]}break;case"translation":for(var l=0;l<r;l++){var u=l*m.numComponents,h=s*l+12*C.index+8;a[h+0]=m.data[u+0],a[h+1]=m.data[u+1],a[h+2]=m.data[u+2],a[h+3]=p.data[l*p.numComponents]}break}}return new ma(t.name,e,r,a)}buildSkeleton(e,t,r,s=0){let a=this.gltf.nodes[r];a.name||(a.name="Node_"+r);let n=new iu(a.name);if(n.parent=t,a.scale&&n.scale.set(a.scale[0],a.scale[1],a.scale[2]),a.rotation&&n.rotation.set(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3]),a.translation&&n.translation.set(a.translation[0],a.translation[1],a.translation[2]),e.addJoint(n),a.children)for(let l of a.children)this.buildSkeleton(e,n,l,s+1)}}class au{constructor(e){o(this,"loop",!0),o(this,"speed",1),o(this,"t",0),o(this,"time",0),o(this,"weight",0),o(this,"currFrame",0),o(this,"lastFrame",-1),o(this,"nextFrame",0),o(this,"clip"),o(this,"animation"),o(this,"_isEnd",!1),o(this,"_currSkeletonPose"),this.clip=e,this._currSkeletonPose=new ss(this.clip.skeleton)}reset(){this.time=0,this.weight=0,this._isEnd=!1}get name(){return this.clip.name}get currSkeletonPose(){return this._currSkeletonPose}update(e){this.time=(this.time+e*this.speed)%this.clip.totalTime;let t=this.time/this.clip.frameRate;if(this.currFrame=Math.trunc(t),this.t=t-this.currFrame,this.currFrame<0&&(this.currFrame=this.clip.numFrame+this.currFrame),this.time>=0?this.nextFrame=(this.currFrame+1)%this.clip.numFrame:(this.nextFrame=this.currFrame-1,this.nextFrame<0&&(this.nextFrame=this.clip.numFrame+this.nextFrame),this.t=1-this.t),this._isEnd)this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1;else if(this.currFrame!=this.lastFrame){let a=this.speed<0?0:this.clip.numFrame;this.currFrame==a&&(this.loop?(this.currFrame=0,this.nextFrame=1,this.time=this.t=0):(this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1,this._isEnd=!0));var r=this.clip.getEvents();if(r)for(let n of r){var s=Math.floor(n.time/this.clip.frameRate);if(s=Math.min(s,this.clip.numFrame),s=Math.max(s,0),s==this.currFrame){n.skeletonAnimation=this.animation,this.animation.eventDispatcher.dispatchEvent(n);break}}this.lastFrame=this.currFrame}this.clip.getLerpSkeletonPose(this.currFrame,this.nextFrame,this.t,this._currSkeletonPose)}}class vi extends Ee{constructor(){super(),o(this,"isPlaying",!0),o(this,"timeScale",1),o(this,"_skeleton"),o(this,"_clips",[]),o(this,"_clipStates",new Map),o(this,"_mixSkeletonPose"),o(this,"_mixTempSkeletonPose"),o(this,"_currentClipState"),o(this,"_bindList",[]),o(this,"_jointMatrixIndexTableBuffer"),o(this,"_crossFadeState")}start(){}get currName(){return this._currentClipState?this._currentClipState.name:""}set skeleton(e){this._skeleton=e,this._mixSkeletonPose=new ss(this._skeleton,!0),this._mixTempSkeletonPose=new ss(this._skeleton);const t=new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);this._jointMatrixIndexTableBuffer=new ge(this._skeleton.numJoint*4,0,t)}get skeleton(){return this._skeleton}get finalSkeletonPose(){return this._mixSkeletonPose}get jointMatrixIndexTableBuffer(){return this._jointMatrixIndexTableBuffer}getJointIndexTable(e){let t=new Array;for(let r=0;r<e.length;r++){const s=e[r];let a=this._skeleton.getJointByName(s);t[r]=a?a.index:-1}return t}addAnimationClip(e){if(!this._clipStates.has(e.name)){this._clips.push(e);let t=new au(e);t.animation=this,this._clipStates.set(e.name,t),this._currentClipState||this.setCurrentClipState(t)}}getAnimationClip(e){var t=this.getAnimationClipState(e);return t?t.clip:null}getAnimationClips(){return this._clips}getAnimationClipState(e){return this._clipStates.has(e)?this._clipStates.get(e):null}getAnimationClipStates(){return this._clipStates}pause(){this.isPlaying=!1}resume(){this.isPlaying=!0}play(e,t=1,r=!1){if(this._currentClipState&&this._currentClipState.name==e)return r&&this._currentClipState.reset(),!1;let s=this.getAnimationClipState(e);return s?(s.speed=t,s.reset(),this._clipStates.forEach((a,n)=>{a.weight=0}),this.setCurrentClipState(s),!0):!1}crossFade(e,t){if(t<.01){this.play(e);return}if(this._currentClipState.name==e)return;let r=this.getAnimationClipState(e);r&&(r.reset(),this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(r,this._currentClipState,t)):this._crossFadeState=new Ng(r,this._currentClipState,t),this._currentClipState=r)}setAnimIsLoop(e,t){this._clipStates.has(e)&&(this._clipStates.get(e).loop=t)}addJointBind(e,t){this._bindList.push({jointName:e,obj:t})}removeJointBind(e){for(let t=0;t<this._bindList.length;t++)if(this._bindList[t].obj==e){this._bindList.splice(t,1);break}}onUpdate(){if(!this.isPlaying)return;let e=he.delta*.001*this.timeScale;this._crossFadeState&&this._crossFadeState.update(e);var t=0,r=[];if(this._clipStates.forEach((a,n)=>{a.weight>0&&(a.update(e),t+=a.weight,r.push(a))}),r.length>0){this._mixSkeletonPose.copyFrom(r[0].currSkeletonPose);for(var s=1;s<r.length;++s){const a=r[s];this._mixTempSkeletonPose.lerp(this._mixSkeletonPose,a.currSkeletonPose,a.weight/t),this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose)}}}cloneTo(e){let t=e.addComponent(vi);t.skeleton=this.skeleton;for(var r=0;r<this._clips.length;++r)t.addAnimationClip(this._clips[r])}setCurrentClipState(e){this._currentClipState!=e&&(this._currentClipState=e,this._currentClipState.weight=1)}}class Ng{constructor(e,t,r){o(this,"inClip"),o(this,"outClip"),o(this,"currentTime"),o(this,"crossFadeTime"),this.reset(e,t,r)}reset(e,t,r){this.inClip=e,this.outClip=t,this.currentTime=0,this.crossFadeTime=r}update(e){!this.inClip||!this.outClip||(this.currentTime+=e,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}class Xs{static add(e){this.list.indexOf(e)==-1&&this.list.push(e)}static remove(e){let t=this.list.indexOf(e);t!=-1&&this.list.splice(t,1)}}o(Xs,"list",[]);class Ws extends Ee{constructor(){super(),o(this,"name"),o(this,"size",1),o(this,"lightData"),o(this,"dirFix",1),o(this,"bindOnChange"),o(this,"needUpdateShadow",!0),o(this,"realTimeShadow",!0),o(this,"_castGI",!1),o(this,"_castShadow",!1),o(this,"_iesProfiles")}init(){this.transform.object3D.bound=new Be(new g,new g),this.lightData=new Gr,this.lightData.lightMatrixIndex=this.transform.worldMatrix.index}onChange(){this.bindOnChange&&this.bindOnChange(),this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition,new g(this.size,this.size,this.size)),this._castGI&&(Q.instance.state.giLightingChange=!0),this._castShadow?(this.needUpdateShadow=!0,Ve.addShadowLight(this)):Ve.removeShadowLight(this)}start(){this.transform.onPositionChange=()=>this.onPositionChange(),this.transform.onScaleChange=()=>this.onScaleChange(),this.transform.onRotationChange=()=>this.onRotChange(),this.onPositionChange(),this.onRotChange(),this.onScaleChange()}onPositionChange(){this.lightData.lightPosition.copyFrom(this.transform.worldPosition)}onRotChange(){this.dirFix==1?this.lightData.direction.copyFrom(this.transform.forward):this.lightData.direction.copyFrom(this.transform.back),this.lightData.lightTangent.copyFrom(this.transform.up),this.onChange()}onScaleChange(){this.onChange()}onEnable(){this.onChange(),Q.instance.addLight(this.transform.scene3D,this)}onDisable(){this.onChange(),Q.instance.removeLight(this.transform.scene3D,this),Ve.removeShadowLight(this)}set iesProfiles(e){this._iesProfiles=e,this.lightData.iesIndex=e.index,Bi.use=!0,this.onChange()}get iesProfile(){return this._iesProfiles}get r(){return this.lightData.lightColor.r}set r(e){this.lightData.lightColor.r=e,this.onChange()}get g(){return this.lightData.lightColor.g}set g(e){this.lightData.lightColor.g=e,this.onChange()}get b(){return this.lightData.lightColor.b}set b(e){this.lightData.lightColor.b=e,this.onChange()}get lightColor(){return this.lightData.lightColor}set lightColor(e){this.lightData.lightColor=e,this.onChange()}get intensity(){return this.lightData.intensity}set intensity(e){this.lightData.intensity=e,this.onChange()}set castShadow(e){e!=this._castShadow&&(this._castShadow=e,this.onChange())}get castShadow(){return this._castShadow}get shadowIndex(){return this.lightData.castShadowIndex}get castGI(){return this._castGI}set castGI(e){e?Xs.add(this):Xs.remove(this),this._castGI=e,e&&this.onChange()}get direction(){return this.lightData.direction}destroy(e){this.bindOnChange=null,Q.instance.removeLight(this.transform.scene3D,this),Ve.removeShadowLight(this),this.transform.eventDispatcher.removeEventListener(Oe.ROTATION_ONCHANGE,this.onRotChange,this),this.transform.eventDispatcher.removeEventListener(Oe.SCALE_ONCHANGE,this.onScaleChange,this),super.destroy(e)}}class ou extends Ws{constructor(){super(),o(this,"shadowCamera")}init(){super.init(),this.object3D.name==""&&(this.object3D.name="DirectionLight_"+Pt()),this.radius=Number.MAX_SAFE_INTEGER,this.lightData.lightType=Qe.DirectionLight,this.lightData.linear=0,this.lightData.quadratic=.3}start(){super.start(),this.castGI=!0}get radius(){return this.lightData.range}set radius(e){this.lightData.range=e,this.onChange()}get indirect(){return this.lightData.quadratic}set indirect(e){this.lightData.quadratic=e,this.onChange()}debug(){}}class nu extends Ws{constructor(){super()}init(){super.init(),this.lightData.lightType=Qe.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+Pt())}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(e){this.lightData.quadratic=e,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(e){let t=e.graphic3D.createCustomShape(`PointLight_${this.object3D.instanceID}`,this.transform);t.buildAxis(),t.buildCircle(g.ZERO,this.range,32,g.X_AXIS),t.buildCircle(g.ZERO,this.range,32,g.Y_AXIS),t.buildCircle(g.ZERO,this.range,32,g.Z_AXIS)}debug(){}debugDraw(e){}}class lu extends Ws{constructor(){super()}init(){super.init(),this.lightData.lightType=Qe.SpotLight,this.object3D.name==""&&(this.object3D.name="SpotLight"+Pt())}get innerAngle(){return this.lightData.innerAngle/this.lightData.outerAngle*100}set innerAngle(e){this.lightData.innerAngle=K(e,0,100)/100*this.lightData.outerAngle,this.onChange()}get outerAngle(){return this.lightData.outerAngle*qi*2}set outerAngle(e){this.lightData.outerAngle=K(e,1,179)*_e*.5,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}start(){super.start(),this.lightData.lightType=Qe.SpotLight}onUpdate(){}onGraphic(e){let t=e.graphic3D.createCustomShape(`SpotLight_${this.object3D.instanceID}`,this.transform);const r=this.range,s=this.outerAngle/2;t.buildAxis();let a=(90-s)*_e,n=r*Math.cos(a),l=r*Math.sin(a);t.buildLines([g.ZERO,new g(0,n,l)]),t.buildLines([g.ZERO,new g(n,0,l)]),a=(90+s)*_e,n=r*Math.cos(a),l=r*Math.sin(a),t.buildLines([g.ZERO,new g(0,n,l)]),t.buildLines([g.ZERO,new g(n,0,l)]),t.buildArcLine(g.ZERO,r,90-s,90+s,16,g.X_AXIS),t.buildArcLine(g.ZERO,r,90-s,90+s,16,g.Y_AXIS),t.buildCircle(new g(0,0,r*Math.sin(a)),r*Math.cos(a),32,g.Z_AXIS)}debug(){}debugDraw(e){}}class Aa extends ce{constructor(){super(),o(this,"skinJointsName"),o(this,"mInverseBindMatrixData"),o(this,"mInverseBindMatrixBuffer"),o(this,"mSkeletonAnimation"),o(this,"mJointIndexTableBuffer"),this.addRendererMask(Ue.SkinnedMesh)}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(vi),!this.skeletonAnimation){let e=this.object3D.parentObject.parentObject.getComponentsInChild(vi);e.length>0&&(this.skeletonAnimation=e[0]),this.skeletonAnimation||(this.skeletonAnimation=this.object3D.getComponentFromParent(vi))}}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(e){if(this.mSkeletonAnimation=e,!!e&&!this.mJointIndexTableBuffer){let t=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new ge(t.length*4,0,new Float32Array(t)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(e){this.mInverseBindMatrixData=e;var t=new Float32Array(e.length*16);for(let r=0;r<e.length;r++){let s=r*16,a=e[r];t.set(a,s)}this.mInverseBindMatrixBuffer=new ge(t.byteLength,0,t),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(e){let t=e.addComponent(Aa);t.geometry=this.geometry,t.material=this.material.clone(),t.castShadow=this.castShadow,t.castGI=this.castGI,t.receiveShadow=this.receiveShadow,t.rendererMask=this.rendererMask,t.skinJointsName=this.skinJointsName,t.skinInverseBindMatrices=this.skinInverseBindMatrices,t.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(e,t,r,s){for(let a=0;a<this.materials.length;a++){let l=this.materials[a].getPass(t);if(l)for(let h=0;h<l.length;h++){const u=l[h];u.pipeline||(u.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),u.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),u.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(e,t,r,s)}}class hu{static apply(e,t,r){let s=t.extensions;if(s&&s.KHR_materials_clearcoat){r.defaultPass.setDefine("USE_CLEARCOAT",!0);let a=s.KHR_materials_clearcoat;"clearcoatFactor"in a&&(t.clearcoatFactor=a.clearcoatFactor,r.clearcoatFactor=t.clearcoatFactor),"clearcoatRoughnessFactor"in a&&(t.clearcoatRoughnessFactor=a.clearcoatRoughnessFactor,r.clearcoatRoughnessFactor=t.clearcoatRoughnessFactor)}}}class uu{static apply(e,t,r){let s=t.extensions;s&&s.KHR_materials_emissive_strength?(r.emissiveIntensity=s.KHR_materials_emissive_strength.emissiveStrength*.5,r.emissiveMap==A.res.blackTexture&&(r.emissiveMap=A.res.whiteTexture)):r.emissiveIntensity=1}}class cu{static apply(e,t,r){let s=t.extensions;s&&s.KHR_materials_unlit?r.supportLight=!0:r.supportLight=!1}}class fu{constructor(e){o(this,"gltf"),o(this,"subParser"),o(this,"_testCount",8),o(this,"_hasCastShadow",!1),this.gltf=e.gltf,this.subParser=e}async convertNodeToObject3D(e,t){const r=new te;if(r.name=e.name,r[le.GLTF_NODE_INDEX_PROPERTY]=e.nodeId,e.nodeObj=r,e.matrix&&(e.translation=[0,0,0],e.rotation=[0,0,0,1],e.scale=[1,1,1]),e.translation&&(r.transform.x=e.translation[0],r.transform.y=e.translation[1],r.transform.z=e.translation[2]),e.rotation){let s=new q;s.setFromArray(e.rotation),r.transform.localRotQuat=s}if(e.scale&&(r.transform.scaleX=e.scale[0],r.transform.scaleY=e.scale[1],r.transform.scaleZ=e.scale[2]),t.addChild(r),e.light&&this.convertLight(e,r),e.primitives&&this.convertprimitives(e,r),e.skeleton){let s=r.addComponent(vi);if(s){s.skeleton=this.subParser.parseSkeleton(e.skeleton.skeleton);for(let a=0;a<this.gltf.animations.length;a++){let n=this.gltf.animations[a];n.name||(n.name=a.toString());let l=this.subParser.parseSkeletonAnimation(s.skeleton,n);s.addAnimationClip(l)}}}return r}convertLight(e,t){switch(e.light.type){case"directional":let r=t.addComponent(ou);t.name=e.light.name,r.intensity=e.light.intensity*.1,r.radius=Number.MAX_SAFE_INTEGER,r.dirFix=-1,this._hasCastShadow||(this._hasCastShadow=!0,r.castShadow=this._hasCastShadow),r.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1),r.debug();break;case"point":if(this._testCount>0){let a=t.addComponent(nu);a.name=e.light.name,a.intensity=e.light.intensity?e.light.intensity*8*2:1,a.radius=8,a.at=2,a.range=e.light.range?e.light.range:8,a.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1)}this._testCount--;break;case"spot":let s=t.addComponent(lu);s.name=e.light.name,s.intensity=e.light.intensity*5,s.radius=1,s.dirFix=-1,s.at=2,s.range=e.light.range?e.light.range:8,s.outerAngle=e.light.spot.outerConeAngle*qi,s.lightColor=e.light.color?new z(e.light.color[0],e.light.color[1],e.light.color[2]):new z(1,1,1,1);break}}convertprimitives(e,t){for(let r=0;r<e.primitives.length;r++){const s=e.primitives[r];s.modelName;let a=s.material;a.name==null&&(a.name=Pt());let n,l=`matkey_${a.name}`;if(a&&this.gltf.resources[l])n=this.gltf.resources[l];else{let d=n=new yi;if(this.gltf.resources[l]=d,d.name=a.name,s.material){const{baseColorTexture:p,baseColorFactor:m,metallicFactor:_,roughnessFactor:v,doubleSided:y,metallicRoughnessTexture:C,normalTexture:B,occlusionTexture:T,emissiveTexture:M,emissiveFactor:D,enableBlend:P,alphaCutoff:L}=s.material;let I=d=this.applyMaterialExtensions(s.material,d);if("enableBlend"in s.material&&(s.material.enableBlend?(I.blendMode=xe.NORMAL,I.depthWriteEnabled=!1):I.blendMode=xe.NONE,s.material.defines&&s.material.defines.indexOf("ALPHA_BLEND")!=-1&&(I.blendMode=xe.ALPHA,I.transparent=!0,I.depthWriteEnabled=!1)),"alphaCutoff"in s.material&&L>0&&(I.alphaCutoff=L,I.blendMode=xe.NORMAL,I.transparent=!0,I.depthWriteEnabled=!1),s.material.transformUV1&&(I.uvTransform_1=s.material.transformUV1),s.material.transformUV2&&(I.uvTransform_2=s.material.transformUV2),I.baseColor=new z(m[0],m[1],m[2],m[3]),I.roughness=v,I.metallic=_,I.doubleSide=y,I.ao=1,p&&(I.baseMap=p),B&&(I.normalMap=B),C&&(I.maskMap=C),T&&C!=T&&(I.aoMap=T),M&&(I.emissiveMap=M),D&&(D[0]>0||D[1]>0||D[2]>0)){I.emissiveMap&&I.emissiveMap==A.res.blackTexture&&(I.emissiveMap=A.res.whiteTexture);let O=D[3]?D[3]:1;I.emissiveColor=new z(D[0],D[1],D[2],O),I.emissiveIntensity=1}}}const{attribArrays:h,modelName:u,drawMode:c}=s;let f;if(!h.indices.data){let d=[],p=h.position.data.length/3/3;for(let m=0;m<p;m++){let _=m*3;d.push(_+2),d.push(_+0),d.push(_+1)}h.indices={data:new Uint8Array(d),normalize:!1,numComponents:1}}if(!h.normal){let d=[],p=h.position.data.length/3;for(let m=0;m<p;m++)d.push(0),d.push(0),d.push(0);h.normal={data:new Float32Array(d),normalize:!1,numComponents:3}}if(h.indices.data&&h.indices.data.length>3){let d=s.meshName();this.gltf.resources[d]?f=this.gltf.resources[d]:(f||(f=this.createGeometryBase(d,h,s)),this.gltf.resources[d]=f);const p=new te;if(p.name=u+r,this.gltf.animations&&h[Y.joints0]!=null){f||(f=this.createGeometryBase(u,h,s)),this.gltf.resources[d]=f;let m=this.gltf.nodes[e.skin.skeleton];if(m.dnode&&m.dnode.nodeObj){let y=m.dnode.nodeObj.addComponent(vi);if(y){y.skeleton=this.subParser.parseSkeleton(e.skin.skeleton);for(let C=0;C<this.gltf.animations.length;C++){let B=this.gltf.animations[C];B.name||(B.name=C.toString());let T=this.subParser.parseSkeletonAnimation(y.skeleton,B);y.addAnimationClip(T)}}}else m.dnode.skeleton=e.skin;let _=p.addComponent(Aa);_.castShadow=!0,_.castGI=!0,_.geometry=f,_.material=n,_.skinJointsName=this.parseSkinJoints(e.skin),_.skinInverseBindMatrices=e.skin.inverseBindMatrices}else{f||(f=this.createGeometryBase(u,h,s)),this.gltf.resources[d]=f,f.hasAttribute(Y.joints0)&&f.vertexAttributeMap.delete(Y.joints0);let m=p.addComponent(ce);m.castShadow=!0,m.castGI=!0,m.geometry=f,m.material=n}e.skin&&e.skin.defines,t.addChild(p)}}}createGeometryBase(e,t,r){let s=new tt;s.name=e,s.morphTargetsRelative=r.morphTargetsRelative;let a=r.targetNames;if(a&&a.length>0){let l=s.morphTargetDictionary={};for(let h=0;h<a.length;h++)l[a[h]]=h}if(s.morphTargetDictionary){let l=t.position.data.length/3,h=new Float32Array(l);for(let u=0;u<l;u++)h[u]=u;t.vIndex={data:h,normalize:!1,numComponents:1}}for(const l in t){let h=t[l];s.setAttribute(l,h.data)}let n=s.getAttribute(Y.indices);return s.addSubGeometry({indexStart:0,indexCount:n.data.length,vertexStart:0,index:0}),s}applyMaterialExtensions(e,t){return hu.apply(this.gltf,e,t),cu.apply(this.gltf,e,t),uu.apply(this.gltf,e,t),t}parseSkinJoints(e){let t=[];for(let r of e.joints){let s=this.gltf.nodes[r];t.push(s.name)}return t}}class js{constructor(){o(this,"currentSceneName"),o(this,"gltf"),o(this,"initUrl"),o(this,"_generator"),o(this,"_version"),o(this,"_BASE64_MARKER",";base64,"),o(this,"_cameraParser",null),o(this,"_meshParser",null),o(this,"_materialParser",null),o(this,"_skinParser",null),o(this,"_skeletonParser",null),o(this,"_converter",null)}get version(){return this.version?this.version:this.gltf?this.gltf.asset?(this._version=this.gltf.asset.version,this.gltf.asset.minVersion&&(this._version+=`\r minVersion${this.gltf.asset.minVersion}`),this.version):this.errorMiss("asset"):(console.warn("glTF not loaded."),null)}async parse(e,t,r){this.gltf=t,this.initUrl=e;const{version:s,generator:a}=this.gltf.asset;if(this._generator=a,s!=="2.0")return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`),!1;const n={nodes:await this.parseScene(r),animations:this.parseAnimations(),name:this.currentSceneName};return await this.convertToNode(n)}destory(){rs.unload(this.gltf),this.gltf=null}async parseScene(e){const t=e||this.gltf.scene||0,r=this.gltf.scenes[t];if(typeof r>"u")return this.errorMiss("scene",t);this.currentSceneName=r.name||"GLTF_NO_NAME_SCENE";const s=[],a=r.nodes;for(let n=0;n<a.length;n++){const l=await this.parseNode(a[n]);l&&s.push(l)}return s}async parseNode(e){const t=this.gltf.nodes[e];if(!t)return this.errorMiss("node",e);if(t.isParsed)return t.dnode;const{name:r,matrix:s,translation:a,rotation:n,scale:l}=t,h={name:r,matrix:s,translation:a,rotation:n,scale:l,nodeId:e,camera:null,primitives:null,skin:null,children:null,light:null};if(t.camera!==void 0&&(h.camera=this.parseCamera(t.camera)),t.mesh!==void 0&&(h.primitives=await this.parseMesh(t.mesh)),t.extensions!==void 0&&this.applyNodeExtensions(t,h),t.skin!==void 0){const u=this.parseSkin(t.skin);u&&(h.skin=u)}if(h.children=[],t.children)for(let u=0;u<t.children.length;u++)h.children.push(await this.parseNode(t.children[u]));return t.dnode=h,t.isParsed=!0,t.dnode}errorMiss(e,t){throw new Error(e+t)}parseCamera(e){return this._cameraParser||(this._cameraParser=new Jh(this.gltf)),this._cameraParser.parse(e)}async parseMesh(e){return this._meshParser||(this._meshParser=new $h(this)),this._meshParser.parse(e)}async parseTexture(e){let t=this.gltf.textures[e];if(t&&!t.dtexture){if(t&&t.source!=null){let r=this.gltf.images[t.source];if(r.uri){let s=r.uri;s=it.getURLName(s),t.dtexture=this.gltf.resources[s]}else if(r.bufferView){let s=this.parseBufferView(r.bufferView),a=new ii,n=new Blob([s],{type:r.mimeType});await a.loadFromBlob(n),t.dtexture=a}else t.dtexture=this.gltf.resources[r.name]}else if(t.name){let r=it.getURLName(t.name);t.dtexture=this.gltf.resources[r]}}return t.dtexture||console.log("miss texture , please check texture!",e,t),t.dtexture}async parseMaterial(e){return this._materialParser||(this._materialParser=new eu(this)),this._materialParser.parse(e)}parseAnimations(){return[]}async parseObject3D(e,t){return this._converter||(this._converter=new fu(this)),this._converter.convertNodeToObject3D(e,t)}parseSkeleton(e){return this._skeletonParser||(this._skeletonParser=new Lo(this)),this._skeletonParser.parse(e)}parseSkeletonAnimation(e,t){return this._skeletonParser||(this._skeletonParser=new Lo(this)),this._skeletonParser.parseSkeletonAnimation(e,t)}async traverse(e,t){for(let r=0;r<t.length;r++){const s=await this.parseObject3D(t[r],e);await this.traverse(s,t[r].children)}}async convertToNode(e){const t=new te;t.name=e.name;const r=e.nodes;e.animations;const s=[],a=[];await this.traverse(t,r);let n;return{rootNode:t,textures:s,animations:n,cameras:a}}parseSkin(e){return this._skinParser||(this._skinParser=new tu(this)),this._skinParser.parse(e)}parseAccessor(e){const t=this.gltf.accessors[e];if(!t)return this.errorMiss("accessor",e);if(t.isParsed)return t.daccessor;t.isParsed=!0,t.daccessor=!1;const r=!!t.normalized,s=this.gltf.bufferViews[t.bufferView],a=s&&s.byteStride,n=Po(t.componentType);let l=1;switch(t.type){case"SCALAR":l=1;break;case"VEC2":l=2;break;case"VEC3":l=3;break;case"VEC4":case"MAT2":l=4;break;case"MAT3":l=9;break;case"MAT4":l=16;break;default:l=0;break}if(l===0)return console.error(`glTF has unknown data type in accessor: ${t.type}`),!1;const h=l*n.BYTES_PER_ELEMENT;let u;if(s!==void 0){if(u=this.parseBufferView(t.bufferView),!u)return t.daccessor}else u=new Uint8Array(h*t.count).buffer;let c=this.getTypedArrayFromArrayBuffer(u,a,t.byteOffset||0,n,l,t.count);if(t.sparse){const{count:f,indices:d,values:p}=t.sparse;c=new n(c);const m=d.byteOffset||0,_=this.gltf.bufferViews[d.bufferView],v=Po(d.componentType),y=this.parseBufferView(d.bufferView),C=this.getTypedArrayFromArrayBuffer(y,_.byteStride,m,v,1,f),B=p.byteOffset||0,T=this.gltf.bufferViews[p.bufferView],M=this.parseBufferView(p.bufferView),D=this.getTypedArrayFromArrayBuffer(M,T.byteStride,B,n,l,f);for(let P=0;P<C.length;P++)c.set(D.slice(P*l,P*l+l),C[P]*l)}return t.computeResult={typedArray:c,arrayType:n,numComponents:l},t.daccessor={data:c,numComponents:l,normalize:r},t.daccessor}getTypedArrayFromArrayBuffer(e,t,r,s,a,n){let l;const h=a*s.BYTES_PER_ELEMENT;if(t&&h!==t){const u=a*n;l=new s(u);for(let c=0;c<n;c++){const f=new s(e,r+c*t,a);for(let d=0;d<a;d++)l[c*a+d]=f[d]}}else l=new s(e,r,n*a);return l}parseBufferView(e){const t=this.gltf.bufferViews[e];if(!t)return this.errorMiss("bufferView",e);if(t.isParsed)return t.dbufferView;t.isParsed=!0,t.dbufferView=!1;const r=this.parseBuffer(t.buffer);if(r){const{byteOffset:s,byteLength:a}=t,n=new Uint8Array(r,s||0,a);t.dbufferView=new Uint8Array(n).buffer}return t.dbufferView}parseBuffer(e){const t=this.gltf.buffers[e];if(!t)return this.errorMiss("buffer",e);if(t.isParsed)return t.dbuffer;if(t.isParsed=!0,t.dbuffer=!1,t.uri.substring(0,5)!=="data:"){const r=t.uri,s=this.gltf.resources[r];s?s.byteLength===t.byteLength?t.dbuffer=this.gltf.resources[r]:console.error(`load gltf resource "${r}" at buffers[${e} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`):console.error(`load gltf resource "${r}" at buffers[${e}] failed`)}else{const r=t.uri.indexOf(this._BASE64_MARKER)+this._BASE64_MARKER.length,s=window.atob(t.uri.substring(r)),a=new Uint8Array(s.length);for(let n=0;n<s.length;n++)a[n]=s.charCodeAt(n);t.dbuffer=a.buffer}return t.dbuffer}getLight(e){return this.gltf.extensions.KHR_lights_punctual.lights[e]}applyNodeExtensions(e,t){let r=e.extensions;r.KHR_lights_punctual&&this.gltf.extensions.KHR_lights_punctual&&(t.light=this.getLight(r.KHR_lights_punctual.light))}}class du{constructor(){o(this,"magic"),o(this,"version"),o(this,"length")}}class gu{constructor(){o(this,"chunkLength"),o(this,"chunkType"),o(this,"chunkData")}}class qs extends Xt{constructor(){super(...arguments),o(this,"_gltf")}async parseBuffer(e){let t=new Uint8Array(e);t.pos=0;const r=this.parseHeader(t);if(r.magic!=1179937895)return console.error("invalid GLB file"),!1;if(r.version!==2)return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${r.version}`),!1;let s=[];for(;t.pos<t.length;){let f=this.parseChunk(t);s.push(f)}if(s[0].chunkType!=1313821514)return console.error("invalid GLBChunk"),!1;let a="",n=65535,l=s[0].chunkData;for(let f=0;f<l.length;f+=n){let d=l.length-f;d=Math.min(d,n);let p=l.subarray(f,f+d);a+=String.fromCharCode(...p)}let h=JSON.parse(a);this._gltf=new Ys,this._gltf={...this._gltf,...h},this._gltf.resources={};for(let f=0;f<this._gltf.buffers.length;f++){let d=this._gltf.buffers[f];d.isParsed=!0,d.dbuffer=s[f+1].chunkData.buffer}if(this._gltf.images)for(let f=0;f<this._gltf.images.length;f++){let d=this._gltf.images[f];d.name=d.name||"bufferView_"+d.bufferView.toString();const p=this._gltf.bufferViews[d.bufferView],m=this._gltf.buffers[p.buffer];let _=new Uint8Array(m.dbuffer,p.byteOffset,p.byteLength),v=new Blob([_],{type:d.mimeType}),y=new ii;await y.loadFromBlob(v),y.name=d.name,this._gltf.resources[d.name]=y}let c=await new js().parse(this.initUrl,this._gltf,this._gltf.scene);return c?(this.data=c.rootNode,c.rootNode):null}async parseJsonAndBuffer(e,t){this._gltf=new Ys,this._gltf={...this._gltf,...e},this._gltf.resources={};let r=this._gltf.buffers[0];if(r.isParsed=!0,r.dbuffer=t,this._gltf.images)for(let n=0;n<this._gltf.images.length;n++){let l=this._gltf.images[n];l.name=l.name||"bufferView_"+l.bufferView.toString();const h=this._gltf.bufferViews[l.bufferView],u=this._gltf.buffers[h.buffer];let c=new Uint8Array(u.dbuffer,h.byteOffset,h.byteLength),f=new Blob([c],{type:l.mimeType}),d=new ii;await d.loadFromBlob(f),d.name=l.name,this._gltf.resources[l.name]=d}let a=await new js().parse(this.initUrl,this._gltf,this._gltf.scene);return a?(this.data=a.rootNode,a.rootNode):null}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseHeader(e){let t=e.pos,r=new du,s=new Uint32Array(e.buffer,t,3);return e.pos+=s.byteLength,r.magic=s[0],r.version=s[1],r.length=s[2],r}parseChunk(e){let t=e.pos,r=new gu,s=new Uint32Array(e.buffer,t,2);t=e.pos+=s.byteLength,r.chunkLength=s[0],r.chunkType=s[1],r.chunkData=new Uint8Array(e.buffer,t,r.chunkLength);const a=new Uint8Array(r.chunkLength);for(let n=0;n<r.chunkLength;n++)a[n]=r.chunkData[n];return r.chunkData=a,e.pos+=r.chunkLength,r}}o(qs,"format","bin");class as{constructor(e=0,t="\0"){o(this,"Type",0),o(this,"Line",0),o(this,"Colume",0),o(this,"Literal",""),this.Type=e,this.Literal=t}isTypeEqual(e){return this.Type==e}isLiteralEqual(e){return this.Literal==e}isBuiltinType(){return this.Type>33&&this.Type<101}isDataType(){return this.Type==1||this.isBuiltinType()}isOperation(){return this.Type>102&&this.Type<127}isAssignOperation(){return this.Type>128&&this.Type<133}get nOperationPriorityLevel(){switch(this.Type){case 26:return 1;case 27:return 1;case 125:return 2;case 110:return 3;case 114:return 3;case 105:return 4;case 106:return 4;case 103:return 5;case 104:return 5;case 115:return 6;case 116:return 6;case 119:return 7;case 120:return 7;case 122:return 7;case 123:return 7;case 121:return 8;case 124:return 8;case 111:return 9;case 113:return 10;case 112:return 11;case 107:return 12;case 109:return 13;case 108:return 14;case 24:return 15;case 126:return 16;case 129:return 16;case 130:return 16;case 131:return 16;case 132:return 16}return 99}}var x=(i=>(i[i.EOF=0]="EOF",i[i.IDENT=1]="IDENT",i[i.VOID=2]="VOID",i[i.CONST=3]="CONST",i[i.LAYOUT=4]="LAYOUT",i[i.PRECISION=5]="PRECISION",i[i.ATTRIBUTE=6]="ATTRIBUTE",i[i.UNIFORM=7]="UNIFORM",i[i.VARYING=8]="VARYING",i[i.INVARIANT=9]="INVARIANT",i[i.IN=10]="IN",i[i.OUT=11]="OUT",i[i.INOUT=12]="INOUT",i[i.IF=13]="IF",i[i.ELSE=14]="ELSE",i[i.FOR=15]="FOR",i[i.WHILE=16]="WHILE",i[i.DO=17]="DO",i[i.BREAK=18]="BREAK",i[i.RETURN=19]="RETURN",i[i.CONTINUE=20]="CONTINUE",i[i.STRUCT=21]="STRUCT",i[i.COMMA=22]="COMMA",i[i.COLON=23]="COLON",i[i.QUEMARK=24]="QUEMARK",i[i.SEMICOLON=25]="SEMICOLON",i[i.LEFTSAMLL=26]="LEFTSAMLL",i[i.RIGHTSAMLL=27]="RIGHTSAMLL",i[i.LEFTMEDI=28]="LEFTMEDI",i[i.RIGHTMEDI=29]="RIGHTMEDI",i[i.LEFTBIG=30]="LEFTBIG",i[i.RIGHTBIG=31]="RIGHTBIG",i[i.LITERAL=32]="LITERAL",i[i.BeginBuiltinType=33]="BeginBuiltinType",i[i.INT=34]="INT",i[i.INT_ARRAY=35]="INT_ARRAY",i[i.UINT=36]="UINT",i[i.UINT_ARRAY=37]="UINT_ARRAY",i[i.BOOL=38]="BOOL",i[i.BOOL_ARRAY=39]="BOOL_ARRAY",i[i.FLOAT=40]="FLOAT",i[i.FLOAT_ARRAY=41]="FLOAT_ARRAY",i[i.DOUBLE=42]="DOUBLE",i[i.DOUBLE_ARRAY=43]="DOUBLE_ARRAY",i[i.VEC2=44]="VEC2",i[i.VEC2_ARRAY=45]="VEC2_ARRAY",i[i.VEC3=46]="VEC3",i[i.VEC3_ARRAY=47]="VEC3_ARRAY",i[i.VEC4=48]="VEC4",i[i.VEC4_ARRAY=49]="VEC4_ARRAY",i[i.BVEC2=50]="BVEC2",i[i.BVEC2_ARRAY=51]="BVEC2_ARRAY",i[i.BVEC3=52]="BVEC3",i[i.BVEC3_ARRAY=53]="BVEC3_ARRAY",i[i.BVEC4=54]="BVEC4",i[i.BVEC4_ARRAY=55]="BVEC4_ARRAY",i[i.IVEC2=56]="IVEC2",i[i.IVEC2_ARRAY=57]="IVEC2_ARRAY",i[i.IVEC3=58]="IVEC3",i[i.IVEC3_ARRAY=59]="IVEC3_ARRAY",i[i.IVEC4=60]="IVEC4",i[i.IVEC4_ARRAY=61]="IVEC4_ARRAY",i[i.UVEC2=62]="UVEC2",i[i.UVEC2_ARRAY=63]="UVEC2_ARRAY",i[i.UVEC3=64]="UVEC3",i[i.UVEC3_ARRAY=65]="UVEC3_ARRAY",i[i.UVEC4=66]="UVEC4",i[i.UVEC4_ARRAY=67]="UVEC4_ARRAY",i[i.MAT2x2=68]="MAT2x2",i[i.MAT2x2_ARRAY=69]="MAT2x2_ARRAY",i[i.MAT2x3=70]="MAT2x3",i[i.MAT2x3_ARRAY=71]="MAT2x3_ARRAY",i[i.MAT2x4=72]="MAT2x4",i[i.MAT2x4_ARRAY=73]="MAT2x4_ARRAY",i[i.MAT3x2=74]="MAT3x2",i[i.MAT3x2_ARRAY=75]="MAT3x2_ARRAY",i[i.MAT3x3=76]="MAT3x3",i[i.MAT3x3_ARRAY=77]="MAT3x3_ARRAY",i[i.MAT3x4=78]="MAT3x4",i[i.MAT3x4_ARRAY=79]="MAT3x4_ARRAY",i[i.MAT4x2=80]="MAT4x2",i[i.MAT4x2_ARRAY=81]="MAT4x2_ARRAY",i[i.MAT4x3=82]="MAT4x3",i[i.MAT4x3_ARRAY=83]="MAT4x3_ARRAY",i[i.MAT4x4=84]="MAT4x4",i[i.MAT4x4_ARRAY=85]="MAT4x4_ARRAY",i[i.SAMPLER=86]="SAMPLER",i[i.SAMPLER_1D=87]="SAMPLER_1D",i[i.SAMPLER_2D=88]="SAMPLER_2D",i[i.SAMPLER_3D=89]="SAMPLER_3D",i[i.SAMPLER_CUBE=90]="SAMPLER_CUBE",i[i.SAMPLER_SHADOW=91]="SAMPLER_SHADOW",i[i.SAMPLER_1D_SHADOW=92]="SAMPLER_1D_SHADOW",i[i.SAMPLER_2D_SHADOW=93]="SAMPLER_2D_SHADOW",i[i.TEXTURE_1D=94]="TEXTURE_1D",i[i.TEXTURE_1D_ARRAY=95]="TEXTURE_1D_ARRAY",i[i.TEXTURE_2D=96]="TEXTURE_2D",i[i.TEXTURE_2D_ARRAY=97]="TEXTURE_2D_ARRAY",i[i.TEXTURE_3D=98]="TEXTURE_3D",i[i.TEXTURE_CUBE=99]="TEXTURE_CUBE",i[i.TEXTURE_CUBE_ARRAY=100]="TEXTURE_CUBE_ARRAY",i[i.EndBuiltinType=101]="EndBuiltinType",i[i.BeginOperation=102]="BeginOperation",i[i.ADD=103]="ADD",i[i.SUB=104]="SUB",i[i.MUL=105]="MUL",i[i.DIV=106]="DIV",i[i.AND=107]="AND",i[i.OR=108]="OR",i[i.XOR=109]="XOR",i[i.NOT=110]="NOT",i[i.BITAND=111]="BITAND",i[i.BITOR=112]="BITOR",i[i.BITXOR=113]="BITXOR",i[i.BITNOT=114]="BITNOT",i[i.BITSHIFT_L=115]="BITSHIFT_L",i[i.BITSHIFT_R=116]="BITSHIFT_R",i[i.INC=117]="INC",i[i.DEC=118]="DEC",i[i.GREATER=119]="GREATER",i[i.GREATEREQUAL=120]="GREATEREQUAL",i[i.EQUAL=121]="EQUAL",i[i.LESS=122]="LESS",i[i.LESSEQUAL=123]="LESSEQUAL",i[i.NOTEQUAL=124]="NOTEQUAL",i[i.DOT=125]="DOT",i[i.ASSIGN=126]="ASSIGN",i[i.EndOperation=127]="EndOperation",i[i.BeginAssignOperation=128]="BeginAssignOperation",i[i.ADDASSIGN=129]="ADDASSIGN",i[i.SUBASSIGN=130]="SUBASSIGN",i[i.MULASSIGN=131]="MULASSIGN",i[i.DIVASSIGN=132]="DIVASSIGN",i[i.EndAssignOperation=133]="EndAssignOperation",i))(x||{});class nr{constructor(e){o(this,"_char"),o(this,"_line"),o(this,"_column"),o(this,"_source"),o(this,"_currPosition"),o(this,"_nextPosition"),this.reset(e)}reset(e){this._char="",this._line=0,this._column=0,this._source=e,this._currPosition=0,this._nextPosition=0}get source(){return this._source}getChar(){return this._char}get currPosition(){return this._currPosition}peekChar(){return this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition]}readChar(){this._char=this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition],this._char!==`
`?this._column++:(this._line++,this._column=0),this._currPosition=this._nextPosition,this._nextPosition++}readCharAndSkipWhitespace(){this.readChar(),this.skipWhitespace()}readIdentifier(){for(var e=this._currPosition;this.isIdentifier(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}isIdentifier(e){var t=e.charCodeAt(0);return 97<=t&&t<=122||65<=t&&t<=90||48<=t&&t<=57||t==95}skipWhitespace(){for(;this.IsWhitespace(this._char);)this.readChar()}IsWhitespace(e){return e===" "||e==="	"||e==="\r"||e===`
`}skipComment(){for(;this._char!==`
`&&this._char!=="\0";)this.readChar();this.skipWhitespace()}skipMultilineComment(){if(!(this._char!=="/"&&this.peekChar()!=="*")){this.readChar(),this.readChar();for(let e=1;e>0&&this._char!=="\0";)if(this.readChar(),this._char==="/"&&this.peekChar()==="*"){e++,this.readChar();continue}else if(this._char==="*"&&this.peekChar()==="/"){e--,this.readChar();continue}this.readChar(),this.readChar(),this.skipWhitespace()}}isDigit(e){var t=e.charCodeAt(0);return 48<=t&&t<=57}readNumber(){for(var e=this._currPosition;this.isDigit(this._char);)this.readChar();if(this._char===".")for(this.readChar();this.isDigit(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}readValue(){return this.isDigit(this._char)?this.readNumber():this.readIdentifier()}readLine(){var e=this._currPosition,t=this._source.indexOf(`
`,this._currPosition);return t==-1&&(t=this._source.length),this._line++,this._column=0,this._currPosition=t,this._nextPosition=t+1,this._source.substring(e,t+1)}}class pu extends nr{constructor(e){super(e.source),o(this,"_tokenPosition",0),o(this,"_tokens",[]),this.parse()}skipToken(e){this._tokenPosition+=e}peekToken(e){return this._tokenPosition+e>=this._tokens.length?new as(x.EOF,"\0"):this._tokens[this._tokenPosition+e]}GetNextToken(){if(this._tokenPosition>=this._tokens.length)return new as(x.EOF,"\0");let e=this._tokens[this._tokenPosition];return this._tokenPosition++,e}get currTokenPosition(){return this._tokenPosition}parse(){this.readChar(),this._tokens=new Array;var e;do e=this.nextToken(),this._tokens.push(e);while(e.Type!=x.EOF)}nextToken(){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/")return this.skipComment(),this.nextToken();if(this.peekChar()==="*")return this.skipMultilineComment(),this.nextToken()}var e=new as;switch(e.Line=this._line,e.Colume=this._column,this._char){case"\0":e.Type=x.EOF,e.Literal="EOF";break;case".":e.Type=x.DOT,e.Literal=".";break;case",":e.Type=x.COMMA,e.Literal=",";break;case":":e.Type=x.COLON,e.Literal=":";break;case"?":e.Type=x.QUEMARK,e.Literal="?";break;case";":e.Type=x.SEMICOLON,e.Literal=";";break;case"(":e.Type=x.LEFTSAMLL,e.Literal="(";break;case")":e.Type=x.RIGHTSAMLL,e.Literal=")";break;case"[":e.Type=x.LEFTMEDI,e.Literal="[";break;case"]":e.Type=x.RIGHTMEDI,e.Literal="]";break;case"{":e.Type=x.LEFTBIG,e.Literal="{";break;case"}":e.Type=x.RIGHTBIG,e.Literal="}";break;case"+":if(this.peekChar()==="+"){this.readChar(),e.Type=x.INC,e.Literal="++";break}else if(this.peekChar()==="="){this.readChar(),e.Type=x.ADDASSIGN,e.Literal="+=";break}e.Type=x.ADD,e.Literal="+";break;case"-":if(this.peekChar()==="-"){this.readChar(),e.Type=x.DEC,e.Literal="--";break}else if(this.peekChar()==="="){this.readChar(),e.Type=x.SUBASSIGN,e.Literal="-=";break}e.Type=x.SUB,e.Literal="-";break;case"*":if(this.peekChar()==="="){this.readChar(),e.Type=x.MULASSIGN,e.Literal="*=";break}e.Type=x.MUL,e.Literal="*";break;case"/":if(this.peekChar()==="="){this.readChar(),e.Type=x.DIVASSIGN,e.Literal="/=";break}e.Type=x.DIV,e.Literal="/";break;case"&":if(this.peekChar()==="&"){this.readChar(),e.Type=x.AND,e.Literal="&&";break}e.Type=x.BITAND,e.Literal="&";break;case"|":if(this.peekChar()==="|"){this.readChar(),e.Type=x.OR,e.Literal="||";break}e.Type=x.BITOR,e.Literal="&";break;case"^":e.Type=x.BITXOR,e.Literal="^";break;case"!":if(this.peekChar()==="="){this.readChar(),e.Type=x.NOTEQUAL,e.Literal="!=";break}e.Type=x.NOT,e.Literal="!";break;case">":if(this.peekChar()==="="){this.readChar(),e.Type=x.GREATEREQUAL,e.Literal=">=";break}else if(this.peekChar()===">"){this.readChar(),e.Type=x.BITSHIFT_R,e.Literal=">>";break}e.Type=x.GREATER,e.Literal=">";break;case"=":if(this.peekChar()==="="){this.readChar(),e.Type=x.EQUAL,e.Literal="==";break}e.Type=x.ASSIGN,e.Literal="=";break;case"<":if(this.peekChar()==="="){this.readChar(),e.Type=x.LESSEQUAL,e.Literal="<=";break}else if(this.peekChar()==="<"){this.readChar(),e.Type=x.BITSHIFT_L,e.Literal="<<";break}e.Type=x.LESS,e.Literal="<";break;default:return this.isDigit(this._char)?this.readDecimal():(e.Literal=this.readIdentifier(),e.Type=this.lookupIdentifier(e.Literal),this.getChar()=="["&&this.peekChar()=="]"&&e.isBuiltinType()&&(e.Type++,e.Literal+="[]",this.readChar(),this.readChar()),e)}return this.readChar(),e}readDecimal(){var e=new as;e.Line=this._line,e.Colume=this._column,e.Type=x.LITERAL;var t=this.readNumber();return this._char==="e"?(e.Literal=t+this._char,this.readChar(),e.Literal+=this._char,this.readChar(),e.Literal+=this.readNumber(),e.Type=x.LITERAL,e):this._char==="u"?(this.readChar(),e.Type=x.LITERAL,e.Literal=t+"u",e):this._char==="f"?(this.readChar(),e.Type=x.LITERAL,e.Literal=t+"f",e):(e.Type=x.LITERAL,e.Literal=t,e)}lookupIdentifier(e){switch(e){case"void":return x.VOID;case"int":return x.INT;case"uint":return x.UINT;case"bool":return x.BOOL;case"true":return x.BOOL;case"false":return x.BOOL;case"float":return x.FLOAT;case"vec2":return x.VEC2;case"vec3":return x.VEC3;case"vec4":return x.VEC4;case"bvec2":return x.BVEC2;case"bvec3":return x.BVEC3;case"bvec4":return x.BVEC4;case"ivec2":return x.IVEC2;case"ivec3":return x.IVEC3;case"ivec4":return x.IVEC4;case"uvec2":return x.UVEC2;case"uvec3":return x.UVEC3;case"uvec4":return x.UVEC4;case"mat2":return x.MAT2x2;case"mat2x2":return x.MAT2x2;case"mat2x3":return x.MAT2x3;case"mat2x4":return x.MAT2x4;case"mat3":return x.MAT3x3;case"mat3x2":return x.MAT3x2;case"mat3x3":return x.MAT3x3;case"mat3x4":return x.MAT3x4;case"mat4":return x.MAT4x4;case"mat4x2":return x.MAT4x2;case"mat4x3":return x.MAT4x3;case"mat4x4":return x.MAT4x4;case"sampler":return x.SAMPLER;case"sampler1D":return x.SAMPLER_1D;case"sampler2D":return x.SAMPLER_2D;case"sampler3D":return x.SAMPLER_3D;case"samplerCube":return x.SAMPLER_CUBE;case"samplerShadow":return x.SAMPLER_SHADOW;case"sampler1DShadow":return x.SAMPLER_1D_SHADOW;case"sampler2DShadow":return x.SAMPLER_2D_SHADOW;case"texture1D":return x.TEXTURE_1D;case"texture2D":return x.TEXTURE_2D;case"texture3D":return x.TEXTURE_3D;case"textureCube":return x.TEXTURE_CUBE;case"texture1DArray":return x.TEXTURE_1D_ARRAY;case"texture2DArray":return x.TEXTURE_2D_ARRAY;case"textureCubeArray":return x.TEXTURE_CUBE_ARRAY;case"const":return x.CONST;case"layout":return x.LAYOUT;case"precision":return x.PRECISION;case"attribute":return x.ATTRIBUTE;case"uniform":return x.UNIFORM;case"varying":return x.VARYING;case"invariant":return x.INVARIANT;case"in":return x.IN;case"out":return x.OUT;case"inout":return x.INOUT;case"if":return x.IF;case"else":return x.ELSE;case"for":return x.FOR;case"while":return x.WHILE;case"do":return x.DO;case"break":return x.BREAK;case"return":return x.RETURN;case"continue":return x.CONTINUE;case"struct":return x.STRUCT}return x.IDENT}}class Fg{constructor(){o(this,"name",""),o(this,"value",""),o(this,"args",[])}}class mu extends nr{constructor(e){super(e),o(this,"_result"),o(this,"_skipLine"),o(this,"_definitionTables"),this._result="",this._skipLine=!1,this._definitionTables=new Map,this.parse()}parse(){for(this.readChar();this._char!=="\0";){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/"){this.skipComment();continue}if(this.peekChar()==="*"){this.skipMultilineComment();continue}}if(this._char==="#"){this.readCharAndSkipWhitespace();var e=this.readIdentifier();switch(e){case"version":this.readLine().trim();break;case"define":this.readCharAndSkipWhitespace();var t=this.readIdentifier();if(this.getChar()==="("){let l=new Fg;if(this.readCharAndSkipWhitespace(),this.getChar()!==")")do{var r=this.readIdentifier();if(l.args.push(r),this.skipWhitespace(),this.getChar()===","){this.readCharAndSkipWhitespace();continue}}while(this.getChar()!==")");this.readCharAndSkipWhitespace(),l.name=t,l.value=this.readLine().trim(),this._definitionTables.set(t,l),this.readCharAndSkipWhitespace()}else{let l=this.readLine().trim();l[0]=="="&&(l=l.substring(1)),this._definitionTables.set(t,l)}break;case"if":let n=this.readLine().trim();if(n=="0"||n=="false"){this._skipLine=!0;break}if(this._definitionTables.has(n)&&(n=this._definitionTables.get(n),n=="0"||n=="false")){this._skipLine=!0;break}break;case"ifdef":this.readCharAndSkipWhitespace();var s=this.readIdentifier();this._skipLine=!this._definitionTables.has(s);break;case"else":this._skipLine=!this._skipLine;break;case"endif":this._skipLine=!1;break;default:throw"Unknown preprocessing command:"+e}}else{var a=this.readLine();if(!this._skipLine){for(let n of this._definitionTables.keys()){let l=a.indexOf(n);if(l!=-1){let h=this._definitionTables.get(n);if(typeof h=="string")a=a.replace(n,h);else{let u=h,c=new nr(a.substring(l+n.length));if(c.readCharAndSkipWhitespace(),c.getChar()==="("){c.readCharAndSkipWhitespace();for(let m=1;c.getChar()!=="\0"&&m>0;){switch(c.getChar()){case"(":m++;break;case")":m--;break}c.readCharAndSkipWhitespace()}}let f=l,d=f+n.length+c.currPosition,p=a.substring(f,d).trim();if(u.args.length>0){let m=[],_=p.substring(p.indexOf("(")+1,p.lastIndexOf(")")).trim();_.length>0&&(m=this.parseArgs(_));let v=u.value.substring(u.value.indexOf("("));for(let y=0;y<u.args.length;y++)v=v.replace(u.args[y],m[y]);v=u.value.substring(0,u.value.indexOf("("))+v,a=a.replace(p,v)}else a=a.replace(p,u.value)}}}this._result+=a}this.readChar()}}}get source(){return this._result}parseArgs(e){let t=[],r=0,s=new nr(e),a=s.currPosition;if(s.readCharAndSkipWhitespace(),s.getChar()!=="\0")for(s.readCharAndSkipWhitespace();s.getChar()!=="\0";){switch(s.getChar()){case"(":r++;break;case")":r--;break;case",":if(r==0){let n=e.substring(a,s.currPosition);t.push(n),a=s.currPosition+1}break}s.readCharAndSkipWhitespace()}if(a<s.currPosition){let n=e.substring(a,s.currPosition);t.push(n)}return t}}class Au{constructor(e){o(this,"result"),o(this,"ASTRoot"),o(this,"_syntax"),this.result="",this._syntax=e,this.ASTRoot=e.ASTRoot}generateWGSL(){let e=new Uo;var t=new yu;let r=[],s=[],a=[];for(let c of this.ASTRoot.nodes)if(c instanceof vs)if(c.scope=="in")if(c.nodes[0]instanceof Te){e.layoutsIn.push(c);let f=new No;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.locationID=Number.parseInt(c.qualifier.get("location")),t.inputAttribute.push(f)}else if(c.qualifier.has("local_size_x"))e.workGroupSize=c;else throw"not impl";else if(c.scope=="out")if(e.layoutsOut.push(c),c.nodes[0]instanceof Te){let f=new No;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.locationID=Number.parseInt(c.qualifier.get("location")),t.outputAttribute.push(f)}else throw"not impl";else if(c.scope=="uniform")if(s.push(c),c.nodes[0]instanceof Te){let f=new Oo;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.setID=Number.parseInt(c.qualifier.get("set")),f.bindingID=Number.parseInt(c.qualifier.get("binding")),t.uniformInfo.push(f)}else if(c.nodes[0]instanceof oi){let f=new Oo;f.name="unif"+t.uniformInfo.length.toString(),f.type=c.nodes[0].name,f.setID=Number.parseInt(c.qualifier.get("set")),f.bindingID=Number.parseInt(c.qualifier.get("binding")),t.uniformInfo.push(f)}else throw"not impl";else c.scope=="buffer"&&r.push(c);else a.push(c);e.stage="fragment";let n=0,l=new nr(""),h=this._syntax.lexer.source,u=new Map;for(;(n=h.indexOf("gl_",n))!=-1;){l.reset(h.substring(n,n+32)),l.readChar();let c=l.readIdentifier();if(n+=c.length,!u.has(c))switch(u.set(c,c),c){case"gl_InstanceID":e.stage="vertex",e.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");break;case"gl_Position":e.stage="vertex",e.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"),e.addIdentifier("gl_Position","stout.gl_Position");break;case"gl_VertexIndex":e.stage="vertex",e.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");break;case"gl_FrontFacing":e.stage="fragment",e.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");break;case"gl_FragDepth":e.stage="fragment",e.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"),e.addIdentifier("gl_FragDepth","stout.gl_FragDepth");break;case"gl_WorkGroupID":e.stage="compute",e.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");break;case"gl_NumWorkGroups":e.stage="compute",e.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");break;case"gl_LocalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");break;case"gl_LocalInvocationIndex":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");break;case"gl_GlobalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");break;default:throw"Unprocessed built-in variables: "+c}}for(let c of s)c.nodes[0]instanceof oi&&(t.sourceCode+=c.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let c of s)t.sourceCode+=c.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let c of r)c.nodes[0]instanceof oi&&(t.sourceCode+=c.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let c of r)t.sourceCode+=c.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let c of a)t.sourceCode+=c.formatToWGSL(e,0),c instanceof Te&&(t.sourceCode+=`;\r
`);return t}}class Uo{constructor(e){o(this,"_stage","fragment"),o(this,"_builtinIn",[]),o(this,"_builtinOut",[]),o(this,"_layoutsIn",[]),o(this,"_layoutsOut",[]),o(this,"_layoutUniformCount",0),o(this,"_workGroupSize"),o(this,"_parentContext"),o(this,"_identifierEnv",new Map),this._parentContext=e}get stage(){return this.parentContext!=null?this.parentContext.stage:this._stage}set stage(e){this.parentContext!=null&&(this.parentContext.stage=e),this._stage=e}get builtinIn(){return this.parentContext!=null?this.parentContext.builtinIn:this._builtinIn}get builtinOut(){return this.parentContext!=null?this.parentContext.builtinOut:this._builtinOut}get layoutsIn(){return this.parentContext!=null?this.parentContext.layoutsIn:this._layoutsIn}get layoutsOut(){return this.parentContext!=null?this.parentContext.layoutsOut:this._layoutsOut}get layoutUniformCount(){return this.parentContext!=null?this.parentContext.layoutUniformCount:this._layoutUniformCount}set layoutUniformCount(e){if(this.parentContext!=null){this.parentContext.layoutUniformCount=e;return}this._layoutUniformCount=e}get workGroupSize(){return this.parentContext!=null?this.parentContext.workGroupSize:this._workGroupSize}set workGroupSize(e){this.parentContext!=null&&(this.parentContext.workGroupSize=e),this._workGroupSize=e}get parentContext(){return this._parentContext}findIdentifier(e){return this._identifierEnv.has(e)?this._identifierEnv.get(e):this._parentContext!=null?this._parentContext.findIdentifier(e):e}addIdentifier(e,t){this._identifierEnv.set(e,t)}hasIdentifier(e){return this._identifierEnv.has(e)}}class me{constructor(){o(this,"nodes",[])}addNode(e){this.nodes.push(e)}formatToWGSL(e,t){return""}}class oi extends me{constructor(e){super(),o(this,"name",""),o(this,"fields",[]),this.name=e}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTBIG){let t=new oi(e.peekToken(0).Literal);for(e.skipToken(2);e.peekToken(0).Type!=x.RIGHTBIG;){let r=Te.parse(e);t.fields.push(r)}return e.peekToken(0).Type==x.RIGHTBIG&&e.skipToken(1),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t}throw"Error parsing structure: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+"struct "+this.name+` {\r
`;for(let a of this.fields)a.arraySize.nodes.length<=0?r+=s+"  "+a.name+": "+St(a.type)+`,\r
`:a.arraySize.nodes[0]instanceof ni?r+=s+"  "+a.name+": array<"+St(a.type)+", "+a.arraySize.nodes[0].value+`>,\r
`:r+=s+"  "+a.name+": array<"+St(a.type)+", "+a.arraySize.nodes[0].formatToWGSL(e,0)+`>,\r
`;return r+=s+`};\r
`,r}}class _a extends me{constructor(e,t,r,s){super(),o(this,"name"),o(this,"args"),o(this,"body"),o(this,"returnType"),this.name=e,this.args=t,this.body=r,this.returnType=s}static parse(e){if((e.peekToken(0).isBuiltinType()||e.peekToken(0).Type==x.VOID)&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.LEFTSAMLL){let t=e.peekToken(0).Literal,r=e.peekToken(1).Literal;e.skipToken(2);let s=new Array;if(e.peekToken(0).Type!=x.LEFTSAMLL)throw"Error parsing function parameter list: Unexpected character";for(e.skipToken(1);e.peekToken(0).Type!=x.EOF;){if(e.peekToken(0).Type==x.RIGHTSAMLL){e.skipToken(1);break}(e.peekToken(0).Type==x.INOUT||e.peekToken(0).Type==x.IN||e.peekToken(0).Type==x.OUT)&&e.skipToken(1);let n=Te.parse(e);s.push(n),e.peekToken(0).Type==x.COMMA&&e.skipToken(1)}let a=Gt.parse(e);return new _a(r,s,a,t)}throw"Error parsing function: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t),a,n=e.layoutsOut.length>0||e.builtinOut.length>0;switch(e.stage){case"compute":a="ComputeOutput";break;case"vertex":a="VertexOutput";break;case"fragment":a="FragmentOutput";break;default:a="StructOutput";break}if(this.name=="main"&&n){r+="struct "+a+` {\r
`;for(let c of e.layoutsOut)if(c.nodes[0]instanceof Te){let f=c.nodes[0];c.qualifier.size==1&&c.qualifier.has("location")&&(r+="  @location("+c.qualifier.get("location")+") "),r+=f.name+": "+St(f.type)+`,\r
`,e.addIdentifier(f.name,"stout."+f.name)}let u=e.builtinOut;for(let c of u)r+="  "+c+`,\r
`;r+=`};\r
\r
`}let l="";if(this.name=="main"&&(e.workGroupSize!=null?l+="@"+e.stage+" "+e.workGroupSize.formatToWGSL(e,0)+` \r
`:l+="@"+e.stage+`\r
`),e=new Uo(e),l+=s+"fn "+this.name+"(",this.name!="main"){for(let u=0;u<this.args.length;u++){let c=this.args[u];u>0&&(l+=", "),l+=c.name+": "+St(c.type),e.addIdentifier(c.name,c.name)}l+=") -> "+St(this.returnType)}else{let u=e.layoutsIn;for(let f=0;f<u.length;f++){let d=u[f];if(f>0?l+=`,\r
    `:l+=`\r
    `,d.nodes[0]instanceof Te){let p=d.nodes[0];d.qualifier.size==1&&d.qualifier.has("location")&&(l+="@location("+d.qualifier.get("location")+") "),l+=p.name+": "+St(p.type),e.addIdentifier(p.name,p.name)}}u.length>0&&(l+=`,\r
    `);let c=e.builtinIn;for(let f of c)l+=f+`,\r
    `;n?l+=") -> "+a:l+=") "}let h="";this.name=="main"&&n&&(h+="    var stout: "+a+` ;\r
`);for(let u of this.body.nodes)h+=u.formatToWGSL(e,t+1),!(u instanceof Gi)&&!(u instanceof Xi)&&!(u instanceof Yi)&&(h+=`;\r
`);return this.name=="main"&&n&&(h+=`    return stout;\r
`),r+=l+` {\r
`,r+=h,r+=s+`}\r
`,r+=`\r
`,r}}class xa extends me{constructor(){super(),o(this,"args",[])}static parse(e){if(e.peekToken(0).Type==x.LEFTSAMLL){e.skipToken(1);let t=new xa;for(;e.peekToken(0).Type!=x.EOF;){if(e.peekToken(0).Type==x.RIGHTSAMLL){e.skipToken(1);break}let r=ie.parse(e);t.args.push(r),e.peekToken(0).Type==x.COMMA&&e.skipToken(1)}return t}throw"Error parsing function argument table: Unexpected character"}}class Hi extends me{constructor(e,t){super(),o(this,"name"),o(this,"args"),this.name=e,this.args=t}static parse(e){if(e.peekToken(0).isDataType()&&e.peekToken(1).Type==x.LEFTSAMLL){let t=e.peekToken(0).Literal;e.skipToken(1);let r=xa.parse(e);return new Hi(t,r)}throw"Error parsing function argument table: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);if(this.name=="texture"&&this.args.args[0].nodes[0]instanceof Hi){let a=this.args.args[0].nodes[0];if(a.name=="sampler2D"){r+=s+"textureSample(";for(let n=0;n<a.args.args.length;n++){let l=a.args.args[n];n>0&&(r+=", "),r+=l.formatToWGSL(e,0)}for(let n=1;n<this.args.args.length;n++){let l=this.args.args[n];n>0&&(r+=", "),r+=l.formatToWGSL(e,0)}return r+=")",r}}r+=s+St(this.name)+"(";for(let a=0;a<this.args.args.length;a++){let n=this.args.args[a];a>0&&(r+=", "),r+=n.formatToWGSL(e,0)}return r+=")",r}}class Te extends me{constructor(e,t,r=new ie){super(),o(this,"type"),o(this,"name"),o(this,"arraySize"),o(this,"hasIn"),o(this,"hasOut"),o(this,"hasConst"),this.type=e,this.name=t,this.hasIn=!1,this.hasOut=!1,this.hasConst=!1,this.arraySize=r}static parse(e){let t=new Te("",""),r=e.peekToken(0);if(r.Type==x.CONST)e.skipToken(1),t.hasConst=!0;else if(r.Type==x.IN)e.skipToken(1),t.hasIn=!0;else if(r.Type==x.OUT)e.skipToken(1),t.hasOut=!0;else if(r.Type==x.INOUT)e.skipToken(1),t.hasIn=!0,t.hasOut=!0;else if(!r.isDataType())throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.isDataType()&&e.peekToken(1).Type==x.LEFTMEDI){if(t.type=r.Literal,e.skipToken(2),t.arraySize=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),e.peekToken(0).Type!=x.IDENT)throw"Unexpected";t.name=e.peekToken(0).Literal,e.skipToken(1)}else if(r.isDataType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.LEFTMEDI)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(3),e.peekToken(0).Type==x.RIGHTMEDI?e.skipToken(1):(t.arraySize=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1));else if(r.isDataType()&&e.peekToken(1).Type==x.IDENT)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(2);else throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.Type==x.SEMICOLON)return e.skipToken(1),t;if(r.Type==x.RIGHTSAMLL)return t;if(r.Type==x.ASSIGN){let s=e.peekToken(0);e.skipToken(1);let a=new ri(t.name),n=ie.parse(e);return e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t.addNode(new Ai(s,a,n)),t}else if(r.Type==x.COMMA){for(;e.peekToken(0).Type==x.COMMA&&e.peekToken(1).Type==x.IDENT;){let s=new Te(t.type,e.peekToken(1).Literal);t.addNode(s),e.skipToken(2),e.peekToken(0).Type==x.ASSIGN&&(e.skipToken(-1),s.addNode(ie.parse(e)))}return t}throw"Error parsing declaration expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);if(this.hasConst?r+=s+"let ":r+=s+"var ",e.addIdentifier(this.name,this.name),this.arraySize.nodes.length<=0?r+=this.name+": "+St(this.type):this.arraySize.nodes[0]instanceof ni?r+=this.name+": array<"+St(this.type)+", "+this.arraySize.nodes[0].value+">":r+=this.name+": array<"+St(this.type)+", "+this.arraySize.nodes[0].formatToWGSL(e,0)+">",this.nodes.length>0&&this.nodes[0]instanceof Ai)r+=" = "+this.nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof ie&&this.nodes[0].nodes[0]instanceof Ai)r+=" = "+this.nodes[0].nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof Te){r+=`;\r
`;for(let a of this.nodes)r+=a.formatToWGSL(e,t)+`;\r
`}else r+=`;\r
`;return r}}class Yi extends me{constructor(e,t,r,s){super(),o(this,"expression1"),o(this,"condition"),o(this,"expression2"),o(this,"loopBody"),this.expression1=e,this.condition=t,this.expression2=r,this.loopBody=s}static parse(e){if(e.peekToken(0).Type==x.FOR&&e.peekToken(1).Type==x.LEFTSAMLL){e.skipToken(2);let t;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),t=new ie):e.peekToken(0).isDataType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.ASSIGN?(t=new Te(e.peekToken(0).Literal,e.peekToken(1).Literal),e.skipToken(1),t.addNode(ie.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1)):(t=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1));let r;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),r=new ie):(r=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1));let s;e.peekToken(0).Type==x.SEMICOLON?(e.skipToken(1),s=new ie):(s=ie.parse(e),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1)),e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1);let a;return e.peekToken(0).Type==x.LEFTBIG?a=Gt.parse(e):a=new Gt,new Yi(t,r,s,a)}throw"Error parsing for loop: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+"for (",r+=this.expression1.formatToWGSL(e,0)+"; ",r+=this.condition.formatToWGSL(e,0)+"; ",r+=this.expression2.formatToWGSL(e,0)+")",r+=` { \r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,t+1),!(a instanceof Gi)&&!(a instanceof Xi)&&!(a instanceof Yi)&&(r+=`;\r
`);return r+=s+`} \r
`,r}}class Xi extends me{constructor(e,t){super(),o(this,"conditionExpr"),o(this,"loopBody"),this.conditionExpr=e,this.loopBody=t}static parse(e){if(e.peekToken(0).Type==x.WHILE){e.skipToken(1),e.peekToken(0).Type==x.LEFTSAMLL&&e.skipToken(1);let t=ie.parse(e);e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1);let r=Gt.parse(e);return new Xi(t,r)}throw"Error parsing while loop: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+`loop {\r
`,r+=s+"    if ("+this.conditionExpr.formatToWGSL(e,0)+`) { break; }\r
\r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,t+1),!(a instanceof Gi)&&!(a instanceof Xi)&&!(a instanceof Yi)&&(r+=`;\r
`);return r+=s+`}\r
`,r}}class kg extends me{constructor(){super()}}class Gi extends me{constructor(e,t,r){super(),o(this,"conditionExpr"),o(this,"trueBranch"),o(this,"falseBranch"),this.conditionExpr=e,this.trueBranch=t,this.falseBranch=r}static parse(e){if(e.peekToken(0).Type==x.IF){e.skipToken(1),e.peekToken(0).Type==x.LEFTSAMLL&&e.skipToken(1);let t=ie.parse(e),r,s=new Gt;if(e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1),e.peekToken(0).Type==x.LEFTBIG?r=Gt.parse(e):(r=new Gt,e.peekToken(0).Type==x.RETURN?r.addNode(_s.parse(e)):r.addNode(ie.parse(e))),e.peekToken(0).Type==x.ELSE)if(e.skipToken(1),e.peekToken(0).Type==x.LEFTBIG)s=Gt.parse(e);else throw"not impl";return new Gi(t,r,s)}throw"Error parsing IF branch statement: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);r+=s+"if ("+this.conditionExpr.formatToWGSL(e,0)+`) {\r
`;for(let a of this.trueBranch.nodes)r+=a.formatToWGSL(e,t+1)+`;\r
`;if(this.falseBranch.nodes.length>0){r+=s+`} else {\r
`;for(let a of this.falseBranch.nodes)r+=a.formatToWGSL(e,t+1)+`;\r
`}return r+=s+`}\r
`,r}}class ie extends me{constructor(){super()}static parse(e){let t=new Array,r=new Array,s=0;for(;e.peekToken(0).Type!=x.EOF;){let a=e.peekToken(0);if(a.Type==x.SEMICOLON||a.Type==x.RIGHTMEDI||a.Type==x.COMMA||a.Type==x.COLON||a.Type==x.RIGHTBIG)break;if(a.isOperation()){if(a.isOperation()){if(a.Type==x.INC||a.Type==x.DEC){let n=a;e.skipToken(1);let l=ie.parse(e);r.push(new lr(n,void 0,l));continue}else if(t.length>0){if(t[t.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel)ie.unionOperation(t,r);else if(t.length>0&&t[t.length-1].Literal=="-"){let l=t.pop(),h=r.pop();r.push(new lr(l,void 0,h))}}t.push(a),e.skipToken(1)}}else if(a.Type==x.LITERAL){r.push(new ni(a.Literal)),e.skipToken(1);continue}else if(a.Type==x.LEFTSAMLL){s++,t.push(a),e.skipToken(1);continue}else if(a.Type==x.RIGHTSAMLL){if(s<=0)break;for(s--;ie.unionOperation(t,r););if(t[t.length-1].Type==x.LEFTSAMLL){t.pop();let n=new _u;n.addNode(r.pop()),r.push(n)}e.skipToken(1);continue}else if(a.Type==x.IDENT){if(e.peekToken(1).Type==x.INC||e.peekToken(1).Type==x.DEC){let n=e.peekToken(1),l=new ri(a.Literal);r.push(new lr(n,l,void 0)),e.skipToken(2);continue}else if(e.peekToken(1).Type==x.LEFTSAMLL){r.push(Hi.parse(e));continue}else if(e.peekToken(1).Type==x.DOT){r.push(xs.parse(e));continue}else if(e.peekToken(1).Type==x.LEFTMEDI){r.push(Wi.parse(e));continue}r.push(new ri(a.Literal)),e.skipToken(1);continue}else{if(a.isBuiltinType()&&e.peekToken(1).Type==x.LEFTSAMLL){r.push(Hi.parse(e));continue}if(a.isAssignOperation()){let n=a;e.skipToken(1);let l=r.pop(),h=ie.parse(e);r.push(new Ai(n,l,h));continue}if(a.Type==x.LEFTBIG&&(e.peekToken(1).Type==x.LITERAL||e.peekToken(1).Type==x.SUB&&e.peekToken(2).Type==x.LITERAL)){r.push(Is.parse(e));continue}if(a.Type==x.QUEMARK){t.length>0&&t[t.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel&&ie.unionOperation(t,r),e.skipToken(1);let n=r.pop(),l=ie.parse(e);e.peekToken(0).Type==x.COLON&&e.skipToken(1);let h=ie.parse(e);if(r.push(new xu(n,l,h)),e.peekToken(-1).Type==x.SEMICOLON)break;continue}if(a.Type==x.LEFTMEDI){e.skipToken(1);let n=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1);let l=r.pop();r.push(new Wi(l,n));continue}throw"An unexpected character"}}for(;t.length>0&&ie.unionOperation(t,r););if(t.length<=0&&r.length==1){let a=new ie;return a.addNode(r.pop()),a}throw"Error parsing expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){return this.nodes[0].formatToWGSL(e,t)}static unionOperation(e,t){if(e.length<0||t.length<2){if(e.length>0&&e[e.length-1].Literal=="-"){let r=e.pop(),s=t.pop();return t.push(new lr(r,void 0,s)),!0}return!1}if(e[e.length-1].isOperation()){let r=t.pop(),s=e.pop(),a=t.pop();return s.Type==x.DOT?t.push(new xs(a,r)):t.push(new Ai(s,a,r)),!0}return!1}}class _u extends me{constructor(){super()}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+"("+this.nodes[0].formatToWGSL(e,0)+")"}}class ri extends me{constructor(e){super(),o(this,"name"),this.name=e}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+e.findIdentifier(this.name)}}class ni extends me{constructor(e){super(),o(this,"value"),this.value=e}static parse(e){let t=e.peekToken(0);if(t.Type==x.SUB&&e.peekToken(1).Type==x.LITERAL){let r=new ni("-"+e.peekToken(1).Literal);return e.skipToken(2),r}else if(t.Type==x.LITERAL){let r=new ni(t.Literal);return e.skipToken(1),r}throw"Error parsing literal constants: Unexpected characters("+t.Literal+")"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.value}}class Is extends ni{constructor(e){super(""),o(this,"arrayValue"),this.arrayValue=e}static parse(e){if(e.peekToken(0).Type==x.LEFTBIG&&e.peekToken(1).Type==x.LITERAL||e.peekToken(0).Type==x.LEFTBIG&&e.peekToken(1).Type==x.SUB&&e.peekToken(2).Type==x.LITERAL){e.skipToken(1);let t=[];for(;e.peekToken(0).Type!=x.RIGHTBIG;){if(e.peekToken(0).Type==x.LEFTSAMLL){t.push(Is.parse(e));continue}if(t.push(ni.parse(e)),e.peekToken(0).Type==x.COMMA){e.skipToken(1);continue}else if(e.peekToken(0).Type==x.RIGHTBIG){e.skipToken(1);break}else throw"Error parsing array constants: Unexpected characters"}return new Is(t)}throw"Error parsing array constants: Unexpected characters"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);this.arrayValue[0].value.includes(".")?r+=s+"array<f32, "+this.arrayValue.length.toString()+">(":r+=s+"array<i32, "+this.arrayValue.length.toString()+">(";for(let a=0;a<this.arrayValue.length;a++)a>0&&(r+=", "),r+=this.arrayValue[a].formatToWGSL(e,0);return r+=")",r}}class zg extends me{constructor(){super()}}class Gg extends me{constructor(){super()}}class va extends me{constructor(){super()}static parse(e){if(e.peekToken(0).Type==x.CONTINUE&&e.peekToken(1).Type==x.SEMICOLON)return e.skipToken(2),new va;throw"Error parsing continue: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);return r+=s+"continue",r}}class _s extends me{constructor(e){super(),o(this,"value"),this.value=e}static parse(e){if(e.peekToken(0).Type==x.RETURN){e.skipToken(1);let t=ie.parse(e);return e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),new _s(t)}throw"Error parsing return expression: Unexpected character"}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);return r+=s+"return "+this.value.formatToWGSL(e,0),r}}class lr extends me{constructor(e,t,r){super(),o(this,"op"),o(this,"leftValue"),o(this,"rightValue"),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);if(this.op.Literal=="++"||this.op.Literal=="--")if(this.leftValue!=null){let a=this.leftValue.formatToWGSL(e,0);r+=s+a+" = "+a+" "+this.op.Literal[0]+" 1"}else{let a=this.rightValue.formatToWGSL(e,0);r+=s+a+" = "+a+" "+this.op.Literal[0]+" 1"}else this.leftValue!=null?r+=s+this.leftValue.formatToWGSL(e,0)+this.op.Literal:r+=s+this.op.Literal+this.rightValue.formatToWGSL(e,0);return r}}class Ai extends me{constructor(e,t,r){super(),o(this,"op"),o(this,"leftValue"),o(this,"rightValue"),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",s=t<=0?"":"    ".repeat(t);return r+=s+this.leftValue.formatToWGSL(e,0)+" "+this.op.Literal+" "+this.rightValue.formatToWGSL(e,0),r}}class xu extends me{constructor(e,t,r){super(),o(this,"condition"),o(this,"expression1"),o(this,"expression2"),this.condition=e,this.expression1=t,this.expression2=r}static parse(e){throw"Error parsing ternary operation expression: Unexpected character"}formatToWGSL(e,t){return""}}class xs extends me{constructor(e,t){super(),o(this,"leftValue"),o(this,"rightValue"),this.leftValue=e,this.rightValue=t}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.DOT&&e.peekToken(2).Type==x.IDENT){let t=new ri(e.peekToken(0).Literal),r=new ri(e.peekToken(2).Literal);return e.skipToken(3),new xs(t,r)}throw"Error parsing selection expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"."+this.rightValue.formatToWGSL(e,0)}}class Wi extends me{constructor(e,t){super(),o(this,"leftValue"),o(this,"indexValue"),this.leftValue=e,this.indexValue=t}static parse(e){if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTMEDI){let t=new ri(e.peekToken(0).Literal);e.skipToken(2);let r=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1);let s=new Wi(t,r);for(;e.peekToken(0).Type==x.LEFTMEDI;)e.skipToken(1),r=ie.parse(e),e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),s=new Wi(s,r);return s}throw"Error parsing index expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"["+this.indexValue.formatToWGSL(e,0)+"]"}}class Gt extends me{constructor(){super()}static parse(e){if(e.peekToken(0).Type==x.LEFTBIG){e.skipToken(1);let t=new Gt;for(let r=1;r>0&&e.peekToken(0).Type!=x.EOF;){let s=e.peekToken(0);if(s.Type==x.LEFTBIG){r++,e.skipToken(1);continue}if(s.Type==x.RIGHTBIG){r--,e.skipToken(1);continue}if(s.Type==x.SEMICOLON){e.skipToken(1);continue}if(s.isDataType()&&e.peekToken(1).Type==x.IDENT){t.addNode(Te.parse(e));continue}if(s.Type==x.CONST&&e.peekToken(1).isDataType()&&e.peekToken(2).Type==x.IDENT){t.addNode(Te.parse(e));continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.ASSIGN){t.addNode(ie.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1);continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.LEFTMEDI){let a=Wi.parse(e);if(e.peekToken(0).Type==x.ASSIGN){let n=e.peekToken(0);e.skipToken(1);let l=ie.parse(e);e.peekToken(0).Type==x.RIGHTMEDI&&e.skipToken(1),t.addNode(new Ai(n,a,l));continue}t.addNode(a);continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.DOT){let a=ie.parse(e);t.addNode(a);continue}else if(s.Type==x.IDENT&&e.peekToken(1).isAssignOperation()){let a=e.peekToken(1),n=new ri(s.Literal);e.skipToken(2);let l=ie.parse(e);e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t.addNode(new Ai(a,n,l));continue}else if(s.Type==x.IDENT&&(e.peekToken(1).Type==x.INC||e.peekToken(1).Type==x.DEC)&&e.peekToken(2).Type==x.SEMICOLON){let a=e.peekToken(1);t.addNode(new lr(a,new ri(s.Literal),void 0)),e.skipToken(3);continue}else if(s.Type==x.RETURN){t.addNode(_s.parse(e));continue}else if(s.Type==x.CONTINUE){t.addNode(va.parse(e));continue}else if(s.Type==x.WHILE){t.addNode(Xi.parse(e));continue}else if(s.Type==x.FOR){t.addNode(Yi.parse(e));continue}else if(s.Type==x.IF){t.addNode(Gi.parse(e));continue}else if(s.Type==x.IDENT&&e.peekToken(1).Type==x.LEFTSAMLL){t.addNode(Hi.parse(e)),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(0);continue}throw"Error parsing block: Unexpected symbol("+s.Literal+")"}return t}throw"Error parsing block: Unexpected symbol"}}class ya extends me{constructor(e,t){super(),o(this,"type"),o(this,"qualifier"),this.type=t,this.qualifier=e}static parse(e){if(e.peekToken(0).Type==x.PRECISION&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).isBuiltinType()){let t=new ya(e.peekToken(1).Literal,e.peekToken(2).Literal);return e.skipToken(3),e.peekToken(0).Type==x.SEMICOLON&&e.skipToken(1),t}throw"Error parsing precision qualifier: Unexpected character"}formatToWGSL(e,t){return""}}class vs extends me{constructor(){super(),o(this,"scope",""),o(this,"qualifier",new Map)}addQualifier(e,t=""){this.qualifier.set(e,t)}static parse(e){if(e.peekToken(0).Type==x.LAYOUT&&e.peekToken(1).Type==x.LEFTSAMLL){let t=new vs;e.skipToken(2);do if(e.peekToken(0).Type==x.IDENT){if(e.peekToken(1).Type==x.ASSIGN&&e.peekToken(2).Type==x.LITERAL){let s=e.peekToken(0).Literal,a=e.peekToken(2).Literal;if(t.addQualifier(s,a),e.skipToken(3),e.peekToken(0).Type==x.COMMA){e.skipToken(1);continue}let n=e.peekToken(0);n.Line=0}else if(e.peekToken(1).Type==x.RIGHTSAMLL){let s=e.peekToken(0).Literal;t.addQualifier(s,""),e.skipToken(1);break}else if(e.peekToken(1).Type==x.COMMA){let s=e.peekToken(0).Literal;t.addQualifier(s,""),e.skipToken(2);continue}}while(e.peekToken(0).Type!=x.RIGHTSAMLL);if(e.peekToken(0).Type==x.RIGHTSAMLL&&e.skipToken(1),t.scope=e.peekToken(0).Literal,e.skipToken(1),e.peekToken(0).Type==x.SEMICOLON)return e.skipToken(1),t;if(e.peekToken(0).isBuiltinType()&&e.peekToken(1).Type==x.IDENT&&e.peekToken(2).Type==x.SEMICOLON){let r=new Te(e.peekToken(0).Literal,e.peekToken(1).Literal);return t.addNode(r),e.skipToken(3),t}else if(e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.LEFTBIG){let r=oi.parse(e);return t.addNode(r),e.peekToken(0).Type==x.IDENT&&e.peekToken(1).Type==x.SEMICOLON&&(r.addNode(new Te(r.name,e.peekToken(0).Literal)),e.skipToken(2)),t}else throw"Error parsing layout qualifier type: Unexpected symbol("+e.peekToken(0).Literal+")"}throw"Error parsing layout qualifier: Unexpected symbol"}formatToWGSL(e,t){let r="";if(this.qualifier.size==1&&this.qualifier.has("location"))r+="@location("+this.qualifier.get("location")+") ";else if(this.qualifier.size==2&&this.qualifier.has("set")&&this.qualifier.has("binding"))r+="@group("+this.qualifier.get("set")+") @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size>=1&&this.qualifier.has("binding"))r+="@group(0) @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size==1&&this.qualifier.has("push_constant"))r+="@push_constant ";else if(this.qualifier.size>=1&&this.qualifier.has("local_size_x"))r+="@workgroup_size(",r+=this.qualifier.get("local_size_x")+", ",r+=this.qualifier.has("local_size_y")?this.qualifier.get("local_size_y")+", ":"1, ",r+=this.qualifier.has("local_size_z")?this.qualifier.get("local_size_z")+"":"1",r+=")";else if(this.nodes.length<=0)return"";let s=this.nodes[0];if(s instanceof Te){switch(s.type){case"sampler":case"texture2D":r+="var ";break;default:this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ";break}e.addIdentifier(s.name,s.name),r+=s.name+": "+St(s.type)+`;\r
`}else if(s instanceof oi){if(this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ",s.nodes.length<=0){let a="unif"+e.layoutUniformCount.toString();for(;e.hasIdentifier(a);)e.layoutUniformCount++,a="unif"+e.layoutUniformCount.toString();for(let n of s.fields)e.addIdentifier(n.name,a+"."+n.name);r+=a+": "+s.name+`;\r
`,e.layoutUniformCount++}else{let a=s.nodes[0];r+=a.name+": "+a.type+`;\r
`}return r}return r}}function St(i){switch(i){case"int":return"i32";case"int[]":return"array<i32>";case"uint":return"u32";case"uint[]":return"array<u32>";case"float":return"f32";case"float[]":return"array<f32>";case"vec2":return"vec2<f32>";case"vec3":return"vec3<f32>";case"vec4":return"vec4<f32>";case"vec2[]":return"array<vec2<f32>>";case"vec3[]":return"array<vec3<f32>>";case"vec4[]":return"array<vec4<f32>>";case"ivec2":return"vec2<i32>";case"ivec3":return"vec3<i32>";case"ivec4":return"vec4<i32>";case"ivec2[]":return"array<vec2<i32>>";case"ivec3[]":return"array<vec3<i32>>";case"ivec4[]":return"array<vec4<i32>>";case"mat2":return"mat2x2<f32>";case"mat2x2":return"mat2x2<f32>";case"mat2x3":return"mat2x3<f32>";case"mat2x4":return"mat2x4<f32>";case"mat2[]":return"array<mat2x2<f32>>";case"mat2x2[]":return"array<mat2x2<f32>>";case"mat2x3[]":return"array<mat2x3<f32>>";case"mat2x4[]":return"array<mat2x4<f32>>";case"mat3":return"mat3x3<f32>";case"mat3x2":return"mat3x2<f32>";case"mat3x3":return"mat3x3<f32>";case"mat3x4":return"mat3x4<f32>";case"mat3[]":return"array<mat3x3<f32>>";case"mat3x2[]":return"array<mat3x2<f32>>";case"mat3x3[]":return"array<mat3x3<f32>>";case"mat3x4[]":return"array<mat3x4<f32>>";case"mat4":return"mat4x4<f32>";case"mat4x2":return"mat4x2<f32>";case"mat4x3":return"mat4x3<f32>";case"mat4x4":return"mat4x4<f32>";case"mat4[]":return"array<mat4x4<f32>>";case"mat4x2[]":return"array<mat4x2<f32>>";case"mat4x3[]":return"array<mat4x3<f32>>";case"mat4x4[]":return"array<mat4x4<f32>>";case"texture2D":return"texture_2d<f32>"}return i}class vu{constructor(e){o(this,"_lexer"),o(this,"_rootNode"),this._lexer=e,this._rootNode=new me,this.parse()}get lexer(){return this._lexer}parse(){for(;this.peekToken(0).Type!==x.EOF;){if(this.peekToken(0).Type==x.SEMICOLON){this.skipToken(1);continue}let e=this.parseStatement();e!==null&&this._rootNode.addNode(e)}}parseStatement(){let e=this.peekToken();if(e.Type==x.LAYOUT&&this.peekToken(1).Type==x.LEFTSAMLL)return vs.parse(this._lexer);if(e.Type==x.STRUCT)return this.skipToken(1),oi.parse(this._lexer);if((e.isBuiltinType()||e.Type==x.VOID)&&this.peekToken(1).Type==x.IDENT&&this.peekToken(2).Type==x.LEFTSAMLL)return _a.parse(this._lexer);if(e.Type==x.CONST&&this.peekToken(1).isDataType())return Te.parse(this._lexer);if(e.isDataType()&&this.peekToken(1).Type==x.IDENT)return Te.parse(this._lexer);if(e.Type==x.OUT&&this.peekToken(1).isDataType()&&this.peekToken(2).Type==x.IDENT)return Te.parse(this._lexer);if(e.Type==x.PRECISION)return ya.parse(this._lexer);throw"Error parsing statement: Unexpected character"}skipToken(e){this._lexer.skipToken(e)}peekToken(e=0){return this._lexer.peekToken(e)}getNextToken(){return this._lexer.GetNextToken()}get ASTRoot(){return this._rootNode}}class Ks{static convertGLSL(e){var t=new mu(e),r=new pu(t),s=new vu(r),a=new Au(s);return a.generateWGSL()}}o(Ks,"VertexShader","VertexShader"),o(Ks,"FragmentShader","FragmentShader");class Oo{constructor(){o(this,"setID",0),o(this,"bindingID",0),o(this,"name",""),o(this,"type","")}}class No{constructor(){o(this,"name",""),o(this,"type",""),o(this,"locationID",0),o(this,"builtinName","")}isBuiltinAttribute(){return this.builtinName!=""}}class yu{constructor(){o(this,"uniformInfo",[]),o(this,"inputAttribute",[]),o(this,"outputAttribute",[]),o(this,"sourceCode","")}}var Ut=(i=>(i[i.vertex=0]="vertex",i[i.fragment=1]="fragment",i[i.computer=2]="computer",i))(Ut||{});class Cu{constructor(){o(this,"blendMode",xe.NONE),o(this,"depthCompare",vt.less),o(this,"depthWriteEnabled",!0),o(this,"frontFace","ccw"),o(this,"cullMode",ui.back),o(this,"topology",Ms.triangle_list),o(this,"depthBias",10),o(this,"useLight",!1),o(this,"useProbe",!1),o(this,"acceptGI",!1),o(this,"acceptShadow",!1),o(this,"castShadow",!1),o(this,"castReflection",!1),o(this,"receiveEnv",!1),o(this,"renderLayer",1e3),o(this,"renderOrder",2e3),o(this,"unclippedDepth",!1),o(this,"transparent",!1),o(this,"multisample",0),o(this,"label"),o(this,"useZ",!0),o(this,"splitTexture",!1),o(this,"alphaCutoff"),o(this,"useFragDepth",!1)}setFromMapValues(e){e.has("blendMode")&&(this.blendMode=this.convertBlendMode(e.get("blendMode"))),e.has("depthCompare")&&(this.depthCompare=e.get("depthCompare")),e.has("depthWriteEnabled")&&(this.depthWriteEnabled=e.get("depthWriteEnabled")),e.has("frontFace")&&(this.frontFace=e.get("frontFace")),e.has("cullMode")&&(this.cullMode=e.get("cullMode")),e.has("topology")&&(this.topology=e.get("topology")),e.has("depthBias")&&(this.depthBias=e.get("depthBias")),e.has("useLight")&&(this.useLight=e.get("useLight")),e.has("useProbe")&&(this.useProbe=e.get("useProbe")),e.has("acceptGI")&&(this.acceptGI=e.get("acceptGI")),e.has("acceptShadow")&&(this.acceptShadow=e.get("acceptShadow")),e.has("castShadow")&&(this.castShadow=e.get("castShadow")),e.has("receiveEnv")&&(this.receiveEnv=e.get("receiveEnv")),e.has("renderLayer")&&(this.renderLayer=e.get("renderLayer")),e.has("renderOrder")&&(this.renderOrder=e.get("renderOrder")),e.has("unclippedDepth")&&(this.unclippedDepth=e.get("unclippedDepth")),e.has("multisample")&&(this.multisample=e.get("multisample")),e.has("label")&&(this.label=e.get("label")),e.has("useZ")&&(this.useZ=e.get("useZ"))}convertBlendMode(e){switch(e){case"ABOVE":return xe.ABOVE;case"ALPHA":return xe.ALPHA;case"NORMAL":return xe.NORMAL;case"ADD":return xe.ADD;case"BELOW":return xe.BELOW;case"ERASE":return xe.ERASE;case"MUL":return xe.MUL;case"SCREEN":return xe.SCREEN;case"DIVD":return xe.DIVD;case"SOFT_ADD":return xe.SOFT_ADD}return xe.NONE}}class wu extends Jt{constructor(){super(),o(this,"uniformNodes",[]),o(this,"_onChange",!0),this.bufferType=Mt.MaterialDataUniformGPUBuffer}initDataUniform(e){this.uniformNodes=e;let t=0;for(const r in e){const s=e[r];s||console.error(r,"is empty"),t+=s.size*4}t=Math.floor(t/256+1)*256,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,t/4);for(const r in e){const s=e[r];s||console.error(r,"is empty");let a=this.memory.allocation_node(s.size*4);s.memoryInfo=a,s.bindOnChange=()=>this.onChange()}}onChange(){this._onChange=!0}apply(){if(this.uniformNodes.length!=0&&this._onChange){for(const e in this.uniformNodes)this.uniformNodes[e].update();super.apply(),this._onChange=!1}}}class Ot{static init(){this.renderShaderModulePool=new Map,this.renderShader=new Map}}o(Ot,"renderShaderModulePool"),o(Ot,"renderShader");class Js{static getSharePipeline(e){let t=this.pipelineMap.get(e);return t||null}static setSharePipeline(e,t){this.pipelineMap.set(e,t)}}o(Js,"pipelineMap",new Map);class We extends Ka{constructor(e,t){super(),o(this,"useRz",!1),o(this,"vsName"),o(this,"fsName"),o(this,"shaderState"),o(this,"textures"),o(this,"pipeline"),o(this,"bindGroupLayouts"),o(this,"materialDataUniformBuffer"),o(this,"envMap"),o(this,"prefilterMap"),o(this,"_sourceVS"),o(this,"_sourceFS"),o(this,"_destVS"),o(this,"_destFS"),o(this,"_vsShaderModule"),o(this,"_fsShaderModule"),o(this,"_textureGroup",-1),o(this,"_textureChange",!1),o(this,"_groupsShaderReflectionVarInfos"),o(this,"_cacheEntries"),this.vsName=e.toLowerCase(),this.fsName=t.toLowerCase(),this.vsName in N||console.error("Shader Not Register, Please Register Shader!",this.vsName),this.fsName in N||console.error("Shader Not Register, Please Register Shader!",this.fsName),N[this.vsName]&&(this._sourceVS=N[this.vsName]),N[this.fsName]&&(this._sourceFS=N[this.fsName]),this.textures={},this.bindGroups=[],this.shaderState=new Cu,this.materialDataUniformBuffer=new wu,this.materialDataUniformBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._bufferDic.set("global",this.materialDataUniformBuffer),this._bufferDic.set("materialUniform",this.materialDataUniformBuffer)}get renderOrder(){return this.shaderState.renderOrder}set renderOrder(e){this.shaderState.renderOrder!=e&&(this._valueChange=!0),this.shaderState.renderOrder=e}get doubleSide(){return this.shaderState.cullMode==ui.none}set doubleSide(e){let t=e?ui.none:this.cullMode;this.shaderState.cullMode!=t&&(this._valueChange=!0),this.shaderState.cullMode=t}get cullMode(){return this.shaderState.cullMode}set cullMode(e){this.shaderState.cullMode!=e&&(this._valueChange=!0),this.shaderState.cullMode=e}get frontFace(){return this.shaderState.frontFace}set frontFace(e){this.shaderState.frontFace!=e&&(this._valueChange=!0),this.shaderState.frontFace=e}get depthBias(){return this.shaderState.depthBias}set depthBias(e){this.shaderState.depthBias!=e&&(this._valueChange=!0),this.shaderState.depthBias=e}get topology(){return this.shaderState.topology}set topology(e){this.shaderState.topology!=e&&(this._valueChange=!0),this.shaderState.topology=e}get blendMode(){return this.shaderState.blendMode}set blendMode(e){this.shaderState.blendMode!=e&&(this._valueChange=!0,e!=xe.NORMAL&&e!=xe.NONE&&(this.renderOrder=3e3)),this.shaderState.blendMode=e}get depthCompare(){return this.shaderState.depthCompare}set depthCompare(e){this.shaderState.depthCompare!=e&&(this._valueChange=!0),this.shaderState.depthCompare=e}setShaderEntry(e="",t=""){this.vsEntryPoint=e,this.fsEntryPoint=t}setUniform(e,t){super.setUniform(e,t),this.materialDataUniformBuffer.onChange()}setTexture(e,t){t&&this.textures[e]!=t&&(this.textures[e]&&this.textures[e].unBindStateChange(this),this._textureChange=!0,this.textures[e]=t,e=="envMap"?this.envMap=t:e=="prefilterMap"&&(this.prefilterMap=t),t.bindStateChange(()=>{this._textureChange=!0},this))}get baseColor(){return this.getUniform("baseColor")}set baseColor(e){this.setUniform("baseColor",e)}getTexture(e){return this.textures[e]}genRenderPipeline(e,t){let r=this.createGroupLayouts();this.createPipeline(e,t,r)}reBuild(e,t){this.compileShader(Ut.vertex,this._destVS,t),this.compileShader(Ut.fragment,this._destFS,t),this.genRenderPipeline(e,t)}apply(e,t,r){this.materialDataUniformBuffer.apply(),this._textureChange&&this._textureGroup!=-1&&(this._textureChange=!1,this.genGroups(this._textureGroup,this.shaderReflection.groups,!0)),this._valueChange&&(this._shaderChange&&(this.preCompile(e),this._shaderChange=!1),this.shaderVariant=ct.genRenderShaderVariant(this),this.reBuild(e,t),this._valueChange=!1,r&&r())}preCompile(e){this.preDefine(e),this.preCompileShader(Ut.vertex,this._sourceVS.concat()),this.preCompileShader(Ut.fragment,this._sourceFS.concat()),this.genReflection()}applyPostDefine(e,t){return t.outAttachments.length>1?(this.defineValue.USE_WORLDPOS=!0,this.defineValue.USEGBUFFER=!0):(this.defineValue.USE_WORLDPOS=!1,this.defineValue.USEGBUFFER=!1),ut.parse(e,this.defineValue)}setBindGroup(e,t){this.bindGroups[e]=t}checkBuffer(e,t){}preCompileShader(e,t,r){let s=t;if(s.indexOf("version ")!=-1){var a=Ks.convertGLSL(s);s=a.sourceCode}for(const n in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,n)){const l=this.constValues[n];s=s.replaceAll(`&${n}`,l.toString())}switch(e){case Ut.vertex:this._destVS=s;break;case Ut.fragment:this._destFS=s;break}}compileShader(e,t,r){let s=t;s=this.applyPostDefine(s,r);let a=t;for(let l in this.defineValue)a+=`${l}=${this.defineValue[l]},`;let n=Ot.renderShaderModulePool.get(a);switch(n||(s=this.applyPostDefine(s,r),n=S.device.createShaderModule({label:e==Ut.vertex?this.vsName:this.fsName,code:s}),n.getCompilationInfo().then(l=>{l.messages.length>0&&(console.log(s),console.log(l))}),Ot.renderShaderModulePool.set(a,n)),e){case Ut.vertex:this._vsShaderModule=n,this._destVS=s;break;case Ut.fragment:this._fsShaderModule=n,this._destFS=s;break}}getGroupLayout(e,t){let r=[];for(let s=0;s<t.length;s++){const a=t[s];if(a)if(a.varType=="uniform"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let n=this._bufferDic.get(a.varName).visibility,l={binding:a.binding,visibility:n,buffer:{type:"uniform"}};r.push(l)}else if(a.varType=="storage-read"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let n=this._bufferDic.get(a.varName).visibility,l={binding:a.binding,visibility:n,buffer:{type:"read-only-storage"}};r.push(l)}else if(a.varType=="var")switch(a.dataType){case"sampler":{let n=a.varName.replace("Sampler",""),l=this.textures[n]?this.textures[n]:A.res.redTexture,h={binding:a.binding,visibility:l.visibility,sampler:l.samplerBindingLayout};r.push(h),this._textureGroup=e}break;case"sampler_comparison":{let n=a.varName.replace("Sampler",""),l=this.textures[n]?this.textures[n]:A.res.redTexture,h={binding:a.binding,visibility:l.visibility,sampler:l.sampler_comparisonBindingLayout};r.push(h),this._textureGroup=e}break;case"texture_2d<f32>":case"texture_2d_array<f32>":case"texture_cube<f32>":case"texture_depth_2d":case"texture_depth_2d_array":case"texture_depth_cube":case"texture_depth_cube_array":{let n=this.textures[a.varName]?this.textures[a.varName]:A.res.redTexture,l={binding:a.binding,visibility:n.visibility,texture:n.textureBindingLayout};r.push(l),this._textureGroup=e,se.getInstance().attached(n,this)}break;case"texture_external":{let n=this.textures[a.varName]?this.textures[a.varName]:A.res.redTexture,l={binding:a.binding,visibility:n.visibility,externalTexture:{}};r.push(l),this._textureGroup=e,se.getInstance().attached(n,this)}break;default:{let n=this.textures[a.varName]?this.textures[a.varName]:A.res.redTexture,l={binding:a.binding,visibility:n.visibility,texture:n.textureBindingLayout};r.push(l),this._textureGroup=e,se.getInstance().attached(n,this)}break}else{debugger;console.error("bind group can't empty")}}return r}genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const s=t[e];let a=[];for(let l=0;l<s.length;l++){const h=s[l];if(h){if(h.varType=="uniform"){let u=this._bufferDic.get(h.varName);if(u){if(u.bufferType==Mt.MaterialDataUniformGPUBuffer){let f=[];for(let d=0;d<h.dataFields.length;d++){const p=h.dataFields[d];this.uniforms[p.name]||console.error(`shader-${this.vsName}:${this.fsName} ${p.name}is empty`),f.push(this.uniforms[p.name])}this.materialDataUniformBuffer.initDataUniform(f)}let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};a.push(c),this.checkBuffer(h.varName,u)}else console.error(`shader${this.vsName}-${this.fsName}`,`buffer ${h.varName} is missing!`)}else if(h.varType=="storage-read"){let u=this._bufferDic.get(h.varName);if(u){let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};a.push(c),this.checkBuffer(h.varName,u)}else console.error(`buffer ${h.varName} is missing!`)}else if(h.varType=="var")if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c||(c=A.res.blackTexture,this.setTexture(u,c)),c){let f={binding:h.binding,resource:c.gpuSampler};a.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c){let f={binding:h.binding,resource:c.gpuSampler_comparison};a.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else{let u=this.textures[h.varName];if(u||(u=A.res.whiteTexture,this.setTexture(h.varName,u)),u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}}}let n=S.device.createBindGroup({layout:this.bindGroupLayouts[e],entries:a});this.bindGroups[e]=n}}createPipeline(e,t,r){let s=e,a=this.shaderState,n=t.outAttachments;if(t.outColor!=-1){let u=n[t.outColor];a.blendMode!=xe.NONE?u.blend=no.getBlend(a.blendMode):delete u.blend}let l={label:this.vsName+"|"+this.fsName,layout:r,primitive:{topology:a.topology,cullMode:a.cullMode,frontFace:a.frontFace},vertex:void 0};this.vsEntryPoint!=""&&(l.vertex={module:this._vsShaderModule,entryPoint:this.vsEntryPoint,buffers:s.vertexBuffer.vertexBufferLayouts}),this.fsEntryPoint!=""&&(l.fragment={module:this._fsShaderModule,entryPoint:this.fsEntryPoint,targets:n}),a.multisample>0&&(l.multisample={count:a.multisample}),(t.zPreTexture||t.depthTexture)&&(a.blendMode!=xe.NONE,A.setting.render.zPrePass&&t.zPreTexture&&a.useZ?l.depthStencil={depthWriteEnabled:!1,depthCompare:vt.less,format:t.zPreTexture.format}:l.depthStencil={depthWriteEnabled:a.depthWriteEnabled,depthCompare:a.depthCompare,format:t.depthTexture.format});let h=Js.getSharePipeline(this.shaderVariant);h?this.pipeline=h:(this.pipeline=w.createPipeline(l),Js.setSharePipeline(this.shaderVariant,this.pipeline))}createGroupLayouts(){this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroupLayouts=[Hr.getGlobalDataBindGroupLayout()];for(let r=1;r<e.groups.length;r++){let s=e.groups[r];if(s){let a=this.getGroupLayout(r,s);this._groupsShaderReflectionVarInfos[r]=s;let n=S.device.createBindGroupLayout({entries:a,label:`vs${this.vsName} fs${this.fsName} ${s.length}`});this.bindGroupLayouts[r]=n}else console.error("can't set empty group!",r)}let t=S.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts});return this._groupsShaderReflectionVarInfos[0],this._groupsShaderReflectionVarInfos[1]&&this.genGroups(1,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[2]&&this.genGroups(2,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[3]&&this.genGroups(3,this._groupsShaderReflectionVarInfos),t}preDefine(e){let t=e.hasAttribute(Y.joints0),r=e.hasAttribute(Y.a_morphPositions_0),s=e.hasAttribute(Y.TANGENT),a=e.hasAttribute(Y.color),n=this.shaderState.acceptGI,l=this.shaderState.useLight;this.defineValue.USE_SKELETON=t,this.defineValue.USE_MORPHTARGETS=r,"USE_TANGENT"in this.defineValue||(this.defineValue.USE_TANGENT=s),this.defineValue.USE_GI=n,this.defineValue.USE_CASTSHADOW=this.shaderState.castShadow,this.defineValue.USE_SHADOWMAPING=this.shaderState.acceptShadow,this.defineValue.USE_LIGHT=l,this.defineValue.USE_VERTXCOLOR=a,A.setting.pick.mode=="pixel"&&(this.defineValue.USE_WORLDPOS=!0),A.setting.gi.enable?this.defineValue.USEGI=!0:this.defineValue.USEGI=!1,A.setting.render.debug&&(this.defineValue.USE_DEBUG=!0,this.defineValue.DEBUG_CLUSTER=!0),this.shaderState.useLight?this.defineValue.USE_LIGHT=!0:this.defineValue.USE_LIGHT=!1,A.setting.render.useLogDepth?(this.defineValue.USE_LOGDEPTH=!0,this.shaderState.useFragDepth=!0):this.defineValue.USE_LOGDEPTH=!1,this.shaderState.useFragDepth?this.defineValue.USE_OUTDEPTH=!0:this.defineValue.USE_OUTDEPTH=!1,this.defineValue.USE_PCF_SHADOW=A.setting.shadow.type=="PCF",this.defineValue.USE_HARD_SHADOW=A.setting.shadow.type=="HARD",this.defineValue.USE_SOFT_SHADOW=A.setting.shadow.type=="SOFT",this.defineValue.USE_CSM=lt.Cascades>1,this.defineValue.USE_IES_PROFILE=Bi.use}genReflection(){this.shaderVariant=ct.genRenderShaderVariant(this);let e=ct.poolGetReflection(this.shaderVariant);if(e)this.shaderReflection=e;else{let t=ut.parse(this._destVS,this.defineValue);t=ut.parse(t,this.defineValue),ct.getShaderReflection2(t,this);let r=ut.parse(this._destFS,this.defineValue);r=ut.parse(r,this.defineValue),ct.getShaderReflection2(r,this),ct.final(this)}this.shaderState.splitTexture=this.shaderReflection.useSplit}destroy(e){for(const t in this.textures)if(Object.prototype.hasOwnProperty.call(this.textures,t)){const r=this.textures[t];if(se.getInstance().detached(r,this),e&&!se.getInstance().hasReference(r))r.destroy(e);else{r.destroy(!1);let s=se.getInstance().getReference(r),a=[];s.forEach((n,l)=>{"name"in n?a.push(n.name):a.push("NaN")})}}this.bindGroups.length=0,this.shaderState=null,this.textures=null,this.pipeline=null,this.bindGroupLayouts=null,this._sourceVS=null,this._sourceFS=null,this._destVS=null,this._destFS=null,this._vsShaderModule=null,this._fsShaderModule=null,this.materialDataUniformBuffer.destroy(e),this.materialDataUniformBuffer=null}static destroyShader(e){Ot.renderShader.has(e)&&(Ot.renderShader.get(e).destroy(),Ot.renderShader.delete(e))}static getShader(e){return Ot.renderShader.get(e)}static createShader(e,t){let r=new We(e,t);return Ot.renderShader.set(r.instanceID,r),r.instanceID}}class _i{constructor(){o(this,"name"),o(this,"instanceID"),o(this,"enable",!0),o(this,"_defaultPass"),o(this,"_renderPasses"),o(this,"_depthCompare",vt.less),this._renderPasses=new Map}get depthCompare(){return this._depthCompare}set depthCompare(e){this._depthCompare=e,this._defaultPass.depthCompare=e}get defaultPass(){return this._defaultPass}set defaultPass(e){this._defaultPass=e,this.addPass(re.COLOR,e)}get doubleSide(){return this._defaultPass.doubleSide}set doubleSide(e){this._defaultPass.doubleSide=e}get castShadow(){return this.defaultPass.shaderState.castShadow}set castShadow(e){let t=this.defaultPass;t.shaderState.castShadow=e}get blendMode(){return this.defaultPass.blendMode}set blendMode(e){let t=this.defaultPass;t.blendMode=e}get transparent(){return this.defaultPass.shaderState.transparent}set transparent(e){let t=this.defaultPass;t.shaderState.transparent=e,e&&(t.renderOrder=3e3)}get cullMode(){return this.defaultPass.cullMode}set cullMode(e){let t=this.defaultPass;t.cullMode=e}hasPass(e){return this._renderPasses.has(e)}getPass(e){return this._renderPasses.get(e)}getAllPass(){return this._renderPasses.get(re.COLOR)}addPass(e,t,r=-1){this._renderPasses.has(e)||this._renderPasses.set(e,[]);let s=this._renderPasses.get(e);return e==re.COLOR&&s.length==0&&(this._defaultPass=t),s.indexOf(t)!=-1||(r==-1?s.push(t):s.splice(r,-1,t)),s}removePass(e,t){if(this._renderPasses.has(e)){let r=this._renderPasses.get(e);t<r.length&&r.splice(t,1)}}clone(){return null}destroy(e){for(const t of this._renderPasses){let r=t[1];for(const s of r)for(const a in s.textures)a.indexOf("defaultOri")==-1&&s.textures[a].destroy(e)}}}class os extends _i{constructor(){super()}setDefault(){let e=this.defaultPass;e.setUniformFloat("shadowBias",35e-5),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z),e.setUniformColor("emissiveColor",new z(1,1,1)),e.setUniformVector4("materialF0",new j(.04,.04,.04,1)),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",1),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("roughness_min",0),e.setUniformFloat("roughness_max",1),e.setUniformFloat("metallic_min",0),e.setUniformFloat("metallic_max",1),e.setUniformFloat("emissiveIntensity",0),e.setUniformFloat("alphaCutoff",0),e.setUniformFloat("ior",1.5),e.setUniformFloat("clearcoatFactor",0),e.setUniformFloat("clearcoatRoughnessFactor",0),e.setUniformColor("clearcoatColor",new z(1,1,1)),e.setUniformFloat("clearcoatWeight",0)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseColor(){return this.defaultPass.getUniform("baseColor")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get normalMap(){return this.defaultPass.getTexture("normalMap")}set normalMap(e){this.defaultPass.setTexture("normalMap",e)}get doubleSide(){return this.defaultPass.doubleSide}set doubleSide(e){this.defaultPass.doubleSide=e}get alphaCutoff(){return this.defaultPass.shaderState.alphaCutoff}set alphaCutoff(e){this.defaultPass.setDefine("USE_ALPHACUT",!0),this.defaultPass.shaderState.alphaCutoff=e,this.defaultPass.setUniform("alphaCutoff",e)}get emissiveColor(){return this.defaultPass.getUniform("emissiveColor")}set emissiveColor(e){this.defaultPass.setUniform("emissiveColor",e)}get emissiveIntensity(){return this.defaultPass.getUniform("emissiveIntensity")}set emissiveIntensity(e){this.defaultPass.setUniform("emissiveIntensity",e)}get uvTransform_1(){return this.defaultPass.uniforms.transformUV1.vector4}set uvTransform_1(e){this.defaultPass.setUniformVector4("transformUV1",e)}get uvTransform_2(){return this.defaultPass.uniforms.transformUV2.vector4}set uvTransform_2(e){this.defaultPass.setUniformVector4("transformUV2",e)}get depthWriteEnabled(){return this.defaultPass.shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.defaultPass.shaderState.depthWriteEnabled=e}get materialF0(){return this.defaultPass.uniforms.materialF0.vector4}set materialF0(e){this.defaultPass.setUniformVector4("materialF0",e)}get roughness(){return this.defaultPass.uniforms.roughness.value}set roughness(e){this.defaultPass.setUniformFloat("roughness",e)}get metallic(){return this.defaultPass.uniforms.metallic.value}set metallic(e){this.defaultPass.setUniformFloat("metallic",e)}get ao(){return this.defaultPass.uniforms.ao.value}set ao(e){this.defaultPass.setUniformFloat("ao",e)}get metallic_min(){return this.defaultPass.uniforms.metallic_min.value}set metallic_min(e){this.defaultPass.setUniformFloat("metallic_min",e)}get metallic_max(){return this.defaultPass.uniforms.metallic_max.value}set metallic_max(e){this.defaultPass.setUniformFloat("metallic_max",e)}get roughness_min(){return this.defaultPass.uniforms.roughness_min.value}set roughness_min(e){this.defaultPass.setUniformFloat("roughness_min",e)}get roughness_max(){return this.defaultPass.uniforms.roughness_max.value}set roughness_max(e){this.defaultPass.setUniformFloat("roughness_max",e)}get normalScale(){return this.defaultPass.uniforms.normalScale.value}set normalScale(e){this.defaultPass.setUniformFloat("normalScale",e)}get maskMap(){return this.defaultPass.textures.maskMap}set maskMap(e){this.defaultPass.setDefine("USE_MR",!0),this.defaultPass.setTexture("maskMap",e)}set aoMap(e){e&&(this.defaultPass.setTexture("aoMap",e),e!=A.res.whiteTexture&&this.defaultPass.setDefine("USE_AOTEX",!0))}get aoMap(){return this.defaultPass.textures.aoMap}set clearCoatRoughnessMap(e){e&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.defaultPass.setTexture("clearCoatRoughnessMap",e),this.defaultPass.setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.defaultPass.textures.clearCoatRoughnessMap}get brdfLUT(){return this.defaultPass.textures.brdfLUT}set brdfLUT(e){this.defaultPass.setTexture("brdfLUT",e),this.defaultPass.setTexture("brdflutMap",e)}get emissiveMap(){return this.defaultPass.textures.emissiveMap}set emissiveMap(e){this.defaultPass.setTexture("emissiveMap",e)}set envIntensity(e){this.defaultPass.setUniformFloat("envIntensity",e)}get envIntensity(){return this.defaultPass.uniforms.envIntensity.value}set ior(e){this.defaultPass.setUniformFloat("ior",e)}get ior(){return this.defaultPass.uniforms.ior.value}useCleanCoat(){this.defaultPass.setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(e){this.defaultPass.setUniformFloat("clearcoatFactor",e),this.useCleanCoat()}get clearcoatFactor(){return this.defaultPass.uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(e){this.defaultPass.setUniformFloat("clearcoatRoughnessFactor",e),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.defaultPass.uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(e){this.defaultPass.setUniformFloat("clearcoatWeight",e),this.useCleanCoat()}get clearcoatWeight(){return this.defaultPass.uniforms.clearcoatWeight.value}set clearcoatColor(e){this.defaultPass.setUniformColor("clearcoatColor",e),this.useCleanCoat()}get clearcoatColor(){return this.defaultPass.uniforms.clearcoatColor.color}}class yi extends os{constructor(){super();let e=new We("PBRLItShader","PBRLItShader");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0;let r=A.res.getTexture("BRDFLUT");this.brdfLUT=r,e.setDefine("USE_BRDF",!0),this.setDefault(),this.baseMap=A.res.whiteTexture,this.normalMap=A.res.normalTexture,this.emissiveMap=A.res.blackTexture,this.alphaCutoff=.5}clone(){let e=new yi,t=e.defaultPass;return t.setUniform("shadowBias",this.defaultPass.getUniform("shadowBias")),t.setUniform("transformUV1",this.defaultPass.getUniform("transformUV1")),t.setUniform("transformUV2",this.defaultPass.getUniform("transformUV2")),t.setUniform("baseColor",this.defaultPass.getUniform("baseColor")),t.setUniform("emissiveColor",this.defaultPass.getUniform("emissiveColor")),t.setUniform("materialF0",this.defaultPass.getUniform("materialF0")),t.setUniform("envIntensity",this.defaultPass.getUniform("envIntensity")),t.setUniform("normalScale",this.defaultPass.getUniform("normalScale")),t.setUniform("roughness",this.defaultPass.getUniform("roughness")),t.setUniform("metallic",this.defaultPass.getUniform("metallic")),t.setUniform("ao",this.defaultPass.getUniform("ao")),t.setUniform("roughness_min",this.defaultPass.getUniform("roughness_min")),t.setUniform("roughness_max",this.defaultPass.getUniform("roughness_max")),t.setUniform("metallic_min",this.defaultPass.getUniform("metallic_min")),t.setUniform("metallic_max",this.defaultPass.getUniform("metallic_max")),t.setUniform("emissiveIntensity",this.defaultPass.getUniform("emissiveIntensity")),t.setUniform("alphaCutoff",this.defaultPass.getUniform("alphaCutoff")),t.setUniform("ior",this.defaultPass.getUniform("ior")),t.setUniform("clearcoatFactor",this.defaultPass.getUniform("clearcoatFactor")),t.setUniform("clearcoatRoughnessFactor",this.defaultPass.getUniform("clearcoatRoughnessFactor")),t.setUniform("clearcoatColor",this.defaultPass.getUniform("clearcoatColor")),t.setUniform("clearcoatWeight",this.defaultPass.getUniform("clearcoatWeight")),t.setTexture("baseMap",this.defaultPass.getTexture("baseMap")),t.setTexture("normalMap",this.defaultPass.getTexture("normalMap")),t.setTexture("emissiveMap",this.defaultPass.getTexture("emissiveMap")),t.setTexture("aoMap",this.defaultPass.getTexture("aoMap")),t.setTexture("maskMap",this.defaultPass.getTexture("maskMap")),e}}class Fo extends Xt{constructor(){super(...arguments),o(this,"textData",""),o(this,"source_vertices"),o(this,"source_normals"),o(this,"source_tangents"),o(this,"source_textureCoords"),o(this,"matLibs"),o(this,"geometrys"),o(this,"activeGeo"),o(this,"facesMaterialsIndex"),o(this,"mtl"),o(this,"mtlUrl")}async parseString(e){return this.source_vertices=[],this.source_normals=[],this.source_tangents=[],this.source_textureCoords=[],this.matLibs={},this.geometrys={},this.textData=e,await Promise.all([this.parserOBJ(),this.loadMTL()]),this.parser_mesh(),"null"}applyVector2(e,t,r){t[e]&&t[e].length>0?(r.push(t[e][0]),r.push(t[e][1])):(r.push(0),r.push(0))}applyVector3(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2])}applyVector4(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2]),r.push(t[e][3])}async loadMTL(){let t=await new ht().loadTxt(this.baseUrl+this.mtlUrl),r=t.data,s,a=r.split(`\r
`);for(let h=0;h<a.length;h++){let u=a[h];var n=u.indexOf("#");n!=-1&&(u=u.substring(0,n)),u=u.trim();var l=u.split(/\s+/);l[0]==="newmtl"?(s={name:l[1]},this.matLibs[l[1]]=s):l[0].indexOf("map_")!=-1?(s[l[0]]=l[1],s.textures||(s.textures=[l[l.length-1]]),s.textures.push(l[l.length-1])):l.length==2?s[l[0]]=Number(l[1]):l.length==3?s[l[0]]=[Number(l[1]),Number(l[2])]:l.length==4&&(s[l[0]]=[Number(l[1]),Number(l[2]),Number(l[3])])}for(const h in this.matLibs){const u=this.matLibs[h];if(u.textures&&u.textures.length>0)for(let c=0;c<u.textures.length;c++){const f=it.normalizePath(this.baseUrl+u.textures[c]);await A.res.loadTexture(f)}}return t=null,!0}async load_textures(){}parserLine(e){var t=e.indexOf("#");if(t!=-1){if(e.indexOf("# object")!=-1){var r=e.split(/\s+/);let d=r[1],p=r[2];this.activeGeo={type:d,name:p[1],source_mat:"",source_faces:[]},this.geometrys[p]=this.activeGeo}e=e.substring(0,t)}e=e.trim();var r=e.split(/\s+/);if(r[0]==="v"){var s=[Number(r[1]),Number(r[2]),Number(r[3]),r[4]?1:Number(r[4])];this.source_vertices.push(s)}else if(r[0]==="vt"){var a=[Number(r[1]),Number(r[2]),r[3]?1:Number(r[3])];this.source_textureCoords.push(a)}else if(r[0]==="vn"){var n=[Number(r[1]),Number(r[2]),Number(r[3])];this.source_normals.push(n)}else if(r[0]==="f"){for(var l={indices:[],texture:[],normal:[]},h=1;h<r.length;++h){var u=r[h].indexOf("//"),c=r[h].split(/\W+/);u>0?(l.indices.push(c[0]),l.normal.push(c[1])):c.length===1?l.indices.push(c[0]):c.length===2?(l.indices.push(c[0]),l.texture.push(c[1])):c.length===3&&(l.indices.push(c[0]),l.texture.push(c[1]),l.normal.push(c[2]))}this.activeGeo.source_faces.push(l)}else r[0]==="usemtl"?this.activeGeo.source_mat=r[1]:r[0]==="mtllib"&&(this.mtlUrl=r[1])}async parserOBJ(){let e=this.textData.split(`\r
`);for(let t=0;t<e.length;t++){const r=e[t];this.parserLine(r)}return this.textData="",!0}async parser_mesh(){for(const e in this.geometrys){const t=this.geometrys[e];t.vertex_arr=[],t.normal_arr=[],t.uv_arr=[],t.indeice_arr=[];let r=0;for(let a=0;a<t.source_faces.length;a++){const n=t.source_faces[a];let l=parseInt(n.indices[0])-1,h=parseInt(n.indices[1])-1,u=parseInt(n.indices[2])-1,c=parseInt(n.normal[0])-1,f=parseInt(n.normal[1])-1,d=parseInt(n.normal[2])-1,p=parseInt(n.texture[0])-1,m=parseInt(n.texture[1])-1,_=parseInt(n.texture[2])-1;if(this.applyVector3(l,this.source_vertices,t.vertex_arr),this.applyVector3(c,this.source_normals,t.normal_arr),this.applyVector2(p,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(h,this.source_vertices,t.vertex_arr),this.applyVector3(f,this.source_normals,t.normal_arr),this.applyVector2(m,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,t.vertex_arr),this.applyVector3(d,this.source_normals,t.normal_arr),this.applyVector2(_,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,n.indices.length>3){let v=parseInt(n.indices[3])-1,y=parseInt(n.normal[3])-1,C=parseInt(n.texture[3])-1;this.applyVector3(l,this.source_vertices,t.vertex_arr),this.applyVector3(c,this.source_normals,t.normal_arr),this.applyVector2(p,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,t.vertex_arr),this.applyVector3(d,this.source_normals,t.normal_arr),this.applyVector2(_,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(v,this.source_vertices,t.vertex_arr),this.applyVector3(y,this.source_normals,t.normal_arr),this.applyVector2(C,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++}}let s=new te;for(const a in this.geometrys){const n=this.geometrys[a];let l=new tt;l.setIndices(new Uint32Array(n.indeice_arr)),l.setAttribute(Y.position,new Float32Array(n.vertex_arr)),l.setAttribute(Y.normal,new Float32Array(n.normal_arr)),l.setAttribute(Y.uv,new Float32Array(n.uv_arr)),l.setAttribute(Y.TEXCOORD_1,new Float32Array(n.uv_arr)),l.addSubGeometry({indexStart:0,indexCount:n.indeice_arr.length,vertexStart:0,index:0});let h=new yi,u=this.matLibs[n.source_mat];h.baseMap=A.res.getTexture(it.normalizePath(this.baseUrl+u.map_Kd));let c=new te,f=c.addComponent(ce);f.geometry=l,f.material=h,s.addChild(c)}this.data=s}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}o(Fo,"format","text");let bu=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`,Su=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;class Iu{static blurImageFromTexture(e,t,r,s){const a=S.device;let n=s?Su:bu;const l=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:n}),entryPoint:"main"}}),h=4*4,u=a.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(u,0,new Uint32Array([e.width,e.height,t,r]));const c=a.createTexture({size:[t,r,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:"blurImageFromTexture"});let f=[{binding:0,resource:{buffer:u,size:4*4}},{binding:1,resource:e.gpuTexture.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:c.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})}];const d=a.createBindGroup({layout:l.getBindGroupLayout(0),entries:f}),p=w.beginCommandEncoder(),m=p.beginComputePass();return m.setPipeline(l),m.setBindGroup(0,d),m.dispatchWorkgroups(Math.floor(t/8),Math.floor(r/8)),m.end(),w.endCommandEncoder(p),u.destroy(),c}}class Zs extends at{constructor(){super(4,4),o(this,"width",4),o(this,"height",4),o(this,"depthOrArrayLayers",6),o(this,"visibility",GPUShaderStage.FRAGMENT),o(this,"textureBindingLayout",{viewDimension:"cube",multisampled:!1}),o(this,"samplerBindingLayout",{type:"filtering"}),this.addressModeU=Bt.clamp_to_edge,this.addressModeV=Bt.clamp_to_edge,this.addressModeW=Bt.clamp_to_edge,this.magFilter=this.minFilter="linear",this.mipmapFilter="linear",this.visibility=GPUShaderStage.FRAGMENT}createTextureDescriptor(e,t,r,s,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,n=1){this.width=e,this.height=t,this.format=s,this.usage=a,this.textureDescriptor={size:{width:e,height:t,depthOrArrayLayers:6},mipLevelCount:r,format:s,usage:a,dimension:"2d"},n>1?this.viewDescriptor={dimension:"cube-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}}const Eu=class{static createFace(i,e,t,r){const s=S.device;this.pipeline==null&&(this.pipeline=s.createComputePipeline({layout:"auto",compute:{module:s.createShaderModule({code:Eu.createCube}),entryPoint:"main"}}));const a=this.pipeline,n=4*4;this.configBuffer||(this.configBuffer=s.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.configBuffer,0,new Uint32Array([i,0,0,0])),this.blurSettingBuffer||(this.blurSettingBuffer=s.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([0,0,0,0]));let l=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:t.getGPUView()},{binding:2,resource:r.getGPUView()}];const h=s.createBindGroup({layout:a.getBindGroupLayout(0),entries:l}),u=w.beginCommandEncoder(),c=u.beginComputePass();c.setPipeline(a),c.setBindGroup(0,h),c.dispatchWorkgroups(e/8,e/8),c.end(),w.endCommandEncoder(u)}};let hr=Eu;o(hr,"createCube",`

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`),o(hr,"configBuffer",null),o(hr,"blurSettingBuffer",null),o(hr,"pipeline");class ko extends Zs{constructor(){super(),o(this,"_images"),o(this,"_url"),this.useMipmap=!0}generateImages(e){let t=S.device;this.width=this.height=32,"width"in e[0]&&(this.width=this.height=e[0].width);let r=Math.min(this.width,this.height);for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;this.textureBindingLayout.viewDimension="cube",this.samplerBindingLayout.type="filtering",this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format),this.textureDescriptor.size={width:this.width,height:this.height,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuTexture=t.createTexture(this.textureDescriptor);let s=[],a=s,n=this.width,l=this.height;if(e[0]instanceof at){for(let h=0;h<6;h++){let u=e[h];s[h]=u.getGPUTexture()}this.uploadMipmapGPUTexture(0,this.width,this.width,s)}else{this.uploadBaseImages(this.width,e);for(let h=0;h<6;h++){let u=new ii(!1);u.format=this.format,u.source=e[h],s[h]=u.getGPUTexture()}}for(let h=1;h<this.mipmapCount;h++){a=s,s=[];let u={width:n,height:l,gpuTexture:null};n=n/2,l=l/2;for(let c=0;c<6;c++)u.gpuTexture=a[c],s[c]=Iu.blurImageFromTexture(u,n,l,!1);this.uploadMipmapGPUTexture(h,n,l,s)}this.gpuSampler=t.createSampler(this)}uploadBaseImages(e,t){let r=S.device;const s=w.beginCommandEncoder();for(let a=0;a<6;a++)r.queue.copyExternalImageToTexture({source:t[a]},{texture:this.gpuTexture,mipLevel:0,origin:{x:0,y:0,z:a}},{width:e,height:e,depthOrArrayLayers:1});w.endCommandEncoder(s)}uploadMipmapGPUTexture(e,t,r,s){const a=w.beginCommandEncoder();for(let n=0;n<6;n++)a.copyTextureToTexture({texture:s[n],mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.gpuTexture,mipLevel:e,origin:{x:0,y:0,z:n}},{width:t,height:r,depthOrArrayLayers:1});w.endCommandEncoder(a)}get images(){return this._images}set images(e){if(this._images=e,this._images[0]instanceof HTMLImageElement){let t=function(n,l){l.decode().then(async()=>{r[n]=await createImageBitmap(l),s--,s==0&&a.generateImages(r)})},r=[],s=6,a=this;for(let n=0;n<6;n++)t(n,this._images[n])}else(this._images instanceof HTMLCanvasElement||this._images instanceof ImageBitmap)&&this.generateImages(this._images)}async load(e){this._url=e;let t=6,r=[];this.format=G.rgba8unorm;let s=this;async function a(n,l){const h=document.createElement("img");if(h.src=l,h.setAttribute("crossOrigin",""),await h.decode(),r[n]=await createImageBitmap(h),t--,t==0)return s.generateImages(r),!0}for(let n=0;n<6;n++)await a(n,e[n]);return!0}async loadStd(e){this._url=e,this.format=G.rgba8unorm;const t=document.createElement("img");t.src=e,t.setAttribute("crossOrigin",""),await t.decode();let r=new ii(!1);r.name=it.getURLName(e),r.format="rgba8unorm",r.source=await createImageBitmap(t);let s=Math.round(Math.log2(r.width/4));s=Math.pow(2,s),this.width=this.height=s;let a=[];for(let n=0;n<6;n++){let l=new oe(s,s,this.format,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);l.name="face "+n,a.push(l),hr.createFace(n,this.width,r,l)}return this.generateImages(a),!0}}var Bu=(i=>(i[i.Left=0]="Left",i[i.Right=1]="Right",i[i.Bottom=2]="Bottom",i[i.Top=3]="Top",i[i.Back=4]="Back",i[i.Front=5]="Front",i))(Bu||{});class zo{static getRotationToFace(e){let t=q.identity().clone(),r=new g,s=new V().identity(),a=new g;switch(e){case 3:r.set(0,-1,0),a.set(0,0,-1);break;case 2:r.set(0,1,0),a.set(0,0,1);break;case 1:r.set(1,0,0),a.set(0,1,0);break;case 0:r.set(-1,0,0),a.set(0,1,0);break;case 4:r.set(0,0,-1),a.set(0,1,0);break;case 5:return q.identity()}return s.lookAt(new g,r,a),t.setFromRotationMatrix(s),t}}let Tu=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`,Mu=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;const It=class{static convertRGBE2RGBA(i,e){const t=S.device,r=t.createComputePipeline({layout:"auto",compute:{module:t.createShaderModule({code:Mu}),entryPoint:"main"}}),s=t.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(s,0,new Uint32Array([i.width,i.height,i.width,i.height]));const a=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});t.queue.writeBuffer(a,0,e);let n=[{binding:0,resource:{buffer:s,size:4*4}},{binding:1,resource:{buffer:a,size:e.byteLength}},{binding:2,resource:i.getGPUView()}];const l=t.createBindGroup({layout:r.getBindGroupLayout(0),entries:n}),h=w.beginCommandEncoder(),u=h.beginComputePass();u.setPipeline(r),u.setBindGroup(0,l),u.dispatchWorkgroups(Math.floor(i.width/8),Math.floor(i.height/8)),u.end(),w.endCommandEncoder(h),s.destroy()}static makeTextureCube(i,e,t){const r=S.device;It.makeFaceTexturePipeline||(It.makeFaceTexturePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:Tu}),entryPoint:"main"}}));const s=It.makeFaceTexturePipeline,a=4*4;It.configBuffer||(It.configBuffer=r.createBuffer({size:a,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),r.queue.writeBuffer(It.configBuffer,0,new Uint32Array([i.width,i.height,e,e]));const n=4*6;if(!It.quaternionBuffer){It.quaternionBuffer=r.createBuffer({size:n*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let p=new Float32Array(4*6);for(let m=0;m<6;m++){let _=zo.getRotationToFace(m);p[m*4+0]=_.x,p[m*4+1]=_.y,p[m*4+2]=_.z,p[m*4+3]=_.w}r.queue.writeBuffer(It.quaternionBuffer,0,p)}let l=[{binding:0,resource:{buffer:It.configBuffer,size:4*4}},{binding:1,resource:{buffer:It.quaternionBuffer,size:n*4}},{binding:2,resource:i.gpuSampler},{binding:3,resource:i.getGPUView()}],h=[{binding:0,resource:t}];const u=r.createBindGroup({layout:s.getBindGroupLayout(0),entries:l}),c=r.createBindGroup({layout:s.getBindGroupLayout(1),entries:h}),f=w.beginCommandEncoder(),d=f.beginComputePass();d.setPipeline(s),d.setBindGroup(0,u),d.setBindGroup(1,c),d.dispatchWorkgroups(e/8,e/8,6),d.end(),w.endCommandEncoder(f)}};let Di=It;o(Di,"makeFaceTexturePipeline"),o(Di,"configBuffer"),o(Di,"quaternionBuffer");class Go extends at{constructor(){super(32,32,null),this.isHDRTexture=!0}create(e=32,t=32,r=null,s=!0){this.width=e,this.height=t;let a=S.device;const n=2,l=e*4*n;let h=r;this.format=G.rgba16float,this.useMipmap=s,this.updateTextureDescription(),this.updateGPUTexture();const u=a.createBuffer({size:h.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(u,0,h);const c=w.beginCommandEncoder();return c.copyBufferToTexture({buffer:u,bytesPerRow:l},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(c),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),this.gpuSampler=a.createSampler(this),this}async load(e,t){return(await new ht().load(e,$s,t)).getHDRTexture()}}const Du=new Float32Array(1),Qg=new Int32Array(Du.buffer);let ur=function(i){Du[0]=i;const e=Qg[0];let t=e>>16&32768,r=e>>12&2047;const s=e>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?1:0)&&e&8388607,t):s<114?(r|=2048,t|=(r>>114-s)+(r>>113-s&1),t):(t|=s-112<<10|r>>1,t+=r&1,t)};var Pu=(i=>(i[i.RGBE_RETURN_FAILURE=-1]="RGBE_RETURN_FAILURE",i[i.rgbe_read_error=1]="rgbe_read_error",i[i.rgbe_write_error=2]="rgbe_write_error",i[i.rgbe_format_error=3]="rgbe_format_error",i[i.rgbe_memory_error=4]="rgbe_memory_error",i))(Pu||{});class Qo{constructor(){o(this,"valid"),o(this,"string"),o(this,"comments"),o(this,"programtype"),o(this,"format"),o(this,"gamma"),o(this,"exposure"),o(this,"width"),o(this,"height")}}class $s extends Xt{constructor(){super(...arguments),o(this,"_rgbeArray"),o(this,"_width"),o(this,"_height"),o(this,"_RGBE_RETURN_FAILURE",-1),o(this,"_parserType",G.rgba8uint)}parseBuffer(e){let t,r=new Uint8Array(e);r.pos=0;const s=this.paserHeader(r);if(s instanceof Qo){const a=this._width=s.width,n=this._height=s.height;let l=this.parserPixel(r.subarray(r.pos),a,n);if(l instanceof Uint8Array){switch(this._rgbeArray=l,this._parserType){}return this.data=t,t}}return null}verification(){if(this.data&&this.data instanceof at)return!0;if(this._rgbeArray)return!0;throw new Error("Method not implemented.")}getTexture(){return this.data}getCubeTexture(){let e=this._width/4;return new ea().createFromHDRData(e,{width:this._width,height:this._height,array:this._rgbeArray})}getHDRTexture(){return new Go().create(this._width,this._height,this._rgbeArray)}parseError(e,t){switch(e){case 1:console.error("Read Error: "+(t||""));break;case 2:console.error("Write Error: "+(t||""));break;case 3:console.error("Bad File Format: "+(t||""));break;default:case 4:console.error("Error: "+(t||""))}return-1}parserBlock(e,t,r){t=t||1024;let a=e.pos,n=-1,l=0,h="",u=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));const c=`
`;for(;0>(n=u.indexOf(c))&&l<t&&a<e.byteLength;)h+=u,l+=u.length,a+=128,u+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));return-1<n?(r!==!1&&(e.pos+=l+n+1),h+u.slice(0,n)):!1}paserHeader(e){const t=/^#\?(\S+)/,r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,n=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l=new Qo;let h,u;if(e.pos>=e.byteLength||!(h=this.parserBlock(e)))return this.parseError(1,"no header found");if(!(u=h.match(t)))return this.parseError(3,"bad initial token");const c=1,f=2,d=4;for(l.valid|=c,l.programtype=u[1],l.string+=h+`
`;h=this.parserBlock(e),h!==!1;){if(l.string+=h+`
`,h.charAt(0)==="#"){l.comments+=h+`
`;continue}if((u=h.match(r))&&(l.gamma=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(s))&&(l.exposure=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(a))&&(l.valid|=f,l.format=u[1]),(u=h.match(n))&&(l.valid|=d,l.height=parseInt(u[1],10),l.width=parseInt(u[2],10)),l.valid&f&&l.valid&d)break}return l.valid&f?l.valid&d?l:(this.parseError(3,"missing image size specifier"),null):(this.parseError(3,"missing format specifier"),null)}parserPixel(e,t,r){const s=t;if(s<8||s>32767||e[0]!==2||e[1]!==2||e[2]&128)return new Uint8Array(e);if(s!==(e[2]<<8|e[3]))return this.parseError(3,"wrong scanline width");const a=new Uint8Array(4*t*r);if(!a.length)return this.parseError(4,"unable to allocate buffer space");let n=0,l=0;const h=4*s,u=new Uint8Array(4),c=new Uint8Array(h);let f=r;for(;f>0&&l<e.byteLength;){if(l+4>e.byteLength)return this.parseError(1,"");if(u[0]=e[l++],u[1]=e[l++],u[2]=e[l++],u[3]=e[l++],u[0]!=2||u[1]!=2||(u[2]<<8|u[3])!=s)return this.parseError(3,"bad rgbe scanline format");let d=0,p;for(;d<h&&l<e.byteLength;){p=e[l++];const _=p>128;if(_&&(p-=128),p===0||d+p>h)return this.parseError(3,"bad scanline data");if(_){const v=e[l++];for(let y=0;y<p;y++)c[d++]=v}else c.set(e.subarray(l,l+p),d),d+=p,l+=p}const m=s;for(let _=0;_<m;_++){let v=0;a[n]=c[_+v],v+=s,a[n+1]=c[_+v],v+=s,a[n+2]=c[_+v],v+=s,a[n+3]=c[_+v],n+=4}f--}return a}rbgeToFloat(e,t,r,s){const a=e[t+3],n=Math.pow(2,a-128)/255;r[s+0]=e[t+0]*n,r[s+1]=e[t+1]*n,r[s+2]=e[t+2]*n,r[s+3]=1}rbgeToHalfFloat(e,t,r,s){const a=e[t+3],n=Math.pow(2,a-128)/255;r[s+0]=ur(e[t+0]*n),r[s+1]=ur(e[t+1]*n),r[s+2]=ur(e[t+2]*n),r[s+3]=ur(1)}}o($s,"format","bin");let Ru=`
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(localPos:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(localPos);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;class cr{static importantSample(e,t,r,s){const a=S.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:Ru}),entryPoint:"main"}}));const n=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([e.width,e.height,t,t]));const h=4*6;if(!this.quaternionBuffer){this.quaternionBuffer=a.createBuffer({size:h*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let v=new Float32Array(4*6);for(let y=0;y<6;y++){let C=zo.getRotationToFace(y);v[y*4+0]=C.x,v[y*4+1]=C.y,v[y*4+2]=C.z,v[y*4+3]=C.w}a.queue.writeBuffer(this.quaternionBuffer,0,v)}this.blurSettingBuffer||(this.blurSettingBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([r,0,0,0]));const u=e.erpTexture;let c=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:{buffer:this.quaternionBuffer,size:h*4}},{binding:2,resource:u.gpuSampler},{binding:3,resource:u.getGPUView()}],f=[{binding:0,resource:{buffer:this.blurSettingBuffer,size:4*4}},{binding:1,resource:s}];const d=a.createBindGroup({layout:n.getBindGroupLayout(0),entries:c}),p=a.createBindGroup({layout:n.getBindGroupLayout(1),entries:f}),m=w.beginCommandEncoder(),_=m.beginComputePass();_.setPipeline(n),_.setBindGroup(0,d),_.setBindGroup(1,p),_.dispatchWorkgroups(t/8,t/8,6),_.end(),w.endCommandEncoder(m)}}o(cr,"configBuffer",null),o(cr,"quaternionBuffer",null),o(cr,"blurSettingBuffer",null),o(cr,"pipeline");class Vo{constructor(e){o(this,"faceTextureRef"),o(this,"_texture"),this._texture=e,this.faceTextureRef={}}uploadTexture(e,t){let r=this.getGpuSource(e);return Di.makeTextureCube(t,this._texture.width,r.v),this}uploadErpTexture(e){let t=this.getGpuSource(0);return Di.makeTextureCube(e,this._texture.width,t.v),this.generateMipmap(e),this}getGpuSource(e){let t=this.faceTextureRef[e];return t||(t={t:this._texture.getGPUTexture(),v:this._texture.getGPUTexture().createView({format:this._texture.format,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1,arrayLayerCount:6})},this.faceTextureRef[e]=t),t}generateMipmap(e){let t=1;for(;t<this._texture.mipmapCount;)this.generateMipmapAtLevel(t,e),t++}generateMipmapAtLevel(e,t,r=3){let s=this._texture.width/Math.pow(2,e),a={width:s,height:s,erpTexture:t},n=(e+1)/this._texture.mipmapCount;n=Math.pow(n,r);let l=this.getGpuSource(e);cr.importantSample(a,s,n,l.v)}}class ea extends Zs{constructor(){super(),o(this,"_url"),o(this,"_faceData"),this.useMipmap=!0,this.format=G.rgba16float,this.isHDRTexture=!0,this._faceData=new Vo(this)}createFromHDRData(e,t){let r=new oe(t.width,t.height,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),s=new Float32Array(t.array);return Di.convertRGBE2RGBA(r,s),this.createFromTexture(e,r),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=S.device.createSampler(this),this._faceData.uploadErpTexture(t),this}async load(e,t){return this._url=e,(await new ht().load(e,$s,t)).getCubeTexture()}}function Lu(i){return new TextDecoder().decode(i)}class ta{constructor(e,t,r,s){o(this,"buffer"),o(this,"binOffset"),o(this,"binLength"),o(this,"header"),this.buffer=e,this.binOffset=t+r,this.binLength=s;let a=null;if(r!==0){const n=new Uint8Array(e,t,r);a=JSON.parse(Lu(n))}else a={};this.header=a}getKeys(){return Object.keys(this.header)}getData(e,t,r=null,s=null){const a=this.header;if(!(e in a))return null;const n=a[e];if(n instanceof Object){if(Array.isArray(n))return n;{const{buffer:l,binOffset:h,binLength:u}=this,c=n.byteOffset||0,f=n.type||s,d=n.componentType||r;if("type"in n&&s&&n.type!==s)throw new Error("FeatureTable: Specified type does not match expected type.");let p;switch(f){case"SCALAR":p=1;break;case"VEC2":p=2;break;case"VEC3":p=3;break;case"VEC4":p=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${e}".`)}let m;const _=h+c,v=t*p;switch(d){case"BYTE":m=new Int8Array(l,_,v);break;case"UNSIGNED_BYTE":m=new Uint8Array(l,_,v);break;case"SHORT":m=new Int16Array(l,_,v);break;case"UNSIGNED_SHORT":m=new Uint16Array(l,_,v);break;case"INT":m=new Int32Array(l,_,v);break;case"UNSIGNED_INT":m=new Uint32Array(l,_,v);break;case"FLOAT":m=new Float32Array(l,_,v);break;case"DOUBLE":m=new Float64Array(l,_,v);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${e}".`)}if(_+v*m.BYTES_PER_ELEMENT>h+u)throw new Error("FeatureTable: Feature data read outside binary body length.");return m}}else return n}}class Ho extends ta{constructor(e,t,r,s,a){super(e,r,s,a),o(this,"batchSize"),this.batchSize=t}getData(e,t=null,r=null){return super.getData(e,this.batchSize,t,r)}}function Yo(i){let e;if(i instanceof DataView?e=i:e=new DataView(i),String.fromCharCode(e.getUint8(0))==="{")return null;let t="";for(let r=0;r<4;r++)t+=String.fromCharCode(e.getUint8(r));return t}class Uu{async parse(e){const t=new DataView(e),r=Yo(t);console.assert(r==="b3dm");const s=t.getUint32(4,!0);console.assert(s===1);const a=t.getUint32(8,!0);console.assert(a===e.byteLength);const n=t.getUint32(12,!0),l=t.getUint32(16,!0),h=t.getUint32(20,!0),u=t.getUint32(24,!0),c=28,f=new ta(e,c,n,l),d=c+n+l,p=new Ho(e,f.getData("BATCH_LENGTH"),d,h,u),m=d+h+u,_=new Uint8Array(e,m,a-m);return{version:s,featureTable:f,batchTable:p,glbBytes:_}}}const ia=class extends Uu{constructor(){super(),o(this,"adjustmentTransform"),o(this,"gltfBuffer"),this.adjustmentTransform=new V().identity(),ia.tempMatrix||(ia.tempMatrix=new V().identity())}async parse(i){const e=await super.parse(i);this.gltfBuffer=e.glbBytes.slice().buffer;let r=await new jo().parseBinary(this.gltfBuffer),{batchTable:s,featureTable:a}=e;const n=a.getData("RTC_CENTER");n&&(r.x+=n[0],r.y+=n[1],r.z+=n[2]);let l=r.getComponent(Oe);l.updateWorldMatrix();let h=ia.tempMatrix;h.compose(l.localPosition,l.localRotQuat,l.localScale),h.multiply(this.adjustmentTransform);let u=h.decompose(yt.QUATERNION);return l.localRotQuat.copyFrom(u[1]),l.localRotQuat=l.localRotQuat,l.localPosition.copyFrom(u[0]),l.localPosition=l.localPosition,l.localScale.copyFrom(u[2]),l.localScale=l.localScale,l.updateWorldMatrix(),r.batchTable=s,r.featureTable=a,r}static decodeText(i){if(typeof TextDecoder<"u")return new TextDecoder().decode(i);let e="";for(let t=0,r=i.length;t<r;t++)e+=String.fromCharCode(i[t]);try{return decodeURIComponent(escape(e))}catch{return e}}};let Pi=ia;o(Pi,"tempMatrix");class Xo extends Xt{async parseBuffer(e){let t=new Pi;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}o(Xo,"format","bin");const Ou="glTF",ns=12,Nu={JSON:1313821514,BIN:5130562},Wo={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class Fu{constructor(e){o(this,"name"),o(this,"content"),o(this,"body"),o(this,"header"),this.name=Wo.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,ns);if(this.header={magic:Pi.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Ou)throw new Error("GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("GLTFLoader: Legacy binary file detected.");const r=this.header.length-ns,s=new DataView(e,ns);let a=0;for(;a<r;){const n=s.getUint32(a,!0);a+=4;const l=s.getUint32(a,!0);if(a+=4,l===Nu.JSON){const h=new Uint8Array(e,ns+a,n);this.content=Pi.decodeText(h)}else if(l===Nu.BIN){const h=ns+a;this.body=e.slice(h,h+n)}a+=n}if(this.content===null)throw new Error("GLTFLoader: JSON content not found.")}}class jo{constructor(){o(this,"_binary")}async parseBinary(e){this._binary=e;const t=Pi.decodeText(new Uint8Array(this._binary,0,4)),r={};let s,a;if(t===Ou){try{a=r[Wo.KHR_BINARY_GLTF]=new Fu(this._binary)}catch{return}s=r[Wo.KHR_BINARY_GLTF].content}else s=Pi.decodeText(new Uint8Array(this._binary));const n=JSON.parse(s);return await this.parseGLB(n,a.body)}async parseGLB(e,t){return await new qs().parseJsonAndBuffer(e,t)}}class ku{async parse(e){const t=new DataView(e),r=Yo(t);console.assert(r==="i3dm");const s=t.getUint32(4,!0);console.assert(s===1);const a=t.getUint32(8,!0);console.assert(a===e.byteLength);const n=t.getUint32(12,!0),l=t.getUint32(16,!0),h=t.getUint32(20,!0),u=t.getUint32(24,!0);t.getUint32(28,!0);const c=32,f=new ta(e,c,n,l),d=c+n+l,p=new Ho(e,f.getData("INSTANCES_LENGTH"),d,h,u),m=d+h+u,_=new Uint8Array(e,m,a-m);return{version:s,featureTable:f,batchTable:p,glbBytes:_}}}class zu extends te{constructor(e,t,r){super(),o(this,"_geometry"),o(this,"_material"),o(this,"_instanceList"),this._geometry=e,this._material=t,this._instanceList=[];for(let s=0;s<r;s++){let a,n=new te;a=n.addComponent(ce),a.geometry=this._geometry,a.material=this._material,this.addChild(n),this._instanceList.push(n)}}setMatrixAt(e,t){let r=this._instanceList[e],s=t.decompose(yt.QUATERNION),a=r.transform;return a.localRotQuat.copyFrom(s[1]),a.localRotQuat=a.localRotQuat,a.localPosition.copyFrom(s[0]),a.localPosition=a.localPosition,a.localScale.copyFrom(s[2]),a.localScale=a.localScale,this}}const rt=class extends ku{constructor(){super(),o(this,"adjustmentTransform"),o(this,"_gltfBuffer"),rt.tempFwd||(rt.tempFwd=new g),rt.tempUp||(rt.tempUp=new g),rt.tempRight||(rt.tempRight=new g),rt.tempPos||(rt.tempPos=new g),rt.tempQuat||(rt.tempQuat=new q),rt.tempSca||(rt.tempSca=new g),rt.tempMat||(rt.tempMat=new V),this.adjustmentTransform=new V().identity()}async parse(i){const e=await super.parse(i);this._gltfBuffer=e.glbBytes.slice().buffer;let r=await new jo().parseBinary(this._gltfBuffer),{batchTable:s,featureTable:a}=e;const n=this.adjustmentTransform,l=a.getData("INSTANCES_LENGTH"),h=a.getData("POSITION",l,"FLOAT","VEC3"),u=a.getData("NORMAL_UP",l,"FLOAT","VEC3"),c=a.getData("NORMAL_RIGHT",l,"FLOAT","VEC3"),f=a.getData("SCALE_NON_UNIFORM",l,"FLOAT","VEC3"),d=a.getData("SCALE",l,"FLOAT","SCALAR"),p=new Map,m=[];r.traverse(y=>{let C;if(C=y?y.getComponent(ce):null,C){const{geometry:B,material:T}=C,M=new zu(B,T,l);M.localPosition=M.localPosition.copy(y.localPosition),M.localRotation=M.localRotation.copy(y.localRotation),M.localScale=M.localScale.copy(y.localScale),m.push(M),p.set(y,M)}});const _=new g;for(let y=0;y<l;y++)_.x+=h[y*3+0]/l,_.y+=h[y*3+1]/l,_.z+=h[y*3+2]/l;p.forEach((y,C)=>{const B=C.parent?C.parentObject:null;B&&(B.removeChild(C),B.addChild(y),y.transform.updateWorldMatrix(),y.transform.worldMatrix.transformVector4(_,y.localPosition))});const v=rt;for(let y=0;y<l;y++){v.tempMat.identity(),v.tempPos.set(h[y*3+0]-_.x,h[y*3+1]-_.y,h[y*3+2]-_.z),u?(v.tempUp.set(u[y*3+0],u[y*3+1],u[y*3+2]),v.tempRight.set(c[y*3+0],c[y*3+1],c[y*3+2]),v.tempRight.crossProduct(v.tempUp,v.tempFwd).normalize(),v.tempMat.makeBasis(v.tempRight,v.tempUp,v.tempFwd),v.tempQuat.setFromRotationMatrix(v.tempMat)):v.tempQuat.set(0,0,0,1),d?v.tempSca.setScalar(d[y]):f?v.tempSca.set(f[y*3+0],f[y*3+1],f[y*3+2]):v.tempSca.set(1,1,1),v.tempMat.compose(v.tempPos,v.tempQuat,v.tempSca),v.tempMat.multiplyMatrices(v.tempMat,n);for(let C=0,B=m.length;C<B;C++)m[C].setMatrixAt(y,v.tempMat)}return r.batchTable=s,r.featureTable=a,r}};let si=rt;o(si,"tempFwd"),o(si,"tempUp"),o(si,"tempRight"),o(si,"tempPos"),o(si,"tempQuat"),o(si,"tempSca"),o(si,"tempMat");class qo extends Xt{async parseBuffer(e){let t=new si;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}o(qo,"format","bin");class ra extends Zs{constructor(){super(),o(this,"_faceData"),o(this,"_url"),this.useMipmap=!0,this.format=G.rgba16float,this._faceData=new Vo(this)}get ldrImageUrl(){return this._url}async load(e,t){this._url=e;let r=new ii(!1);return await r.load(e,t),this.createFromLDRTexture(r),this}createFromLDRTexture(e){let t=Math.log2(e.width/4);return t=Math.pow(2,Math.round(t)),this.createFromTexture(t,e),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=S.device.createSampler(this),this._faceData.uploadErpTexture(t),this}}let Gu=`
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;class Qu{constructor(){o(this,"compute"),this.compute=new be(Gu)}generateBRDFLUTTexture(){let e=new oe(256,256,G.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);this.compute.setStorageTexture("brdflutTexture",e),this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let t=w.beginCommandEncoder();return w.computeCommand(t,[this.compute]),w.endCommandEncoder(t),e}}class Vu extends at{constructor(){super(...arguments),o(this,"_dataBuffer")}create(e,t,r,s=!1){let a=S.device;const n=Math.ceil(e*4/256)*256;this.format=G.rgba8unorm,this.mipmapCount=Math.floor(s?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const l=this._dataBuffer=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=w.beginCommandEncoder();return h.copyBufferToTexture({buffer:l,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h),s&&Ht.webGPUGenerateMipmap(this),this}updateTexture(e,t,r){let s=S.device;const a=Math.ceil(e*4/256)*256;this.mipmapCount=Math.floor(Math.log2(e)),this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null;const n=this._dataBuffer=s.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(n,0,r);const l=w.beginCommandEncoder();l.copyBufferToTexture({buffer:n,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(l),this.gpuSampler=s.createSampler(this),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class fr{constructor(e){o(this,"id"),o(this,"guiTexture"),o(this,"uvRec",new j(0,0,1,1)),o(this,"uvBorder",new j(0,0,0,0)),o(this,"offsetSize",new j(0,0,4,4)),o(this,"borderSize",new j(0,0,0,0)),o(this,"trimSize",new Z),o(this,"isSliced",!1),o(this,"height",4),o(this,"width",4),o(this,"xadvance",0),o(this,"xoffset",0),o(this,"yoffset",0),this.guiTexture=e||A.res.defaultGUITexture}}const Ko=class{constructor(i){o(this,"_staticId",-1),o(this,"dynamicId",-1),o(this,"texture"),o(this,"width",1),o(this,"height",1),i||(i=A.res.whiteTexture),this.texture=i,Ko._maxUid++,this._staticId=Ko._maxUid,this.init()}get staticId(){return this._staticId}init(){this.dynamicId=-1,this.width=this.texture.width,this.height=this.texture.height}};let dr=Ko;o(dr,"_maxUid",-1);class Vg{constructor(){o(this,"fntCache",{}),o(this,"fntData",{})}addFontData(e,t,r){this.fntData[`${e}${t}`]=r}getFontData(e,t){return this.fntData[`${e}${t}`]}addFnt(e,t,r,s){let a=`${e}${t}`;this.fntCache[a]||(this.fntCache[a]={}),this.fntCache[a][r]=s}getFnt(e,t,r){let s=`${e}${t}`,a=this.fntCache[s];return a?a[r]:this.fntCache[" "]}}let gr=new Vg;class Hu{constructor(){o(this,"face",""),o(this,"size",0),o(this,"bold",!1),o(this,"italic",!1),o(this,"stretchH",0),o(this,"spacing",""),o(this,"outline",0),o(this,"lineHeight",0),o(this,"base",0),o(this,"scaleW",0),o(this,"scaleH",0),o(this,"pages",0),o(this,"packed",0),o(this,"alphaChnl",0),o(this,"redChnl",0),o(this,"greenChnl",0),o(this,"blueChnl",0),o(this,"count",0),o(this,"fontPage",[]),o(this,"fontChar",{})}}class Yu{constructor(){o(this,"id",0),o(this,"file","")}}class Xu{constructor(){o(this,"id",-1),o(this,"x",0),o(this,"y",0),o(this,"width",0),o(this,"height",0),o(this,"xoffset",0),o(this,"yoffset",0),o(this,"xadvance",0),o(this,"page",0),o(this,"chnl",0)}}const Ri=class extends Xt{static parseSprite(i,e){for(const t in e.fontChar)if(Object.prototype.hasOwnProperty.call(e.fontChar,t)){const r=e.fontChar[t];let s=new fr;s.id=r.id.toString(),s.offsetSize.set(0,0,r.width,r.height),s.trimSize.set(r.width,r.height),s.width=r.width,s.height=r.height,s.xadvance=r.xadvance,s.xoffset=r.xoffset,s.yoffset=r.yoffset,s.guiTexture=i[r.page],s.uvRec.set(r.x/e.scaleW,(e.scaleH-(r.y+r.height))/e.scaleH,r.width/e.scaleW,r.height/e.scaleH),gr.addFnt(e.face,e.size,s.id,s)}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}async parseString(i){let e=this.getNewLine(i),t=i,r=new Hu;t.trim().split(e).forEach((s,a)=>{if(a<2)Ri.readLineProperty(s,r);else if(a<r.pages+2){let n=new Yu;Ri.readLineProperty(s,n),r.fontPage.push(n)}else if(a<r.pages+3)Ri.readLineProperty(s,r);else if(r.count>0){let n=new Xu;Ri.readLineProperty(s,n),r.fontChar[n.id]=n,r.count--}}),t="",this.data=r,await this.loadFontTextures()}getNewLine(i){return i.indexOf(`\r
`)!=-1?`\r
`:i.indexOf("\r")!=-1?"\r":`
`}async loadFontTextures(){let i=[],e=this.data;for(const t of e.fontPage){let r=this.baseUrl+t.file;await A.res.loadTexture(r,null,!0);let s=A.res.getTexture(r),a=new dr(s);i.push(a)}Ri.parseSprite(i,e),e.fontChar[" "]||Ri.insertSpaceChar(e,i[0])}static insertSpaceChar(i,e){let t=new fr,r=i.size*.5,s=i.lineHeight*.5;t.id=" ",t.offsetSize.set(0,0,i.size,i.size),t.trimSize.set(r,s),t.width=r,t.height=s,t.xadvance=0,t.xoffset=0,t.yoffset=0,t.guiTexture=e,t.uvRec.set(0,0,1e-6,1e-6),gr.addFnt(i.face,i.size,t.id,t)}static readLineProperty(i,e){i.trim().split(" ").forEach((t,r)=>{let s=t.split("=");if(s.length>1){let a=s[0],n=s[1];Object.prototype.hasOwnProperty.call(e,a)&&(n.indexOf('"')==-1?e[a]=parseFloat(s[1]):e[a]=n.replace('"',"").replace('"',""))}})}};let Jo=Ri;o(Jo,"format","text");function Hg(i,e){let t=new fr;return t.id=i,t.offsetSize.set(0,0,e.width,e.height),t.trimSize.set(e.width,e.height),t.width=e.width,t.height=e.height,t.xadvance=0,t.xoffset=0,t.yoffset=0,t.guiTexture=new dr(e),t.uvRec.set(0,0,1,1),e.isVideoTexture||(e.flipY=!0),t}function Wu(i,e,t){let r=new fr;r.guiTexture=i,r.id=e,r.uvRec.copyFrom(t.textureRect),r.trimSize.x=t.textureRect.z,r.trimSize.y=t.textureRect.w,r.offsetSize.x=t.textureRectOffset.x,r.offsetSize.y=t.textureRectOffset.y,r.offsetSize.z=t.size.x,r.offsetSize.w=t.size.y,r.width=t.size.x,r.height=t.size.y;let s=1/i.width,a=1/i.height;r.uvRec.set(r.uvRec.x*s,r.uvRec.y*a,r.uvRec.z*s,r.uvRec.w*a);let n=.1;return t.border.x<=n&&t.border.y<=n&&t.border.z<=n&&t.border.x<=n?r.isSliced=!1:(r.borderSize.copyFrom(t.border),r.uvBorder.copyFrom(t.border),r.uvBorder.x-=t.textureRectOffset.x,r.uvBorder.y-=t.textureRectOffset.y,r.uvBorder.z=t.border.z-(t.size.x-t.textureRect.z-t.textureRectOffset.x),r.uvBorder.w=t.border.w-(t.size.y-t.textureRect.w-t.textureRectOffset.y),r.uvBorder.x/=t.textureRect.z,r.uvBorder.z/=t.textureRect.z,r.uvBorder.y/=t.textureRect.w,r.uvBorder.w/=t.textureRect.w,r.isSliced=!0),r}class ju{constructor(e){o(this,"_spriteMap",new Map),o(this,"_spriteList",[]),o(this,"textureSize",new Z),o(this,"name"),this.textureSize.set(e.x,e.y)}setTexture(e,t,r){let s=Wu(e,t,r);return this._spriteMap.set(s.id,s),this._spriteList.push(s),s}getSprite(e){return this._spriteMap.get(e)}get spriteList(){return this._spriteList}}class Zo extends Xt{constructor(){super(...arguments),o(this,"_json"),o(this,"_texture")}async parseString(e){this._json=JSON.parse(e);let t=this.userData.replace(".json",".png");this._texture=await A.res.loadTexture(t,null,!0),this.data={json:this._json,texture:this._texture},this.parseAtlas()}verification(){if(this.data)return!0;throw new Error("verify failed.")}parseAtlas(){let e=new ju(this._json.size),t=new dr(this._texture),r=this._json.atlas;for(const s in r)e.setTexture(t,s,r[s]);A.res.addAtlas(this.baseUrl,e),this.data=e}}o(Zo,"format","text");class qu{constructor(){o(this,"_texturePool"),o(this,"_materialPool"),o(this,"_prefabPool"),o(this,"_gltfPool"),o(this,"_atlasList"),o(this,"normalTexture"),o(this,"maskTexture"),o(this,"whiteTexture"),o(this,"blackTexture"),o(this,"redTexture"),o(this,"blueTexture"),o(this,"greenTexture"),o(this,"yellowTexture"),o(this,"grayTexture"),o(this,"defaultSky"),o(this,"defaultGUITexture"),o(this,"defaultGUISprite"),this._texturePool=new Map,this._materialPool=new Map,this._prefabPool=new Map,this._gltfPool=new Map,this._atlasList=new Map,this.initDefault()}getGltf(e){return this._gltfPool.get(e)}addTexture(e,t){this._texturePool.set(e,t)}getTexture(e){return this._texturePool.get(e)}addMat(e,t){return this._materialPool.set(e,t)}getMat(e){return this._materialPool.get(e)}addPrefab(e,t){this._prefabPool.set(e,t)}getPrefab(e){return this._prefabPool.get(e).instantiate()}addAtlas(e,t){t.name=e,this._atlasList.set(e,t)}getAtlas(e){return this._atlasList.get(e)}getGUISprite(e){for(let t of this._atlasList.values()){let r=t.getSprite(e);if(r)return r}return null}async loadGltf(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,s=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new ht;s==".gltf"?r=await a.load(e,Ke,t):r=await a.load(e,qs,t);let n=r.data;return this._prefabPool.set(e,n),this._gltfPool.set(e,r.gltf),n}async loadObj(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,s=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new ht;s==".obj"&&(r=await a.load(e,Fo,t));let n=r.data;return this._prefabPool.set(e,n),n}async loadB3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let n=(await new ht().load(e,Xo,t,r)).data;return this._prefabPool.set(e,n),n}async loadI3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let n=(await new ht().load(e,qo,t,r)).data;return this._prefabPool.set(e,n),n}async loadTexture(e,t,r){if(this._texturePool.has(e))return this._texturePool.get(e);let s=new ii;return s.flipY=r,await s.load(e,t),this._texturePool.set(e,s),s}async loadHDRTexture(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Go;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadHDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ea;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadLDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ra;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadTextureCubeMaps(e){let t=e[0];if(this._texturePool.has(t))return this._texturePool.get(t);let r=new ko;return await r.load(e),this._texturePool.set(e[0],r),r}async loadTextureCubeStd(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ko;return await r.loadStd(e),r}async loadJSON(e,t){return await new ht().loadJson(e,t).then(async r=>r).catch(r=>{console.log(r)})}async loadFont(e,t,r){let a=await new ht().load(e,Jo,t,r),n=a.data;return gr.addFontData(n.face,n.size,n),a.data}async loadAtlas(e,t){return(await new ht().load(e,Zo,t,e)).data}createTexture(e,t,r,s,a,n,l){let h=32,u=32,c=new Uint8Array(h*u*4);this.fillColor(c,e,t,r,s,a,n);let f=new Vu;return f.name=l,f.create(16,16,c,!0),l&&this.addTexture(l,f),f}fillColor(e,t,r,s,a,n,l){for(let h=0;h<t;h++)for(let u=0;u<r;u++){let c=u*t+h;e[c*4+0]=s,e[c*4+1]=a,e[c*4+2]=n,e[c*4+3]=l}}initDefault(){this.normalTexture=this.createTexture(32,32,255*.5,255*.5,255,255,"default-normalTexture"),this.maskTexture=this.createTexture(32,32,255,255*.5,0,255,"default-maskTexture"),this.whiteTexture=this.createTexture(32,32,255,255,255,255,"default-whiteTexture"),this.blackTexture=this.createTexture(32,32,0,0,0,255,"default-blackTexture"),this.redTexture=this.createTexture(32,32,255,0,0,255,"default-redTexture"),this.blueTexture=this.createTexture(32,32,0,0,255,255,"default-blueTexture"),this.greenTexture=this.createTexture(32,32,0,255,0,255,"default-greenTexture"),this.yellowTexture=this.createTexture(32,32,0,255,255,255,"default-yellowTexture"),this.grayTexture=this.createTexture(32,32,128,128,128,255,"default-grayTexture");let t=new Qu().generateBRDFLUTTexture(),r=t.name="BRDFLUT";this.addTexture(r,t),this.defaultSky=new ea,this.defaultSky.createFromTexture(128,this.blackTexture),se.getInstance().attached(this.defaultSky,this),se.getInstance().attached(t,this),se.getInstance().attached(this.normalTexture,this),se.getInstance().attached(this.maskTexture,this),se.getInstance().attached(this.whiteTexture,this),se.getInstance().attached(this.blackTexture,this),se.getInstance().attached(this.redTexture,this),se.getInstance().attached(this.blueTexture,this),se.getInstance().attached(this.greenTexture,this),se.getInstance().attached(this.yellowTexture,this),se.getInstance().attached(this.grayTexture,this),this.defaultGUITexture=new dr(this.whiteTexture),this.defaultGUISprite=new fr(this.defaultGUITexture),this.defaultGUISprite.trimSize.set(4,4)}}class ye{}o(ye,"pixelRatio",1),o(ye,"solution",new Z(1600,1280)),o(ye,"quadMaxCountForWorld",256),o(ye,"quadMaxCountForView",2048),o(ye,"SortOrderStartWorld",7e3),o(ye,"SortOrderStartView",8e3),o(ye,"SortOrderCanvasSpan",1e4);var Nt=(i=>(i[i.View=0]="View",i[i.World=2]="World",i))(Nt||{}),pr=(i=>(i[i.Simple=0]="Simple",i[i.Sliced=1]="Sliced",i[i.Tiled=2]="Tiled",i[i.Filled=3]="Filled",i))(pr||{}),xi=(i=>(i[i.None=0]="None",i[i.BillboardY=9]="BillboardY",i[i.BillboardXYZ=10]="BillboardXYZ",i))(xi||{});class A{static get frameRate(){return this._frameRate}static set frameRate(e){this._frameRate=e,this._frameRateValue=1/e,e>=360&&(this._frameRateValue=0)}static get size(){return S.presentationSize}static get aspect(){return S.aspect}static get width(){return S.windowWidth}static get height(){return S.windowHeight}static async init(e={}){console.log("Engine Version",Hf),this.divB=document.createElement("div"),this.divB.style.position="absolute",this.divB.style.zIndex="999",this.divB.style.color="#FFFFFF",this.divB.style.top="150px",document.body.appendChild(this.divB),this.setting={...this.setting,...e.engineSetting},await ee.init(V.allocCount),await S.init(e.canvasConfig),N.init(),Ot.init(),pe.init(),Fe.init(),Ve.init(),this.res=new qu,this._beforeRender=e.beforeRender,this._renderLoop=e.renderLoop,this._lateRender=e.lateRender,this.inputSystem=new In,this.inputSystem.initCanvas(S.canvas)}static startRenderView(e){this.renderJobs||(this.renderJobs=new Map),this.views=[e];let t=new wo(e);return this.renderJobs.set(e,t),t.addPost(new uo),t.start(),this.resume(),t}static startRenderViews(e){this.renderJobs||(this.renderJobs=new Map),this.views=e;for(let t=0;t<e.length;t++){const r=e[t];let s=new wo(r);this.renderJobs.set(r,s),s.addPost(new uo),s.start()}this.resume()}static getRenderJob(e){return this.renderJobs.get(e)}static pause(){this._requestAnimationFrameID!=0&&(cancelAnimationFrame(this._requestAnimationFrameID),this._requestAnimationFrameID=0)}static resume(){this._requestAnimationFrameID=requestAnimationFrame(e=>this.render(e))}static render(e){this._deltaTime=e-this._time,this._time=e,this._frameRateValue>0?(this._frameTimeCount+=this._deltaTime*.001,this._frameTimeCount>=this._frameRateValue*.95&&(this._frameTimeCount=0,this.updateFrame(e))):this.updateFrame(e),this.resume()}static updateGUIPixelRatio(e,t){let r=ye.solution.x/ye.solution.y,s=e/t;r<s?ye.pixelRatio=t/ye.solution.y:ye.pixelRatio=e/ye.solution.x}static updateFrame(e){he.delta=e-he.time,he.time=e,he.frame+=1,So.tick(he.delta);let t=this.views,r=0;for(r=0;r<t.length;r++){const n=t[r];n.scene.waitUpdate(),n.camera.resetPerspective(S.aspect)}this.updateGUIPixelRatio(S.canvas.clientWidth,S.canvas.clientHeight),this._beforeRender&&this._beforeRender();for(const n of ae.componentsBeforeUpdateList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l)}}let s=S.device.createCommandEncoder();for(const n of ae.componentsComputeList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l,s)}}S.device.queue.submit([s.finish()]);for(const n of ae.componentsUpdateList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l)}}this._renderLoop&&this._renderLoop(),ee.updateAllContinueTransform(0,V.useCount,16),pe.modelMatrixBindGroup.writeBuffer(V.useCount*16),this.renderJobs.forEach((n,l)=>{n.renderFrame()});for(const n of ae.componentsLateUpdateList){let l=n[0],h=n[1];for(const u of h){let c=u[0],f=u[1];c.enable&&f(l)}}this._lateRender&&this._lateRender()}}o(A,"res"),o(A,"inputSystem"),o(A,"views"),o(A,"_frameRateValue",0),o(A,"_frameRate",360),o(A,"_frameTimeCount",0),o(A,"_deltaTime",0),o(A,"_time",0),o(A,"_beforeRender"),o(A,"_renderLoop"),o(A,"_lateRender"),o(A,"_requestAnimationFrameID",0),o(A,"Engine3D"),o(A,"divB"),o(A,"setting",{occlusionQuery:{enable:!0,debug:!1},pick:{enable:!0,mode:"bound",detail:"mesh"},render:{debug:!1,renderPassState:4,renderState_left:5,renderState_right:5,renderState_split:.5,quadScale:1,hdrExposure:1.5,debugQuad:-1,maxPointLight:1e3,maxDirectLight:4,maxSportLight:1e3,drawOpMin:0,drawOpMax:Number.MAX_SAFE_INTEGER,drawTrMin:0,drawTrMax:Number.MAX_SAFE_INTEGER,zPrePass:!1,useLogDepth:!1,gi:!1,postProcessing:{globalFog:{debug:!1,enable:!1,fogType:0,fogHeightScale:.1,start:400,end:10,density:.02,ins:.5,skyFactor:.5,skyRoughness:.4,overrideSkyFactor:.8,fogColor:new z(112/255,61/255,139/255,1),falloff:.7,rayLength:200,scatteringExponent:2.7,dirHeightLine:10},ssao:{enable:!1,radius:.15,bias:-.1,aoPower:2,debug:!0},outline:{enable:!1,strength:1,groupCount:4,outlinePixel:2,fadeOutlinePixel:4,textureScale:.7,useAddMode:!1,debug:!0},taa:{enable:!1,jitterSeedCount:8,blendFactor:.1,sharpFactor:.6,sharpPreBlurFactor:.5,temporalJitterScale:.13,debug:!0},gtao:{enable:!1,darkFactor:1,maxDistance:5,maxPixel:50,rayMarchSegment:6,multiBounce:!1,usePosFloat32:!0,blendColor:!0,debug:!0},ssr:{enable:!1,pixelRatio:1,fadeEdgeRatio:.2,rayMarchRatio:.5,fadeDistanceMin:600,fadeDistanceMax:2e3,roughnessThreshold:.5,powDotRN:.2,mixThreshold:.1,debug:!0},bloom:{enable:!1,blurX:4,blurY:4,strength:.25,exposure:1,radius:1.3,luminosityThreshold:.98,debug:!1},fxaa:{enable:!1},depthOfView:{enable:!1,iterationCount:3,pixelOffset:1,near:150,far:300}}},shadow:{enable:!0,type:"HARD",pointShadowBias:.002,shadowSize:1024,pointShadowSize:1024,shadowSoft:.005,needUpdate:!0,autoUpdate:!0,updateFrameRate:2,csmMargin:.1,csmScatteringExp:.7,csmAreaScale:.4,debug:!1},gi:{enable:!1,offsetX:0,offsetY:0,offsetZ:0,probeSpace:64,probeXCount:4,probeYCount:2,probeZCount:4,probeSize:32,probeSourceTextureSize:2048,octRTMaxSize:2048,octRTSideSize:16,maxDistance:64*1.73,normalBias:.25,depthSharpness:1,hysteresis:.98,lerpHysteresis:.01,irradianceChebyshevBias:.01,rayNumber:144,irradianceDistanceBias:32,indirectIntensity:1,ddgiGamma:2.2,bounceIntensity:.025,probeRoughness:1,realTimeGI:!1,debug:!1,autoRenderProbe:!1},sky:{type:"HDRSKY",sky:null,skyExposure:1,defaultFar:65536,defaultNear:1},light:{maxLight:4096},material:{materialChannelDebug:!1,materialDebug:!1}}),o(A,"renderJobs");let Yg=`
#include "GlobalUniform"

struct UniformData {
  radius: f32 ,
  bias: f32,
  aoPower: f32 ,
  blurSize: f32 ,
};

// @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(0) var<uniform> uniformData: UniformData;
@group(0) @binding(1) var colorMap : texture_2d<f32>;
// @group(0) @binding(2) var ssaoMapSampler : sampler;
@group(0) @binding(2) var ssaoMap : texture_2d<f32>;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

@compute @workgroup_size( 8 , 8 )
fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  var fragCoord = vec2<i32>( globalInvocation_id.xy );

  var texSize = vec2<f32>(textureDimensions(ssaoMap).xy);
  var texCoord = vec2<f32>(fragCoord) / texSize ;

  let blurSize = i32(uniformData.blurSize);

  var result = vec4<f32>(0.0) ;
  var ii = 0.0 ;
  for (var i = -2; i < 2 ; i+=1) {
     for (var j = -2; j < 2 ; j+=1) {
        var offset = vec2<i32>( i , j ) ;
        result += textureLoad(ssaoMap, fragCoord + offset, 0 );
        // result += textureSampleLevel(ssaoMap,ssaoMapSampler, vec2<f32>( fragCoord + offset) / texSize , 0.0 );
        ii += 1.0 ;
     }
  }
  var fResult = result.r / ii ;
  var color = textureLoad(colorMap, fragCoord , 0 );
  textureStore(outTex, fragCoord , vec4(color.rgb * fResult,1.0) );
}
`,Ku=`
#include "GlobalUniform"

  struct BlurSetting{
    near: f32,
    far: f32,
    pixelOffset: f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> blurSetting: BlurSetting;

  @group(0) @binding(2) var positionBufferTex : texture_2d<f32>;
  @group(0) @binding(3) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(4) var inTexSampler : sampler;
  @group(0) @binding(5) var inTex : texture_2d<f32>;
  @group(0) @binding(6) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> cameraPosition: vec3<f32>;
  var<private> texSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> texelSize: vec2<f32>;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(inTex).xy;
    texelSize = 1.0 / vec2<f32>(texSize - 1);
    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    let wPosition:vec3<f32> = textureLoad(positionBufferTex, fragCoord , 0).xyz;
    var distance = length(wPosition - cameraPosition);
    var oc:vec4<f32> = textureLoad(inTex, fragCoord, 0);
    if(distance > blurSetting.near){
        let normal = textureLoad(normalBufferTex, fragCoord, 0);
        var pixelScale = 0.5;
        if(normal.w > 0.5){
            distance = min(distance, blurSetting.far);
            pixelScale = (distance - blurSetting.near) / (blurSetting.far - blurSetting.near);
        }
        oc = mixBlurColor(oc, fragCoord, blurSetting.pixelOffset, pixelScale);
    }
    textureStore(outTex, fragCoord, oc);
  }

  fn mixBlurColor(orginColor:vec4<f32>, coord:vec2<i32>, pixelOffset:f32, scale:f32) -> vec4<f32> {

    let uv = vec2<f32>(coord);
    var uv0 = (uv + scale * vec2<f32>( pixelOffset,  pixelOffset)) * texelSize;
    var uv1 = (uv + scale * vec2<f32>(-pixelOffset,  pixelOffset)) * texelSize;
    var uv2 = (uv + scale * vec2<f32>(-pixelOffset, -pixelOffset)) * texelSize;
    var uv3 = (uv + scale * vec2<f32>( pixelOffset, -pixelOffset)) * texelSize;

    uv0.x = processUVEdge(uv0.x);
    uv0.y = processUVEdge(uv0.y);
    uv1.x = processUVEdge(uv1.x);
    uv1.y = processUVEdge(uv1.y);
    uv2.x = processUVEdge(uv2.x);
    uv2.y = processUVEdge(uv2.y);
    uv3.x = processUVEdge(uv3.x);
    uv3.y = processUVEdge(uv3.y);

    var ob = vec4<f32>(0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv0, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv1, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv2, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv3, 0.0);
    return mix(orginColor, ob * 0.25, scale);
  }

  fn processUVEdge(v: f32) -> f32{
      var value = v;
      if(value < 0.0){
        value = - value;
      }else if(value > 1.0){
        value = 2.0 - value;
      }
      return value;
  }
`,Ju=`
    #include "GlobalUniform"
    
    struct GTAO{
      maxDistance: f32,
      maxPixel: f32,
      darkFactor: f32,
      rayMarchSegment: f32,
      cameraNear: f32,
      cameraFar: f32,
      multiBounce: f32,
      blendColor: f32,
    }

    @group(0) @binding(1) var<uniform> gtaoData: GTAO;
    @group(0) @binding(2) var<storage, read_write> directions : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read_write> aoBuffer : array<f32>;

    @group(0) @binding(4) var posTex : texture_2d<f32>;
    @group(0) @binding(5) var normalTex : texture_2d<f32>;
    @group(0) @binding(6) var inTex : texture_2d<f32>;
    @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> maxPixelScaled: f32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      let index = fragCoord.x + fragCoord.y * i32(texSize.x);
      let lastFactor = aoBuffer[index];
      var newFactor = 0.0;
      if(wNormal.w < 0.5){//sky
          
      }else{
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          let ndc = globalUniform.projMat * globalUniform.viewMat * vec4<f32>(wPosition, 1.0);
          let ndcZ = ndc.z / ndc.w;
          maxPixelScaled = calcPixelByNDC(ndcZ);
          newFactor = rayMarch();
      }
      
      var factor:f32 = mix(lastFactor, newFactor, 0.6);
      aoBuffer[index] = factor;
      factor = blurFactor(factor);
      factor = saturate(1.0 - factor * gtaoData.darkFactor);
      var gtao = vec3<f32>(factor);
      if(gtaoData.multiBounce > 0.5){
          gtao = MultiBounce(factor, oc.xyz);
      }
      
      var outColor = gtao;
      if(gtaoData.blendColor > 0.5){
          outColor = oc.xyz * gtao;
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }
    
    fn MultiBounce(AO:f32, Albedo:vec3<f32>) -> vec3<f32>
    {
        var A = 2 * Albedo - 0.33;
        var B = -4.8 * Albedo + 0.64;
        var C = 2.75 * Albedo + 0.69;
        return max(vec3<f32>(AO), ((AO * A + B) * AO + C) * AO);
    }
    
    fn calcPixelByNDC(ndcZ:f32) -> f32{
      let nearAspect = gtaoData.cameraNear / (gtaoData.cameraFar - gtaoData.cameraNear);
      let aspect = (1.0 + nearAspect) / (ndcZ + nearAspect);
      var viewPortMax = min(f32(texSize.x), f32(texSize.y));
      var maxPixel = min(viewPortMax, gtaoData.maxPixel * aspect);
      maxPixel = max(0.1, maxPixel);
      return maxPixel;
    }
    
    fn blurFactor(centerFactor:f32) -> f32{
      var coord0 = clamp(fragCoord + vec2<i32>(1, 0) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord1 = clamp(fragCoord + vec2<i32>(-1, 0), vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord2 = clamp(fragCoord + vec2<i32>(0, 1) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord3 = clamp(fragCoord + vec2<i32>(0, -1), vec2<i32>(0), vec2<i32>(texSize - 1));
      var index0 = coord0.x + coord0.y * i32(texSize.x);
      var index1 = coord1.x + coord1.y * i32(texSize.x);
      var index2 = coord2.x + coord2.y * i32(texSize.x);
      var index3 = coord3.x + coord3.y * i32(texSize.x);
      let factor0:f32 = aoBuffer[index0];
      let factor1:f32 = aoBuffer[index1];
      let factor2:f32 = aoBuffer[index2];
      let factor3:f32 = aoBuffer[index3];
      var factor = 0.25 * (factor0 + factor1 + factor2 + factor3);
      factor = mix(factor, centerFactor, 0.8);
      return factor;
    }
    
    fn rayMarch() -> f32{
      let originNormal = normalize(vec3<f32>(wNormal.xyz) * 2.0 - 1.0);
      let stepPixel = maxPixelScaled / gtaoData.rayMarchSegment;
      var weight:f32 = 0.0;
      var totalWeight:f32 = 0.1;
      for(var i:i32 = 0; i < 8; i += 1){
          let dirVec2 = directions[i];
          for(var j:f32 = 1.1; j < maxPixelScaled; j += stepPixel){
              var sampleCoord = vec2<i32>(dirVec2 * j) + fragCoord;
              if(sampleCoord.x >= 0 && sampleCoord.y >= 0 
                && sampleCoord.x < i32(texSize.x) 
                && sampleCoord.y < i32(texSize.y) )
              {
                totalWeight += 1.0;
                let samplePosition = textureLoad(posTex, sampleCoord, 0).xyz;
                let distanceVec2 = samplePosition - wPosition;
                let distance = length(distanceVec2);
                if(distance < gtaoData.maxDistance && distance > 1.0){
                  let sampleDir = normalize(distanceVec2);
                  var factor = saturate(dot(sampleDir, originNormal) - 0.1);
                  factor *= 1.0 - distance / gtaoData.maxDistance;
                  weight += factor;
                }
              }
          }
      }
      weight /= totalWeight;
      return weight;
    }
  `,Zu=`

    #include "GlobalUniform"
    struct LightData {
      index:f32,
      lightType:i32,
      radius:f32,
      linear:f32,
      
      position:vec3<f32>,
      lightMatrixIndex:f32,

      direction:vec3<f32>,
      quadratic:f32,

      lightColor:vec3<f32>,
      intensity:f32,

      innerCutOff :f32,
      outerCutOff:f32,
      range :f32,
      castShadow:i32,

      lightTangent:vec3<f32>,
      ies:f32,
    };

    struct Uniforms {
      matrix : array<mat4x4<f32>>
    };

    struct CacheGodRay {
      pos:vec3<f32>,
      value:f32,
    };

    struct GodRayUniform{
      intensity: f32,
      rayMarchCount: f32,
      viewPortWidth: f32,
      viewPortHeight: f32,

      blendColor: f32,
      scatteringExponent: f32,
    }

    @group(0) @binding(1) var<uniform> godRayUniform: GodRayUniform;
    @group(0) @binding(2) var posTex : texture_2d<f32>;
    @group(0) @binding(3) var normalTex : texture_2d<f32>;
    @group(0) @binding(4) var inTex : texture_2d<f32>;
    @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;
    @group(0) @binding(6) var shadowMapSampler : sampler_comparison;
    @group(0) @binding(7) var shadowMap : texture_depth_2d_array;

    @group(1) @binding(0)
    var<storage,read> lightBuffer: array<LightData>;
    @group(1) @binding(1)
    var<storage, read> models : Uniforms;

    @group(2) @binding(0) var<storage, read_write> historyGodRayData: array<CacheGodRay>;
    
    struct ShadowStruct{
      directShadowVisibility:f32,
      pointShadows:array<f32,8>,
     }

    var<private> viewDirection: vec3<f32> ;
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> directLight: LightData;
    var<private> shadowStrut: ShadowStruct ;

    const csmCount:i32 = ${lt.Cascades} ;
    fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
      let enableCSM:bool = globalUniform.enableCSM > 0.5;
      var light = lightBuffer[0];
      var visibility = 1.0;
      var shadowIndex = i32(light.castShadow);
      if (shadowIndex >= 0 ) {
        var shadowMatrix:mat4x4<f32>;
        if(enableCSM && csmCount > 1){
          for(var csm:i32 = 0; csm < csmCount; csm ++){
            var csmShadowBias = globalUniform.csmShadowBias[csm];
            shadowMatrix = globalUniform.csmMatrix[csm];
            let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
            if(csmShadowResult.y < 0.5){
              visibility = csmShadowResult.x;
              break;
            }
          }
        }else{
          shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
          visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
        }
      }
      shadowStrut.directShadowVisibility = visibility;
    }
    
    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var NoL = abs(dot(N, normalize(light.direction)));
        var bias = shadowBias / max(NoL, 0.000001);
        visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
        visibility += 0.001;
      }
      return vec2<f32>(visibility, isOutSideArea);
    }

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );

      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      var outColor = oc.xyz;
      directLight = lightBuffer[0] ;
      if(directLight.castShadow >= 0){
        let index = fragCoord.x + fragCoord.y * i32(texSize.x);
        var historyData = historyGodRayData[index];
        let lightColor = directLight.lightColor;
        
        var godRayFactor = 0.0;
        if(wNormal.w > 0.5){
          //not sky
          let lightPos = models.matrix[u32(directLight.lightMatrixIndex)][3].xyz;
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          viewDirection = normalize(globalUniform.CameraPos - wPosition) ;
          godRayFactor = rayMarch();
          godRayFactor = updateGodRay(historyData, godRayFactor);
        }
        historyData.pos = wPosition;
        historyData.value = godRayFactor;
        historyGodRayData[index] = historyData;

        outColor = oc.xyz + vec3<f32>(godRayFactor * godRayUniform.intensity * lightColor);
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }

    fn updateGodRay(historyData:CacheGodRay, newFactor:f32) -> f32 {
      var changeFactor = 0.2;
      if(length(historyData.pos - wPosition) > 0.01){
        changeFactor = 0.4;
      }
      var factor = mix(historyData.value, newFactor, changeFactor);
      
      let pixelOffset = 1 + i32(globalUniform.frame) % 3;
      let coordRange = vec2<i32>(texSize);
      let coordIndex0 = getCoordIndex(fragCoord.x + pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex1 = getCoordIndex(fragCoord.x - pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex2 = getCoordIndex(fragCoord.x, fragCoord.y + pixelOffset * 2, coordRange);

      let oldOC0 = historyGodRayData[coordIndex0].value;
      let oldOC1 = historyGodRayData[coordIndex1].value;
      let oldOC2 = historyGodRayData[coordIndex2].value;

      let opRound = (oldOC0 + oldOC1 + oldOC2) * 0.3333333;
      factor = mix(opRound, factor, 0.5);

      return factor;
    }

    fn getCoordIndex(x0:i32, y0:i32, size:vec2<i32>) -> i32{
      let x = clamp(x0, 0, size.x - 1);
      let y = clamp(y0, 0, size.y - 1);
      return y * size.x + x;
    }
    
    
    fn rayMarch() -> f32{
      var godRayFactor = 0.0;
      let L = normalize(directLight.direction);
      let rayMarchCount = godRayUniform.rayMarchCount;
      if(godRayUniform.blendColor > 0.5){
        let eyePosition = globalUniform.CameraPos;
        var samplePosition = eyePosition;
        var lastSamplePosition = eyePosition;
        
        var frameOffset = f32(i32(globalUniform.frame) % 4);
        frameOffset *= 0.25;
        var N = normalize(wNormal.xyz);
        for(var i:f32 = 1.0; i < rayMarchCount; i += 1.0){
          var t = (i + frameOffset) / rayMarchCount;
          lastSamplePosition = samplePosition;
          samplePosition = mix(eyePosition, wPosition, t * t);

          // var shadowVisibility = directionShadowMapping(samplePosition, globalUniform.shadowBias);
          directShadowMaping(samplePosition.xyz, N, globalUniform.shadowBias);
          var shadowVisibility = shadowStrut.directShadowVisibility;
          if(shadowVisibility > 0.5){
            var stepFactor = calcGodRayValue(samplePosition, L, viewDirection);
            stepFactor *= length(lastSamplePosition - samplePosition);
            godRayFactor += stepFactor;
          }
        }
        godRayFactor /= length(wPosition - eyePosition);
      }
      return godRayFactor;
    }

    fn calcGodRayValue(pos:vec3<f32>, L:vec3<f32>, V:vec3<f32>) -> f32{
      var halfLoV = normalize(L + V);
      var LoV = saturate(dot(V,halfLoV));
      LoV = pow(LoV, godRayUniform.scatteringExponent);
      var distance = length(pos - globalUniform.CameraPos) / (globalUniform.far);
      distance = 1.0 - saturate(distance);
      distance *= distance;
      return LoV * distance;
    }
  `,$u=`
    @group(0) @binding(0) var textureR : texture_2d<f32>;
    @group(0) @binding(1) var textureG : texture_2d<f32>;
    @group(0) @binding(2) var textureB : texture_2d<f32>;
    @group(0) @binding(3) var textureA : texture_2d<f32>;
    @group(0) @binding(4) var outTex : texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let size = textureDimensions(outTex);
        let fragCoord : vec2<i32> = vec2<i32>(GlobalInvocationID.xy); 
        var uv:vec2<f32>;
        uv.x = f32(fragCoord.x)/f32(size.x);
        uv.y = f32(fragCoord.y)/f32(size.y);
        var oc:vec4<f32> = textureSampleLevel(atlasTexture, atlasTextureSampler, targetUV, 0.0);

        let sizeR = textureDimensions(textureR);
        let sizeG = textureDimensions(textureG);
        let sizeB = textureDimensions(textureB);
        let sizeA = textureDimensions(textureA);
        
        var tr = textureLoad(textureR, vec2<i32>(uv * sizeR) , 0 ) ;
        var tg = textureLoad(textureG, vec2<i32>(uv * sizeG) , 0 ) ;
        var tb = textureLoad(textureB, vec2<i32>(uv * sizeB) , 0 ) ;
        var ta = textureLoad(textureA, vec2<i32>(uv * sizeA) , 0 ) ;

        let color = vec4<f32>(tr,tg,tb,ta);
        textureStore(outTex, fragCoord , vec4(color));
    }

`,ec=`
   struct OutlineSettingData{
      strength: f32,
      useAddMode: f32,
      outlinePixel: f32,
      fadeOutlinePixel: f32,
      lowTexWidth: f32,
      lowTexHeight: f32,
      slot0: f32,
      slot1: f32,
   }

   @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
   @group(0) @binding(1) var inTex : texture_2d<f32>;
   @group(0) @binding(2) var lowTexSampler : sampler;
   @group(0) @binding(3) var lowTex : texture_2d<f32>;
   @group(0) @binding(4) var outlineTex : texture_storage_2d<rgba16float, write>;
   
   var<private> texSize: vec2<u32>;
   var<private> fragCoord: vec2<i32>;

   @compute @workgroup_size( 8 , 8 , 1 )
   fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
   {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outlineTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
         return;
      }

      var uv01 = vec2<f32>(fragCoord) / (vec2<f32>(texSize) - 1.0);
      var offset = vec2<f32>(texSize) / vec2<f32>(outlineSetting.lowTexWidth, outlineSetting.lowTexHeight);
      offset = 0.5 * offset / (vec2<f32>(texSize) - 1.0);
      uv01 += offset;
      var outLineColor = textureSampleLevel(lowTex, lowTexSampler, uv01, 0.0);

      outLineColor.x *= outlineSetting.strength;
      outLineColor.y *= outlineSetting.strength;
      outLineColor.z *= outlineSetting.strength;

      var inColor = textureLoad(inTex, fragCoord, 0);
      var blendColor:vec3<f32> = vec3<f32>(0.0);
      if(outlineSetting.useAddMode > 0.5){
         blendColor = inColor.xyz + outLineColor.xyz * outLineColor.w;
      }else{
         blendColor = mix(inColor.xyz, outLineColor.xyz, outLineColor.w);
      }
      textureStore(outlineTex, fragCoord, vec4<f32>(blendColor, inColor.w));
   }

`,tc=`
  struct OutlineSettingData{
    strength: f32,
    useAddMode: f32,
    outlinePixel: f32,
    fadeOutlinePixel: f32,
    lowTexWidth: f32,
    lowTexHeight: f32,
    slot0: f32,
    slot1: f32,
  }

  struct OutlineSlotData{
    color: vec3<f32>,
    count: f32,
  }

  struct OutlineWeightData{
    slotIndex:f32,
    outerSlotIndex:f32,
    entityIndex:f32,
    weight:f32
  }

  struct OutlineEntities{
    list: array<f32, 16u>,
  }

  @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
  @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
  @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
  @group(0) @binding(3) var<storage, read_write> entitiesBuffer : array<OutlineEntities>;
  @group(0) @binding(4) var indexTexture : texture_2d<f32>;

  var<private> texSize: vec2<u32>;
  var<private> lowSize: vec2<i32>;
  var<private> fragCoord: vec2<i32>;
  var<private> fragCoordLow: vec2<i32>;
  var<private> coordIndex: i32;

  var<private> fragOutline: OutlineWeightData;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoordLow = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(indexTexture).xy;
    lowSize = vec2<i32>(i32(outlineSetting.lowTexWidth), i32(outlineSetting.lowTexHeight));
    let scaleValue = f32(texSize.x) / f32(lowSize.x);
    fragCoord.x = i32(f32(fragCoordLow.x) * scaleValue);
    fragCoord.y = i32(f32(fragCoordLow.y) * scaleValue);

    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    if(fragCoordLow.x >= lowSize.x || fragCoordLow.y >= lowSize.y){
        return;
    }
    
    coordIndex = fragCoordLow.x + fragCoordLow.y * lowSize.x;
    fragOutline = weightBuffer[coordIndex];
    var wPos = textureLoad(indexTexture, fragCoord, 0 ) ;
    
    fragOutline.entityIndex = round(wPos.w);
    fragOutline.slotIndex = -1.0;
    fragOutline.outerSlotIndex = -1.0;
    fragOutline.weight = 0.0;
    
    if(fragOutline.entityIndex >= 0.0){
      fragOutline.slotIndex = f32(matchOutlineSlot());
    }
    weightBuffer[coordIndex] = fragOutline;
  }

  fn matchOutlineSlot() -> i32
  {
    for(var i:i32 = 0; i < 8; i ++){
        var slotData:OutlineSlotData = slotsBuffer[i];
        var entities:array<f32, 16u> = entitiesBuffer[i].list;
        let count:i32 = i32(slotData.count);
        for(var j:i32 = 0; j < count; j ++){
            var outlineIndex = entities[j];
            if(abs(fragOutline.entityIndex - outlineIndex) < 0.1){ 
                return i;
            }
        }
    }
    return -1;
  }
`,ic=`
    struct OutlineSettingData{
        strength: f32,
        useAddMode: f32,
        outlinePixel: f32,
        fadeOutlinePixel: f32,
        lowTexWidth: f32,
        lowTexHeight: f32,
        slot0: f32,
        slot1: f32,
    }
    
    struct OutlineSlotData{
        color: vec3<f32>,
        count: f32,
    }
    
    struct OutlineWeightData{
        slotIndex:f32,
        outerSlotIndex:f32,
        entityIndex:f32,
        weight:f32
    }

    @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
    @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
    @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
    @group(0) @binding(3) var<storage, read_write> oldOutlineColor : array<vec4<f32>>;
    @group(0) @binding(4) var lowTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    var<private> fragOutline: OutlineWeightData;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        fragCoord = vec2<i32>( globalInvocation_id.xy );
        texSize = textureDimensions(lowTex).xy;
        if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
            return;
        }
        
        coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
        fragOutline = weightBuffer[coordIndex];
        
        var newOC = vec4<f32>(0.0);
        
        calcOutline();
        let outerSlotIndex:i32 = i32(round(fragOutline.outerSlotIndex));
        if(outerSlotIndex >= 0){
            let outLineColor = slotsBuffer[outerSlotIndex].color;
            newOC = vec4<f32>(outLineColor, fragOutline.weight);
        }
        
        let coordIndex0 = fragCoord.x + 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex1 = fragCoord.x - 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex2 = fragCoord.x + (fragCoord.y - 1) * i32(texSize.x);

        let oldOC = oldOutlineColor[coordIndex];
        let oldOC0 = oldOutlineColor[coordIndex0];
        let oldOC1 = oldOutlineColor[coordIndex1];
        let oldOC2 = oldOutlineColor[coordIndex2];
        
        newOC = mix((oldOC + oldOC0 + oldOC1 + oldOC2) * 0.25, newOC, 0.5);
        oldOutlineColor[coordIndex] = newOC;
        textureStore(lowTex, fragCoord, newOC);
    }
    
    fn calcOutline()
    {
        let outlinePixel = outlineSetting.outlinePixel;
        let pixelRadius = outlinePixel + outlineSetting.fadeOutlinePixel;
        let minX = max(0.0, f32(fragCoord.x) - pixelRadius);
        let maxX = min(f32(texSize.x), f32(fragCoord.x) + pixelRadius);
        let minY = max(0.0, f32(fragCoord.y) - pixelRadius);
        let maxY = min(f32(texSize.y), f32(fragCoord.y) + pixelRadius);
        var coordTemp_f32 = vec2<f32>(0.0);
        var coordCurrent_f32 = vec2<f32>(fragCoord);
        var tempCoordIndex = 0;
        var tempWeightData: OutlineWeightData;
        for(var x:f32 = minX; x < maxX; x += 1.0){
            for(var y:f32 = minY; y < maxY; y += 1.0){
                coordTemp_f32.x = x;
                coordTemp_f32.y = y;
                let distanceToOuter = length(coordTemp_f32 - coordCurrent_f32);
                if(distanceToOuter < pixelRadius){
                    var coord_i32 = vec2<i32>(coordTemp_f32);
                    tempCoordIndex = coord_i32.x + coord_i32.y * i32(texSize.x);
                    tempWeightData = weightBuffer[tempCoordIndex];
                    let outlineGap = abs(tempWeightData.slotIndex - fragOutline.slotIndex);
                    if(outlineGap > 0.1){
                        if(tempWeightData.slotIndex > fragOutline.slotIndex){
                            if(abs(tempWeightData.slotIndex - fragOutline.outerSlotIndex) < 0.1){
                                fragOutline.weight = max(fragOutline.weight, calcWeight(pixelRadius, distanceToOuter, outlinePixel));
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }else if(tempWeightData.slotIndex > fragOutline.outerSlotIndex){
                                fragOutline.weight = calcWeight(pixelRadius, distanceToOuter, outlinePixel);
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }
                        }
                    }
                }
            }
        }
    }
    
    fn calcWeight(totalRadius:f32, distance:f32, innerRadius:f32) -> f32{
        if(distance < innerRadius){
            return 1.0;
        }
        var ret = 1.0 - (distance - innerRadius)  / (totalRadius - innerRadius);

        return ret;
    }
`,rc=`

    #include "GlobalUniform"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,
        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,
    }

    //@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
    @group(0) @binding(1) var<storage,read_write> outBuffer: PickResult;
    @group(0) @binding(2) var visibleMap : texture_2d<f32>;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    // result.pick_meshID
    let texSize = textureDimensions(visibleMap).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy); 
    let info = textureLoad(visibleMap, vec2<i32>(mouseUV) , 0);

    outBuffer.pick_meshID = f32(info.w) ;
    outBuffer.pick_meshID2 = f32(info.w) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    outBuffer.pick_Position = vec4<f32>(info.xyzw) ;
    outBuffer.pick_Normal = vec4<f32>(info.xyzw) ;
    }
`,Xg=`
#include "GlobalUniform"
  struct UniformData {
    radius: f32 ,
    bias: f32,
    aoPower: f32 ,
    blurSize: f32 ,
  };

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> uniformData: UniformData;
  @group(0) @binding(2) var<storage,read> sampleData: array<vec4<f32>>;

  // @group(0) @binding(3) var colorMap : texture_2d<f32>;
  @group(0) @binding(3) var positionMap : texture_2d<f32>;
  @group(0) @binding(4) var normalMap : texture_2d<f32>;

  @group(0) @binding(5) var noiseMapSampler: sampler;
  @group(0) @binding(6) var noiseMap : texture_2d<f32>;

  @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> kernelSize: i32 = 32 ;

  @compute @workgroup_size( 8 , 8 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    var fragCoord = vec2<i32>( globalInvocation_id.xy );

    var texSize = textureDimensions(positionMap).xy;
    var texCoord = vec2<f32>(fragCoord) / vec2<f32>(texSize);

    var fragColor = vec4<f32>(1.0);

    var viewMat = standUniform.viewMat  ;
    // var color = textureLoad(colorMap, fragCoord , 0 ) ;
    var wPos = textureLoad(positionMap, fragCoord , 0 ) ;

    var fragPosition = viewMat * vec4<f32>(wPos.xyz,1.0);
    fragPosition = vec4(fragPosition.xyz / fragPosition.w,1.0) ;

    var texNormal = textureLoad(normalMap, fragCoord , 0 ) ;
    var sampleNormal = texNormal.xyz ;
    sampleNormal = sampleNormal * 2.0 - 1.0;
    var fragNormal = viewMat * vec4<f32>((sampleNormal.xyz),0.0);

    var pes = vec2<f32>(texSize.xy) / 4.0 ;
    var noiseTex:vec4<f32> = textureSampleLevel(noiseMap, noiseMapSampler, texCoord * pes , 0.0);
    var randomVec  = (viewMat * vec4<f32>(normalize(noiseTex.xyz),0.0)).xyz;

    var tangent = normalize(randomVec - fragNormal.xyz * dot(randomVec , fragNormal.xyz));
    var bTangent = cross(fragNormal.xyz, tangent) + 0.0001 ;
    var tbn = mat3x3<f32>(tangent, bTangent, fragNormal.xyz);

    var offset:vec4<f32>;
    var samplePos :vec3<f32>;
    var offsetPosition:f32;
    var sample_depth_v:vec4<f32>;
    var occlusion:f32 = 0.0;
    var rangeCheck:f32 = 0.0 ;
    var radius:f32 = uniformData.radius * 32.0 * fragPosition.z ;

    for(var i:i32 = 0; i < 32 ; i = i + 1 ){
      samplePos  = (tbn * sampleData[i].xyz ) ;
      samplePos  = fragPosition.xyz + samplePos * radius ;

      offset = vec4(samplePos, 1.0);
      offset = standUniform.projMat * offset;

      var off = offset.xyz / offset.w;
      off = (off.xyz * 0.5 ) + 0.5 ;
      off.y = 1.0 - off.y ;
      var offsetUV = vec2<i32>(off.xy * vec2<f32>(texSize.xy));

      sample_depth_v = textureLoad(positionMap, offsetUV.xy , 0 ) ;
      sample_depth_v = vec4<f32>((viewMat * vec4<f32>(sample_depth_v.xyz,1.0)).xyz,1.0);
      offsetPosition = sample_depth_v.z / sample_depth_v.w ;

      rangeCheck = smoothstep(0.0, 1.0, radius / abs(offsetPosition - fragPosition.z ));
      // rangeCheck = smoothstep(0.0, 1.0, radius / uniformData.bias);

      var a = 1.0 ;
      if(offsetPosition >= (samplePos.z + uniformData.bias)){
        a = 0.0 ;
      }
      a = a * rangeCheck ;
      occlusion = occlusion + a ;
    }

    occlusion = 1.0 - ( occlusion / f32(kernelSize) * texNormal.w );
    occlusion = pow(occlusion, uniformData.aoPower) ;

    // color = color * occlusion ;

    textureStore(outTex, fragCoord , vec4(occlusion));
  }
`,sc=`
@group(0) @binding(0) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(1) var colorMap : texture_2d<f32>;
  @group(0) @binding(2) var ssrMapSampler : sampler;
  @group(0) @binding(3) var ssrMap : texture_2d<f32>;
  @group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> colorTexSize: vec2<u32>;
  var<private> ssrTexSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> ssrCoord: vec2<i32>;

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }
  
  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    colorTexSize = textureDimensions(colorMap).xy;
    ssrTexSize = textureDimensions(ssrMap).xy;
    if(fragCoord.x >= i32(colorTexSize.x) || fragCoord.y >= i32(colorTexSize.y)){
        return;
    }
    let scale:f32 = f32(ssrTexSize.x) / f32(colorTexSize.x);
    ssrCoord = vec2<i32>(vec2<f32>(fragCoord.xy) * scale);
    let index = ssrCoord.x + ssrCoord.y * i32(ssrTexSize.x);
    let hitData = rayTraceBuffer[index];
    var color = textureLoad(colorMap, fragCoord , 0);
    var uv01 = vec2<f32>(f32(fragCoord.x), f32(fragCoord.y));
    uv01 = uv01 / vec2<f32>(colorTexSize - 1);
    
    var ssrColor = textureSampleLevel(ssrMap, ssrMapSampler, uv01, 0.0);
    var tc = mix(color, ssrColor, hitData.fresnel) ;
    var outColor = tc ;
    outColor.a = color.a ; 
    textureStore(outTex, fragCoord , outColor );
  }

`,ac=`
  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(1) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(2) var<storage, read_write> ssrColorData : array<vec4<f32>>;
  @group(0) @binding(3) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(4) var colorMap: texture_2d<f32>;
  @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> ssrBufferCoord: vec2<i32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> bufferData: RayTraceRetData;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> coordIndex: i32;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy );
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));

    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }

    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    bufferData = rayTraceBuffer[coordIndex];
    var oc = vec4<f32>(0.0, 0.0, 0.0, -1.0);
    
    var mixFactor = historyPosition[coordIndex].w;
    
    if(bufferData.alpha >= 0.0 && bufferData.roughness < ssrUniform.roughnessThreshold){
      let roughness = clamp(bufferData.roughness, 0.0, 1.0);
      let prefilterColor = bufferData.skyColor;
      var ssrColor = textureLoad(colorMap, vec2<i32>(bufferData.hitCoord), 0);
      ssrColor.w = bufferData.alpha;
      oc = ssrColor;
    }
    let skyColor = vec4<f32>(bufferData.skyColor, 1.0);
    oc = mix(oc, skyColor, 1.0 - bufferData.alpha);
    
    let lastColor = ssrColorData[coordIndex];
    var newColor = mix(oc, lastColor, mixFactor);
    newColor.w = oc.w;
    
    ssrColorData[coordIndex] = newColor;
    
    textureStore(outTex, ssrBufferCoord , newColor);
  }
`,oc=`
  #include "GlobalUniform"

  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct HitData{
    hitPos:vec3<f32>,
    hitNormal:vec3<f32>,
    fadeAlpha:vec4<f32>,
    hitCoord:vec2<i32>,
    hitResult:i32,
    hitSky:i32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(2) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(4) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(5) var zBufferTexture : texture_2d<f32>;
  @group(0) @binding(6) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(7) var materialBufferTex : texture_2d<f32>;
  @group(0) @binding(8) var prefilterMapSampler: sampler;
  @group(0) @binding(9) var prefilterMap: texture_cube<f32>;

  var<private> rayOrigin: vec3<f32>;
  var<private> rayDirection: vec3<f32>;
  var<private> cameraPosition: vec3<f32>;
  var<private> reflectionDir: vec3<f32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> fragCoordColor: vec2<i32>;
  var<private> ssrBufferCoord: vec2<i32>;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> hitData: HitData;
  var<private> rayTraceRet: RayTraceRetData;
  var<private> worldPosition: vec3<f32>;
  var<private> worldNormal: vec3<f32>;
  var<private> roughness: f32;
  var<private> fresnel: f32;

  var<private> historyPos: vec3<f32>;
  var<private> coordIndex: i32;

  var <private> PI: f32 = 3.14159;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy);
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }
    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;

    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));
    fragCoordColor = convertColorCoordFromSSRCoord(ssrBufferCoord);

    hitData.fadeAlpha = vec4<f32>(0.0);
    hitData.hitCoord = vec2<i32>(0);
    hitData.hitResult = 0;
    hitData.hitNormal = vec3<f32>(0.0, 1.0, 0.0);
    hitData.hitSky = 1;

    worldPosition = textureLoad(zBufferTexture, fragCoordColor , 0).xyz;
    historyPos = historyPosition[coordIndex].xyz;
    
    var mixFactor = 0.2;
    if(length(historyPos - worldPosition) < ssrUniform.mixThreshold){
        mixFactor = 0.9;
    }
    historyPosition[coordIndex] = vec4<f32>(worldPosition, mixFactor);
    
    let normal_v4 = textureLoad(normalBufferTex, fragCoordColor , 0);
    worldNormal = normalize(vec3<f32>(normal_v4.xyz) * 2.0 - 1.0);
    let materialData = textureLoad(materialBufferTex, fragCoordColor , 0 );
    let roughness = materialData.g * (1.0 - materialData.b);
    fresnel = (1.0 - roughness) * ssrUniform.reflectionRatio;

    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    rayOrigin = vec3<f32>(worldPosition.xyz);

    rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    
    var randomSeed = fract(ssrUniform.randomSeedX + worldPosition.x);
    rand_seed.x = randomSeed;
    rand_seed.y = fract(ssrUniform.randomSeedY + worldPosition.y + worldPosition.z);
    randomSeed = rand();
    
    let normalRandom = makeRandomDirection(worldNormal, u32(randomSeed * 256.0), 256, roughness);
    
    reflectionDir = normalize(reflect(rayDirection, normalRandom));

    if(normal_v4.w > 0.5 && roughness < ssrUniform.roughnessThreshold){
      let uvOrigin = vec2<f32>(f32(fragCoordColor.x), f32(fragCoordColor.y));
      let rayMarchPosition = rayOrigin + reflectionDir * 100.0;
      var uvRayMarch = standUniform.projMat * (standUniform.viewMat * vec4<f32>(rayMarchPosition, 1.0));
      var uvOffset = (vec2<f32>(uvRayMarch.xy / uvRayMarch.w) + 1.0) * 0.5;
      uvOffset.y = 1.0 - uvOffset.y;
      uvOffset = uvOffset * vec2<f32>(colorTexSize - 1) - uvOrigin;
      uvOffset = normalize(uvOffset);

      rayTrace(uvOffset);
      if(hitData.hitResult == 1){
          hidingArtifact();
          rayTraceRet.alpha = hitData.fadeAlpha.x * hitData.fadeAlpha.y * hitData.fadeAlpha.z * hitData.fadeAlpha.w;
          if(hitData.hitSky == 1){
            rayTraceRet.alpha = 0.0;
          }
      }else{
        rayTraceRet.alpha = 0.0;
      }
      rayTraceRet.skyColor = getSkyColor();
    }else{
      rayTraceRet.alpha = -1.0;
      rayTraceRet.skyColor = vec3<f32>(0.0);
    }

    rayTraceRet.roughness = roughness;
    rayTraceRet.fresnel = fresnel;
    rayTraceRet.hitCoord = vec2<f32>(hitData.hitCoord);

    let index:i32 = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    rayTraceBuffer[index] = rayTraceRet;
  }

  fn makeRandomDirection(srcDirection:vec3<f32>, i:u32, SAMPLE_COUNT:u32, roughness:f32) -> vec3<f32>
  {
    var N: vec3<f32> = normalize(srcDirection);
    var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
    return ImportanceSampleGGX(Xi, N, roughness);
  }

  fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
  {
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) /f32(N), rdi);
  }

  fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
  {
    var a = roughness*roughness;

    var phi = 2.0 * PI * Xi.x;
    var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    var sinTheta = sqrt(1.0 - cosTheta*cosTheta);

    // from spherical coordinates to cartesian coordinates
    var H:vec3<f32>;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    // from tangent-space vector to world-space sample vector
  var up:vec3<f32>;
    if(abs(N.z) < 0.999)
    {
        up = vec3<f32>(0.0, 0.0, 1.0);
    }
    else
    {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
  var tangent:vec3<f32>  = normalize(cross(up, N));
  var bitangent:vec3<f32> = cross(N, tangent);
  var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
  return normalize(sampleVec);
  }

  var<private> rand_seed :vec2<f32> = vec2<f32>(0.0);
  fn rand() -> f32 {
    rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);
    rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);
    return rand_seed.y;
  }

  fn getSkyColor() -> vec3<f32>{
    let calcRoughness = clamp(roughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, reflectionDir, calcRoughness * MAX_REFLECTION_LOD);
    return LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)) * standUniform.skyExposure;
  }

  fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

  fn convertColorCoordFromSSRCoord(coord:vec2<i32>) -> vec2<i32>{
    let color_ssr_ratio = ssrUniform.colorMapSizeX / ssrUniform.ssrBufferSizeX;
    let targetCoord = vec2<f32>(coord) * color_ssr_ratio;
    return vec2<i32>(targetCoord);
  }

  fn hidingArtifact(){
    let texSizeF32 = vec2<f32>(f32(colorTexSize.x), f32(colorTexSize.y));
    let halfTexSizeF32 = texSizeF32 * 0.5;

    //near screen edge
    var distance2Center = abs(vec2<f32>(f32(hitData.hitCoord.x), f32(hitData.hitCoord.y)) - halfTexSizeF32);
    let halfEdgeSize:f32 = min(texSizeF32.x, texSizeF32.y) * clamp(0.01, ssrUniform.fadeEdgeRatio, 1.0) * 0.5;
    var distance2Edge = min(vec2<f32>(halfEdgeSize), halfTexSizeF32 - distance2Center);
    var ratioXY = distance2Edge / halfEdgeSize;
    hitData.fadeAlpha.x = sqrt(ratioXY.x * ratioXY.y);

    //back face hit
    var backFaceBias = max(0.0, dot(hitData.hitNormal, -reflectionDir));
    hitData.fadeAlpha.y = pow(backFaceBias, max(0.0001, ssrUniform.powDotRN));

    //screen distance ratio
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    let screenPointer = hitData.hitCoord - fragCoordColor;
    var screenDistance = length(vec2<f32>(f32(screenPointer.x), f32(screenPointer.y)));
    screenDistance = clamp(screenDistance / maxLength, 0.0, 1.0);
    hitData.fadeAlpha.z = 1.0 - screenDistance;

    //position distance ratio
    var fadeDistance = length(vec3<f32>(hitData.hitPos - cameraPosition));
    var dFar = ssrUniform.fadeDistanceMax;
    var dNear = ssrUniform.fadeDistanceMin;
    dFar = max(1.0, dFar);
    dNear = clamp(dNear, 0.001, dFar - 0.001);
    fadeDistance = clamp(fadeDistance, dNear, dFar);
    fadeDistance = (fadeDistance - dNear) / (dFar - dNear);
    hitData.fadeAlpha.w = 1.0 - fadeDistance;
  }

  fn rayTrace(rayMarchDir:vec2<f32>){
    let stepLength = 4.0;
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    for(var i:f32 = 1.0; i < maxLength; i = i + stepLength){
        let offsetFloat32 = i * rayMarchDir;
        var uv = fragCoordColor + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
        let hitRet = rayInterestScene(uv);
        if(hitRet > 0){
          hitData.hitResult = hitRet;
          break;
        }
    }
    if(hitData.hitResult == 1){
        let fromUV = hitData.hitCoord;
        for(var i:f32 = -stepLength; i <= 0.0; i = i + 1.0){
          let offsetFloat32 = i * rayMarchDir;
          var uv = fromUV + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
          let hitRet = rayInterestScene(uv);
          if(hitRet == 1){
            let WN = textureLoad(normalBufferTex, hitData.hitCoord , 0 );
            if(WN.w > 0.5){
                hitData.hitSky = 0;
            }
            let normal = vec3<f32>(WN.xyz) * 2.0 - 1.0;
            hitData.hitNormal = normalize(vec3<f32>(normal.xyz));
            break;
          }
        }
    }
  }

  fn rayInterestScene(uv:vec2<i32>) -> i32 {
    if(uv.x < 0 || uv.y < 0 || uv.x >= colorTexSize.x || uv.y >= colorTexSize.y){
      return 2;
    }else{
      let hitPos = textureLoad(zBufferTexture, uv , 0 );
      let testDir = normalize(vec3<f32>(hitPos.xyz - rayOrigin));
      let cosValue = dot(reflectionDir, testDir);

      if(cosValue > 0.9996){
        let cross1 = cross(reflectionDir, -rayDirection);
        let cross2 = cross(reflectionDir, testDir);
        if(dot(cross1, cross2) > 0.0){
          hitData.hitPos = vec3<f32>(hitPos.xyz);
          hitData.hitCoord = uv;
          return 1;
        }
      }
    }
    return 0;
  }
`,nc=`
    @group(0) @binding(0) var<storage, read_write> preColor : array<vec4<f32>>;
    @group(0) @binding(1) var preColorTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(preColorTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
      textureStore(preColorTex, fragCoord , preColor[coordIndex]);
    }
 `,lc=`
    struct TAAData{
      preProjMatrix: mat4x4<f32>,
      preViewMatrix: mat4x4<f32>,
      jitterFrameIndex: f32,
      blendFactor: f32,
      sharpFactor: f32,
      sharpPreBlurFactor: f32,
      jitterX: f32,
      jitterY: f32,
      slot0: f32,
      slot1: f32,
    }
    @group(0) @binding(0) var<uniform> taaData: TAAData;
    @group(0) @binding(1) var inTex : texture_2d<f32>;
    @group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      
      let c0 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y - 1), 0);
      let c1 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y + 1), 0);
      let c2 = textureLoad(inTex, vec2<i32>(fragCoord.x - 1, fragCoord.y), 0);
      let c3 = textureLoad(inTex, vec2<i32>(fragCoord.x + 1, fragCoord.y), 0);
      
      var roundColor = (c0 + c1 + c2 + c3) * 0.25;
      let originColor = textureLoad(inTex, fragCoord, 0);
      let blurColor = mix(roundColor, originColor, taaData.sharpPreBlurFactor);
      var oc = (originColor - blurColor * taaData.sharpFactor) / (1.0 - taaData.sharpFactor);
      oc = clamp(oc, vec4<f32>(0.0), oc);
      textureStore(outTex, fragCoord , oc);
    }
`,hc=`
#include "GlobalUniform"

struct TAAData{
  preProjMatrix: mat4x4<f32>,
  preViewMatrix: mat4x4<f32>,
  jitterFrameIndex: f32,
  blendFactor: f32,
  sharpFactor: f32,
  sharpPreBlurFactor: f32,
  jitterX: f32,
  jitterY: f32,
  slot0: f32,
  slot1: f32,
}

@group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(1) var<uniform> taaData: TAAData;
@group(0) @binding(2) var<storage, read_write> preColorBuffer : array<vec4<f32>>;

@group(0) @binding(3) var preColorTexSampler : sampler;
@group(0) @binding(4) var preColorTex : texture_2d<f32>;
@group(0) @binding(5) var posTex : texture_2d<f32>;
@group(0) @binding(6) var inTexSampler : sampler;
@group(0) @binding(7) var inTex : texture_2d<f32>;
@group(0) @binding(8) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;
var<private> coordIndex: i32;
var<private> color_min: vec4<f32>;
var<private> color_max: vec4<f32>;
var<private> color_avg: vec4<f32>;
var<private> re_proj_uv01: vec2<f32>;
var<private> FLT_EPS:f32 = 5.960464478e-8;  // 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  let frame = standUniform.frame;
  coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
  
  let oc = blendColor();
  preColorBuffer[coordIndex] = oc;
  textureStore(outTex, fragCoord , oc);
}

fn blendColor() -> vec4<f32>
{
  var preCoord = fragCoord;
  var mixWeight = 1.0;
  re_proj_uv01 = vec2<f32>(0.0);
  var reProjectionCoord:vec2<f32> = vec2<f32>(fragCoord);
  //var jitterUVOffset = 0.5 * vec2<f32>(taaData.jitterX, -taaData.jitterY);
  if(taaData.jitterFrameIndex > 0.5){
      var wPos = textureLoad(posTex, fragCoord, 0);
      let ndc = taaData.preProjMatrix * (taaData.preViewMatrix * vec4<f32>(wPos.xyz, 1.0));
      re_proj_uv01 = vec2<f32>(ndc.x, -ndc.y) / ndc.w;
      re_proj_uv01 = (re_proj_uv01 + 1.0) * 0.5;
      
      if(re_proj_uv01.x >= 0.0 && re_proj_uv01.x <= 1.0 && re_proj_uv01.y >= 0.0 && re_proj_uv01.y <= 1.0){
          mixWeight = taaData.blendFactor;
          //reProjectionCoord = re_proj_uv01 + jitterUVOffset;
          reProjectionCoord.x = re_proj_uv01.x * f32(texSize.x - 1);
          reProjectionCoord.y = re_proj_uv01.y * f32(texSize.y - 1);
          preCoord = vec2<i32>(reProjectionCoord);
      }else{ 
          //outside of screen
          mixWeight = 1.0;
      }
  }
  
  var curUV01 = vec2<f32>(fragCoord) / vec2<f32>(texSize - 1);
  //curUV01 += jitterUVOffset;
  
  let curColor = textureSampleLevel(inTex, inTexSampler, curUV01, 0.0);
  
  let preIndex = preCoord.x + preCoord.y * i32(texSize.x);
  var preColor = textureSampleLevel(preColorTex, preColorTexSampler, re_proj_uv01, 0.0);
  
  //minmax9(fragCoord);
  minmax4(fragCoord);
  
  preColor = clip_aabb(color_min.xyz, color_max.xyz, color_avg, preColor);
  var outColor = mix(preColor, curColor, mixWeight);

  return outColor;
}

fn clampCoord(coord0:vec2<i32>) -> vec2<i32>{
  return clamp(coord0, vec2<i32>(0), vec2<i32>(texSize - 1));
}

fn minmax4(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv1 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv2 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      
      let c0 = textureLoad(inTex, uv0, 0);
      let c1 = textureLoad(inTex, uv1, 0);
      let c2 = textureLoad(inTex, uv2, 0);
      let c3 = textureLoad(inTex, uv3, 0);
      
      color_min = min(c0, min(c1, min(c2, c3)));
      color_max = max(c0, max(c1, max(c2, c3)));
      color_avg = (c0 + c1 + c2 + c3) * 0.25;
  }
  
 fn minmax9(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y - 1));
      let uv1 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv2 = clampCoord(vec2<i32>(coord.x - 1, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv4 = clampCoord(vec2<i32>(coord.x, coord.y));
      let uv5 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv6 = clampCoord(vec2<i32>(coord.x + 1, coord.y - 1));
      let uv7 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      let uv8 = clampCoord(vec2<i32>(coord.x + 1, coord.y + 1));
      
      let ctl = textureLoad(inTex, uv0, 0);
      let ctc = textureLoad(inTex, uv1, 0);
      let ctr = textureLoad(inTex, uv2, 0);
      let cml = textureLoad(inTex, uv3, 0);
      let cmc = textureLoad(inTex, uv4, 0);
      let cmr = textureLoad(inTex, uv5, 0);
      let cbl = textureLoad(inTex, uv6, 0);
      let cbc = textureLoad(inTex, uv7, 0);
      let cbr = textureLoad(inTex, uv8, 0);
      
      color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
      color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
      color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;
  }
  
  fn clip_aabb(aabb_max:vec3<f32>, aabb_min:vec3<f32>, color_avg:vec4<f32>, input_texel:vec4<f32>) -> vec4<f32>
  {
      var p_clip:vec3<f32> = 0.5 * (aabb_max + aabb_min);
      var e_clip:vec3<f32> = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
      var v_clip:vec4<f32> = input_texel - vec4<f32>(p_clip, color_avg.w);
      var v_unit:vec3<f32> = v_clip.xyz / e_clip;
      var a_unit:vec3<f32> = abs(v_unit);
      var ma_unit:f32 = max(a_unit.x, max(a_unit.y, a_unit.z));

      if (ma_unit > 1.0){
          return vec4<f32>(p_clip, color_avg.w) + v_clip / ma_unit;
      }else{
          return input_texel;
      }
  }`,uc=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Le.getMorphTargetShaderBinding(2,1)}
#endif

#if USE_SKELETON
    ${Or.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) TEXCOORD_1: vec2<f32>,

  #if USE_TANGENT
      @location(4) TANGENT: vec4<f32>,
      #if USE_SKELETON
          @location(5) joints0: vec4<f32>,
          @location(6) weights0: vec4<f32>,
          #if USE_JOINT_VEC8
          @location(7) joints1: vec4<f32>,
          @location(8) weights1: vec4<f32>,
      #endif
      #elseif USE_MORPHTARGETS
          ${Le.getMorphTargetAttr(5)}
      #endif
  #elseif USE_SKELETON
      @location(4) joints0: vec4<f32>,
      @location(5) weights0: vec4<f32>,
      #if USE_JOINT_VEC8
      @location(6) joints1: vec4<f32>,
      @location(7) weights1: vec4<f32>,
      #endif
  #elseif USE_MORPHTARGETS
     ${Le.getMorphTargetAttr(4)}
  #endif
}



@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${Le.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`,cc=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @location(1) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Le.getMorphTargetShaderBinding(2,1)}
##endif
 
#if USE_SKELETON
    ${Or.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) TEXCOORD_1: vec2<f32>,

  #if USE_TANGENT
      @location(4) TANGENT: vec4<f32>,
      #if USE_SKELETON
          @location(5) joints0: vec4<f32>,
          @location(6) weights0: vec4<f32>,
          #if USE_JOINT_VEC8
          @location(7) joints1: vec4<f32>,
          @location(8) weights1: vec4<f32>,
      #endif
      #elseif USE_MORPHTARGETS
         ${Le.getMorphTargetAttr(5)}
      #endif
  #elseif USE_SKELETON
      @location(4) joints0: vec4<f32>,
      @location(5) weights0: vec4<f32>,
      #if USE_JOINT_VEC8
      @location(6) joints1: vec4<f32>,
      @location(7) weights1: vec4<f32>,
      #endif
  #elseif USE_MORPHTARGETS
      ${Le.getMorphTargetAttr(4)}
  #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_MORPHTARGETS
        ${Le.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`,fc=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`,dc=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`,Wg=`
#include "GlobalUniform"

struct RenderBound{
    index:f32,
}

struct Uniforms {
    matrix : array<mat4x4<f32>>
};

//@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
@group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(2) var<storage, read> planes: array<vec4<f32>,7>;
@group(0) @binding(3) var<storage, read> cullingList: array<RenderBound>;
@group(0) @binding(4) var<storage,read_write> outBuffer: array<f32>;


var<private> boundPoints : array<vec4<f32>,8> ;   

fn IsInClipSpace( coord : vec4<f32> ) -> bool {
    return -coord.w <= coord.x && coord.x <= coord.w
        && -coord.w <= coord.y && coord.y <= coord.w
        && -coord.w <= coord.z && coord.z <= coord.w;
}

fn IsOutsideThePlane( plane: vec4<f32>, pointPosition : vec3<f32> ) -> bool{
    if(dot(plane.xyz, pointPosition) + plane.w > 0.0){
        return true;
    }
    return false;
}

fn containsBox( size:vec3<f32> , center:vec3<f32> ) -> f32 {
    var c = 0.0 ;
    var d = 0.0 ;

    var r = max(size.x, size.y);
    var sr = max(r , size.z);
    var scx = center.x;
    var scy = center.y;
    var scz = center.z;

    for(var p:i32 = 0; p < 6 ; p = p + 1 ){
        var plane = planes[p];
        d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
        if (d <= -sr) {
        return 0.0;
        }
        if (d > sr) {
        c+=1.0;
        }
    }

    if( c >= 6.0 ){
        return 2.0 ;
    }else{
        return 1.0 ;
    }
}

@compute @workgroup_size( 128 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
    let id = globalInvocation_id.x ;
    if(id + 1u > u32(planes[6].x) ){
        outBuffer[id] = f32(0.0); 
        return ;
    }

    let renderBound = cullingList[id];
    let boundID = i32(renderBound.index) ;
    var plane = planes[0];

    let worldMatrix = models.matrix[boundID];
    let projMat = globalUniform.projMat ;

    let const_boundMin : vec3<f32> = vec3<f32>(-0.5,-0.5,-0.5) ;   
    let const_boundMax : vec3<f32> = vec3<f32>(0.5,0.5,0.5) ;   

    let boundMin = worldMatrix * vec4<f32>(const_boundMin, 1.0);
    let boundMax = worldMatrix * vec4<f32>(const_boundMax, 1.0);

    let size = abs( boundMax.xyz - boundMin.xyz ) * 0.65 ;
    let center = worldMatrix[3].xyz ;

    var isIn :f32 = 0.0 ;

    isIn = containsBox(size,center);

    outBuffer[id] = f32(isIn); 
}
`,$o=`
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`,gc=`
#include "GlobalUniform"

struct uniformData {
    exposure: f32,
    roughness: f32
};

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
    var linRGB1: vec3<f32>;
    linRGB1 = linRGB;
    linRGB1 = max(linRGB1, vec3<f32>(0.0, 0.0, 0.0));
    linRGB1.x = pow(linRGB1.x, 0.4166666567325592);
    linRGB1.y = pow(linRGB1.y, 0.4166666567325592);
    linRGB1.z = pow(linRGB1.z, 0.4166666567325592);
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

@fragment
fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`,pc=`
    @group(0) @binding(0) var<storage,read_write> visibleBuffer: array<f32>;
    @group(0) @binding(1) var zBufferTexture : texture_2d<f32>;

    @compute @workgroup_size(8, 8, 1)
    fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32> ) {
        var fragCoord = vec2<i32>( globalInvocation_id.xy );
        let md = textureLoad(zBufferTexture,fragCoord,0);

        let meshID = i32(floor( md.w + 0.1 ));
        if (meshID >= 0) {
            visibleBuffer[meshID] = 1.0 ;
        }
    }
`,mc=`
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(0) vID: f32, @location(1) vPos:vec3<f32> ,  @location(2) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`,Ac=`
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(0) vID: f32 ,
        @location(1) vPos: vec3<f32> ,
        @location(2) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${Le.getMorphTargetShaderBinding(1,0)}
    #endif

    #if USE_SKELETON
        ${Or.groupBindingAndFunctions(1,0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(0) position: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(7) joints1: vec4<f32>,
                @location(8) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            ${Le.getMorphTargetAttr(5)}
        #endif
    #elseif USE_SKELETON
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(6) joints1: vec4<f32>,
            @location(7) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        ${Le.getMorphTargetAttr(4)}
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${Le.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`,_c=`
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`,xc=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
            @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`,vc=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`,jg=`
#version 450
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
layout(location = 2) in vec2 uv;

layout(location = 0) out vec2 fragUV;
layout(location = 1) out vec4 vWorldPos;
layout(location = 2) out vec3 vWorldNormal;

layout(set = 0, binding = 0) 
uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
};

layout(set = 1, binding = 0) 
buffer Uniforms {
    mat4[] modeMat;
};

 mat4 inverse( in mat4 m ){
    return mat4(
        m[0][0], m[1][0], m[2][0], 0.0,
        m[0][1], m[1][1], m[2][1], 0.0,
        m[0][2], m[1][2], m[2][2], 0.0,
        -dot(m[0].xyz,m[3].xyz),
        -dot(m[1].xyz,m[3].xyz),
        -dot(m[2].xyz,m[3].xyz),
        1.0 );
}

void main(){
    fragUV = uv;
    mat4 modelMat = modeMat[gl_InstanceID]; 
    mat4 vm = viewMat * modelMat;
	mat3 normalMatrix = mat3(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	vec3 eNormal = normalize( normalMatrix * normal );
    
    vWorldPos = modelMat * vec4(position.xyz,1.0) ;

    mat4 fixedViewMat = viewMat ;
    fixedViewMat[3] = vec4(0.0,0.0,-8.0,1.0);
    vec4 mvPosition = modelMat * vec4( position.xyz, 1.0 );
    gl_Position = projMat * fixedViewMat * mvPosition;
}

`,qg=`
#version 450

layout(location = 0) in vec2 fragUV;
layout(location = 1) in vec4 vWorldPos;
layout(location = 2) in vec3 vWorldNormal;

layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) 
uniform sampler baseMapSampler;
layout(set = 2, binding = 1) 
uniform texture2D baseMap;

layout(set = 3, binding = 0) uniform uniformData {
    vec3 eyesPos;
    float exposure;
    float roughness;
};

vec3 LinearToGammaSpace(in vec3 linRGB)
{
    vec3 _linRGB = vec3(linRGB) ;
    _linRGB = max(linRGB, vec3(0.0, 0.0, 0.0));
    _linRGB.r = pow(linRGB.r,0.416666667);
    _linRGB.g = pow(linRGB.g,0.416666667);
    _linRGB.b = pow(linRGB.b,0.416666667);
    return max(1.055 * _linRGB - 0.055, vec3(0.0));
}

void main(){
    int maxMipLevel = textureQueryLevels(baseMap, fragUV).x ;
    vec4 textureColor = textureCubeLod( sampler2D(baseMap, baseMapSampler), normalize(vWorldPos.xyz), roughness * float(maxMipLevel) ) ;
    o_Target = vec4(LinearToGammaSpace(textureColor.rgb),1.0) * exposure ;
}

`,Kg=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix ;
    mat4 pvMatrixInv ;
    float frame;
    float time;
    float detail;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;
    float intensity;
};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;

layout(set = 2, binding = 2) uniform sampler lutMapSample;
layout(set = 2, binding = 3) uniform texture2D lutMap;

layout(set = 3, binding = 0) uniform UniformData{
    float intensity ;
};

void main() {
    vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
    vec4 col = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale);
    // vec3 col = vec3(pow(base.xyz,vec3(1.0/2.2)));

    float Bcolor = col.b * 63.0;
	vec2 quad1;
    quad1.y = floor(floor(Bcolor) / 8.0);
    quad1.x = floor(Bcolor) - (quad1.y * 8.0);

    vec2 quad2;
    quad2.y = floor(ceil(Bcolor) / 8.0);
    quad2.x = ceil(Bcolor) - (quad2.y * 8.0);

    const float tmp = (0.125-(0.5/512.0)) ;
    const float tmp2 = 0.5/512.0 ;

    vec2 uv1;
    vec2 uv2;
	uv1.x = ((quad1.x)*0.125)+ tmp2 + (tmp* col.r);
	uv1.y = (((quad1.y)*0.125) + tmp2 + (tmp* col.g));

	uv2.x = ((quad2.x)*0.125)+ tmp2 + (tmp* col.r);
	uv2.y = (((quad2.y)*0.125)+ tmp2 + (tmp* col.g));

    vec4 color1 = texture(sampler2D(lutMap, lutMapSample), uv1);
    vec4 color2 = texture(sampler2D(lutMap, lutMapSample), uv2);

    vec4 newColor = mix(color1, color2, fract(Bcolor));
    // vec3 outC = pow(newColor.xyz,vec3(2.2));

    o_Target = vec4(newColor.rgb, col.a );
    // o_Target = vec4(1.0);
}
`;class en{}o(en,"Ori_AllShader",`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }

        fn frag(){
            ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
            ORI_ShadingInput.Roughness = materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = materialUniform.ao ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

            #if USE_SHADOWMAPING
                useShadow();
            #endif

            BxDFShading();
        }
    `);let yc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "Irradiance_frag"
    #include "MathShader"
    
    struct MaterialUniform {
      probeUniform:vec4<f32>,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    var<private> probeID: i32 ;
    var<private> debugType: i32 ;
    
    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        probeID = i32(materialUniform.probeUniform.x);
        debugType = i32(materialUniform.probeUniform.y);
        if(debugType == 0){
            ORI_ShadingInput.BaseColor = debugProbe(probeID);
        }else if(debugType == 1){
            ORI_ShadingInput.BaseColor = getIrradiance();
        }else if(debugType == 2){
            ORI_ShadingInput.BaseColor = debugProbeDepth(probeID);
        }
        UnLit();
    }
    `,Cc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    // @group(1) @binding(auto)
    // var noes_MapSampler: sampler;
    // @group(1) @binding(auto)
    // var noes_Map: texture_2d<f32>;

    @group(1) @binding(auto)
    var splitTexture_MapSampler: sampler;
    @group(1) @binding(auto)
    var splitTexture_Map: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
        screenUV = (screenUV.xy + 1.0) * 0.5;
        screenUV.y = 1.0 - screenUV.y;

        screenUV.x = clamp(sin(screenUV.x * 1.0),0.0,1.0) ;
        screenUV.y = clamp(sin(screenUV.y * 1.0),0.0,1.0) ;
        // screenUV.y = cos(ORI_VertexVarying.fragPosition.y/7.15);

        let frameMap = textureSample(splitTexture_Map,splitTexture_MapSampler,screenUV);
        // let noesMap = textureSample(noes_Map,noes_MapSampler,screenUV);

        ORI_ShadingInput.BaseColor = vec4<f32>( frameMap.rgb , 1.0) ;
        UnLit();
    }
`,wc=`
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < 0.5){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor ;
        ORI_ShadingInput.BaseColor.w = 1.0 ;
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`,Jg=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;


    struct MaterialUniform {
        baseColor:vec4<f32>,
        lineWeight:f32
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(vertex:VertexAttributes) -> VertexOutput {
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

                #if USE_MORPHTARGETS
                    vertexPosition = vertexPosition * morphTargetData.morphBaseInfluence + vertex.a_morphPositions_0 * morphTargetData.morphInfluence0;
                    #if USE_MORPHNORMALS
                        vertexNormal = vertexNormal * morphTargetData.morphBaseInfluence + vertex.a_morphNormals_0 * morphTargetData.morphInfluence0;
                    #endif
                #endif

                #if USE_SKELETON
                    #if USE_JOINT_VEC8
                        let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #else
                        let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #endif
                #endif


                #if USE_TANGENT
                    ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
                #endif

                ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

                let worldNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

                vertexPosition = vertexPosition + worldNormal * materialUniform.lineWeight ;

                var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
                var viewPosition = ORI_MATRIX_V * worldPos;
                var clipPosition = ORI_MATRIX_P * viewPosition ;

                ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
                ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
                ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
                ORI_VertexOut.varying_Clip = clipPosition ;
                ORI_VertexOut.varying_WPos = worldPos ;
                ORI_VertexOut.varying_WPos.w = f32(vertex.index);
                ORI_VertexOut.varying_WNormal = worldNormal ;
                ORI_VertexOut.member = clipPosition ;


        return ORI_VertexOut ;
    }

    fn frag(){
        let color = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0) ;
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = 0.5  ;
        ORI_ShadingInput.Metallic = 0.5 ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);
        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;
        UnLit();
    }
`,Zg=`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        @group(1) @binding(auto)
        var rtColorTex: texture_2d<f32>;

        @group(1) @binding(auto)
        var baseMapSampler: sampler;
        @group(1) @binding(auto)
        var baseMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var normalMapSampler: sampler;
        @group(1) @binding(auto)
        var normalMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var displaceMapSampler: sampler;
        @group(1) @binding(auto)
        var displaceMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
 
        @group(1) @binding(auto)
        var reflectMapSampler: sampler;
        @group(1) @binding(auto)
        var reflectMap: texture_2d<f32>;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            // let displaceDimensions = textureDimensions(displaceMap) ;
            // let displace = textureGather(0,displaceMap,displaceMapSampler,inputData.uv) ;
            // ORI_VertexOut.member.y += displace.r * 10.0;
            return ORI_VertexOut ;
        }

        fn frag(){
            var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
            screenUV = (screenUV.xy + 1.0) * 0.5;
            screenUV.y = 1.0 - screenUV.y;

            let FrameMap = textureSample(rtColorTex,baseMapSampler,screenUV);

            let Albedo = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0);
            var Normal = textureSample(normalMap,normalMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            Normal.y = 1.0 - Normal.y ;
            let Displace = textureSample(displaceMap,displaceMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            let Ao = textureSample(aoMap,aoMapSampler,ORI_VertexVarying.fragUV0).r ;
            let ReflectMap = 1.0 - textureSample(reflectMap,reflectMapSampler,ORI_VertexVarying.fragUV0).r ;

            ORI_ShadingInput.BaseColor = FrameMap * materialUniform.baseColor * vec4<f32>(LinearToGammaSpace(Albedo.rgb),1.0);
            ORI_ShadingInput.Roughness = ReflectMap * materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = Ao * materialUniform.ao ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            let normal = unPackRGNormal(Normal,Displace.r*materialUniform.normalScale,1.0) ;
            ORI_ShadingInput.Normal = normal ;

            BxDFShading();
        }
    `,bc=`
        #include "Common_vert"
        #include "Common_frag"
        #include "UnLit_frag"

        @group(1) @binding(auto) var pointShadowMapSampler: sampler;
        @group(1) @binding(auto) var pointShadowMap: texture_depth_cube ;

        struct MaterialUniform {
            center: vec3<f32>,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }
 
        fn frag(){

            var center = materialUniform.center ; 

            var dir = normalize(ORI_VertexVarying.vWorldPos.xyz - center) ;
            var depth = textureSample(pointShadowMap,pointShadowMapSampler,dir.xyz) ;
            depth = depth * globalUniform.far ;

            ORI_ShadingInput.BaseColor = vec4<f32>(depth*255.0,0.0,0.0,1.0)  ;
            UnLit();
        }
    `,tn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < 0.5){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        UnLit();
    }
`,$g=`
    struct MaterialUniform{
       #if USE_BRDF
        #include "PhysicMaterialUniform_frag"
       #endif

       #if USE_ColorLit
       #endif

       #if USE_UnLit
       #endif
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;
`,Sc=`
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`,Ic=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        return textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`,Ec=`
struct FragmentOutput {
    @location(0) o_Target: vec4<f32>
};

${Ts}

#include "FastMathShader" 
 
struct LightData {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,
    
    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:i32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct UniformData {
    fogColor : vec4<f32>,
    fogType : f32 ,
    fogHeightScale : f32 , 
    start: f32,
    end: f32,
    density : f32 ,
    ins : f32 ,
    falloff : f32 ,
    rayLength : f32 ,
    scatteringExponent : f32 ,
    dirHeightLine : f32 ,
    skyFactor: f32,
    skyRoughness: f32,
    overrideSkyFactor: f32,
    isSkyHDR: f32
};

@group(1) @binding(0)
var positionMapSampler: sampler;
@group(1) @binding(1)
var positionMap: texture_2d<f32>;

@group(1) @binding(2)
var colorMapSampler: sampler;
@group(1) @binding(3)
var colorMap: texture_2d<f32>;

@group(1) @binding(4)
var normalMapSampler: sampler;
@group(1) @binding(5)
var normalMap: texture_2d<f32>;

@group(1) @binding(6)
var prefilterMapSampler: sampler;
@group(1) @binding(7)
var prefilterMap: texture_cube<f32>;


@group(2) @binding(0)
var<uniform> global : UniformData;
var<private> varying_uv: vec2<f32>;

@group(2) @binding(1)
var<storage,read> lightBuffer: array<LightData>;

var<private> texPosition: vec4<f32>;
var<private> texNormal: vec4<f32>;
var<private> texColor: vec4<f32>;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32>
{
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

fn getSkyColor(worldPosition:vec3<f32>, skyRoughness:f32, isHDRTexture:bool) -> vec3<f32>
{
    let cameraPosition = vec3<f32>(globalUniform.cameraWorldMatrix[3].xyz);
    let rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    let calcRoughness = clamp(skyRoughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, rayDirection, calcRoughness * MAX_REFLECTION_LOD);
    if(isHDRTexture){
        prefilterColor = vec4<f32>(LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)), prefilterColor.w);
    }
    return prefilterColor.xyz * globalUniform.skyExposure;
}

@fragment
fn main(@location(0) fragUV: vec2<f32>, @builtin(position) coord: vec4<f32>) -> FragmentOutput {
    var texCoord = vec2<f32>(fragUV.x, 1.0 - fragUV.y);
    texPosition = textureSample(positionMap, positionMapSampler, texCoord) ;
    texNormal = textureSample(normalMap, normalMapSampler, texCoord) ;
    texColor = textureSample(colorMap, colorMapSampler, texCoord) ;
  
    var opColor = vec3<f32>(0.0);
    if(texNormal.w <= 0.5){
        //for sky
        if(global.overrideSkyFactor > 0.01){
            opColor = blendSkyColor();
        }else{
            opColor = texColor.xyz;
        }
    }else{
        //for ground
        var fogFactor = calcFogFactor();
        if(global.skyFactor > 0.01 || global.overrideSkyFactor > 0.01){
            opColor = blendGroundColor(fogFactor);
        }else{
            opColor = mix(texColor.rgb, global.fogColor.xyz, fogFactor);
        }

        let sunLight = lightBuffer[0] ;
        var inScatteringValue = inScatterIng(sunLight.direction, texPosition.xyz, sunLight.lightColor);
        opColor += inScatteringValue;
    }
    return FragmentOutput(vec4<f32>(opColor.xyz, texColor.a));
}

fn calcFogFactor() -> f32 
{
    var cameraPos = globalUniform.cameraWorldMatrix[3].xyz  ;
    let dis = distance(cameraPos, texPosition.xyz);
    var heightFactor = computeFog(dis) + cFog(-texPosition.y);
    return clamp(global.ins * heightFactor,0.0,1.0);
}

    
fn blendGroundColor(fogFactor:f32) -> vec3<f32>
{
    var skyColorBlur = getSkyColor(texPosition.xyz, global.skyRoughness, global.isSkyHDR > 0.5);
    let skyFactor = clamp(global.skyFactor - global.overrideSkyFactor * 0.5, 0.0, 1.0);
    var fogColor = mix(global.fogColor.xyz, skyColorBlur, skyFactor);
    return mix(texColor.rgb, fogColor.rgb, fogFactor);
}

fn blendSkyColor() -> vec3<f32>
{
    let overrideSkyFactor = sqrt(global.overrideSkyFactor);
    var skyColorBlur = getSkyColor(texPosition.xyz, overrideSkyFactor * 0.3, global.isSkyHDR > 0.5);
    return mix(global.fogColor.xyz, skyColorBlur, 1.0 - overrideSkyFactor);
}


fn computeFog(z:f32) -> f32 
{
    var fog = 0.0;
    if( global.fogType < 0.5 ){
        fog = (global.end - z) / (global.end - global.start);
    }else if(global.fogType < 1.5 ){
        fog = exp2(-global.density * z);
    }else if(global.fogType == 2.5 ){
        fog = global.density * z;
        fog = exp2(-fog * fog);
    }
    return max(fog,0.0);
}

  fn cFog(y:f32) -> f32 
  {
     let fogDensity = global.density * exp(global.fogHeightScale * y);
     let fogFactor = (1.0 - exp2(-global.falloff)) / global.falloff ;
     let fog = fogDensity * fogFactor * max(global.rayLength - global.start, 0.0); 
     return max(fog,0.0);
  }

  fn inScatterIng(sunDir:vec3<f32>, worldPos:vec3<f32>, sunColor:vec3<f32>) -> vec3<f32> 
  {
    let viewDir = normalize(globalUniform.CameraPos.xyz - worldPos.xyz) ;
    let VoL = saturate(dot(viewDir,sunDir)) ;
    var scatter = pow(VoL,global.scatteringExponent);
    scatter *= (1.0-saturate(exp2(-global.dirHeightLine)));
    return vec3<f32>(scatter*sunColor);
  }

`;class rn{}o(rn,"cs",`
    #include 'ColorUtil'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = saturate((1.0 - phaseTheta) * setting.sunRadius);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `);class Bc{constructor(){o(this,"sunRadius",500),o(this,"sunRadiance",11),o(this,"mieG",.76),o(this,"mieHeight",1200),o(this,"eyePos",1500),o(this,"sunX",.71),o(this,"sunY",.56),o(this,"sunBrightness",1),o(this,"displaySun",!0),o(this,"defaultTextureCubeSize",512),o(this,"defaultTexture2DSize",1024),o(this,"skyColor",new z(1,1,1,1))}}class Tc extends ra{constructor(e){return super(),o(this,"_internalTexture"),o(this,"_cubeSize"),o(this,"setting"),this.setting=e,this._cubeSize=e.defaultTextureCubeSize,this._internalTexture=new ep(e.defaultTexture2DSize,e.defaultTexture2DSize*.5),this._internalTexture.update(this.setting),this.createFromTexture(this._cubeSize,this._internalTexture),this}get texture2D(){return this._internalTexture}apply(){return this._internalTexture.update(this.setting),this._faceData.uploadErpTexture(this._internalTexture),this}}class ep extends oe{constructor(e,t){super(e,t,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),o(this,"_computeShader"),o(this,"_uniformBuffer"),this.initCompute(e,t)}initCompute(e,t){this._uniformBuffer=new Dt(16*4),this._uniformBuffer.apply(),this._computeShader=new be(rn.cs),this._computeShader.setUniformBuffer("uniformBuffer",this._uniformBuffer),this._computeShader.setStorageTexture("outTexture",this),this._computeShader.workerSizeX=e/8,this._computeShader.workerSizeY=t/8}update(e){this._uniformBuffer.setFloat("width",this.width),this._uniformBuffer.setFloat("height",this.height),this._uniformBuffer.setFloat("sunU",e.sunX),this._uniformBuffer.setFloat("sunV",e.sunY),this._uniformBuffer.setFloat("eyePos",e.eyePos),this._uniformBuffer.setFloat("sunRadius",e.sunRadius),this._uniformBuffer.setFloat("sunRadiance",e.sunRadiance),this._uniformBuffer.setFloat("mieG",e.mieG),this._uniformBuffer.setFloat("mieHeight",e.mieHeight),this._uniformBuffer.setFloat("sunBrightness",e.sunBrightness),this._uniformBuffer.setFloat("displaySun",e.displaySun?1:0),this._uniformBuffer.setColor("skyColor",e.skyColor),this._uniformBuffer.apply();let t=w.beginCommandEncoder();return w.computeCommand(t,[this._computeShader]),w.endCommandEncoder(t),this}}class Mc extends _i{constructor(){super();let e=new We("sky_vs_frag_wgsl","sky_fs_frag_wgsl");this.defaultPass=e,e.setUniformVector3("eyesPos",new g),e.setUniformFloat("exposure",1),e.setUniformFloat("roughness",0);let t=e.shaderState;t.frontFace="cw",t.cullMode=ui.back,t.depthWriteEnabled=!1,t.depthCompare=vt.less}set baseMap(e){this.defaultPass.setTexture("baseMap",e);const t="IS_HDR_SKY";this.defaultPass.defineValue[t]!=e?.isHDRTexture&&this.defaultPass.setDefine(t,!!e?.isHDRTexture)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set envMap(e){}set shadowMap(e){}get exposure(){return A.setting.sky.skyExposure}set exposure(e){A.setting.sky.skyExposure=e}get roughness(){return this.defaultPass.uniforms.roughness.value}set roughness(e){"roughness"in this.defaultPass.uniforms&&(this.defaultPass.uniforms.roughness.value=e)}}class ls extends tt{constructor(e,t,r,s,a,n,l){super(),o(this,"shape_vertices",[]),o(this,"shape_indices",[]),o(this,"radius"),o(this,"widthSegments"),o(this,"heightSegments"),o(this,"phiStart"),o(this,"phiLength"),o(this,"thetaStart"),o(this,"thetaLength"),this.radius=e,this.widthSegments=t,this.heightSegments=r,this.phiStart=s,this.phiLength=a,this.thetaStart=n,this.thetaLength=l,this.buildGeometry()}buildGeometry(){var e,t,r=0;let s=this.heightSegments,a=this.widthSegments,n=this.radius;var l=(s+1)*(a+1);let h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),f=new Uint16Array(a*s*2*3),d=0,p=0,m=0;for(t=0;t<=s;++t){var _=Math.PI*t/s,v=-n*Math.cos(_),y=n*Math.sin(_);for(e=0;e<=a;++e){var C=2*Math.PI*e/a,B=y*Math.cos(C),T=y*Math.sin(C),M=1/Math.sqrt(B*B+T*T+v*v);if(h[d++]=B,h[d++]=T,h[d++]=v,u[p++]=B*M,u[p++]=T*M,u[p++]=v*M,c[m++]=e/a,c[m++]=t/s,e>0&&t>0){var D=(a+1)*t+e,P=(a+1)*t+e-1,L=(a+1)*(t-1)+e-1,I=(a+1)*(t-1)+e;t==s?(f[r++]=D,f[r++]=L,f[r++]=I):t==1?(f[r++]=D,f[r++]=P,f[r++]=L):(f[r++]=D,f[r++]=P,f[r++]=L,f[r++]=D,f[r++]=L,f[r++]=I)}}}this.setIndices(f),this.setAttribute(Y.position,h),this.setAttribute(Y.normal,u),this.setAttribute(Y.uv,c),this.setAttribute(Y.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,index:0}),this.bounds=new Be(g.ZERO,new g(this.radius*2,this.radius*2,this.radius*2))}}class sa extends ce{constructor(){super(...arguments),o(this,"skyMaterial")}init(){super.init(),this.castShadow=!1,this.castGI=!0,this.addRendererMask(Ue.Sky),this.alwaysRender=!0,this.object3D.bound=new Be(g.ZERO.clone(),g.MAX),this.geometry=new ls(A.setting.sky.defaultFar,20,20),this.skyMaterial||(this.skyMaterial=new Mc)}onEnable(){this._readyPipeline?(this.castNeedPass(),!this._inRenderer&&this.transform.scene3D&&(Q.instance.sky=this,this._inRenderer=!0)):this.initPipeline()}onDisable(){this._inRenderer&&this.transform.scene3D&&(this._inRenderer=!1,Q.instance.sky=null)}renderPass2(e,t,r,s,a,n=!1){super.renderPass2(e,t,r,s,a,n)}set map(e){this.skyMaterial.baseMap=e,this.skyMaterial.name==null&&(this.skyMaterial.name="skyMaterial"),this.material=this.skyMaterial}get map(){return this.skyMaterial.baseMap}get exposure(){return this.skyMaterial.exposure}set exposure(e){this.skyMaterial&&(this.skyMaterial.exposure=e)}get roughness(){return this.skyMaterial.roughness}set roughness(e){this.skyMaterial&&(this.skyMaterial.roughness=e)}}class tp{constructor(){o(this,"rotateX"),o(this,"rotateY"),o(this,"sunX"),o(this,"sunY"),this.reset()}reset(){return this.rotateX=this.rotateY=this.sunX=this.sunY=Number.MAX_VALUE,this}isRotateChange(e,t){return Math.abs(this.rotateX-e)>=.001||Math.abs(this.rotateY-t)>=.001}isSkyChange(e,t){return Math.abs(this.sunX-e)>=.001||Math.abs(this.sunY-t)>=.001}save(e,t,r,s){return this.sunX=e,this.sunY=t,this.rotateX=r,this.rotateY=s,this}}class ip extends sa{constructor(){super(...arguments),o(this,"_atmosphericScatteringSky"),o(this,"_onChange",!0),o(this,"_relatedTransform"),o(this,"_historyData")}get sunX(){return this._atmosphericScatteringSky.setting.sunX}set sunX(e){this._atmosphericScatteringSky.setting.sunX!=e&&(this._atmosphericScatteringSky.setting.sunX=e,this._onChange=!0)}get sunY(){return this._atmosphericScatteringSky.setting.sunY}set sunY(e){this._atmosphericScatteringSky.setting.sunY!=e&&(this._atmosphericScatteringSky.setting.sunY=e,this._onChange=!0)}get eyePos(){return this._atmosphericScatteringSky.setting.eyePos}set eyePos(e){this._atmosphericScatteringSky.setting.eyePos!=e&&(this._atmosphericScatteringSky.setting.eyePos=e,this._onChange=!0)}get sunRadius(){return this._atmosphericScatteringSky.setting.sunRadius}set sunRadius(e){this._atmosphericScatteringSky.setting.sunRadius!=e&&(this._atmosphericScatteringSky.setting.sunRadius=e,this._onChange=!0)}get sunRadiance(){return this._atmosphericScatteringSky.setting.sunRadiance}set sunRadiance(e){this._atmosphericScatteringSky.setting.sunRadiance!=e&&(this._atmosphericScatteringSky.setting.sunRadiance=e,this._onChange=!0)}get sunBrightness(){return this._atmosphericScatteringSky.setting.sunBrightness}set sunBrightness(e){this._atmosphericScatteringSky.setting.sunBrightness!=e&&(this._atmosphericScatteringSky.setting.sunBrightness=e,this._onChange=!0)}get displaySun(){return this._atmosphericScatteringSky.setting.displaySun}set displaySun(e){this._atmosphericScatteringSky.setting.displaySun!=e&&(this._atmosphericScatteringSky.setting.displaySun=e,this._onChange=!0)}init(){super.init(),this._historyData=new tp,this._atmosphericScatteringSky=new Tc(new Bc);let e=this.transform.view3D,t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,this.onUpdate(e)}start(e){let t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,super.start()}get relativeTransform(){return this._relatedTransform}set relativeTransform(e){this._relatedTransform=e,this._historyData.reset()}onUpdate(e){this._relatedTransform&&(this._relatedTransform.rotationZ=0,this._historyData.isRotateChange(this._relatedTransform.rotationX,this._relatedTransform.rotationY)?(this.sunX=(this._relatedTransform.rotationY+90)/360,this.sunY=this._relatedTransform.rotationX/180+.5):this._historyData.isSkyChange(this.sunX,this.sunY)&&(this._relatedTransform.rotationY=this.sunX*360-90,this._relatedTransform.rotationX=(this.sunY-.5)*180),this._historyData.save(this.sunX,this.sunY,this._relatedTransform.rotationX,this._relatedTransform.rotationY)),this._onChange&&(this._onChange=!1,this._atmosphericScatteringSky.apply())}destroy(e){super.destroy(e),this._atmosphericScatteringSky.destroy(),this._atmosphericScatteringSky=null,this._onChange=null}}class ys extends Ee{constructor(){super(),o(this,"type"),o(this,"camera"),o(this,"_cameraPosition"),this._cameraPosition=new g}onUpdate(){this.enable&&this.transform.view3D.camera&&this.updateBillboardMatrix()}updateBillboardMatrix(){let e=this.transform.view3D.camera;this._cameraPosition.copyFrom(e.transform.back),this.type==xi.BillboardXYZ||this.type==xi.BillboardY&&(this._cameraPosition.y=0),this._cameraPosition.normalize(),this._cameraPosition.add(this.object3D.localPosition,this._cameraPosition),this.transform.lookAt(this.object3D.localPosition,this._cameraPosition,e.transform.up)}cloneTo(e){let t=e.addComponent(ys);t.type=this.type}}var mr=(i=>(i[i.None=0]="None",i[i.Box=1]="Box",i[i.Capsule=2]="Capsule",i[i.Sphere=3]="Sphere",i[i.Mesh=4]="Mesh",i))(mr||{});const Li=class{constructor(){o(this,"_center"),o(this,"_size"),o(this,"_halfSize"),o(this,"_shapeType",0),Li.v3_help_0||(Li.v3_help_0=new g),Li.helpMatrix||(Li.helpMatrix=new V),Li.helpRay||(Li.helpRay=new ci),this._center=new g,this._size=new g,this._halfSize=new g}get shapeType(){return this._shapeType}setFromCenterAndSize(i,e){return i&&this._center.copy(i),e&&this._size.copy(e),this}get center(){return this._center}set center(i){this._center.copy(i)}get size(){return this._size}set size(i){this._size.copy(i),this._halfSize.copy(i).multiplyScalar(.5)}get halfSize(){return this._halfSize}rayPick(i,e){return null}};let Xe=Li;o(Xe,"v3_help_0"),o(Xe,"helpMatrix"),o(Xe,"helpRay");class Dc extends Xe{constructor(){super(),o(this,"_pickRet"),o(this,"box"),this._shapeType=mr.Box,this.box=new Be(new g,new g)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.size);let s=Xe.helpMatrix;s.copyFrom(t).invert();let a=Xe.helpRay.copy(e);a.applyMatrix(s);let n=a.intersectBox(this.box,Xe.v3_help_0);return n?(this._pickRet||(this._pickRet={intersectPoint:new g,distance:0}),this._pickRet.intersectPoint=n,this._pickRet.distance=g.distance(a.origin,Xe.v3_help_0),this._pickRet):null}}class rp extends Ee{constructor(){super(),o(this,"_shape"),this._shape=new Dc}start(){A.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.set(this.transform.worldMatrix.index,this)}onEnable(e){ae.bindEnablePick(e,this,null)}onDisable(e){ae.unBindEnablePick(e,this)}get shape(){return this._shape}set shape(e){this._shape=e}rayPick(e){return this._enable?this._shape.rayPick(e,this.transform.worldMatrix):null}beforeDestroy(e){A.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.delete(this.transform.worldMatrix.index),super.beforeDestroy(e)}}var Pc=(i=>(i[i.PingPong=0]="PingPong",i[i.Repeat=1]="Repeat",i[i.Clamp=2]="Clamp",i))(Pc||{});class sn{constructor(e=0,t=0){o(this,"serializedVersion","2"),o(this,"time"),o(this,"value"),o(this,"inSlope",0),o(this,"outSlope",0),o(this,"tangentMode",0),this.time=e,this.value=t}unSerialized(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inSlope=="Infinity"?NaN:e.inSlope,this.outSlope=e.outSlope=="Infinity"?NaN:e.outSlope}unSerialized2(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inTangent=="Infinity"?NaN:e.inTangent,this.outSlope=e.outTangent=="Infinity"?NaN:e.outTangent}}class an{constructor(){o(this,"index"),o(this,"time"),o(this,"timeEnd"),o(this,"coeff",[])}}class aa{constructor(e,t=1,r=1){if(o(this,"_totalTime",1),o(this,"_cache",new an),o(this,"_cacheOut",{lhsIndex:0,rhsIndex:0}),o(this,"_InvalidateCache",!1),o(this,"curve",[]),o(this,"serializedVersion"),o(this,"preWarpMode"),o(this,"postWarpMode"),o(this,"rotationOrder"),e)for(let s=0;s<e.length;s++){const a=e[s];this.addKeyFrame(a)}this.preWarpMode=t,this.postWarpMode=r}get totalTime(){return this._totalTime}get first(){return this.curve[0]}get last(){return this.curve[this.curve.length-1]}addKeyFrame(e){this.curve.indexOf(e)==-1&&this.curve.push(e),this.calcTotalTime()}removeKeyFrame(e){let t=this.curve.indexOf(e);t!=-1&&this.curve.splice(t,1),this.calcTotalTime()}calculateCacheData(e,t,r,s=0){let a=this.curve,n=a[t],l=a[r];e.index=t,e.time=n.time+s,e.timeEnd=l.time+s,e.index=t;let h,u,c,f,d,p,m;h=l.time-n.time,h=Math.max(h,1e-4),c=l.value-n.value,u=1/(h*h),f=n.outSlope,d=l.inSlope,p=f*h,m=d*h,e.coeff[0]=(p+m-c-c)*u/h,e.coeff[1]=(c+c+c-p-p-m)*u,e.coeff[2]=f,e.coeff[3]=n.value,this.setupStepped(e.coeff,n,l)}getValue(e){return e=this.wrapTime(e),this.findCurve(e,this._cacheOut),this.calculateCacheData(this._cache,this._cacheOut.lhsIndex,this._cacheOut.rhsIndex,0),this.evaluateCache(this._cache,e)}getKeyCount(){return this.curve.length}getKey(e){return this.curve[e]}unSerialized(e){this.preWarpMode=e.m_PreInfinity,this.postWarpMode=e.m_PostInfinity,this.rotationOrder=e.m_RotationOrder;let t=e.m_Curve.length;for(let r=0;r<t;r++)this.curve[r]=new sn,this.curve[r].unSerialized(e.m_Curve[r.toString()]);return this.calcTotalTime(),this}unSerialized2(e){this.preWarpMode=e.preWrapMode,this.postWarpMode=e.postWrapMode;let t=e.keyFrames||e.keys,r=t.length;for(let s=0;s<r;s++)this.curve[s]=new sn,this.curve[s].unSerialized2(t[s.toString()]);return this.calcTotalTime(),this}wrapTime(e){let t=this.curve,r=t[0].time,s=t[t.length-1].time;return e<r?this.preWarpMode==2?e=r:this.preWarpMode==0?e=Ja(e,r,s):e=Za(e,r,s):e>s&&(this.postWarpMode==2?e=s:this.postWarpMode==0?e=Ja(e,r,s):e=Za(e,r,s)),e}evaluateCache(e,t){let r=t-e.time;return r*(r*(r*e.coeff[0]+e.coeff[1])+e.coeff[2])+e.coeff[3]}findCurve(e,t){let r=this.curve;for(let s=1;s<r.length;s++){let a=r[s-1],n=r[s];a.time<=e&&n.time>e&&(t.lhsIndex=s-1,t.rhsIndex=s)}}setupStepped(e,t,r){(isNaN(t.outSlope)||isNaN(r.inSlope))&&(e[0]=0,e[1]=0,e[2]=0,e[3]=t.value)}invalidateCache(){this._InvalidateCache=!0}calcTotalTime(){let e=0;for(let t of this.curve)e=Math.max(e,t.time);this._totalTime=e}static scaleCurveValue(e,t){if(!e._InvalidateCache)for(let r=0;r<e.curve.length;r++){let s=e.curve[r];s.value*=t,s.inSlope*=t,s.outSlope*=t}e.invalidateCache()}}class Rc extends aa{constructor(){super(),o(this,"attribute",""),o(this,"propertyList"),o(this,"path")}unSerialized(e){let{attribute:t,path:r}=e;return this.attribute=t,this.path=r,this.propertyList=t.split("."),super.unSerialized(e.curve),this}}class Lc{constructor(){o(this,"curve",{})}}var Ar=(i=>(i[i.Default=0]="Default",i[i.Clamp=1]="Clamp",i[i.Once=1]="Once",i[i.Loop=2]="Loop",i[i.PingPong=4]="PingPong",i[i.ClampForever=8]="ClampForever",i))(Ar||{});class sp{constructor(){o(this,"name"),o(this,"objAnimClip"),o(this,"totalTime",0),o(this,"time",0),o(this,"_stopTime",0),o(this,"_loopTime"),o(this,"_wrapMode"),o(this,"_sampleRate")}get wrapMode(){return this._wrapMode||(this._wrapMode=0),this._wrapMode}set wrapMode(e){this._wrapMode=e}parse(e){this.objAnimClip={};let t=e.AnimationClip,{m_Name:r,m_AnimationClipSettings:s,m_WrapMode:a,m_SampleRate:n}=t;this.name=r,this._wrapMode=a,this._sampleRate=n,this._loopTime=s.m_LoopTime;for(const l in t.m_EditorCurves)if(Object.prototype.hasOwnProperty.call(t.m_EditorCurves,l)){const h=t.m_EditorCurves[l];let u=h.attribute,c=new Rc;c.unSerialized(h),this.totalTime=Math.max(this.totalTime,c.totalTime);let f=this.objAnimClip[h.path];f||(f=new Lc,this.objAnimClip[h.path]=f),f.curve[u]=c}}}class Uc{constructor(){o(this,"transform"),o(this,"quaternion"),o(this,"materialColor")}}class Wt{static updatePropertyTag(e,t){e.quaternion||(e.quaternion=this.tag_quaternion[t]),e.transform||(e.transform=this.tag_transform[t]),e.materialColor||(e.materialColor=this.tag_materialColor[t])}}o(Wt,"Property",{"m_LocalPosition.x":"localPosition.x","m_LocalPosition.y":"localPosition.y","m_LocalPosition.z":"localPosition.z","m_LocalRotation.x":"localQuaternion.x","m_LocalRotation.y":"localQuaternion.y","m_LocalRotation.z":"localQuaternion.z","m_LocalRotation.w":"localQuaternion.w","localEulerAnglesRaw.x":"localRotation.x","localEulerAnglesRaw.y":"localRotation.y","localEulerAnglesRaw.z":"localRotation.z","m_LocalEulerAngles.x":"localRotation.x","m_LocalEulerAngles.y":"localRotation.y","m_LocalEulerAngles.z":"localRotation.z","m_LocalScale.x":"localScale.x","m_LocalScale.y":"localScale.y","m_LocalScale.z":"localScale.z","m_Color.r":"materialColor.r","m_Color.g":"materialColor.g","m_Color.b":"materialColor.b","m_Color.a":"materialColor.a","material._Color.r":"materialColor.r","material._Color.g":"materialColor.g","material._Color.b":"materialColor.b","material._Color.a":"materialColor.a","material._UnlitColor.r":"materialColor.r","material._UnlitColor.g":"materialColor.g","material._UnlitColor.b":"materialColor.b","material._UnlitColor.a":"materialColor.a","field of view":"camera3D.fov",m_IsActive:"active",m_Sprite:"sprite",m_FlipX:"flipX",m_FlipY:"flipY"}),o(Wt,"Scale",{"m_LocalPosition.x":1,"m_LocalPosition.y":1,"m_LocalPosition.z":-1,"localEulerAnglesRaw.x":-1,"localEulerAnglesRaw.y":1,"localEulerAnglesRaw.z":1,"m_LocalEulerAngles.x":-1,"m_LocalEulerAngles.y":1,"m_LocalEulerAngles.z":1,"m_LocalRotation.x":1,"m_LocalRotation.y":1,"m_LocalRotation.z":-1,"m_LocalRotation.w":-1,"field of view":1,m_IsActive:1,m_Sprite:1}),o(Wt,"tag_quaternion",{"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0}),o(Wt,"tag_materialColor",{"material._Color.r":!0,"material._Color.g":!0,"material._Color.b":!0,"material._Color.a":!0,"material._UnlitColor.r":!0,"material._UnlitColor.g":!0,"material._UnlitColor.b":!0,"material._UnlitColor.a":!0}),o(Wt,"tag_transform",{"m_LocalPosition.x":!0,"m_LocalPosition.y":!0,"m_LocalPosition.z":!0,"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0,"localEulerAnglesRaw.x":!0,"localEulerAnglesRaw.y":!0,"localEulerAnglesRaw.z":!0,"m_LocalEulerAngles.x":!0,"m_LocalEulerAngles.y":!0,"m_LocalEulerAngles.z":!0,"m_LocalScale.x":!0,"m_LocalScale.y":!0,"m_LocalScale.z":!0});const on=class{constructor(i){o(this,"_rootObject3D"),o(this,"_animation"),o(this,"_propertyCache"),o(this,"_currentClip"),o(this,"_frame",0),o(this,"_time",0),o(this,"_isPlaying",!0),o(this,"speed",1),o(this,"_propertyTagDic"),this._rootObject3D=i.object3D,this._animation=i,this._propertyTagDic=new Map,this.reset()}reset(){this._propertyCache={},this._propertyTagDic.clear()}get time(){return this._time}get currentClip(){return this._currentClip}play(i,e=!0){this._isPlaying=!0,e&&(this._time=0),i!=this._currentClip&&i&&this.parseAnimClip(i),this._currentClip=i,this.validProperty()}parseAnimClip(i){var e;this.reset();for(const t in i.objAnimClip){let r=i.objAnimClip[t],s=this._rootObject3D,a={};if(t==""?s=this._rootObject3D:s=this._rootObject3D.getObjectByName(t),!s)continue;let n=new Uc;this._propertyTagDic.set(s,n);let l=r.curve;for(const h in l){Wt.updatePropertyTag(n,h);let u=(e=this._propertyCache)[t]||(e[t]={}),c=Wt.Property[h].split("."),f=c[0];if(c.length>1){let d=a[f];d||(d=a[f]=s[f]),u[h]={value:d,property:c[1]}}else u[h]={value:s,property:c[0]}}}return this}stop(){return this._isPlaying=!1,this}toggle(){return this._isPlaying=!this._isPlaying,this}get isPlaying(){return this._isPlaying}update(i,e){if(i=i*.001,e=e*.001,!this._currentClip||this._frame==i||!this._isPlaying)return;this._frame=i;let t=this._time;this._time=this.calcTime(t+e*this.speed),this.validProperty(),this._currentClip.wrapMode!=Ar.Loop&&this._currentClip.wrapMode!=Ar.Default&&(this.speed>0?this._time>=this._currentClip.totalTime:this._time<=0)&&(this._isPlaying=!1,this._animation.statusCall(on.Complete,t,this._time)),this._animation.statusCall(on.Seek,t,this._time)}seek(i){return this._time=this.calcTime(i),this._rootObject3D&&this.validProperty(),this}calcTime(i){return this._currentClip.wrapMode==Ar.Loop||this._currentClip.wrapMode==Ar.Default?i=ro(i,this._currentClip.totalTime):i=K(i,0,this._currentClip.totalTime),i}validProperty(){for(const i in this._currentClip.objAnimClip){let t=this._currentClip.objAnimClip[i].curve;for(const r in t){const s=t[r];let a=this._propertyCache[i][r],n=s.getValue(this._time);r in Wt.Scale&&(n*=Wt.Scale[r]),a.value[a.property]=n}}this._propertyTagDic.forEach((i,e)=>{this.applyProperty(i,e)})}applyProperty(i,e){i.quaternion&&V.getEuler(e.transform.localRotation,e.transform.localRotQuat,!0,"ZYX"),i.transform&&(e.transform.localPosition=e.transform.localPosition,e.transform.localRotation=e.transform.localRotation,e.transform.localScale=e.transform.localScale);let t=e;i.materialColor&&t.notifyMaterialColorChange(0,"baseColor")}};let _r=on;o(_r,"Complete",0),o(_r,"Seek",1);class ap{constructor(){o(this,"clipName"),o(this,"data"),o(this,"time")}}class Ui extends je{constructor(e,t){super(t),o(this,"animation"),o(this,"frame"),this.animation=e}}o(Ui,"SEEK","SEEK"),o(Ui,"COMPLETE","COMPLETE");class An extends Ee{constructor(){super(),o(this,"_animator"),o(this,"_clips",[]),o(this,"defaultClip"),o(this,"autoPlay"),o(this,"_seekEvent"),o(this,"_completeEvent"),o(this,"_keyFrameList"),this._seekEvent=new Ui(this,Ui.SEEK),this._completeEvent=new Ui(this,Ui.COMPLETE),this._keyFrameList={}}registerEventKeyFrame(e){let t=this._keyFrameList[e.clipName];t==null&&(this._keyFrameList[e.clipName]=t=[]),t.push(e)}init(){this._animator=new _r(this)}onUpdate(){this.enable&&this._animator.update(he.time,he.delta)}appendClip(e){this._clips.push(e),this.play(e.name)}statusCall(e,t,r){if(e==_r.Complete)this.eventDispatcher.dispatchEvent(this._completeEvent);else if(e==_r.Seek&&t!=r){let s=this._keyFrameList[this.currentClip.name];if(s)for(let a of s)a.time>t&&a.time<=r&&(this._seekEvent.data=this._seekEvent.frame=a,this.eventDispatcher.dispatchEvent(this._seekEvent))}}set speed(e){this._animator.speed=e}get speed(){return this._animator.speed}stop(){this._animator.stop()}toggle(){this._animator.toggle()}getClip(e){let t;for(let r of this._clips)if(r.name==e){t=r;break}return t}get currentClip(){return this._animator.currentClip}get time(){return this._animator.time}seek(e){this._animator.seek(e)}play(e,t=!0){let r=this.getClip(e);return r?(this._animator.play(r,t),r):null}start(){this.autoPlay&&this.play(this.defaultClip)}copyComponent(e){this.autoPlay=e.autoPlay,this.defaultClip=e.defaultClip;let t=e._clips;for(let r=0,s=t.length;r<s;r++)this.appendClip(t[r]);return this}cloneTo(e){e.addComponent(An).copyComponent(this)}}class op extends Ee{constructor(){super(...arguments),o(this,"_targetRenderers",{}),o(this,"_vec3",new g),o(this,"_matrix4",new V),o(this,"_quaternion",new q)}init(e){let t=this.fetchMorphRenderers(this.object3D);for(const r of t){Tt.hasMask(r.rendererMask,Ue.MorphTarget)&&r.selfCloneMaterials("MORPH_TARGET_UUID");for(const a in r.geometry.morphTargetDictionary){let n=this._targetRenderers[a]||[];n.push(r),this._targetRenderers[a]=n}}}getMorphRenderersByKey(e){return this._targetRenderers[e]}cloneMorphRenderers(){let e={};for(let t in this._targetRenderers)e[t]=this._targetRenderers[t];return e}applyBlendShape(e,t,r=1){if(!e){console.warn("blendShape is null");return}this._vec3.setFromArray(e.transform.transform[3]),this._vec3.multiplyScalar(r),this.object3D.transform.localPosition=this._vec3,this._vec3.setFromArray(e.transform.transform[2]),this._matrix4.copyColFrom(2,this._vec3),this._vec3.setFromArray(e.transform.transform[1]),this._matrix4.copyColFrom(1,this._vec3),this._vec3.setFromArray(e.transform.transform[0]),this._matrix4.copyColFrom(0,this._vec3),this._matrix4.transpose(),this._quaternion.fromMatrix(this._matrix4),this.object3D.localQuaternion=this._quaternion;for(let s in t){let a=this._targetRenderers[s],n=t[s],l=e.texture[n];this.applyMorphTargetInfluence(s,l,a)}}applyMorphTargetInfluence(e,t,r){for(let s of r)s.setMorphInfluence(e,t)}fetchMorphRenderers(e){let t=e.getComponentsInChild(ce),r=[];for(let s of t)s.hasMask(Ue.MorphTarget)&&r.push(s);return r}}class np{constructor(){o(this,"texture"),o(this,"transform")}}class lp{constructor(e,t){o(this,"_computePipeline"),o(this,"_computeBindGroup");let r=S.device;this._computePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:e}),entryPoint:"CsMain"}}),this._computeBindGroup=r.createBindGroup({layout:this._computePipeline.getBindGroupLayout(0),entries:t})}compute(e,t,r,s){let a=e.beginComputePass();return a.setPipeline(this._computePipeline),a.setBindGroup(0,this._computeBindGroup),a.dispatchWorkgroups(t,r,s),a.end(),this}}class hp extends zr{constructor(){super(),o(this,"numJoint"),o(this,"numState"),o(this,"time"),o(this,"weight"),o(this,"argumentsData"),o(this,"_isDirty",!1),o(this,"_argumentsBuffer"),o(this,"_argumentsBufferEntries"),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numState",data:[0]},{name:"retain1",data:[0]},{name:"retain2",data:[0]},{name:"time",data:[0,0]},{name:"weight",data:[0,0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){return this._isDirty&&(this._isDirty=!1,S.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer)),this}allocationMemorySet(e){this.argumentsData={};let t=0;for(let s=0;s<e.length;s++){const a=e[s];t+=a.data.length}this.allocation(t*4);let r=this;for(let s=0;s<e.length;s++){const a=e[s],n=a.name;this.argumentsData[n]=this.allocation_node(a.data.length*4),r[n]=this.argumentsData[n]}}generateGPUBuffer(){let e=S.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}class up extends zr{constructor(){super(),o(this,"numJoint"),o(this,"numFrame"),o(this,"retain0"),o(this,"retain1"),o(this,"argumentsData"),o(this,"_isDirty",!1),o(this,"_argumentsBuffer"),o(this,"_argumentsBufferEntries"),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numFrame",data:[0]},{name:"retain0",data:[0]},{name:"retain1",data:[0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){this._isDirty&&(this._isDirty=!1,S.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer))}allocationMemorySet(e){this.argumentsData={};let t=0;for(let s=0;s<e.length;s++){const a=e[s];t+=a.data.length}this.allocation(t*4);let r=this;for(let s=0;s<e.length;s++){const a=e[s],n=a.name;this.argumentsData[n]=this.allocation_node(a.data.length*4),r[n]=this.argumentsData[n]}}generateGPUBuffer(){let e=S.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}let cp=`
  ${Bs}

  struct Arguments {
    numJoint: f32,
    numState: f32,
    retain1: f32,
    retain2: f32,
    time: vec2<f32>,
    weight: vec2<f32>,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsFinalMatrix: array<mat4x4<f32>>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let numState = i32(args.numState);
    let nJointIndex = i32(workgroup_id.x);

    jointsFinalMatrix[nJointIndex] = mixMatrix4x4(jointsWorldMatrix[0 * numJoint + nJointIndex], jointsWorldMatrix[1 * numJoint + nJointIndex], args.time[0]) * args.weight[0];

    for (var i = 1; i < numState; i++) {
      jointsFinalMatrix[nJointIndex] += mixMatrix4x4(jointsWorldMatrix[(i * 2 + 0) * numJoint + nJointIndex], jointsWorldMatrix[(i * 2 + 1) * numJoint + nJointIndex], args.time[i]) * args.weight[i];
    }
  }
`,fp=`
  ${Bs}

  struct Arguments {
    numJoint: f32,
    numFrame: f32,
    retain0: f32,
    retain1: f32,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsKeyframe: array<JointData>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;
  @group(0) @binding(3) var<storage, read_write> jointsParentIndex: array<f32>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let nFrameIndex = i32(workgroup_id.x);
    for (var nJointIndex = 0; nJointIndex < numJoint; nJointIndex++) {
      let dataIndex = nFrameIndex * numJoint + nJointIndex;
      let joint = jointsKeyframe[dataIndex];
      let jointLocalMatrix = MakeMatrix4x4(joint.scale.xyz, joint.rotation, joint.translation.xyz);

      let nParentIndex = i32(jointsParentIndex[nJointIndex]);
      if (nParentIndex < 0) {
        jointsWorldMatrix[dataIndex] = jointLocalMatrix;
      } else {
        jointsWorldMatrix[dataIndex] = jointsWorldMatrix[nFrameIndex * numJoint + nParentIndex] * jointLocalMatrix;
      }
    }
  }
`;class dp extends Ee{constructor(){super(),o(this,"context"),o(this,"gain"),this.context=new AudioContext,this.gain=this.context.createGain(),this.gain.connect(this.context.destination)}start(){}onUpdate(){if(!this.context)return;const e=this.context.listener,t=this.object3D.transform.worldPosition,r=this.object3D.transform.forward,s=this.object3D.transform.up;if(!isNaN(r.x))if(e.positionX){const a=this.context.currentTime;e.positionX.linearRampToValueAtTime(t.x,a),e.positionY.linearRampToValueAtTime(t.y,a),e.positionZ.linearRampToValueAtTime(t.z,a),e.forwardX.linearRampToValueAtTime(r.x,a),e.forwardY.linearRampToValueAtTime(r.y,a),e.forwardZ.linearRampToValueAtTime(r.z,a),e.upX.linearRampToValueAtTime(s.x,a),e.upY.linearRampToValueAtTime(s.y,a),e.upZ.linearRampToValueAtTime(s.z,a)}else e.setPosition(t.x,t.y,t.z),e.setOrientation(r.x,r.y,r.z,s.x,s.y,s.z)}destroy(){this.gain.disconnect(),this.context.close(),super.destroy()}}class hs extends _i{constructor(){super();let e=new We("UnLit","UnLit");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z(1,1,1,1)),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.defaultPass=e,this.baseMap=A.res.whiteTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get baseColor(){return this.defaultPass.uniforms.baseColor.color}set envMap(e){}set shadowMap(e){}}class us extends tt{constructor(e=1,t=1,r=1){super(),o(this,"width"),o(this,"height"),o(this,"depth"),this.width=e,this.height=t,this.depth=r,this.initVertex()}initVertex(){let e=this.width/2,t=this.height/2,r=this.depth/2;this.bounds=new Be(g.ZERO.clone(),new g(this.width,this.height,this.depth));let s=new Float32Array([-e,t,r,e,t,r,e,t,-r,-e,t,-r,-e,t,r,e,t,-r,e,-t,r,-e,-t,r,-e,-t,-r,e,-t,-r,e,-t,r,-e,-t,-r,-e,-t,r,-e,t,r,-e,t,-r,-e,-t,-r,-e,-t,r,-e,t,-r,e,t,r,e,-t,r,e,-t,-r,e,t,-r,e,t,r,e,-t,-r,e,t,r,-e,t,r,-e,-t,r,-e,-t,r,e,-t,r,e,t,r,e,-t,-r,-e,-t,-r,-e,t,-r,e,t,-r,e,-t,-r,-e,t,-r]),a=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),n=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),l=[0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15,17,16,18,20,19,21,23,22,24,26,25,27,29,28,30,32,31,33,35,34],h=new Uint16Array(l.reverse());this.setIndices(h),this.setAttribute(Y.position,s),this.setAttribute(Y.normal,a),this.setAttribute(Y.uv,n),this.setAttribute(Y.TEXCOORD_1,n),this.addSubGeometry({indexStart:0,indexCount:l.length,vertexStart:0,index:0})}}class Oc extends Ee{constructor(){super(),o(this,"listener",null),o(this,"context",null),o(this,"gainNode",null),o(this,"source",null),o(this,"_options",{loop:!0,volume:1}),o(this,"playing",!1),o(this,"_currentTime",0),o(this,"_buffer",null)}setLister(e){return this.listener=e,this.context=e.context,this.gainNode=this.context.createGain(),this.gainNode.connect(this.listener.gain),this.context.addEventListener("statechange",()=>{var t,r;((t=this.context)==null?void 0:t.state)==="closed"&&(console.warn("AudioListener removed"),this.stop(),(r=this.gainNode)==null||r.disconnect(),this.listener=null,this.context=null,this.gainNode=null)}),this}async load(e,t={}){var r;Object.assign(this._options,t);let a=await(await fetch(e)).arrayBuffer();this._buffer=await((r=this.context)==null?void 0:r.decodeAudioData(a))}async loadBuffer(e,t={}){var r;Object.assign(this._options,t),this._buffer=await((r=this.context)==null?void 0:r.decodeAudioData(e))}play(){if(!this.context)return console.warn("no audio source yet"),this;if(this.playing)return console.warn("Audio is alredy playing"),this;if(!this._buffer)return console.warn("Audio is not ready"),this;const e=this.context.createBufferSource();return e.buffer=this._buffer,e.loop=this._options.loop,this.source=e,this.connect(),this.source.start(0,this._currentTime),this.setVolume(this._options.volume),this.playing=!0,this}pause(){var e,t,r;return this.playing?(this._currentTime=((e=this.context)==null?void 0:e.currentTime)||0,(t=this.source)==null||t.stop(),(r=this.source)==null||r.disconnect(),this.playing=!1,this):(console.warn("Audio is not playing"),this)}stop(){return this.pause(),this._currentTime=0,this}setVolume(e){var t;return this.context?((t=this.gainNode)==null||t.gain.setTargetAtTime(e,this.context?this.context.currentTime:0,.01),this):(console.warn("no audio source yet"),this)}connect(){var e;(e=this.source)==null||e.connect(this.gainNode)}onUpdate(){super.onUpdate()}destroy(e){var t;this.stop(),(t=this.gainNode)==null||t.disconnect(),super.destroy(e)}}class gp extends Oc{constructor(){super(),o(this,"panner"),o(this,"_helper",!1),o(this,"_thickness",.1),o(this,"_step",16),o(this,"_lines",[])}setLister(e){var t;return super.setLister(e),this.panner=(t=this.context)==null?void 0:t.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gainNode),this}showHelper(e,t){this._helper=!0,e&&(this._thickness=e),t&&(this._step=t);const r=this.panner.coneInnerAngle,s=this.panner.coneOuterAngle,a=(s-r)/2;let n=this.panner.refDistance,l=this.panner.maxDistance,h=new us(1,1,1),u=new hs;u.baseColor=new z(1,0,0);let c=new hs;c.baseColor=new z(0,0,1);let f=new hs;f.baseColor=new z(0,1,0);let d=new hs;d.baseColor=new z(1,1,0);for(let p=0;p<this._step;p++){let m=new te,_=p*s/(this._step-1),v=_<a||_>r+a;{let y=new te,C=y.addComponent(ce);C.geometry=h,C.material=v?c:u,C.castShadow=!1,C.castGI=!1,y.localScale=new g(n,this._thickness,this._thickness),y.x=n/2,m.addChild(y)}{let y=new te,C=y.addComponent(ce);C.geometry=h,C.material=v?d:f,C.castShadow=!1,C.castGI=!1,y.localScale=new g(l,this._thickness/2,this._thickness/2),y.x=l/2,m.addChild(y)}m.rotationY=-90+s/2-_,this.object3D.addChild(m),this._lines.push(m)}}hideHelper(){this._helper=!1;for(let e of this._lines)e.removeAllChild(),e.removeFromParent(),e.destroy();this._lines.length=0}toggleHelper(){this._helper?this.hideHelper():this.showHelper()}updateHeler(){this.hideHelper(),this.showHelper()}get refDistance(){return this.panner.refDistance}set refDistance(e){this.panner.refDistance=e,this._helper&&this.updateHeler()}get rolloffFactor(){return this.panner.rolloffFactor}set rolloffFactor(e){this.panner.rolloffFactor=e}get distanceModel(){return this.panner.distanceModel}set distanceModel(e){this.panner.distanceModel=e}get maxDistance(){return this.panner.maxDistance}set maxDistance(e){this.panner.maxDistance=e,this._helper&&this.updateHeler()}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this._helper&&this.updateHeler(),this}connect(){var e;(e=this.source)==null||e.connect(this.panner)}start(){}stop(){return super.stop()}onUpdate(){if(!this.playing)return;const e=this.panner,t=this.object3D.transform.worldPosition,r=this.object3D.transform.forward;if(!isNaN(r.x))if(e.positionX&&this.context){const s=this.context.currentTime;e.positionX.linearRampToValueAtTime(t.x,s),e.positionY.linearRampToValueAtTime(t.y,s),e.positionZ.linearRampToValueAtTime(t.z,s),e.orientationX.linearRampToValueAtTime(r.x,s),e.orientationY.linearRampToValueAtTime(r.y,s),e.orientationZ.linearRampToValueAtTime(r.z,s)}else e.setPosition(t.x,t.y,t.z),e.setOrientation(r.x,r.y,r.z)}destroy(e){this.panner.disconnect(),this.hideHelper(),super.destroy(e)}}class pp{constructor(e=null,t=null){o(this,"_autoUpdate",!0),o(this,"_target"),o(this,"_lookAtObject"),o(this,"_origin",new g(0,0,0)),o(this,"_speed",300),this._target=e,this._lookAtObject=t}get target(){return this._target}set target(e){this._target!=e&&(this._target=e)}get lookAtObject(){return this._lookAtObject}set lookAtObject(e){this._lookAtObject!=e&&(this._lookAtObject=e)}get speed(){return this._speed}set speed(e){this._speed=e}update(){}}class mp extends Ee{constructor(){super(),o(this,"focus"),o(this,"distance",5),o(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Zi),!this._camera){console.error("FirstPersonCameraController need camera");return}if(!this.focus){console.error("FirstPersonCameraController need target");return}A.inputSystem.addEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.addEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){A.inputSystem.addEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){A.inputSystem.removeEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){let t=this.transform.localRotation;t.y+=e.movementX*.01,t.x+=e.movementY*.01,this.transform.localRotation=t}mouseWheel(e){this.distance+=A.inputSystem.wheelDelta*.1}onUpdate(){let e=new g;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t}destroy(e){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var Je=(i=>(i[i.Key_BackSpace=8]="Key_BackSpace",i[i.Key_Tab=9]="Key_Tab",i[i.Key_Clear=12]="Key_Clear",i[i.Key_Enter=13]="Key_Enter",i[i.Key_Shift_L=16]="Key_Shift_L",i[i.Key_Control_L=17]="Key_Control_L",i[i.Key_Alt_L=18]="Key_Alt_L",i[i.Key_Pause=19]="Key_Pause",i[i.Key_CapsLock=20]="Key_CapsLock",i[i.Key_Escape=21]="Key_Escape",i[i.Key_Esc=27]="Key_Esc",i[i.Key_Space=32]="Key_Space",i[i.Key_Prior=33]="Key_Prior",i[i.Key_Next=34]="Key_Next",i[i.Key_End=35]="Key_End",i[i.Key_Home=36]="Key_Home",i[i.Key_Left=37]="Key_Left",i[i.Key_Up=38]="Key_Up",i[i.Key_Right=39]="Key_Right",i[i.Key_Down=40]="Key_Down",i[i.Key_Select=41]="Key_Select",i[i.Key_Print=42]="Key_Print",i[i.Key_Execute=43]="Key_Execute",i[i.Key_Insert=45]="Key_Insert",i[i.Key_Delete=46]="Key_Delete",i[i.Key_Help=47]="Key_Help",i[i.Key_0=48]="Key_0",i[i.Key_1=49]="Key_1",i[i.Key_2=50]="Key_2",i[i.Key_3=51]="Key_3",i[i.Key_4=52]="Key_4",i[i.Key_5=53]="Key_5",i[i.Key_6=54]="Key_6",i[i.Key_7=55]="Key_7",i[i.Key_8=56]="Key_8",i[i.Key_9=57]="Key_9",i[i.Key_A=65]="Key_A",i[i.Key_B=66]="Key_B",i[i.Key_C=67]="Key_C",i[i.Key_D=68]="Key_D",i[i.Key_E=69]="Key_E",i[i.Key_F=70]="Key_F",i[i.Key_G=71]="Key_G",i[i.Key_H=72]="Key_H",i[i.Key_I=73]="Key_I",i[i.Key_J=74]="Key_J",i[i.Key_K=75]="Key_K",i[i.Key_L=76]="Key_L",i[i.Key_M=77]="Key_M",i[i.Key_N=78]="Key_N",i[i.Key_O=79]="Key_O",i[i.Key_P=80]="Key_P",i[i.Key_Q=81]="Key_Q",i[i.Key_R=82]="Key_R",i[i.Key_S=83]="Key_S",i[i.Key_T=84]="Key_T",i[i.Key_U=85]="Key_U",i[i.Key_V=86]="Key_V",i[i.Key_W=87]="Key_W",i[i.Key_X=88]="Key_X",i[i.Key_Y=89]="Key_Y",i[i.Key_Z=90]="Key_Z",i[i.Key_KP_0=96]="Key_KP_0",i[i.Key_KP_1=97]="Key_KP_1",i[i.Key_KP_2=98]="Key_KP_2",i[i.Key_KP_3=99]="Key_KP_3",i[i.Key_KP_4=100]="Key_KP_4",i[i.Key_KP_5=101]="Key_KP_5",i[i.Key_KP_6=102]="Key_KP_6",i[i.Key_KP_7=103]="Key_KP_7",i[i.Key_KP_8=104]="Key_KP_8",i[i.Key_KP_9=105]="Key_KP_9",i[i.Key_Multiply=106]="Key_Multiply",i[i.Key_Add=107]="Key_Add",i[i.Key_Separator=108]="Key_Separator",i[i.Key_Subtract=109]="Key_Subtract",i[i.Key_Decimal=110]="Key_Decimal",i[i.Key_Divide=111]="Key_Divide",i[i.Key_F1=112]="Key_F1",i[i.Key_F2=113]="Key_F2",i[i.Key_F3=114]="Key_F3",i[i.Key_F4=115]="Key_F4",i[i.Key_F5=116]="Key_F5",i[i.Key_F6=117]="Key_F6",i[i.Key_F7=118]="Key_F7",i[i.Key_F8=119]="Key_F8",i[i.Key_F9=120]="Key_F9",i[i.Key_F10=121]="Key_F10",i[i.Key_F11=122]="Key_F11",i[i.Key_F12=123]="Key_F12",i[i.Key_F13=124]="Key_F13",i[i.Key_F14=125]="Key_F14",i[i.Key_F15=126]="Key_F15",i[i.Key_F16=127]="Key_F16",i[i.Key_F17=128]="Key_F17",i[i.Key_F18=129]="Key_F18",i[i.Key_F19=130]="Key_F19",i[i.Key_F20=131]="Key_F20",i[i.Key_F21=132]="Key_F21",i[i.Key_F22=133]="Key_F22",i[i.Key_F23=134]="Key_F23",i[i.Key_F24=135]="Key_F24",i[i.Key_Num_Lock=136]="Key_Num_Lock",i[i.Key_Scroll_Lock=137]="Key_Scroll_Lock",i))(Je||{});class Ap extends Ee{constructor(){super(),o(this,"moveSpeed",2),o(this,"targetPos",new g(0,0,10)),o(this,"lookAtPos",new g(0,0,0)),o(this,"config",{shiftMoveScale:20}),o(this,"_moveScale",1),o(this,"_dir"),o(this,"_mouseFactory",25),o(this,"_factory",1.5),o(this,"_mouseDown",!1),o(this,"_lastPos"),o(this,"_keyState"),this._lastPos=new g,this._keyState={front:!1,back:!1,left:!1,right:!1,q:!1,e:!1},this.setCamera(new g(0,0,100),new g(0,0,0))}setCamera(e,t){this.targetPos.copyFrom(e),this.lookAtPos.copyFrom(t),this.Reset()}start(){A.inputSystem.addEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.addEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.mouseDown,this),A.inputSystem.addEventListener(Qt.KEY_UP,this.keyUp,this),A.inputSystem.addEventListener(Qt.KEY_DOWN,this.keyDown,this),this.transform.lookAt(this.targetPos,this.lookAtPos)}mouseWheel(e){}keyUp(e){switch(e.keyCode){case Je.Key_W:this._keyState.front=!1;break;case Je.Key_S:this._keyState.back=!1;break;case Je.Key_A:this._keyState.left=!1;break;case Je.Key_D:this._keyState.right=!1;break;case Je.Key_Shift_L:this._moveScale=1;break;case Je.Key_Q:this._keyState.q=!1;break;case Je.Key_E:this._keyState.e=!1;break;case Je.Key_F:this.transform.lookAt(this.targetPos,this.lookAtPos);break}}keyDown(e){switch(e.keyCode){case Je.Key_W:this._keyState.front=!0;break;case Je.Key_S:this._keyState.back=!0;break;case Je.Key_A:this._keyState.left=!0;break;case Je.Key_D:this._keyState.right=!0;break;case Je.Key_Q:this._keyState.q=!0;break;case Je.Key_E:this._keyState.e=!0;break;case Je.Key_Shift_L:this._moveScale=this.config.shiftMoveScale}}Reset(){this._lastPos.x=A.inputSystem.mouseLastX,this._lastPos.y=A.inputSystem.mouseLastY}mouseDown(e){this.Reset(),this._mouseDown=!0}mouseUp(e){this.Reset(),this._mouseDown=!1}get factory(){return this._factory}set factory(e){this._factory=e}get mouseFactory(){return this._mouseFactory}set mouseFactory(e){this._mouseFactory=e}internal(e,t,r){return(t-e)*r}onUpdate(){let e=this.transform,t=K(he.delta,0,.016);if(this._mouseDown&&(e.rotationY-=this.internal(e.rotationY+(A.inputSystem.mouseLastX-this._lastPos.x)*.25,e.rotationY,t*this._mouseFactory),e.rotationX-=this.internal(e.rotationX+(A.inputSystem.mouseLastY-this._lastPos.y)*.25,e.rotationX,t*this._mouseFactory),this.Reset()),this._keyState.front){let r=e.forward;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.back){let r=e.forward;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.left){let r=e.left;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.right){let r=e.left;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}this._keyState.q&&(e.y=Ii(e.y,e.y-this.moveSpeed*this._moveScale,t*this._factory)),this._keyState.e&&(e.y=Ii(e.y,e.y+this.moveSpeed*this._moveScale,t*this._factory))}destroy(e){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.mouseDown,this),A.inputSystem.removeEventListener(Qt.KEY_UP,this.keyUp,this),A.inputSystem.removeEventListener(Qt.KEY_DOWN,this.keyDown,this),super.destroy(e)}}class Oi{static add(e,t,r){return r||(r=new g),r.x=e.x+t.x,r.y=e.y+t.y,r.z=e.z+t.z,r}static sub(e,t,r){return r||(r=new g),r.x=e.x-t.x,r.y=e.y-t.y,r.z=e.z-t.z,r}static mul(e,t,r){return r||(r=new g),r.x=e.x*t.x,r.y=e.y*t.y,r.z=e.z*t.z,r}static mulScale(e,t,r){return r||(r=new g),r.x=e.x*t,r.y=e.y*t,r.z=e.z*t,r}static div(e,t,r){return r||(r=new g),r.x=e.x/t.x,r.y=e.y/t.y,r.z=e.z/t.z,r}static normalize(e){return e.clone().normalize()}static dot(e,t){let r=g.HELP_0;return r.copyFrom(e),r.dotProduct(t)}static calculateVectorAngle_xz(e,t){return Math.acos((e.x*t.x+e.y*t.y)/Math.sqrt((e.x*e.x+e.y*e.y)*(t.x*t.x+t.y*t.y)))}static distance(e,t){return g.distance(e,t)}static getRandomXYZ(e=-100,t=100){return new g(Math.random()*(t-e)+e,Math.random()*(t-e)+e,Math.random()*(t-e)+e)}static getRandomV3(e=-100,t=100,r,s){return new g(Math.random()*t+e,Math.random()*s+r,Math.random()*t+e)}static sphere(e){let t=e*Math.random(),r=new g(Math.random()*1-.5,Math.random()*1-.5,Math.random()*1-.5);return r.normalize(),r.scaleBy(t),r}static sphereXYZ(e,t,r=1,s=1,a=1){let n=e+(t-e)*Math.random(),l=new g(Math.random()*r-r*.5,Math.random()*s-s*.5,Math.random()*a-a*.5);return l.normalize(),l.scaleBy(n),l}}class _p extends Ee{constructor(){super(),o(this,"camera"),o(this,"minDistance",.1),o(this,"maxDistance",500),o(this,"rollSmooth",15),o(this,"dragSmooth",20),o(this,"wheelSmooth",10),o(this,"wheelStep",.002),o(this,"mouseRightFactor",.5),o(this,"mouseLeftFactor",20),o(this,"smooth",!0),o(this,"_wheelStep",.002),o(this,"_distance",0),o(this,"distance",10),o(this,"_roll",0),o(this,"roll",0),o(this,"_pitch",0),o(this,"pitch",0),o(this,"_currentPos"),o(this,"_targetPos"),o(this,"_mouseLeftDown",!1),o(this,"_mouseRightDown",!1),o(this,"_bottomClamp",89.99),o(this,"_topClamp",-89.99),o(this,"_tempDir",new g),o(this,"_tempPos",new g),this._currentPos=new te,this._targetPos=new te}start(){this.camera=this.object3D.getOrAddComponent(Zi),A.inputSystem.addEventListener(R.POINTER_DOWN,this.onMouseDown,this),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onMouseMove,this),A.inputSystem.addEventListener(R.POINTER_UP,this.onMouseUp,this),A.inputSystem.addEventListener(R.POINTER_WHEEL,this.onMouseWheel,this)}setCamera(e,t,r,s){this.roll=e,this.pitch=t,this.distance=r,this.maxDistance<r*1.5&&(this.maxDistance=r*1.5),s&&this._targetPos.transform.localPosition.copy(s)}focusByBounds(e){let t=Zt.genMeshBounds(e);this.target=t.center}set target(e){this._targetPos.transform.localPosition.copy(e)}get target(){return this._targetPos.transform.localPosition}onMouseWheel(e){this.enable&&(this._wheelStep=this.wheelStep*Oi.distance(this._currentPos.transform.worldPosition,this.camera.transform.worldPosition)/10,this.distance-=A.inputSystem.wheelDelta*this._wheelStep,this.distance=K(this.distance,this.minDistance,this.maxDistance))}onMouseDown(e){if(this.enable)switch(e.mouseCode){case 0:this._mouseLeftDown=!0;break;case 1:break;case 2:this._mouseRightDown=!0;break}}onMouseUp(e){this._mouseLeftDown=!1,this._mouseRightDown=!1}onMouseMove(e){if(this.enable){if(this._mouseRightDown){let t=.25,r=this.camera.transform.forward;Oi.mulScale(r,e.movementY*t*this.camera.aspect,g.HELP_1),this._targetPos.x+=g.HELP_1.x*this.mouseRightFactor,this._targetPos.z+=g.HELP_1.z*this.mouseRightFactor;let s=this.camera.transform.right;Oi.mulScale(s,-e.movementX*t,g.HELP_1),this._targetPos.x-=g.HELP_1.x*this.mouseRightFactor,this._targetPos.z-=g.HELP_1.z*this.mouseRightFactor}this._mouseLeftDown&&(this.roll-=e.movementX*he.delta*.001*this.mouseLeftFactor,this.pitch-=e.movementY*he.delta*.001*this.mouseLeftFactor,this.pitch=K(this.pitch,this._topClamp,this._bottomClamp))}}onBeforeUpdate(e){if(!this.enable)return;let t=K(he.delta,0,.016);this.smooth?(this._currentPos.x+=(this._targetPos.x-this._currentPos.x)*t*this.dragSmooth,this._currentPos.y+=(this._targetPos.y-this._currentPos.y)*t*this.dragSmooth,this._currentPos.z+=(this._targetPos.z-this._currentPos.z)*t*this.dragSmooth,this._distance+=(this.distance-this._distance)*t*this.wheelSmooth,this._roll+=(this.roll-this._roll)*t*this.rollSmooth,this._pitch+=(this.pitch-this._pitch)*t*this.rollSmooth):(this._currentPos.x=this._targetPos.x,this._currentPos.y=this._targetPos.y,this._currentPos.z=this._targetPos.z,this._distance=this.distance,this._roll=this.roll,this._pitch=this.pitch),this._tempDir.set(0,0,1);let r=q.HELP_0;r.fromEulerAngles(this._pitch,this._roll,0),this._tempDir.applyQuaternion(r),this._tempPos=Oi.mulScale(this._tempDir,this._distance,this._tempPos),this._tempPos.add(this._currentPos.transform.localPosition,this._tempPos),this.transform.lookAt(this._tempPos,this._currentPos.transform.localPosition,g.UP),this.camera.lookTarget.copy(this._currentPos.transform.localPosition)}destroy(e){A.inputSystem.removeEventListener(R.POINTER_DOWN,this.onMouseDown,this),A.inputSystem.removeEventListener(R.POINTER_MOVE,this.onMouseMove,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.onMouseUp,this),A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.onMouseWheel,this),super.destroy(e),this.camera=null}}class xp extends Ee{constructor(){super(),o(this,"_camera"),o(this,"autoRotate",!1),o(this,"autoRotateSpeed",.1),o(this,"rotateFactor",.5),o(this,"zoomFactor",.1),o(this,"panFactor",.25),o(this,"_smooth",5),o(this,"_minDistance",1),o(this,"_maxDistance",1e5),o(this,"_maxPolarAngle",90),o(this,"_minPolarAngle",-90),o(this,"_target",new g(0,0,0)),o(this,"_cTarget",new g(0,0,0)),o(this,"_position",new g(0,0,0)),o(this,"_cPosition",new g(0,0,0)),o(this,"_spherical",new vp),o(this,"_isMouseDown",!1),o(this,"_lastMouseX",-1),o(this,"_lastMouseY",-1),o(this,"_isPanning",!1)}get target(){return this._target}set target(e){this._target=e}get smooth(){return this._smooth}set smooth(e){this._smooth=Math.max(e,1)}get minDistance(){return this._minDistance}set minDistance(e){this._minDistance=K(e,2e-6,this._maxDistance)}get maxDistance(){return this._maxDistance}set maxDistance(e){this._maxDistance=K(e,this._minDistance,1/0)}get minPolarAngle(){return this._minPolarAngle}set minPolarAngle(e){this._minPolarAngle=K(e,-90,this._maxPolarAngle)}get maxPolarAngle(){return this._maxPolarAngle}set maxPolarAngle(e){this._maxPolarAngle=K(e,this._minPolarAngle,90)}start(){this._camera=this.object3D.getComponent(Zi),this._position=this.object3D.transform.localPosition.clone(),this._cPosition=this._position.clone(),this._target=this._camera.lookTarget.clone(),this._cTarget=this._target.clone(),this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z),this._camera.lookAt(this._cPosition,this._cTarget,g.UP),this.addEventListener()}onEnable(){this.addEventListener()}onDisable(){this.removeEventListener()}onUpdate(){let e=this._isPanning?1:this.smooth,t=!1;this._cPosition.equals(this.object3D.transform.localPosition)||(this._position.copyFrom(this.object3D.transform.localPosition),e=1,t=!0),this._cTarget.equals(this._target)||(this._cTarget.copyFrom(this._target),e=1,t=!0),t?this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z):!this._isMouseDown&&this.autoRotate&&(this._spherical.theta-=this.autoRotateSpeed*Math.PI/180,this.updateCamera());let r=(this._position.x-this._cPosition.x)/e,s=(this._position.y-this._cPosition.y)/e,a=(this._position.z-this._cPosition.z)/e;this._cPosition.x=Math.abs(r)>1e-10?this._cPosition.x+r:this._position.x,this._cPosition.y=Math.abs(s)>1e-10?this._cPosition.y+s:this._position.y,this._cPosition.z=Math.abs(a)>1e-10?this._cPosition.z+a:this._position.z,this._camera.lookAt(this._cPosition,this._cTarget,g.UP)}onWheel(e){e.deltaY=K(e.deltaY,-this._spherical.radius,this._spherical.radius),this._spherical.radius+=e.deltaY*this.zoomFactor,this._spherical.radius=K(this._spherical.radius,this.minDistance,this.maxDistance),this.updateCamera()}onPointerDown(e){this._isMouseDown=!0,this._lastMouseX=e.mouseX,this._lastMouseY=e.mouseY,e.mouseCode===2&&(this._isPanning=!0)}onPointerMove(e){if(!this._isMouseDown||!this.enable)return;let t=e.mouseX,r=e.mouseY;if(e.mouseCode===0&&this._lastMouseX>0&&this._lastMouseY>0){const s=-(t-this._lastMouseX)*this.rotateFactor,a=(r-this._lastMouseY)*this.rotateFactor;this._spherical.theta+=s*Math.PI/180,this._spherical.phi-=a*Math.PI/180,this._spherical.phi=K(this._spherical.phi,this.minPolarAngle,this.maxPolarAngle),this.updateCamera()}else e.mouseCode===2&&(Oi.mulScale(this.object3D.transform.up,e.movementY*this.panFactor*this._camera.aspect,g.HELP_1),this._target.y+=g.HELP_1.y,Oi.mulScale(this.object3D.transform.right,-e.movementX*this.panFactor,g.HELP_1),this._target.x-=g.HELP_1.x,this._target.z-=g.HELP_1.z,this._cTarget.copyFrom(this._target),this.updateCamera());this._lastMouseX=t,this._lastMouseY=r}onPointerUp(e){this._isMouseDown=!1,e.mouseCode===2&&(this._isPanning=!1)}onPointerLeave(){this._isMouseDown=!1,this._isPanning=!1}updateCamera(){this._spherical.makeSafe();let e=this._spherical.getCoords();this._position.set(e.x+this._target.x,e.y+this._target.y,e.z+this._target.z)}addEventListener(){A.inputSystem.addEventListener(R.POINTER_WHEEL,this.onWheel,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.onPointerDown,this),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onPointerMove,this),A.inputSystem.addEventListener(R.POINTER_UP,this.onPointerUp,this),A.inputSystem.addEventListener(R.POINTER_OUT,this.onPointerLeave,this)}removeEventListener(){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.onWheel,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.onPointerDown,this),A.inputSystem.removeEventListener(R.POINTER_MOVE,this.onPointerMove,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.onPointerUp,this),A.inputSystem.removeEventListener(R.POINTER_OUT,this.onPointerLeave,this)}}class vp{constructor(e=1,t=0,r=0){return o(this,"radius"),o(this,"phi"),o(this,"theta"),o(this,"coords"),this.radius=e,this.phi=t,this.theta=r,this.coords=new g,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}makeSafe(){return this.phi=Math.max(2e-4,Math.min(Math.PI-2e-4,this.phi)),this}setFromVector3(e){return this.setCoords(e.x,e.y,e.z)}setCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(K(t/this.radius,-1,1))),this}getCoords(){const e=Math.sin(this.phi)*this.radius;return this.coords.x=e*Math.sin(this.theta),this.coords.y=Math.cos(this.phi)*this.radius,this.coords.z=e*Math.cos(this.theta),this.coords}}class yp extends Ee{constructor(){super(),o(this,"focus"),o(this,"_rotation",new g(45,0,0)),o(this,"distance",5),o(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Zi),!this._camera){console.error("ThirdPersonCameraController need camera");return}if(!this.focus){console.error("ThirdPersonCameraController need target");return}A.inputSystem.addEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.addEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.addEventListener(R.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){A.inputSystem.addEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){A.inputSystem.removeEventListener(R.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){this._rotation.y+=e.movementX*.01,this._rotation.x+=e.movementY*.01}mouseWheel(e){this.distance+=A.inputSystem.wheelDelta*.1}onUpdate(){let e=new g;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t.subtract(e)}destroy(e){A.inputSystem.removeEventListener(R.POINTER_WHEEL,this.mouseWheel,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.mouseUp,this),A.inputSystem.removeEventListener(R.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var De=(i=>(i[i.NORMAL=0]="NORMAL",i[i.DOWN=1]="DOWN",i[i.OVER=2]="OVER",i[i.DISABLE=3]="DISABLE",i))(De||{});let Cp=Math.PI,Nc=Cp*2;class Qi{constructor(e=1,t=0,r=0,s=1,a=0,n=0){o(this,"a"),o(this,"b"),o(this,"c"),o(this,"d"),o(this,"tx"),o(this,"ty"),this.a=e,this.b=t,this.c=r,this.d=s,this.tx=a,this.ty=n}clone(){return new Qi(this.a,this.b,this.c,this.d,this.tx,this.ty)}concat(e){let t=this.a,r=this.c,s=this.tx;this.a=t*e.a+this.b*e.c,this.b=t*e.b+this.b*e.d,this.c=r*e.a+this.d*e.c,this.d=r*e.b+this.d*e.d,this.tx=s*e.a+this.ty*e.c+e.tx,this.ty=s*e.b+this.ty*e.d+e.ty}copyFrom(e){return this.a=e.a,this.b=e.b,this.c=e.c,this.d=e.d,this.tx=e.tx,this.ty=e.ty,this}identity(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this}invert(){this._invertInto(this)}rotate(e){if(e=+e,e!==0){e=e*_e;let t=Math.cos(e),r=Math.sin(e),s=this.a,a=this.b,n=this.c,l=this.d,h=this.tx,u=this.ty;this.a=s*t-a*r,this.b=s*r+a*t,this.c=n*t-l*r,this.d=n*r+l*t,this.tx=h*t-u*r,this.ty=h*r+u*t}}scale(e,t){e!==1&&(this.a*=e,this.c*=e,this.tx*=e),t!==1&&(this.b*=t,this.d*=t,this.ty*=t)}setTo(e,t,r,s,a,n){return this.a=e,this.b=t,this.c=r,this.d=s,this.tx=a,this.ty=n,this}transformPoint(e,t,r){let s=this.a*e+this.c*t+this.tx,a=this.b*e+this.d*t+this.ty;return r?(r.setTo(s,a,0,1),r):new g(s,a,0,1)}setTranslate(e,t){this.tx=e,this.ty=t}translate(e,t){this.tx+=e,this.ty+=t}mul(e){let t=this,r=e,s=t.a,a=t.b,n=t.c,l=t.d,h=t.tx,u=t.ty,c=r.a,f=r.b,d=r.c,p=r.d,m=r.tx,_=r.ty;f!==0||d!==0?(this.a=s*c+a*d,this.b=s*f+a*p,this.c=n*c+l*d,this.d=n*f+l*p,this.tx=c*h+d*u+m,this.ty=f*h+p*u+_):(this.a=s*c,this.b=a*p,this.c=n*c,this.d=l*p,this.tx=c*h+m,this.ty=p*u+_)}equals(e){return this.a==e.a&&this.b==e.b&&this.c==e.c&&this.d==e.d&&this.tx==e.tx&&this.ty==e.ty}prepend(e,t,r,s,a,n){let l=this.tx;if(e!=1||t!=0||r!=0||s!=1){let h=this.a,u=this.c;this.a=h*e+this.b*r,this.b=h*t+this.b*s,this.c=u*e+this.d*r,this.d=u*t+this.d*s}return this.tx=l*e+this.ty*r+a,this.ty=l*t+this.ty*s+n,this}append(e){let t=this.a,r=this.b,s=this.c,a=this.d;return(e.a!=1||e.b!=0||e.c!=0||e.d!=1)&&(this.a=e.a*t+e.b*s,this.b=e.a*r+e.b*a,this.c=e.c*t+e.d*s,this.d=e.c*r+e.d*a),this.tx=e.tx*t+e.ty*s+this.tx,this.ty=e.tx*r+e.ty*a+this.ty,this}deltaTransformPoint(e){let t=this,r=t.a*e.x+t.c*e.y,s=t.b*e.x+t.d*e.y;return new g(r,s)}toString(){return"(a="+this.a+", b="+this.b+", c="+this.c+", d="+this.d+", tx="+this.tx+", ty="+this.ty+")"}createBox(e,t,r=0,s=0,a=0){let n=this;if(r!==0){r=r*_e;let l=Math.cos(r),h=Math.sin(r);n.a=l*e,n.b=h*t,n.c=-h*e,n.d=l*t}else n.a=e,n.b=0,n.c=0,n.d=t;n.tx=s,n.ty=a}createGradientBox(e,t,r=0,s=0,a=0){this.createBox(e/1638.4,t/1638.4,r,s+e/2,a+t/2)}_invertInto(e){let t=this.a,r=this.b,s=this.c,a=this.d,n=this.tx,l=this.ty;if(r==0&&s==0){e.b=e.c=0,t==0||a==0?e.a=e.d=e.tx=e.ty=0:(t=e.a=1/t,a=e.d=1/a,e.tx=-t*n,e.ty=-a*l);return}let h=t*a-r*s;if(h==0){e.identity();return}h=1/h;let u=e.a=a*h;r=e.b=-r*h,s=e.c=-s*h,a=e.d=t*h,e.tx=-(u*n+s*l),e.ty=-(r*n+a*l)}getScaleX(){let e=this;if(e.a==1&&e.b==0)return 1;let t=Math.sqrt(e.a*e.a+e.b*e.b);return this.getDeterminant()<0?-t:t}getScaleY(){let e=this;if(e.c==0&&e.d==1)return 1;let t=Math.sqrt(e.c*e.c+e.d*e.d);return this.getDeterminant()<0?-t:t}getSkewX(){return Math.atan2(this.d,this.c)-Math.PI/2}getSkewY(){return Math.atan2(this.b,this.a)}updateScaleAndRotation(e,t,r,s){if((r==0||r==Nc)&&(s==0||s==Nc)){this.a=e,this.b=this.c=0,this.d=t;return}r=r*_e,s=s*_e;let a=Math.cos(r),n=Math.sin(r);r==s?(this.a=a*e,this.b=n*e):(this.a=Math.cos(s)*e,this.b=Math.sin(s)*e),this.c=-n*t,this.d=a*t}preMultiplyInto(e,t){let r=e.a*this.a,s=0,a=0,n=e.d*this.d,l=e.tx*this.a+this.tx,h=e.ty*this.d+this.ty;(e.b!==0||e.c!==0||this.b!==0||this.c!==0)&&(r+=e.b*this.c,n+=e.c*this.b,s+=e.a*this.b+e.b*this.d,a+=e.c*this.a+e.d*this.c,l+=e.ty*this.c,h+=e.tx*this.b),t.a=r,t.b=s,t.c=a,t.d=n,t.tx=l,t.ty=h}$transformBounds(e){let t=this.a,r=this.b,s=this.c,a=this.d,n=this.tx,l=this.ty,h=e.x,u=e.y,c=h+e.width,f=u+e.height,d=t*h+s*u+n,p=r*h+a*u+l,m=t*c+s*u+n,_=r*c+a*u+l,v=t*c+s*f+n,y=r*c+a*f+l,C=t*h+s*f+n,B=r*h+a*f+l,T=0;d>m&&(T=d,d=m,m=T),v>C&&(T=v,v=C,C=T),e.x=Math.floor(d<v?d:v),e.width=Math.ceil((m>C?m:C)-e.x),p>_&&(T=p,p=_,_=T),y>B&&(T=y,y=B,B=T),e.y=Math.floor(p<y?p:y),e.height=Math.ceil((_>B?_:B)-e.y)}getDeterminant(){return this.a*this.d-this.b*this.c}}class Cs extends Ee{constructor(){super(...arguments),o(this,"isGUICanvas",!0),o(this,"index",0)}addChild(e){return this.object3D.addChild(e),this}removeChild(e){return this.object3D.removeChild(e),this}cloneTo(e){e.getOrAddComponent(Cs).copyComponent(this)}copyComponent(e){return e.index=e.index,this}}var Pe=(i=>(i[i.NONE=0]="NONE",i[i.POSITION=1]="POSITION",i[i.SPRITE=2]="SPRITE",i[i.COLOR=4]="COLOR",i[i.MAX=7]="MAX",i))(Pe||{});class nn{constructor(e){o(this,"array"),o(this,"buffer"),this.buffer=new ge(e,0),this.array=new Float32Array(this.buffer.memory.shareDataBuffer)}}class Fc extends tt{constructor(e){super(),o(this,"_attributeUV"),o(this,"_attributeVIndex"),o(this,"_faceIndexes"),o(this,"_uvSize",2),o(this,"_vIndexSize",1),o(this,"_posAttribute"),o(this,"_spriteAttribute"),o(this,"_colorAttribute"),o(this,"_onPositionChange",!0),o(this,"_onSpriteChange",!0),o(this,"_onColorChange",!0),o(this,"maxQuadCount"),this.maxQuadCount=e}updateBounds(e,t){let r=Number.MAX_VALUE*.1;return e=new g(-r,-r,-r),t=new g(r,r,r),this.bounds.setFromMinMax(e,t),this}get vPositionBuffer(){return this._onPositionChange&&(this._posAttribute.buffer.apply(),this._onPositionChange=!1),this._posAttribute.buffer}get vSpriteBuffer(){return this._onSpriteChange&&(this._spriteAttribute.buffer.apply(),this._onSpriteChange=!1),this._spriteAttribute.buffer}get vColorBuffer(){return this._onColorChange&&(this._colorAttribute.buffer.apply(),this._onColorChange=!1),this._colorAttribute.buffer}create(){this.createBuffer(),this.updateBounds();let e=this.maxQuadCount,t=[],r=[];for(let a=0;a<e;a++)t.push(...ai.attUV);for(let a=0,n=this.maxQuadCount*ai.vertexCount;a<n;a++)r[a]=a;this._attributeUV=new Float32Array(ai.vertexCount*e*this._uvSize),this._attributeVIndex=new Float32Array(ai.vertexCount*e*this._vIndexSize),this._attributeUV.set(t,0),this._attributeVIndex.set(r,0);let s=[];for(let a=0;a<e;a++)for(let n=0;n<ai.indecies.length;n++){const l=ai.indecies[n]+a*4;s.push(l)}return this._faceIndexes=new Uint32Array(e*6),this._faceIndexes.set(s,0),this.setIndices(this._faceIndexes),this.setAttribute(Y.uv,this._attributeUV),this.setAttribute(Y.vIndex,this._attributeVIndex),this.addSubGeometry({indexStart:0,indexCount:this._faceIndexes.length,vertexStart:0,index:0}),this}createBuffer(){let e=this.maxQuadCount;this._posAttribute=new nn(e*4),this._spriteAttribute=new nn(e*(4+4+2+2)),this._colorAttribute=new nn(e*4)}fillQuad(e,t){e.dirtyAttributes&Pe.POSITION&&this.fillQuadPosition(e,t),e.dirtyAttributes&Pe.COLOR&&this.fillQuadColor(e,t),e.dirtyAttributes&Pe.SPRITE&&this.fillQuadSprite(e,t)}fillQuadPosition(e,t){kc.setXYZW(this._posAttribute.array,e.z,e.left,e.bottom,e.right,e.top),this._onPositionChange=!0}fillQuadColor(e,t){let r=e.color,s=this._colorAttribute.array;kc.setXYZW(s,e.z,r.r,r.g,r.b,r.a),this._onColorChange=!0}fillQuadSprite(e,t){let r=e.sprite,s=0,a=0;r.isSliced&&e.imageType==pr.Sliced&&(s=r.trimSize.x,s=(t.width-(r.offsetSize.z-r.trimSize.x))/s,a=r.trimSize.y,a=(t.height-(r.offsetSize.w-r.trimSize.y))/a);let n=r.guiTexture.dynamicId,l=r.uvRec,h=r.uvBorder,u=this._spriteAttribute.array,c=(4+4+2+2)*e.z;u[c+0]=l.x,u[c+1]=l.y,u[c+2]=l.z,u[c+3]=l.w,u[c+4]=h.x,u[c+5]=h.y,u[c+6]=h.z,u[c+7]=h.w,u[c+8]=s,u[c+9]=a,u[c+10]=n,u[c+11]=e.visible?1:0,this._onSpriteChange=!0}}class wp{static set(e,t,r,s,...a){let n=t*s+r;for(let l=0,h=a.length;l<h;l++)e[n+l]=a[l]}}class kc extends wp{static setXYZW(e,t,r,s,a,n){this.set(e,t,0,4,r,s,a,n)}static setXYZ(e,t,r,s,a){this.set(e,t,0,4,r,s,a)}static setZ(e,t,r){this.set(e,t,3,4,r)}}class ai{}o(ai,"vertexCount",4),o(ai,"attUV",[0,0,1,0,1,1,0,1]),o(ai,"indecies",[0,1,2,0,2,3]);class zc{constructor(){o(this,"_textureMap",new Map),o(this,"_textureList",[])}build(e,t,r){let s=-1,a=-1;this._textureMap.clear(),this._textureList.length=0;let n=[],l=t.quadMaxCount-1,h;for(let u of e){let c=u.needUpdateQuads;n.length=0;const f=this.collectQuads(u.object3D,n);for(let d of f){d.z=++s;let p=d.sprite.guiTexture;if(!this._textureMap.has(p.staticId)&&(++a,this._textureMap.set(p.staticId,p),p.dynamicId=a,this._textureList[a]=p.texture,a>7)){console.warn("texture Count Exceeded the maximum limit of 7");break}if(d.cacheTextureId!=p.dynamicId&&(d.dirtyAttributes=Pe.MAX,d.cacheTextureId=p.dynamicId),(c||r)&&(d.dirtyAttributes=Pe.MAX),d.dirtyAttributes&Pe.POSITION&&d.applyTransform(u),d.dirtyAttributes&&d.writeToGeometry(t._geometry,u),s==l){h=!0;break}}if(h)break}return t._uiMaterial.setTextures(this._textureList),t._limitVertexCount=(s+1)*4,!h}collectQuads(e,t){t||(t=[]);let r=e.components.values();for(let s of r){let a=s;if(a.isUIShadow||!a.mainQuads)continue;let n=a.getShadowRender();n&&this.push(n.mainQuads,t),this.push(a.mainQuads,t)}return t}push(e,t){e&&e.length>0&&t.push(...e)}}const gt=class{static bindTextureArray(){let i="";for(let e=0;e<7;e++)i+=`
        @group(1) @binding(auto)
        var tex_${e}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${e}
        var tex_${e}: texture_external;
#else
        var tex_${e}: texture_2d<f32>;
#endif
`;return i}static sampleTexture(i){return`
#if VideoTexture${i}
            let size = textureDimensions(tex_${i}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${i}, iuv) ;
#else
            color = textureSampleLevel(tex_${i}, tex_${i}Sampler, uv, 0.0);
#endif        `}};let Ni=gt;o(Ni,"fs",`
        ${Wa}
        ${gt.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${gt.sampleTexture(0)}
            }else if(texId == 1){
                ${gt.sampleTexture(1)}
            }else if(texId == 2){
                ${gt.sampleTexture(2)}
            }else if(texId == 3){            
                ${gt.sampleTexture(3)}
            }else if(texId == 4){            
                ${gt.sampleTexture(4)}
            }else if(texId == 5){            
                ${gt.sampleTexture(5)}
            }else if(texId == 6){            
                ${gt.sampleTexture(6)}
            }
            color *= vColor4;
            color.a *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = color;
            return fragmentOutput ;
        }`),o(Ni,"GUI_common_vs",`
        ${Xa}
        ${Ts}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            guiSolution:vec2<f32>,
            
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            limitVertex:f32,
            pixelRatio:f32,
        }
        
        struct VertexOutput {
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(0) uv: vec2<f32>,
            @location(1) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `),o(Ni,"GUI_shader_view",`
        ${gt.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5 && vertexIndex < materialUniform.limitVertex;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${gt.fs}
        `),o(Ni,"GUI_shader_world",`
        ${gt.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5 && vertexIndex < materialUniform.limitVertex;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${gt.fs}

        `);class Gc extends _i{constructor(e){super(),o(this,"_scissorRect"),o(this,"_screenSize",new Z(1024,768)),o(this,"_scissorEnable",!1),o(this,"_videoTextureFlags",{}),N.register("GUI_shader_view",Ni.GUI_shader_view),N.register("GUI_shader_world",Ni.GUI_shader_world);let t=e==Nt.View?"GUI_shader_view":"GUI_shader_world",r=new We(t,t);r.setShaderEntry("VertMain","FragMain"),r.setUniformVector2("screenSize",this._screenSize),r.setUniformVector2("guiSolution",this._screenSize),r.setUniformVector4("scissorRect",new j),r.setUniformFloat("scissorCornerRadius",0),r.setUniformFloat("scissorFadeOutSize",0),r.setUniformFloat("limitVertex",0),r.setUniformFloat("pixelRatio",1);let s=r.shaderState;s.depthWriteEnabled=!1,r.blendMode=xe.ALPHA,r.depthCompare=e==Nt.View?vt.always:vt.less_equal,r.cullMode=ui.back,this.defaultPass=r}setLimitVertex(e){this.defaultPass.setUniformFloat("limitVertex",e)}setGUISolution(e,t){this.defaultPass.setUniformVector2("guiSolution",e),this.defaultPass.setUniformFloat("pixelRatio",t)}setScissorRect(e,t,r,s){this._scissorRect||(this._scissorRect=new j),this._scissorRect.set(e,t,r,s),this.defaultPass.setUniformVector4("scissorRect",this._scissorRect)}setScissorEnable(e){this._scissorEnable!=e&&(this._scissorEnable=e,e?this.defaultPass.setDefine("SCISSOR_ENABLE",!0):this.defaultPass.deleteDefine("SCISSOR_ENABLE"),this.defaultPass.noticeValueChange())}setScissorCorner(e,t){this.defaultPass.setUniformFloat("scissorCornerRadius",e),this.defaultPass.setUniformFloat("scissorFadeOutSize",t)}setScreenSize(e,t){return this._screenSize.set(e,t),this.defaultPass.setUniformVector2("screenSize",this._screenSize),this}setTextures(e){for(let t=0;t<7;t++){let r=e[t]||A.res.whiteTexture;this.defaultPass.setTexture(`tex_${t}`,r),this.setVideoTextureDefine(t,r.isVideoTexture)}}setVideoTextureDefine(e,t){let r=!1;t!=this._videoTextureFlags[e]&&(t?this.defaultPass.setDefine(`VideoTexture${e}`,!0):this.defaultPass.deleteDefine(`VideoTexture${e}`),this._videoTextureFlags[e]=t,r=!0),r&&this.defaultPass.noticeValueChange()}set envMap(e){}set shadowMap(e){}set baseMap(e){}set normalMap(e){}set emissiveMap(e){}set irradianceMap(e){}set irradianceDepthMap(e){}}class Qc extends ce{constructor(){super(...arguments),o(this,"_guiGeometry")}init(e){super.init(),this.addRendererMask(Ue.UI),this.removeRendererMask(Ue.Default),this.castGI=!1,this.castShadow=!1,this.alwaysRender=!0,this._ignoreEnvMap=this._ignorePrefilterMap=!0}get geometry(){return super.geometry}set geometry(e){super.geometry=e,this._guiGeometry=e}nodeUpdate(e,t,r,s){for(let a=0;a<this.materials.length;a++){let l=this.materials[a].getPass(t),h=this._guiGeometry.vPositionBuffer,u=this._guiGeometry.vSpriteBuffer,c=this._guiGeometry.vColorBuffer;if(l)for(let f=0;f<l.length;f++){const d=l[f];d.pipeline||(d.setStorageBuffer("vPositionBuffer",h),d.setStorageBuffer("vSpriteBuffer",u),d.setStorageBuffer("vColorBuffer",c))}}super.nodeUpdate(e,t,r,s)}onUpdate(e){}}class Vc{constructor(){o(this,"_use"),o(this,"_unUse"),this._use=[],this._unUse=[]}pushBack(e){let t=this._use.indexOf(e);t!=-1&&(this._use.splice(t,1),this._unUse.push(e))}getUseList(){return this._use}getOne(e,t){let r;return this._unUse.length>0?(r=this._unUse[0],this._unUse.splice(0,1),this._use.push(r),r):(r=new e(t),this._use.push(r),r)}hasFree(){return this._unUse.length>0}}let xr;const oa=class{constructor(){o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"width",1),o(this,"height",1),o(this,"_globalX",0),o(this,"_globalY",0),o(this,"_globalWidth",0),o(this,"_globalHeight",0),o(this,"_visible",!0),o(this,"_offsetX",0),o(this,"_offsetY",0),o(this,"_sprite",A.res.defaultGUISprite),o(this,"_color",new z(1,1,1,1)),o(this,"_imageType",pr.Simple),o(this,"dirtyAttributes",Pe.MAX),o(this,"cacheTextureId",-1)}static get quadPool(){return this.textPool||(this.textPool=new Vc),this.textPool}static recycleQuad(i){i.sprite=null,i.dirtyAttributes=Pe.MAX,i.x=0,i.y=0,i.z=-1,i.cacheTextureId=-1,oa.quadPool.pushBack(i)}static spawnQuad(){return oa.quadPool.getOne(oa)}get imageType(){return this._imageType}set imageType(i){this._imageType=i,this.setAttrChange(Pe.SPRITE|Pe.POSITION)}get color(){return this._color}set color(i){this._color.copyFrom(i),this.setAttrChange(Pe.COLOR)}get visible(){return this._visible}set visible(i){i!=this._visible&&(this._visible=i,this.setAttrChange(Pe.SPRITE))}get sprite(){return this._sprite}set sprite(i){this._sprite!=i&&(this._sprite=i,this.setAttrChange(Pe.SPRITE|Pe.POSITION))}get left(){return this._globalX-this._offsetX}get right(){return this.left+this._globalWidth}get top(){return this._globalY-this._offsetY}get bottom(){return this.top+this._globalHeight}setSize(i,e){this.width=i,this.height=e,this.setAttrChange(Pe.POSITION)}setXY(i,e){this.x=i,this.y=e,this.setAttrChange(Pe.POSITION)}setAttrChange(i){this.dirtyAttributes=this.dirtyAttributes|i}applyTransform(i){this.setAttrChange(Pe.POSITION);let e=this._sprite,t=i.getWorldMatrix();(this.x!=0||this.y!=0)&&(t=this.getQuadMatrix(t));let r=t.getScaleX(),s=t.getScaleY(),a=e.isSliced&&this._imageType==pr.Sliced;if(this._offsetX=i.width*.5*r,this._offsetY=i.height*.5*s,a)this._globalWidth=r*(i.width-(e.offsetSize.z-e.trimSize.x)),this._globalHeight=s*(i.height-(e.offsetSize.w-e.trimSize.y)),this._globalX=t.tx+e.offsetSize.x*r,this._globalY=t.ty+e.offsetSize.y*s;else{let n=this.width/e.offsetSize.z,l=this.height/e.offsetSize.w;this._globalWidth=r*e.trimSize.x*n,this._globalHeight=s*e.trimSize.y*l,this._globalX=t.tx+e.offsetSize.x*n*r,this._globalY=t.ty+e.offsetSize.y*l*s}return this}getQuadMatrix(i){return xr||(xr=new Qi),xr.identity(),xr.setTranslate(this.x,this.y),xr.mul(i),xr}writeToGeometry(i,e){return i.fillQuad(this,e),this.dirtyAttributes=Pe.NONE,this}};let Fi=oa;o(Fi,"textPool");class ln extends Ee{constructor(){super(...arguments),o(this,"_uiTransform"),o(this,"_visible",!0)}destroy(){this._uiTransform.setNeedUpdateUIPanel(),super.destroy()}get uiTransform(){return this._uiTransform}get visible(){return this._visible}set visible(e){var t;this._visible!=e&&(this._visible=e,(t=this.onUIComponentVisible)==null||t.call(this,this._visible))}init(e){var t;(t=super.init)==null||t.call(this,e),this._uiTransform=this.object3D.getOrAddComponent(li),this._uiTransform.setNeedUpdateUIPanel()}copyComponent(e){return this.visible=e.visible,this}}class cs extends ln{constructor(){super(...arguments),o(this,"_mainQuads"),o(this,"_shadowRender"),o(this,"_shadowSource"),o(this,"isUIShadow"),o(this,"isShadowless"),o(this,"needUpdateShadow")}init(e){var t;(t=super.init)==null||t.call(this,e),this._mainQuads=[]}destroy(){var e,t;this.detachQuads(),(e=this._shadowRender)==null||e.setShadowSource(null),(t=this._shadowSource)==null||t.setShadowRenderer(null),super.destroy(),this._shadowRender=null,this._shadowSource=null}start(){var e;(e=super.start)==null||e.call(this),this.isUIShadow?this.autoBindShadow(null,this):this.isShadowless||this.autoBindShadow(this,null),this.setShadowDirty()}setShadowDirty(){this._shadowRender&&(this._shadowRender.needUpdateShadow=!0)}get mainQuads(){return this._mainQuads}setShadowRenderer(e){this._shadowRender=e}setShadowSource(e){this._shadowSource=e}getShadowRender(){return this._shadowRender}autoBindShadow(e,t){let r=this.object3D.components.values();if(!e)for(let s of r){let a=s;if(!(a.isShadowless||a.isUIShadow)&&a.mainQuads){e=a;break}}if(!t)for(let s of r){let a=s;if(a.isUIShadow&&a.mainQuads){t=a;break}}return e&&t?(e.setShadowRenderer(t),t.setShadowSource(e),!0):!1}recycleQuad(e){if(e&&this._mainQuads){let t=this._mainQuads.indexOf(e);t>=0?(this._mainQuads.splice(t,1),Fi.recycleQuad(e)):e=null}return e}attachQuad(e){return this._mainQuads&&this._mainQuads.push(e),this}detachQuads(){if(this._mainQuads)for(;this._mainQuads.length>0;){let e=this._mainQuads.shift();this.recycleQuad(e)}return this}copyComponent(e){return super.copyComponent(e),this.isUIShadow=e.isUIShadow,this.isShadowless=e.isShadowless,this}}class Vi extends cs{init(e){var t;(t=super.init)==null||t.call(this,e),this.attachQuad(Fi.spawnQuad()),this.sprite=A.res.defaultGUISprite}cloneTo(e){e.getOrAddComponent(Vi).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.sprite=e.sprite,this.color=e.color,this.imageType=e.imageType,this}set sprite(e){e||(e=A.res.defaultGUISprite);for(let t of this._mainQuads)t.sprite=e,t.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}onTransformResize(){this.applyTransformSize()}applyTransformSize(){for(let e of this._mainQuads)e.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}get sprite(){return this._mainQuads[0].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}get color(){return this._mainQuads[0].color}set color(e){for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get imageType(){return this._mainQuads[0].imageType}set imageType(e){for(let t of this._mainQuads)t.imageType=e;this.setShadowDirty()}}class ws extends Vi{constructor(){super(...arguments),o(this,"space",Nt.World),o(this,"needUpdateGeometry",!0),o(this,"panelOrder",0),o(this,"needSortOnCameraZ"),o(this,"_billboard"),o(this,"_rebuild"),o(this,"scissorEnable",!1),o(this,"scissorCornerRadius",0),o(this,"scissorFadeOutSize",0),o(this,"_uiRenderer"),o(this,"_uiMaterial"),o(this,"_geometry"),o(this,"_limitVertexCount",0),o(this,"_maxCount",128),o(this,"isUIPanel",!0),o(this,"_collectTransform",[])}cloneTo(e){e.getOrAddComponent(ws).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.panelOrder=e.panelOrder,this.needSortOnCameraZ=e.needSortOnCameraZ,this.cullMode=e.cullMode,this.billboard=e.billboard,this.scissorEnable=e.scissorEnable,this.scissorCornerRadius=e.scissorCornerRadius,this.scissorFadeOutSize=e.scissorFadeOutSize,this}init(e){super.init(e),this.create(this.space),this.visible=!1}create(e){this._maxCount=this.space==Nt.World?ye.quadMaxCountForWorld:ye.quadMaxCountForView,this._uiRenderer=this.object3D.addComponent(Qc),this._geometry=this._uiRenderer.geometry=new Fc(this._maxCount).create(),this._uiMaterial=this._uiRenderer.material=new Gc(e),this._uiRenderer.renderOrder=ye.SortOrderStartWorld,this._rebuild=new zc,this.object3D.bound=new Be(new g,new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1))}get quadMaxCount(){return this._maxCount}set billboard(e){this.space==Nt.View?e=xi.None:console.warn("Cannot enable billboard in view space"),e==xi.BillboardXYZ||e==xi.BillboardY?(this._billboard=this.object3D.getOrAddComponent(ys),this._billboard.type=e):(this.object3D.removeComponent(ys),this._billboard=null)}get billboard(){return this._billboard?this._billboard.type:xi.None}set cullMode(e){this.space==Nt.World?this._uiRenderer.material.cullMode=e:console.warn("Cannot change cullMode in view space")}get cullMode(){return this._uiRenderer.material.cullMode}onUpdate(e){var t;(t=super.onUpdate)==null||t.call(this,e),this.rebuildGUIMesh(e)}rebuildGUIMesh(e){let t=this,r=t._collectTransform;if(r.length=0,t.object3D.getComponents(li,r),r.length>0){t._rebuild.build(r,t,t.needUpdateGeometry);for(const h of r)h.needUpdateQuads=!1}let s=t.object3D.getComponentFromParent(Cs),a=s?s.index:0;t._uiRenderer.enable=r.length>0;let n=t.isViewPanel?ye.SortOrderStartView:ye.SortOrderStartWorld;t._uiRenderer.renderOrder=a*ye.SortOrderCanvasSpan+n+t.panelOrder,t._uiRenderer.needSortOnCameraZ=t.needSortOnCameraZ;let l=t._uiMaterial;if(l.setGUISolution(ye.solution,ye.pixelRatio),l.setScreenSize(S.canvas.clientWidth,S.canvas.clientHeight),l.setLimitVertex(t._limitVertexCount),l.setScissorEnable(t.scissorEnable),t.scissorEnable){let h=t.mainQuads[0];l.setScissorRect(h.left,h.bottom,h.right,h.top),l.setScissorCorner(t.scissorCornerRadius,t.scissorFadeOutSize)}t.needUpdateGeometry=!1}}class Ca extends ws{constructor(){super(),o(this,"isViewPanel",!0),o(this,"space",Nt.View)}cloneTo(e){e.getOrAddComponent(Ca).copyComponent(this)}}class wa extends ws{constructor(){super(),o(this,"isWorldPanel",!0),o(this,"space",Nt.World),o(this,"_depthTest",!0)}cloneTo(e){e.getOrAddComponent(wa).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.depthTest=e.depthTest,this}get depthTest(){return this._depthTest}set depthTest(e){if(this._depthTest!=e){this._depthTest=e;let t=this.depthTest?vt.less_equal:vt.always;this._uiRenderer.material.depthCompare=t}}}let hn;class li extends Ee{constructor(){super(),o(this,"useParentPivot",!1),o(this,"parent"),o(this,"pivotX",.5),o(this,"pivotY",.5),o(this,"_width",100),o(this,"_height",100),o(this,"_localVisible",!0),o(this,"_globalVisible",!0),o(this,"_uiInteractiveList"),o(this,"_localMatrix"),o(this,"_worldMatrix"),o(this,"_onChange",!0),o(this,"needUpdateQuads",!0),o(this,"_tempTransforms",[]),this._localMatrix=new Qi,this._worldMatrix=new Qi}get uiInteractiveList(){return this._uiInteractiveList}init(e){var t;super.init(e),this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),this.onParentChange(null,(t=this.object3D.parent)==null?void 0:t.object3D)}onTransformChange(e){this.onChange=!0}addUIInteractive(e){return this._uiInteractiveList||(this._uiInteractiveList=[]),this._uiInteractiveList.push(e),this}removeUIInteractive(e){if(this._uiInteractiveList){let t=this._uiInteractiveList.indexOf(e);if(t>=0)return this._uiInteractiveList.slice(t,1),e}return null}get globalVisible(){return this._globalVisible}set visible(e){if(this._localVisible!=e){this._localVisible=e;let t=this.parent?this.parent._globalVisible:!0;this.onUITransformVisible(this._localVisible&&t)}}get visible(){return this._localVisible}onUITransformVisible(e){let t=this._localVisible&&e;t!=this._globalVisible&&(this._globalVisible=t,this.object3D.components.forEach((r,s)=>{let a=r;if(a.onUITransformVisible)if(a==this)for(let n of this.object3D.entityChildren){let l=n.getComponent(li);l&&l.onUITransformVisible(this._globalVisible)}else a.onUITransformVisible(this._globalVisible)}))}onParentChange(e,t){var r,s;(r=this.parent)==null||r.setNeedUpdateUIPanel(),this.parent=t?.getComponent(li),(s=this.parent)==null||s.setNeedUpdateUIPanel()}get width(){return this._width}get height(){return this._height}resize(e,t){var r;if(this._width!=e||this._height!=t){this._width=e,this._height=t,this.onChange=!0;for(let s of this.object3D.components.values())(r=s.onTransformResize)==null||r.call(s);return!0}return!1}get x(){return this.object3D.x}set x(e){e!=this.object3D.x&&(this.object3D.x=e,this.onChange=!0)}get y(){return this.object3D.y}set y(e){e!=this.object3D.y&&(this.object3D.y=e,this.onChange=!0)}setXY(e,t){let r=this.object3D.localPosition;r.set(e,t,r.z),this.object3D.localPosition=r,this.onChange=!0}get z(){return this.object3D.z}set z(e){e!=this.object3D.z&&(this.object3D.z=e,this.onChange=!0)}get scaleX(){return this.object3D.scaleX}set scaleX(e){this.onChange=!0,this.object3D.scaleX=e}get scaleY(){return this.object3D.scaleY}set scaleY(e){this.onChange=!0,this.object3D.scaleY=e}get scaleZ(){return this.object3D.scaleZ}set scaleZ(e){this.onChange=!0,this.object3D.scaleZ=e}get onChange(){return this._onChange}set onChange(e){if(this._onChange!=e&&(this._onChange=e,e)){this._tempTransforms.length=0;let t=this.object3D.getComponents(li,this._tempTransforms,!0);for(let r of t)r._onChange=!0,r.needUpdateQuads=!0}}onEnable(){this.setNeedUpdateUIPanel(),this.onChange=!0}onDisable(){this.setNeedUpdateUIPanel(),this.onChange=!0}setNeedUpdateUIPanel(){let e;e=this.object3D.getComponentFromParent(wa),e||(e=this.object3D.getComponentFromParent(Ca)),e&&(e.needUpdateGeometry=!0)}cloneTo(e){let t=e.getOrAddComponent(li);t.visible=this.visible,t.x=this.x,t.y=this.y,t.z=this.z,t.resize(this.width,this.height),t.pivotX=this.pivotX,t.pivotY=this.pivotY,t.scaleX=this.scaleX,t.scaleY=this.scaleY}matrix(){let e=this._localMatrix,t=this.object3D.rotationZ;return this.parent?(e.updateScaleAndRotation(this.object3D.scaleX,this.object3D.scaleY,t,t),e.tx=this.object3D.x,e.ty=this.object3D.y):e.updateScaleAndRotation(1,1,0,0),(this.pivotX!=.5||this.pivotY!=.5)&&(hn||(hn=new Qi().identity()),e.mul(hn.setTo(1,0,0,1,-(this.pivotX-.5)*this.width,-(this.pivotY-.5)*this.height))),e}getWorldMatrix(){let e=this,t=e._worldMatrix;return this._onChange&&(t.copyFrom(e.matrix()),e.parent&&t.mul(e.parent.getWorldMatrix()),e._onChange=!1),t}beforeDestroy(e){var t;this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),(t=super.beforeDestroy)==null||t.call(this,e)}}class Hc{constructor(){o(this,"_ray"),o(this,"_mouseCode"),o(this,"_clickEvent"),o(this,"_outEvent"),o(this,"_overEvent"),o(this,"_upEvent"),o(this,"_downEvent"),o(this,"_view"),o(this,"_lastDownTarget"),o(this,"_lastOverTarget"),o(this,"_lastDownPosition",new Z),o(this,"_calcDistanceVec2",new Z),o(this,"_lastDownTime",0),o(this,"_clickTimeSpan",200),o(this,"_clickDistanceSpan",10),o(this,"_colliderOut",[]),o(this,"_transformList",[]),o(this,"_sortWorldPanelList",[]),o(this,"_iteractive2PanelDict",new Map)}init(e){this._view=e,this._ray=new ci,this._clickEvent=new R(R.PICK_CLICK_GUI),this._outEvent=new R(R.PICK_OUT_GUI),this._overEvent=new R(R.PICK_OVER_GUI),this._upEvent=new R(R.PICK_UP_GUI),this._downEvent=new R(R.PICK_DOWN_GUI),A.inputSystem.addEventListener(R.POINTER_DOWN,this.onTouchDown,this,null,1),A.inputSystem.addEventListener(R.POINTER_UP,this.onTouchUp,this,null,1),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onTouchMove,this,null,1),A.inputSystem.addEventListener(R.POINTER_CLICK,this.onTouchClick,this,null,1)}onTouchClick(e){this._lastOverTarget&&e.stopImmediatePropagation()}onTouchMove(e){this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r!=this._lastOverTarget&&(this._lastOverTarget&&this._lastOverTarget.enable&&(this._lastOverTarget.mouseStyle=De.NORMAL,this._outEvent.data=this._lastOverTarget,this._lastOverTarget.object3D.dispatchEvent(this._outEvent)),r&&(r.mouseStyle=De.OVER,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastOverTarget=r)}onTouchDown(e){this._lastDownTime=he.time,this._lastDownPosition.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r&&(r.mouseStyle=De.DOWN,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastDownTarget=r}onTouchUp(e){this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;this._lastDownTarget&&this._lastDownTarget.enable&&(this._lastDownTarget.mouseStyle=De.NORMAL),r&&r==this._lastDownTarget&&he.time-this._lastDownTime<=this._clickTimeSpan&&(this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._calcDistanceVec2.distance(this._lastDownPosition)<=this._clickDistanceSpan&&(this._clickEvent.data={pick:r,pickInfo:t,mouseCode:this._mouseCode},r.object3D.dispatchEvent(this._clickEvent))),this._lastDownTarget=null}collectEntities(){return this._colliderOut.length=0,this._sortWorldPanelList.length=0,this._iteractive2PanelDict.clear(),this._view.canvasList.slice().reverse().forEach(t=>{if(t&&t.transform&&t.transform.parent){let r=t.object3D.getComponentsByProperty("isUIPanel",!0,!0);r.sort((s,a)=>{let n=s._uiRenderer.__renderOrder,l=a._uiRenderer.__renderOrder;return n>l?-1:1});for(let s of r){this._transformList.length=0,s.object3D.getComponents(li,this._transformList),this._transformList.reverse();for(const a of this._transformList){let n=a.uiInteractiveList;if(n&&n.length>0)for(let l of n)this._colliderOut.push(l),this._iteractive2PanelDict.set(l,s)}}}}),this._colliderOut}pick(e){this._ray=this._view.camera.screenPointToRay(A.inputSystem.mouseX,A.inputSystem.mouseY);let t=new Z(A.inputSystem.mouseX,A.inputSystem.mouseY),r=new Z(S.canvas.clientWidth,S.canvas.clientHeight),s;for(const a of e)if(a.interactive&&a.enable&&a.interactiveVisible){let n=this._iteractive2PanelDict.get(a);if(s=a.rayPick(this._ray,n,t,r),s)return s.collider=a,s}return null}}var Yc=(i=>(i[i.COLLINEAR=0]="COLLINEAR",i[i.LINES_INTERSECT=1]="LINES_INTERSECT",i[i.SEGMENTS_INTERSECT=2]="SEGMENTS_INTERSECT",i[i.A_BISECTS_B=3]="A_BISECTS_B",i[i.B_BISECTS_A=4]="B_BISECTS_A",i[i.PARALELL=5]="PARALELL",i))(Yc||{}),Xc=(i=>(i[i.ON_LINE=0]="ON_LINE",i[i.LEFT_SIDE=1]="LEFT_SIDE",i[i.RIGHT_SIDE=2]="RIGHT_SIDE",i))(Xc||{});const pt=class{constructor(i,e){o(this,"start"),o(this,"end"),o(this,"color",new z(1,1,1,1)),o(this,"_normal"),o(this,"_normalCalculated",!1),this.start=i,this.end=e}set(i,e){this.start=i,this.end=e}getCenter(){let i=g.HELP_0;return this.start.subtract(this.end,i),i.scaleBy(.5),i.add(this.end),i}inverse(){let i=this.start;this.start=this.end,this.end=i}equals(i){return this.start==i.start&&this.end==i.end||this.start==i.end&&this.end==i.start}toArray(){return[this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z]}static getLines(i){let e=[];for(let t=0;t<i.length;t++){let r=t,s=ro(t+1,i.length),a=i[r],n=i[s];e.push(new pt(a,n))}return e}intersection(i,e=null){var t=(i.end.z-i.start.z)*(this.end.x-this.start.x)-(i.end.x-i.start.x)*(this.end.z-this.start.z),r=(i.end.x-i.start.x)*(this.start.z-i.start.z)-(i.end.z-i.start.z)*(this.start.x-i.start.x),s=(i.start.x-this.start.x)*(this.end.z-this.start.z)-(i.start.z-this.start.z)*(this.end.x-this.start.x);if(t==0)return r==0&&s==0?0:5;r=r/t,s=s/t;var a=this.start.x+r*(this.end.x-this.start.x),n=this.start.z+r*(this.end.z-this.start.z);return e!=null&&(e.x=a,e.y=0,e.z=n),r>=0&&r<=1&&s>=0&&s<=1?2:s>=0&&s<=1?3:r>=0&&r<=1?4:1}getDirection(){var i=this.end.subtract(this.start),e=new g(i.x,i.y);return e.normalize()}copyFrom(i){this.start||(this.start=new g),this.end||(this.end=new g),this.start.copyFrom(i.start),this.end.copyFrom(i.end)}static IsEqual(i,e){return Math.abs(i-e)<1e-7}static squreDistanceSegmentToSegment(i,e,t){let r=i.start,s=i.end,a=e.start,n=e.end,l=r.x,h=r.y,u=r.z,c=s.x,f=s.y,d=s.z,p=a.x,m=a.y,_=a.z,v=n.x,y=n.y,C=n.z,B=c-l,T=f-h,M=d-u,D=v-p,P=y-m,L=C-_,I=l-p,O=h-m,k=u-_,H=B*B+T*T+M*M,W=B*D+T*P+M*L,ne=D*D+P*P+L*L,fe=B*I+T*O+M*k,we=D*I+P*O+L*k,ze=H*ne-W*W,Re=ze,ue=ze,de=0,Ge=0;this.IsEqual(ze,0)?(de=0,Re=1,Ge=we,ue=ne):(de=W*we-ne*fe,Ge=H*we-W*fe,de<0?(de=0,Ge=we,ue=ne):de>Re&&(de=Re,Ge=we+W,ue=ne)),Ge<0?(Ge=0,-fe<0?de=0:-fe>H?de=Re:(de=-fe,Re=H)):Ge>ue&&(Ge=ue,-fe+W<0?de=0:-fe+W>H?de=Re:(de=-fe+W,Re=H));let ot=0,nt=0;this.IsEqual(de,0)?ot=0:ot=de/Re,this.IsEqual(Ge,0)?nt=0:nt=Ge/ue;let Et=I+ot*B-nt*D,_t=O+ot*T-nt*P,xt=k+ot*M-nt*L;return Et*Et+_t*_t+xt*xt}isNear(i,e=0,t){let r=g.HELP_0,s=g.HELP_1;r.copyFrom(i.origin),s.copyFrom(i.direction),s.scaleBy(9999),s.add(r,s),pt.cacluteLine0.set(r,s),pt.cacluteLine1.copyFrom(this),t&&(t.perspectiveMultiplyPoint3(pt.cacluteLine1.start,pt.cacluteLine1.start),t.perspectiveMultiplyPoint3(pt.cacluteLine1.end,pt.cacluteLine1.end));let a=pt.squreDistanceSegmentToSegment(pt.cacluteLine0,pt.cacluteLine1,t);return a+1e-4<=e?(i.length=a,!0):(i.length=-999999,!1)}};let vr=pt;o(vr,"cacluteLine0",new pt(null,null)),o(vr,"cacluteLine1",new pt(null,null));const Wc=class{constructor(i,e,t){o(this,"v1"),o(this,"v2"),o(this,"v3"),o(this,"u1"),o(this,"u2"),o(this,"u3"),o(this,"n1"),o(this,"n2"),o(this,"n3"),o(this,"t0"),o(this,"t"),o(this,"u"),o(this,"v"),o(this,"min",new g),o(this,"max",new g),o(this,"id",0),this.id=Wc.ID+++200,i&&e&&t&&this.set(i,e,t)}set(i,e,t){this.v1=i,this.v2=e,this.v3=t;let r=this.min,s=this.max;return r.x=Math.min(this.v1.x,this.v2.x,this.v3.x),r.y=Math.min(this.v1.y,this.v2.y,this.v3.y),r.z=Math.min(this.v1.z,this.v2.z,this.v3.z),s.x=Math.max(this.v1.x,this.v2.x,this.v3.x),s.y=Math.max(this.v1.y,this.v2.y,this.v3.y),s.z=Math.max(this.v1.z,this.v2.z,this.v3.z),this}getNormal(){let i=this.v1,e=this.v2,t=this.v3,r=new g(e.x-i.x,e.y-i.y,e.z-i.z),a=new g(t.x-i.x,t.y-i.y,t.z-i.z).crossProduct(r);return a.normalize(),a}turnBack(){let i=this.v3;this.v3=this.v1,this.v1=i}getLines(){let i=this.v1,e=this.v2,t=this.v3;return[new vr(i,e),new vr(e,t),new vr(t,i)]}equals(i){let e=this.getLines(),t=i.getLines(),r=0;for(let s=0;s<e.length;s++)for(let a=0;a<t.length;a++)e[s].equals(t[a])&&r++;return r==3}getCenter(){let i=this.min,e=this.max,t=new g;return t.x=(i.x+e.x)*.5,t.y=(i.y+e.y)*.5,t.z=(i.z+e.z)*.5,t}intersects(i){var e=this.max,t=this.min,r=i.max,s=i.min;return t.x<=r.x&&e.x>=s.x&&t.y<=r.y&&e.y>=s.y&&t.z<=r.z&&e.z>=s.z}sign2D(i,e,t){return(i.x-t.x)*(e.z-t.z)-(e.x-t.x)*(i.z-t.z)}pointInTriangle2D(i){let e=this.v1,t=this.v2,r=this.v3,s,a,n,l,h;return s=this.sign2D(i,e,t),a=this.sign2D(i,t,r),n=this.sign2D(i,r,e),l=s<0||a<0||n<0,h=s>0||a>0||n>0,!(l&&h)}toArray(){return[this.v1.x,this.v1.y,this.v1.z,this.v2.x,this.v2.y,this.v2.z,this.v3.x,this.v3.y,this.v3.z]}};let na=Wc;o(na,"ID",-1);class Ft{static init(){this._pt0=new g,this._pt1=new g,this._pt2=new g,this._pt3=new g,this._ray=new ci,this._triangle=new na,this._hitPoint=new g,this._worldMatrix=new V}static rayPick(e,t,r,s,a,n){this._isInit||(this.init(),this._isInit=!0);let l=this._worldMatrix;if(s==Nt.World){let h;this.calculateHotArea_World(a,this._pt0,this._pt1,this._pt2,this._pt3),l.copyFrom(n).invert();let u=this._ray;if(u.copy(e).applyMatrix(l),this._triangle.set(this._pt0,this._pt1,this._pt2),h=u.intersectTriangle(u.origin,u.direction,this._triangle),h||(this._triangle.set(this._pt1,this._pt2,this._pt3),h=u.intersectTriangle(u.origin,u.direction,this._triangle)),h)return{distance:0,intersectPoint:h}}else{this.calculateHotArea_View(a,this._pt0,this._pt1,this._pt2,this._pt3);let h=r.x,u=r.y,c=Math.min(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,f=Math.min(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5,d=Math.max(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,p=Math.max(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5;return t.x<=d&&t.x>=c&&t.y<=p&&t.y>=f?(this._hitPoint.set(t.x,t.y,0),{distance:0,intersectPoint:this._hitPoint}):null}return null}static calculateHotArea_View(e,t,r,s,a){let n=e.getWorldMatrix(),l=n.getScaleX(),h=n.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;t.set(-u,-c,0),r.set(u,-c,0),s.set(-u,c,0),a.set(u,c,0);let f=n.tx;t.x+=f,r.x+=f,s.x+=f,a.x+=f,f=n.ty,t.y-=f,r.y-=f,s.y-=f,a.y-=f,t.multiplyScalar(ye.pixelRatio),r.multiplyScalar(ye.pixelRatio),s.multiplyScalar(ye.pixelRatio),a.multiplyScalar(ye.pixelRatio)}static calculateHotArea_World(e,t,r,s,a){let n=e.getWorldMatrix(),l=n.getScaleX(),h=n.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;t.set(-u,c,0),r.set(u,c,0),s.set(-u,-c,0),a.set(u,-c,0);let f=n.tx;t.x+=f,r.x+=f,s.x+=f,a.x+=f,f=n.ty,t.y+=f,r.y+=f,s.y+=f,a.y+=f}}o(Ft,"_pt0"),o(Ft,"_pt1"),o(Ft,"_pt2"),o(Ft,"_pt3"),o(Ft,"_hitPoint"),o(Ft,"_worldMatrix"),o(Ft,"_ray"),o(Ft,"_triangle"),o(Ft,"_isInit");var jc=(i=>(i[i.UpperLeft=0]="UpperLeft",i[i.UpperCenter=1]="UpperCenter",i[i.UpperRight=2]="UpperRight",i[i.MiddleLeft=3]="MiddleLeft",i[i.MiddleCenter=4]="MiddleCenter",i[i.MiddleRight=5]="MiddleRight",i[i.LowerLeft=6]="LowerLeft",i[i.LowerCenter=7]="LowerCenter",i[i.LowerRight=8]="LowerRight",i))(jc||{}),qc=(i=>(i[i.Upper=0]="Upper",i[i.Middle=1]="Middle",i[i.Lower=2]="Lower",i))(qc||{}),Kc=(i=>(i[i.Left=0]="Left",i[i.Center=1]="Center",i[i.Right=2]="Right",i))(Kc||{});class Jc{constructor(){o(this,"charList",[]),o(this,"quadList",[]),o(this,"width",0),o(this,"index",0)}}class Zc{layout(e){let t=[],r=e.originSize,s=gr.getFontData(e.font,r),a=e.fontSize/r;return this.makeTextLine(e.uiTransform,e.alignment,t,e.font,s,e.text,a,r,e.lineSpacing),t}makeTextLine(e,t,r,s,a,n,l,h,u){let c=-1,f=0,d=h*l,p=d*.5,m=e.width/l,_=e.height/l,v=0,y=e.height,C=()=>{f=0,c++;let D=new Jc;return D.index=c,r.push(D),D},B=(D,P)=>{const L=D.charCodeAt(0).toString();let I=gr.getFnt(s,h,L),O=null;return I?(O=Fi.spawnQuad(),O.sprite=I,O.x=(f+I.xoffset)*l-v,O.y=(a.base-I.height-I.yoffset-a.base)*l+y,O.width=I.offsetSize.width*l,O.height=I.offsetSize.height*l,f+=I.xadvance):D==`
`||(D=="	"?f+=d:f+=p),P.width=f,P.quadList.push(O),P.charList.push(D),O},T=()=>{let D=this.getAlignment(t);switch(D.v){case 0:for(let P=0,L=r.length;P<L;P++){let I=r[P];if(P>0){let O=P*d*u;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.y-=O)}}}break;case 1:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(_-L*h*u)*.5*l+P*d*u;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.y-=O)}}break;case 2:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(_-L*h*u)*l+P*d*u;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.y-=O)}}break}switch(D.h){case 0:break;case 1:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(m-I.width)*.5*l;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.x+=O)}}break;case 2:for(let P=0,L=r.length;P<L;P++){let I=r[P],O=(m-I.width)*l;for(let k=0,H=I.quadList.length;k<H;k++){let W=I.quadList[k];W&&(W.x+=O)}}break}};(()=>{let D=null,P=n.length,L=!1;for(let I=0;I<P;I++){D==null&&(D=C());let O=n.charAt(I);O==`
`||L?(D=null,L=!1):(B(O,D),L=D.width+d>=m)}})(),T()}getAlignment(e){let t={v:0,h:0};switch(e){case 1:t.v=0,t.h=1;break;case 0:t.v=0,t.h=0;break;case 2:t.v=0,t.h=2;break;case 4:t.v=1,t.h=1;break;case 3:t.v=1,t.h=0;break;case 5:t.v=1,t.h=2;break;case 7:t.v=2,t.h=1;break;case 6:t.v=2,t.h=0;break;case 8:t.v=2,t.h=2;break}return t}}class ba extends ln{constructor(){super(...arguments),o(this,"_style",De.NORMAL),o(this,"_interactive",!1)}set interactive(e){this._interactive=e}get interactive(){return this._interactive}set mouseStyle(e){this._style=e}get interactiveVisible(){return this._uiTransform.globalVisible&&this._visible}init(e){super.init(e),this._uiTransform.addUIInteractive(this)}destroy(){this._uiTransform.removeUIInteractive(this),super.destroy()}rayPick(e,t,r,s){return Ft.rayPick(e,r,s,t.space,this._uiTransform,t.transform.worldMatrix)}cloneTo(e){e.getOrAddComponent(ba).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.enable=e._enable,this.interactive=e._interactive,this.mouseStyle=e._style,this}}var $c=(i=>(i[i.NONE=0]="NONE",i[i.COLOR=1]="COLOR",i[i.SPRITE=2]="SPRITE",i))($c||{});class _n extends ba{constructor(){super(...arguments),o(this,"_spriteMap"),o(this,"_colorMap"),o(this,"_image"),o(this,"_isCreateImage"),o(this,"_transition",2)}init(e){super.init(e),this._interactive=!0,this._spriteMap=new Map,this._colorMap=new Map,this._image=this.object3D.getComponent(Vi),this._isCreateImage=this._image==null,this._image||(this._image=this.object3D.addComponent(Vi)),this.imageType=pr.Sliced}onEnable(){this.mouseStyle=De.NORMAL}onDisable(){this.mouseStyle=De.DISABLE}set transition(e){this._transition!=e&&(this._transition=e,this.validateStyle(this._style,!0))}get transition(){return this._transition}get imageType(){return this._image.imageType}set imageType(e){this._image.imageType=e}setStyleColor(e,t){return this._colorMap.set(e,t),this._style==e&&this.validateStyle(this._style,!0),this}getStyleColor(e){return this._colorMap.get(e)}set mouseStyle(e){super.mouseStyle=e,this.validateStyle(e,!0)}get normalSprite(){return this._spriteMap.get(De.NORMAL)}set normalSprite(e){this._spriteMap.set(De.NORMAL,e),this._style==De.NORMAL&&this.validateStyle(this._style,!0)}get overSprite(){return this._spriteMap.get(De.OVER)}set overSprite(e){this._spriteMap.set(De.OVER,e),this._style==De.OVER&&this.validateStyle(this._style,!0)}set downSprite(e){this._spriteMap.set(De.DOWN,e),this._style==De.DOWN&&this.validateStyle(this._style,!0)}get downSprite(){return this._spriteMap.get(De.DOWN)}set disableSprite(e){this._spriteMap.set(De.DISABLE,e),this._style==De.DISABLE&&this.validateStyle(this._style,!0)}get disableSprite(){return this._spriteMap.get(De.DISABLE)}validateStyle(e,t){if(this._transition&2){let r=this._spriteMap.get(e);this._image.sprite=r}if(this._transition&1){let r=this._colorMap.get(e);r&&(this._image.color=r)}}cloneTo(e){e.getOrAddComponent(_n).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.imageType=e.imageType,this.transition=e.transition,e._spriteMap.forEach((t,r)=>{t&&this._spriteMap.set(r,t)}),e._colorMap.forEach((t,r)=>{t&&this._colorMap.set(r,t.clone())}),this.mouseStyle=e.mouseStyle,this}destroy(){this._isCreateImage&&this._image&&(this.object3D.removeComponent(Vi),this._image=null),super.destroy()}}class xn extends cs{constructor(){super(),o(this,"_count",0)}init(e){var t;(t=super.init)==null||t.call(this,e),this._count=e?e.count:1;for(let r=0;r<this._count;r++)this.attachQuad(Fi.spawnQuad());this._uiTransform.resize(0,0)}getQuad(e){return this._mainQuads[e]}cloneTo(e){e.addComponent(xn,{count:this._count}).copyComponent(this)}copyComponent(e){super.copyComponent(e);for(let t=0;t<e._count;t++)this.setSprite(t,e.getSprite(t)),this.setColor(t,e.getColor(t)),this.setImageType(t,e.getImageType(t));return this}setSprite(e,t){this._mainQuads[e].sprite=t||A.res.defaultGUISprite,this.setShadowDirty()}getSprite(e){return this._mainQuads[e].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}getColor(e){return this._mainQuads[e].color}setColor(e,t){this._mainQuads[e].color=t,this.setShadowDirty()}getImageType(e){return this._mainQuads[e].imageType}setImageType(e,t){this._mainQuads[e].imageType=t,this.setShadowDirty()}setSize(e,t,r){this._mainQuads[e].setSize(t,r),this.setShadowDirty()}setXY(e,t,r){this._mainQuads[e].setXY(t,r),this.setShadowDirty()}getXY(e,t){t||(t=new Z);let r=this._mainQuads[e];return t.x=r.x,t.y=r.y,t}}class vn extends cs{constructor(){super(...arguments),o(this,"_shadowQuality",1),o(this,"_shadowOffset"),o(this,"_shadowRadius"),o(this,"_shadowColor"),o(this,"_subShadowColor"),o(this,"needUpdateShadow",!1)}init(e){var t;(t=super.init)==null||t.call(this,e),this._shadowRadius=2,this._shadowQuality=1,this._shadowOffset=new Z(4,-4),this._shadowColor=new z(.1,.1,.1,.8),this._subShadowColor=this._shadowColor.clone(),this.isUIShadow=!0}cloneTo(e){e.getOrAddComponent(vn).copyComponent(this)}copyComponent(e){return super.copyComponent(this),this._shadowColor=e._shadowColor,this._shadowOffset=e._shadowOffset,this._shadowRadius=e._shadowRadius,this._shadowQuality=e.shadowQuality,this}get shadowColor(){return this._shadowColor}set shadowColor(e){this._shadowColor.copyFrom(e),this.needUpdateShadow=!0}set shadowQuality(e){e=K(e,0,4),this._shadowQuality!=e&&(this._shadowQuality=e,this.needUpdateShadow=!0)}get shadowQuality(){return this._shadowQuality}set shadowOffset(e){this._shadowOffset=e,this.needUpdateShadow=!0}get shadowOffset(){return this._shadowOffset||(this._shadowOffset=new Z(4,-4)),this._shadowOffset}set shadowRadius(e){this._shadowRadius!=e&&(this._shadowRadius=e,this.applyShadow())}get shadowRadius(){return this._shadowRadius}onUpdate(e){this.needUpdateShadow&&(this.applyShadow(),this.needUpdateShadow=!1)}applyShadow(){if(this.detachQuads(),this._shadowSource&&this._shadowQuality>0){let e=this._shadowSource.mainQuads;if(e.length>0)for(let t of e)this.createQuadShadow(t)}this._uiTransform.setNeedUpdateUIPanel()}createQuadShadow(e){let t=this._shadowQuality,r=Math.PI*2;this._subShadowColor.copyFrom(this._shadowColor),this._subShadowColor.a=1/Math.max(1,t);for(let s=0;s<t;s++){let a=Fi.spawnQuad(),n=0,l=0;if(s==0)a.color=this._shadowColor;else{let h=r*(s-1)/(t-1);n=Math.sin(h)*this._shadowRadius,l=Math.cos(h)*this._shadowRadius,a.color=this._subShadowColor}a.setXY(n+this._shadowOffset.x+e.x,l+this._shadowOffset.y+e.y),a.setSize(e.width,e.height),a.sprite=e.sprite,a.visible=e.visible,a.imageType=e.imageType,this.attachQuad(a)}}}class yn extends cs{constructor(){super(),o(this,"_font","\u5FAE\u8F6F\u96C5\u9ED1"),o(this,"_fontSize",14),o(this,"_originSize",42),o(this,"_alignment",0),o(this,"_lineSpacing",1),o(this,"_text",""),o(this,"_color",new z(1,1,1,1)),o(this,"textLine",null),o(this,"layoutProxy",new Zc)}cloneTo(e){e.getOrAddComponent(yn).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this._font=e._font,this._fontSize=e._fontSize,this._originSize=e._originSize,this._alignment=e._alignment,this._lineSpacing=e._lineSpacing,this._color.copyFrom(e._color),this.text=e.text,this}get originSize(){return this._originSize}get font(){return this._font}set font(e){this._font=e}get fontSize(){return this._fontSize}set fontSize(e){this._fontSize!=e&&(this._fontSize=e,this.layoutText())}get text(){return this._text}set text(e){this._text!=e&&(e||(e=""),this._text=e,this.layoutText())}layoutText(){this.detachQuads(),this.textLine=this.layoutProxy.layout(this);for(let e=0,t=this.textLine.length;e<t;e++){let r=this.textLine[e];for(let s=0,a=r.quadList.length;s<a;s++){let n=r.quadList[s];n&&this.attachQuad(n)}}this.color=this._color,this._uiTransform.setNeedUpdateUIPanel(),this.onUIComponentVisible(this._visible),this.setShadowDirty()}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t&&(t.visible=!e);this.setShadowDirty()}onTransformResize(){this.layoutText()}get color(){return this._color}set color(e){this._color.copyFrom(e);for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get alignment(){return this._alignment}set alignment(e){this._alignment!=e&&(this._alignment=e,this.layoutText())}get lineSpacing(){return this._lineSpacing}set lineSpacing(e){this._lineSpacing!=e&&(this._lineSpacing=e,this.layoutText())}}class bp extends Ee{constructor(){super(...arguments),o(this,"_postList")}init(e){this._postList=new Map}start(){}stop(){}onEnable(){this.activePost()}onDisable(){this.unActivePost()}activePost(){let e=this.transform.view3D,t=A.getRenderJob(e);this._postList.forEach(r=>{t.addPost(r)})}unActivePost(){let e=this.transform.view3D,t=A.getRenderJob(e);this._postList.forEach(r=>{t.removePost(r)})}addPost(e){if(this._postList.has(e.prototype))return;let t=new e;return this._postList.set(e.prototype,t),this._enable&&this.activePost(),t}removePost(e){if(!this._postList.has(e.prototype))return;let t=this._postList.get(e.prototype);this._postList.delete(e.prototype);let r=this.transform.view3D;A.getRenderJob(r).removePost(t)}getPost(e){return this._postList.has(e.prototype)?this._postList.get(e.prototype):null}}class ef extends te{constructor(){super(),o(this,"index",0),o(this,"drawCallFrame",-1)}}var un=(i=>(i[i.CastGI=0]="CastGI",i[i.ReceiveGI=1]="ReceiveGI",i[i.CastDepth=2]="CastDepth",i[i.Other=3]="Other",i))(un||{});class cn extends os{constructor(e=0,t=0){super(),N.register("GIProbeShader",yc),this.defaultPass=new We("GIProbeShader","GIProbeShader"),this.defaultPass.setDefine("USE_BRDF",!0),this.defaultPass.setShaderEntry("VertMain","FragMain"),this.defaultPass.setUniformVector4("probeUniform",new j(t,e,0,0));let r=this.defaultPass.shaderState;r.acceptShadow=!1,r.castShadow=!1,r.receiveEnv=!1,r.acceptGI=!1,r.useLight=!1;let s=A.res.getTexture("BRDFLUT");this.brdfLUT=s,this.baseMap=A.res.whiteTexture,this.normalMap=A.res.normalTexture,this.emissiveMap=A.res.blackTexture}debug(){}}o(cn,"count",0);class Sp extends Ee{constructor(){super(...arguments),o(this,"_probes"),o(this,"_volume"),o(this,"_debugMr",[])}init(){A.setting.gi.enable=!0}start(){this._volume=pe.getLightEntries(this.transform.scene3D).irradianceVolume,this.initProbe()}initProbe(){let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,s=new ls(4,16,16),a=new g;this._probes=[];for(let n=0;n<e;n++)for(let l=0;l<t;l++)for(let h=0;h<r;h++){let u=n+h*e+l*(e*r),c=new ef;c.index=u,c.name=`${n}_${l}_${h}`;let f=c.addComponent(ce);f.material=new cn(un.CastGI,u),f.geometry=s,f.castGI=!1,f.castShadow=!1,this._debugMr.push(f),this.object3D.addChild(c),this._volume.calcPosition(n,l,h,a),c.x=a.x,c.y=a.y,c.z=a.z,this._probes[u]=c,this._debugMr.push(f)}for(let n=0;n<this._probes.length;n++)Q.instance.addGIProbe(this.transform.scene3D,this._probes[n]);this.object3D.transform.enable=!1,this._volume.setting.debug&&this.debug()}debug(){}debugProbeRay(e,t){const r=A.setting.gi.rayNumber;let s=new q(0,-.7071067811865475,.7071067811865475,0);for(let a=0;a<r;a++){let n=e*r+a,l=new g(-t[n*4+0],-t[n*4+1],-t[n*4+2],0);s.transformVector(l,l);let h=t[n*4+3],u=this._probes[e].transform.worldPosition.clone(),c=l.scaleBy(h);c.add(u,c)}}changeProbesVolumeData(){this._volume.setVolumeDataChange()}changeProbesPosition(){this._volume.setVolumeDataChange();let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,s=new g;for(let a=0;a<e;a++)for(let n=0;n<t;n++)for(let l=0;l<r;l++){let h=a+l*e+n*(e*r),u=this._probes[h];this._volume.calcPosition(a,n,l,s),u.x=s.x,u.y=s.y,u.z=s.z}}onUpdate(){A.setting.gi.maxDistance=A.setting.gi.probeSpace*1.5;let e=this.transform.scene3D.view.camera,t=g.distance(e.transform.worldPosition,e.transform.targetPos)/300;if(this._debugMr&&this._debugMr.length>0)for(let r=0;r<this._debugMr.length;r++){const s=this._debugMr[r].transform;s.scaleX=t,s.scaleY=t,s.scaleZ=t}}}class Ip extends $t{constructor(){super(...arguments),o(this,"_keyRenderGroup"),o(this,"_keyBufferGroup"),o(this,"_keyIdsGroup")}init(e){this._keyRenderGroup=new Map,this._keyBufferGroup=new Map,this._keyIdsGroup=new Map}start(){let e=[];this.object3D.getComponents(ce,e,!0);for(let t=0;t<e.length;t++){const r=e[t];r.transform.updateWorldMatrix(!0),r.enable=!1;let s=r.geometry.instanceID;for(let a=0;a<r.materials.length;a++){const n=r.materials[a];s+=n.instanceID}if(this._keyRenderGroup.has(s))this._keyRenderGroup.get(s).push(r),this._keyIdsGroup.get(s).push(r.transform.worldMatrix.index);else{let a=new ge(e.length);a.visibility=GPUShaderStage.VERTEX,this._keyRenderGroup.set(s,[r]),this._keyBufferGroup.set(s,a),this._keyIdsGroup.set(s,[r.transform.worldMatrix.index])}}this._keyBufferGroup.forEach((t,r)=>{let s=this._keyIdsGroup.get(r),a=this._keyBufferGroup.get(r);a.setInt32Array("matrixIDs",new Int32Array(s)),a.apply()})}stop(){}nodeUpdate(e,t,r,s){this._keyRenderGroup.forEach((a,n)=>{let l=this._keyBufferGroup.get(n),h=a[0];for(let u=0;u<h.materials.length;u++){let f=h.materials[u].getPass(t);if(f)for(let d=0;d<f.length;d++){const p=f[d];p.setDefine("USE_INSTANCEDRAW",!0),p.setStorageBuffer("instanceDrawID",l)}}h.nodeUpdate(e,t,r,s)}),this.preInit=!1}renderPass(e,t,r){this._keyRenderGroup.forEach((s,a)=>{let n=s[0];n.instanceCount=s.length,this.renderItem(e,t,n,r)})}renderItem(e,t,r,s){let a=r.transform._worldMatrix;for(let n=0;n<r.materials.length;n++){let h=r.materials[n].getPass(t);if(!(!h||h.length==0))for(let u=0;u<h.length;u++){if(!h||h.length==0)continue;let c=h[u];w.bindGeometryBuffer(s.encoder,r.geometry);const f=c;f.shaderState.splitTexture&&(s.endRenderPass(),Fe.WriteSplitColorTexture(r.instanceID),s.beginRenderPass(),w.bindCamera(s.encoder,e.camera),w.bindGeometryBuffer(s.encoder,r.geometry)),w.bindPipeline(s.encoder,f);let _=r.geometry.subGeometries[n].lodLevels[r.lodLevel];r.instanceCount>0?w.drawIndexed(s.encoder,_.indexCount,r.instanceCount,_.indexStart,0,0):w.drawIndexed(s.encoder,_.indexCount,1,_.indexStart,0,a.index)}}}}class Ep extends Xe{constructor(){super(),o(this,"radius",2.5),o(this,"height",10),this._shapeType=mr.Capsule}}const la=class extends Xe{constructor(){super(),o(this,"mesh"),o(this,"_pickRet"),this._shapeType=mr.Mesh}rayPick(i,e){if(this.mesh){la.triangle||(la.triangle=new na(new g,new g,new g));let t=this.mesh.getAttribute("position"),r=this.mesh.getAttribute("indices"),s=Xe.helpMatrix;s.copyFrom(e).invert();let a=Xe.helpRay.copy(i);if(a.applyMatrix(s),a.intersectBox(this.mesh.bounds),!a.intersectBox(this.mesh.bounds,Xe.v3_help_0))return null;if(r&&t&&r.data.length>0){let l=t.data;for(let h=0,u=r.data.length/3;h<u;h++){let c=h*3;const f=r.data[c+0]*3,d=r.data[c+1]*3,p=r.data[c+2]*3;let m=la.triangle,_=m.v1.set(l[f+0],l[f+1],l[f+2]),v=m.v2.set(l[d+0],l[d+1],l[d+2]),y=m.v3.set(l[p+0],l[p+1],l[p+2]);m.set(_,v,y);let C=a.intersectTriangle(a.origin,a.direction,m);if(C)return this._pickRet||(this._pickRet={intersectPoint:new g,distance:0}),this._pickRet.intersectPoint=C,this._pickRet.distance=g.distance(a.origin,C),this._pickRet}}}return null}};let tf=la;o(tf,"triangle");class Sa{constructor(e,t){o(this,"center",new g),o(this,"extents"),o(this,"max"),o(this,"min"),o(this,"size"),o(this,"tmpVecA",new g),o(this,"tmpVecB",new g),o(this,"tmpVecC",new g),o(this,"tmpVecD",new g),o(this,"radius",0),o(this,"diffBetweenPoints",new g),o(this,"owner"),o(this,"forward",new g(0,0,1)),o(this,"worldCenter"),o(this,"worldSize"),o(this,"_center",new g),this.center=e||new g(0,0,0),this.radius=t===void 0?.5:t}updateBound(){throw new Error("Method not implemented.")}containsPoint(e){var t=this.tmpVecA.subtract(e,this.center).lengthSquared,r=this.radius;return t<r*r}intersectsRay(e,t){var r=this.tmpVecA.copyFrom(e.origin).subtract(this.center),s=r.dotProduct(this.tmpVecB.copyFrom(e.direction).normalize()),a=r.dotProduct(r)-this.radius*this.radius;if(a>0&&s>0)return null;var n=s*s-a;if(n<0)return!1;var l=Math.abs(-s-Math.sqrt(n));return t&&t.copyFrom(e.direction).scaleBy(l).add(e.origin),!0}intersectsBoundingSphere(e){this.tmpVecA.subtract(e.center,this.center);var t=e.radius+this.radius;return this.tmpVecA.lengthSquared<=t*t}calculateTransform(e){this.update(e)}inFrustum(e,t){return t.containsSphere(e)}clone(){return new Sa(this.center.clone(),this.radius)}update(e){this.owner=e,this._center.add(e.transform.worldMatrix.position,this.center),this.forward=e.transform.forward}merge(e){throw new Error("BoundingSphere merge is not ready!")}setFromCenterAndSize(e,t){this.center.copy(e),this.radius=t}}class Bp extends Xe{constructor(e){super(),o(this,"_pickRet"),o(this,"box"),o(this,"radius",.5),this._shapeType=mr.Sphere,this.radius=e,this.box=new Sa(new g,1)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.radius);let s=Xe.helpMatrix;s.copyFrom(t).invert();let a=Xe.helpRay.copy(e);a.applyMatrix(s);let n=a.intersectSphere(a.origin,a.direction,this.box.center,this.box.radius);return n?(this._pickRet||(this._pickRet={intersect:!1,intersectPoint:new g,distance:0}),this._pickRet.intersect=!0,this._pickRet.intersectPoint=n,this._pickRet.distance=g.distance(a.origin,Xe.v3_help_0),this._pickRet):null}}class Tp extends te{constructor(){super(),o(this,"_envMap"),o(this,"skyObject"),o(this,"envMapChange",!0),o(this,"view"),this.transform.scene3D=this,this.skyObject=new te,this.addChild(this.skyObject),this._isScene3D=!0,this.envMap||(this.envMap=A.res.defaultSky)}get envMap(){return this._envMap}set envMap(e){this._envMap!=e&&(this.envMapChange=!0),this._envMap=e,Q.instance.sky&&"map"in Q.instance.sky&&(Q.instance.sky.map=e)}get exposure(){return Q.instance.sky&&"exposure"in Q.instance.sky?Q.instance.sky.exposure:0}set exposure(e){Q.instance.sky&&"exposure"in Q.instance.sky&&(Q.instance.sky.exposure=e,A.setting.sky.skyExposure=e)}get roughness(){if(Q.instance.sky&&"roughness"in Q.instance.sky)return Q.instance.sky.roughness}set roughness(e){Q.instance.sky&&"roughness"in Q.instance.sky&&(Q.instance.sky.roughness=e)}}class rf extends Us{constructor(){super(3,Ms.triangle_list)}}class sf extends Us{constructor(){super(2,Ms.line_list)}}class af extends te{constructor(){super(),o(this,"mLineRender"),o(this,"mFillRender"),this.mLineRender=this.addComponent(sf),this.mFillRender=this.addComponent(rf)}drawAxis(e,t=new g(0,0,0),r=10){this.createCustomShape(e).buildAxis(t,r)}drawLines(e,t,r=z.COLOR_WHITE){this.createCustomShape(e).buildLines(t,r)}drawCurve(e,t,r=10,s=.5,a=z.COLOR_WHITE){var n=[];let l=new g,h=new g;for(let u=0;u<t.length-1;++u){n.push(t[u]);const c=t[Math.max(u-1,0)],f=t[u],d=t[u+1],p=t[Math.min(u+2,t.length-1)];d.subtract(c,l).multiplyScalar(s/3).add(f,l),f.subtract(p,h).multiplyScalar(s/3).add(d,h),n.push(...this.calculateBezierCurve(f,l,h,d,r))}n.push(t[t.length-1]),this.drawLines(e,n,a)}calculateBezierCurve(e,t,r,s,a){var n=new Array(a);for(let l=0;l<a;++l){let h=(l+1)/(a+1),u=1-h,c=e.mul(u*u*u),f=t.mul(3*h*u*u),d=r.mul(3*h*h*u),p=s.mul(h*h*h);n[l]=c.add(f).add(d).add(p)}return n}drawRect(e,t,r,s,a=z.COLOR_WHITE){this.drawLines(e,[t,new g(t.x+r,t.y,t.z),new g(t.x+r,t.y+s,t.z),new g(t.x,t.y+s,t.z),t],a)}drawCircle(e,t,r,s=32,a=g.Y_AXIS,n=z.COLOR_WHITE){this.createCustomShape(e).buildCircle(t,r,s,a,n)}drawSector(e,t,r,s,a,n=16,l=g.Y_AXIS,h=z.COLOR_WHITE){const u=(a-s)*_e;s*=_e;var c=[];c.push(t);for(let m=0;m<=n;++m){m>0&&c.push(c[c.length-1]);var f=u*(m/n)+s,d=r*Math.cos(f),p=r*Math.sin(f);switch(l){case g.X_AXIS:c.push(t.add(new g(0,d,p)));break;case g.Y_AXIS:c.push(t.add(new g(d,0,p)));break;case g.Z_AXIS:c.push(t.add(new g(d,p,0)));break;default:c.push(t.add(new g(d,p,0)));break}}c.push(c[c.length-1]),c.push(t),this.mLineRender.fillShapeData(e,"line",h,c)}drawArcLine(e,t,r,s,a,n=16,l=g.Y_AXIS,h=z.COLOR_WHITE){this.mLineRender.allocGraphics3DShape(e,this.transform._worldMatrix.index).buildArcLine(t,r,s,a,n,l,h)}createCustomShape(e,t=this.transform){return this.mLineRender.allocGraphics3DShape(e,t._worldMatrix.index)}drawBox(e,t,r,s=z.COLOR_WHITE){var a=[];a.push(t),a.push(new g(r.x,t.y,t.z)),a.push(a[a.length-1]),a.push(new g(r.x,r.y,t.z)),a.push(a[a.length-1]),a.push(new g(t.x,r.y,t.z)),a.push(a[a.length-1]),a.push(t),a.push(a[a.length-1]),a.push(new g(t.x,t.y,r.z)),a.push(a[a.length-1]),a.push(new g(r.x,t.y,r.z)),a.push(a[a.length-1]),a.push(new g(r.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new g(t.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new g(t.x,t.y,r.z)),a.push(new g(t.x,r.y,t.z)),a.push(new g(t.x,r.y,r.z)),a.push(new g(r.x,r.y,t.z)),a.push(new g(r.x,r.y,r.z)),a.push(new g(r.x,t.y,t.z)),a.push(new g(r.x,t.y,r.z)),this.mLineRender.fillShapeData(e,"line",s,a)}drawFillRect(e,t,r,s,a=z.COLOR_WHITE){this.mFillRender.fillShapeData(e,"fill",a,[t,new g(t.x+r,t.y,t.z),new g(t.x+r,t.y+s,t.z),new g(t.x+r,t.y+s,t.z),new g(t.x,t.y+s,t.z),t])}drawFillCircle(e,t,r,s=32,a=g.Y_AXIS,n=z.COLOR_WHITE){var l=[];l.push(t);for(let f=0;f<=s;++f){f>=2&&(l.push(t),l.push(l[l.length-2]));var h=2*Math.PI*f/s,u=r*Math.cos(h),c=r*Math.sin(h);switch(a){case g.X_AXIS:l.push(t.add(new g(0,u,c)));break;case g.Y_AXIS:l.push(t.add(new g(u,0,c)));break;case g.Z_AXIS:l.push(t.add(new g(u,c,0)));break;default:l.push(t.add(new g(u,c,0)));break}}this.mFillRender.fillShapeData(e,"fill",n,l)}drawMeshWireframe(e,t,r,s=z.COLOR_WHITE){t&&this.createCustomShape(e,r||this.transform).fillShapeData(t.genWireframe(),s)}drawFillSector(e,t,r,s,a,n=16,l=g.Y_AXIS,h=z.COLOR_WHITE){const u=(a-s)*_e;s*=_e;var c=[];c.push(t);for(let m=0;m<=n;++m){m>=2&&(c.push(t),c.push(c[c.length-2]));var f=u*(m/n)+s,d=r*Math.cos(f),p=r*Math.sin(f);switch(l){case g.X_AXIS:c.push(t.add(new g(0,d,p)));break;case g.Y_AXIS:c.push(t.add(new g(d,0,p)));break;case g.Z_AXIS:c.push(t.add(new g(d,p,0)));break;default:c.push(t.add(new g(d,p,0)));break}}this.mFillRender.fillShapeData(e,"fill",h,c)}drawBoundingBox(e,t,r=z.COLOR_WHITE){this.drawBox(e,t.min,t.max,r)}drawCameraFrustum(e,t=z.COLOR_WHITE){if(e.type==Ie.perspective){let r=Math.tan(e.fov/2*_e),s=r*e.aspect,a=e.transform._worldMatrix,n=a.transformVector(new g(-s,-r,1)),l=a.transformVector(new g(-s,r,1)),h=a.transformVector(new g(s,-r,1)),u=a.transformVector(new g(s,r,1)),c=e.far,f=e.near,d=e.transform.worldPosition,p=new g().copyFrom(n).multiplyScalar(c).add(d),m=new g().copyFrom(l).multiplyScalar(c).add(d),_=new g().copyFrom(h).multiplyScalar(c).add(d),v=new g().copyFrom(u).multiplyScalar(c).add(d),y=new g().copyFrom(n).multiplyScalar(f).add(d),C=new g().copyFrom(l).multiplyScalar(f).add(d),B=new g().copyFrom(h).multiplyScalar(f).add(d),T=new g().copyFrom(u).multiplyScalar(f).add(d),M=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);M.buildLines([C,m],t),M.buildLines([y,p],t),M.buildLines([T,v],t),M.buildLines([B,_],t),M.buildLines([m,v,_,p,m],t),M.buildLines([C,T,B,y,C],t)}else if(e.type==Ie.ortho){e.viewPort,e.viewPort.height;let r=e.transform.worldMatrix,s=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*.5,e.far)),a=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*-.5,e.far)),n=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*.5,e.far)),l=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*-.5,e.far)),h=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*.5,e.near)),u=r.transformVector(new g(e.viewPort.width*-.5,e.viewPort.height*-.5,e.near)),c=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*.5,e.near)),f=r.transformVector(new g(e.viewPort.width*.5,e.viewPort.height*-.5,e.near)),d=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);d.buildLines([h,s],t),d.buildLines([u,a],t),d.buildLines([c,n],t),d.buildLines([f,l],t),d.buildLines([s,n,l,a,s],t),d.buildLines([h,c,f,u,h],t)}}drawObjectBoundingBox(e,t=z.COLOR_WHITE){let r=Zt.genMeshBounds(e);this.drawBox(`Bounds_${e.instanceID}`,r.min,r.max,t)}Clear(e){this.mLineRender.shapes.has(e)?this.mLineRender.removeShape(e):this.mFillRender.shapes.has(e)&&this.mFillRender.removeShape(e)}ClearAll(){this.mLineRender.shapes.clear(),this.mFillRender.shapes.clear()}ChangeColor(e,t){var r;if(this.mLineRender.shapes.has(e))r=this.mLineRender.shapes.get(e);else if(this.mFillRender.shapes.has(e))r=this.mFillRender.shapes.get(e);else return;const s=r.shapeData;for(let a=0;a<s.length;a+=ei.ShapeVertexSize)s[a+4]=t.r,s[a+5]=t.g,s[a+6]=t.b,s[a+7]=t.a}}class of{constructor(){o(this,"_computeShader"),o(this,"_outBuffer")}init(){let e=wt.getGBufferFrame("ColorPassGBuffer");this._computeShader=new be(rc),this._outBuffer=new ir(32),this._computeShader.setStorageBuffer("outBuffer",this._outBuffer),this._computeShader.setSamplerTexture("visibleMap",e.getPositionMap())}compute(e){let t=pe.getCameraGroup(e.camera);this._computeShader.setStorageBuffer("globalUniform",t.uniformGPUBuffer);let r=w.beginCommandEncoder();w.computeCommand(r,[this._computeShader]),w.endCommandEncoder(r),this._outBuffer.readBuffer()}getPickMeshID(){var e=this._outBuffer.outFloat32Array[0]+.1;return Math.floor(e)}getPickWorldPosition(e){e||(e=new g);var t=this._outBuffer.outFloat32Array[4],r=this._outBuffer.outFloat32Array[5],s=this._outBuffer.outFloat32Array[6];return e.set(t,r,s),e}getPickScreenUV(e){e||(e=new Z);var t=this._outBuffer.outFloat32Array[2],r=this._outBuffer.outFloat32Array[3];return e.set(t,r),e}}class nf extends hi{constructor(e){super(),o(this,"ray"),o(this,"isTouching",!1),o(this,"_mouseCode"),o(this,"_pickEvent"),o(this,"_outEvent"),o(this,"_overEvent"),o(this,"_upEvent"),o(this,"_downEvent"),o(this,"_mouseMove"),o(this,"_pickCompute"),o(this,"_lastDownTarget"),o(this,"mouseEnableMap"),o(this,"_view"),o(this,"_lastFocus"),o(this,"_interestList",[]),this._view=e,this.init()}init(){this.ray=new ci,this.mouseEnableMap=new Map,this._pickEvent=new R(R.PICK_CLICK),this._outEvent=new R(R.PICK_OUT),this._overEvent=new R(R.PICK_OVER),this._mouseMove=new R(R.PICK_MOVE),this._upEvent=new R(R.PICK_UP),this._downEvent=new R(R.PICK_DOWN)}start(){A.setting.pick.enable&&(A.inputSystem.addEventListener(R.POINTER_DOWN,this.onTouchStart,this),A.inputSystem.addEventListener(R.POINTER_UP,this.onTouchEnd,this),A.inputSystem.addEventListener(R.POINTER_CLICK,this.onTouchOnce,this),A.inputSystem.addEventListener(R.POINTER_MOVE,this.onTouchMove,this)),A.setting.pick.mode=="pixel"&&(this._pickCompute=new of,this._pickCompute.init())}stop(){A.inputSystem.removeEventListener(R.POINTER_DOWN,this.onTouchStart,this),A.inputSystem.removeEventListener(R.POINTER_UP,this.onTouchEnd,this),A.inputSystem.removeEventListener(R.POINTER_CLICK,this.onTouchOnce,this),A.inputSystem.removeEventListener(R.POINTER_MOVE,this.onTouchMove,this)}onTouchStart(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);this._lastDownTarget=t,t&&(this._downEvent.target=t.object3D,this._downEvent.ctrlKey=e.ctrlKey,this._downEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._downEvent),t.object3D.containEventListener(R.PICK_DOWN)&&t.object3D.dispatchEvent(this._downEvent))}onTouchEnd(e){this.isTouching=!1,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._upEvent.target=t.object3D,this._upEvent.ctrlKey=e.ctrlKey,this._upEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._upEvent),t.object3D.containEventListener(R.PICK_UP)&&t.object3D.dispatchEvent(this._upEvent))}getPickInfo(){return{worldPos:this._pickCompute.getPickWorldPosition(),screenUv:this._pickCompute.getPickScreenUV(),meshID:this._pickCompute.getPickMeshID()}}onTouchMove(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._mouseMove.target=t.object3D,this._mouseMove.ctrlKey=e.ctrlKey,this._mouseMove.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._mouseMove),t.object3D.containEventListener(R.PICK_MOVE)&&t.object3D.dispatchEvent(this._mouseMove)),t!=this._lastFocus&&(this._lastFocus&&this._lastFocus.object3D&&(this._outEvent.target=this._lastFocus.object3D,this._outEvent.data={pick:this._lastFocus,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this._outEvent.ctrlKey=e.ctrlKey,this.dispatchEvent(this._outEvent),this._lastFocus.object3D.containEventListener(R.PICK_OUT)&&this._lastFocus.object3D.dispatchEvent(this._outEvent)),t&&(this._overEvent.target=t.object3D,this._overEvent.ctrlKey=e.ctrlKey,this._overEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._overEvent),t.object3D.containEventListener(R.PICK_OVER)&&t.object3D.dispatchEvent(this._overEvent))),this._lastFocus=t}onTouchOnce(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);if(t){let r=A.setting.pick.mode=="pixel"?this.getPickInfo():null;this._pickEvent.target=t.object3D,this._pickEvent.ctrlKey=e.ctrlKey,this._pickEvent.data={pick:t,pickInfo:r,mouseCode:this._mouseCode},this.dispatchEvent(this._pickEvent),t===this._lastDownTarget&&t.object3D.containEventListener(R.PICK_CLICK)&&t.object3D.dispatchEvent(this._pickEvent)}this._lastDownTarget=null}findNearestObj(e,t){var r;return e.sort((s,a)=>s.distance>a.distance?1:-1),(r=e[0])==null?void 0:r.collider}pick(e){if(this._interestList.length=0,A.setting.pick.mode=="pixel"){this._pickCompute.compute(this._view);let t=this._pickCompute.getPickMeshID(),r=this.mouseEnableMap.get(t);if(r){let s=this._pickCompute.getPickWorldPosition(),a=g.distance(s,this.ray.origin);this._interestList.push({distance:a,collider:r,intersectPoint:s})}}else if(A.setting.pick.mode=="bound"){this.ray=e.screenPointToRay(A.inputSystem.mouseX,A.inputSystem.mouseY);let t,r=ae.componentsEnablePickerList.get(this._view);if(r)for(const s of r){let a=s[0];a.enable&&(t=a.rayPick(this.ray),t&&(t.collider=a,this._interestList.push(t)))}}}}class Mp extends Lr{constructor(e=0,t=0,r=0,s=0){super(),o(this,"_camera"),o(this,"_scene"),o(this,"_viewPort"),o(this,"_enablePick",!1),o(this,"_enable",!0),o(this,"pickFire"),o(this,"guiPick"),o(this,"canvasList"),o(this,"graphic3D"),this.canvasList=[],this._viewPort=new j(e,t,r,s),this.enablePick=!0,this.graphic3D=new af}get enable(){return this._enable}set enable(e){this._enable=e}get enablePick(){return this._enablePick}set enablePick(e){this._enablePick!=e&&(this.pickFire=new nf(this),this.pickFire.start()),this._enablePick=e}get scene(){return this._scene}set scene(e){this._scene=e,e.view=this,Ve.createBuffer(e),this.graphic3D&&e.addChild(this.graphic3D),e&&this.canvasList.forEach(t=>{t&&e.addChild(t.object3D)})}get camera(){return this._camera}set camera(e){this._camera=e}get viewPort(){return this._viewPort}set viewPort(e){this._viewPort=e}enableUICanvas(e=0){let t=this.canvasList[e];if(!t){let r=new te;r.name="Canvas "+e,t=r.addComponent(Cs),t.index=e,this.canvasList[e]=t}return this.scene.addChild(t.object3D),this.guiPick||(this.guiPick=new Hc,this.guiPick.init(this)),t}disableUICanvas(e=0){let t=this.canvasList[e];t&&t.object3D&&t.object3D.removeFromParent()}}class Dp{constructor(e){o(this,"normal"),o(this,"fixNormal"),o(this,"center"),o(this,"rotateShape"),o(this,"distance",0),o(this,"index"),this.index=e,this.rotateShape=[]}}class Pp extends tt{constructor(){super(...arguments),o(this,"vScale"),o(this,"uNegate"),o(this,"sections")}build(e,t,r,s=1,a=!0){if(r.length<2)throw new Error("path length is not enough");return this.vScale=s,this.uNegate=a,e=e.slice(),t&&e.push(e[0]),this.sections=this.buildSections(e,r),this.buildGeometry(e,this.sections),this.bounds=new Be(g.ZERO.clone(),new g(100,100,100)),this}buildSections(e,t){let r,s,a,n=[],l=t.length;for(let u=0;u<l;u++){let c=new Dp(u);r=t[u],s=t[u+1],c.center=r.clone(),s==null?(c.normal=a.clone(),c.distance=0):(a=s.subtract(r),c.distance=a.length,c.normal=a.normalize()),n.push(c)}n[0].fixNormal=n[0].normal.clone();for(let u=1;u<l;u++){let c=n[u-1],f=n[u];f.fixNormal=f.normal.add(c.normal).normalize()}let h=new V().identity();for(let u=0;u<l;u++){let c=n[u],f,d;if(u==0)f=g.UP,d=e;else{let p=n[u-1];f=p.fixNormal,d=p.rotateShape}V.fromToRotation(f,c.fixNormal,h);for(let p=0,m=e.length;p<m;p++){let _=h.multiplyPoint3(d[p]);c.rotateShape.push(_)}}return n}buildGeometry(e,t){let r=t.length,s=e.length,a=r*s,n=r-1,l=new Float32Array(a*3),h=new Float32Array(a*3),u=new Float32Array(a*2),c=new Uint32Array(n*(s-1)*6),f=s-1,d=0,p=0,m=[0];for(let v=1;v<s;v++)p+=e[v-1].subtract(e[v]).length,m.push(p);for(let v=0;v<r;v++){let y=t[v];for(let C=0;C<s;C++){let B=(v*s+C)*3,T=y.rotateShape[C].add(y.center);l[B]=T.x,l[B+1]=T.y,l[B+2]=T.z,h[B+1]=1;let M=(v*s+C)*2,D=m[C]/p;u[M]=this.uNegate?1-D:D,u[M+1]=d*this.vScale}d+=y.distance}let _=0;for(let v=0;v<n;v++){let y=v*s;for(let C=0;C<f;C++){let B=C,T=C+1,M=B+s,D=T+s;c[_++]=B+y,c[_++]=T+y,c[_++]=M+y,c[_++]=T+y,c[_++]=D+y,c[_++]=M+y}}return this.setIndices(c),this.setAttribute(Y.position,l),this.setAttribute(Y.normal,h),this.setAttribute(Y.uv,u),this.setAttribute(Y.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:c.length,vertexStart:0,index:0}),this.computeNormals(),this}}class Rp{constructor(){o(this,"name"),o(this,"offset"),o(this,"size"),o(this,"arrayStride"),o(this,"stepMode"),o(this,"attributes")}}class Lp{constructor(){o(this,"name"),o(this,"format"),o(this,"offset"),o(this,"shaderLocation"),o(this,"stride")}}var lf=(i=>(i[i.position=3]="position",i[i.normal=3]="normal",i[i.TANGENT=4]="TANGENT",i[i.uv=2]="uv",i[i.TEXCOORD_1=2]="TEXCOORD_1",i[i.color=4]="color",i[i.joints0=4]="joints0",i[i.weights0=4]="weights0",i[i.joints1=4]="joints1",i[i.weights1=4]="weights1",i[i.vIndex=1]="vIndex",i[i.weight=1]="weight",i[i.a_morphPositions_0=3]="a_morphPositions_0",i))(lf||{});class Up{constructor(){}}class Op{constructor(){o(this,"entity")}get data(){return null}}class hf{constructor(){o(this,"min",0),o(this,"max",0)}set(e,t){return this.max=t,this.min=e,this}copy(e){return this.max=e.max,this.min=e.min,this}isInterestRange(e){return!(this.max>e.min||e.max<this.min)}}class uf{constructor(){o(this,"_spaceDesc")}getRange(e){return this._spaceDesc[e]}initSpace(e){this._spaceDesc={};for(let t of e)(this._spaceDesc[t]=new hf).set(-Number.MAX_VALUE,Number.MAX_VALUE);return this}isContain(e,t){let r=this._spaceDesc[e];return t>=r.min&&t<r.max}isInterestRange(e,t){let r=this._spaceDesc[e];return r?t.isInterestRange(r):!1}splitSpace(e,t,r){let s=this._spaceDesc[e];return t?s.max=r:s.min=r,this}copySpace(e){for(let t in e._spaceDesc){let r=e._spaceDesc[t];this._spaceDesc[t].copy(r)}return this}}const cf=class{};let yr=cf;o(yr,"MaxEntityCountInLeaf",4),o(yr,"MaxLayer",10),o(yr,"ClearLeafLayer",cf.MaxLayer-4);const ff=class{constructor(){o(this,"uuid","0"),this.uuid=(ff.UUID++).toString()}};let ha=ff;o(ha,"UUID",0);class Np{constructor(){o(this,"map",{}),o(this,"_count",0)}get count(){return this._count}push(e){return this.map[e.uuid]?!1:(this.map[e.uuid]=e,this._count++,!0)}remove(e){return this.map[e]?(delete this.map[e],this._count--,!0):!1}}const ki=class extends ha{constructor(i=0){super(),o(this,"_dimensionIndex",0),o(this,"_dimensions"),o(this,"_dimension"),o(this,"_left"),o(this,"_right"),o(this,"_space"),o(this,"_parent"),o(this,"_entities"),o(this,"layer"),o(this,"_splitEntityList",[]),o(this,"pointIntersect",new g),this.layer=i,ki.nodeCount++}get dimension(){return this._dimension}initNode(i,e,t){return this._dimensions=e,this._dimensionIndex=t,this._dimension=e[t],this._space=new uf().initSpace(e),i&&this._space.copySpace(i._space),this._parent=i,this._entities=new Np,this}updateEntity(i){if(i.isInNode(this,this._dimension)&&(i.attachTreeNode(this),this.autoSplit(),this._left&&this._right)){let e=(this._dimensionIndex+1)%this._dimensions.length,t=this._dimensions[e];i.isInNode(this._right,t)?this._right.updateEntity(i):i.isInNode(this._left,t)&&this._left.updateEntity(i)}}buildRoot(i){for(const e of i)e.entity.attachTreeNode(this);this.autoSplit()}autoSplit(){if(this._entities.count>yr.MaxEntityCountInLeaf&&!this._right&&!this._left&&this.layer<yr.MaxLayer){let i=this._splitEntityList,e=(this._dimensionIndex+1)%this._dimensions.length,t=this._dimensions[e],r=0;for(const s in this._entities.map){let a=this._entities.map[s];r+=a.centerValue(t),i.push(a)}r/=this._entities.count,this._left=new ki(this.layer+1),this._right=new ki(this.layer+1),this._left.initNode(this,this._dimensions,e),this._right.initNode(this,this._dimensions,e),this._left.setSpace(!0,r),this._right.setSpace(!1,r);for(let s of i)s.isInNode(this._right,t)?s.attachTreeNode(this._right):s.isInNode(this._left,t)&&s.attachTreeNode(this._left)}this._left&&this._left.autoSplit(),this._right&&this._right.autoSplit()}setSpace(i,e){return this._parent&&this._space.splitSpace(this._dimension,i,e),this}isEmpty(){return this._left==null&&this._right==null&&this._entities.count==0}pushEntity(i){return this._entities.push(i)}removeEntity(i){return this._entities.remove(i.uuid)}autoClear(){let i=this;for(;i&&i.layer>yr.ClearLeafLayer&&i.clearLeaf();)i=i._parent}clearLeaf(){let i=!this._left&&!this._right,e=!i&&this._left.isEmpty()&&this._right.isEmpty();return e&&(this._left=this._right=null,ki.nodeCount-=2),i||e}isContain(i){return this._space.isContain(this._dimension,i)}nodeIntersectsBox(i){let e=this._space.getRange("x"),t=this._space.getRange("y"),r=this._space.getRange("z"),s=ki.rangeBox;return s.min.set(e.min,t.min,r.min),s.max.set(e.max,t.max,r.max),s.intersectsBox(i)}nodeIntersectsRay(i){let e=this._space.getRange("x"),t=this._space.getRange("y"),r=this._space.getRange("z"),s=ki.rangeBox;return s.min.set(e.min,t.min,r.min),s.max.set(e.max,t.max,r.max),!0}pointCast(i,e=0,t){if(t=t||[],this._entities.count>0){let r=this._entities.map;for(let s in r){let a=r[s],n=a.entityContainPoint(i);!n&&e>0&&(n=a.squareDistanceTo(i,this._dimensions)<=e),n&&t.push(a)}}this._left&&this._left.isContain(i[this._left.dimension])&&this._left.pointCast(i,e,t),this._right&&this._right.isContain(i[this._right.dimension])&&this._right.pointCast(i,e,t)}boxCast(i,e){if(e=e||[],this._entities.count>0){let t=this._entities.map;for(let r in t){let s=t[r];s.entityIntersectsBox(i)&&e.push(s)}}this._left&&this._left.nodeIntersectsBox(i)&&this._left.boxCast(i,e),this._right&&this._right.nodeIntersectsBox(i)&&this._right.boxCast(i,e)}rayCast(i,e,t){e=e||[],t=t||[];let r=this.pointIntersect;if(this._entities.count>0){let s=this._entities.map;for(let a in s){let n=s[a];n.entityIntersectsRay(i,r)&&(t.push(new g().copyFrom(r)),e.push(n))}}this._left&&this._left.nodeIntersectsRay(i)&&this._left.rayCast(i,e,t),this._right&&this._right.nodeIntersectsRay(i)&&this._right.rayCast(i,e,t)}};let fn=ki;o(fn,"nodeCount",0),o(fn,"rangeBox",new Be(new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)));class Fp extends ha{constructor(e){super(),o(this,"userData"),o(this,"node"),this.userData=e}centerValue(e){return 0}isInNode(e,t){return!1}entityContainPoint(e){return!1}squareDistanceTo(e,t){return Number.MAX_VALUE}entityIntersectsBox(e){return!1}entityIntersectsRay(e,t){return!1}attachTreeNode(e){return this.node&&this.detachTreeNode(),this.node=e,this.node.pushEntity(this)}detachTreeNode(){let e=this.node.removeEntity(this);return this.node=null,e}updateNode(e){let t=this.node;t&&this.detachTreeNode(),e.updateEntity(this),t&&t.autoClear()}}class df extends je{}o(df,"RESIZE","resize");var gf=(i=>(i[i.MOUSE_LEFT=0]="MOUSE_LEFT",i[i.MOUSE_MID=1]="MOUSE_MID",i[i.MOUSE_RIGHT=2]="MOUSE_RIGHT",i))(gf||{});class dn extends je{}o(dn,"LOADER_PROGRESS","loaderProgress"),o(dn,"LOADER_COMPLETE","loaderComplete");class fs extends je{}o(fs,"ADDED","added"),o(fs,"REMOVED","removed"),o(fs,"CHILD_ADD_EVENT","childAddEvent"),o(fs,"CHILD_REMOVED","childRemoved");class ua extends je{}o(ua,"SHOW","show"),o(ua,"HIDE","hide"),o(ua,"UPDATE","update");class kp{static merge(e,t,r,s){let a=0,n=0;a=Math.max(e.width,a),a=Math.max(t.width,a),a=Math.max(r.width,a),a=Math.max(s.width,a),n=Math.max(e.height,n),n=Math.max(t.height,n),n=Math.max(r.height,n),n=Math.max(s.height,n);let l=new oe(a,n,G.rgba8unorm),h=new be($u);h.setSamplerTexture("textureR",e),h.setSamplerTexture("textureG",t),h.setSamplerTexture("textureB",r),h.setSamplerTexture("textureA",s),h.setStorageTexture("outTex",l),h.workerSizeX=Math.ceil(a/8),h.workerSizeY=Math.ceil(n/8);let u=w.beginCommandEncoder();return w.computeCommand(u,[h]),w.endCommandEncoder(u),l}}class zp extends Jt{constructor(e,t,r=0){super(),this.bufferType=Mt.StructStorageGPUBuffer,this.createBufferByStruct(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,e,t)}}class ds{static createMipmap(e,t){const r=S.device;this._pipelineMax||(this._pipelineMax=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMax}),entryPoint:"main"}})),this._pipelineMin||(this._pipelineMin=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMin}),entryPoint:"main"}}));let s=Math.ceil(e.width*.5),a=Math.ceil(e.height*.5),n={mipmapCount:t,texture:e,srcView:null,mipLevel:1,dstHeight:a,dstWidth:s};n.srcView=e.getGPUTexture().createView({format:e.format,dimension:"2d",baseMipLevel:0,mipLevelCount:1}),e.width>1024&&e.height>1024?this.mipmap(this._pipelineMax,n):this.mipmap(this._pipelineMin,n)}static mipmap(e,t){const r=S.device,s=w.beginCommandEncoder();let a=e==this._pipelineMax,n,l;for(let h=t.mipLevel;h<t.mipmapCount;h++){let u=[],c=0;u.push({binding:c++,resource:t.srcView}),u.push({binding:c++,resource:t.texture.gpuSampler}),n=t.texture.getGPUTexture().createView({format:t.texture.format,dimension:"2d",baseMipLevel:h,mipLevelCount:1}),u.push({binding:c++,resource:n});const f=r.createBindGroup({layout:e.getBindGroupLayout(0),entries:u}),d=s.beginComputePass();d.setPipeline(e),d.setBindGroup(0,f);let p=t.dstWidth,m=t.dstHeight;if(a&&(p=Math.max(1,Math.floor(t.dstWidth/8)),m=Math.max(1,Math.floor(t.dstHeight/8))),d.dispatchWorkgroups(p,m),t.dstHeight*=.5,t.dstWidth*=.5,t.srcView=n,t.mipLevel=h+1,l=a&&(t.dstWidth<8||t.dstHeight<8),d.end(),l)break}w.endCommandEncoder(s),l&&this.mipmap(this._pipelineMin,t)}}o(ds,"codeMax",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            //fromColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            //if(dstSize.x == 512){
            //    fromColor.x = 1.0;
            //}else  if(dstSize.x == 256){
            //    fromColor.y = 1.0;
            //}else if(dstSize.x == 128){
            //    fromColor.z = 1.0;
            //}
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),o(ds,"codeMin",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(1, 1)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),o(ds,"_pipelineMax"),o(ds,"_pipelineMin");class pf{constructor(){o(this,"name",""),o(this,"passMap",new Map)}}class mf{constructor(){o(this,"passType",""),o(this,"shaderState",new Map),o(this,"vertexShader",""),o(this,"fragmentShader","")}}class Cr{static parser(e,t){e=ut.filterComment(e);let r=new pf,s=e.indexOf(this.shaderKeyword),a=e.indexOf("{",s),n=e.substring(s+this.shaderKeyword.length,a).trim();r.name=n.substring(1,n.length-1),n=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));let l=this.splitPassBlock(n);for(let h of l){let u=this.parserPassBlock(h),c;r.passMap.has(u.passType)?c=r.passMap.get(u.passType):(c=[],r.passMap.set(u.passType,c)),c.push(u),u.vertexShader.length>0&&(u.vertexShader=ut.parse(u.vertexShader,t)),u.fragmentShader.length>0&&(u.fragmentShader=ut.parse(u.fragmentShader,t))}return r}static splitPassBlock(e){let t=0,r=[];for(;t<e.length;){let s=e.indexOf(this.passKeyword,t);if(s==-1){r.push(e.substring(t));break}t!=0&&r.push(e.substring(t,s)),t=s+this.passKeyword.length}return r}static parserPassBlock(e){let t=new mf,r=e.indexOf(this.passTypeKeyword),s=e.indexOf('"',r);return r=e.indexOf('"',s+1),t.passType=e.substring(r+1,s).trim(),this.parserShaderState(t,e),r=e.indexOf(this.vertexKeyword),r!=-1&&(t.vertexShader=this.extractBlock(e.substring(r+this.vertexKeyword.length),"{","}")),r=e.indexOf(this.fragmentKeyword),r!=-1&&(t.fragmentShader=this.extractBlock(e.substring(r+this.fragmentKeyword.length),"{","}")),t}static parserShaderState(e,t){let r=t.indexOf("ShaderState");if(r==-1)return!1;r=t.indexOf("{",r);let s=t.indexOf("}",r),n=t.substring(r+1,s).split(",");for(let l of n){let h=l.split(":"),u=h[0].trim(),c=this.convertValue(h[1].trim());e.shaderState.set(u,c)}return!0}static convertValue(e){return e.length==4&&e.toLowerCase()=="true"?!0:e.length==5&&e.toLowerCase()=="false"?!1:e[0]=='"'?e.substring(1,e.length-1):Number.parseInt(e)}static extractBlock(e,t,r){let s=e.indexOf(t);if(s==-1)return"";let a=0,n=0;e=e.substring(s);for(let h of e){if(h==t?a++:h==r&&a--,a<=0)break;n++}return e.substring(1,n).trim()}}o(Cr,"passKeyword","pass"),o(Cr,"shaderKeyword","Shader"),o(Cr,"vertexKeyword","vertex"),o(Cr,"fragmentKeyword","fragment"),o(Cr,"passTypeKeyword","PassType");let Af=new je("IrradianceDataReaderCompleteEvent");class Es extends hi{constructor(){super(...arguments),o(this,"readFlag",!1),o(this,"probeRenderer"),o(this,"opColorBuffer"),o(this,"opDepthBuffer"),o(this,"srcColorMap"),o(this,"srcDepthMap"),o(this,"opDepthArray"),o(this,"opColorArray")}initReader(e,t,r){this.probeRenderer=e,this.srcColorMap=t,this.srcDepthMap=r;let s=A.setting.gi,a=s.octRTMaxSize*s.octRTMaxSize;this.opColorBuffer=S.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opColorArray=new Float32Array(a*4),this.opDepthBuffer=S.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opDepthArray=new Float32Array(a*4),this.probeRenderer.addEventListener(Co.type,()=>{this.onProbeRenderComplete()},this),this.probeRenderer.addEventListener(Hs.type,()=>{console.log("GIRenderStartEvent")},this)}async onProbeRenderComplete(){if(console.log("GIRenderCompleteEvent"),this.readFlag)console.log("irradianceDataReader is reading yet!!!");else{this.readFlag=!0;let e=Date.now();console.log("irradianceDataReader start reading "),await Es.read(this.srcColorMap.getGPUTexture(),this.opColorBuffer,this.opColorArray),await Es.read(this.srcDepthMap.getGPUTexture(),this.opDepthBuffer,this.opDepthArray),this.readFlag=!1,console.log("process time :",Date.now()-e),console.log("irradianceDataReader read complete"),this.dispatchEvent(Af)}}static async read(e,t,r){let s=w.beginCommandEncoder();s.copyTextureToBuffer({texture:e},{buffer:t,bytesPerRow:e.width*16},[e.width,e.height]),w.endCommandEncoder(s),await t.mapAsync(GPUMapMode.READ);const a=t.getMappedRange();r.set(new Float32Array(a),0),t.unmap()}}let Gp=new Es;class Qp{constructor(){o(this,"computeShader"),o(this,"visibleBuffer"),o(this,"texture"),this.computeShader=new be(pc),this.visibleBuffer=new ir(8192*2),this.computeShader.setStorageBuffer("visibleBuffer",this.visibleBuffer),this.texture=Fe.getTexture(Ae.zBufferTexture_NAME),this.computeShader.setSamplerTexture("zBufferTexture",this.texture),this.computeShader.workerSizeX=Math.ceil(this.texture.width/8),this.computeShader.workerSizeY=Math.ceil(this.texture.height/8),this.computeShader.workerSizeZ=1}compute(e,t){this.visibleBuffer.reset(!0,0),this.visibleBuffer.apply();let r=w.beginCommandEncoder();w.computeCommand(r,[this.computeShader]),this.visibleBuffer.readBuffer(),t.zVisibleList=this.visibleBuffer.outFloat32Array}}class Vp extends Ct{constructor(){super(),o(this,"blurTexture1"),o(this,"blurTexture2"),o(this,"rendererPassState"),o(this,"blurComputes"),o(this,"blurSettings"),o(this,"outTexture"),o(this,"rtFrame")}onAttach(e){A.setting.render.postProcessing.depthOfView.enable=!0}onDetach(e){A.setting.render.postProcessing.depthOfView.enable=!1}createGUI(){}get pixelOffset(){return A.setting.render.postProcessing.depthOfView.pixelOffset}set pixelOffset(e){e=Math.max(0,e);let t=A.setting.render.postProcessing.depthOfView;t.pixelOffset=e}get near(){return A.setting.render.postProcessing.depthOfView.near}set near(e){e=Math.max(0,e);let t=A.setting.render.postProcessing.depthOfView;t.near=e}get far(){return A.setting.render.postProcessing.depthOfView.far}set far(e){e=Math.max(0,e);let t=A.setting.render.postProcessing.depthOfView;t.far=e}createBlurCompute(){this.blurSettings=[],this.blurComputes=[];let e=A.setting.render.postProcessing.depthOfView;for(let t=0;t<e.iterationCount;t++){let r=new Dt(4),s=new be(Ku);this.blurComputes.push(s),this.blurSettings.push(r),s.setUniformBuffer("blurSetting",r);let a=wt.getGBufferFrame("ColorPassGBuffer");s.setSamplerTexture(Ae.positionBufferTex_NAME,a.attachments[1]),s.setSamplerTexture(Ae.normalBufferTex_NAME,a.attachments[2]);let n=t%2==0?this.blurTexture1:this.blurTexture2,l=t%2==1?this.blurTexture1:this.blurTexture2;s.setSamplerTexture("inTex",n),s.setStorageTexture("outTex",l),s.workerSizeX=Math.ceil(this.blurTexture1.width/8),s.workerSizeY=Math.ceil(this.blurTexture1.height/8),s.workerSizeZ=1,this.outTexture=l}}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.blurTexture1=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture1.name="dof1";let s=new Ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.blurTexture2=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture2.name="dof2";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.rtFrame=new Ze([this.blurTexture1,this.blurTexture2],[s,a])}render(e,t){if(!this.blurComputes){this.createResource(),this.createBlurCompute(),this.createGUI();let s=pe.getCameraGroup(e.camera);for(let a=0;a<this.blurComputes.length;a++)this.blurComputes[a].setUniformBuffer("standUniform",s.uniformGPUBuffer);this.rendererPassState=He.createRendererPassState(this.rtFrame,null)}this.autoSetColorTexture("inTex",this.blurComputes[0]);let r=A.setting.render.postProcessing.depthOfView;r.far=Math.max(r.near,r.far)+1e-4;for(let s=0;s<r.iterationCount;s++){let a=this.blurComputes[s],n=this.blurSettings[s];n.setFloat("near",r.near),n.setFloat("far",r.far),n.setFloat("pixelOffset",(s+1)*r.pixelOffset),n.apply(),a.setStorageBuffer("blurSetting",n)}w.computeCommand(t,this.blurComputes),w.lastRenderPassState=this.rendererPassState}}class Hp extends Ct{constructor(){super(),o(this,"gtaoTexture"),o(this,"rendererPassState"),o(this,"gtaoCompute"),o(this,"gtaoSetting"),o(this,"aoBuffer"),o(this,"directionsBuffer"),o(this,"directionsArray"),o(this,"rtFrame"),o(this,"Render"),o(this,"randomCount",0)}onAttach(e){A.setting.render.postProcessing.gtao.enable=!0,this.createGUI()}onDetach(e){A.setting.render.postProcessing.gtao.enable=!1,this.removeGUI()}get maxDistance(){return A.setting.render.postProcessing.gtao.maxDistance}set maxDistance(e){e=K(e,.1,50);let t=A.setting.render.postProcessing.gtao;t.maxDistance=e}get maxPixel(){return A.setting.render.postProcessing.gtao.maxPixel}set maxPixel(e){e=K(e,5,100);let t=A.setting.render.postProcessing.gtao;t.maxPixel=e}get darkFactor(){return A.setting.render.postProcessing.gtao.darkFactor}set darkFactor(e){e=K(e,.01,1);let t=A.setting.render.postProcessing.gtao;t.darkFactor=e}get rayMarchSegment(){return A.setting.render.postProcessing.gtao.rayMarchSegment}set rayMarchSegment(e){e=K(e,4,10);let t=A.setting.render.postProcessing.gtao;t.rayMarchSegment=e}get multiBounce(){return A.setting.render.postProcessing.gtao.multiBounce}set multiBounce(e){let t=A.setting.render.postProcessing.gtao;t.multiBounce=e}get blendColor(){return A.setting.render.postProcessing.gtao.blendColor}set blendColor(e){let t=A.setting.render.postProcessing.gtao;t.blendColor=e}get usePosFloat32(){return A.setting.render.postProcessing.gtao.usePosFloat32}set usePosFloat32(e){let t=A.setting.render.postProcessing.gtao;t.usePosFloat32=e}createGUI(){}removeGUI(){}createCompute(){A.setting.render.postProcessing.gtao,this.gtaoCompute=new be(Ju);let e=new Dt(4*2);this.gtaoCompute.setUniformBuffer("gtaoData",e),this.directionsArray=new Float32Array(8*2),this.directionsBuffer=new ge(8*2),this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply(),this.gtaoCompute.setStorageBuffer("directions",this.directionsBuffer),this.aoBuffer=new ge(this.gtaoTexture.width*this.gtaoTexture.height),this.gtaoCompute.setStorageBuffer("aoBuffer",this.aoBuffer);let t=wt.getGBufferFrame("ColorPassGBuffer"),r=t.attachments[1];this.gtaoCompute.setSamplerTexture("posTex",r),this.gtaoCompute.setSamplerTexture("normalTex",t.attachments[2]),this.autoSetColorTexture("inTex",this.gtaoCompute),this.gtaoCompute.setStorageTexture("outTex",this.gtaoTexture),this.gtaoCompute.workerSizeX=Math.ceil(this.gtaoTexture.width/8),this.gtaoCompute.workerSizeY=Math.ceil(this.gtaoTexture.height/8),this.gtaoCompute.workerSizeZ=1,this.gtaoSetting=e}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.gtaoTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.gtaoTexture.name="gtaoTex";let s=new Ce;s.loadOp="load",this.rtFrame=new Ze([this.gtaoTexture],[s])}randomDirection(){this.randomCount++,this.randomCount>1&&(this.randomCount=0);let e=Math.PI*2*this.randomCount/16,t=Math.PI*2/8;for(let r=0;r<8;r++){let s=e+r*t;this.directionsArray[r*2]=Math.sin(s),this.directionsArray[r*2+1]=Math.cos(s)}return this.directionsArray}render(e,t){if(!this.gtaoCompute){this.createResource(),this.createCompute(),this.rendererPassState=He.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GTAO";let h=pe.getCameraGroup(e.camera);this.gtaoCompute.setUniformBuffer("globalUniform",h.uniformGPUBuffer)}let r=A.setting.render.postProcessing.gtao;this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply();let s=1-.2*(he.frame%2),a=r.maxDistance*s,n=r.maxPixel*s;this.gtaoSetting.setFloat("maxDistance",a),this.gtaoSetting.setFloat("maxPixel",n),this.gtaoSetting.setFloat("darkFactor",r.darkFactor),this.gtaoSetting.setFloat("rayMarchSegment",r.rayMarchSegment);let l=e.camera;this.gtaoSetting.setFloat("cameraNear",l.near),this.gtaoSetting.setFloat("cameraFar",l.far),this.gtaoSetting.setFloat("multiBounce",r.multiBounce?1:0),this.gtaoSetting.setFloat("blendColor",r.blendColor?1:0),this.gtaoSetting.apply(),w.computeCommand(t,[this.gtaoCompute]),w.lastRenderPassState=this.rendererPassState}}class Yp extends Ct{constructor(){super(),o(this,"viewQuad"),o(this,"rtTexture"),o(this,"_globalFog"),o(this,"_lastSkyTexture");let e=this._globalFog=A.setting.render.postProcessing.globalFog,t=wt.getGBufferFrame("ColorPassGBuffer"),r=S.presentationSize;N.register("GlobalFog_shader",Ec);let s={fogColor:new $(new z(e.fogColor.r,e.fogColor.g,e.fogColor.b,e.fogColor.a)),fogType:new $(e.fogType),fogHeightScale:new $(e.fogHeightScale),start:new $(e.start),end:new $(e.end),density:new $(e.density),ins:new $(e.ins),falloff:new $(e.falloff),rayLength:new $(e.rayLength),scatteringExponent:new $(e.scatteringExponent),dirHeightLine:new $(e.dirHeightLine),skyFactor:new $(e.skyFactor),skyRoughness:new $(e.skyRoughness),overrideSkyFactor:new $(e.overrideSkyFactor),isSkyHDR:new $(0)};this.rtTexture=this.createRTTexture("GlobalFog",r[0],r[1],G.rgba16float),this.viewQuad=this.createViewQuad("GlobalFog","GlobalFog_shader",this.rtTexture,s);let a=t.getPositionMap(),n=t.getNormalMap();this.setInputTexture(a,n)}onAttach(e){A.setting.render.postProcessing.globalFog.enable=!0}onDetach(e){A.setting.render.postProcessing.globalFog.enable=!1}set fogType(e){this._globalFog.fogType=e,this.viewQuad.uniforms.fogType.value=e}get fogType(){return this._globalFog.fogType}set fogHeightScale(e){this._globalFog.fogHeightScale=e,this.viewQuad.uniforms.fogHeightScale.value=e}get fogHeightScale(){return this.viewQuad.uniforms.fogHeightScale.value}set start(e){this._globalFog.start=e,this.viewQuad.uniforms.start.value=e}get start(){return this.viewQuad.uniforms.start.value}set end(e){this._globalFog.end=e,this.viewQuad.uniforms.end.value=e}get end(){return this.viewQuad.uniforms.end.value}set ins(e){this._globalFog.ins=e,this.viewQuad.uniforms.ins.value=e}get ins(){return this.viewQuad.uniforms.ins.value}set density(e){this._globalFog.density=e,this.viewQuad.uniforms.density.value=e}get density(){return this.viewQuad.uniforms.density.value}set skyRoughness(e){this._globalFog.skyRoughness=e,this.viewQuad.uniforms.skyRoughness.value=e}get skyRoughness(){return this._globalFog.skyRoughness}set skyFactor(e){this._globalFog.skyFactor=e,this.viewQuad.uniforms.skyFactor.value=e}get skyFactor(){return this._globalFog.skyFactor}set overrideSkyFactor(e){this._globalFog.overrideSkyFactor=e,this.viewQuad.uniforms.overrideSkyFactor.value=e}get overrideSkyFactor(){return this._globalFog.overrideSkyFactor}get fogColor(){return this._globalFog.fogColor}set fogColor(e){this._globalFog.fogColor.copyFrom(e),this.viewQuad.uniforms.fogColor.color=e,this.viewQuad.uniforms.fogColor.onChange()}set falloff(e){this._globalFog.falloff=e,this.viewQuad.uniforms.falloff.value=e}get falloff(){return this.viewQuad.uniforms.falloff.value}set rayLength(e){this._globalFog.rayLength=e,this.viewQuad.uniforms.rayLength.value=e}get rayLength(){return this._globalFog.rayLength}set scatteringExponent(e){this._globalFog.scatteringExponent=e,this.viewQuad.uniforms.scatteringExponent.value=e}get scatteringExponent(){return this._globalFog.scatteringExponent}set dirHeightLine(e){this._globalFog.dirHeightLine=e,this.viewQuad.uniforms.dirHeightLine.value=e}get dirHeightLine(){return this._globalFog.dirHeightLine}setInputTexture(e,t){const r=this.viewQuad.pass;r.setTexture("positionMap",e),r.setTexture("normalMap",t),this._lastSkyTexture=this.getSkyTexture(),r.setTexture("prefilterMap",this._lastSkyTexture)}getSkyTexture(){let e=A.res.defaultSky;return Q.instance.sky instanceof sa&&(e=Q.instance.sky.map),e}render(e,t){const r=this.viewQuad.pass;let s=this.getSkyTexture();s!=this._lastSkyTexture&&(this._lastSkyTexture=s,r.setTexture("prefilterMap",this._lastSkyTexture)),r.setTexture("colorMap",this.getOutTexture()),r.setUniformFloat("isSkyHDR",s.isHDRTexture?1:0),this.viewQuad.renderTarget(e,this.viewQuad,t)}}class Xp extends Ct{constructor(){super(),o(this,"godRayTexture"),o(this,"rendererPassState"),o(this,"godRayCompute"),o(this,"historyGodRayData"),o(this,"godRaySetting"),o(this,"rtFrame"),o(this,"Render"),o(this,"blendColor",!0),o(this,"rayMarchCount",16),o(this,"scatteringExponent",5),o(this,"intensity",.5)}onAttach(e){this.createGUI()}onDetach(e){this.removeGUI()}createGUI(){}removeGUI(){}createCompute(e){A.setting.render.postProcessing.gtao,this.godRayCompute=new be(Zu);let t=new Dt(4*3);this.godRayCompute.setUniformBuffer("godRayUniform",t),this.historyGodRayData=new ge(4*this.godRayTexture.width*this.godRayTexture.height),this.godRayCompute.setStorageBuffer("historyGodRayData",this.historyGodRayData);let r=wt.getGBufferFrame("ColorPassGBuffer");this.godRayCompute.setSamplerTexture("posTex",r.attachments[1]),this.godRayCompute.setSamplerTexture("normalTex",r.attachments[2]),this.autoSetColorTexture("inTex",this.godRayCompute),this.godRayCompute.setStorageTexture("outTex",this.godRayTexture);let s=A.getRenderJob(e).shadowMapPassRenderer;this.godRayCompute.setSamplerTexture("shadowMap",s.depth2DArrayTexture),this.godRayCompute.workerSizeX=Math.ceil(this.godRayTexture.width/8),this.godRayCompute.workerSizeY=Math.ceil(this.godRayTexture.height/8),this.godRayCompute.workerSizeZ=1,this.godRaySetting=t}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.godRayTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.godRayTexture.name="godRayTexture";let s=new Ce;s.loadOp="load",this.rtFrame=new Ze([this.godRayTexture],[s])}render(e,t){if(!this.godRayCompute){this.createResource(),this.createCompute(e);let s=pe.getLightEntries(e.scene);this.godRayCompute.setStorageBuffer("lightBuffer",s.storageGPUBuffer),this.godRayCompute.setStorageBuffer("models",pe.modelMatrixBindGroup.matrixBufferDst),this.rendererPassState=He.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GodRay";let a=pe.getCameraGroup(e.camera);this.godRayCompute.setUniformBuffer("globalUniform",a.uniformGPUBuffer),bt.addFolder("GodRay"),bt.add(this,"blendColor",0,1,.1),bt.add(this,"scatteringExponent",1,10,.1),bt.add(this,"rayMarchCount",10,30,1),bt.add(this,"intensity",.01,2,.01),bt.endFolder()}this.godRaySetting.setFloat("intensity",this.intensity),this.godRaySetting.setFloat("rayMarchCount",this.rayMarchCount);let r=e.camera;this.godRaySetting.setFloat("viewPortWidth",r.viewPort.width),this.godRaySetting.setFloat("viewPortHeight",r.viewPort.height),this.godRaySetting.setFloat("blendColor",this.blendColor?1:0),this.godRaySetting.setFloat("scatteringExponent",this.scatteringExponent),this.godRaySetting.apply(),w.computeCommand(t,[this.godRayCompute]),w.lastRenderPassState=this.rendererPassState}}class Wp extends Ct{constructor(){super(),o(this,"brightnessView"),o(this,"compositeView"),o(this,"blurList"),o(this,"blurX",1),o(this,"blurY",1);const e=A.setting.render.postProcessing.bloom;e.enable=!0;let t=S.presentationSize,r=this.createRTTexture("HDRBloomPost-outTextures",t[0],t[1],G.rgba16float,!1);Fe.createRTTexture(Ae.colorBufferTex_NAME,t[0],t[1],G.rgba16float,!1);{let l=this.createRTTexture("brightnessTextures",t[0],t[1],G.rgba16float,!1);this.brightnessView=this.createViewQuad("brightnessView","Bloom_Brightness_frag_wgsl",l,{luminosityThreshold:new $(e.luminosityThreshold)})}let s=5,a=t[0],n=t[1];this.blurList=[];for(let l=0;l<s;l++){let h=this.createRTTexture(`tex_l${l}`,a,n,G.rgba16float),u=this.createRTTexture(`tex_r${l}`,a,n,G.rgba16float),c=this.createViewQuad(`ql${l}`,"Bloom_blur_frag_wgsl",h,{texSize:new $(new Z(a*2,n*2)),hScale:new $(l),vScale:new $(l),horizontal:new $(.5)}),f=this.createViewQuad(`qr${l}`,"Bloom_blur_frag_wgsl",u,{texSize:new $(new Z(a*2,n*2)),hScale:new $(l),vScale:new $(l),horizontal:new $(1)});this.blurList.push({ql:c,qr:f}),a/=2,n/=2}this.compositeView=this.createViewQuad("compositeView","Bloom_composite_frag_wgsl",r,{tintColor:new $(new z(1,1,1)),bloomStrength:new $(e.strength),exposure:new $(e.exposure),bloomRadius:new $(1)}),this.blurX=e.blurX,this.blurY=e.blurY,this.luminosityThreshold=e.luminosityThreshold,this.strength=e.strength,this.radius=e.radius}onAttach(e){this.debug()}onDetach(e){}debug(){}get tintColor(){return this.compositeView.uniforms.tintColor.color}set tintColor(e){this.compositeView.uniforms.tintColor.color=e}get strength(){return this.compositeView.uniforms.bloomStrength.value}set strength(e){this.compositeView.uniforms.bloomStrength.value=e}get exposure(){return this.compositeView.uniforms.exposure.value}set exposure(e){this.compositeView.uniforms.exposure.value=e}get radius(){return this.compositeView.uniforms.bloomRadius.value}set radius(e){this.compositeView.uniforms.bloomRadius.value=e}get luminosityThreshold(){return this.brightnessView.uniforms.luminosityThreshold.value}set luminosityThreshold(e){this.brightnessView.uniforms.luminosityThreshold.value=e}render(e,t){{let r=this.getOutTexture();this.brightnessView.renderToViewQuad(e,this.brightnessView,t,r);{let s=this.brightnessView.rendererPassState.renderTargets[0];for(let a=0;a<this.blurList.length;a++){let n=this.blurList[a].ql,l=this.blurList[a].qr;n.pass.setUniformFloat("horizontal",.5),n.pass.setUniformFloat("vScale",a*this.blurX),n.renderToViewQuad(e,n,t,s),s=n.rendererPassState.renderTargets[0],l.pass.setUniformFloat("horizontal",2),l.pass.setUniformFloat("hScale",a*this.blurY),l.renderToViewQuad(e,l,t,s),s=l.rendererPassState.renderTargets[0]}}{let s=this.compositeView.pass;s.setTexture("blurTex1",this.blurList[0].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex2",this.blurList[1].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex3",this.blurList[2].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex4",this.blurList[3].qr.rendererPassState.renderTargets[0]),s.setTexture("blurTex5",this.blurList[4].qr.rendererPassState.renderTargets[0]),this.compositeView.renderToViewQuad(e,this.compositeView,t,r)}}}}class _f{constructor(){o(this,"indexList"),o(this,"color"),o(this,"count")}}class xf{constructor(){o(this,"SlotCount",8),o(this,"MaxEntities",16),o(this,"defaultColor",new z(.2,1,1,1)),o(this,"slots",[]),o(this,"dataDirty",!0);let e=A.setting.render.postProcessing.outline.groupCount;this.SlotCount=Math.max(1,Math.min(e,this.SlotCount));for(let t=0;t<this.SlotCount;t++){let r=this.slots[t]=new _f;r.indexList=new Float32Array(this.MaxEntities),r.color=this.defaultColor.clone(),r.count=0}}clear(){for(let e=0;e<this.SlotCount;e++)this.clearAt(e)}clearAt(e){this.dataDirty=!0;let t=this.slots[e];return t.color.copyFrom(this.defaultColor),t.indexList.fill(-1),t.count=0,this}fillDataAt(e,t,r){this.dataDirty=!0;let s=this.slots[e];if(s){s.indexList.fill(-1);for(let a=0,n=t.length;a<n;a++)s.indexList[a]=t[a];s.count=t.length,s.color.copyFrom(r)}return this}fetchData(e){return e.dirty=this.dataDirty,e.slots=this.slots,this.dataDirty=!1,this}}let kt=new xf;class jp extends Ct{constructor(){super(),o(this,"outlineTex"),o(this,"lowTex"),o(this,"rendererPassState"),o(this,"calcWeightCompute"),o(this,"outlineCompute"),o(this,"blendCompute"),o(this,"outlineSetting"),o(this,"slotsBuffer"),o(this,"slotsArray"),o(this,"entitiesArray"),o(this,"entitiesBuffer"),o(this,"weightBuffer"),o(this,"lowTexSize"),o(this,"oldOutlineColor"),o(this,"rtFrame"),o(this,"fetchData"),o(this,"computeList")}onAttach(e){A.setting.render.postProcessing.outline.enable=!0}onDetach(e){A.setting.render.postProcessing.outline.enable=!1}set outlinePixel(e){e=K(e,0,8);let t=A.setting.render.postProcessing.outline;t.outlinePixel!=e&&(t.outlinePixel=e)}get outlinePixel(){return A.setting.render.postProcessing.outline.outlinePixel}set fadeOutlinePixel(e){let t=A.setting.render.postProcessing.outline;e=K(e,0,8),t.fadeOutlinePixel!=e&&(t.fadeOutlinePixel=e)}get fadeOutlinePixel(){return A.setting.render.postProcessing.outline.fadeOutlinePixel}set strength(e){e=K(e,0,1);let t=A.setting.render.postProcessing.outline;t.strength!=e&&(t.strength=e)}get strength(){return A.setting.render.postProcessing.outline.strength}set useAddMode(e){A.setting.render.postProcessing.outline.useAddMode=e}get useAddMode(){return A.setting.render.postProcessing.outline.useAddMode}createGUI(){}createCompute(){let t=wt.getGBufferFrame("ColorPassGBuffer").getPositionMap();this.calcWeightCompute=new be(tc),this.calcWeightCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.calcWeightCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.calcWeightCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.calcWeightCompute.setStorageBuffer("entitiesBuffer",this.entitiesBuffer),this.calcWeightCompute.setSamplerTexture("indexTexture",t),this.calcWeightCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.calcWeightCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.calcWeightCompute.workerSizeZ=1,this.outlineCompute=new be(ic),this.outlineCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.outlineCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.outlineCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.outlineCompute.setStorageBuffer("oldOutlineColor",this.oldOutlineColor),this.outlineCompute.setStorageTexture("lowTex",this.lowTex),this.outlineCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.outlineCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.outlineCompute.workerSizeZ=1,this.blendCompute=new be(ec),this.blendCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.autoSetColorTexture("inTex",this.blendCompute),this.blendCompute.setSamplerTexture("lowTex",this.lowTex),this.blendCompute.setStorageTexture("outlineTex",this.outlineTex),this.blendCompute.workerSizeX=Math.ceil(this.outlineTex.width/8),this.blendCompute.workerSizeY=Math.ceil(this.outlineTex.height/8),this.blendCompute.workerSizeZ=1}createResource(){let e=S.presentationSize,t=e[0],r=e[1],s=A.setting.render.postProcessing.outline.textureScale;this.lowTexSize=new Z(Math.ceil(t*s),Math.ceil(r*s)),this.lowTex=new oe(this.lowTexSize.x,this.lowTexSize.y,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.lowTex.name="lowTex";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.outlineTex=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outlineTex.name="outlineTex";let n=new Ce;n.clearValue=[0,0,0,1],n.loadOp="clear",this.rtFrame=new Ze([this.outlineTex],[n]),this.outlineSetting=new Dt(8),this.weightBuffer=new ge(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.oldOutlineColor=new ge(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.slotsArray=new Float32Array(kt.SlotCount*4),this.slotsBuffer=new ge(this.slotsArray.length),this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesArray=new Float32Array(kt.SlotCount*kt.MaxEntities),this.entitiesBuffer=new ge(this.entitiesArray.length),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.slotsBuffer.apply(),this.fetchData||(this.fetchData={})}fetchOutlineData(){if(kt.fetchData(this.fetchData),this.fetchData.dirty){let e=kt.SlotCount,t=kt.MaxEntities;for(let r=0;r<e;r++){let s=4*r,a=this.fetchData.slots[r];this.slotsArray[s+0]=a.color.r,this.slotsArray[s+1]=a.color.g,this.slotsArray[s+2]=a.color.b,this.slotsArray[s+3]=a.count,s=t*r,this.entitiesArray.set(a.indexList,s)}this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.entitiesBuffer.apply()}}render(e,t){this.calcWeightCompute||(this.createResource(),this.createCompute(),this.createGUI(),this.rendererPassState=He.createRendererPassState(this.rtFrame,null)),this.computeList||(this.computeList=[this.calcWeightCompute,this.outlineCompute,this.blendCompute]);let r=A.setting.render.postProcessing.outline;this.outlineSetting.setFloat("strength",r.strength),this.outlineSetting.setFloat("useAddMode",r.useAddMode?1:0),this.outlineSetting.setFloat("outlinePixel",r.outlinePixel),this.outlineSetting.setFloat("fadeOutlinePixel",r.fadeOutlinePixel),this.outlineSetting.setFloat("lowTexWidth",this.lowTexSize.x),this.outlineSetting.setFloat("lowTexHeight",this.lowTexSize.y),this.outlineSetting.apply(),this.fetchOutlineData(),w.computeCommand(t,this.computeList),w.lastRenderPassState=this.rendererPassState}}class qp extends Ct{constructor(){super(),o(this,"SSR_RayTraceCompute"),o(this,"SSR_IS_Compute"),o(this,"SSR_Blend_Compute"),o(this,"isRetTexture"),o(this,"finalTexture"),o(this,"rendererPassState"),o(this,"ssrUniformBuffer"),o(this,"rayTraceData"),o(this,"ssrColorData"),o(this,"isKernelFloat32Array"),o(this,"rtFrame"),o(this,"historyPosition"),o(this,"reflectionRatio",.5)}onAttach(e){A.setting.render.postProcessing.ssr.enable=!0,this.debug()}onDetach(e){A.setting.render.postProcessing.ssr.enable=!1}get fadeEdgeRatio(){return A.setting.render.postProcessing.ssr.fadeEdgeRatio}set fadeEdgeRatio(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.fadeEdgeRatio=e}get rayMarchRatio(){return A.setting.render.postProcessing.ssr.rayMarchRatio}set rayMarchRatio(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.rayMarchRatio=e}get roughnessThreshold(){return A.setting.render.postProcessing.ssr.roughnessThreshold}set roughnessThreshold(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.roughnessThreshold=e}get fadeDistanceMin(){return A.setting.render.postProcessing.ssr.fadeDistanceMin}set fadeDistanceMin(e){e=K(e,0,1e4);let t=A.setting.render.postProcessing.ssr;t.fadeDistanceMin=e}get fadeDistanceMax(){return A.setting.render.postProcessing.ssr.fadeDistanceMax}set fadeDistanceMax(e){e=K(e,0,1e4);let t=A.setting.render.postProcessing.ssr;t.fadeDistanceMax=e}get powDotRN(){return A.setting.render.postProcessing.ssr.powDotRN}set powDotRN(e){e=K(e,0,1);let t=A.setting.render.postProcessing.ssr;t.powDotRN=e}debug(){}createRayTraceShader(){this.SSR_RayTraceCompute=new be(oc),this.SSR_RayTraceCompute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_RayTraceCompute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_RayTraceCompute.setStorageBuffer("historyPosition",this.historyPosition);let e=wt.getGBufferFrame("ColorPassGBuffer");this.SSR_RayTraceCompute.setSamplerTexture("zBufferTexture",e.getPositionMap()),this.SSR_RayTraceCompute.setSamplerTexture(Ae.normalBufferTex_NAME,e.attachments[2]),this.SSR_RayTraceCompute.setSamplerTexture(Ae.materialBufferTex_NAME,e.attachments[3]),Q.instance.sky instanceof sa&&this.SSR_RayTraceCompute.setSamplerTexture("prefilterMap",Q.instance.sky.map),this.SSR_RayTraceCompute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_RayTraceCompute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_RayTraceCompute.workerSizeZ=1}createISShader(){this.SSR_IS_Compute=new be(ac),this.SSR_IS_Compute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_IS_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_IS_Compute.setStorageBuffer("ssrColorData",this.ssrColorData),this.SSR_IS_Compute.setStorageBuffer("historyPosition",this.historyPosition),this.autoSetColorTexture("colorMap",this.SSR_IS_Compute),this.SSR_IS_Compute.setStorageTexture("outTex",this.isRetTexture),this.SSR_IS_Compute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_IS_Compute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_IS_Compute.workerSizeZ=1}createBlendShader(e){this.SSR_Blend_Compute=new be(sc),this.SSR_Blend_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.autoSetColorTexture("colorMap",this.SSR_Blend_Compute),this.SSR_Blend_Compute.setSamplerTexture("ssrMap",e),this.SSR_Blend_Compute.setStorageTexture("outTex",this.finalTexture),this.SSR_Blend_Compute.workerSizeX=Math.ceil(this.finalTexture.width/8),this.SSR_Blend_Compute.workerSizeY=Math.ceil(this.finalTexture.height/8),this.SSR_Blend_Compute.workerSizeZ=1}createResource(){let e=S.presentationSize,t=e[0],r=e[1];this.finalTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.finalTexture.name="ssrOutTex";let s=new Ce;s.clearValue=[0,0,0,0],s.loadOp="clear";let a=Math.ceil(t*A.setting.render.postProcessing.ssr.pixelRatio),n=Math.ceil(r*A.setting.render.postProcessing.ssr.pixelRatio);this.isRetTexture=new oe(a,n,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.isRetTexture.name="ssrTextureIn";let l=new Ce;l.clearValue=[0,0,0,0],l.loadOp="clear",this.rtFrame=new Ze([this.finalTexture,this.isRetTexture],[s,l]),this.rayTraceData=new ge(a*n*8,GPUBufferUsage.COPY_SRC),this.ssrColorData=new ge(a*n*4,GPUBufferUsage.COPY_SRC),this.historyPosition=new ge(a*n*4,GPUBufferUsage.COPY_SRC),this.ssrUniformBuffer=new Dt(4*8),this.ssrUniformBuffer.setFloat("ssrBufferSizeX",this.isRetTexture.width),this.ssrUniformBuffer.setFloat("ssrBufferSizeY",this.isRetTexture.height),this.ssrUniformBuffer.setFloat("colorMapSizeX",this.finalTexture.width),this.ssrUniformBuffer.setFloat("colorMapSizeY",this.finalTexture.height),this.ssrUniformBuffer.apply()}render(e,t){if(!this.SSR_RayTraceCompute){this.createResource(),this.createISShader(),this.createRayTraceShader(),this.createBlendShader(this.isRetTexture),this.finalTexture,this.rendererPassState=He.createRendererPassState(this.rtFrame,null);let a=pe.getCameraGroup(e.camera);this.SSR_RayTraceCompute.setUniformBuffer("standUniform",a.uniformGPUBuffer)}let r=A.setting.render.postProcessing.ssr;this.ssrUniformBuffer.setFloat("fadeEdgeRatio",r.fadeEdgeRatio),this.ssrUniformBuffer.setFloat("rayMarchRatio",r.rayMarchRatio),this.ssrUniformBuffer.setFloat("fadeDistanceMin",r.fadeDistanceMin),this.ssrUniformBuffer.setFloat("fadeDistanceMax",r.fadeDistanceMax),this.ssrUniformBuffer.setFloat("mixThreshold",r.mixThreshold),this.ssrUniformBuffer.setFloat("roughnessThreshold",r.roughnessThreshold),this.ssrUniformBuffer.setFloat("reflectionRatio",this.reflectionRatio),this.ssrUniformBuffer.setFloat("powDotRN",r.powDotRN),this.ssrUniformBuffer.setFloat("randomSeedX",Math.random()),this.ssrUniformBuffer.setFloat("randomSeedY",Math.random()),this.ssrUniformBuffer.apply();let s=[this.SSR_RayTraceCompute,this.SSR_IS_Compute,this.SSR_Blend_Compute];w.computeCommand(t,s),w.lastRenderPassState=this.rendererPassState}}class Kp{static createSeeds(){let e=20,t=32,r=[new g(0,0,e)],s=0,a=.02;for(let n=1;n<t;n++){let l=new g;r.push(l),s+=1-(1-.618)*n/t,a+=n*.01,l.x=Math.sin(s)*a,l.y=Math.cos(s)*a,l.z=1-n/t,l.multiplyScalar(e)}return r}}class Jp extends Ct{constructor(){super(),o(this,"taaTexture"),o(this,"outTexture"),o(this,"rendererPassState"),o(this,"taaCompute"),o(this,"copyTexCompute"),o(this,"sharpCompute"),o(this,"taaSetting"),o(this,"preColorBuffer"),o(this,"preColorTex"),o(this,"preProjMatrix"),o(this,"preViewMatrix"),o(this,"rtFrame")}onAttach(e){A.setting.render.postProcessing.taa.enable=!0,e.camera.enableJitterProjection(!0),this.createGUI()}onDetach(e){A.setting.render.postProcessing.taa.enable=!1,e.camera.enableJitterProjection(!1)}get jitterSeedCount(){return A.setting.render.postProcessing.taa.jitterSeedCount}set jitterSeedCount(e){e=K(e,2,8),e=Math.round(e);let t=A.setting.render.postProcessing.taa;t.jitterSeedCount=e}get blendFactor(){return A.setting.render.postProcessing.taa.blendFactor}set blendFactor(e){e=K(e,0,1);let t=A.setting.render.postProcessing.taa;t.blendFactor=e}get sharpFactor(){return A.setting.render.postProcessing.taa.sharpFactor}set sharpFactor(e){e=K(e,.1,.9);let t=A.setting.render.postProcessing.taa;t.sharpFactor=e}get sharpPreBlurFactor(){return A.setting.render.postProcessing.taa.sharpPreBlurFactor}set sharpPreBlurFactor(e){e=K(e,.1,.9);let t=A.setting.render.postProcessing.taa;t.sharpPreBlurFactor=e}get temporalJitterScale(){return A.setting.render.postProcessing.taa.temporalJitterScale}set temporalJitterScale(e){e=K(e,0,1);let t=A.setting.render.postProcessing.taa;t.temporalJitterScale=e}createGUI(){}createCompute(e){let t=new be(hc);A.setting.render.postProcessing.taa;let r=new Dt(16*2+4*3),s=pe.getCameraGroup(e.camera);t.setUniformBuffer("standUniform",s.uniformGPUBuffer),t.setUniformBuffer("taaData",r),t.setStorageBuffer("preColorBuffer",this.preColorBuffer);let a=wt.getGBufferFrame("ColorPassGBuffer");t.setSamplerTexture("preColorTex",this.preColorTex),t.setSamplerTexture("posTex",a.getPositionMap()),this.autoSetColorTexture("inTex",t),t.setStorageTexture("outTex",this.taaTexture),t.workerSizeX=Math.ceil(this.taaTexture.width/8),t.workerSizeY=Math.ceil(this.taaTexture.height/8),t.workerSizeZ=1,this.taaCompute=t,this.taaSetting=r,this.copyTexCompute=new be(nc),this.copyTexCompute.setStorageBuffer("preColor",this.preColorBuffer),this.copyTexCompute.setStorageTexture("preColorTex",this.preColorTex),this.copyTexCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.copyTexCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.copyTexCompute.workerSizeZ=1,this.sharpCompute=new be(lc),this.sharpCompute.setUniformBuffer("taaData",r),this.sharpCompute.setSamplerTexture("inTex",this.taaTexture),this.sharpCompute.setStorageTexture("outTex",this.outTexture),this.sharpCompute.workerSizeX=Math.ceil(this.outTexture.width/8),this.sharpCompute.workerSizeY=Math.ceil(this.outTexture.height/8),this.sharpCompute.workerSizeZ=1}createResource(){this.preProjMatrix=new V().identity(),this.preViewMatrix=new V().identity();let e=S.presentationSize,t=e[0],r=e[1];this.preColorBuffer=new ge(t*r*4,GPUBufferUsage.COPY_SRC),this.preColorTex=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.preColorTex.name="taaTex";let s=new Ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.taaTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.taaTexture.name="taaTex";let a=new Ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.outTexture=new oe(t,r,G.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outTexture.name="sharpTaaTex";let n=new Ce;n.clearValue=[0,0,0,1],n.loadOp="clear",this.rtFrame=new Ze([this.preColorTex,this.taaTexture,this.outTexture],[s,a,n])}render(e,t){this.taaCompute||(this.createResource(),this.createCompute(e),this.rendererPassState=He.createRendererPassState(this.rtFrame,null));let r=A.setting.render.postProcessing.taa;this.taaSetting.setMatrix("preProjMatrix",this.preProjMatrix),this.taaSetting.setMatrix("preViewMatrix",this.preViewMatrix),this.taaSetting.setFloat("jitterFrameIndex",e.camera.jitterFrameIndex),this.taaSetting.setFloat("blendFactor",r.blendFactor),this.taaSetting.setFloat("sharpFactor",r.sharpFactor),this.taaSetting.setFloat("sharpPreBlurFactor",r.sharpPreBlurFactor),this.taaSetting.setFloat("jitterX",e.camera.jitterX),this.taaSetting.setFloat("jitterY",e.camera.jitterY),this.taaSetting.apply(),w.computeCommand(t,[this.copyTexCompute,this.taaCompute,this.sharpCompute]),w.lastRenderPassState=this.rendererPassState,this.preProjMatrix.copyFrom(e.camera.projectionMatrix),this.preViewMatrix.copyFrom(e.camera.viewMatrix)}}class vf{constructor(){o(this,"_tempIndexArray",[]),o(this,"_rendererList",[])}setOutline(e,t){this.setOutlineList([e],t?[t]:null)}setOutlineList(e,t){e||(e=[]);let r=kt.defaultColor,s=kt.SlotCount;for(let a=0;a<s;a++){this._tempIndexArray.length=0;let n=e[a],l=(t?t[a]:null)||r;if(n)for(const h of n)this.getEntityIdList(h,this._tempIndexArray);kt.fillDataAt(a,this._tempIndexArray,l)}}clearOutline(){return kt.clear(),this}getEntityIdList(e,t){this._rendererList.length=0;let r=e.getComponents(ce,this._rendererList);for(const s of r)t.push(s.object3D.transform._worldMatrix.index)}}let Zp=new vf;class yf{constructor(){o(this,"localPosition",new g),o(this,"worldPosition",new g),o(this,"uv",new Z),o(this,"faceIndex"),o(this,"isIn",!1),o(this,"t",0),o(this,"u",0),o(this,"v",0),o(this,"triangle"),o(this,"v0"),o(this,"v1"),o(this,"v2"),o(this,"pickList"),o(this,"color")}}const gs=class{static distPtTri(i,e,t,r){let s=new g,a=new g,n=new g;r.subtract(e,s),t.subtract(e,a),i.subtract(e,n);let l=et(s,s),h=et(s,a),u=et(s,n),c=et(a,a),f=et(a,n),d=1/(l*c-h*h),p=(c*u-h*f)*d,m=(l*f-h*u)*d;if(p>=-gs.EPS&&m>=-gs.EPS&&p+m<=1+gs.EPS){let _=e[1]+s[1]*p+a[1]*m;return Math.abs(_-i[1])}return gs.FLT_MAX}static IntersectTriangle(i,e,t){let r=e.v1,s=e.v2,a=e.v3,n=s.subtract(r,g.HELP_3),l=a.subtract(r,g.HELP_4),h=i.direction.crossProduct(l,g.HELP_5),u=et(n,h),c;if(u>0){if(t)return null;c=i.origin.subtract(r,g.HELP_2)}else c=r.subtract(i.origin,g.HELP_2),u=-u;if(u<1e-4)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let f=et(c,h);if(f<0||f>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let d=c.crossProduct(n,g.HELP_1),p=et(i.direction,d);if(p<0||f+p>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let m=et(l,d),_=1/u;m*=_,f*=_,p*=_,this._info.isIn=!0,this._info.t=m,this._info.u=f,this._info.v=p;let v=1-f-p;return this._u0.copyFrom(e.u1),this._u0.scale(v),this._u1.copyFrom(e.u2),this._u1.scale(f),this._u2.copyFrom(e.u3),this._u2.scale(p),this._info.uv.copyFrom(this._u0),this._info.uv.add(this._u1,this._info.uv),this._info.uv.add(this._u2,this._info.uv),this._info.localPosition.copyFrom(i.direction).multiplyScalar(m),this._info.localPosition.add(i.origin,this._info.localPosition),this._info}};let zi=gs;o(zi,"EPS",1e-4),o(zi,"FLT_MAX",3402823466e29),o(zi,"_info",new yf),o(zi,"_u0",new Z),o(zi,"_u1",new Z),o(zi,"_u2",new Z);const gn=class extends hi{constructor(){if(super(),o(this,"_maxRetry",3),gn._instance)throw new Error("LoadManager is singleton class...")}loadAll(i,e){return new Promise((t,r)=>{let s=i.length,a=[];i.forEach((n,l)=>{let h=new e;this.load(n,e).then(u=>{h.parse(u),a.push(h),s--,s===0&&t(a)})})})}static getInstance(){return this._instance||(this._instance=new gn)}loadUrls(i,e){return new Promise((t,r)=>{let s=i.length,a=[];i.forEach((n,l)=>{this.load(n,e).then(h=>{a.push(h),s--,s===0&&t(a),s<0&&console.error(`loadUrls ${i} error`)})})})}get maxRetry(){return this._maxRetry}set maxRetry(i){this._maxRetry=i}load(i,e){return new Promise((t,r)=>{switch(e.format){}})}};let Cf=gn;o(Cf,"_instance");class $p{}class em{}class tm{}class im{}class rm{}class sm{}class am{}class om{}class nm{}class lm{}class hm{constructor(){o(this,"asset"),o(this,"extras"),o(this,"geometricError"),o(this,"properties"),o(this,"refine"),o(this,"root")}}class um{constructor(){o(this,"boundingVolume"),o(this,"children"),o(this,"geometricError"),o(this,"transform")}}class cm{constructor(){o(this,"boundingVolume"),o(this,"geometricError"),o(this,"refine"),o(this,"content"),o(this,"contents")}}class fm{constructor(){o(this,"uri"),o(this,"group"),o(this,"metadata")}}class dm{constructor(){o(this,"class"),o(this,"properties")}}class Cn{constructor(){o(this,"group"),o(this,"_modelList"),o(this,"_tileSet"),o(this,"_rootPath"),this.group=new te}async loadTileSet(e,t){this._modelList=[],this._rootPath=e;let r=e+"/"+t;if(this._tileSet=await A.res.loadJSON(r),this._tileSet.root.transform){let l=new V;for(let h=0;h<16;h++)l.rawData[h]=this._tileSet.root.transform[h]}let s=new V;switch((this._tileSet.asset&&this._tileSet.asset.gltfUpAxis||"y").toLowerCase()){case"x":s.makeRotationAxis(g.Y_AXIS,-Math.PI/2);break;case"y":s.makeRotationAxis(g.X_AXIS,Math.PI/2);break;case"z":s.identity();break}let n=s.clone();n.invert(),this.applyTransform(this.group.transform,n);for(let l of this._tileSet.root.children){let h=[];if(l.content&&l.content.uri&&h.push(l.content.uri),l.contents)for(let u of l.contents)h.push(u.uri);for(let u of h){let c=this._rootPath+"/"+u,f={onProgress:p=>this.onLoadProgress(p),onComplete:p=>this.onComplete(p)},d;if(c.endsWith(".glb"))d=await A.res.loadGltf(c,f),this.applyTransform(d.transform,s);else if(c.endsWith("tileset.json")){let p=c.replace("/tileset.json",""),m=new Cn;await m.loadTileSet(p,"tileset.json"),d=m.group}else c.endsWith(".i3dm")?d=await A.res.loadI3DM(c,f,s):c.endsWith(".b3dm")&&(d=await A.res.loadB3DM(c,f,s));d&&(this._modelList.push(d),this.group.addChild(d))}}}onLoadProgress(e){}onComplete(e){}applyTransform(e,t){let r=t.decompose(yt.QUATERNION);e.localRotQuat.copyFrom(r[1]),e.localRotQuat=e.localRotQuat,e.localPosition.copyFrom(r[0]),e.localPosition=e.localPosition,e.localScale.copyFrom(r[2]),e.localScale=e.localScale}}class wf extends os{constructor(){super(),N.register("ColorLitShader",en.Ori_AllShader);let e=new We("ColorLitShader","ColorLitShader");e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain"),e.setUniformColor("baseColor",new z),e.setUniformColor("emissiveColor",new z),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",0),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("alphaCutoff",0);let t=e.shaderState;t.acceptShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,e.setTexture("normalMap",A.res.normalTexture),e.setTexture("emissiveMap",A.res.blackTexture)}clone(){return null}debug(){}}o(wf,"count",0);function gm(i,e){}class wn extends os{constructor(){super(),N.register("GlassShader",Cc);let e=new We("GlassShader","GlassShader");this.defaultPass=e,e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0;let r=A.res.getTexture("BRDFLUT");this.brdfLUT=r,this.baseMap=A.res.whiteTexture,this.normalMap=A.res.normalTexture,this.emissiveMap=A.res.blackTexture}clone(){console.log(`clone material ${this.name}`);let e=new wn;return e.baseMap=this.baseMap,e.normalMap=this.normalMap,e.aoMap=this.aoMap,this.maskMap&&(e.maskMap=this.maskMap),e.emissiveMap=this.emissiveMap,this.uvTransform_1&&(e.uvTransform_1=new j().copyFrom(this.uvTransform_1)),this.uvTransform_2&&(e.uvTransform_2=new j().copyFrom(this.uvTransform_2)),e.baseColor=this.baseColor.clone(),e.emissiveColor=this.emissiveColor.clone(),this.materialF0&&(e.materialF0=new j().copyFrom(this.materialF0)),e.envIntensity=this.envIntensity,e.normalScale=this.normalScale,e.roughness=this.roughness,e.metallic=this.metallic,e.ao=this.ao,e.roughness_min=this.roughness_min,e.roughness_max=this.roughness_max,e.metallic_min=this.metallic_min,e.metallic_max=this.metallic_max,e.emissiveIntensity=this.emissiveIntensity,e.alphaCutoff=this.alphaCutoff,e.ior=this.ior,e.clearcoatFactor=this.clearcoatFactor,e.clearcoatRoughnessFactor=this.clearcoatRoughnessFactor,e}}class pm extends _i{constructor(){super();let e=new We("LambertShader","LambertShader");e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z(1,1,1,1)),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.defaultPass=e,this.baseMap=A.res.grayTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}get baseMap(){return this.defaultPass.getTexture("baseMap")}set baseColor(e){this.defaultPass.setUniformColor("baseColor",e)}get baseColor(){return this.defaultPass.uniforms.baseColor.color}set envMap(e){}set shadowMap(e){}}class mm extends _i{constructor(){super(),N.register("UnLitShader",tn),N.register("PointShadowDebug",bc);let e=new We("UnLitShader","PointShadowDebug");this.defaultPass=e,e.setShaderEntry("VertMain","FragMain"),e.setUniformVector4("transformUV1",new j(0,0,1,1)),e.setUniformVector4("transformUV2",new j(0,0,1,1)),e.setUniformColor("baseColor",new z),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.baseMap=A.res.whiteTexture}set baseMap(e){this.defaultPass.setTexture("baseMap",e)}set envMap(e){}set shadowMap(e){}debug(){}}class bf extends We{constructor(){super("castPointShadowMap_vert","shadowCastMap_frag"),this.setShaderEntry("main","main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class Sf extends We{constructor(){super("shadowCastMap_vert","directionShadowCastMap_frag"),this.setShaderEntry("main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}setTexture(e,t){super.setTexture(e,t)}}class If extends We{constructor(){super("ZPass_shader_vs","ZPass_shader_vs"),this.setShaderEntry("main"),this.useRz=!1;let e=this.shaderState;e.receiveEnv=!1}}class Ef extends We{constructor(){super("gbuffer_vs","gbuffer_fs"),o(this,"transparency"),this.setShaderEntry("VertMain","FragMain"),this.shaderState,this.setUniformColor("baseColor",new z),this.setUniformColor("emissiveColor",new z),this.setUniformFloat("emissiveIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("alphaCutoff",1),this.blendMode=xe.NONE,this.setTexture("normalMap",A.res.normalTexture)}}class Bf extends We{constructor(){super("sky_vs_frag_wgsl","SkyGBuffer_fs"),this.setUniformFloat("exposure",1),this.setUniformFloat("roughness",0);let e=this.shaderState;e.frontFace="ccw",e.cullMode=ui.front,e.depthWriteEnabled=!1,e.depthCompare=vt.less}}class Ia{constructor(e=[]){o(this,"_points"),o(this,"_cacheValue"),this.points=e,this._cacheValue=new Z}get points(){return this._points}set points(e){this._points=e}getValue(e){e<0&&(e=0),e>1&&(e=1);let t=this.points.length-1,r=Math.floor(t*e),s=r+1,a=st.fract((t+1)*e);return s>=t&&(s=r,a=0),this._cacheValue.x=this.points[r].x+(this.points[s].x-this.points[r].x)*a,this._cacheValue.y=this.points[r].y+(this.points[s].y-this.points[r].y)*a,this._cacheValue}static createBezierPoints(e,t){for(var r=new Ia,s=0;s<t;s++){var a=Ia.multiPointBezier(e,s/t);r.points.push(a)}return r}static multiPointBezier(e,t){for(var r=e.length,s=0,a=0,n=function(u,c){for(var f=1,d=1;c>0;)f*=u,d*=c,u--,c--;return f/d},l=0;l<r;l++){var h=e[l];s+=h.x*Math.pow(1-t,r-1-l)*Math.pow(t,l)*n(r-1,l),a+=h.y*Math.pow(1-t,r-1-l)*Math.pow(t,l)*n(r-1,l)}return new Z(s,a)}}class Tf{static calculateCubicBezierPoint(e,t,r,s,a){e>1&&(e=1),e<0&&(e=0);let n=1-e,l=n*n,h=n*n*n,u=e*e,c=e*e*e,f=t.mul(h),d=r.mul(3);d=d.mul(e),d=d.mul(l);let p=s.mul(3);p=p.mul(u),p=p.mul(n);let m=a.mul(c);return f=f.add(d),f=f.add(p),f=f.add(m),f}static bezierPoint(e,t,r,s){e>1&&(e=1),e<0&&(e=0);let a=1-e,n=a*a,l=e*e,h=t.mul(n),u=r.mul(2);u.scaleBy(a),u.scaleBy(e);let c=s.mul(l);return h=h.add(u),h=h.add(c),h}static calculateCubicBezierPoints(e,t,r){e>1&&(e=1),e<0&&(e=0);let s=1-e,a=s*s,n=s*s*s,l=e*e,h=e*e*e,u=t[r].mul(n),c=t[r+1].mul(3);c=c.mul(e),c=c.mul(a);let f=t[r+2].mul(3);f=f.mul(l),f=f.mul(s);let d=t[r+3].mul(h);return u=u.add(c),u=u.add(f),u=u.add(d),u}static bezierPathValue(e,t){e>1&&(e=1),e<0&&(e=0);let r=t.length,s=this.tmp_points;s.length=0;for(let a=1;a<r;++a)for(let n=0;n<r-a;++n){if(a==1){let h=new g;h.x=t[n].x*(1-e)+t[n+1].x*e,h.y=t[n].y*(1-e)+t[n+1].y*e,h.z=t[n].z*(1-e)+t[n+1].z*e,this.tmp_points.push(h);continue}let l=new g;l.x=s[n].x*(1-e)+s[n+1].x*e,l.y=s[n].y*(1-e)+s[n+1].y*e,l.z=s[n].z*(1-e)+s[n+1].z*e,s.push(l)}return s[0]}}o(Tf,"tmp_points",[]);class ca{constructor(e){o(this,"controlVertices"),this.setControlVertices(e)}setControlVertices(e){e.length==4&&(this.controlVertices=e.concat())}getPoint(e){if(!(e>=0&&e<=1))return g.ZERO;let t=1-e,r=t*t*t,s=3*e*t*t,a=3*e*e*t,n=e*e*e;return this.controlVertices[0].mul(r).add(this.controlVertices[1].mul(s)).add(this.controlVertices[2].mul(a)).add(this.controlVertices[3].mul(n))}getTangent(e){if(!(e>=0&&e<=1))return g.ZERO;let t=this.controlVertices,r=t[0].add(t[1].add(t[0]).mul(e)),s=t[1].add(t[2].add(t[1]).mul(e)),a=t[2].add(t[3].add(t[2]).mul(e)),n=r.add(s.subtract(r).mul(e));return s.add(a.subtract(s).mul(e)).subtract(n)}getClosestParam(e,t=1e-6){return this.getClosestParamRec(e,0,1,t)}getClosestParamRec(e,t,r,s){let a=(t+r)/2;if(r-t<s)return a;let n=(t+a)/2,l=(a+r)/2,h=this.getPoint(n),u=this.getPoint(l),c=h.subtract(e).lengthSquared,f=u.subtract(e).lengthSquared;return c<f?r=a:t=a,this.getClosestParamRec(e,t,r,s)}}var Mf=(i=>(i[i.Open=0]="Open",i[i.Closed=1]="Closed",i))(Mf||{});class Am{constructor(e,t=0){o(this,"type",0),o(this,"numCurveSegments",0),o(this,"numControlVertices",0),o(this,"controlVertices",[]),this.setControlVertices(e,t)}getPathType(){return this.type}isClosed(){return this.type==1}isValid(){return this.numCurveSegments>0}clear(){this.controlVertices.length=0,this.type=0,this.numCurveSegments=0,this.numControlVertices=0}computeApproxLength(){if(!this.isValid())return 0;let e=this.numCurveSegments+1;if(e<2)return 0;let t=0,r=this.controlVertices;for(let s=1;s<e;s++){let a=r[(s-1)*3],n=r[s*3];t+=a.subtract(n).lengthSquared}return t==0?0:t}computeApproxParamPerUnitLength(){let e=this.computeApproxLength();return this.numCurveSegments/e}computeApproxNormParamPerUnitLength(){return 1/this.computeApproxLength()}interpolatePoints(e,t){let r=e.length;r<2&&console.error("point count must great 1"),this.clear(),this.type=t;let s=this.controlVertices;switch(t){case 0:{this.numCurveSegments=r-1,this.numControlVertices=3*r-2,s.length=this.numControlVertices;for(let l=0;l<r;l++)s[l*3]=e[l];let a=e[1].subtract(e[0]).mul(.25);s[1]=e[0].add(a);let n=e[r-2].subtract(e[r-1]).mul(.25);s[this.numControlVertices-2]=e[r-1].add(n);for(let l=1;l<this.numCurveSegments;l++){let h=e[l-1].subtract(e[l]),u=e[l+1].subtract(e[l]),c=h.lengthSquared,f=u.lengthSquared;if(c>0&&f>0){let d=(c+f)/8,p=u.div(f).subtract(h.div(c));p.normalize(),p=p.mul(d),s[l*3-1]=e[l].subtract(p),s[l*3+1]=e[l].add(p)}else s[l*3-1]=e[l],s[l*3+1]=e[l]}break}case 1:{this.numCurveSegments=r,this.numControlVertices=3*r+1,s.length=this.numControlVertices;for(let a=0;a<r;a++)s[a*3]=e[a];s[this.numControlVertices-1]=e[0];for(let a=1;a<=this.numCurveSegments;a++){let n=a-1,l=(a+1)%this.numCurveSegments,h=a%this.numCurveSegments,u=e[n].subtract(e[h]),c=e[l].subtract(e[h]),f=u.lengthSquared,d=c.lengthSquared,p=3*a-1,m=(3*a+1)%(this.numControlVertices-1);if(f>0&&d>0){let _=(f+d)/8,v=c.div(d).subtract(u.div(f));v.normalize(),v=v.mul(_),s[p]=e[h].subtract(v),s[m]=e[h].add(v)}else s[p]=e[h],s[m]=e[h]}break}}}setControlVertices(e,t){let r=e.length;r<=0||t==0&&r<4||t==1&&r<7||(r-1)%3==0&&(this.clear(),this.type=t,this.numControlVertices=r,this.numCurveSegments=(r-1)/3,this.controlVertices=e)}getPoint(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=st.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=[],s=this.controlVertices;return r[0]=s[3*t+0],r[1]=s[3*t+1],r[2]=s[3*t+2],r[3]=s[3*t+3],new ca(r).getPoint(e-t)}getPointNorm(e){return this.getPoint(e*this.numCurveSegments)}getTangent(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=st.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=this.controlVertices,s=[];return s[0]=r[3*t+0],s[1]=r[3*t+1],s[2]=r[3*t+2],s[3]=r[3*t+3],new ca(s).getTangent(e-t)}getTangentNorm(e){return this.getTangent(e*this.numCurveSegments)}computeClosestParam(e,t){let r=Number.MAX_SAFE_INTEGER,s=0,a=[],n=new ca(a);for(let l=0;l<this.controlVertices.length-1;l+=3){for(let f=0;f<4;f++)a[f]=this.controlVertices[l+f];n.setControlVertices(a);let h=n.getClosestParam(e,t),c=n.getPoint(h).subtract(e).lengthSquared;c<r&&(r=c,s=l/3+h)}return s}computeClosestNormParam(e,t){return this.computeClosestParam(e,t*this.numCurveSegments)}}var Df=(i=>(i[i.kParticleSystemClampVelocityCurveId=322376503]="kParticleSystemClampVelocityCurveId",i[i.kParticleSystemForceCurveId=306581307]="kParticleSystemForceCurveId",i[i.kParticleSystemRotationCurveId=1793934638]="kParticleSystemRotationCurveId",i[i.kParticleSystemRotationBySpeedCurveId=3737431713]="kParticleSystemRotationBySpeedCurveId",i[i.kParticleSystemStartSpeedCurveId=2527743459]="kParticleSystemStartSpeedCurveId",i[i.kParticleSystemSizeCurveId=2368504881]="kParticleSystemSizeCurveId",i[i.kParticleSystemSizeBySpeedCurveId=4085612399]="kParticleSystemSizeBySpeedCurveId",i[i.kParticleSystemVelocityCurveId=3774601268]="kParticleSystemVelocityCurveId",i[i.kParticleSystemUVCurveId=326370691]="kParticleSystemUVCurveId",i[i.kParticleSystemColorGradientId=1494990940]="kParticleSystemColorGradientId",i[i.kParticleSystemColorByVelocityGradientId=1089181156]="kParticleSystemColorByVelocityGradientId",i[i.kParticleSystemMeshSelectionId=3159510623]="kParticleSystemMeshSelectionId",i[i.kParticleSystemUVRowSelectionId=2941263940]="kParticleSystemUVRowSelectionId",i))(Df||{});const _m=3.141592653589793;class xm{}function Pf(i,e,t){let r=.3333333333333333,s=.5,a=i*r,n=a*a,h=n*a-a*e*s+t*s,u=-n+e*r,c=u*u*u,f=c+h*h;if(f>=0){let m=Math.sqrt(f)-h;return m=m>0?Math.pow(m,r):-Math.pow(-m,r),-a-u/m+m}let d=Math.sqrt(-c),p=Math.acos(-h/d);return d=Math.pow(d,r),d=d-u/d,p=-a+d*Math.cos(p*r),p}function fa(i,e,t,r){let s=1e-5;if(Math.abs(i)<s)return Math.abs(e)>s?(r.r0=-t/e,1):0;let a=e*e-4*i*t;if(a<0)return 0;let n=.5/i,l=Math.sqrt(a);return r.r0=(l-e)*n,r.r1=(-l-e)*n,2}function Rf(i,e,t,r,s){let a=0;if(Math.abs(e)>=1e-4){let n=t/e,l=r/e,h=s/e;i[0]=Pf(n,l,h),a++;let u=e,c=t+e*i[0],f=r+t*i[0]+e*i[0]*i[0];a+=fa(u,c,f,{r0:i[1],r1:i[2]})}else a+=fa(t,r,s,{r0:i[1],r1:i[2]});return a}class jt{constructor(){o(this,"coeff",[])}static EvalSegment(e,t){return e*(e*(e*t[0]+t[1])+t[2])+t[3]}}const wr=class{constructor(){o(this,"segments",[]),o(this,"integrationCache",[]),o(this,"doubleIntegrationCache",[]),o(this,"times",[]),o(this,"segmentCount"),this.segments[wr.kMaxNumSegments]=new jt,this.integrationCache[wr.kMaxNumSegments]=0,this.doubleIntegrationCache[wr.kMaxNumSegments]=0,this.times[wr.kMaxNumSegments]=0}calculateMinMax(i,e){i.x=Math.min(i.x,e),i.y=Math.max(i.y,e)}findMinMaxDoubleIntegrated(){let i=Z.ZERO.clone(),e=20,t=1/e,r=t;for(let s=0;s<e;s++)this.calculateMinMax(i,this.evaluateDoubleIntegrated(r)),r+=t;return i}findMinMaxIntegrated(){let i=Z.ZERO.clone(),e=[],t=[];for(let r=0;r<this.segmentCount;r++){let s=4*this.segments[r].coeff[0],a=3*this.segments[r].coeff[1],n=2*this.segments[r].coeff[2],l=1*this.segments[r].coeff[3],h=[],u=Rf(h,s,a,n,l);for(let c=0;c<u;c++){let f=h[c]+e[r];f>=e[r]&&f<t[r]&&this.calculateMinMax(i,this.evaluateIntegrated(f))}this.calculateMinMax(i,this.evaluateIntegrated(t[r])),this.times[r]}return i}generateIntegrationCache(i){i.integrationCache[0]=0;let e=i.times[0],t=0;for(let r=1;r<i.segmentCount;r++){let s=i.segments[r-1].coeff;pn(s);let a=e-t;i.integrationCache[r]=i.integrationCache[r-1]+jt.EvalSegment(a,s)*a,t=e,e=i.times[r]}}generateDoubleIntegrationCache(i){let e=0,t=0;for(let r=0;r<i.segmentCount;r++){i.doubleIntegrationCache[r]=e;let s=i.times[r]-t;s=Math.max(s,0),e+=jt.EvalSegment(s,i.segments[r].coeff)*s*s+i.integrationCache[r]*s,t=i.times[r]}}integrate(){this.generateIntegrationCache(this);for(let i=0;i<this.segmentCount;i++)pn(this.segments[i].coeff)}doubleIntegrate(){this.generateIntegrationCache(this);for(let i=0;i<this.segmentCount;i++)Lf(this.segments[i].coeff);this.generateDoubleIntegrationCache(this)}static isValidCurve(i){let e=i.getKeyCount(),t=e-1;return i.getKey(0).time!=0&&t++,i.getKey(e-1).time!=1&&t++,t<=wr.kMaxNumSegments}evaluateDoubleIntegrated(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t]){let r=i-e;return this.doubleIntegrationCache[t]+this.integrationCache[t]*r+jt.EvalSegment(r,this.segments[t].coeff)*r*r}e=this.times[t]}return 1}evaluateIntegrated(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t]){let r=i-e;return this.integrationCache[t]+jt.EvalSegment(r,this.segments[t].coeff)*r}e=this.times[t]}return 1}evaluate(i){let e=0;for(let t=0;t<this.segmentCount;t++){if(i<=this.times[t])return jt.EvalSegment(i-e,this.segments[t].coeff);e=this.times[t]}return 1}buildCurve(i,e){let t=i.getKeyCount();this.segmentCount=1;let r=1.01;if(this.segments.length=0,this.integrationCache.length=0,this.doubleIntegrationCache.length=0,this.times.length=0,this.times[0]=r,t!=0)if(t==1)this.segments[0]=new jt,this.segments[0].coeff[3]=i.getKey(0).value*e;else{this.segmentCount=t-1;let s=0;i.getKey(0).time!=0&&(this.segments[0].coeff[3]=i.getKey(0).value,this.times[0]=i.getKey(0).time,s=1);for(let a=0;a<this.segmentCount;a++){let n;i.calculateCacheData(n,a,a+1,0),this.segments[a+s].coeff=n.coeff.concat(),this.times[a+s]=i.getKey(a+1).time}this.segmentCount+=s,i.getKey(t-1).time!=1&&(this.segments[this.segmentCount].coeff[3]=i.getKey(t-1).value,this.segmentCount++),this.times[this.segmentCount-1]=r;for(let a=0;a<this.segmentCount;a++)this.segments[a].coeff[0]*=e,this.segments[a].coeff[1]*=e,this.segments[a].coeff[2]*=e,this.segments[a].coeff[3]*=e}return!0}};let da=wr;o(da,"kMaxNumSegments",8);function Lf(i){i[0]/=20,i[1]/=12,i[2]/=6,i[3]/=2}function pn(i){i[0]/=4,i[1]/=3,i[2]/=2,i[3]/=1}var Uf=(i=>(i[i.kEMScalar=0]="kEMScalar",i[i.kEMOptimized=1]="kEMOptimized",i[i.kEMOptimizedMinMax=2]="kEMOptimizedMinMax",i[i.kEMSlow=3]="kEMSlow",i))(Uf||{}),Of=(i=>(i[i.kMMCScalar=0]="kMMCScalar",i[i.kMMCCurve=1]="kMMCCurve",i[i.kMMCTwoCurves=2]="kMMCTwoCurves",i[i.kMMCTwoConstants=3]="kMMCTwoConstants",i))(Of||{});class vm{constructor(){o(this,"max"),o(this,"min")}}class ym{constructor(){o(this,"max"),o(this,"min")}integrate(){this.max.integrate(),this.min.integrate()}doubleIntegrate(){this.max.doubleIntegrate(),this.min.doubleIntegrate()}findMinMaxIntegrated(){return null}findMinMaxDoubleIntegrated(){return null}}class Nf{constructor(e=1){o(this,"minMaxState"),o(this,"minCurve"),o(this,"maxCurve"),o(this,"_scalar",1),o(this,"_minScalar"),this._scalar=e,this.minMaxState=0,this.minCurve=new aa,this.maxCurve=new aa}setScalar(e){this._scalar=e}getScalar(){return this._scalar}static evaluateSlow(e,t,r){let s=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==2?Ii(e.minCurve.getValue(t)*e.getScalar(),s,r):s}static evaluate(e,t,r=1){if(e.minMaxState==0)return e.getScalar();let s=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==1?Ii(e.minCurve.getValue(t)*e.getScalar(),s,r):e.minMaxState==3?Ii(e._minScalar,e._scalar,r):e.minMaxState==2?Ii(e.minCurve.getValue(t)*e.getScalar(),s,1*Math.random()):this.evaluateSlow(e,t,1)}unSerialized(e){this.minMaxState=e.minMaxState,this._scalar=e.scalar,this._minScalar=e.minScalar,this.maxCurve.unSerialized(e.maxCurve),this.minCurve.unSerialized(e.minCurve)}}class Cm{constructor(){o(this,"value",0),o(this,"mode",0),o(this,"spread",0),o(this,"speed",new Nf)}unSerialized(e){this.value=e.value,this.mode=e.mode,this.spread=e.spread,this.speed.unSerialized(e.speed)}}function wm(i,e){let t=da.isValidCurve(i.max);return e!=2&&e!=3?t:t&&da.isValidCurve(i.min)}function bm(i,e,t,r){i.max.buildCurve(e.max,t),r!=2&&r!=3?i.min.buildCurve(e.max,t):i.min.buildCurve(e.min,t)}function Sm(i,e){let t=e.getKeyCount();if(t!=0)if(t==1)ps(i,e.getKey(0).value);else{let r=t-1;ps(i,e.getKey(0).value);for(let s=0;s<r;s++){let a=new an;e.calculateCacheData(a,s,s+1,0);let n=3*a.coeff[0],l=2*a.coeff[1],h=1*a.coeff[2],u=e.getKey(s).time,c=e.getKey(s+1).time,f=[],d=fa(n,l,h,{r0:f[0],r1:f[1]});for(let p=0;p<d;p++)f[p]>=0&&f[p]+u<c&&ps(i,jt.EvalSegment(f[p],a.coeff));ps(i,jt.EvalSegment(c-u,a.coeff))}}}function ps(i,e){i.x=Math.min(i.x,e),i.y=Math.max(i.y,e)}class bn{constructor(e,t){o(this,"point",new g),o(this,"normal",g.UP),o(this,"_tmpVecA",new g),this.point=e,this.normal=t}clone(){return new bn(this.point.clone(),this.normal.clone())}intersectsLine(e,t,r){var s=-this.normal.dotProduct(this.point),a=this.normal.dotProduct(e)+s,n=this.normal.dotProduct(t)+s,l=a/(a-n),h=l>=0&&l<=1;return h&&r&&r.lerp(e,t,l),h}intersectsRay(e,t){t||(t=this._tmpVecA),t.copy(this.point).subtract(e.origin,t);var r=this.normal.dotProduct(t)/this.normal.dotProduct(e.direction),s=r>=0;return s&&t.copyFrom(e.direction).multiplyScalar(r).add(e.origin,t),s}}function Im(i,e){return Math.random()*e+Math.random()*i+(e-i)*Math.random()}function Em(i,e,t){let r=t*Math.random();return Math.random()*e*r+Math.random()*i*r+(e-i)*Math.random()*r}function Ff(i,e,t){let r=0,s=0;for(;r===0;)r=Math.random();for(;s===0;)s=Math.random();let a=Math.sqrt(-2*Math.log(r))*Math.cos(2*Math.PI*s);return a=a/10+.5,(a>1||a<0)&&(a=Ff(i,e,t)),a=Math.pow(a,t),a*=e-i,a+=i,a}function zt(i){return i>0?Math.floor(i):Math.floor(i)-1}let J=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];function mn(i,e){let t=i&15,r=1+(t&7);return t&8&&(r=-r),r*e}function ga(i,e,t){let r=i&7,s=r<4?e:t,a=r<4?t:e;return(r&1?-s:s)+(r&2?-2*a:2*a)}function ms(i,e,t,r){let s=i&15,a=s<8?e:t,n=s<4?t:s==12||s==14?e:r;return(s&1?-a:a)+(s&2?-n:n)}function br(i,e,t,r,s){let a=i&31,n=a<24?e:t,l=a<16?t:r,h=a<8?r:s;return(a&1?-n:n)+(a&2?-l:l)+(a&4?-h:h)}let mt=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];function Bm(i){let e=zt(i),t=e+1,r=i-e,s=r-1,a,n,l=1-r*r;l*=l,a=l*l*mn(J[e&255],r);let h=1-s*s;return h*=h,n=h*h*mn(J[t&255],s),.25*(a+n)}function Tm(i,e){const t=.366025403,r=.211324865;let s,a,n,l=(i+e)*t,h=i+l,u=e+l,c=zt(h),f=zt(u),d=(c+f)*r,p=c-d,m=f-d,_=i-p,v=e-m,y,C;_>v?(y=1,C=0):(y=0,C=1);let B=_-y+r,T=v-C+r,M=_-1+2*r,D=v-1+2*r,P=c&255,L=f&255,I=.5-_*_-v*v;I<0?s=0:(I*=I,s=I*I*ga(J[P+J[L]],_,v));let O=.5-B*B-T*T;O<0?a=0:(O*=O,a=O*O*ga(J[P+y+J[L+C]],B,T));let k=.5-M*M-D*D;return k<0?n=0:(k*=k,n=k*k*ga(J[P+1+J[L+1]],M,D)),40*(s+a+n)}function Mm(i,e,t){const r=.333333333,s=.166666667;let a,n,l,h,u=(i+e+t)*r,c=i+u,f=e+u,d=t+u,p=zt(c),m=zt(f),_=zt(d),v=(p+m+_)*s,y=p-v,C=m-v,B=_-v,T=i-y,M=e-C,D=t-B,P,L,I,O,k,H;T>=M?M>=D?(P=1,L=0,I=0,O=1,k=1,H=0):T>=D?(P=1,L=0,I=0,O=1,k=0,H=1):(P=0,L=0,I=1,O=1,k=0,H=1):M<D?(P=0,L=0,I=1,O=0,k=1,H=1):T<D?(P=0,L=1,I=0,O=0,k=1,H=1):(P=0,L=1,I=0,O=1,k=1,H=0);let W=T-P+s,ne=M-L+s,fe=D-I+s,we=T-O+2*s,ze=M-k+2*s,Re=D-H+2*s,ue=T-1+3*s,de=M-1+3*s,Ge=D-1+3*s,ot=p&255,nt=m&255,Et=_&255,_t=.6-T*T-M*M-D*D;_t<0?a=0:(_t*=_t,a=_t*_t*ms(J[ot+J[nt+J[Et]]],T,M,D));let xt=.6-W*W-ne*ne-fe*fe;xt<0?n=0:(xt*=xt,n=xt*xt*ms(J[ot+P+J[nt+L+J[Et+I]]],W,ne,fe));let qt=.6-we*we-ze*ze-Re*Re;qt<0?l=0:(qt*=qt,l=qt*qt*ms(J[ot+O+J[nt+k+J[Et+H]]],we,ze,Re));let Kt=.6-ue*ue-de*de-Ge*Ge;return Kt<0?h=0:(Kt*=Kt,h=Kt*Kt*ms(J[ot+1+J[nt+1+J[Et+1]]],ue,de,Ge)),32*(a+n+l+h)}function Dm(i,e,t,r){const s=.309016994,a=.138196601;let n,l,h,u,c,f=(i+e+t+r)*s,d=i+f,p=e+f,m=t+f,_=r+f,v=zt(d),y=zt(p),C=zt(m),B=zt(_),T=(v+y+C+B)*a,M=v-T,D=y-T,P=C-T,L=B-T,I=i-M,O=e-D,k=t-P,H=r-L,W=I>O?32:0,ne=I>k?16:0,fe=O>k?8:0,we=I>H?4:0,ze=O>H?2:0,Re=k>H?1:0,ue=W+ne+fe+we+ze+Re,de,Ge,ot,nt,Et,_t,xt,qt,Kt,Ea,Ba,Ta;de=mt[ue][0]>=3?1:0,Ge=mt[ue][1]>=3?1:0,ot=mt[ue][2]>=3?1:0,nt=mt[ue][3]>=3?1:0,Et=mt[ue][0]>=2?1:0,_t=mt[ue][1]>=2?1:0,xt=mt[ue][2]>=2?1:0,qt=mt[ue][3]>=2?1:0,Kt=mt[ue][0]>=1?1:0,Ea=mt[ue][1]>=1?1:0,Ba=mt[ue][2]>=1?1:0,Ta=mt[ue][3]>=1?1:0;let Ma=I-de+a,Da=O-Ge+a,Pa=k-ot+a,Ra=H-nt+a,La=I-Et+2*a,Ua=O-_t+2*a,Oa=k-xt+2*a,Na=H-qt+2*a,Fa=I-Kt+3*a,ka=O-Ea+3*a,za=k-Ba+3*a,Ga=H-Ta+3*a,Qa=I-1+4*a,Va=O-1+4*a,Ha=k-1+4*a,Ya=H-1+4*a,Sr=v&255,Ir=y&255,Er=C&255,Br=B&255,Tr=.6-I*I-O*O-k*k-H*H;Tr<0?n=0:(Tr*=Tr,n=Tr*Tr*br(J[Sr+J[Ir+J[Er+J[Br]]]],I,O,k,H));let Mr=.6-Ma*Ma-Da*Da-Pa*Pa-Ra*Ra;Mr<0?l=0:(Mr*=Mr,l=Mr*Mr*br(J[Sr+de+J[Ir+Ge+J[Er+ot+J[Br+nt]]]],Ma,Da,Pa,Ra));let Dr=.6-La*La-Ua*Ua-Oa*Oa-Na*Na;Dr<0?h=0:(Dr*=Dr,h=Dr*Dr*br(J[Sr+Et+J[Ir+_t+J[Er+xt+J[Br+qt]]]],La,Ua,Oa,Na));let Pr=.6-Fa*Fa-ka*ka-za*za-Ga*Ga;Pr<0?u=0:(Pr*=Pr,u=Pr*Pr*br(J[Sr+Kt+J[Ir+Ea+J[Er+Ba+J[Br+Ta]]]],Fa,ka,za,Ga));let Rr=.6-Qa*Qa-Va*Va-Ha*Ha-Ya*Ya;return Rr<0?c=0:(Rr*=Rr,c=Rr*Rr*br(J[Sr+1+J[Ir+1+J[Er+1+J[Br+1]]]],Qa,Va,Ha,Ya)),27*(n+l+h+u+c)}const kf=class extends Z{constructor(i=0,e=0){super(i,e),o(this,"u",0),o(this,"v",0),this.u=i,this.v=e}length(){return 0}};let zf=kf;o(zf,"uv_0",new kf);class Pm extends tt{constructor(e=1,t=1,r=1,s=8,a=8,n=!1,l=0,h=Math.PI*2){super(),o(this,"radiusTop"),o(this,"radiusBottom"),o(this,"height"),o(this,"radialSegments"),o(this,"heightSegments"),o(this,"openEnded"),o(this,"thetaStart"),o(this,"thetaLength"),this.radiusTop=e,this.radiusBottom=t,this.height=r,this.radialSegments=s,this.heightSegments=a,this.openEnded=n,this.thetaStart=l,this.thetaLength=h,this.instanceID=Pt(),this.buildGeometry()}addGroup(e,t,r){this.addSubGeometry({indexStart:e,indexCount:t,vertexStart:e,index:r})}buildGeometry(){const e=this;this.radialSegments=Math.floor(this.radialSegments),this.heightSegments=Math.floor(this.heightSegments);const t=[],r=[],s=[],a=[];let n=0;const l=[],h=this.height/2;let u=0;m(),this.openEnded===!1&&(this.radiusTop>0&&_(!0),this.radiusBottom>0&&_(!1));let c=new Float32Array(t),f=new Float32Array(r),d=new Float32Array(s),p=new Uint16Array(a);this.setAttribute(Y.position,c),this.setAttribute(Y.normal,f),this.setAttribute(Y.uv,d),this.setAttribute(Y.TEXCOORD_1,d),this.setIndices(p);function m(){const v=new g,y=new g;let C=0;const B=(e.radiusBottom-e.radiusTop)/e.height;for(let T=0;T<=e.heightSegments;T++){const M=[],D=T/e.heightSegments,P=D*(e.radiusBottom-e.radiusTop)+e.radiusTop;for(let L=0;L<=e.radialSegments;L++){const I=L/e.radialSegments,O=I*e.thetaLength+e.thetaStart,k=Math.sin(O),H=Math.cos(O);y.x=P*k,y.y=-D*e.height+h,y.z=P*H,t.push(y.x,y.y,y.z),v.set(k,B,H).normalize(),r.push(v.x,v.y,v.z),s.push(I,1-D),M.push(n++)}l.push(M)}for(let T=0;T<e.radialSegments;T++)for(let M=0;M<e.heightSegments;M++){const D=l[M][T],P=l[M+1][T],L=l[M+1][T+1],I=l[M][T+1];a.push(D,P,I),a.push(P,L,I),C+=6}e.addGroup(u,C,0),u+=C}function _(v){const y=n,C=new Z,B=new g;let T=0;const M=v===!0?e.radiusTop:e.radiusBottom,D=v===!0?1:-1;for(let L=1;L<=e.radialSegments;L++)t.push(0,h*D,0),r.push(0,D,0),s.push(.5,.5),n++;const P=n;for(let L=0;L<=e.radialSegments;L++){const O=L/e.radialSegments*e.thetaLength+e.thetaStart,k=Math.cos(O),H=Math.sin(O);B.x=M*H,B.y=h*D,B.z=M*k,t.push(B.x,B.y,B.z),r.push(0,D,0),C.x=k*.5+.5,C.y=H*.5*D+.5,s.push(C.x,C.y),n++}for(let L=0;L<e.radialSegments;L++){const I=y+L,O=P+L;v===!0?a.push(O,O+1,I):a.push(O+1,O,I),T+=3}e.addGroup(u,T,v===!0?1:2),u+=T}}}class Rm extends tt{constructor(e=.4,t=.1,r=32,s=32){super(),o(this,"radius"),o(this,"tube"),o(this,"radialSegments"),o(this,"tubularSegments"),this.radius=e,this.tube=t,this.radialSegments=r,this.tubularSegments=s,this.initVertex()}initVertex(){const e=2*Math.PI,t=this.radius,r=this.tube,s=this.radialSegments,a=this.tubularSegments;this.bounds=new Be(g.ZERO.clone(),new g(t*2,r*2,t*2));var n=(s+1)*(a+1);let l=new Float32Array(n*3),h=new Float32Array(n*3),u=new Float32Array(n*2),c=new Uint16Array(s*a*2*3),f=0,d=0,p=0,m=0;for(let _=0;_<=s;_++)for(let v=0;v<=a;v++){const y=v/a,C=_/s,B=y*e,T=C*Math.PI*2;if(l[f++]=(t+r*Math.cos(T))*Math.sin(B),l[f++]=r*Math.sin(T),l[f++]=(t+r*Math.cos(T))*Math.cos(B),h[d++]=Math.sin(B)*Math.cos(T),h[d++]=Math.sin(T),h[d++]=Math.cos(B)*Math.cos(T),u[p++]=y,u[p++]=C,v<a&&_<s){const M=a+1,D=M*_+v,P=M*(_+1)+v,L=M*(_+1)+v+1,I=M*_+v+1;c[m++]=D,c[m++]=I,c[m++]=P,c[m++]=I,c[m++]=L,c[m++]=P}}this.setIndices(c),this.setAttribute(Y.position,l),this.setAttribute(Y.normal,h),this.setAttribute(Y.uv,u),this.setAttribute(Y.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:c.length,vertexStart:0,index:0})}}class Lm extends at{constructor(e,t){super(e,t,6),o(this,"width",4),o(this,"height",4),o(this,"depthOrArrayLayers",6),o(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),this.format=G.depth24plus,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.textureBindingLayout.viewDimension="cube"}internalCreateTexture(){this.textureDescriptor={format:"depth24plus",size:{width:this.width,height:this.height,depthOrArrayLayers:6},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=S.device.createTexture(this.textureDescriptor)}internalCreateView(){this.viewDescriptor={dimension:"cube"},this.view=this.gpuTexture.createView(this.viewDescriptor)}internalCreateSampler(){this.gpuSampler=S.device.createSampler({}),this.gpuSampler_comparison=S.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Gf extends at{constructor(){super(...arguments),o(this,"uint16Array"),o(this,"floatArray"),o(this,"_dataBuffer")}create(e,t,r=null,s=!0){if(r==null){r=[];for(let a=0,n=e*t*4;a<n;a++)r[a]=0}return this.updateTexture(e,t,r,s),this}updateTexture(e,t,r,s=!0){(e!=this.width||t!=this.height)&&(this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null,this.gpuTexture&&this.gpuTexture.destroy(),this.gpuTexture=null),this.floatArray=r;let a=S.device;const n=e*4*2;this.format=G.rgba16float,this.mipmapCount=Math.floor(s?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format),(!this.uint16Array||this.uint16Array.length!=r.length)&&(this.uint16Array=new Uint16Array(r.length));let l=this.uint16Array;for(let c=0,f=l.length;c<f;c++)l[c]=ur(r[c]);const h=this._dataBuffer=a.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,l);const u=w.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),w.endCommandEncoder(u),this.gpuSampler=a.createSampler(this),this.gpuTexture=this.getGPUTexture(),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class Um extends at{create(e,t,r,s=!0){let a=S.device;const n=e*4*4;this.format=G.rgba32float;let l=1;this.createTextureDescriptor(e,t,l,this.format);const h=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,r);const u=w.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(u),s&&(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float"),this.gpuSampler=a.createSampler({})}fromBuffer(e,t,r){let s=S.device;const a=e*4*4;this.format=G.rgba32float,this.mipmapCount=1,this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const n=w.beginCommandEncoder();return n.copyBufferToTexture({buffer:r,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(n),this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=s.createSampler({}),this}}class Om extends ra{constructor(e){super(),o(this,"_internalTexture"),o(this,"_minSize",32),o(this,"_skyColor"),this._skyColor=e,this._internalTexture=new Gf;let t=[];return A.res.fillColor(t,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.create(this._minSize,this._minSize,t,!1),this.createFromTexture(this._minSize,this._internalTexture),this}changeColor(e){return this._skyColor=e,A.res.fillColor(this._internalTexture.floatArray,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.updateTexture(this._minSize,this._minSize,this._internalTexture.floatArray,!1),this._faceData.uploadTexture(0,this._internalTexture),this}get color(){return this._skyColor}set color(e){this.changeColor(e)}}class Nm extends at{create(e,t,r,s=!0){let a=S.device;const n=e*4*4;this.format=G.rgba16float,this.mipmapCount=Math.floor(s?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const l=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h),this.minFilter="nearest",this.magFilter="nearest",this.mipmapFilter="nearest",this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="nearest",this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.gpuSampler=a.createSampler(this),this.mipmapCount>1&&Ht.webGPUGenerateMipmap(this)}}class Fm extends te{constructor(e,t=.1){super(),o(this,"length",100),o(this,"thickness",.1),this.length=e,this.thickness=t}}class km extends DataView{constructor(e,t,r){super(e,t,r),o(this,"position",0)}}class zm{static merge(e,t,r){}static generateNormal(){}static generateTangent(){}static packUV(){}}class Gm{static color_temperature_to_rgb(e){e<1e3?e=1e3:e>4e4&&(e=4e4);let t=e/100,r=this.get_red(t),s=this.get_green(t),a=this.get_blue(t);return new z(r/255,s/255,a/255,1)}static get_red(e){if(e<=66)return 255;let t=329.698727446*Math.pow(e-60,-.1332047592);return this.bound(t)}static get_green(e){let t=0;return e<=66?t=99.4708025861*Math.log(e)-161.1195681661:t=288.1221695283*Math.pow(e-60,-.0755148492),this.bound(t)}static get_blue(e){let t=0;return e>=66?255:e<=19?0:(t=138.5177312231*Math.log(e-10)-305.0447927307,this.bound(t))}static bound(e,t=0,r=255){let s=Math.max(e,t);return Math.min(s,r)}}class pa{static initHeap(){this.boxGeo||(this.boxGeo=new us),this.sphere||(this.sphere=new ls(1,35,35)),this.material||(this.material=new yi)}static get CubeMesh(){return this.initHeap(),this.boxGeo}static get SphereMesh(){return this.initHeap(),this.sphere}static GetCube(){this.initHeap();let e=new te,t=e.addComponent(ce);return t.geometry=this.boxGeo,t.material=this.material.clone(),t.castShadow=!0,e}static GetSingleCube(e,t,r,s,a,n){this.initHeap();let l=new yi;l.baseColor=new z(s,a,n,1);let h=new te,u=h.addComponent(ce);return u.castGI=!0,u.geometry=new us(e,t,r),u.material=l,h}static GetSingleSphere(e,t,r,s){this.initHeap();let a=new yi;a.baseColor=new z(t,r,s,1);let n=new te,l=n.addComponent(ce);return l.castGI=!0,l.geometry=new ls(e,20,20),l.material=a,n}static get Sphere(){this.initHeap();let e=new te,t=e.addComponent(ce);return t.geometry=this.sphere,t.material=this.material,e}static GetSingleCube2(e,t=10){this.initHeap();let r=new te,s=r.addComponent(ce);return s.castShadow=!1,s.geometry=new us(t,t,t),s.material=e,r}}o(pa,"boxGeo"),o(pa,"sphere"),o(pa,"material");class Qm extends Number{}class Vm extends Number{}class Hm extends Number{}class Ym extends wi{constructor(){super(...arguments),o(this,"x",0),o(this,"y",0),o(this,"z",0),o(this,"w",0)}}


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
var parseProtocol = __webpack_require__(/*! ../helpers/parseProtocol */ "./node_modules/axios/lib/helpers/parseProtocol.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = __webpack_require__(/*! ./cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
axios.VERSION = (__webpack_require__(/*! ./env/data */ "./node_modules/axios/lib/env/data.js").version);
axios.toFormData = __webpack_require__(/*! ./helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

// Expose AxiosError class
axios.AxiosError = __webpack_require__(/*! ../lib/core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var CanceledError = __webpack_require__(/*! ./CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var buildFullPath = __webpack_require__(/*! ./buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(/*! ./AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var transitionalDefaults = __webpack_require__(/*! ./transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var toFormData = __webpack_require__(/*! ../helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ../adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ../adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: __webpack_require__(/*! ./env/FormData */ "./node_modules/axios/lib/helpers/null.js")
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = {
  "version": "0.27.2"
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ ((module) => {

// eslint-disable-next-line strict
module.exports = null;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = (__webpack_require__(/*! ../env/data */ "./node_modules/axios/lib/env/data.js").version);
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};


/***/ }),

/***/ "./others/index.ts":
/*!*************************!*\
  !*** ./others/index.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeometryMain: () => (/* reexport safe */ _orillusion__WEBPACK_IMPORTED_MODULE_0__.GeometryMain)
/* harmony export */ });
/* harmony import */ var _orillusion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./orillusion */ "./others/orillusion/index.ts");
// export * from "./babylon";

// export * from "./render"
// export * from "./taigpu"
// export * from "./dxf"
// export * from "./usethree"


/***/ }),

/***/ "./others/orillusion/geometry.ts":
/*!***************************************!*\
  !*** ./others/orillusion/geometry.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeometryMain: () => (/* binding */ GeometryMain)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _orillusion_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @orillusion/core */ "./node_modules/@orillusion/core/dist/orillusion.es.js");


const Engine3D = _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Engine3D;
Engine3D.setting.render.postProcessing.globalFog.fogType = 0; //Liner:0, Exp:1, Exp2:2
Engine3D.setting.render.postProcessing.globalFog.start = 400;
Engine3D.setting.render.postProcessing.globalFog.end = 0;
Engine3D.setting.render.postProcessing.globalFog.fogHeightScale = 1;
Engine3D.setting.render.postProcessing.globalFog.density = 0.02;
Engine3D.setting.render.postProcessing.globalFog.ins = 1;
Engine3D.setting.render.postProcessing.globalFog.fogColor =
    new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Color(84, 90, 239, 255);
Engine3D.setting.render.postProcessing.globalFog.skyFactor = 0.5;
Engine3D.setting.render.postProcessing.globalFog.skyRoughness = 0.4;
Engine3D.setting.render.postProcessing.globalFog.overrideSkyFactor = 0.8;
class GeometryMain {
    constructor() {
        this.run();
    }
    scene;
    hoverCameraController;
    lightObj;
    async run() {
        await _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Engine3D.init({
            canvasConfig: { devicePixelRatio: window.devicePixelRatio },
        });
        this.scene = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Scene3D();
        let cameraObj = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Object3D();
        let mainCamera = cameraObj.addComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Camera3D);
        mainCamera.perspective(37, _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.webGPUContext.aspect, 1, 10000.0);
        this.hoverCameraController = mainCamera.object3D.addComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.HoverCameraController);
        this.scene.addChild(cameraObj);
        //set camera data
        this.hoverCameraController.setCamera(130, -30, 2000);
        this.hoverCameraController.target = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(-1073, 61 - 150, 314);
        // this.initScene(this.scene);
        // Orillusion.AtmosphericComponent
        let sky = this.scene.getOrAddComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.SkyRenderer);
        // sky.map = await Orillusion.Engine3D.res.loadHDRTextureCube(
        //   "http://localhost:9988/sky/kloofendal_48d_partly_cloudy_puresky_8k.hdr"
        // );
        sky.map = await _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Engine3D.res.loadTextureCubeStd("public/pic/pizzo_pernice_puresky_8k.jpg");
        // create a basic cube
        // this.scene.addChild(
        //   Orillusion.Object3DUtil.GetSingleCube(10, 10, 10, 0.6, 0.6, 0.6)
        // );
        // add an Atmospheric sky enviroment
        // const sun = this.scene.addComponent(Orillusion.AtmosphericComponent);
        // sun.sunY = 0.6;
        ////////////////////////////////////////////////
        // create a view with target scene and camera
        let view = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.View3D();
        view.scene = this.scene;
        view.camera = mainCamera;
        // start render
        let data1 = await _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Engine3D.res.loadGltf("public/glb/L19-8k.glb");
        data1.traverse((child) => {
            const mesh = child.getComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.MeshRenderer);
            if (mesh) {
                // console.log("mesh", mesh.material.envMap = sky.map)
                // @ts-ignore
                mesh.material.envIntensity = 4;
            }
        });
        // 
        this.scene.addChild(data1);
        let data2 = await _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Engine3D.res.loadGltf("public/glb/d-0907.glb");
        data2.traverse((child) => {
            const mesh = child.getComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.MeshRenderer);
            if (mesh) {
                // console.log("mesh", mesh.material.envMap = sky.map)
                mesh.material.blendMode = _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.BlendMode.NORMAL;
                // @ts-ignore
                mesh.material.alphaCutoff = 0.1;
                // @ts-ignore
                mesh.material.baseColor.a = 0.3;
                mesh.material.transparent = true;
                // @ts-ignore
                mesh.material.envIntensity = 0.1;
            }
        });
        data2.localPosition = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(-745, 12, 430);
        data2.localRotation = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, (2.63544717051144 * 180) / Math.PI, 0);
        data2.localScale = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(1.04, 1, 1.04);
        // 
        this.scene.addChild(data2);
        this.scene.envMap = sky.map;
        //   Orillusion.Engine3D.pause();
        //   // 
        //   Orillusion.Engine3D.resume();
        // }, 1000 * 4);
        // let postProcessing = this.scene.addComponent(
        //   Orillusion.PostProcessingComponent
        // );
        // postProcessing.addPost(Orillusion.GlobalFog);
        _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Engine3D.startRenderView(view);
        setTimeout(() => {
            this.initScene(this.scene);
        }, 1000 * 0.2);
    }
    light;
    async initScene(scene) {
        let dirLight = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Object3D();
        dirLight.rotationX = 60;
        dirLight.rotationY = 30;
        dirLight.rotationZ = 30;
        this.light = dirLight.addComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.DirectLight);
        this.light.intensity = 100;
        // light.lightColor.r = 255 / 255
        // light.lightColor.g = 157 / 255
        // light.lightColor.b = 5 / 255
        scene.addChild(dirLight);
        // let GUIHelp = new dat.GUI();
        // GUIHelp.addFolder("Direct Light");
        // GUIHelp.add(dirLight, "rotationX", -180, 180, 1);
        // GUIHelp.add(dirLight, "rotationY", -180, 180, 1);
        // GUIHelp.add(dirLight, "rotationZ", -180, 180, 1);
        // GUIHelp.addColor(
        //   { color: Object.values(this.light.lightColor).map((v) => v * 255) },
        //   "color"
        // ).onChange((v) => {
        //   this.light.lightColor.copyFromArray(v);
        // });
        // GUIHelp.add(this.light, "intensity", 0, 200, 1);
        ////////////////////////////////////////////////
        let mat = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.LitMaterial();
        mat.baseMap = _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Engine3D.res.grayTexture;
        let floor = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Object3D();
        let mr = floor.addComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.MeshRenderer);
        // mr.geometry = new Orillusion.BoxGeometry(2000, 1, 2000);
        mr.geometry = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.BoxGeometry(2450, 1, 4450);
        mr.material = mat;
        floor.localRotation = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, (-0.488692190558412 * 180) / Math.PI, 0);
        floor.localPosition = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(-2216, 26, 2150);
        this.scene.addChild(floor);
        // console.log('floor: ', floor);
        /////////////////////////////////////////////////////////////
        // const east0 = await this.addMesh("public/json/0.json");
        // const east11 = await this.addMesh("public/json/11.json");
        const east19 = await this.addMesh("public/json/19.json");
        // const east26 = await this.addMesh("public/json/26.json");
        // const east28 = await this.addMesh("public/json/28.json");
        // const east31 = await this.addMesh("public/json/31.json");
        // const _list = [east0, east11, east19, east26, east28, east31];
        // // const _list = [east31]
        // // east11.getComponent(Orillusion.MeshRenderer).enable = false
        this.scene.update();
        // // this.scene.removeChild(east26);
        // _list.forEach((_item) => {
        //   _item.getComponent(Orillusion.MeshRenderer).enable = false;
        // });
        // _list[0].getComponent(Orillusion.MeshRenderer).enable = true;
        // let _index = 0;
        // setInterval(() => {
        //   _list.forEach((_item) => {
        //     _item.getComponent(Orillusion.MeshRenderer).enable = false;
        //   });
        //   _list[_index].getComponent(Orillusion.MeshRenderer).enable = true;
        //   _index++;
        //   _index = _index % _list.length;
        // }, 1000 * 0.5);
    }
    async addMesh(url = "public/json/11.json") {
        const dataMesh = (await axios__WEBPACK_IMPORTED_MODULE_0___default().get(url)).data;
        let east = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Object3D();
        let eastMR = east.addComponent(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.MeshRenderer);
        let eastGeo = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.GeometryBase();
        eastGeo.setAttribute(_orillusion_core__WEBPACK_IMPORTED_MODULE_1__.VertexAttributeName.position, new Float32Array(dataMesh.data.attributes.position.array));
        eastGeo.setAttribute("NEKOYUU", new Float32Array(dataMesh.data.attributes["DEPL____DEPL"].array));
        // eastGeo.vertexBuffer
        eastGeo.setIndices(new Uint16Array(dataMesh.data.index.array));
        eastGeo.addSubGeometry({
            indexStart: 0,
            indexCount: dataMesh.data.index.array.length,
            vertexStart: 0,
            index: 0,
        });
        eastGeo.computeNormals();
        eastMR.geometry = eastGeo;
        const customMaterial = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.LambertMaterial();
        customMaterial.doubleSide = true;
        // @ts-ignore
        customMaterial._defaultPass._sourceFS = /*wgsl*/ `
    #include "GlobalUniform"
    struct FragmentVarying {
      @location(0) fragUV0: vec2<f32>,
      @location(1) fragUV1: vec2<f32>,
      @location(2) viewPosition: vec4<f32>,
      @location(3) fragPosition: vec4<f32>,
      @location(4) vWorldPos: vec4<f32>,
      @location(5) vWorldNormal: vec3<f32>,
      @location(6) TAI: f32,
      // @location(6) vColor: vec4<f32>,

      #if USE_SHADOWMAPING
          @location(7) vShadowPos: vec4<f32>,
      #endif

      #if USE_TANGENT
          @location(8) TANGENT: vec4<f32>,
      #endif
      
      @builtin(front_facing) face: bool,
      @builtin(position) fragCoord : vec4<f32>
  };
    #include "ColorPassFragmentOutput"
    #include "ShadingInput"

    const colorbar: array<f32, 63> = array<f32, 63>(0.0196078431372549, 0.3803921568627451, 0.996078431372549, 0.0196078431372549, 0.47058823529411764, 0.9333333333333333, 0.0196078431372549, 0.5529411764705883, 0.8627450980392157, 0.0196078431372549, 0.6274509803921569, 0.7803921568627451, 0.0196078431372549, 0.6980392156862745, 0.6823529411764706, 0.0196078431372549, 0.7725490196078432, 0.5764705882352941, 0.0196078431372549, 0.8509803921568627, 0.4549019607843137, 0.01568627450980392, 0.9176470588235294, 0.30980392156862746, 0.4470588235294118, 0.9568627450980393, 0.11764705882352941, 0.7490196078431373, 0.9803921568627451, 0.03529411764705882, 0.996078431372549, 0.996078431372549, 0.011764705882352941, 0.996078431372549, 0.9058823529411765, 0.15294117647058825, 0.996078431372549, 0.807843137254902, 0.21568627450980393, 0.996078431372549, 0.7058823529411765, 0.21568627450980393, 0.996078431372549, 0.6039215686274509, 0.21568627450980393, 0.996078431372549, 0.49019607843137253, 0.21568627450980393, 0.996078431372549, 0.3607843137254902, 0.21176470588235294, 0.9882352941176471, 0.1803921568627451, 0.20392156862745098, 0.9098039215686274, 0.08627450980392157, 0.2823529411764706, 0.803921568627451, 0.0392156862745098, 0.35294117647058826, 0.6823529411764706, 0.047058823529411764, 0.4117647058823529);
    var<private> ORI_FragmentOutput: FragmentOutput;
    var<private> ORI_VertexVarying: FragmentVarying;
    var<private> ORI_ShadingInput: ShadingInput;
    var<private> viewDir:vec3<f32>;
    @fragment
    fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
      
      // ORI_FragmentOutput.color = vec4<f32>(vertex_varying.vColor.r, vertex_varying.vColor.g,vertex_varying.vColor.b,1.);

      
      var maxValue: f32 = 0.02407176621275162;
      var minValue: f32 = 0.0005287034969998025;
      var scalar = (vertex_varying.TAI - minValue) / (maxValue - minValue);
      if(scalar<=0.){
        ORI_FragmentOutput.color = vec4<f32>(
          colorbar[0], 
          colorbar[1], 
          colorbar[2], 
        1.);
      }else if(scalar>=1.){
        ORI_FragmentOutput.color = vec4<f32>(
          colorbar[60], 
          colorbar[61], 
          colorbar[62], 
        1.);
      }else{
        var index = i32(floor(scalar* 20));
        var index1 = index + 1;
        var mixValue = scalar* 20 - floor(scalar* 20);
        ORI_FragmentOutput.color = vec4<f32>(
          colorbar[index1 * 3] * mixValue + (1. - mixValue) * colorbar[index * 3], 
          colorbar[index1 * 3 + 1] * mixValue + (1. - mixValue) * colorbar[index * 3 +1],
          colorbar[index1 * 3 + 2] * mixValue + (1. - mixValue) * colorbar[index * 3 + 2],
        1.);
      }
      return ORI_FragmentOutput ;
    }

`;
        // @ts-ignore
        customMaterial._defaultPass._sourceVS =
            // @ts-ignore
            customMaterial._defaultPass._sourceVS.replace('#include "Common_frag"', "");
        // @ts-ignore
        customMaterial._defaultPass._sourceVS =
            // @ts-ignore
            customMaterial._defaultPass._sourceVS.replace('#include "Common_vert"', 
            /*wgsl*/ `
    #include "WorldMatrixUniform"

    struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) NEKOYUU: f32,

    }

    struct VertexOutput {
    @location(0) varying_UV0: vec2<f32>,
    @location(1) varying_UV1: vec2<f32>,
    @location(2) varying_ViewPos: vec4<f32>,
    @location(3) varying_Clip: vec4<f32>,
    @location(4) varying_WPos: vec4<f32>,
    @location(5) varying_WNormal: vec3<f32>,
    @location(6) TAI: f32,
    // @location(6) varying_Color: vec4<f32>,
    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;


    #if USE_SKELETON
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #endif

    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
    #endif

    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }

    const colorbar: array<f32, 63> = array<f32, 63>(0.0196078431372549, 0.3803921568627451, 0.996078431372549, 0.0196078431372549, 0.47058823529411764, 0.9333333333333333, 0.0196078431372549, 0.5529411764705883, 0.8627450980392157, 0.0196078431372549, 0.6274509803921569, 0.7803921568627451, 0.0196078431372549, 0.6980392156862745, 0.6823529411764706, 0.0196078431372549, 0.7725490196078432, 0.5764705882352941, 0.0196078431372549, 0.8509803921568627, 0.4549019607843137, 0.01568627450980392, 0.9176470588235294, 0.30980392156862746, 0.4470588235294118, 0.9568627450980393, 0.11764705882352941, 0.7490196078431373, 0.9803921568627451, 0.03529411764705882, 0.996078431372549, 0.996078431372549, 0.011764705882352941, 0.996078431372549, 0.9058823529411765, 0.15294117647058825, 0.996078431372549, 0.807843137254902, 0.21568627450980393, 0.996078431372549, 0.7058823529411765, 0.21568627450980393, 0.996078431372549, 0.6039215686274509, 0.21568627450980393, 0.996078431372549, 0.49019607843137253, 0.21568627450980393, 0.996078431372549, 0.3607843137254902, 0.21176470588235294, 0.9882352941176471, 0.1803921568627451, 0.20392156862745098, 0.9098039215686274, 0.08627450980392157, 0.2823529411764706, 0.803921568627451, 0.0392156862745098, 0.35294117647058826, 0.6823529411764706, 0.047058823529411764, 0.4117647058823529);
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        // var maxValue: f32 = 0.02407176621275162;
        // var minValue: f32 = 0.0005287034969998025;
        // var scalar = (vertex.NEKOYUU - minValue) / (maxValue - minValue);
        // var index = i32(floor(scalar * 21));
        // ORI_VertexOut.varying_Color = vec4<f32>(colorbar[index * 3], colorbar[index * 3 + 1], colorbar[index * 3 + 2], 1);
        ORI_VertexOut.TAI = vertex.NEKOYUU;
        // var index: i32 = 1;
        // ORI_VertexOut.varying_Color = vec4<f32>(colorbar[index * 3], colorbar[index * 3 + 1], colorbar[index * 3 + 2], 1);
        return ORI_VertexOut ;
    }
    `);
        // // @ts-ignore
        eastMR.material = customMaterial;
        // @ts-ignore
        customMaterial._defaultPass.shaderReflection.attributes[4] = {
            format: "float32",
            group: 0,
            location: 3,
            name: "NEKOYUU",
            size: 2,
            type: "location",
            value: 0,
            valueType: "f32",
        };
        east.localPosition = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(-981.747704246813, 15.6032435128293 + 6, 326.097317442621);
        east.localRotation = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(90, -(1.061 * 180) / Math.PI, 180);
        east.localScale = new _orillusion_core__WEBPACK_IMPORTED_MODULE_1__.Vector3(1.04, 1.04, 1.04);
        this.scene.addChild(east);
        return east;
    }
}


/***/ }),

/***/ "./others/orillusion/index.ts":
/*!************************************!*\
  !*** ./others/orillusion/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeometryMain: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_0__.GeometryMain)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry */ "./others/orillusion/geometry.ts");
// export * from "./IllusionMain";
// export * from "./globalIllumination";
// export * from "./shadow";
// export * from "./nephogram"



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeometryMain: () => (/* reexport safe */ _others__WEBPACK_IMPORTED_MODULE_0__.GeometryMain)
/* harmony export */ });
/* harmony import */ var _others__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../others */ "./others/index.ts");
// export * from "./core";
// export * from "./geometry";
// export * from "./materials";
// export * from "./meshes";


})();

TAIGPU = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx3REFBd0Qsa0RBQWtELDREQUE0RCxlQUFlLDZCQUE2Qiw0RUFBNEUsa0JBQWtCLHFIQUFxSCxnQkFBZ0Isd0RBQXdELFlBQVksNEVBQTRFLGFBQWEsbUdBQW1HLG1CQUFtQixZQUFZLDJFQUEyRSxlQUFlLG9GQUFvRixVQUFVLDZIQUE2SCxxQkFBcUIs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVU7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0IsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHdCQUF3Qjs7QUFFeEIseUJBQXlCO0FBQ3pCLHdCQUF3Qjs7QUFFeEIseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLFNBQVMscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsRUFBRSxhQUFhLEVBQUU7QUFDdEM7O0FBRUEscUJBQXFCLEVBQUUsYUFBYSxJQUFJO0FBQ3hDOztBQUVBLHFCQUFxQixFQUFFLGFBQWEsSUFBSTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLGFBQWEsRUFBRTtBQUN0QztBQUNBO0FBQ0EscUJBQXFCLEVBQUUsYUFBYSxJQUFJO0FBQ3hDOztBQUVBO0FBQ0EseUJBQXlCLEVBQUUsYUFBYSxJQUFJO0FBQzVDO0FBQ0E7QUFDQSxFQUFFLDZCQUE2QixtQkFBbUIsRUFBRSxnQkFBZ0Isa0NBQWtDO0FBQ3RHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFVBQVUsbUJBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQsdUNBQXVDLFlBQVk7QUFDbkQseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLHlHQUF5RztBQUN6RztBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLEVBQUUsU0FBUyxlQUFlLDJNQUEyTSxlQUFlLDhCQUE4QixtREFBbUQsK3RCQUErdEIsbUJBQW1CLCtDQUErQyx5QkFBeUIseVRBQXlULGFBQWEseUNBQXlDLGFBQWEsb0ZBQW9GLG9MQUFvTDtBQUNud0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLFNBQVMsZUFBZSxtR0FBbUcsZUFBZSxtQkFBbUIsMlZBQTJWLGFBQWEsZ0NBQWdDLG9OQUFvTixhQUFhLDhHQUE4Ryx1SkFBdUo7O0FBRTdnQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEMsa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFVBQVU7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9E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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcmRBO0FBQzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7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V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL0BvcmlsbHVzaW9uL2NvcmUvZGlzdC9vcmlsbHVzaW9uLmVzLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL251bGwuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VQcm90b2NvbC5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwid2VicGFjazovL1RBSUdQVS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9UQUlHUFUvLi9vdGhlcnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vb3RoZXJzL29yaWxsdXNpb24vZ2VvbWV0cnkudHMiLCJ3ZWJwYWNrOi8vVEFJR1BVLy4vb3RoZXJzL29yaWxsdXNpb24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vVEFJR1BVL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL1RBSUdQVS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9UQUlHUFUvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL1RBSUdQVS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL1RBSUdQVS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL1RBSUdQVS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUWY9T2JqZWN0LmRlZmluZVByb3BlcnR5LFZmPShpLGUsdCk9PmUgaW4gaT9RZihpLGUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTppW2VdPXQsbz0oaSxlLHQpPT4oVmYoaSx0eXBlb2YgZSE9XCJzeW1ib2xcIj9lK1wiXCI6ZSx0KSx0KSxiO2xldCB6PShiPWNsYXNze2NvbnN0cnVjdG9yKGk9MSxlPTEsdD0xLHI9MSl7byh0aGlzLFwiclwiLDApLG8odGhpcyxcImdcIiwwKSxvKHRoaXMsXCJiXCIsMCksbyh0aGlzLFwiYVwiLDApLHRoaXMuc2V0VG8oaSxlLHQscil9Y29udmVydFRvSERSUkdCKCl7cmV0dXJuIHRoaXMucj10aGlzLnIqTWF0aC5wb3coMi40LHRoaXMuYSksdGhpcy5nPXRoaXMuZypNYXRoLnBvdygyLjQsdGhpcy5hKSx0aGlzLmI9dGhpcy5iKk1hdGgucG93KDIuNCx0aGlzLmEpLHRoaXN9dW5TZXJpYWxpemVkKGkpe3JldHVybiB0aGlzLnI9aS5yLHRoaXMuZz1pLmcsdGhpcy5iPWkuYix0aGlzLmE9aS5hLHRoaXN9aGV4VG9SR0IoaSl7cmV0dXJuIHRoaXMucj0oaT4+MTYmMjU1KS8yNTUsdGhpcy5nPShpPj44JjI1NSkvMjU1LHRoaXMuYj0oaSYyNTUpLzI1NSx0aGlzfWhleFRvUkdCQShpKXtyZXR1cm4gdGhpcy5hPShpPj4yNCYyNTUpLzI1NSx0aGlzLnI9KGk+PjE2JjI1NSkvMjU1LHRoaXMuZz0oaT4+OCYyNTUpLzI1NSx0aGlzLmI9KGkmMjU1KS8yNTUsdGhpc31zdGF0aWMgcmFuZG9tKGk9MSl7bGV0IGU9bmV3IGI7cmV0dXJuIGUuYT1pLGUucj1pKk1hdGgucmFuZG9tKCksZS5nPWkqTWF0aC5yYW5kb20oKSxlLmI9aSpNYXRoLnJhbmRvbSgpLGV9c2V0VG8oaSxlLHQscil7dGhpcy5yPU1hdGgubWF4KGksMCksdGhpcy5nPU1hdGgubWF4KGUsMCksdGhpcy5iPU1hdGgubWF4KHQsMCksdGhpcy5hPU1hdGgubWF4KHIsMCl9c2V0SGV4KGkpe2lmKHR5cGVvZiBpIT1cInN0cmluZ1wifHxiLk5PTl9IRVhfQ0hBUlMudGVzdChpKXx8IWIuVkFMSURfSEVYX1NJWkUudGVzdChpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSB2YWxpZCBoZXggc3RyaW5nXCIpO2k9aS5yZXBsYWNlKC9eIy8sXCJcIik7bGV0IGU9MTtpLmxlbmd0aD09PTgmJihlPU51bWJlci5wYXJzZUludChpLnNsaWNlKDYsOCksMTYpLzI1NSxpPWkuc2xpY2UoMCw2KSksaS5sZW5ndGg9PT00JiYoZT1OdW1iZXIucGFyc2VJbnQoaS5zbGljZSgzLDQpLnJlcGVhdCgyKSwxNikvMjU1LGk9aS5zbGljZSgwLDMpKSxpLmxlbmd0aD09PTMmJihpPWlbMF0raVswXStpWzFdK2lbMV0raVsyXStpWzJdKTtjb25zdCB0PU51bWJlci5wYXJzZUludChpLDE2KSxyPXQ+PjE2LHM9dD4+OCYyNTUsYT10JjI1NSxuPWU7dGhpcy5hPW4sdGhpcy5yPXIvMjU1LHRoaXMuZz1zLzI1NSx0aGlzLmI9YS8yNTV9Z2V0SGV4KCl7bGV0IGk9dD0+e3QqPTI1NTtsZXQgcj10LnRvU3RyaW5nKDE2KTtyZXR1cm4gci5sZW5ndGg9PT0xJiYocj1cIjBcIityKSxyfTtyZXR1cm4gaSh0aGlzLnIpK2kodGhpcy5nKStpKHRoaXMuYikraSh0aGlzLmEpfWdldCByZ2IoKXtyZXR1cm5bdGhpcy5yKjI1NT4+PjAsdGhpcy5nKjI1NT4+PjAsdGhpcy5iKjI1NT4+PjBdfXNldCByZ2IoaSl7dGhpcy5zZXRUbyhpWzBdLzI1NSxpWzFdLzI1NSxpWzJdLzI1NSx0aGlzLmEpfWdldCByZ2JhKCl7cmV0dXJuW3RoaXMucioyNTU+Pj4wLHRoaXMuZyoyNTU+Pj4wLHRoaXMuYioyNTU+Pj4wLHRoaXMuYSoyNTU+Pj4wXX1zZXQgcmdiYShpKXt0aGlzLnNldFRvKGlbMF0vMjU1LGlbMV0vMjU1LGlbMl0vMjU1LGlbM10vMjU1KX1jbG9uZSgpe3JldHVybiBuZXcgYigpLmNvcHlGcm9tKHRoaXMpfWNvcHlGcm9tKGkpe3JldHVybiB0aGlzLnI9aS5yLHRoaXMuZz1pLmcsdGhpcy5iPWkuYix0aGlzLmE9aS5hLHRoaXN9Y29weUZyb21BcnJheShpLGU9MjU1KXtyZXR1cm4gdGhpcy5yPWlbMF0vZSx0aGlzLmc9aVsxXS9lLHRoaXMuYj1pWzJdL2UsdGhpcy5hPWlbM10vZSx0aGlzfWNvcHlGcm9tVmVjdG9yKGkpe3JldHVybiB0aGlzLnI9aS54LHRoaXMuZz1pLnksdGhpcy5iPWkueix0aGlzLmE9aS53LHRoaXN9c3RhdGljIGhleFJHQkNvbG9yKGksZT1udWxsKXtyZXR1cm4gZT1lfHxuZXcgYixlLmhleFRvUkdCKGkpLGV9fSxvKGIsXCJDT0xPUl9SRURcIixuZXcgYigxLDAsMCwxKSksbyhiLFwiQ09MT1JfR1JFRU5cIixuZXcgYigwLDEsMCwxKSksbyhiLFwiQ09MT1JfQkxVRVwiLG5ldyBiKDAsMCwxLDEpKSxvKGIsXCJDT0xPUl9XSElURVwiLG5ldyBiKDEsMSwxLDEpKSxvKGIsXCJDT0xPUl8wXCIsbmV3IGIpLG8oYixcIkNPTE9SXzFcIixuZXcgYiksbyhiLFwiQ09MT1JfMlwiLG5ldyBiKSxvKGIsXCJIRVhfQ0hBUkFDVEVSU1wiLFwiYS1mXFxcXGRcIiksbyhiLFwiTUFUQ0hfM09SNF9IRVhcIixgIz9bJHtiLkhFWF9DSEFSQUNURVJTfV17M31bJHtiLkhFWF9DSEFSQUNURVJTfV0/YCksbyhiLFwiTUFUQ0hfNk9SOF9IRVhcIixgIz9bJHtiLkhFWF9DSEFSQUNURVJTfV17Nn0oWyR7Yi5IRVhfQ0hBUkFDVEVSU31dezJ9KT9gKSxvKGIsXCJOT05fSEVYX0NIQVJTXCIsbmV3IFJlZ0V4cChgW14jJHtiLkhFWF9DSEFSQUNURVJTfV1gLFwiZ2lcIikpLG8oYixcIlZBTElEX0hFWF9TSVpFXCIsbmV3IFJlZ0V4cChgXiR7Yi5NQVRDSF8zT1I0X0hFWH0kfF4ke2IuTUFUQ0hfNk9SOF9IRVh9JGAsXCJpXCIpKSxvKGIsXCJQUklNQVJZXCIsNDE0OTY4NSksbyhiLFwiUFJJTUFSWURBUktcIiwzMTYyMDE1KSxvKGIsXCJBQ0NFTlRcIiwxNjcyODE5MyksbyhiLFwiV0hJVEVcIiwxNjc3NzIxNSksbyhiLFwiSVZPUllcIiwxNjc3NzIwMCksbyhiLFwiTElHSFRZRUxMT1dcIiwxNjc3NzE4NCksbyhiLFwiWUVMTE9XXCIsMTY3NzY5NjApLG8oYixcIlNOT1dcIiwxNjc3NTkzMCksbyhiLFwiRkxPUkFMV0hJVEVcIiwxNjc3NTkyMCksbyhiLFwiTEVNT05DSElGRk9OXCIsMTY3NzU4ODUpLG8oYixcIkNPUk5TSUxLXCIsMTY3NzUzODgpLG8oYixcIlNFQVNIRUxMXCIsMTY3NzQ2MzgpLG8oYixcIkxBVkVOREVSQkxVU0hcIiwxNjc3MzM2NSksbyhiLFwiUEFQQVlBV0hJUFwiLDE2NzczMDc3KSxvKGIsXCJCTEFOQ0hFREFMTU9ORFwiLDE2NzcyMDQ1KSxvKGIsXCJNSVNUWVJPU0VcIiwxNjc3MDI3MyksbyhiLFwiQklTUVVFXCIsMTY3NzAyNDQpLG8oYixcIk1PQ0NBU0lOXCIsMTY3NzAyMjkpLG8oYixcIk5BVkFKT1dISVRFXCIsMTY3Njg2ODUpLG8oYixcIlBFQUNIUFVGRlwiLDE2NzY3NjczKSxvKGIsXCJHT0xEXCIsMTY3NjY3MjApLG8oYixcIlBJTktcIiwxNjc2MTAzNSksbyhiLFwiTElHSFRQSU5LXCIsMTY3NTg0NjUpLG8oYixcIk9SQU5HRVwiLDE2NzUzOTIwKSxvKGIsXCJMSUdIVFNBTE1PTlwiLDE2NzUyNzYyKSxvKGIsXCJEQVJLT1JBTkdFXCIsMTY3NDc1MjApLG8oYixcIkNPUkFMXCIsMTY3NDQyNzIpLG8oYixcIkhPVFBJTktcIiwxNjczODc0MCksbyhiLFwiVE9NQVRPXCIsMTY3MzcwOTUpLG8oYixcIk9SQU5HRVJFRFwiLDE2NzI5MzQ0KSxvKGIsXCJERUVQUElOS1wiLDE2NzE2OTQ3KSxvKGIsXCJGVUNIU0lBXCIsMTY3MTE5MzUpLG8oYixcIk1BR0VOVEFcIiwxNjcxMTkzNSksbyhiLFwiUkVEXCIsMTY3MTE2ODApLG8oYixcIk9MRExBQ0VcIiwxNjY0MzU1OCksbyhiLFwiTElHSFRHT0xERU5ST0RZRUxMT1dcIiwxNjQ0ODIxMCksbyhiLFwiTElORU5cIiwxNjQ0NTY3MCksbyhiLFwiQU5USVFVRVdISVRFXCIsMTY0NDQzNzUpLG8oYixcIlNBTE1PTlwiLDE2NDE2ODgyKSxvKGIsXCJHSE9TVFdISVRFXCIsMTYzMTY2NzEpLG8oYixcIk1JTlRDUkVBTVwiLDE2MTIxODUwKSxvKGIsXCJXSElURVNNT0tFXCIsMTYxMTkyODUpLG8oYixcIkJFSUdFXCIsMTYxMTkyNjApLG8oYixcIldIRUFUXCIsMTYxMTMzMzEpLG8oYixcIlNBTkRZQlJPV05cIiwxNjAzMjg2NCksbyhiLFwiQVpVUkVcIiwxNTc5NDE3NSksbyhiLFwiSE9ORVlERVdcIiwxNTc5NDE2MCksbyhiLFwiQUxJQ0VCTFVFXCIsMTU3OTIzODMpLG8oYixcIktIQUtJXCIsMTU3ODc2NjApLG8oYixcIkxJR0hUQ09SQUxcIiwxNTc2MTUzNiksbyhiLFwiUEFMRUdPTERFTlJPRFwiLDE1NjU3MTMwKSxvKGIsXCJWSU9MRVRcIiwxNTYzMTA4NiksbyhiLFwiREFSS1NBTE1PTlwiLDE1MzA4NDEwKSxvKGIsXCJMQVZFTkRFUlwiLDE1MTMyNDEwKSxvKGIsXCJMSUdIVENZQU5cIiwxNDc0NTU5OSksbyhiLFwiQlVSTFlXT09EXCIsMTQ1OTYyMzEpLG8oYixcIlBMVU1cIiwxNDUyNDYzNyksbyhiLFwiR0FJTlNCT1JPXCIsMTQ0NzQ0NjApLG8oYixcIkNSSU1TT05cIiwxNDQyMzEwMCksbyhiLFwiUEFMRVZJT0xFVFJFRFwiLDE0MzgxMjAzKSxvKGIsXCJHT0xERU5ST0RcIiwxNDMyOTEyMCksbyhiLFwiT1JDSElEXCIsMTQzMTU3MzQpLG8oYixcIlRISVNUTEVcIiwxNDIwNDg4OCksbyhiLFwiTElHSFRHUkVZXCIsMTM4ODIzMjMpLG8oYixcIlRBTlwiLDEzODA4NzgwKSxvKGIsXCJDSE9DT0xBVEVcIiwxMzc4OTQ3MCksbyhiLFwiUEVSVVwiLDEzNDY4OTkxKSxvKGIsXCJJTkRJQU5SRURcIiwxMzQ1ODUyNCksbyhiLFwiTUVESVVNVklPTEVUUkVEXCIsMTMwNDcxNzMpLG8oYixcIlNJTFZFUlwiLDEyNjMyMjU2KSxvKGIsXCJEQVJLS0hBS0lcIiwxMjQzMzI1OSksbyhiLFwiUk9TWUJST1dOXCIsMTIzNTc1MTkpLG8oYixcIk1FRElVTU9SQ0hJRFwiLDEyMjExNjY3KSxvKGIsXCJEQVJLR09MREVOUk9EXCIsMTIwOTI5MzkpLG8oYixcIkZJUkVCUklDS1wiLDExNjc0MTQ2KSxvKGIsXCJQT1dERVJCTFVFXCIsMTE1OTE5MTApLG8oYixcIkxJR0hUU1RFRUxCTFVFXCIsMTE1ODQ3MzQpLG8oYixcIlBBTEVUVVJRVU9JU0VcIiwxMTUyOTk2NiksbyhiLFwiR1JFRU5ZRUxMT1dcIiwxMTQwMzA1NSksbyhiLFwiTElHSFRCTFVFXCIsMTEzOTMyNTQpLG8oYixcIkRBUktHUkFZXCIsMTExMTkwMTcpLG8oYixcIkJST1dOXCIsMTA4MjQyMzQpLG8oYixcIlNJRU5OQVwiLDEwNTA2Nzk3KSxvKGIsXCJEQVJLT1JDSElEXCIsMTAwNDAwMTIpLG8oYixcIlBBTEVHUkVFTlwiLDEwMDI1ODgwKSxvKGIsXCJEQVJLVklPTEVUXCIsOTY5OTUzOSksbyhiLFwiTUVESVVNUFVSUExFXCIsOTY2MjY4MyksbyhiLFwiTElHSFRHUkVFTlwiLDk0OTgyNTYpLG8oYixcIkRBUktTRUFHUkVFTlwiLDk0MTk5MTkpLG8oYixcIlNBRERMRUJST1dOXCIsOTEyNzE4NyksbyhiLFwiREFSS01BR0VOVEFcIiw5MTA5NjQzKSxvKGIsXCJEQVJLUkVEXCIsOTEwOTUwNCksbyhiLFwiQkxVRVZJT0xFVFwiLDkwNTUyMDIpLG8oYixcIkxJR0hUU0tZQkxVRVwiLDg5MDAzNDYpLG8oYixcIlNLWUJMVUVcIiw4OTAwMzMxKSxvKGIsXCJHUkFZXCIsODQyMTUwNCksbyhiLFwiT0xJVkVcIiw4NDIxMzc2KSxvKGIsXCJQVVJQTEVcIiw4Mzg4NzM2KSxvKGIsXCJNQVJPT05cIiw4Mzg4NjA4KSxvKGIsXCJBUVVBTUFSSU5FXCIsODM4ODU2NCksbyhiLFwiQ0hBUlRSRVVTRVwiLDgzODgzNTIpLG8oYixcIkxBV05HUkVFTlwiLDgxOTA5NzYpLG8oYixcIk1FRElVTVNMQVRFQkxVRVwiLDgwODc3OTApLG8oYixcIkxJR0hUU0xBVEVHUkFZXCIsNzgzMzc1MyksbyhiLFwiU0xBVEVHUkFZXCIsNzM3Mjk0NCksbyhiLFwiT0xJVkVEUkFCXCIsNzA0ODczOSksbyhiLFwiU0xBVEVCTFVFXCIsNjk3MDA2MSksbyhiLFwiRElNR1JBWVwiLDY5MDgyNjUpLG8oYixcIk1FRElVTUFRVUFNQVJJTkVcIiw2NzM3MzIyKSxvKGIsXCJDT1JORkxPV0VSQkxVRVwiLDY1OTE5ODEpLG8oYixcIkNBREVUQkxVRVwiLDYyNjY1MjgpLG8oYixcIkRBUktPTElWRUdSRUVOXCIsNTU5Nzk5OSksbyhiLFwiSU5ESUdPXCIsNDkxNTMzMCksbyhiLFwiTUVESVVNVFVSUVVPSVNFXCIsNDc3MjMwMCksbyhiLFwiREFSS1NMQVRFQkxVRVwiLDQ3MzQzNDcpLG8oYixcIlNURUVMQkxVRVwiLDQ2MjA5ODApLG8oYixcIlJPWUFMQkxVRVwiLDQyODY5NDUpLG8oYixcIlRVUlFVT0lTRVwiLDQyNTE4NTYpLG8oYixcIk1FRElVTVNFQUdSRUVOXCIsMzk3ODA5NyksbyhiLFwiTElNRUdSRUVOXCIsMzMyOTMzMCksbyhiLFwiREFSS1NMQVRFR1JBWVwiLDMxMDA0OTUpLG8oYixcIlNFQUdSRUVOXCIsMzA1MDMyNyksbyhiLFwiRk9SRVNUR1JFRU5cIiwyMjYzODQyKSxvKGIsXCJMSUdIVFNFQUdSRUVOXCIsMjE0Mjg5MCksbyhiLFwiRE9ER0VSQkxVRVwiLDIwMDMxOTkpLG8oYixcIk1JRE5JR0hUQkxVRVwiLDE2NDQ5MTIpLG8oYixcIkFRVUFcIiw2NTUzNSksbyhiLFwiQ1lBTlwiLDY1NTM1KSxvKGIsXCJTUFJJTkdHUkVFTlwiLDY1NDA3KSxvKGIsXCJMSU1FXCIsNjUyODApLG8oYixcIk1FRElVTVNQUklOR0dSRUVOXCIsNjQxNTQpLG8oYixcIkRBUktUVVJRVU9JU0VcIiw1Mjk0NSksbyhiLFwiREVFUFNLWUJMVUVcIiw0OTE1MSksbyhiLFwiREFSS0NZQU5cIiwzNTcyMyksbyhiLFwiVEVBTFwiLDMyODk2KSxvKGIsXCJHUkVFTlwiLDMyNzY4KSxvKGIsXCJEQVJLR1JFRU5cIiwyNTYwMCksbyhiLFwiQkxVRVwiLDI1NSksbyhiLFwiTUVESVVNQkxVRVwiLDIwNSksbyhiLFwiREFSS0JMVUVcIiwxMzkpLG8oYixcIk5BVllcIiwxMjgpLG8oYixcIkJMQUNLXCIsMCksYik7Y2xhc3MgaGV7c3RhdGljIHN0YXJ0KGUpe3RoaXMuX3N0YXJ0VGltZT1wZXJmb3JtYW5jZS5ub3coKSx0aGlzLl90aW1lTGFiZWw9ZX1zdGF0aWMgZW5kKCl7Y29uc29sZS5sb2codGhpcy5fdGltZUxhYmVsLHBlcmZvcm1hbmNlLm5vdygpLXRoaXMuX3N0YXJ0VGltZSl9fW8oaGUsXCJ0aW1lXCIsMCksbyhoZSxcImZyYW1lXCIsMCksbyhoZSxcImRlbHRhXCIsMCksbyhoZSxcIl9zdGFydFRpbWVcIiwwKSxvKGhlLFwiX3RpbWVMYWJlbFwiLFwiXCIpO2NsYXNzIGple2NvbnN0cnVjdG9yKGU9bnVsbCx0PW51bGwpe28odGhpcyxcInRhcmdldFwiKSxvKHRoaXMsXCJjdXJyZW50VGFyZ2V0XCIpLG8odGhpcyxcInR5cGVcIiksbyh0aGlzLFwiZGF0YVwiKSxvKHRoaXMsXCJwYXJhbVwiKSxvKHRoaXMsXCJ0aW1lXCIsMCksbyh0aGlzLFwiZGVsYXlcIiwwKSxvKHRoaXMsXCJtb3VzZUNvZGVcIiwwKSxvKHRoaXMsXCJjdHJsS2V5XCIpLG8odGhpcyxcImFsdEtleVwiKSxvKHRoaXMsXCJzaGlmdEtleVwiKSxvKHRoaXMsXCJ0YXJnZXRUb3VjaGVzXCIpLG8odGhpcyxcImNoYW5nZWRUb3VjaGVzXCIpLG8odGhpcyxcInRvdWNoZXNcIiksbyh0aGlzLFwiX3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLCExKSxvKHRoaXMsXCJ2aWV3XCIpLHRoaXMudHlwZT1lLHRoaXMuZGF0YT10fXN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpe3RoaXMuX3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbj0hMH1yZXNldCgpe3RoaXMuX3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbj0hMX1nZXQgaXNTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKXtyZXR1cm4gdGhpcy5fc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9ufX1jbGFzcyBMcntjb25zdHJ1Y3RvcihlPW51bGwsdD1udWxsLHI9bnVsbCxzPW51bGwsYT0wKXtvKHRoaXMsXCJpZFwiLDApLG8odGhpcyxcImN1cnJlbnRcIiksdGhpcy50eXBlPWUsdGhpcy50aGlzT2JqZWN0PXQsdGhpcy5oYW5kbGVyPXIsdGhpcy5wYXJhbT1zLHRoaXMucHJpb3JpdHk9YX1lcXVhbEN1cnJlbnRMaXN0ZW5lcihlLHQscixzKXtyZXR1cm4gdGhpcy50eXBlPT1lJiZ0aGlzLnRoaXNPYmplY3Q9PXImJnRoaXMuaGFuZGxlcj09dCYmdGhpcy5wYXJhbT09c31kaXNwb3NlKCl7dGhpcy5oYW5kbGVyPW51bGwsdGhpcy50aGlzT2JqZWN0PW51bGwsdGhpcy5wYXJhbT1udWxsLHRoaXMucHJpb3JpdHk9MH19byhMcixcImV2ZW50X2lkX2NvdW50XCIsMCk7Y2xhc3MgaGl7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJsaXN0ZW5lcnNcIix7fSksbyh0aGlzLFwiZGF0YVwiKX1kaXNwYXRjaEV2ZW50KGUpe3ZhciB0PXRoaXMubGlzdGVuZXJzW2UudHlwZV07aWYodCE9bnVsbCl7dD10LnNsaWNlKCk7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBzPXRbcl07aWYocy5oYW5kbGVyKXt0cnl7ZS5wYXJhbT1zLnBhcmFtLGUuY3VycmVudFRhcmdldD1zLHMudGhpc09iamVjdCxzLmhhbmRsZXIuY2FsbChzLnRoaXNPYmplY3QsZSl9Y2F0Y2h7fWlmKGUuaXNTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pYnJlYWt9fX19ZGVzdHJveSgpe2Zvcih2YXIgZSBpbiB0aGlzLmxpc3RlbmVycylmb3IodmFyIHQ9dGhpcy5saXN0ZW5lcnNbZV07dC5sZW5ndGg+MDspe3ZhciByPXRbMF07ci5oYW5kbGVyPW51bGwsci50aGlzT2JqZWN0PW51bGwsdC5zcGxpY2UoMCwxKX19YWRkRXZlbnRMaXN0ZW5lcihlLHQscixzPW51bGwsYT0wKXtpZih0aGlzLmxpc3RlbmVyc1tlXT09bnVsbCYmKHRoaXMubGlzdGVuZXJzW2VdPVtdKSwhdGhpcy5oYXNFdmVudExpc3RlbmVyKGUsdCxyKSl7dmFyIG49bmV3IExyKGUscix0LHMsYSk7cmV0dXJuIG4uaWQ9KytMci5ldmVudF9pZF9jb3VudCxuLmN1cnJlbnQ9dGhpcyx0aGlzLmxpc3RlbmVyc1tlXS5wdXNoKG4pLHRoaXMubGlzdGVuZXJzW2VdLnNvcnQoZnVuY3Rpb24obCxoKXtyZXR1cm4gaC5wcmlvcml0eS1sLnByaW9yaXR5fSksbi5pZH1mb3IobGV0IGw9MDtsPHRoaXMubGlzdGVuZXJzW2VdLmxlbmd0aDtsKyspe2xldCBoPXRoaXMubGlzdGVuZXJzW2VdW2xdO2lmKGguZXF1YWxDdXJyZW50TGlzdGVuZXIoZSx0LHIscykpcmV0dXJuIGguaWR9cmV0dXJuIDB9cmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHQscil7aWYodGhpcy5oYXNFdmVudExpc3RlbmVyKGUsdCxyKSlmb3IodmFyIHM9MDtzPHRoaXMubGlzdGVuZXJzW2VdLmxlbmd0aDtzKyspe3ZhciBhPXRoaXMubGlzdGVuZXJzW2VdW3NdO2lmKGEuZXF1YWxDdXJyZW50TGlzdGVuZXIoZSx0LHIsYS5wYXJhbSkpe2EuaGFuZGxlcj1udWxsLGEudGhpc09iamVjdD1udWxsLHRoaXMubGlzdGVuZXJzW2VdLnNwbGljZShzLDEpO3JldHVybn19fXJlbW92ZUV2ZW50TGlzdGVuZXJBdChlKXtmb3IodmFyIHQgaW4gdGhpcy5saXN0ZW5lcnMpZm9yKHZhciByPTA7cjx0aGlzLmxpc3RlbmVyc1t0XS5sZW5ndGg7cisrKXt2YXIgcz10aGlzLmxpc3RlbmVyc1t0XVtyXTtpZihzLmlkPT1lKXJldHVybiBzLmhhbmRsZXI9bnVsbCxzLnRoaXNPYmplY3Q9bnVsbCx0aGlzLmxpc3RlbmVyc1t0XS5zcGxpY2UociwxKSwhMH1yZXR1cm4hMX1yZW1vdmVBbGxFdmVudExpc3RlbmVyKGU9bnVsbCl7bGV0IHQ7aWYoZSl7aWYodGhpcy5saXN0ZW5lcnNbZV0pe2Zvcih2YXIgcj0wO3I8dGhpcy5saXN0ZW5lcnNbZV0ubGVuZ3RoO3IrKyl0PXRoaXMubGlzdGVuZXJzW2VdW3JdLHQuZGlzcG9zZSgpLHRoaXMubGlzdGVuZXJzW2VdLnNwbGljZShyLDEpO2RlbGV0ZSB0aGlzLmxpc3RlbmVyc1tlXX19ZWxzZSBmb3IobGV0IHMgaW4gdGhpcy5saXN0ZW5lcnMpe2Zvcih2YXIgcj0wO3I8dGhpcy5saXN0ZW5lcnNbc10ubGVuZ3RoO3IrKyl0PXRoaXMubGlzdGVuZXJzW3NdW3JdLHQuZGlzcG9zZSgpLHRoaXMubGlzdGVuZXJzW3NdLnNwbGljZShyLDEpO2RlbGV0ZSB0aGlzLmxpc3RlbmVyc1tzXX19Y29udGFpbkV2ZW50TGlzdGVuZXIoZSl7cmV0dXJuIHRoaXMubGlzdGVuZXJzW2VdPT1udWxsPyExOnRoaXMubGlzdGVuZXJzW2VdLmxlbmd0aD4wfWhhc0V2ZW50TGlzdGVuZXIoZSx0PW51bGwscj1udWxsKXtpZih0aGlzLmxpc3RlbmVyc1tlXT09bnVsbClyZXR1cm4hMTtpZihyJiZ0KWZvcih2YXIgcz0wO3M8dGhpcy5saXN0ZW5lcnNbZV0ubGVuZ3RoO3MrKyl7dmFyIGE9dGhpcy5saXN0ZW5lcnNbZV1bc107aWYoYS5lcXVhbEN1cnJlbnRMaXN0ZW5lcihlLHQscixhLnBhcmFtKSlyZXR1cm4hMH1yZXR1cm4hMX19Y2xhc3MgUXQgZXh0ZW5kcyBqZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwia2V5Q29kZVwiLDApfX1vKFF0LFwiS0VZX0RPV05cIixcIm9uS2V5RG93blwiKSxvKFF0LFwiS0VZX1VQXCIsXCJvbktleVVwXCIpO2NsYXNzIFIgZXh0ZW5kcyBqZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwicG9pbnRlcklkXCIpLG8odGhpcyxcInBvaW50ZXJUeXBlXCIpLG8odGhpcyxcImlzUHJpbWFyeVwiKSxvKHRoaXMsXCJwcmVzc3VyZVwiKSxvKHRoaXMsXCJtb3VzZVhcIiksbyh0aGlzLFwibW91c2VZXCIpLG8odGhpcyxcIm1vdmVtZW50WFwiKSxvKHRoaXMsXCJtb3ZlbWVudFlcIiksbyh0aGlzLFwiZGVsdGFYXCIpLG8odGhpcyxcImRlbHRhWVwiKSxvKHRoaXMsXCJkZWx0YVpcIil9cmVzZXQoKXtzdXBlci5yZXNldCgpLHRoaXMubW91c2VYPTAsdGhpcy5tb3VzZVk9MCx0aGlzLm1vdmVtZW50WD0wLHRoaXMubW92ZW1lbnRZPTAsdGhpcy5kZWx0YVg9MCx0aGlzLmRlbHRhWT0wLHRoaXMuZGVsdGFaPTB9fW8oUixcIlBJQ0tfT1ZFUlwiLFwib25QaWNrT3ZlclwiKSxvKFIsXCJQSUNLX09WRVJfR1VJXCIsXCJvblBpY2tPdmVyR1VJXCIpLG8oUixcIlBJQ0tfQ0xJQ0tcIixcIm9uUGlja0NsaWNrXCIpLG8oUixcIlBJQ0tfQ0xJQ0tfR1VJXCIsXCJvblBpY2tDbGlja0dVSVwiKSxvKFIsXCJQSUNLX09VVFwiLFwib25QaWNrT3V0XCIpLG8oUixcIlBJQ0tfT1VUX0dVSVwiLFwib25QaWNrT3V0R1VJXCIpLG8oUixcIlBJQ0tfTU9WRVwiLFwib25QaWNrTW92ZVwiKSxvKFIsXCJQSUNLX1VQXCIsXCJvblBpY2tVcFwiKSxvKFIsXCJQSUNLX1VQX0dVSVwiLFwib25QaWNrVXBHVUlcIiksbyhSLFwiUElDS19ET1dOXCIsXCJvblBpY2tEb3duXCIpLG8oUixcIlBJQ0tfRE9XTl9HVUlcIixcIm9uUGlja0Rvd25HVUlcIiksbyhSLFwiUE9JTlRFUl9SSUdIVF9DTElDS1wiLFwib25Qb2ludGVyUmlnaHRDbGlja1wiKSxvKFIsXCJQT0lOVEVSX01JRF9VUFwiLFwib25Qb2ludGVyTWlkVXBcIiksbyhSLFwiUE9JTlRFUl9NSURfRE9XTlwiLFwib25Qb2ludGVyTWlkRG93blwiKSxvKFIsXCJQT0lOVEVSX0NMSUNLXCIsXCJvblBvaW50ZXJDbGlja1wiKSxvKFIsXCJQT0lOVEVSX01PVkVcIixcIm9uUG9pbnRlck1vdmVcIiksbyhSLFwiUE9JTlRFUl9ET1dOXCIsXCJvblBvaW50ZXJEb3duXCIpLG8oUixcIlBPSU5URVJfVVBcIixcIm9uUG9pbnRlclVwXCIpLG8oUixcIlBPSU5URVJfT1VUXCIsXCJvblBvaW50ZXJPdXRcIiksbyhSLFwiUE9JTlRFUl9PVkVSXCIsXCJvblBvaW50ZXJPdmVyXCIpLG8oUixcIlBPSU5URVJfV0hFRUxcIixcIm9uUG9pbnRlcldoZWVsXCIpO2NvbnN0IFg9Y2xhc3N7Y29uc3RydWN0b3IoaT0wLGU9MCx0PTAscj0wKXtvKHRoaXMsXCJ4XCIsMCksbyh0aGlzLFwieVwiLDApLG8odGhpcyxcInpcIiwwKSxvKHRoaXMsXCJ3XCIsMSksbyh0aGlzLFwiaW5kZXhcIiwwKSx0aGlzLnNldChpLGUsdCxyKSx0aGlzLmluZGV4PVguX2luZGV4Kyt9c3RhdGljIGdldCBaRVJPKCl7cmV0dXJuIG5ldyBYKDAsMCwwKX1zdGF0aWMgZ2V0IE9ORSgpe3JldHVybiBuZXcgWCgxLDEsMSl9c3RhdGljIGdldCBMRUZUKCl7cmV0dXJuIG5ldyBYKC0xLDAsMCl9c3RhdGljIGdldCBSSUdIVCgpe3JldHVybiBuZXcgWCgxLDAsMCl9c3RhdGljIGdldCBVUCgpe3JldHVybiBuZXcgWCgwLDEsMCl9c3RhdGljIGdldCBET1dOKCl7cmV0dXJuIG5ldyBYKDAsLTEsMCl9c3RhdGljIGdldCBCQUNLKCl7cmV0dXJuIG5ldyBYKDAsMCwtMSl9c3RhdGljIGdldCBGT1JXQVJEKCl7cmV0dXJuIG5ldyBYKDAsMCwxKX1zZXQgYShpKXt0aGlzLnc9aX1zZXQgcihpKXt0aGlzLng9aX1zZXQgZyhpKXt0aGlzLnk9aX1zZXQgYihpKXt0aGlzLno9aX1nZXQgYSgpe3JldHVybiB0aGlzLnd9Z2V0IHIoKXtyZXR1cm4gdGhpcy54fWdldCBnKCl7cmV0dXJuIHRoaXMueX1nZXQgYigpe3JldHVybiB0aGlzLnp9Z2V0IGxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKX1nZXQgbGVuZ3RoU3F1YXJlZCgpe3JldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMuen1nZXQgcG9zaXRpb24oKXtyZXR1cm4gdGhpc31zdGF0aWMgZ2V0VG93UG9pbnRieURpcihpLGUsdCxyLHMpe3M9PVguWl9BWElTPyhlLng9aS55LGUueT0taS54LHQueD0taS55LHQueT1pLngsZS5zY2FsZUJ5KHIqLjUpLHQuc2NhbGVCeShyKi41KSk6cz09WC5ZX0FYSVMmJihlLng9aS56LGUuej0taS54LHQueD0taS56LHQuej1pLngsZS5zY2FsZUJ5KHIqLjUpLHQuc2NhbGVCeShyKi41KSl9c3RhdGljIHBvaW50VG9MaW5lKGksZSx0KXtsZXQgcj0wLHMsYSxuO2lmKHM9WC5kaXN0YW5jZShpLGUpLGE9WC5kaXN0YW5jZShpLHQpLG49WC5kaXN0YW5jZShlLHQpLG48PTFlLTZ8fGE8PTFlLTYpcmV0dXJuIHI9MCxyO2lmKHM8PTFlLTZ8fG4qbj49cypzK2EqYSlyZXR1cm4gcj1hLHI7aWYoYSphPj1zKnMrbipuKXJldHVybiByPW4scjtsZXQgbD0ocythK24pLzI7cmV0dXJuIHI9MipNYXRoLnNxcnQobCoobC1zKSoobC1hKSoobC1uKSkvcyxyfXN0YXRpYyBkb3QoaSxlKXtyZXR1cm4gaS54KmUueCtpLnkqZS55K2kueiplLnp9c3RhdGljIGdldFBvaW50cyhpLGUpe2xldCB0PVtdO2ZvcihsZXQgcj0wO3I8aTtyKyspe2NvbnN0IHM9bmV3IFgoTWF0aC5yYW5kb20oKSplLWUqLjUsTWF0aC5yYW5kb20oKSplLWUqLjUsTWF0aC5yYW5kb20oKSplLWUqLjUpO3QucHVzaChzKX1yZXR1cm4gdH1zdGF0aWMgZ2V0UG9pbnROdW1iZXJzKGksZSl7bGV0IHQ9W107Zm9yKGxldCByPTA7cjxpO3IrKyl0LnB1c2goTWF0aC5yYW5kb20oKSplLWUqLjUsTWF0aC5yYW5kb20oKSplLWUqLjUsTWF0aC5yYW5kb20oKSplLWUqLjUpO3JldHVybiB0fXN0YXRpYyBnZXRBbmdsZShpLGUpe2xldCB0PWkuZG90UHJvZHVjdChlKS8oaS5sZW5ndGgqZS5sZW5ndGgpO3JldHVybiBNYXRoLmFjb3ModCkqMTgwL01hdGguUEl9c3RhdGljIHNxck1hZ25pdHVkZShpKXtyZXR1cm4gaS54KmkueCtpLnkqaS55K2kueippLnp9c3RhdGljIGdldFpZQW5nbGUoaSxlKXtyZXR1cm4gdGhpcy5jYWxBbmdsZShpLnksaS56LGUueSxlLnopfXN0YXRpYyBzdWIoaSxlLHQ9bnVsbCl7cmV0dXJuIHQ9dHx8bmV3IFgsdC54PWkueC1lLngsdC55PWkueS1lLnksdC56PWkuei1lLnosdH1zdGF0aWMgYWRkKGksZSx0PW51bGwpe3JldHVybiB0PXR8fG5ldyBYLHQueD1pLngrZS54LHQueT1pLnkrZS55LHQuej1pLnorZS56LHR9c3RhdGljIHNtb290aERhbXAoaSxlLHQscixzLGEpe3JldHVybiBudWxsfXN0YXRpYyBkaXN0YW5jZShpLGUpe3ZhciB0PWkueC1lLngscj1pLnktZS55LHM9aS56LWUuejtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtyKnIrcypzKX1zdGF0aWMgc3F1YXJlRGlzdGFuY2UoaSxlKXt2YXIgdD1pLngtZS54LHI9aS55LWUueSxzPWkuei1lLno7cmV0dXJuIHQqdCtyKnIrcypzfXN0YXRpYyBkaXN0YW5jZVhaKGksZSl7dmFyIHQ9aS54LWUueCxyPTAscz1pLnotZS56O3JldHVybiBNYXRoLnNxcnQodCp0K3IqcitzKnMpfXNldChpLGUsdCxyPTEpe3JldHVybiB0aGlzLng9aSx0aGlzLnk9ZSx0aGlzLno9dCx0aGlzLnc9cix0aGlzfWFkZChpLGU9bnVsbCl7ZXx8KGU9bmV3IFgpO3ZhciB0PXRoaXMueCxyPXRoaXMueSxzPXRoaXMueixhPXRoaXMudyxuPWkueCxsPWkueSxoPWkueix1PWkudztyZXR1cm4gZS5zZXRUbyh0K24scitsLHMraCxhK3UpLGV9c3ViVmVjdG9ycyhpLGUpe3JldHVybiB0aGlzLng9aS54LWUueCx0aGlzLnk9aS55LWUueSx0aGlzLno9aS56LWUueix0aGlzfWRpc3RhbmNlVG9TcXVhcmVkKGkpe2xldCBlPXRoaXMueC1pLngsdD10aGlzLnktaS55LHI9dGhpcy56LWkuejtyZXR1cm4gZSplK3QqdCtyKnJ9YWRkWFlaVyhpLGUsdCxyLHM9bnVsbCl7c3x8KHM9bmV3IFgpO3ZhciBhPXRoaXMueCxuPXRoaXMueSxsPXRoaXMueixoPXRoaXMudyx1PWksYz1lLGY9dCxkPXI7cmV0dXJuIHMuc2V0VG8oYSt1LG4rYyxsK2YsaCtkKSxzfWNsb25lKCl7cmV0dXJuIG5ldyBYKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9Y29weUZyb20oaSl7dmFyIGU9dGhpcztyZXR1cm4gZS54PWkueCxlLnk9aS55LGUuej1pLnosZS53PWkudyxlfWRlY3JlbWVudEJ5KGkpe3RoaXMueC09aS54LHRoaXMueS09aS55LHRoaXMuei09aS56fWRvdFByb2R1Y3QoaSl7cmV0dXJuIHRoaXMueCppLngrdGhpcy55KmkueSt0aGlzLnoqaS56fWVxdWFscyhpLGU9ITEpe3JldHVybiB0aGlzLng9PWkueCYmdGhpcy55PT1pLnkmJnRoaXMuej09aS56JiYoIWV8fHRoaXMudz09aS53KX1pbmNyZW1lbnRCeShpKXt0aGlzLngrPWkueCx0aGlzLnkrPWkueSx0aGlzLnorPWkuen1kaXZpZGUoaSl7cmV0dXJuIGkgaW5zdGFuY2VvZiBYP25ldyBYKHRoaXMueC9pLngsdGhpcy55L2kueSx0aGlzLnovaS56KToodGhpcy54PXRoaXMueC9pLHRoaXMueT10aGlzLnkvaSx0aGlzLno9dGhpcy56L2ksdGhpcyl9bmVnYXRlKCl7cmV0dXJuIHRoaXMueD0tdGhpcy54LHRoaXMueT0tdGhpcy55LHRoaXMuej0tdGhpcy56LHRoaXN9bm9ybWFsaXplKGk9MSl7bGV0IGU9dGhpcztpZih0aGlzLmxlbmd0aCE9MCl7dmFyIHQ9aS90aGlzLmxlbmd0aDtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXQsZX1yZXR1cm4gZX1hcHBseVF1YXRlcm5pb24oaSl7Y29uc3QgZT10aGlzLngsdD10aGlzLnkscj10aGlzLnoscz1pLngsYT1pLnksbj1pLnosbD1pLncsaD1sKmUrYSpyLW4qdCx1PWwqdCtuKmUtcypyLGM9bCpyK3MqdC1hKmUsZj0tcyplLWEqdC1uKnI7cmV0dXJuIHRoaXMueD1oKmwrZiotcyt1Ki1uLWMqLWEsdGhpcy55PXUqbCtmKi1hK2MqLXMtaCotbix0aGlzLno9YypsK2YqLW4raCotYS11Ki1zLHRoaXN9c2NhbGVCeShpKXtyZXR1cm4gdGhpcy54Kj1pLHRoaXMueSo9aSx0aGlzLnoqPWksdGhpc31tdWwoaSl7bGV0IGU9bmV3IFg7cmV0dXJuIGUueD10aGlzLngqaSxlLnk9dGhpcy55KmksZS56PXRoaXMueippLGV9c2NhbGUoaSl7cmV0dXJuIHRoaXMueCo9aS54LHRoaXMueSo9aS55LHRoaXMueio9aS56LHRoaXN9c2NhbGVUb1JlZihpLGUpe3JldHVybiBlfHwoZT1uZXcgWCksZS54PXRoaXMueCppLGUueT10aGlzLnkqaSxlLno9dGhpcy56KmksZX1zZXRUbyhpLGUsdCxyPTEpe3RoaXMueD1pLHRoaXMueT1lLHRoaXMuej10LHRoaXMudz1yfWNvcHkoaSl7cmV0dXJuIHRoaXMueD1pLngsdGhpcy55PWkueSx0aGlzLno9aS56LHRoaXMudz1pLncsdGhpc31zdWJ0cmFjdChpLGU9bnVsbCl7cmV0dXJuIGV8fChlPW5ldyBYKSxlLnNldFRvKHRoaXMueC1pLngsdGhpcy55LWkueSx0aGlzLnotaS56KSxlfW11bHRpcGx5KGksZT1udWxsKXtlfHwoZT1uZXcgWCk7dmFyIHQ9dGhpcy54LHI9dGhpcy55LHM9dGhpcy56LGE9aS54LG49aS55LGw9aS56O3JldHVybiBlLnNldFRvKHQqYSxyKm4scypsKSxlfWRpdmlkZWQoaSxlPW51bGwpe2V8fChlPW5ldyBYKTt2YXIgdD10aGlzLngscj10aGlzLnkscz10aGlzLnosYT1pLngsbj1pLnksbD1pLno7cmV0dXJuIGUuc2V0VG8odC9hLHIvbixzL2wpLGV9ZGl2KGksZSl7ZXx8KGU9bmV3IFgpO3ZhciB0PXRoaXMueCxyPXRoaXMueSxzPXRoaXMueixhPXRoaXMudztyZXR1cm4gZS5zZXRUbyh0L2ksci9pLHMvaSxhL2kpLGV9bGVycChpLGUsdCl7dmFyIHI9aS54LHM9aS55LGE9aS56LG49aS53LGw9ZS54LGg9ZS55LHU9ZS56LGM9ZS53O3RoaXMueD0obC1yKSp0K3IsdGhpcy55PShoLXMpKnQrcyx0aGlzLno9KHUtYSkqdCthLHRoaXMudz0oYy1uKSp0K259Y2xhbXAoaSxlKXtyZXR1cm4gdGhpcy54PU1hdGgubWF4KGkueCxNYXRoLm1pbihlLngsdGhpcy54KSksdGhpcy55PU1hdGgubWF4KGkueSxNYXRoLm1pbihlLnksdGhpcy55KSksdGhpcy56PU1hdGgubWF4KGkueixNYXRoLm1pbihlLnosdGhpcy56KSksdGhpc310b1N0cmluZygpe3JldHVyblwiPFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLnorXCI+XCJ9bm9ybWFsaXplVG9XYXkyRF9YWSgpe2xldCBpPU1hdGguYWJzKHRoaXMueCksZT1NYXRoLmFicyh0aGlzLnkpO2k+ZT90aGlzLng+MD90aGlzLmNvcHlGcm9tKFguUklHSFQpOnRoaXMuY29weUZyb20oWC5MRUZUKTp0aGlzLnk+MD90aGlzLmNvcHlGcm9tKFguRE9XTik6dGhpcy5jb3B5RnJvbShYLlVQKX10b0FycmF5KCl7cmV0dXJuW3RoaXMueCx0aGlzLnksdGhpcy56XX1jb3B5VG9CeXRlcyhpKXtpLnNldEZsb2F0MzIoMCpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdGhpcy54LCEwKSxpLnNldEZsb2F0MzIoMSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdGhpcy55LCEwKSxpLnNldEZsb2F0MzIoMipGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdGhpcy56LCEwKX1jcm9zc1Byb2R1Y3QoaSxlPW51bGwpe3JldHVybiBlPWV8fG5ldyBYLGUueD10aGlzLnkqaS56LXRoaXMueippLnksZS55PXRoaXMueippLngtdGhpcy54KmkueixlLno9dGhpcy54KmkueS10aGlzLnkqaS54LGUudz0xLGV9Y3Jvc3NWZWN0b3JzKGksZSl7cmV0dXJuIGkuY3Jvc3NQcm9kdWN0KGUsdGhpcyksdGhpc31tdWx0aXBseVNjYWxhcihpKXtyZXR1cm4gdGhpcy54Kj1pLHRoaXMueSo9aSx0aGlzLnoqPWksdGhpc31zZXRGcm9tQXJyYXkoaSxlPTApe3RoaXMueD1pW2VdLHRoaXMueT1pW2UrMV0sdGhpcy56PWlbZSsyXX1kaXZpZGVTY2FsYXIoaSl7cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMS9pKX1jbGFtcExlbmd0aChpLGUpe2xldCB0PXRoaXMubGVuZ3RoO3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0fHwxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChpLE1hdGgubWluKGUsdCkpKX1zZXRTY2FsYXIoaSl7cmV0dXJuIHRoaXMueD1pLHRoaXMueT1pLHRoaXMuej1pLHRoaXN9c3RhdGljIGNhbEFuZ2xlKGksZSx0LHIpe2NvbnN0IHM9bih0LHIsaSxlKTtsZXQgYT1NYXRoLmFjb3MocykqMTgwL01hdGguUEk7cmV0dXJuIHQ8aSYmKGE9LWEpLGE7ZnVuY3Rpb24gbihoLHUsYyxmKXtsZXQgZD1baC1jLHUtZl07cmV0dXJuIGwoZCxbMCwtMV0pfWZ1bmN0aW9uIGwoaCx1KXtsZXQgYz1oWzBdKnVbMF0raFsxXSp1WzFdLGY9TWF0aC5zcXJ0KGhbMF0qaFswXStoWzFdKmhbMV0pKk1hdGguc3FydCh1WzBdKnVbMF0rdVsxXSp1WzFdKTtyZXR1cm4gYy9mfX19O2xldCBnPVg7byhnLFwiTUFYXCIsbmV3IFgoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpKSxvKGcsXCJNSU5cIixuZXcgWChOdW1iZXIuTUlOX1ZBTFVFLE51bWJlci5NSU5fVkFMVUUsTnVtYmVyLk1JTl9WQUxVRSkpLG8oZyxcIlNBRkVfTUFYXCIsbmV3IFgoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSxvKGcsXCJTQUZFX01JTlwiLG5ldyBYKE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSksbyhnLFwiWF9BWElTXCIsbmV3IFgoMSwwLDApKSxvKGcsXCJuZWdfWF9BWElTXCIsbmV3IFgoLTEsMCwwKSksbyhnLFwiWV9BWElTXCIsbmV3IFgoMCwxLDApKSxvKGcsXCJaX0FYSVNcIixuZXcgWCgwLDAsMSkpLG8oZyxcIkhFTFBfMFwiLG5ldyBYKSxvKGcsXCJIRUxQXzFcIixuZXcgWCksbyhnLFwiSEVMUF8yXCIsbmV3IFgpLG8oZyxcIkVQU0lMT05cIiwxZS01KSxvKGcsXCJIRUxQXzNcIixuZXcgWCksbyhnLFwiSEVMUF80XCIsbmV3IFgpLG8oZyxcIkhFTFBfNVwiLG5ldyBYKSxvKGcsXCJIRUxQXzZcIixuZXcgWCksbyhnLFwiX2luZGV4XCIsMCk7Y2xhc3MgU257Y29uc3RydWN0b3IoZSl7byh0aGlzLFwiY2FudmFzWFwiKSxvKHRoaXMsXCJjYW52YXNZXCIpLG8odGhpcyxcImlkZW50aWZpZXJcIiksbyh0aGlzLFwiY2xpZW50WFwiKSxvKHRoaXMsXCJjbGllbnRZXCIpLG8odGhpcyxcInBhZ2VYXCIpLG8odGhpcyxcInBhZ2VZXCIpLG8odGhpcyxcInNjcmVlblhcIiksbyh0aGlzLFwic2NyZWVuWVwiKSx0aGlzLmNhbnZhc1g9ZS5jbGllbnRYLHRoaXMuY2FudmFzWT1lLmNsaWVudFksdGhpcy5pZGVudGlmaWVyPWUuaWRlbnRpZmllcix0aGlzLmNsaWVudFg9ZS5jbGllbnRYLHRoaXMuY2xpZW50WT1lLmNsaWVudFksdGhpcy5wYWdlWD1lLnBhZ2VYLHRoaXMucGFnZVk9ZS5wYWdlWSx0aGlzLnNjcmVlblg9ZS5zY3JlZW5YLHRoaXMuc2NyZWVuWT1lLnNjcmVlbll9fWNsYXNzIEluIGV4dGVuZHMgaGl7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcImNhbnZhc1hcIiwwKSxvKHRoaXMsXCJjYW52YXNZXCIsMCksbyh0aGlzLFwiaXNNb3VzZURvd25cIiwhMSksbyh0aGlzLFwiaXNSaWdodE1vdXNlRG93blwiLCExKSxvKHRoaXMsXCJjYW52YXNcIiksbyh0aGlzLFwibW91c2VYXCIsMCksbyh0aGlzLFwibW91c2VZXCIsMCksbyh0aGlzLFwid2hlZWxEZWx0YVwiLDApLG8odGhpcyxcIm1vdXNlT2Zmc2V0WFwiLDApLG8odGhpcyxcIm1vdXNlT2Zmc2V0WVwiLDApLG8odGhpcyxcIm1vdXNlTGFzdFhcIiwwKSxvKHRoaXMsXCJtb3VzZUxhc3RZXCIsMCksbyh0aGlzLFwiX3RpbWVcIiwwKSxvKHRoaXMsXCJfa2V5U3RhdHVzXCIpLG8odGhpcyxcIl9tb3VzZVN0YXR1c1wiKSxvKHRoaXMsXCJfaXNUb3VjaFN0YXJ0XCIpLG8odGhpcyxcIl9rZXlFdmVudDNkXCIpLG8odGhpcyxcIl9wb2ludGVyRXZlbnQzRFwiKSxvKHRoaXMsXCJfd2luZG93c0V2ZW50M2RcIiksbyh0aGlzLFwiX2dwXCIsITEpLG8odGhpcyxcIl9vbGRQb3NpdGlvbjFcIixudWxsKSxvKHRoaXMsXCJfb2xkUG9zaXRpb24yXCIsbnVsbCksbyh0aGlzLFwiX2Rvd25UaW1lXCIsMCl9aW5pdENhbnZhcyhlKXt0aGlzLmNhbnZhcz1lLGUub25wb2ludGVyZG93bj1yPT57ci5idXR0b249PTA/dGhpcy5tb3VzZVN0YXJ0KHIpOnIuYnV0dG9uPT0xP3RoaXMubWlkZGxlRG93bihyKTpyLmJ1dHRvbj09MiYmdGhpcy5tb3VzZVN0YXJ0KHIpfSxlLm9ucG9pbnRlcnVwPXI9PntyLmJ1dHRvbj09MD90aGlzLm1vdXNlRW5kKHIpOnIuYnV0dG9uPT0xP3RoaXMubWlkZGxlVXAocik6ci5idXR0b249PTImJnRoaXMubW91c2VFbmQocil9LGUub25wb2ludGVyZW50ZXI9cj0+e3RoaXMubW91c2VPdmVyKHIpfSxlLm9ucG9pbnRlcm1vdmU9cj0+e3RoaXMubW91c2VNb3ZlKHIpfSxlLm9ucG9pbnRlcmNhbmNlbD1yPT57dGhpcy5tb3VzZUVuZChyKX0sZS5vbnBvaW50ZXJsZWF2ZT1yPT57dGhpcy5tb3VzZUVuZChyKX0sZS5vbnBvaW50ZXJvdXQ9cj0+e3RoaXMubW91c2VFbmQocil9LGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIscj0+e3IuYnV0dG9uPT0yPyh0aGlzLmlzUmlnaHRNb3VzZURvd249ITEsdGhpcy5yaWdodENsaWNrKHIpKTpyLmJ1dHRvbj09MCYmKHRoaXMuaXNNb3VzZURvd249ITEsdGhpcy5tb3VzZUNsaWNrKHIpKX0sITApLGUuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIscj0+dGhpcy5tb3VzZVdoZWVsKHIpLHtwYXNzaXZlOiExfSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIscj0+dGhpcy5rZXlEb3duKHIpLCEwKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIscj0+dGhpcy5rZXlVcChyKSwhMCksZS5vbmNvbnRleHRtZW51PWZ1bmN0aW9uKCl7cmV0dXJuITF9O2xldCB0PXRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RoaXMuY2FudmFzWD10LmxlZnQsdGhpcy5jYW52YXNZPXQudG9wLHRoaXMuX2tleVN0YXR1cz17fSx0aGlzLl9tb3VzZVN0YXR1cz17fSx0aGlzLl9pc1RvdWNoU3RhcnQ9ITEsdGhpcy5fa2V5RXZlbnQzZD1uZXcgUXQsdGhpcy5fcG9pbnRlckV2ZW50M0Q9bmV3IFIsdGhpcy5fd2luZG93c0V2ZW50M2Q9bmV3IGplfW9uUGluY2goZSx0LHIscyl7dGhpcy5fb2xkUG9zaXRpb24xPW5ldyBnKGUsdCksdGhpcy5fb2xkUG9zaXRpb24yPW5ldyBnKHIscyl9b25Td2lwZShlLHQpe3RoaXMubW91c2VYPWUsdGhpcy5tb3VzZVk9dCx0aGlzLl9vbGRQb3NpdGlvbjE9bnVsbCx0aGlzLl9vbGRQb3NpdGlvbjI9bnVsbCx0aGlzLl90aW1lPW5ldyBEYXRlKCkuZ2V0VGltZSgpfUdldFRhcmdldFRvdWNoZXMoZSl7Zm9yKHZhciB0PW5ldyBBcnJheSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBzPW5ldyBTbihlW3JdKTt0LnB1c2gocyl9cmV0dXJuIHR9cmlnaHRDbGljayhlKXt0aGlzLl9wb2ludGVyRXZlbnQzRC5yZXNldCgpLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlQ29kZT1lLmJ1dHRvbix0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZVg9ZS5jbGllbnRYLXRoaXMuY2FudmFzWCx0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZVk9ZS5jbGllbnRZLXRoaXMuY2FudmFzWSx0aGlzLl9wb2ludGVyRXZlbnQzRC50eXBlPVIuUE9JTlRFUl9SSUdIVF9DTElDSyx0aGlzLl9wb2ludGVyRXZlbnQzRC5jdHJsS2V5PWUuY3RybEtleSx0aGlzLl9wb2ludGVyRXZlbnQzRC5hbHRLZXk9ZS5hbHRLZXksdGhpcy5fcG9pbnRlckV2ZW50M0Quc2hpZnRLZXk9ZS5zaGlmdEtleSx0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fcG9pbnRlckV2ZW50M0QpfW1pZGRsZURvd24oZSl7dGhpcy5fcG9pbnRlckV2ZW50M0QucmVzZXQoKSx0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZUNvZGU9ZS5idXR0b24sdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VYPWUuY2xpZW50WC10aGlzLmNhbnZhc1gsdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VZPWUuY2xpZW50WS10aGlzLmNhbnZhc1ksdGhpcy5fcG9pbnRlckV2ZW50M0QudHlwZT1SLlBPSU5URVJfTUlEX0RPV04sdGhpcy5fcG9pbnRlckV2ZW50M0QuY3RybEtleT1lLmN0cmxLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QuYWx0S2V5PWUuYWx0S2V5LHRoaXMuX3BvaW50ZXJFdmVudDNELnNoaWZ0S2V5PWUuc2hpZnRLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QucG9pbnRlcklkPWUucG9pbnRlcklkLHRoaXMuX3BvaW50ZXJFdmVudDNELnBvaW50ZXJUeXBlPWUucG9pbnRlclR5cGUsdGhpcy5fcG9pbnRlckV2ZW50M0QuaXNQcmltYXJ5PWUuaXNQcmltYXJ5LHRoaXMuX3BvaW50ZXJFdmVudDNELnByZXNzdXJlPWUucHJlc3N1cmUsdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX3BvaW50ZXJFdmVudDNEKX1taWRkbGVVcChlKXt0aGlzLl9wb2ludGVyRXZlbnQzRC5yZXNldCgpLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlQ29kZT1lLmJ1dHRvbix0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZVg9ZS5jbGllbnRYLXRoaXMuY2FudmFzWCx0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZVk9ZS5jbGllbnRZLXRoaXMuY2FudmFzWSx0aGlzLl9wb2ludGVyRXZlbnQzRC50eXBlPVIuUE9JTlRFUl9NSURfVVAsdGhpcy5fcG9pbnRlckV2ZW50M0QuY3RybEtleT1lLmN0cmxLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QuYWx0S2V5PWUuYWx0S2V5LHRoaXMuX3BvaW50ZXJFdmVudDNELnNoaWZ0S2V5PWUuc2hpZnRLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QucG9pbnRlcklkPWUucG9pbnRlcklkLHRoaXMuX3BvaW50ZXJFdmVudDNELnBvaW50ZXJUeXBlPWUucG9pbnRlclR5cGUsdGhpcy5fcG9pbnRlckV2ZW50M0QuaXNQcmltYXJ5PWUuaXNQcmltYXJ5LHRoaXMuX3BvaW50ZXJFdmVudDNELnByZXNzdXJlPWUucHJlc3N1cmUsdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX3BvaW50ZXJFdmVudDNEKX1tb3VzZUNsaWNrKGUpe3RoaXMuX3BvaW50ZXJFdmVudDNELnJlc2V0KCksdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VDb2RlPWUuYnV0dG9uLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlWD1lLmNsaWVudFgtdGhpcy5jYW52YXNYLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlWT1lLmNsaWVudFktdGhpcy5jYW52YXNZLHRoaXMuX3BvaW50ZXJFdmVudDNELnR5cGU9Ui5QT0lOVEVSX0NMSUNLLHRoaXMuX3BvaW50ZXJFdmVudDNELmN0cmxLZXk9ZS5jdHJsS2V5LHRoaXMuX3BvaW50ZXJFdmVudDNELmFsdEtleT1lLmFsdEtleSx0aGlzLl9wb2ludGVyRXZlbnQzRC5zaGlmdEtleT1lLnNoaWZ0S2V5LHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9wb2ludGVyRXZlbnQzRCl9bW91c2VFbmQoZSl7dGhpcy5pc01vdXNlRG93bj0hMSx0aGlzLm1vdXNlTGFzdFg9dGhpcy5tb3VzZVgsdGhpcy5tb3VzZUxhc3RZPXRoaXMubW91c2VZLHRoaXMubW91c2VYPWUuY2xpZW50WC10aGlzLmNhbnZhc1gsdGhpcy5tb3VzZVk9ZS5jbGllbnRZLXRoaXMuY2FudmFzWSx0aGlzLm1vdXNlT2Zmc2V0WD10aGlzLm1vdXNlWC10aGlzLm1vdXNlTGFzdFgsdGhpcy5tb3VzZU9mZnNldFk9dGhpcy5tb3VzZVktdGhpcy5tb3VzZUxhc3RZLHRoaXMuX3BvaW50ZXJFdmVudDNELnJlc2V0KCksdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VDb2RlPWUuYnV0dG9uLHRoaXMuX21vdXNlU3RhdHVzW3RoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlQ29kZV09ITEsdGhpcy5fcG9pbnRlckV2ZW50M0QudHlwZT1SLlBPSU5URVJfVVAsdGhpcy5fcG9pbnRlckV2ZW50M0QuY3RybEtleT1lLmN0cmxLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QuYWx0S2V5PWUuYWx0S2V5LHRoaXMuX3BvaW50ZXJFdmVudDNELnNoaWZ0S2V5PWUuc2hpZnRLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QucG9pbnRlcklkPWUucG9pbnRlcklkLHRoaXMuX3BvaW50ZXJFdmVudDNELnBvaW50ZXJUeXBlPWUucG9pbnRlclR5cGUsdGhpcy5fcG9pbnRlckV2ZW50M0QuaXNQcmltYXJ5PWUuaXNQcmltYXJ5LHRoaXMuX3BvaW50ZXJFdmVudDNELnByZXNzdXJlPWUucHJlc3N1cmUsdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VYPXRoaXMubW91c2VYLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlWT10aGlzLm1vdXNlWSx0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fcG9pbnRlckV2ZW50M0QpfW1vdXNlU3RhcnQoZSl7dGhpcy5pc01vdXNlRG93bj0hMCx0aGlzLm1vdXNlTGFzdFg9dGhpcy5tb3VzZVgsdGhpcy5tb3VzZUxhc3RZPXRoaXMubW91c2VZLHRoaXMubW91c2VYPWUuY2xpZW50WC10aGlzLmNhbnZhc1gsdGhpcy5tb3VzZVk9ZS5jbGllbnRZLXRoaXMuY2FudmFzWSx0aGlzLm1vdXNlT2Zmc2V0WD10aGlzLm1vdXNlWC10aGlzLm1vdXNlTGFzdFgsdGhpcy5tb3VzZU9mZnNldFk9dGhpcy5tb3VzZVktdGhpcy5tb3VzZUxhc3RZLHRoaXMuX3BvaW50ZXJFdmVudDNELnJlc2V0KCksdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VDb2RlPWUuYnV0dG9uLHRoaXMuX3BvaW50ZXJFdmVudDNELmN0cmxLZXk9ZS5jdHJsS2V5LHRoaXMuX3BvaW50ZXJFdmVudDNELmFsdEtleT1lLmFsdEtleSx0aGlzLl9wb2ludGVyRXZlbnQzRC5zaGlmdEtleT1lLnNoaWZ0S2V5LHRoaXMuX3BvaW50ZXJFdmVudDNELnBvaW50ZXJJZD1lLnBvaW50ZXJJZCx0aGlzLl9wb2ludGVyRXZlbnQzRC5wb2ludGVyVHlwZT1lLnBvaW50ZXJUeXBlLHRoaXMuX3BvaW50ZXJFdmVudDNELmlzUHJpbWFyeT1lLmlzUHJpbWFyeSx0aGlzLl9wb2ludGVyRXZlbnQzRC5wcmVzc3VyZT1lLnByZXNzdXJlLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlWD10aGlzLm1vdXNlWCx0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZVk9dGhpcy5tb3VzZVksdGhpcy5fcG9pbnRlckV2ZW50M0QudHlwZT1SLlBPSU5URVJfRE9XTix0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fcG9pbnRlckV2ZW50M0QpfW1vdXNlTW92ZShlKXt0aGlzLm1vdXNlTGFzdFg9dGhpcy5tb3VzZVgsdGhpcy5tb3VzZUxhc3RZPXRoaXMubW91c2VZLHRoaXMubW91c2VYPWUuY2xpZW50WC10aGlzLmNhbnZhc1gsdGhpcy5tb3VzZVk9ZS5jbGllbnRZLXRoaXMuY2FudmFzWSx0aGlzLm1vdXNlT2Zmc2V0WD10aGlzLm1vdXNlWC10aGlzLm1vdXNlTGFzdFgsdGhpcy5tb3VzZU9mZnNldFk9dGhpcy5tb3VzZVktdGhpcy5tb3VzZUxhc3RZLHRoaXMuX3BvaW50ZXJFdmVudDNELnJlc2V0KCksdGhpcy5fcG9pbnRlckV2ZW50M0QudHlwZT1SLlBPSU5URVJfTU9WRSx0aGlzLl9wb2ludGVyRXZlbnQzRC5jdHJsS2V5PWUuY3RybEtleSx0aGlzLl9wb2ludGVyRXZlbnQzRC5hbHRLZXk9ZS5hbHRLZXksdGhpcy5fcG9pbnRlckV2ZW50M0Quc2hpZnRLZXk9ZS5zaGlmdEtleSx0aGlzLl9wb2ludGVyRXZlbnQzRC5wb2ludGVySWQ9ZS5wb2ludGVySWQsdGhpcy5fcG9pbnRlckV2ZW50M0QucG9pbnRlclR5cGU9ZS5wb2ludGVyVHlwZSx0aGlzLl9wb2ludGVyRXZlbnQzRC5pc1ByaW1hcnk9ZS5pc1ByaW1hcnksdGhpcy5fcG9pbnRlckV2ZW50M0QucHJlc3N1cmU9ZS5wcmVzc3VyZSx0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZVg9dGhpcy5tb3VzZVgsdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VZPXRoaXMubW91c2VZLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdmVtZW50WD1lLm1vdmVtZW50WCx0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3ZlbWVudFk9ZS5tb3ZlbWVudFksdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX3BvaW50ZXJFdmVudDNEKX1tb3VzZU92ZXIoZSl7dGhpcy5pc01vdXNlRG93bj0hMSx0aGlzLm1vdXNlTGFzdFg9dGhpcy5tb3VzZVgsdGhpcy5tb3VzZUxhc3RZPXRoaXMubW91c2VZLHRoaXMubW91c2VYPWUuY2xpZW50WC10aGlzLmNhbnZhc1gsdGhpcy5tb3VzZVk9ZS5jbGllbnRZLXRoaXMuY2FudmFzWSx0aGlzLm1vdXNlT2Zmc2V0WD10aGlzLm1vdXNlWC10aGlzLm1vdXNlTGFzdFgsdGhpcy5tb3VzZU9mZnNldFk9dGhpcy5tb3VzZVktdGhpcy5tb3VzZUxhc3RZLHRoaXMuX3BvaW50ZXJFdmVudDNELnJlc2V0KCksdGhpcy5fcG9pbnRlckV2ZW50M0QudHlwZT1SLlBPSU5URVJfT1ZFUix0aGlzLl9wb2ludGVyRXZlbnQzRC5jdHJsS2V5PWUuY3RybEtleSx0aGlzLl9wb2ludGVyRXZlbnQzRC5hbHRLZXk9ZS5hbHRLZXksdGhpcy5fcG9pbnRlckV2ZW50M0Quc2hpZnRLZXk9ZS5zaGlmdEtleSx0aGlzLl9wb2ludGVyRXZlbnQzRC5wb2ludGVySWQ9ZS5wb2ludGVySWQsdGhpcy5fcG9pbnRlckV2ZW50M0QucG9pbnRlclR5cGU9ZS5wb2ludGVyVHlwZSx0aGlzLl9wb2ludGVyRXZlbnQzRC5pc1ByaW1hcnk9ZS5pc1ByaW1hcnksdGhpcy5fcG9pbnRlckV2ZW50M0QucHJlc3N1cmU9ZS5wcmVzc3VyZSx0aGlzLl9wb2ludGVyRXZlbnQzRC5tb3VzZVg9dGhpcy5tb3VzZVgsdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VZPXRoaXMubW91c2VZLHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9wb2ludGVyRXZlbnQzRCl9bW91c2VXaGVlbChlKXtlLnByZXZlbnREZWZhdWx0KCksdGhpcy5tb3VzZUxhc3RYPXRoaXMubW91c2VYLHRoaXMubW91c2VMYXN0WT10aGlzLm1vdXNlWSx0aGlzLm1vdXNlWD1lLmNsaWVudFgtdGhpcy5jYW52YXNYLHRoaXMubW91c2VZPWUuY2xpZW50WS10aGlzLmNhbnZhc1ksdGhpcy5tb3VzZU9mZnNldFg9dGhpcy5tb3VzZVgtdGhpcy5tb3VzZUxhc3RYLHRoaXMubW91c2VPZmZzZXRZPXRoaXMubW91c2VZLXRoaXMubW91c2VMYXN0WSxcIndoZWVsRGVsdGFcImluIGU/KHRoaXMuX3BvaW50ZXJFdmVudDNELmRlbGF5PWUud2hlZWxEZWx0YSx0aGlzLndoZWVsRGVsdGE9ZS53aGVlbERlbHRhKTpcImRlbHRhXCJpbiBlJiYodGhpcy53aGVlbERlbHRhPWUuZGVsdGEpLHRoaXMuX3BvaW50ZXJFdmVudDNELnJlc2V0KCksdGhpcy5fcG9pbnRlckV2ZW50M0QudHlwZT1SLlBPSU5URVJfV0hFRUwsdGhpcy5fcG9pbnRlckV2ZW50M0QuY3RybEtleT1lLmN0cmxLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QuYWx0S2V5PWUuYWx0S2V5LHRoaXMuX3BvaW50ZXJFdmVudDNELnNoaWZ0S2V5PWUuc2hpZnRLZXksdGhpcy5fcG9pbnRlckV2ZW50M0QubW91c2VYPXRoaXMubW91c2VYLHRoaXMuX3BvaW50ZXJFdmVudDNELm1vdXNlWT10aGlzLm1vdXNlWSx0aGlzLl9wb2ludGVyRXZlbnQzRC5kZWx0YVg9ZS5kZWx0YVgsdGhpcy5fcG9pbnRlckV2ZW50M0QuZGVsdGFZPWUuZGVsdGFZLHRoaXMuX3BvaW50ZXJFdmVudDNELmRlbHRhWj1lLmRlbHRhWix0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fcG9pbnRlckV2ZW50M0QpfWtleURvd24oZSl7dGhpcy5fa2V5RXZlbnQzZC5yZXNldCgpLHRoaXMuX2tleUV2ZW50M2Qua2V5Q29kZT1lLmtleUNvZGUsdGhpcy5fa2V5RXZlbnQzZC5jdHJsS2V5PWUuY3RybEtleSx0aGlzLl9rZXlFdmVudDNkLmFsdEtleT1lLmFsdEtleSx0aGlzLl9rZXlFdmVudDNkLnNoaWZ0S2V5PWUuc2hpZnRLZXksdGhpcy5fa2V5U3RhdHVzW2Uua2V5Q29kZV18fCh0aGlzLl9rZXlTdGF0dXNbZS5rZXlDb2RlXT0hMCx0aGlzLl9rZXlFdmVudDNkLnR5cGU9UXQuS0VZX0RPV04sdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2tleUV2ZW50M2QpKX1rZXlVcChlKXt0aGlzLl9rZXlFdmVudDNkLnJlc2V0KCksdGhpcy5fa2V5RXZlbnQzZC5rZXlDb2RlPWUua2V5Q29kZSx0aGlzLl9rZXlTdGF0dXNbZS5rZXlDb2RlXT0hMSx0aGlzLl9rZXlFdmVudDNkLnR5cGU9UXQuS0VZX1VQLHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9rZXlFdmVudDNkKX1HZXRTbGlkZUFuZ2xlKGUsdCl7cmV0dXJuIE1hdGguYXRhbjIodCxlKSoxODAvTWF0aC5QSX1HZXRTbGlkZURpcmVjdGlvbihlLHQscixzKXt2YXIgYT10LXMsbj1yLWUsbD0wO2lmKE1hdGguYWJzKG4pPDImJk1hdGguYWJzKGEpPDIpcmV0dXJuIGw7dmFyIGg9dGhpcy5HZXRTbGlkZUFuZ2xlKG4sYSk7cmV0dXJuIGg+PS00NSYmaDw0NT9sPTQ6aD49NDUmJmg8MTM1P2w9MTpoPj0tMTM1JiZoPC00NT9sPTI6KGg+PTEzNSYmaDw9MTgwfHxoPj0tMTgwJiZoPC0xMzUpJiYobD0zKSxsfX1jb25zdCBIZj1cIjAuNi45XCI7Y2xhc3MgWWZ7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJhZGFwdGVyXCIpLG8odGhpcyxcImRldmljZVwiKSxvKHRoaXMsXCJjb250ZXh0XCIpLG8odGhpcyxcImFzcGVjdFwiKSxvKHRoaXMsXCJwcmVzZW50YXRpb25TaXplXCIsWzAsMF0pLG8odGhpcyxcInByZXNlbnRhdGlvbkZvcm1hdFwiKSxvKHRoaXMsXCJjYW52YXNcIiksbyh0aGlzLFwid2luZG93V2lkdGhcIiksbyh0aGlzLFwid2luZG93SGVpZ2h0XCIpLG8odGhpcyxcImNhbnZhc0NvbmZpZ1wiKSxvKHRoaXMsXCJzdXBlclwiLDEpLG8odGhpcyxcIl9waXhlbFJhdGlvXCIsMSl9Z2V0IHBpeGVsUmF0aW8oKXtyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpb31hc3luYyBpbml0KGUpe3ZhciB0O2lmKHRoaXMuY2FudmFzQ29uZmlnPWUsZSYmZS5jYW52YXMpe2lmKHRoaXMuY2FudmFzPWUuY2FudmFzLHRoaXMuY2FudmFzPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJubyBDYW52YXNcIik7Y29uc3QgYT10aGlzLmNhbnZhcy5jbGllbnRXaWR0aCxuPXRoaXMuY2FudmFzLmNsaWVudEhlaWdodDt0aGlzLnJlc2l6ZSh0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpLGEhPXRoaXMuY2FudmFzLmNsaWVudFdpZHRoJiYodGhpcy5jYW52YXMuc3R5bGUud2lkdGg9YStcInB4XCIpLG4hPXRoaXMuY2FudmFzLmNsaWVudEhlaWdodCYmKHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodD1uK1wicHhcIil9ZWxzZSB0aGlzLmNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLmNhbnZhcy5zdHlsZS50b3A9XCIwcHhcIix0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0PVwiMHB4XCIsdGhpcy5jYW52YXMuc3R5bGUud2lkdGg9XCIxMDAlXCIsdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleD1lPy56SW5kZXg/ZS56SW5kZXgudG9TdHJpbmcoKTpcIjBcIixkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtpZihlJiZlLmJhY2tncm91bmRJbWFnZT8odGhpcy5jYW52YXMuc3R5bGUuYmFja2dyb3VuZD1gdXJsKCR7ZS5iYWNrZ3JvdW5kSW1hZ2V9KWAsdGhpcy5jYW52YXMuc3R5bGVbXCJiYWNrZ3JvdW5kLXNpemVcIl09XCJjb3ZlclwiLHRoaXMuY2FudmFzLnN0eWxlW1wiYmFja2dyb3VuZC1wb3NpdGlvblwiXT1cImNlbnRlclwiKTp0aGlzLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kPVwidHJhbnNwYXJlbnRcIix0aGlzLmNhbnZhcy5zdHlsZVtcInRvdWNoLWFjdGlvblwiXT1cIm5vbmVcIix0aGlzLmNhbnZhcy5zdHlsZVtcIm9iamVjdC1maXRcIl09XCJjb3ZlclwiLG5hdmlnYXRvci5ncHU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR1BVIVwiKTtpZih0aGlzLmFkYXB0ZXI9YXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcih7cG93ZXJQcmVmZXJlbmNlOlwiaGlnaC1wZXJmb3JtYW5jZVwifSksdGhpcy5hZGFwdGVyPT1udWxsKXRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdQVSFcIik7aWYodGhpcy5kZXZpY2U9YXdhaXQgdGhpcy5hZGFwdGVyLnJlcXVlc3REZXZpY2Uoe3JlcXVpcmVkRmVhdHVyZXM6W1wiYmdyYTh1bm9ybS1zdG9yYWdlXCIsXCJkZXB0aC1jbGlwLWNvbnRyb2xcIixcImRlcHRoMzJmbG9hdC1zdGVuY2lsOFwiLFwiaW5kaXJlY3QtZmlyc3QtaW5zdGFuY2VcIixcInJnMTFiMTB1ZmxvYXQtcmVuZGVyYWJsZVwiXSxyZXF1aXJlZExpbWl0czp7bWluVW5pZm9ybUJ1ZmZlck9mZnNldEFsaWdubWVudDoyNTYsbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOnRoaXMuYWRhcHRlci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplfX0pLHRoaXMuZGV2aWNlPT1udWxsKXRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdQVSFcIik7dGhpcy5fcGl4ZWxSYXRpbz0oKHQ9dGhpcy5jYW52YXNDb25maWcpPT1udWxsP3ZvaWQgMDp0LmRldmljZVBpeGVsUmF0aW8pfHx3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSx0aGlzLl9waXhlbFJhdGlvPU1hdGgubWluKHRoaXMuX3BpeGVsUmF0aW8sMiksdGhpcy5kZXZpY2UubGFiZWw9XCJkZXZpY2VcIix0aGlzLnByZXNlbnRhdGlvbkZvcm1hdD1uYXZpZ2F0b3IuZ3B1LmdldFByZWZlcnJlZENhbnZhc0Zvcm1hdCgpLHRoaXMuY29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ3B1XCIpLHRoaXMuY29udGV4dC5jb25maWd1cmUoe2RldmljZTp0aGlzLmRldmljZSxmb3JtYXQ6dGhpcy5wcmVzZW50YXRpb25Gb3JtYXQsdXNhZ2U6R1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUfEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxhbHBoYU1vZGU6XCJwcmVtdWx0aXBsaWVkXCIsY29sb3JTcGFjZTpcImRpc3BsYXktcDNcIn0pLHRoaXMucmVzaXplKHRoaXMuY2FudmFzLmNsaWVudFdpZHRoLHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7bGV0IHI7cmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoKT0+e2NsZWFyVGltZW91dChyKSxyPXNldFRpbWVvdXQoKCk9Pnt0aGlzLnJlc2l6ZSh0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCx0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpfSw1MCl9KS5vYnNlcnZlKHRoaXMuY2FudmFzKSwhMH1yZXNpemUoZSx0KXt0aGlzLmNhbnZhcy53aWR0aD10aGlzLndpbmRvd1dpZHRoPU1hdGguZmxvb3IoZSp0aGlzLnBpeGVsUmF0aW8qdGhpcy5zdXBlciksdGhpcy5jYW52YXMuaGVpZ2h0PXRoaXMud2luZG93SGVpZ2h0PU1hdGguZmxvb3IodCp0aGlzLnBpeGVsUmF0aW8qdGhpcy5zdXBlciksdGhpcy5wcmVzZW50YXRpb25TaXplWzBdPXRoaXMud2luZG93V2lkdGgsdGhpcy5wcmVzZW50YXRpb25TaXplWzFdPXRoaXMud2luZG93SGVpZ2h0LHRoaXMuYXNwZWN0PXRoaXMud2luZG93V2lkdGgvdGhpcy53aW5kb3dIZWlnaHR9fWxldCBTPW5ldyBZZjtjbGFzcyBDaXt9byhDaSxcIkJsb29tX0JyaWdodG5lc3NfZnJhZ193Z3NsXCIsYFxuICAgIHN0cnVjdCB1bmlmb3JtRGF0YSB7XG4gICAgICAgIGx1bWlub3NpdHlUaHJlc2hvbGQ6IGYzMlxuICAgIH07XG5cbiAgICBzdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICBAbG9jYXRpb24oMCkgb19UYXJnZXQ6IHZlYzQ8ZjMyPlxuICAgIH07XG5cbiAgICB2YXI8cHJpdmF0ZT4gZnJhZ1VWMTogdmVjMjxmMzI+O1xuICAgIHZhcjxwcml2YXRlPiBvX1RhcmdldDogdmVjNDxmMzI+O1xuICAgIEBncm91cCgxKSBAYmluZGluZygwKVxuICAgIHZhciBiYXNlTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMSlcbiAgICB2YXIgYmFzZU1hcDogdGV4dHVyZV8yZDxmMzI+O1xuICAgIEBncm91cCgyKSBAYmluZGluZygwKVxuICAgIHZhcjx1bmlmb3JtPiBnbG9iYWw6IHVuaWZvcm1EYXRhO1xuXG4gICAgZm4gQnJpZ2h0bmVzcyhjOiB2ZWMzPGYzMj4pIC0+IGYzMiB7XG4gICAgICAgIHZhciBjMTogdmVjMzxmMzI+O1xuXG4gICAgICAgIGMxID0gYztcbiAgICAgICAgbGV0IGU4OiB2ZWMzPGYzMj4gPSBjMTtcbiAgICAgICAgbGV0IGUxMDogdmVjMzxmMzI+ID0gYzE7XG4gICAgICAgIGxldCBlMTI6IHZlYzM8ZjMyPiA9IGMxO1xuICAgICAgICBsZXQgZTE0OiB2ZWMzPGYzMj4gPSBjMTtcbiAgICAgICAgbGV0IGUxNzogdmVjMzxmMzI+ID0gYzE7XG4gICAgICAgIGxldCBlMTk6IHZlYzM8ZjMyPiA9IGMxO1xuICAgICAgICBsZXQgZTIxOiB2ZWMzPGYzMj4gPSBjMTtcbiAgICAgICAgbGV0IGUyMzogdmVjMzxmMzI+ID0gYzE7XG4gICAgICAgIGxldCBlMjU6IHZlYzM8ZjMyPiA9IGMxO1xuICAgICAgICBsZXQgZTI4OiB2ZWMzPGYzMj4gPSBjMTtcbiAgICAgICAgcmV0dXJuIG1heChtYXgoZTIzLngsIGUyNS55KSwgZTI4LnopO1xuICAgIH1cblxuICAgIGZuIG1haW4xKCkge1xuICAgICAgICB2YXIgdXY6IHZlYzI8ZjMyPjtcbiAgICAgICAgdmFyIExpbmVhckNvbG9yOiB2ZWM0PGYzMj47XG4gICAgICAgIHZhciBUb3RhbEx1bWluYW5jZTogZjMyO1xuICAgICAgICB2YXIgQmxvb21MdW1pbmFuY2U6IGYzMjtcbiAgICAgICAgdmFyIEJsb29tQW1vdW50OiBmMzI7XG5cbiAgICAgICAgbGV0IGU2OiB2ZWMyPGYzMj4gPSBmcmFnVVYxO1xuICAgICAgICB1diA9IGU2Lnh5O1xuICAgICAgICBsZXQgZTExOiB2ZWMyPGYzMj4gPSB1djtcbiAgICAgICAgdXYueSA9ICgxLjAgLSBlMTEueSk7XG4gICAgICAgIGxldCBlMTU6IHZlYzI8ZjMyPiA9IHV2O1xuICAgICAgICBsZXQgZTE2OiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCBlMTUpO1xuICAgICAgICBMaW5lYXJDb2xvciA9IGUxNjtcbiAgICAgICAgbGV0IGUxODogdmVjNDxmMzI+ID0gTGluZWFyQ29sb3I7XG4gICAgICAgIGxldCBlMjc6IHZlYzQ8ZjMyPiA9IExpbmVhckNvbG9yO1xuICAgICAgICBsZXQgZTM2OiB2ZWM0PGYzMj4gPSBMaW5lYXJDb2xvcjtcbiAgICAgICAgbGV0IGUzODogdmVjMzxmMzI+ID0gbWluKHZlYzM8ZjMyPihmMzIoNjUwMDApLCBmMzIoNjUwMDApLCBmMzIoNjUwMDApKSwgZTM2Lnh5eik7XG4gICAgICAgIExpbmVhckNvbG9yLnggPSBlMzgueDtcbiAgICAgICAgTGluZWFyQ29sb3IueSA9IGUzOC55O1xuICAgICAgICBMaW5lYXJDb2xvci56ID0gZTM4Lno7XG4gICAgICAgIGxldCBlNDU6IHZlYzQ8ZjMyPiA9IExpbmVhckNvbG9yO1xuICAgICAgICBsZXQgZTQ3OiB2ZWM0PGYzMj4gPSBMaW5lYXJDb2xvcjtcbiAgICAgICAgbGV0IGU0OTogZjMyID0gQnJpZ2h0bmVzcyhlNDcueHl6KTtcbiAgICAgICAgVG90YWxMdW1pbmFuY2UgPSBlNDk7XG4gICAgICAgIGxldCBlNTE6IGYzMiA9IFRvdGFsTHVtaW5hbmNlO1xuICAgICAgICBsZXQgZTUyOiBmMzIgPSBnbG9iYWwubHVtaW5vc2l0eVRocmVzaG9sZDtcbiAgICAgICAgQmxvb21MdW1pbmFuY2UgPSAoZTUxIC0gZTUyKTtcbiAgICAgICAgbGV0IGU1NTogZjMyID0gQmxvb21MdW1pbmFuY2U7XG4gICAgICAgIGxldCBlNjA6IGYzMiA9IEJsb29tTHVtaW5hbmNlO1xuICAgICAgICBCbG9vbUFtb3VudCA9IGNsYW1wKChlNjAgKiAwLjUpLCAwLjAsIDEuMCk7XG4gICAgICAgIGxldCBlNjc6IGYzMiA9IEJsb29tQW1vdW50O1xuICAgICAgICBsZXQgZTY4OiB2ZWM0PGYzMj4gPSBMaW5lYXJDb2xvcjtcbiAgICAgICAgb19UYXJnZXQgPSB2ZWM0PGYzMj4oKGU2NyAqIGU2OC54eXopLCBmMzIoMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQGZyYWdtZW50XG4gICAgZm4gbWFpbihAbG9jYXRpb24oMCkgZnJhZ1VWOiB2ZWMyPGYzMj4pIC0+IEZyYWdtZW50T3V0cHV0IHtcbiAgICAgICAgZnJhZ1VWMSA9IGZyYWdVVjtcbiAgICAgICAgbWFpbjEoKTtcbiAgICAgICAgbGV0IGUxMzogdmVjNDxmMzI+ID0gb19UYXJnZXQ7XG4gICAgICAgIHJldHVybiBGcmFnbWVudE91dHB1dChlMTMpO1xuICAgIH1cbiAgICBgKSxvKENpLFwiQmxvb21fYmx1cl9mcmFnX3dnc2xcIixgXG4gICAgICBzdHJ1Y3QgdW5pZm9ybURhdGEge1xuICAgICAgICAgIHRleFNpemU6IHZlYzI8ZjMyPixcbiAgICAgICAgICBoU2NhbGU6IGYzMixcbiAgICAgICAgICB2U2NhbGU6IGYzMixcbiAgICAgICAgICBob3Jpem9udGFsOiBmMzJcbiAgICAgIH07XG5cbiAgICAgIHN0cnVjdCBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgICAgQGxvY2F0aW9uKDApIG9fVGFyZ2V0OiB2ZWM0PGYzMj5cbiAgICAgIH07XG5cbiAgICAgIHZhcjxwcml2YXRlPiBmcmFnVVYxOiB2ZWMyPGYzMj47XG4gICAgICB2YXI8cHJpdmF0ZT4gb19UYXJnZXQ6IHZlYzQ8ZjMyPjtcbiAgICAgIEBncm91cCgxKSBAYmluZGluZygwKVxuICAgICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDEpXG4gICAgICB2YXIgYmFzZU1hcDogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApXG4gICAgICB2YXI8dW5pZm9ybT4gZ2xvYmFsOiB1bmlmb3JtRGF0YTtcblxuICAgICAgZm4gbWFpbjEoKSB7XG4gICAgICAgXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBidWZmZXIxOiBhcnJheTxmMzIsNT4gPSBhcnJheTxmMzIsNT4oMC4yMjcwMjY5OTg5OTY3MzQ2MiwgMC4xOTQ1OTQ2MDY3NTcxNjQsIDAuMTIxNjIxNjAxMjgzNTUwMjYsIDAuMDU0MDUzOTk5NDgzNTg1MzYsIDAuMDE2MjE2MDAwNTQyMDQ0NjQpO1xuXG4gICAgICBAZnJhZ21lbnRcbiAgICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+KSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgICAgdmFyIHJlc3VsdDogdmVjMzxmMzI+O1xuICAgICAgICAgIHZhciBpOiBpMzIgPSAxO1xuICAgICAgICAgIHZhciBqOiBpMzIgPSAxO1xuICAgICAgICAgIHZhciB1djogdmVjMjxmMzI+ID0gZnJhZ1VWO1xuICAgICAgICAgIHV2LnkgPSAoMS4wIC0gdXYueSk7XG4gICAgICAgICAgdmFyIHRleF9vZmZzZXQ6IHZlYzI8ZjMyPiA9ICh2ZWMyPGYzMj4oMS4wKSAvIHZlYzI8ZjMyPihnbG9iYWwudGV4U2l6ZSkpO1xuICAgICAgICAgIGxldCBjb2xvcjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZShiYXNlTWFwLCBiYXNlTWFwU2FtcGxlciwgdXYpO1xuICAgICAgICAgIHJlc3VsdCA9IChjb2xvci54eXogKiBidWZmZXIxWzBdKTtcbiAgICAgICAgXG4gICAgICAgICAgaWYgKChnbG9iYWwuaG9yaXpvbnRhbCA+IDEuMCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbG9vcCB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKGkgPCA1KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGMxOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCAodXYgKyB2ZWMyPGYzMj4oKCh0ZXhfb2Zmc2V0LnggKiBmMzIoaSkpICogZ2xvYmFsLmhTY2FsZSksIDAuMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCArIChjMS54eXogKiBidWZmZXIxW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlMTAxOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCAodXYgLSB2ZWMyPGYzMj4oKCh0ZXhfb2Zmc2V0LnggKiBmMzIoaSkpICogZ2xvYmFsLmhTY2FsZSksIDAuMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCArIChlMTAxLnh5eiAqIGJ1ZmZlcjFbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWluZyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGdsb2JhbC5ob3Jpem9udGFsIDwgMS4wKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsb29wIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgZTExNDogaTMyID0gajtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoZTExNCA8IDUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZTE0NDogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZShiYXNlTWFwLCBiYXNlTWFwU2FtcGxlciwgKHV2ICsgdmVjMjxmMzI+KDAuMCwgKCh0ZXhfb2Zmc2V0LnkgKiBmMzIoaikpICogZ2xvYmFsLnZTY2FsZSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKyAoZTE0NC54eXogKiBidWZmZXIxW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlMTc1OiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCAodXYgLSB2ZWMyPGYzMj4oMC4wLCAoKHRleF9vZmZzZXQueSAqIGYzMihqKSkgKiBnbG9iYWwudlNjYWxlKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCArIChlMTc1Lnh5eiAqICBidWZmZXIxW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVpbmcge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gKGogKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgb19UYXJnZXQgPSB2ZWM0PGYzMj4ocmVzdWx0LCAxLjApO1xuICAgICAgICAgIHJldHVybiBGcmFnbWVudE91dHB1dChvX1RhcmdldCk7XG4gICAgICB9XG4gICAgYCksbyhDaSxcIkJsb29tX2NvbXBvc2l0ZV9mcmFnX3dnc2xcIixgXG4gICAgI2luY2x1ZGUgXCJDb2xvclV0aWxcIlxuICAgICAgc3RydWN0IFVuaWZvcm1EYXRhIHtcbiAgICAgICAgICB0aW50Q29sb3I6dmVjNDxmMzI+LFxuICAgICAgICAgIGJsb29tU3RyZW5ndGg6IGYzMixcbiAgICAgICAgICBleHBvc3VyZTogZjMyLFxuICAgICAgICAgIGJsb29tUmFkaXVzOiBmMzIsXG4gICAgICB9O1xuXG4gICAgICBzdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICAgIEBsb2NhdGlvbigwKSBvX1RhcmdldDogdmVjNDxmMzI+XG4gICAgICB9O1xuXG4gICAgICB2YXI8cHJpdmF0ZT4gZnJhZ1VWMTogdmVjMjxmMzI+O1xuICAgICAgdmFyPHByaXZhdGU+IG9fVGFyZ2V0OiB2ZWM0PGYzMj47XG4gICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMClcbiAgICAgIHZhciBiYXNlTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgIEBncm91cCgxKSBAYmluZGluZygxKVxuICAgICAgdmFyIGJhc2VNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgIEBncm91cCgxKSBAYmluZGluZygyKVxuICAgICAgdmFyIGJsdXJUZXgxU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgIEBncm91cCgxKSBAYmluZGluZygzKVxuICAgICAgdmFyIGJsdXJUZXgxOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoNClcbiAgICAgIHZhciBibHVyVGV4MlNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoNSlcbiAgICAgIHZhciBibHVyVGV4MjogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDYpXG4gICAgICB2YXIgYmx1clRleDNTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDcpXG4gICAgICB2YXIgYmx1clRleDM6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgIEBncm91cCgxKSBAYmluZGluZyg4KVxuICAgICAgdmFyIGJsdXJUZXg0U2FtcGxlcjogc2FtcGxlcjtcbiAgICAgIEBncm91cCgxKSBAYmluZGluZyg5KVxuICAgICAgdmFyIGJsdXJUZXg0OiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMTApXG4gICAgICB2YXIgYmx1clRleDVTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDExKVxuICAgICAgdmFyIGJsdXJUZXg1OiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMClcbiAgICAgIHZhcjx1bmlmb3JtPiBnbG9iYWw6IFVuaWZvcm1EYXRhO1xuXG4gICAgICBjb25zdCBibG9vbUZhY3RvcnMgPSBhcnJheTxmMzIsNT4oMS4wLCAwLjgwMDAwMDAxMTkyMDkyOSwgMC42MDAwMDAwMjM4NDE4NTc5LCAwLjQwMDAwMDAwNTk2MDQ2NDUsIDAuMjAwMDAwMDAyOTgwMjMyMjQpO1xuICAgICBcbiAgICAgIGZuIGxlcnBCbG9vbUZhY3RvcihmYWN0b3I6IGYzMikgLT4gZjMyIHtcbiAgICAgICAgICB2YXIgbWlycm9yRmFjdG9yOiBmMzIgPSAoMS4yMDAwMDAwNDc2ODM3MTU4IC0gZmFjdG9yKTtcbiAgICAgICAgICByZXR1cm4gbWl4KGZhY3RvciwgbWlycm9yRmFjdG9yLCBnbG9iYWwuYmxvb21SYWRpdXMpO1xuICAgICAgfVxuXG4gICAgICBmbiBtYWluMSgpIHtcbiAgICBcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IFxuXG4gICAgICBAZnJhZ21lbnRcbiAgICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+KSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgICAgdmFyIHV2OiB2ZWMyPGYzMj4gPSBmcmFnVVY7XG4gICAgICAgICAgdXYueSA9ICgxLjAgLSB1di55KTtcbiAgICAgICAgXG4gICAgICAgICAgbGV0IGUzODogZjMyID0gbGVycEJsb29tRmFjdG9yKGJsb29tRmFjdG9yc1swXSk7XG4gICAgICAgICAgbGV0IGU0NjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZShibHVyVGV4MSwgYmx1clRleDFTYW1wbGVyLCB1dik7XG4gICAgICAgICAgbGV0IGU1MjogZjMyID0gbGVycEJsb29tRmFjdG9yKGJsb29tRmFjdG9yc1sxXSk7XG4gICAgICAgICAgbGV0IGU2MDogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZShibHVyVGV4MiwgYmx1clRleDJTYW1wbGVyLCB1dik7XG4gICAgICAgICAgbGV0IGU2NzogZjMyID0gbGVycEJsb29tRmFjdG9yKGJsb29tRmFjdG9yc1syXSk7XG4gICAgICAgICAgbGV0IGU3NTogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZShibHVyVGV4MywgYmx1clRleDNTYW1wbGVyLCB1dik7XG4gICAgICAgICAgbGV0IGU4MjogZjMyID0gbGVycEJsb29tRmFjdG9yKGJsb29tRmFjdG9yc1szXSk7XG4gICAgICAgICAgbGV0IGU5MDogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZShibHVyVGV4NCwgYmx1clRleDRTYW1wbGVyLCB1dik7XG4gICAgICAgICAgbGV0IGU5NzogZjMyID0gbGVycEJsb29tRmFjdG9yKGJsb29tRmFjdG9yc1s0XSk7XG4gICAgICAgICAgbGV0IGUxMDU6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUoYmx1clRleDUsIGJsdXJUZXg1U2FtcGxlciwgdXYpO1xuICAgICAgICAgIG9fVGFyZ2V0ID0gKCgoKCgoKChlMzggKiB2ZWM0PGYzMj4oYXJyYXk8dmVjMzxmMzI+LDU+KHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApLCB2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCksIHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApKVswXSwgMS4wKSkgKiBlNDYpICsgKChlNTIgKiB2ZWM0PGYzMj4oYXJyYXk8dmVjMzxmMzI+LDU+KHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApLCB2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCksIHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApKVsxXSwgMS4wKSkgKiBlNjApKSArICgoZTY3ICogdmVjNDxmMzI+KGFycmF5PHZlYzM8ZjMyPiw1Pih2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCksIHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApLCB2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCksIHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSlbMl0sIDEuMCkpICogZTc1KSkgKyAoKGU4MiAqIHZlYzQ8ZjMyPihhcnJheTx2ZWMzPGYzMj4sNT4odmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApLCB2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCksIHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApLCB2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCkpWzNdLCAxLjApKSAqIGU5MCkpICsgKChlOTcgKiB2ZWM0PGYzMj4oYXJyYXk8dmVjMzxmMzI+LDU+KHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApLCB2ZWMzPGYzMj4oMS4wLCAxLjAsIDEuMCksIHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgMS4wLCAxLjApKVs0XSwgMS4wKSkgKiBlMTA1KSkpKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgYmFzZUNvbG9yOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCB1dik7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGJsb29tTGlnaHQgPSBnbG9iYWwuYmxvb21TdHJlbmd0aCAqIG9fVGFyZ2V0LnJnYjtcblxuICAgICAgICAgIGJsb29tTGlnaHQgPSBnZXRIRFJDb2xvcihibG9vbUxpZ2h0LnJnYixnbG9iYWwuZXhwb3N1cmUpO1xuICAgICAgICAgIGJsb29tTGlnaHQgPSBMaW5lYXJUb0dhbW1hU3BhY2UoYmxvb21MaWdodCk7XG5cbiAgICAgICAgICBvX1RhcmdldCA9ICBiYXNlQ29sb3IgKyB2ZWM0PGYzMj4oYmxvb21MaWdodCAqIGdsb2JhbC50aW50Q29sb3IucmdiLCBiYXNlQ29sb3IuYSkgO1xuICAgICAgICAgIG9fVGFyZ2V0LmEgPSBtaW4ob19UYXJnZXQuYSwxLjApO1xuICAgICAgICAgIHJldHVybiBGcmFnbWVudE91dHB1dChvX1RhcmdldCk7XG4gICAgICB9XG4gIGApO2xldCBFbj1gXG4gICAgICAgIHZhcjxwcml2YXRlPiBjb2xvclNldCA6IGFycmF5PHZlYzM8ZjMyPiwgOT4gPSBhcnJheTx2ZWMzPGYzMj4sIDk+KFxuICAgICAgICAgICAgdmVjMzxmMzI+KDEuMCwgMC4wLCAwLjApLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDEuMCwgMC41LCAwLjApLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDAuNSwgMS4wLCAwLjApLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDAuMCwgMS4wLCAwLjApLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDAuMCwgMS4wLCAwLjUpLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDAuMCwgMC41LCAxLjApLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDAuMCwgMC4wLCAxLjApLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDAuNSwgMC4wLCAxLjApLFxuICAgICAgICAgICAgdmVjMzxmMzI+KDEuMCwgMC4wLCAwLjUpXG4gICAgICAgICk7XG5cbiAgICAgICAgI2lmIERFQlVHX0NMVVNURVJcbiAgICAgICAgZm4gZGVidWdDbHVzdGVyKGZyYWdDb29yZDp2ZWM0PGYzMj4pIHtcbiAgICAgICAgICAgICNpZiBVU0VfTElHSFRcbiAgICAgICAgICAgICAgdmFyIHRpbGVJRCA6IHUzMiA9IGdldENsdXN0ZXJJZDMoKS56O1xuICAgICAgICAgICAgICBsZXQgY2x1c3RlckRlYnVnID0gdmVjNDxmMzI+KGNvbG9yU2V0W3RpbGVJRCAlIDl1XSwgMS4wKTtcbiAgICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gY2x1c3RlckRlYnVnIDtcbiAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgIGZuIGRlYnVnQ2x1c3RlckJveChmcmFnQ29vcmQ6dmVjNDxmMzI+KSB7XG4gICAgICAgICAgICAjaWYgVVNFX0xJR0hUXG4gICAgICAgICAgICAgIGxldCBjbHVzdGVySWQzIDogdmVjMzx1MzI+ID0gZ2V0Q2x1c3RlcklkMygpO1xuICAgICAgICAgICAgICBsZXQgcHggPSBmMzIoY2x1c3RlcklkMy54KSAvIGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVggO1xuICAgICAgICAgICAgICBsZXQgcHkgPSBmMzIoY2x1c3RlcklkMy55KSAvIGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVkgO1xuICAgICAgICAgICAgICBsZXQgcHogPSBmMzIoY2x1c3RlcklkMy56KSAvIGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVogO1xuICAgICAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4ocHgscHkscHosIDEuMCk7XG5cbiAgICAgICAgICAgICAgdmFyIHNjcmVlblVWID0gT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ0Nvb3JkLnh5IC8gdmVjMjxmMzI+KCBnbG9iYWxVbmlmb3JtLndpbmRvd1dpZHRoICwgZ2xvYmFsVW5pZm9ybS53aW5kb3dIZWlnaHQgKTtcbiAgICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KHNjcmVlblVWLngsc2NyZWVuVVYueSwwLjAsIDEuMCk7XG5cbiAgICAgICAgICAgICAgLy8gbGV0IGNsdXN0ZXJJZCA6IHUzMiA9IGdldENsdXN0ZXJJbmRleCgpO1xuICAgICAgICAgICAgICAvLyBsZXQgY2x1c3RlciA9IGNsdXN0ZXJCdWZmZXJbY2x1c3RlcklkXTtcbiAgICAgICAgXG4gICAgICAgICAgICAgIC8vIGxldCBtaWRQb2ludCA6IHZlYzM8ZjMyPiA9IChjbHVzdGVyLm1heFBvaW50Lnh5eiAtIGNsdXN0ZXIubWluUG9pbnQueHl6KSAqIHZlYzM8ZjMyPigwLjUpO1xuICAgICAgICAgICAgICAvLyBsZXQgY2VudGVyIDogdmVjMzxmMzI+ID0gY2x1c3Rlci5taW5Qb2ludC54eXogKyBtaWRQb2ludDtcbiAgICAgICAgICAgICAgLy8gbGV0IHJhZGl1cyA6IGYzMiA9IGxlbmd0aChtaWRQb2ludCkgO1xuICAgICAgICBcbiAgICAgICAgICAgICAgLy8gbGV0IGZyYWdUb0JvdW5kc0NlbnRlciA6IHZlYzM8ZjMyPiA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLnZpZXdQb3NpdGlvbi54eXogLSBjZW50ZXI7XG4gICAgICAgICAgICAgIC8vIGxldCBkaXN0VG9Cb3VuZHNDZW50ZXIgOiBmMzIgPSBsZW5ndGgoZnJhZ1RvQm91bmRzQ2VudGVyKTtcbiAgICAgICAgICAgICAgLy8gbGV0IG5vcm1EaXN0IDogZjMyID0gZGlzdFRvQm91bmRzQ2VudGVyIC8gcmFkaXVzO1xuICAgICAgICAgICAgICAvLyBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4obm9ybURpc3Qsbm9ybURpc3Qsbm9ybURpc3QsIDEuMCk7XG4gICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICBmbiBkZWJ1Z0NsdXN0ZXJMaWdodENvdW50KGZyYWdDb29yZDp2ZWM0PGYzMj4pe1xuICAgICAgICAgICAgI2lmIFVTRV9MSUdIVFxuICAgICAgICAgICAgLy9MaWdodEluZGV4XG4gICAgICAgICAgICAgIGxldCBjbHVzdGVyIDogTGlnaHRJbmRleCA9IGdldENsdXN0ZXIoKTtcbiAgICAgICAgICAgICAgbGV0IGxpZ2h0Q291bnQgOiB1MzIgPSB1MzIoY2x1c3Rlci5jb3VudCk7XG4gICAgICAgICAgICAgIGxldCBsaWdodEZhY3RvciA6IGYzMiA9IGYzMihsaWdodENvdW50KSAvIGYzMihjbHVzdGVyc1VuaWZvcm0ubWF4TnVtTGlnaHRzUGVyQ2x1c3Rlcik7XG4gICAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9ICBtaXgodmVjNDxmMzI+KDAuMCwgMC4wLDAuMCwgMS4wKSwgdmVjNDxmMzI+KDEuMCwgMS4wLCAxLjAsIDEuMCksIHZlYzQ8ZjMyPihsaWdodEZhY3RvciwgbGlnaHRGYWN0b3IsIGxpZ2h0RmFjdG9yLCBsaWdodEZhY3RvcikpO1xuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgICNlbmRpZlxuICAgIGA7Y2xhc3MgVXJ7fW8oVXIsXCJza3lfdnNfZnJhZ193Z3NsXCIsYFxuICAgICNpbmNsdWRlIFwiV29ybGRNYXRyaXhVbmlmb3JtXCJcbiAgICAjaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuXG4gICAgc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgICBAbG9jYXRpb24oMCkgZnJhZ1VWOiB2ZWMyPGYzMj4sXG4gICAgICBAbG9jYXRpb24oMSkgdldvcmxkUG9zOiB2ZWM0PGYzMj4sXG4gICAgICBAbG9jYXRpb24oMikgdldvcmxkTm9ybWFsOiB2ZWMzPGYzMj4sXG4gICAgICBAYnVpbHRpbihwb3NpdGlvbikgbWVtYmVyOiB2ZWM0PGYzMj5cbiAgICB9O1xuXG4gICAgdmFyPHByaXZhdGU+IE9SSV9WZXJ0ZXhPdXQ6IFZlcnRleE91dHB1dCA7XG5cbiAgICBAdmVydGV4XG4gICAgZm4gbWFpbiggXG4gICAgICBAYnVpbHRpbihpbnN0YW5jZV9pbmRleCkgaW5kZXggOiB1MzIsXG4gICAgICBAbG9jYXRpb24oMCkgcG9zaXRpb246IHZlYzM8ZjMyPixcbiAgICAgIEBsb2NhdGlvbigxKSBub3JtYWw6IHZlYzM8ZjMyPixcbiAgICAgIEBsb2NhdGlvbigyKSB1djogdmVjMjxmMzI+XG4gICAgKSAtPiBWZXJ0ZXhPdXRwdXQge1xuICAgICAgT1JJX1ZlcnRleE91dC5mcmFnVVYgPSB1djtcbiAgICAgIGxldCBtb2RlbE1hdCA9IG1vZGVscy5tYXRyaXhbdTMyKGluZGV4KV07XG4gICAgICBsZXQgdm0gPSBnbG9iYWxVbmlmb3JtLnZpZXdNYXQgKiBtb2RlbE1hdDtcbiAgICAgIGxldCBub3JtYWxNYXRyaXggPSBtYXQzeDM8ZjMyPih2bVswXS54eXosdm1bMV0ueHl6LHZtWzJdLnh5eik7XG5cdCAgICBPUklfVmVydGV4T3V0LnZXb3JsZE5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XG4gICAgICBPUklfVmVydGV4T3V0LnZXb3JsZFBvcyA9IG1vZGVsTWF0ICogdmVjNDxmMzI+KHBvc2l0aW9uLnh5eiwxLjApIDtcblxuICAgICAgdmFyIGZpeFByb2pNYXQgPSBnbG9iYWxVbmlmb3JtLnByb2pNYXQgO1xuICAgICAgZml4UHJvak1hdFsyXS56ID0gMS4wIDsvLzk5OTk5LjAgLyAoOTk5OTkuMCAtIDEuMCkgO1xuICAgICAgZml4UHJvak1hdFszXS56ID0gLTEuMCA7Ly8oLTEuMCAqIDk5OTk5LjApIC8gKDk5OTk5LjAgLSAxLjApIDtcblxuICAgICAgdmFyIGZpeFZpZXdNYXQgPSBnbG9iYWxVbmlmb3JtLnZpZXdNYXQgO1xuICAgICAgZml4Vmlld01hdFszXS54ID0gMC4wIDtcbiAgICAgIGZpeFZpZXdNYXRbM10ueSA9IDAuMCA7XG4gICAgICBmaXhWaWV3TWF0WzNdLnogPSAwLjAgO1xuXG4gICAgICB2YXIgY2xpcFBvcyA9IGZpeFByb2pNYXQgKiBmaXhWaWV3TWF0ICogT1JJX1ZlcnRleE91dC52V29ybGRQb3M7XG4gICAgICBPUklfVmVydGV4T3V0Lm1lbWJlciA9IGNsaXBQb3M7XG4gICAgICByZXR1cm4gT1JJX1ZlcnRleE91dDtcbiAgICB9XG4gIGApLG8oVXIsXCJza3lfZnNfZnJhZ193Z3NsXCIsYFxuICAgICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG5cbiAgICBzdHJ1Y3QgdW5pZm9ybURhdGEge1xuICAgICAgICBleHBvc3VyZTogZjMyLFxuICAgICAgICByb3VnaG5lc3M6IGYzMlxuICAgIH07XG5cbiAgICBzdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICBAbG9jYXRpb24oMCkgb19UYXJnZXQ6IHZlYzQ8ZjMyPixcbiAgICAgICAgI2lmIFVTRV9XT1JMRFBPU1xuICAgICAgICAgIEBsb2NhdGlvbigxKSBvX1Bvc2l0aW9uOiB2ZWM0PGYzMj4sXG4gICAgICAgICNlbmRpZlxuICAgICAgICAjaWYgVVNFR0JVRkZFUlxuICAgICAgICAgIEBsb2NhdGlvbigyKSBvX05vcm1hbDogdmVjNDxmMzI+LFxuICAgICAgICAgIEBsb2NhdGlvbigzKSBvX01hdGVyaWFsOiB2ZWM0PGYzMj5cbiAgICAgICAgI2VuZGlmXG4gICAgfTtcblxuICAgIEBncm91cCgxKSBAYmluZGluZygwKVxuICAgIHZhciBiYXNlTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMSlcbiAgICB2YXIgYmFzZU1hcDogdGV4dHVyZV9jdWJlPGYzMj47XG5cbiAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMClcbiAgICB2YXI8dW5pZm9ybT4gZ2xvYmFsOiB1bmlmb3JtRGF0YTtcblxuICAgIGZuIExpbmVhclRvR2FtbWFTcGFjZShsaW5SR0I6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+IHtcbiAgICAgIHZhciBsaW5SR0IxID0gbWF4KGxpblJHQiwgdmVjMzxmMzI+KDAuMCkpO1xuICAgICAgbGluUkdCMSA9IHBvdyhsaW5SR0IxLCB2ZWMzPGYzMj4oMC40MTY2NjY2NTY3MzI1NTkyKSk7XG4gICAgICByZXR1cm4gbWF4KCgoMS4wNTQ5OTk5NDc1NDc5MTI2ICogbGluUkdCMSkgLSB2ZWMzPGYzMj4oMC4wNTQ5OTk5OTk3MDE5NzY3NzYpKSwgdmVjMzxmMzI+KDAuMCkpO1xuICAgIH1cblxuICAgIEBmcmFnbWVudFxuICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+LCBAbG9jYXRpb24oMSkgdldvcmxkUG9zOiB2ZWM0PGYzMj4sIEBsb2NhdGlvbigyKSB2V29ybGROb3JtYWw6IHZlYzM8ZjMyPikgLT4gRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICBsZXQgbWF4TGV2ZWw6IHUzMiA9IHRleHR1cmVOdW1MZXZlbHMoYmFzZU1hcCk7XG4gICAgICAgIHZhciB0ZXh0dXJlQ29sb3I6dmVjMzxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCBub3JtYWxpemUodldvcmxkUG9zLnh5eiksIGdsb2JhbC5yb3VnaG5lc3MgKiBmMzIobWF4TGV2ZWwpICkueHl6O1xuICAgICAgICAjaWYgSVNfSERSX1NLWVxuICAgICAgICB0ZXh0dXJlQ29sb3IgPSBMaW5lYXJUb0dhbW1hU3BhY2UodGV4dHVyZUNvbG9yKTtcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIGxldCBvX1RhcmdldDogdmVjNDxmMzI+ID12ZWM0PGYzMj4odGV4dHVyZUNvbG9yLCAxLjApICogZ2xvYmFsVW5pZm9ybS5za3lFeHBvc3VyZSA7XG4gICAgICAgIHZhciBub3JtYWxfcmdiYTh1bm9ybSA9ICh2V29ybGROb3JtYWwgKyAxLjApICogMC41O1xuICAgICAgICBub3JtYWxfcmdiYTh1bm9ybSA9IGNsYW1wKG5vcm1hbF9yZ2JhOHVub3JtLCB2ZWMzPGYzMj4oMC4wKSwgdmVjMzxmMzI+KDEuMCkpO1xuXG4gICAgICAgIHJldHVybiBGcmFnbWVudE91dHB1dChcbiAgICAgICAgICBvX1RhcmdldCxcbiAgICAgICAgICAjaWYgVVNFX1dPUkxEUE9TXG4gICAgICAgICAgICAgIHZXb3JsZFBvcyxcbiAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAjaWYgVVNFR0JVRkZFUlxuICAgICAgICAgICAgICB2ZWM0PGYzMj4obm9ybWFsX3JnYmE4dW5vcm0sMC4wKSxcbiAgICAgICAgICAgICAgdmVjNDxmMzI+KDAuMCwxLjAsMC4wLDAuMClcbiAgICAgICAgICAjZW5kaWZcbiAgICAgICAgKTtcbiAgICB9XG4gICAgYCk7bGV0IEJuPWBcbiNpbmNsdWRlIFwiQlJERl9mcmFnXCJcbiNpbmNsdWRlIFwiQ2x1c3RlckxpZ2h0XCJcbiNpbmNsdWRlIFwiU2hhZG93TWFwcGluZ19mcmFnXCJcblxuI2lmIFVTRV9JRVNfUFJPRklMRVxuICAjaW5jbHVkZSBcIklFU1Byb2ZpbGVzX2ZyYWdcIlxuI2VuZGlmXG5cblxuXG5jb25zdCBMVU1FTiA9IDEwLjc2NDtcblxuXG5cbmZuIGNhbGNBdHRlbnVhdGlvbiggZCA6IGYzMiAsICBmYWxsb2ZmU3RhcnQgOiBmMzIgLCAgZmFsbG9mZkVuZCA6IGYzMiktPiBmMzJcbntcbiAgICAvLyBMaW5lYXIgZmFsbG9mZi5cbiAgICByZXR1cm4gc2F0dXJhdGUoKGZhbGxvZmZFbmQtZCkgLyAoZmFsbG9mZkVuZCAtIGZhbGxvZmZTdGFydCkpO1xufVxuXG5mbiBkaXJlY3RMaWdodGluZyggYWxiZWRvOnZlYzM8ZjMyPiwgTjp2ZWMzPGYzMj4sIFY6dmVjMzxmMzI+LCAgcm91Z2huZXNzOmYzMiAsIG1ldGFsbGljOmYzMiAsIGxpZ2h0OkxpZ2h0RGF0YSAsIHNoYWRvd0JpYXM6ZjMyICkgLT4gdmVjMzxmMzI+IHtcbiAgICB2YXIgY29sb3IgPSB2ZWMzPGYzMj4oMC4wKSA7XG4gICAgI2lmIFVTRV9MSUdIVFxuICAgICAgdmFyIEwgPSAtbm9ybWFsaXplKGxpZ2h0LmRpcmVjdGlvbi54eXopIDtcbiAgICAgIGxldCBsaWdodENDID0gcG93KCBsaWdodC5saWdodENvbG9yLnJnYix2ZWMzPGYzMj4oMi4yKSk7XG4gICAgICB2YXIgbGlnaHRDb2xvciA9IGdldEhEUkNvbG9yKCBsaWdodENDLnJnYiAsIGxpZ2h0LmxpbmVhciApICA7XG4gICAgICB2YXIgYXR0ID0gbGlnaHQuaW50ZW5zaXR5IC8gTFVNRU4gO1xuICAgICAgaWYobGlnaHQuY2FzdFNoYWRvdz49MCl7XG4gICAgICAgICAgI2lmIFVTRV9TSEFET1dNQVBJTkdcbiAgICAgICAgICAgIGZvciAodmFyIGo6IGkzMiA9IDA7IGogPCA4OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZihqID09IGxpZ2h0LmNhc3RTaGFkb3cpe1xuICAgICAgICAgICAgICAgICAgYXR0ICo9IHNoYWRvd1N0cnV0LmRpcmVjdFNoYWRvd1Zpc2liaWxpdHlbal0gOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgI2VuZGlmXG4gICAgICB9XG5cbiAgICAgICNpZiBVU0VfTEFNQkVSVFxuICAgICAgICBjb2xvciA9IHZlYzM8ZjMyPigxLjAsMS4wLDEuMCkgO1xuICAgICAgI2VuZGlmIFxuXG4gICAgICAjaWYgVVNFX0JSREZcbiAgICAgICAgY29sb3IgPSBzaW1wbGVCUkRGKGFsYmVkbyxOLFYsTCxhdHQsbGlnaHRDb2xvcixyb3VnaG5lc3MsbWV0YWxsaWMpIDtcbiAgICAgICNlbmRpZiBcbiAgICAjZW5kaWYgXG4gICAgcmV0dXJuIGNvbG9yO1xufVxuXG5mbiBwb2ludExpZ2h0aW5nKCBhbGJlZG86dmVjMzxmMzI+LFdQOnZlYzM8ZjMyPiwgTjp2ZWMzPGYzMj4sIFY6dmVjMzxmMzI+LCByb3VnaG5lc3M6ZjMyICwgbWV0YWxsaWM6ZjMyICxsaWdodDpMaWdodERhdGEgKSAtPiB2ZWMzPGYzMj4ge1xuICAgIHZhciBjb2xvciA9IHZlYzM8ZjMyPigwLjApIDtcbiAgICBsZXQgbGlnaHRQb3MgPSBsaWdodC5wb3NpdGlvbi54eXo7XG4gICAgdmFyIGRpciA9IGxpZ2h0UG9zLnh5eiAtIFdQIDtcbiAgICBsZXQgZGlzdCA9IGxlbmd0aChkaXIpO1xuICAgIGlmKGRpc3QgIT0gMC4wKXtcbiAgICAgIGRpciAqPSAxLjAgLyBkaXN0IDtcbiAgICB9XG4gICAgaWYoIGFicyhkaXN0KSA8IGxpZ2h0LnJhbmdlICl7XG4gICAgICAgIHZhciBMID0gZGlyIDtcbiAgICAgICAgdmFyIGF0dGVuID0gMS4wIDtcbiAgICAgICAgYXR0ZW4gPSAxLjAgLSBzbW9vdGhzdGVwKDAuMCxsaWdodC5yYW5nZSxkaXN0KSA7XG4gICAgICAgIGF0dGVuICo9IDEuMCAvIG1heChsaWdodC5yYWRpdXMsMC4wMDEpICogbGlnaHQuaW50ZW5zaXR5IC8gTFVNRU47XG4gICAgICAgIGlmKCBsaWdodC5jYXN0U2hhZG93ID49IDAgKVxuICAgICAgICB7XG4gICAgICAgICAgICAjaWYgVVNFX1NIQURPV01BUElOR1xuICAgICAgICAgICAgICAvLyBhdHRlbiAqPSBzaGFkb3dTdHJ1dC5wb2ludFNoYWRvd3NbbGlnaHQuY2FzdFNoYWRvd10gOyBcbiAgICAgICAgICAgICAgZm9yICh2YXIgajogaTMyID0gMDsgaiA8IDg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYoaiA9PSBsaWdodC5jYXN0U2hhZG93KXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW4gKj0gc2hhZG93U3RydXQucG9pbnRTaGFkb3dzW2pdIDsgXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICNlbmRpZlxuICAgICAgICB9XG5cbiAgICAgICAgI2lmIFVTRV9JRVNfUFJPRklMRVxuICAgICAgICAgIGF0dGVuICo9IGdldExpZ2h0SUVTUHJvZmlsZUF0dChXUCxsaWdodCk7XG4gICAgICAgICNlbmRpZlxuXG4gICAgICAgIHZhciBsaWdodENvbG9yID0gbGlnaHQubGlnaHRDb2xvci5yZ2IgIDtcbiAgICAgICAgbGlnaHRDb2xvciA9IGdldEhEUkNvbG9yKGxpZ2h0Q29sb3IgLCBsaWdodC5saW5lYXIgKSAgO1xuXG4gICAgICAgICNpZiBVU0VfTEFNQkVSVFxuICAgICAgICAgIGNvbG9yID0gdmVjMzxmMzI+KDEuMCwxLjAsMS4wKSA7XG4gICAgICAgICNlbmRpZiBcblxuICAgICAgICAjaWYgVVNFX0JSREZcbiAgICAgICAgICBjb2xvciA9IChzaW1wbGVCUkRGKGFsYmVkbyxOLFYsTCxhdHRlbixsaWdodENvbG9yLHJvdWdobmVzcyxtZXRhbGxpYykpICA7XG4gICAgICAgICNlbmRpZiBcbiAgICB9IFxuICAgIHJldHVybiBjb2xvciA7XG59XG5cbmZuIGdldERpc3RhbmNlQXR0ZW4oICBsaWdodDpMaWdodERhdGEgLCBkaXN0IDogZjMyICkgLT4gZjMyIHtcbiAgcmV0dXJuIDEuMCAtIHNtb290aHN0ZXAoMC4wLGxpZ2h0LnJhbmdlLGRpc3QpIDtcbn1cblxuZm4gc3BvdExpZ2h0aW5nKCBhbGJlZG86dmVjMzxmMzI+LFdQOnZlYzM8ZjMyPiwgTjp2ZWMzPGYzMj4sIFY6dmVjMzxmMzI+LCByb3VnaG5lc3M6ZjMyICwgbWV0YWxsaWM6ZjMyICxsaWdodDpMaWdodERhdGEgKSAtPiB2ZWMzPGYzMj4ge1xuICAgIGxldCBsaWdodFBvcyA9IGxpZ2h0LnBvc2l0aW9uLnh5ejtcbiAgICB2YXIgZGlyID0gbGlnaHRQb3MueHl6IC0gV1AgO1xuICAgIGxldCBkaXN0ID0gbGVuZ3RoKGRpcikgO1xuICAgIGlmKGRpc3QgIT0gMC4wKXtcbiAgICAgIGRpciAqPSAxLjAgLyBkaXN0IDtcbiAgICB9XG4gICAgdmFyIGNvbG9yID0gdmVjMzxmMzI+KDAuMCkgO1xuICAgIGlmKCBhYnMoZGlzdCkgPCBsaWdodC5yYW5nZSAqIDIuMCApe1xuICAgICAgICB2YXIgTCA9IGRpciA7XG4gICAgICAgIGxldCB0aGV0YSA9IGRvdCgtTCwgbm9ybWFsaXplKGxpZ2h0LmRpcmVjdGlvbikpO1xuICAgICAgICBsZXQgYW5nbGUgPSBhY29zKHRoZXRhKSA7XG4gICAgICAgIHZhciBhdHRlbiA9IDEuMCA7XG4gICAgICAgIHZhciBsaWdodENvbG9yID0gbGlnaHQubGlnaHRDb2xvci5yZ2IgIDtcblxuICAgICAgICBhdHRlbiA9IDEuMCAtIHNtb290aHN0ZXAoMC4wLGxpZ2h0LnJhbmdlLGRpc3QpIDtcbiAgICAgICAgYXR0ZW4gKj0gMS4wIC8gbWF4KGxpZ2h0LnJhZGl1cywwLjEpICogbGlnaHQuaW50ZW5zaXR5IC8gTFVNRU47XG4gICAgICAgIGlmKGFuZ2xlIDwgbGlnaHQub3V0ZXJDdXRPZmYpe1xuICAgICAgICAgIGlmKGFuZ2xlID4gbGlnaHQuaW5uZXJDdXRPZmYpe1xuICAgICAgICAgICAgYXR0ZW4gKj0gMS4wIC0gc21vb3Roc3RlcChsaWdodC5pbm5lckN1dE9mZiwgbGlnaHQub3V0ZXJDdXRPZmYsIGFuZ2xlKSA7XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGF0dGVuID0gMC4wIDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBsaWdodC5jYXN0U2hhZG93ID49IDAgKVxuICAgICAgICB7XG4gICAgICAgICAgICAjaWYgVVNFX1NIQURPV01BUElOR1xuICAgICAgICAgICAgZm9yICh2YXIgajogaTMyID0gMDsgaiA8IDg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmKGogPT0gbGlnaHQuY2FzdFNoYWRvdyl7XG4gICAgICAgICAgICAgICAgICBhdHRlbiAqPSBzaGFkb3dTdHJ1dC5wb2ludFNoYWRvd3Nbal0gOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgI2VuZGlmXG4gICAgICAgIH1cblxuICAgICAgICAjaWYgVVNFX0lFU19QUk9GSUxFXG4gICAgICAgICAgICBhdHRlbiAqPSBnZXRMaWdodElFU1Byb2ZpbGVBdHQoV1AsbGlnaHQpO1xuICAgICAgICAjZW5kaWZcblxuICAgICAgICBsaWdodENvbG9yID0gZ2V0SERSQ29sb3IobGlnaHRDb2xvciAsIGxpZ2h0LmxpbmVhciApIDtcblxuICAgICAgICAjaWYgVVNFX0xBTUJFUlRcbiAgICAgICAgICBjb2xvciA9IHZlYzM8ZjMyPigxLjAsMC41LDEuMCkgO1xuICAgICAgICAjZW5kaWYgXG5cbiAgICAgICAgI2lmIFVTRV9CUkRGXG4gICAgICAgICAgY29sb3IgPSAoc2ltcGxlQlJERihhbGJlZG8sTixWLEwsYXR0ZW4sbGlnaHRDb2xvcixyb3VnaG5lc3MsbWV0YWxsaWMpKSA7XG4gICAgICAgICNlbmRpZiBcbiAgICB9XG4gICAgcmV0dXJuICBjb2xvciA7XG59XG5gLEJzPWBcbnZhcjxwcml2YXRlPiBQSTogZjMyID0gMy4xNDE1OTI2NTM1OTtcblxuXG5mbiBhcHBseVF1YXRlcm5pb24ocG9zaXRpb246dmVjMzxmMzI+LCBxOnZlYzQ8ZjMyPikgLT4gdmVjMzxmMzI+e1xuICBsZXQgeDpmMzIgPSBwb3NpdGlvbi54O1xuICBsZXQgeTpmMzIgPSBwb3NpdGlvbi55O1xuICBsZXQgejpmMzIgPSBwb3NpdGlvbi56O1xuXG4gIGxldCBxeDpmMzIgPSBxLng7XG4gIGxldCBxeTpmMzIgPSBxLnk7XG4gIGxldCBxejpmMzIgPSBxLno7XG4gIGxldCBxdzpmMzIgPSBxLnc7XG5cbiAgbGV0IGl4OmYzMiA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgbGV0IGl5OmYzMiA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgbGV0IGl6OmYzMiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgbGV0IGl3OmYzMiA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgdmFyIHJldDogdmVjMzxmMzI+O1xuICByZXQueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIHJldC55ID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgcmV0LnogPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZuIGludmVyc2UoIG06bWF0M3gzPGYzMj4pIC0+IG1hdDN4MzxmMzI+e1xuICB2YXIgYTAwID0gbVswXVswXTtcbiAgdmFyIGEwMSA9IG1bMF1bMV07XG4gIHZhciBhMDIgPSBtWzBdWzJdO1xuICB2YXIgYTEwID0gbVsxXVswXTtcbiAgdmFyIGExMSA9IG1bMV1bMV07XG4gIHZhciBhMTIgPSBtWzFdWzJdO1xuICB2YXIgYTIwID0gbVsyXVswXTtcbiAgdmFyIGEyMSA9IG1bMl1bMV07XG4gIHZhciBhMjIgPSBtWzJdWzJdO1xuXG4gIHZhciBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIHZhciBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwO1xuXG4gIHZhciBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjEgO1xuICByZXR1cm4gbWF0M3gzPGYzMj4oXG4gICAgICB2ZWMzPGYzMj4oYjAxLyBkZXQsICgtYTIyICogYTAxICsgYTAyICogYTIxKS8gZGV0LCAoYTEyICogYTAxIC0gYTAyICogYTExKS8gZGV0KSxcbiAgICAgIHZlYzM8ZjMyPihiMTEvIGRldCwgKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkvIGRldCwgKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApLyBkZXQpLFxuICAgICAgdmVjMzxmMzI+KGIyMS8gZGV0LCAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkvIGRldCwgKGExMSAqIGEwMCAtIGEwMSAqIGExMCkvIGRldClcbiAgKTtcbn1cblxuZm4gZGlyX3RvX2ZhY2VJZChwdDp2ZWMzPGYzMj4pIC0+IGkzMiB7XG4gICAgLy8qKioqIG54IHB4IG55IHB5IG56IHB6XG4gICAgdmFyIGFic194ID0gYWJzKHB0LngpO1xuICAgIHZhciBhYnNfeSA9IGFicyhwdC55KTtcbiAgICB2YXIgYWJzX3ogPSBhYnMocHQueik7XG4gICAgdmFyIGNvb3JkID0gbWF4KG1heChhYnNfeCwgYWJzX3kpLCBhYnNfeik7XG4gICAgaWYoY29vcmQgPT0gLXB0LngpeyAgcmV0dXJuIDA7fVxuICAgIGlmKGNvb3JkID09IHB0LngpIHsgcmV0dXJuIDE7fVxuXG4gICAgaWYoY29vcmQgPT0gLXB0LnkpeyAgcmV0dXJuIDI7fVxuICAgIGlmKGNvb3JkID09IHB0LnkpIHsgcmV0dXJuIDM7fVxuXG4gICAgaWYoY29vcmQgPT0gLXB0LnopIHsgcmV0dXJuIDQ7fVxuICAgIHJldHVybiA1O1xuICB9XG5cbiAgZm4gY29udmVydF94eXpfdG9fY3ViZV91dih4OmYzMiwgeTpmMzIsIHo6ZjMyICkgLT4gdmVjMjxmMzI+XG4gIHtcbiAgICB2YXIgZGlyID0gdmVjMzxmMzI+KHgsIHksIHopO1xuICAgIHZhciBhYnNYID0gYWJzKGRpci54KTtcbiAgICB2YXIgYWJzWSA9IGFicyhkaXIueSk7XG4gICAgdmFyIGFic1ogPSBhYnMoZGlyLnopO1xuXG4gICAgdmFyIGlzWFBvc2l0aXZlID0gMDtcbiAgICBpZihkaXIueCA+IDAuMCl7aXNYUG9zaXRpdmUgPSAxO31cbiAgICB2YXIgaXNZUG9zaXRpdmUgPSAwO1xuICAgIGlmKGRpci55ID4gMC4wKXtpc1lQb3NpdGl2ZSA9IDE7fVxuICAgIHZhciBpc1pQb3NpdGl2ZSA9IDA7XG4gICAgaWYoZGlyLnogPiAwLjApe2lzWlBvc2l0aXZlID0gMTt9XG5cbiAgICB2YXIgbWF4QXhpczpmMzIgPSAwLjA7XG4gICAgdmFyIHVjOmYzMiA9IDAuMDtcbiAgICB2YXIgdmM6ZjMyID0gMC4wO1xuXG4gICAgLy8gUE9TSVRJVkUgWFxuICAgIGlmIChpc1hQb3NpdGl2ZSA9PSAxICYmIGFic1ggPj0gYWJzWSAmJiBhYnNYID49IGFic1opIHtcbiAgICAgIC8vIHUgKDAgdG8gMSkgZ29lcyBmcm9tICt6IHRvIC16XG4gICAgICAvLyB2ICgwIHRvIDEpIGdvZXMgZnJvbSAteSB0byAreVxuICAgICAgbWF4QXhpcyA9IGFic1g7XG4gICAgICB1YyA9IC16O1xuICAgICAgdmMgPSB5O1xuICAgIH1cbiAgICAvLyBORUdBVElWRSBYXG4gICAgaWYgKGlzWFBvc2l0aXZlID09MCAmJiBhYnNYID49IGFic1kgJiYgYWJzWCA+PSBhYnNaKSB7XG4gICAgICAvLyB1ICgwIHRvIDEpIGdvZXMgZnJvbSAteiB0byArelxuICAgICAgLy8gdiAoMCB0byAxKSBnb2VzIGZyb20gLXkgdG8gK3lcbiAgICAgIG1heEF4aXMgPSBhYnNYO1xuICAgICAgdWMgPSB6O1xuICAgICAgdmMgPSB5O1xuICAgIH1cbiAgICAvLyBQT1NJVElWRSBZXG4gICAgaWYgKGlzWVBvc2l0aXZlPT0xICYmIGFic1kgPj0gYWJzWCAmJiBhYnNZID49IGFic1opIHtcbiAgICAgIC8vIHUgKDAgdG8gMSkgZ29lcyBmcm9tIC14IHRvICt4XG4gICAgICAvLyB2ICgwIHRvIDEpIGdvZXMgZnJvbSAreiB0byAtelxuICAgICAgbWF4QXhpcyA9IGFic1k7XG4gICAgICB1YyA9IHg7XG4gICAgICB2YyA9IC16O1xuICAgIH1cbiAgICAvLyBORUdBVElWRSBZXG4gICAgaWYgKGlzWVBvc2l0aXZlID09MCAmJiBhYnNZID49IGFic1ggJiYgYWJzWSA+PSBhYnNaKSB7XG4gICAgICAvLyB1ICgwIHRvIDEpIGdvZXMgZnJvbSAteCB0byAreFxuICAgICAgLy8gdiAoMCB0byAxKSBnb2VzIGZyb20gLXogdG8gK3pcbiAgICAgIG1heEF4aXMgPSBhYnNZO1xuICAgICAgdWMgPSB4O1xuICAgICAgdmMgPSB6O1xuICAgIH1cbiAgICAvLyBQT1NJVElWRSBaXG4gICAgaWYgKGlzWlBvc2l0aXZlID09IDEmJiBhYnNaID49IGFic1ggJiYgYWJzWiA+PSBhYnNZKSB7XG4gICAgICAvLyB1ICgwIHRvIDEpIGdvZXMgZnJvbSAteCB0byAreFxuICAgICAgLy8gdiAoMCB0byAxKSBnb2VzIGZyb20gLXkgdG8gK3lcbiAgICAgIG1heEF4aXMgPSBhYnNaO1xuICAgICAgdWMgPSB4O1xuICAgICAgdmMgPSB5O1xuICAgIH1cbiAgICAvLyBORUdBVElWRSBaXG4gICAgaWYgKGlzWlBvc2l0aXZlID09MCAmJiBhYnNaID49IGFic1ggJiYgYWJzWiA+PSBhYnNZKSB7XG4gICAgICAvLyB1ICgwIHRvIDEpIGdvZXMgZnJvbSAreCB0byAteFxuICAgICAgLy8gdiAoMCB0byAxKSBnb2VzIGZyb20gLXkgdG8gK3lcbiAgICAgIG1heEF4aXMgPSBhYnNaO1xuICAgICAgdWMgPSAteDtcbiAgICAgIHZjID0geTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHJhbmdlIGZyb20gLTEgdG8gMSB0byAwIHRvIDFcbiAgICB2YXIgdSA9IDAuNWYgKiAodWMgLyBtYXhBeGlzICsgMS4wZik7XG4gICAgdmFyIHYgPSAwLjVmICogKHZjIC8gbWF4QXhpcyArIDEuMGYpO1xuXG4gICAgcmV0dXJuIHZlYzIodSwgdik7XG4gIH1cblxuICAgIC8vIFJldHVybnMgXFx4QjExXG4gICAgZm4gc2lnbk5vdFplcm8oIHYxOnZlYzI8ZjMyPikgLT4gdmVjMjxmMzI+IHtcbiAgICAgICAgdmFyIHY6dmVjMjxmMzI+ID0gdjE7XG4gICAgICAgIGlmKHYueCA+PSAwLjApe1xuICAgICAgICAgICAgdi54ID0gMS4wO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHYueCA9IC0xLjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYodi55ID49IDAuMCl7XG4gICAgICAgICAgICB2LnkgPSAxLjA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdi55PSAtMS4wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIGZuIG9jdEVuY29kZSggdjp2ZWMzPGYzMj4gKSAtPiB2ZWMyPGYzMj4ge1xuICAgICAgICB2YXIgbDFub3JtID0gYWJzKHYueCkgKyBhYnModi55KSArIGFicyh2LnopO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdi54eSAqICgxLjAgLyBsMW5vcm0pO1xuICAgICAgICBpZiAodi56IDwgMC4wKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoMS4wIC0gYWJzKHJlc3VsdC55eCkpICogc2lnbk5vdFplcm8ocmVzdWx0Lnh5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSB1bml0IHZlY3Rvci4gQXJndW1lbnQgbyBpcyBhbiBvY3RhaGVkcmFsIHZlY3RvciBwYWNrZWQgdmlhIG9jdEVuY29kZSxvbiB0aGUgWy0xLCArMV0gc3F1YXJlKi9cbiAgICBmbiBvY3REZWNvZGUoIG86dmVjMjxmMzI+ICkgLT4gdmVjMzxmMzI+IHtcbiAgICAgICAgdmFyIHYgPSB2ZWMzPGYzMj4oby54LCBvLnksIDEuMCAtIGFicyhvLngpIC0gYWJzKG8ueSkpO1xuICAgICAgICBpZiAodi56IDwgMC4wKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gKDEuMCAtIGFicyh2Lnl4KSkgKiBzaWduTm90WmVybyh2Lnh5KTtcbiAgICAgICAgICAgIHYueCA9IHRtcC54O1xuICAgICAgICAgICAgdi55ID0gdG1wLnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSh2KTtcbiAgICB9XG5cbiAgICBmbiBMaW5lYXIwMURlcHRoKHo6ZjMyLG5lYXI6ZjMyLGZhcjpmMzIpLT4gZjMye1xuICAgICAgICBsZXQgWkJ1ZmZlclogPSAoLTEuMCsoZmFyL25lYXIpKSAvIGZhcjtcbiAgICAgICAgbGV0IFpCdWZmZXJXID0gbmVhciAvZmFyIDtcbiAgICAgICAgcmV0dXJuIDEuMCAvIChaQnVmZmVyWiAqIHogKyBaQnVmZmVyVykgO1xuICAgIH1cblxuICAgIFxuICAgIGZuIExpbmVhcml6ZURlcHRoKCBkZXB0aDpmMzIgLCBuZWFyUGxhbmU6ZjMyICwgZmFyUGxhbmU6ZjMyICktPiBmMzIge1xuICAgICAgdmFyIHogPSBkZXB0aCAqIDIuMCAtIDEuMDtcbiAgICAgIHJldHVybiAoMi4wICogbmVhclBsYW5lICogZmFyUGxhbmUpIC8gKGZhclBsYW5lICsgbmVhclBsYW5lIC0geiAqIChmYXJQbGFuZSAtIG5lYXJQbGFuZSkpO1xuICAgIH1cblxuICAgIGZuIGxvZ0RlcHRoKGRlcHRoIDogZjMyLCBmYXI6ZjMyKSAtPiBmMzIge1xuICAgICAgcmV0dXJuIGxvZzIoZGVwdGggKyAxLjApICogMi4wIC8gKGxvZyhmYXIgKyAxLjApIC8gMC42OTMxNDcxODA1NTk5NDUzKSAqIDAuNTtcbiAgICB9XG5cbiAgICBmbiBsb2cyRGVwdGgoZGVwdGggOiBmMzIsIG5lYXI6ZjMyLCBmYXI6ZjMyKSAtPiBmMzIge1xuICAgICAgbGV0IHB0ID0gcG93KChmYXIgLyBuZWFyKSxkZXB0aCk7XG4gICAgICByZXR1cm4gbmVhciAqIHB0IC8gKGZhciAvIG5lYXIpO1xuICAgIH1cblxuICAgXG5cblxuICAgIGZuIFF1YXRlcm5pb25Ub01hdHJpeChxOiB2ZWM0PGYzMj4pIC0+IG1hdDR4NDxmMzI+IHtcbiAgICAgIC8vIElmIHEgaXMgZ3VhcmFudGVlZCB0byBiZSBhIHVuaXQgcXVhdGVybmlvbiwgcyB3aWxsIGFsd2F5c1xuICAgICAgLy8gYmUgMS4gIEluIHRoYXQgY2FzZSwgdGhpcyBjYWxjdWxhdGlvbiBjYW4gYmUgb3B0aW1pemVkIG91dC5cbiAgICAgIC8vZmxvYXQgbm9ybSA9IEdldE5vcm0gKHEpO1xuICAgICAgLy9mbG9hdCBzID0gKG5vcm0gPiAwLjApID8gMi4wL25vcm0gOiAwO1xuXG4gICAgICB2YXIgcmVzdWx0OiBtYXQ0eDQ8ZjMyPjtcbiAgXG4gICAgICAvLyBQcmVjYWxjdWxhdGUgY29vcmRpbmF0ZSBwcm9kdWN0c1xuICAgICAgbGV0IHggPSBxLnggKiAyLjA7XG4gICAgICBsZXQgeSA9IHEueSAqIDIuMDtcbiAgICAgIGxldCB6ID0gcS56ICogMi4wO1xuICAgICAgbGV0IHh4ID0gcS54ICogeDtcbiAgICAgIGxldCB5eSA9IHEueSAqIHk7XG4gICAgICBsZXQgenogPSBxLnogKiB6O1xuICAgICAgbGV0IHh5ID0gcS54ICogeTtcbiAgICAgIGxldCB4eiA9IHEueCAqIHo7XG4gICAgICBsZXQgeXogPSBxLnkgKiB6O1xuICAgICAgbGV0IHd4ID0gcS53ICogeDtcbiAgICAgIGxldCB3eSA9IHEudyAqIHk7XG4gICAgICBsZXQgd3ogPSBxLncgKiB6O1xuICBcbiAgICAgIC8vIENhbGN1bGF0ZSAzeDMgbWF0cml4IGZyb20gb3J0aG9ub3JtYWwgYmFzaXNcbiAgICAgIHJlc3VsdFswXVswXSA9IDEuMCAtICh5eSArIHp6KTtcbiAgICAgIHJlc3VsdFswXVsxXSA9IHh5ICsgd3o7XG4gICAgICByZXN1bHRbMF1bMl0gPSB4eiAtIHd5O1xuICAgICAgcmVzdWx0WzBdWzNdID0gMC4wO1xuICBcbiAgICAgIHJlc3VsdFsxXVswXSA9IHh5IC0gd3o7XG4gICAgICByZXN1bHRbMV1bMV0gPSAxLjAgLSAoeHggKyB6eik7XG4gICAgICByZXN1bHRbMV1bMl0gPSB5eiArIHd4O1xuICAgICAgcmVzdWx0WzFdWzNdID0gMC4wO1xuICBcbiAgICAgIHJlc3VsdFsyXVswXSA9IHh6ICsgd3k7XG4gICAgICByZXN1bHRbMl1bMV0gPSB5eiAtIHd4O1xuICAgICAgcmVzdWx0WzJdWzJdID0gMS4wIC0gKHh4ICsgeXkpO1xuICAgICAgcmVzdWx0WzJdWzNdID0gMC4wO1xuICBcbiAgICAgIHJlc3VsdFszXVswXSA9IDAuMDtcbiAgICAgIHJlc3VsdFszXVsxXSA9IDAuMDtcbiAgICAgIHJlc3VsdFszXVsyXSA9IDAuMDtcbiAgICAgIHJlc3VsdFszXVszXSA9IDEuMDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmbiBNYWtlU2NhbGVNYXRyaXgoc2NhbGU6IHZlYzM8ZjMyPikgLT4gbWF0NHg0PGYzMj4ge1xuICAgICAgICByZXR1cm4gbWF0NHg0PGYzMj4oXG4gICAgICAgICAgc2NhbGUueCwgMC4wLCAwLjAsIDAuMCxcbiAgICAgICAgICAwLjAsIHNjYWxlLnksIDAuMCwgMC4wLFxuICAgICAgICAgIDAuMCwgMC4wLCBzY2FsZS56LCAwLjAsXG4gICAgICAgICAgMC4wLCAwLjAsIDAuMCwgMS4wLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZuIE1ha2VSb3RhdGlvbk1hdHJpeChyb3RhdGlvblF1YXRlcm5pb246IHZlYzQ8ZjMyPikgLT4gbWF0NHg0PGYzMj4ge1xuICAgICAgICByZXR1cm4gUXVhdGVybmlvblRvTWF0cml4KHJvdGF0aW9uUXVhdGVybmlvbik7XG4gICAgfVxuXG4gICAgZm4gTWFrZVRyYW5zbGF0aW9uTWF0cml4KHRyYW5zbGF0aW9uOiB2ZWMzPGYzMj4pIC0+IG1hdDR4NDxmMzI+IHtcbiAgICAgICAgcmV0dXJuIG1hdDR4NDxmMzI+KFxuICAgICAgICAgIDEuMCwgMC4wLCAwLjAsIDAuMCxcbiAgICAgICAgICAwLjAsIDEuMCwgMC4wLCAwLjAsXG4gICAgICAgICAgMC4wLCAwLjAsIDEuMCwgMC4wLFxuICAgICAgICAgIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRyYW5zbGF0aW9uLnosIDEuMCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmbiBNYWtlTWF0cml4NHg0KHNjYWxlOiB2ZWMzPGYzMj4sIHJvdGF0aW9uUXVhdGVybmlvbjogdmVjNDxmMzI+LCB0cmFuc2xhdGlvbjogdmVjMzxmMzI+KSAtPiBtYXQ0eDQ8ZjMyPiB7XG4gICAgICAgIHZhciBzY2FsZU1hdDogbWF0NHg0PGYzMj4gPSBNYWtlU2NhbGVNYXRyaXgoc2NhbGUpO1xuICAgICAgICB2YXIgcm90YXRpb25NYXQ6IG1hdDR4NDxmMzI+ID0gTWFrZVJvdGF0aW9uTWF0cml4KHJvdGF0aW9uUXVhdGVybmlvbik7XG4gICAgICAgIHZhciB0cmFuc2xhdGlvbk1hdDogbWF0NHg0PGYzMj4gPSBNYWtlVHJhbnNsYXRpb25NYXRyaXgodHJhbnNsYXRpb24pO1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25NYXQgKiBzY2FsZU1hdCAqIHJvdGF0aW9uTWF0O1xuICAgIH1cblxuICAgIGZuIG1peE1hdHJpeDR4NChhOiBtYXQ0eDQ8ZjMyPiwgYjogbWF0NHg0PGYzMj4sIHQ6ZjMyKSAtPiBtYXQ0eDQ8ZjMyPiB7XG4gICAgICByZXR1cm4gYSAqICgxLjAgLSB0KSArIGIgKiB0O1xuICAgICAgLy8gcmV0dXJuIG1hdDR4NDxmMzI+KFxuICAgICAgLy8gICBtaXgoYVswXSwgYlswXSwgdCksXG4gICAgICAvLyAgIG1peChhWzFdLCBiWzFdLCB0KSxcbiAgICAgIC8vICAgbWl4KGFbMl0sIGJbMl0sIHQpLFxuICAgICAgLy8gICBtaXgoYVszXSwgYlszXSwgdClcbiAgICAgIC8vICk7XG4gICAgfVxuXG4gICAgZm4gZGVjb2RlRGVwdGgoIGNvbG9yOnZlYzQ8ZjMyPiApIC0+IGYzMntcbiAgICAgIHZhciBkZXB0aCA9IDAuMCA7XG4gICAgICBjb25zdCBiaXRTaGlmdHMgPSB2ZWM0PGYzMj4oMS4wIC8gKDI1Ni4wICogMjU2LjAgKiAyNTYuMCksIDEuMCAvICgyNTYuMCAqIDI1Ni4wKSwgMS4wIC8gMjU2LjAsIDEuMCk7IFxuICAgICAgZGVwdGggPSBkb3QoY29sb3IsIGJpdFNoaWZ0cyk7XG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfVxuXG4gICAgZm4gZW5jb2RlRGVwdGgoIGRlcHRoOmYzMiApIC0+IHZlYzQ8ZjMyPntcbiAgICAgIGNvbnN0IGJpdFNoICA9IHZlYzQ8ZjMyPigyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjApO1xuICAgICAgY29uc3QgYml0TXNrID0gdmVjNDxmMzI+KDAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjApO1xuICAgICAgdmFyIGNvbXA6dmVjNDxmMzI+O1xuICAgICAgY29tcCAgPSBkZXB0aCAqIGJpdFNoO1xuICAgICAgY29tcCAgPSBmcmFjdChjb21wKTtcbiAgICAgIGNvbXAgLT0gY29tcC54eHl6ICogYml0TXNrO1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfVxuYCxUbj1gXG4gICAgICAgIHN0cnVjdCBNYXRlcmlhbFVuaWZvcm0ge1xuICAgICAgICAgIHRyYW5zZm9ybVVWMTp2ZWM0PGYzMj4sXG4gICAgICAgICAgdHJhbnNmb3JtVVYyOnZlYzQ8ZjMyPixcblxuICAgICAgICAgIGJhc2VDb2xvcjogdmVjNDxmMzI+LFxuICAgICAgICAgIGVtaXNzaXZlQ29sb3I6IHZlYzQ8ZjMyPixcbiAgICAgICAgICBtYXRlcmlhbEYwOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgZW52SW50ZW5zaXR5OiBmMzIsXG4gICAgICAgICAgbm9ybWFsU2NhbGU6IGYzMixcbiAgICAgICAgICByb3VnaG5lc3M6IGYzMixcbiAgICAgICAgICBtZXRhbGxpYzogZjMyLFxuICAgICAgICAgIGFvOiBmMzIsXG5cbiAgICAgICAgICByb3VnaG5lc3NfbWluOiBmMzIsXG4gICAgICAgICAgcm91Z2huZXNzX21heDogZjMyLFxuICAgICAgICAgIG1ldGFsbGljX21pbjogZjMyLFxuICAgICAgICAgIG1ldGFsbGljX21heDogZjMyLFxuICAgICAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiBmMzIsXG4gICAgICAgICAgYWxwaGFDdXRvZmY6IGYzMixcbiAgICAgICAgICBpb3I6IGYzMixcbiAgICAgICAgICBjbGVhcmNvYXRDb2xvcjogdmVjNDxmMzI+LFxuICAgICAgICAgIGNsZWFyY29hdFdlaWdodDogZjMyLFxuICAgICAgICAgIGNsZWFyY29hdEZhY3RvcjogZjMyLFxuICAgICAgICAgIGNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcjogZjMyLFxuICAgICAgICB9O1xuICAgICAgXG4gICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKVxuICAgICAgICB2YXI8dW5pZm9ybT4gbWF0ZXJpYWxVbmlmb3JtOiBNYXRlcmlhbFVuaWZvcm07XG4gICAgICBgLE1uPWBcbnN0cnVjdCBNYXRlcmlhbFVuaWZvcm0ge1xuICB0cmFuc2Zvcm1VVjE6dmVjNDxmMzI+LFxuICB0cmFuc2Zvcm1VVjI6dmVjNDxmMzI+LFxuICBiYXNlQ29sb3I6IHZlYzQ8ZjMyPixcbiAgYWxwaGFDdXRvZmY6IGYzMixcbn07XG5cbkBncm91cCgyKSBAYmluZGluZygwKVxudmFyPHVuaWZvcm0+IG1hdGVyaWFsVW5pZm9ybTogTWF0ZXJpYWxVbmlmb3JtO1xuYCxEbj1gXG4gICAgI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiXG4gICAgI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcblxuICAgIGZuIFVuTGl0KCl7XG4gICAgICAgIGxldCBhbHBoYSA9IE9SSV9TaGFkaW5nSW5wdXQuQmFzZUNvbG9yLmEgO1xuICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4oT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IucmdiICogYWxwaGEgLCBhbHBoYSkgO1xuXG4gICAgICAgICNpZiBVU0VfV09STERQT1NcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC53b3JsZFBvcyA9IHZlYzQ8ZjMyPihPUklfVmVydGV4VmFyeWluZy52V29ybGRQb3MueHl6dyk7XG4gICAgICAgICNlbmRpZlxuXG4gICAgICAgICNpZiBVU0VHQlVGRkVSXG4gICAgICAgICAgICB2YXIgbm9ybWFsX3JnYmE4dW5vcm0gPSAoT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkTm9ybWFsICsgMS4wKSAqIDAuNTtcbiAgICAgICAgICAgIG5vcm1hbF9yZ2JhOHVub3JtID0gY2xhbXAobm9ybWFsX3JnYmE4dW5vcm0sIHZlYzM8ZjMyPigwLjApLCB2ZWMzPGYzMj4oMS4wKSk7XG4gICAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQud29ybGROb3JtYWwgPSB2ZWM0PGYzMj4obm9ybWFsX3JnYmE4dW5vcm0sMS4wKTtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5tYXRlcmlhbCA9IHZlYzQ8ZjMyPigxLjAsMS4wLDAuMCwxLjApO1xuICAgICAgICAjZW5kaWZcbiAgICB9XG5cbiAgICBmbiBkZWJ1Z0ZyYWdtZW50T3V0KCl7XG5cbiAgICB9XG5gO2NsYXNzIE9ye3N0YXRpYyBncm91cEJpbmRpbmdBbmRGdW5jdGlvbnMoZSx0KXtyZXR1cm5gXG4gICAgICAgICAgICBzdHJ1Y3QgSm9pbnRzTWF0cml4IHtcbiAgICAgICAgICAgICAgICBtYXRyaXggOiBhcnJheTxtYXQ0eDQ8ZjMyPj5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEBncm91cCgke2V9KSBAYmluZGluZygke3R9KVxuICAgICAgICAgICAgdmFyPHN0b3JhZ2UsIHJlYWQ+IGpvaW50c01hdHJpeEluZGV4VGFibGU6IGFycmF5PGYzMj47XG5cbiAgICAgICAgICAgIEBncm91cCgke2V9KSBAYmluZGluZygke3QrMX0pXG4gICAgICAgICAgICB2YXI8c3RvcmFnZSwgcmVhZD4gam9pbnRzSW52ZXJzZU1hdHJpeDogSm9pbnRzTWF0cml4O1xuXG4gICAgICAgICAgICBAZ3JvdXAoJHtlfSkgQGJpbmRpbmcoJHt0KzJ9KVxuICAgICAgICAgICAgdmFyPHN0b3JhZ2UsIHJlYWQ+IGpvaW50c0luZGV4TWFwaW5nVGFibGU6IGFycmF5PGYzMj47XG5cbiAgICAgICAgICAgIGNvbnN0IE1BWF9KT0lOVF9OVU0gPSA4O1xuICAgICAgICAgICAgZm4gZ2V0U2tlbGV0b25Xb3JsZE1hdHJpeChqb2ludHM6IGFycmF5PGYzMiwgTUFYX0pPSU5UX05VTT4sIHdlaWdodHM6IGFycmF5PGYzMiwgTUFYX0pPSU5UX05VTT4sIG51bTogdTMyKSAtPiBtYXQ0eDQ8ZjMyPiB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDogbWF0NHg0PGYzMj47XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpOiB1MzIgPSAwOyBpIDwgbnVtOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpvaW50SWQgPSBpMzIoam9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpvaW50SW5kZXggPSB1MzIoam9pbnRzSW5kZXhNYXBpbmdUYWJsZVtqb2ludElkXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqb2ludE1hdHJpeEluZGV4ID0gdTMyKGpvaW50c01hdHJpeEluZGV4VGFibGVbam9pbnRJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgam9pbnQgPSBtb2RlbHMubWF0cml4W2pvaW50TWF0cml4SW5kZXhdICogam9pbnRzSW52ZXJzZU1hdHJpeC5tYXRyaXhbam9pbnRJZF0gKiB3ZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gam9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuIGdldFNrZWxldG9uV29ybGRNYXRyaXhfNChqb2ludHM6IHZlYzQ8ZjMyPiwgd2VpZ2h0czogdmVjNDxmMzI+KSAtPiBtYXQ0eDQ8ZjMyPiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNrZWxldG9uV29ybGRNYXRyaXgoYXJyYXk8ZjMyLCBNQVhfSk9JTlRfTlVNPihcbiAgICAgICAgICAgICAgICAgICAgam9pbnRzLngsIGpvaW50cy55LCBqb2ludHMueiwgam9pbnRzLncsXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgKSwgYXJyYXk8ZjMyLCBNQVhfSk9JTlRfTlVNPihcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0cy54LCB3ZWlnaHRzLnksIHdlaWdodHMueiwgd2VpZ2h0cy53LFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICksIDQpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgZm4gZ2V0U2tlbGV0b25Xb3JsZE1hdHJpeF84KGpvaW50czA6IHZlYzQ8ZjMyPiwgd2VpZ2h0czA6IHZlYzQ8ZjMyPiwgam9pbnRzMTogdmVjNDxmMzI+LCB3ZWlnaHRzMTogdmVjNDxmMzI+KSAtPiBtYXQ0eDQ8ZjMyPiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNrZWxldG9uV29ybGRNYXRyaXgoYXJyYXk8ZjMyLCBNQVhfSk9JTlRfTlVNPihcbiAgICAgICAgICAgICAgICAgICAgam9pbnRzMC54LCBqb2ludHMwLnksIGpvaW50czAueiwgam9pbnRzMC53LFxuICAgICAgICAgICAgICAgICAgICBqb2ludHMxLngsIGpvaW50czEueSwgam9pbnRzMS56LCBqb2ludHMxLncsXG4gICAgICAgICAgICAgICAgKSwgYXJyYXk8ZjMyLCBNQVhfSk9JTlRfTlVNPihcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0czAueCwgd2VpZ2h0czAueSwgd2VpZ2h0czAueiwgd2VpZ2h0czAudyxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0czEueCwgd2VpZ2h0czEueSwgd2VpZ2h0czEueiwgd2VpZ2h0czEudyxcbiAgICAgICAgICAgICAgICApLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH19Y2xhc3MgTGV7c3RhdGljIGdldE1vcnBoVGFyZ2V0U2hhZGVyQmluZGluZyhlLHQpe3JldHVybmBcbiAgICAgICAgICAgIGZuIGJsZW5kTW9ycGhUYXJnZXRQb3NpdGlvbih2ZXJ0ZXhJRDppMzIsIHBvc0luOnZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+e1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQ6aTMyID0gdmVydGV4SUQgKiAzO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBwb3NJbiAqIG1vcnBoVGFyZ2V0Q29uZmlnLm1vcnBoQmFzZUluZmx1ZW5jZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gdmVjMzxmMzI+KG1vcnBoVGFyZ2V0T3BQb3NpdGlvbnNbb2Zmc2V0XSwgbW9ycGhUYXJnZXRPcFBvc2l0aW9uc1tvZmZzZXQgKyAxXSwgbW9ycGhUYXJnZXRPcFBvc2l0aW9uc1tvZmZzZXQgKyAyXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgI2lmIFVTRV9NT1JQSE5PUk1BTFNcbiAgICAgICAgICAgICAgICBmbiBibGVuZE1vcnBoVGFyZ2V0Tm9ybWFsKHZlcnRleElEOmkzMiwgbm9ybWFsSW46dmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj57XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQ6aTMyID0gdmVydGV4SUQgKiAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gbm9ybWFsSW4gKiBtb3JwaFRhcmdldENvbmZpZy5tb3JwaEJhc2VJbmZsdWVuY2U7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbCArPSB2ZWMzPGYzMj4obW9ycGhUYXJnZXRPcE5vcm1hbHNbb2Zmc2V0XSwgbW9ycGhUYXJnZXRPcE5vcm1hbHNbb2Zmc2V0ICsgMV0sIG1vcnBoVGFyZ2V0T3BOb3JtYWxzW29mZnNldCArIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgc3RydWN0IE1vcnBoVGFyZ2V0Q29uZmlnRGF0YSB7XG4gICAgICAgICAgICAgICAgbW9ycGhCYXNlSW5mbHVlbmNlOmYzMixcbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldENvdW50OmYzMixcbiAgICAgICAgICAgICAgICB0b3RhbFZlcnRleENvdW50OmYzMixcbiAgICAgICAgICAgICAgICBjb21wdXRlV29ya0dyb3VwWFk6ZjMyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGdyb3VwKCR7ZX0pIEBiaW5kaW5nKCR7dH0pXG4gICAgICAgICAgICB2YXI8dW5pZm9ybT4gbW9ycGhUYXJnZXRDb25maWc6IE1vcnBoVGFyZ2V0Q29uZmlnRGF0YTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGdyb3VwKCR7ZX0pIEBiaW5kaW5nKCR7dCsxfSlcbiAgICAgICAgICAgIHZhcjxzdG9yYWdlLHJlYWQ+IG1vcnBoVGFyZ2V0T3BQb3NpdGlvbnM6IGFycmF5PGYzMj47XG5cbiAgICAgICAgICAgICNpZiBVU0VfTU9SUEhOT1JNQUxTXG4gICAgICAgICAgICAgICAgQGdyb3VwKCR7ZX0pIEBiaW5kaW5nKCR7dCsyfSlcbiAgICAgICAgICAgICAgICB2YXI8c3RvcmFnZSxyZWFkPiBtb3JwaFRhcmdldE9wTm9ybWFsczogYXJyYXk8ZjMyPjtcbiAgICAgICAgICAgICNlbmRpZlxuYH1zdGF0aWMgZ2V0TW9ycGhUYXJnZXRBdHRyKGUpe3JldHVybmBAbG9jYXRpb24oJHtlfSkgdkluZGV4OiBmMzIsYH1zdGF0aWMgZ2V0TW9ycGhUYXJnZXRDYWxjVmVydGV4KCl7cmV0dXJuYFxuICAgICAgICAgICAgdmVydGV4UG9zaXRpb24gPSBibGVuZE1vcnBoVGFyZ2V0UG9zaXRpb24oaTMyKHZlcnRleC52SW5kZXgpLCB2ZXJ0ZXhQb3NpdGlvbik7XG5cbiAgICAgICAgICAgICNpZiBVU0VfTU9SUEhOT1JNQUxTXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsID0gYmxlbmRNb3JwaFRhcmdldE5vcm1hbChpMzIodmVydGV4LnZJbmRleCksIHZlcnRleE5vcm1hbCk7XG4gICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgYH19byhMZSxcIkNzTWFpblwiLGBcbiAgICAgICAgc3RydWN0IE1vcnBoVGFyZ2V0Q29uZmlnRGF0YSB7XG4gICAgICAgICAgICBtb3JwaEJhc2VJbmZsdWVuY2U6ZjMyLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRDb3VudDpmMzIsXG4gICAgICAgICAgICB0b3RhbFZlcnRleENvdW50OmYzMixcbiAgICAgICAgICAgIGNvbXB1dGVXb3JrR3JvdXBYWTpmMzIsXG4gICAgICAgIH07XG5cbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBtb3JwaFRhcmdldENvbmZpZzogTW9ycGhUYXJnZXRDb25maWdEYXRhO1xuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IG1vcnBoVGFyZ2V0SW5mbHVlbmNlIDogYXJyYXk8ZjMyPjtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBtb3JwaFRhcmdldFBvc2l0aW9ucyA6IGFycmF5PGYzMj47XG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gbW9ycGhUYXJnZXRPcFBvc2l0aW9ucyA6IGFycmF5PGYzMj47XG4gICAgICAgIFxuICAgICAgICAjaWYgVVNFX01PUlBITk9STUFMU1xuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhcjxzdG9yYWdlLCByZWFkPiBtb3JwaFRhcmdldE5vcm1hbHMgOiBhcnJheTxmMzI+O1xuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDUpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBtb3JwaFRhcmdldE9wTm9ybWFscyA6IGFycmF5PGYzMj47XG4gICAgICAgICNlbmRpZlxuICAgICAgICBcbiAgICAgICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCA4ICwgOCAsIDEgKVxuICAgICAgICBmbiBDc01haW4oQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbEludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB2ZXJ0ZXhJbmRleDppMzIgPSBpMzIoZ2xvYmFsSW52b2NhdGlvbl9pZC55KSAqIGkzMihtb3JwaFRhcmdldENvbmZpZy5jb21wdXRlV29ya0dyb3VwWFkpICsgaTMyKGdsb2JhbEludm9jYXRpb25faWQueCk7XG4gICAgICAgIFxuICAgICAgICAgICAgbGV0IG1vcnBoVGFyZ2V0Q291bnQ6aTMyID0gaTMyKG1vcnBoVGFyZ2V0Q29uZmlnLm1vcnBoVGFyZ2V0Q291bnQpO1xuICAgICAgICAgICAgbGV0IHRvdGFsVmVydGV4Q291bnQ6aTMyID0gaTMyKG1vcnBoVGFyZ2V0Q29uZmlnLnRvdGFsVmVydGV4Q291bnQpO1xuICAgICAgICAgICAgdmFyIHZlcnRleFBvc2l0aW9uOnZlYzM8ZjMyPiA9IHZlYzM8ZjMyPigwLjApO1xuICAgICAgICAgICAgdmFyIHZlcnRleE5vcm1hbDp2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oMC4wKTtcbiAgICAgICAgICAgIGlmKHZlcnRleEluZGV4IDwgdG90YWxWZXJ0ZXhDb3VudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk6aTMyID0gMDsgaSA8IG1vcnBoVGFyZ2V0Q291bnQ7IGkgKyspe1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0OmkzMiA9IChpICogdG90YWxWZXJ0ZXhDb3VudCArIHZlcnRleEluZGV4KSAqIDM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3JwaFBvc2l0aW9uID0gdmVjMzxmMzI+KG1vcnBoVGFyZ2V0UG9zaXRpb25zW29mZnNldF0sIG1vcnBoVGFyZ2V0UG9zaXRpb25zW29mZnNldCArIDFdLCBtb3JwaFRhcmdldFBvc2l0aW9uc1tvZmZzZXQgKyAyXSk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uICs9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlW2ldICogbW9ycGhQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgd3JpdGVPZmZzZXQgPSB2ZXJ0ZXhJbmRleCAqIDM7XG4gICAgICAgICAgICAgICAgLy9vcCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0T3BQb3NpdGlvbnNbd3JpdGVPZmZzZXRdID0gdmVydGV4UG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBtb3JwaFRhcmdldE9wUG9zaXRpb25zW3dyaXRlT2Zmc2V0ICsgMV0gPSB2ZXJ0ZXhQb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0T3BQb3NpdGlvbnNbd3JpdGVPZmZzZXQgKyAyXSA9IHZlcnRleFBvc2l0aW9uLno7XG5cbiAgICAgICAgICAgICAgICAjaWYgVVNFX01PUlBITk9STUFMU1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk6aTMyID0gMDsgaSA8IG1vcnBoVGFyZ2V0Q291bnQ7IGkgKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldDppMzIgPSAoaSAqIHRvdGFsVmVydGV4Q291bnQgKyB2ZXJ0ZXhJbmRleCkgKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vcnBoTm9ybWFsID0gdmVjMzxmMzI+KG1vcnBoVGFyZ2V0Tm9ybWFsc1tvZmZzZXRdLCBtb3JwaFRhcmdldE5vcm1hbHNbb2Zmc2V0ICsgMV0sIG1vcnBoVGFyZ2V0Tm9ybWFsc1tvZmZzZXQgKyAyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWwgKz0gbW9ycGhUYXJnZXRJbmZsdWVuY2VbaV0gKiBtb3JwaE5vcm1hbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vb3Agbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0T3BOb3JtYWxzW3dyaXRlT2Zmc2V0XSA9IHZlcnRleE5vcm1hbC54O1xuICAgICAgICAgICAgICAgICAgICBtb3JwaFRhcmdldE9wTm9ybWFsc1t3cml0ZU9mZnNldCArIDFdID0gdmVydGV4Tm9ybWFsLnk7XG4gICAgICAgICAgICAgICAgICAgIG1vcnBoVGFyZ2V0T3BOb3JtYWxzW3dyaXRlT2Zmc2V0ICsgMl0gPSB2ZXJ0ZXhOb3JtYWwuejtcbiAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuYCk7bGV0IFBuPWBcbiAgICAjaWYgVVNFX01PUlBIVEFSR0VUU1xuICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRTaGFkZXJCaW5kaW5nKDMsMCl9XG4gICAgI2VuZGlmXG5cbiAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgJHtPci5ncm91cEJpbmRpbmdBbmRGdW5jdGlvbnMoMywwKX0gXG4gICAgI2VuZGlmXG5cbiAgICBzdHJ1Y3QgVmVydGV4QXR0cmlidXRlc3tcbiAgICBAYnVpbHRpbihpbnN0YW5jZV9pbmRleCkgaW5kZXggOiB1MzIsXG4gICAgQGxvY2F0aW9uKDApIHBvc2l0aW9uOiB2ZWMzPGYzMj4sXG4gICAgQGxvY2F0aW9uKDEpIG5vcm1hbDogdmVjMzxmMzI+LFxuICAgIEBsb2NhdGlvbigyKSB1djogdmVjMjxmMzI+LFxuICAgIEBsb2NhdGlvbigzKSBURVhDT09SRF8xOiB2ZWMyPGYzMj4sXG5cbiAgICAjaWYgVVNFX1RBTkdFTlRcbiAgICAgICAgQGxvY2F0aW9uKDQpIFRBTkdFTlQ6IHZlYzQ8ZjMyPixcbiAgICAgICAgI2lmIFVTRV9TS0VMRVRPTlxuICAgICAgICAgICAgQGxvY2F0aW9uKDUpIGpvaW50czA6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAgIEBsb2NhdGlvbig2KSB3ZWlnaHRzMDogdmVjNDxmMzI+LFxuICAgICAgICAgICAgI2lmIFVTRV9KT0lOVF9WRUM4XG4gICAgICAgICAgICBAbG9jYXRpb24oNykgam9pbnRzMTogdmVjNDxmMzI+LFxuICAgICAgICAgICAgQGxvY2F0aW9uKDgpIHdlaWdodHMxOiB2ZWM0PGYzMj4sXG4gICAgICAgICNlbmRpZlxuICAgICAgICAjZWxzZWlmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAgICAgICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRBdHRyKDUpfVxuICAgICAgICAjZW5kaWZcbiAgICAjZWxzZWlmIFVTRV9TS0VMRVRPTlxuICAgICAgICBAbG9jYXRpb24oNCkgam9pbnRzMDogdmVjNDxmMzI+LFxuICAgICAgICBAbG9jYXRpb24oNSkgd2VpZ2h0czA6IHZlYzQ8ZjMyPixcbiAgICAgICAgI2lmIFVTRV9KT0lOVF9WRUM4XG4gICAgICAgIEBsb2NhdGlvbig2KSBqb2ludHMxOiB2ZWM0PGYzMj4sXG4gICAgICAgIEBsb2NhdGlvbig3KSB3ZWlnaHRzMTogdmVjNDxmMzI+LFxuICAgICAgICAjZW5kaWZcbiAgICAjZWxzZWlmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAgICAgJHtMZS5nZXRNb3JwaFRhcmdldEF0dHIoNCl9XG4gICAgI2VuZGlmXG4gICAgfVxuXG4gICAgc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgQGxvY2F0aW9uKDApIHZhcnlpbmdfVVYwOiB2ZWMyPGYzMj4sXG4gICAgQGxvY2F0aW9uKDEpIHZhcnlpbmdfVVYxOiB2ZWMyPGYzMj4sXG4gICAgQGxvY2F0aW9uKDIpIHZhcnlpbmdfVmlld1BvczogdmVjNDxmMzI+LFxuICAgIEBsb2NhdGlvbigzKSB2YXJ5aW5nX0NsaXA6IHZlYzQ8ZjMyPixcbiAgICBAbG9jYXRpb24oNCkgdmFyeWluZ19XUG9zOiB2ZWM0PGYzMj4sXG4gICAgQGxvY2F0aW9uKDUpIHZhcnlpbmdfV05vcm1hbDogdmVjMzxmMzI+LFxuICAgIEBsb2NhdGlvbig2KSB2YXJ5aW5nX0NvbG9yOiB2ZWM0PGYzMj4sXG5cbiAgICAjaWYgVVNFX1NIQURPV01BUElOR1xuICAgICAgICBAbG9jYXRpb24oNykgdmFyeWluZ19TaGFkb3dQb3M6IHZlYzQ8ZjMyPixcbiAgICAjZW5kaWZcblxuICAgICNpZiBVU0VfVEFOR0VOVFxuICAgICAgICBAbG9jYXRpb24oOCkgdmFyeWluZ19UYW5nZW50OiB2ZWM0PGYzMj4sXG4gICAgI2VuZGlmXG5cbiAgICBAYnVpbHRpbihwb3NpdGlvbikgbWVtYmVyOiB2ZWM0PGYzMj5cbiAgICB9O1xuXG4gICAgdmFyPHByaXZhdGU+IE9SSV9WZXJ0ZXhPdXQ6IFZlcnRleE91dHB1dCA7XG5cbiAgICBmbiBPUklfVmVydCh2ZXJ0ZXg6VmVydGV4QXR0cmlidXRlcyl7XG4gICAgdmFyIHZlcnRleFBvc2l0aW9uID0gdmVydGV4LnBvc2l0aW9uO1xuICAgIHZhciB2ZXJ0ZXhOb3JtYWwgPSB2ZXJ0ZXgubm9ybWFsO1xuXG4gICAgI2lmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAke0xlLmdldE1vcnBoVGFyZ2V0Q2FsY1ZlcnRleCgpfSAgICBcbiAgICAjZW5kaWZcblxuICAgICNpZiBVU0VfU0tFTEVUT05cbiAgICAgICAgI2lmIFVTRV9KT0lOVF9WRUM4XG4gICAgICAgICAgICBsZXQgc2tlbGV0b25Ob3JtYWwgPSBnZXRTa2VsZXRvbldvcmxkTWF0cml4XzgodmVydGV4LmpvaW50czAsIHZlcnRleC53ZWlnaHRzMCwgdmVydGV4LmpvaW50czEsIHZlcnRleC53ZWlnaHRzMSk7XG4gICAgICAgICAgICBPUklfTUFUUklYX00gKj0gc2tlbGV0b25Ob3JtYWwgO1xuICAgICAgICAjZWxzZVxuICAgICAgICAgICAgbGV0IHNrZWxldG9uTm9ybWFsID0gZ2V0U2tlbGV0b25Xb3JsZE1hdHJpeF80KHZlcnRleC5qb2ludHMwLCB2ZXJ0ZXgud2VpZ2h0czApO1xuICAgICAgICAgICAgT1JJX01BVFJJWF9NICo9IHNrZWxldG9uTm9ybWFsIDtcbiAgICAgICAgI2VuZGlmXG4gICAgI2VuZGlmXG5cbiAgICAjaWYgVVNFX1RBTkdFTlRcbiAgICAgICAgT1JJX1ZlcnRleE91dC52YXJ5aW5nX1RhbmdlbnQgPSB2ZXJ0ZXguVEFOR0VOVCA7XG4gICAgI2VuZGlmXG5cbiAgICBPUklfTk9STUFMTUFUUklYID0gdHJhbnNwb3NlKGludmVyc2UoIG1hdDN4MzxmMzI+KE9SSV9NQVRSSVhfTVswXS54eXosT1JJX01BVFJJWF9NWzFdLnh5eixPUklfTUFUUklYX01bMl0ueHl6KSApKTtcblxuICAgIHZhciB3b3JsZFBvcyA9IChPUklfTUFUUklYX00gKiB2ZWM0PGYzMj4odmVydGV4UG9zaXRpb24ueHl6LCAxLjApKTtcbiAgICB2YXIgdmlld1Bvc2l0aW9uID0gT1JJX01BVFJJWF9WICogd29ybGRQb3M7XG4gICAgdmFyIGNsaXBQb3NpdGlvbiA9IE9SSV9NQVRSSVhfUCAqIHZpZXdQb3NpdGlvbiA7XG5cbiAgICBPUklfQ2FtZXJhV29ybGREaXIgPSBub3JtYWxpemUoT1JJX0NBTUVSQU1BVFJJWFszXS54eXogLSB3b3JsZFBvcy54eXopIDtcblxuICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19VVjAgPSB2ZXJ0ZXgudXYueHkgO1xuICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19VVjEgPSB2ZXJ0ZXguVEVYQ09PUkRfMS54eTtcbiAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfVmlld1BvcyA9IHZpZXdQb3NpdGlvbiA7XG4gICAgT1JJX1ZlcnRleE91dC52YXJ5aW5nX0NsaXAgPSBjbGlwUG9zaXRpb24gO1xuICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19XUG9zID0gd29ybGRQb3MgO1xuICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19XUG9zLncgPSBmMzIodmVydGV4LmluZGV4KTtcbiAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfV05vcm1hbCA9IG5vcm1hbGl6ZShPUklfTk9STUFMTUFUUklYICogdmVydGV4Tm9ybWFsLnh5eikgO1xuXG4gICAgT1JJX1ZlcnRleE91dC5tZW1iZXIgPSBjbGlwUG9zaXRpb24gO1xuICAgIH1cbmAsUm49YFxuc3RydWN0IE1hdGVyaWFsVW5pZm9ybSB7XG4gIHRyYW5zZm9ybVVWMTp2ZWM0PGYzMj4sXG4gIHRyYW5zZm9ybVVWMjp2ZWM0PGYzMj4sXG4gIGJhc2VDb2xvcjogdmVjNDxmMzI+LFxuICByZWN0Q2xpcDogdmVjNDxmMzI+LFxuICBhbHBoYUN1dG9mZjogZjMyLFxufTtcblxuQGdyb3VwKDIpIEBiaW5kaW5nKDApXG52YXI8dW5pZm9ybT4gbWF0ZXJpYWxVbmlmb3JtOiBNYXRlcmlhbFVuaWZvcm07XG5gLExuPWBcbiAgICBzdHJ1Y3QgSXJyYWRpYW5jZVZvbHVtZURhdGEge1xuICAgICAgICAvLzBcbiAgICAgICAgb3JpZW50YXRpb25JbmRleDpmMzIsXG4gICAgICAgICAgICBoeXN0ZXJlc2lzOmYzMixcbiAgICAgICAgICAgIE9jdFJUU2lkZVNpemU6ZjMyLFxuICAgICAgICAgICAgT2N0UlRNYXhTaXplOmYzMixcblxuICAgICAgICAgICAgLy8xXG4gICAgICAgICAgICBzdGFydFg6ZjMyLFxuICAgICAgICAgICAgc3RhcnRZOmYzMixcbiAgICAgICAgICAgIHN0YXJ0WjpmMzIsXG4gICAgICAgICAgICBQcm9iZVNwYWNlOmYzMixcblxuICAgICAgICAgICAgLy8yXG4gICAgICAgICAgICBncmlkWENvdW50OmYzMixcbiAgICAgICAgICAgIGdyaWRZQ291bnQ6ZjMyLFxuICAgICAgICAgICAgZ3JpZFpDb3VudDpmMzIsXG4gICAgICAgICAgICBtYXhEaXN0YW5jZTpmMzIsXG5cbiAgICAgICAgICAgIC8vM1xuICAgICAgICAgICAgZGVwdGhTaGFycG5lc3M6ZjMyLFxuICAgICAgICAgICAgUHJvYmVTb3VyY2VUZXh0dXJlU2l6ZTpmMzIsXG4gICAgICAgICAgICBQcm9iZVNpemU6ZjMyLFxuICAgICAgICAgICAgYm91bmNlSW50ZW5zaXR5OmYzMixcblxuICAgICAgICAgICAgLy80XG4gICAgICAgICAgICBwcm9iZVJvdWdobmVzczpmMzIsXG4gICAgICAgICAgICBub3JtYWxCaWFzOmYzMixcbiAgICAgICAgICAgIGlycmFkaWFuY2VDaGVieXNoZXZCaWFzOmYzMixcbiAgICAgICAgICAgIHJheU51bWJlcjpmMzIsXG5cbiAgICAgICAgICAgIC8vNVxuICAgICAgICAgICAgaXJyYWRpYW5jZURpc3RhbmNlQmlhczpmMzIsXG4gICAgICAgICAgICBpbmRpcmVjdEludGVuc2l0eTpmMzIsXG4gICAgICAgICAgICBkZGdpR2FtbWE6ZjMyLFxuICAgICAgICAgICAgbGVycEh5c3RlcmVzaXM6ZjMyLFxuICAgICAgICAgICAgLy82XG5cbiAgICAgICAgICAgIGRlYnVnWDpmMzIsXG4gICAgICAgICAgICBkZWJ1Z1k6ZjMyLFxuICAgICAgICAgICAgZGVidWdaOmYzMixcbiAgICAgICAgICAgIHNsb3QwOmYzMixcblxuICAgICAgICAgICAgLy8uLlxuICAgICAgICAgICAgdjc6dmVjNDxmMzI+LFxuICAgIH1cbmAsVW49YFxuICAgICNpbmNsdWRlIFwiTWF0aFNoYWRlclwiXG4gICAgI2luY2x1ZGUgXCJGYXN0TWF0aFNoYWRlclwiXG4gICAgI2luY2x1ZGUgXCJJbnN0YW5jZVVuaWZvcm1cIlxuXG4gICAgdmFyPHByaXZhdGU+IE9SSV9NQVRSSVhfUDogbWF0NHg0PGYzMj47XG4gICAgdmFyPHByaXZhdGU+IE9SSV9NQVRSSVhfVjogbWF0NHg0PGYzMj47XG4gICAgdmFyPHByaXZhdGU+IE9SSV9NQVRSSVhfTTogbWF0NHg0PGYzMj47XG4gICAgdmFyPHByaXZhdGU+IE9SSV9NQVRSSVhfUFY6IG1hdDR4NDxmMzI+O1xuICAgIHZhcjxwcml2YXRlPiBPUklfTUFUUklYX1BWSW52OiBtYXQ0eDQ8ZjMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gT1JJX01BVFJJWF9Xb3JsZDogbWF0NHg0PGYzMj47XG4gICAgdmFyPHByaXZhdGU+IE9SSV9DQU1FUkFNQVRSSVg6IG1hdDR4NDxmMzI+O1xuICAgIHZhcjxwcml2YXRlPiBPUklfTk9STUFMTUFUUklYOiBtYXQzeDM8ZjMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gT1JJX0NhbWVyYVdvcmxkRGlyOiB2ZWMzPGYzMj47XG4gICAgdmFyPHByaXZhdGU+IE9SSV9WaWV3RGlyOiB2ZWMzPGYzMj47XG5cbiAgICB2YXI8cHJpdmF0ZT4gVElNRTogdmVjNDxmMzI+O1xuICAgIHZhcjxwcml2YXRlPiBNT1VTRTogdmVjNDxmMzI+O1xuICAgIHZhcjxwcml2YXRlPiBTQ1JFRU46IHZlYzQ8ZjMyPjtcblxuICAgIHZhcjxwcml2YXRlPiBQcm9qZWN0aW9uUGFyYW1zOiB2ZWM0PGYzMj47XG5cbiAgICBmbiB2ZXJ0ZXhfaW5saW5lKHZlcnRleDpWZXJ0ZXhBdHRyaWJ1dGVzKXtcbiAgICAgICAgVElNRS54ID0gZ2xvYmFsVW5pZm9ybS5mcmFtZTtcbiAgICAgICAgVElNRS55ID0gZ2xvYmFsVW5pZm9ybS50aW1lO1xuICAgICAgICBUSU1FLnogPSBnbG9iYWxVbmlmb3JtLmRlbHRhO1xuXG4gICAgICAgIE1PVVNFLnggPSBnbG9iYWxVbmlmb3JtLm1vdXNlWDtcbiAgICAgICAgTU9VU0UueSA9IGdsb2JhbFVuaWZvcm0ubW91c2VZO1xuXG4gICAgICAgIFNDUkVFTi54ID0gZ2xvYmFsVW5pZm9ybS53aW5kb3dXaWR0aDtcbiAgICAgICAgU0NSRUVOLnkgPSBnbG9iYWxVbmlmb3JtLndpbmRvd0hlaWdodDtcblxuICAgICAgICBQcm9qZWN0aW9uUGFyYW1zLnggPSBnbG9iYWxVbmlmb3JtLm5lYXI7XG4gICAgICAgIFByb2plY3Rpb25QYXJhbXMueSA9IGdsb2JhbFVuaWZvcm0uZmFyO1xuICAgICAgICBQcm9qZWN0aW9uUGFyYW1zLnogPSAxLjAgKyAxLjAgLyBnbG9iYWxVbmlmb3JtLmZhcjtcblxuICAgICAgICBPUklfTUFUUklYX1AgPSBnbG9iYWxVbmlmb3JtLnByb2pNYXQgO1xuICAgICAgICBPUklfTUFUUklYX1YgPSBnbG9iYWxVbmlmb3JtLnZpZXdNYXQgO1xuICAgICAgICBPUklfTUFUUklYX1BWID0gT1JJX01BVFJJWF9QICogT1JJX01BVFJJWF9WIDtcbiAgICAgICAgT1JJX01BVFJJWF9QVkludiA9IGdsb2JhbFVuaWZvcm0ucHZNYXRyaXhJbnYgO1xuICAgICAgICBPUklfQ0FNRVJBTUFUUklYID0gZ2xvYmFsVW5pZm9ybS5jYW1lcmFXb3JsZE1hdHJpeCA7XG5cbiAgICAgICAgT1JJX01BVFJJWF9NID0gbW9kZWxzLm1hdHJpeFt1MzIodmVydGV4LmluZGV4KV07XG4gICAgICAgICAgICBcbiAgICAgICAgI2lmIFVTRV9JTlNUQU5DRURSQVdcbiAgICAgICAgICAgIGxldCBtb2RlbElEID0gaW5zdGFuY2VEcmF3SUQubWF0cml4SURzW3ZlcnRleC5pbmRleF07XG4gICAgICAgICAgICBPUklfTUFUUklYX00gPSBtb2RlbHMubWF0cml4W21vZGVsSURdO1xuICAgICAgICAjZW5kaWZcbiAgICB9XG5gLE9uPWBcbiAgI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcbiAgI2luY2x1ZGUgXCJGcmFnbWVudFZhcnlpbmdcIlxuICAjaW5jbHVkZSBcIkNvbG9yUGFzc0ZyYWdtZW50T3V0cHV0XCJcbiAgI2luY2x1ZGUgXCJTaGFkaW5nSW5wdXRcIlxuXG4gIHZhcjxwcml2YXRlPiBPUklfRnJhZ21lbnRPdXRwdXQ6IEZyYWdtZW50T3V0cHV0O1xuICB2YXI8cHJpdmF0ZT4gT1JJX1ZlcnRleFZhcnlpbmc6IEZyYWdtZW50VmFyeWluZztcbiAgdmFyPHByaXZhdGU+IE9SSV9TaGFkaW5nSW5wdXQ6IFNoYWRpbmdJbnB1dDtcbiAgdmFyPHByaXZhdGU+IHZpZXdEaXI6dmVjMzxmMzI+O1xuICBAZnJhZ21lbnRcbiAgZm4gRnJhZ01haW4oIHZlcnRleF92YXJ5aW5nOkZyYWdtZW50VmFyeWluZyApIC0+IEZyYWdtZW50T3V0cHV0IHtcbiAgICBPUklfVmVydGV4VmFyeWluZyA9IHZlcnRleF92YXJ5aW5nO1xuICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPigxLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgIHZpZXdEaXIgPSBub3JtYWxpemUoZ2xvYmFsVW5pZm9ybS5DYW1lcmFQb3MueHl6IC0gT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5eikgO1xuICAgICNpZiBVU0VfV09STERQT1NcbiAgICAgIE9SSV9GcmFnbWVudE91dHB1dC53b3JsZFBvcyA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZFBvcztcbiAgICAjZW5kaWZcbiAgICAjaWYgVVNFR0JVRkZFUlxuICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LndvcmxkTm9ybWFsID0gdmVjNDxmMzI+KE9SSV9TaGFkaW5nSW5wdXQuTm9ybWFsLnJnYiAsMS4wKTsgXG4gICAgICBPUklfRnJhZ21lbnRPdXRwdXQubWF0ZXJpYWwgPSB2ZWM0PGYzMj4oMC4wLDEuMCwwLjAsMC4wKTtcbiAgICAjZW5kaWZcbiAgICBmcmFnKCk7XG4gICAgXG4gICAgI2lmIFVTRV9ERUJVR1xuICAgICAgZGVidWdGcmFnbWVudE91dCgpO1xuICAgICNlbmRpZlxuXG4gICAgLy8gdmFyIGQxID0gbG9nRGVwdGgoIE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZC53ICwgZ2xvYmFsVW5pZm9ybS5mYXIpO1xuICAgIC8vIE9SSV9GcmFnbWVudE91dHB1dC5vdXRfZGVwdGggPSBkMSA7XG5cbiAgICAjaWYgVVNFX09VVERFUFRIXG4gICAgICAjaWYgVVNFX0xPR0RFUFRIXG4gICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5vdXRfZGVwdGggPSBsb2cyRGVwdGgoT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ0Nvb3JkLnosZ2xvYmFsVW5pZm9ybS5uZWFyLGdsb2JhbFVuaWZvcm0uZmFyKSA7XG4gICAgICAjZWxzZVxuICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQub3V0X2RlcHRoID0gT1JJX1NoYWRpbmdJbnB1dC5GcmFnRGVwdGggO1xuICAgICAgI2VuZGlmXG4gICAgI2VuZGlmXG5cbiAgICAvLyB2YXIgZDEgPSBsb2cyKE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZC53ICsgMS4wKSAqIDIuMCAvIChsb2coZiArIDEuMCkgLyAwLjY5MzE0NzE4MDU1OTk0NTMpICogMC41IDtcbiAgICAvLyAyLjAgLyAoTWF0aC5sb2coY2FtZXJhLmZhciArIDEuMCkgLyBNYXRoLkxOMilcbiAgICAvLyBPUklfRnJhZ21lbnRPdXRwdXQub3V0X2RlcHRoID0gZDEgO1xuXG4gICAgcmV0dXJuIE9SSV9GcmFnbWVudE91dHB1dCA7XG4gIH1cblxuXG5gLE5uPWBcbiAgICAjaW5jbHVkZSBcIldvcmxkTWF0cml4VW5pZm9ybVwiXG4gICAgI2luY2x1ZGUgXCJWZXJ0ZXhBdHRyaWJ1dGVzX3ZlcnRcIlxuICAgICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG4gICAgI2luY2x1ZGUgXCJJbmxpbmVfdmVydFwiXG4gICAgQHZlcnRleFxuICAgIGZuIFZlcnRNYWluKCB2ZXJ0ZXg6VmVydGV4QXR0cmlidXRlcyApIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgIHZlcnRleF9pbmxpbmUodmVydGV4KTtcbiAgICAgICAgdmVydCh2ZXJ0ZXgpO1xuICAgICAgICByZXR1cm4gT1JJX1ZlcnRleE91dCA7XG4gICAgfVxuYCxGbj1gXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgdmFyIGJyZGZsdXRNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKVxuICAgIHZhciBicmRmbHV0TWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5gLGtuPWBcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgcHJlZmlsdGVyTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgcHJlZmlsdGVyTWFwOiB0ZXh0dXJlX2N1YmU8ZjMyPjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgZW52TWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgZW52TWFwOiB0ZXh0dXJlX2N1YmU8ZjMyPjtcbmA7Y2xhc3MgbHR7fW8obHQsXCJDYXNjYWRlc1wiLDQpO2xldCBUcz1gXG5cbiAgc3RydWN0IEdsb2JhbFVuaWZvcm0ge1xuICAgIHByb2pNYXQ6IG1hdDR4NDxmMzI+LFxuICAgIHZpZXdNYXQ6IG1hdDR4NDxmMzI+LFxuICAgIGNhbWVyYVdvcmxkTWF0cml4OiBtYXQ0eDQ8ZjMyPixcbiAgICBwdk1hdHJpeEludiA6IG1hdDR4NDxmMzI+LFxuICAgIHNoYWRvd01hdHJpeDogYXJyYXk8bWF0NHg0PGYzMj4sIDh1PixcbiAgICBjc21TaGFkb3dCaWFzOiB2ZWM0PGYzMj4sXG4gICAgY3NtTWF0cml4OiBhcnJheTxtYXQ0eDQ8ZjMyPiwke2x0LkNhc2NhZGVzfT4sXG5cbiAgICBDYW1lcmFQb3M6IHZlYzM8ZjMyPixcbiAgICBmcmFtZTogZjMyLFxuXG4gICAgdGltZTogZjMyLFxuICAgIGRlbHRhOiBmMzIsXG4gICAgc2hhZG93QmlhczogZjMyLFxuICAgIHNreUV4cG9zdXJlOiBmMzIsXG5cbiAgICByZW5kZXJQYXNzU3RhdGU6ZjMyLFxuICAgIHF1YWRTY2FsZTogZjMyLFxuICAgIGhkckV4cG9zdXJlOiBmMzIsXG4gICAgcmVuZGVyU3RhdGVfbGVmdDogaTMyLFxuXG4gICAgcmVuZGVyU3RhdGVfcmlnaHQ6IGkzMixcbiAgICByZW5kZXJTdGF0ZV9zcGxpdDogZjMyLFxuICAgIG1vdXNlWDogZjMyLFxuICAgIG1vdXNlWTogZjMyLFxuXG4gICAgd2luZG93V2lkdGg6IGYzMixcbiAgICB3aW5kb3dIZWlnaHQ6IGYzMixcbiAgICBuZWFyOiBmMzIsXG4gICAgZmFyOiBmMzIsXG5cbiAgICBwb2ludFNoYWRvd0JpYXM6IGYzMixcbiAgICBzaGFkb3dNYXBTaXplOiBmMzIsXG4gICAgc2hhZG93U29mdDogZjMyLFxuICAgIGVuYWJsZUNTTTpmMzIsXG5cbiAgICBjc21NYXJnaW46ZjMyLFxuICAgIG5vdFVzZWQxOmYzMixcbiAgICBub3RVc2VkMjpmMzIsXG4gICAgbm90VXNlZDM6ZjMyXG4gICAgXG4gIH07XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApXG4gIHZhcjx1bmlmb3JtPiBnbG9iYWxVbmlmb3JtOiBHbG9iYWxVbmlmb3JtO1xuYCx6bj1gXG4gICAgI2lmIFVTRV9JTlNUQU5DRURSQVdcbiAgICAgICAgc3RydWN0IEluc3RhbmNlVW5pZm9ybSB7XG4gICAgICAgICAgICBtYXRyaXhJRHMgOiBhcnJheTxpMzI+XG4gICAgICAgIH07XG4gICAgICAgIEBncm91cCgyKSBAYmluZGluZyg3KVxuICAgICAgICB2YXI8c3RvcmFnZSwgcmVhZD4gaW5zdGFuY2VEcmF3SUQgOiBJbnN0YW5jZVVuaWZvcm07XG4gICAgI2VuZGlmXG5gLFhhPWBcbiAgICBzdHJ1Y3QgVW5pZm9ybXMge1xuICAgICAgICBtYXRyaXggOiBhcnJheTxtYXQ0eDQ8ZjMyPj5cbiAgICB9O1xuXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpXG4gICAgdmFyPHN0b3JhZ2UsIHJlYWQ+IG1vZGVscyA6IFVuaWZvcm1zO1xuYCxHbj1gXG4gIGZuIFBvdzMoICB4IDogZjMyICkgLT4gZjMyXG4gIHtcbiAgICAgIHZhciB4eCA9IHgqeDtcbiAgICAgIHJldHVybiB4ICogeHg7XG4gIH1cblxuICBmbiBQb3c0KCAgeCA6IGYzMiApIC0+IGYzMlxuICB7XG4gICAgICB2YXIgeHggPSB4Kng7XG4gICAgICByZXR1cm4geHggKiB4eDtcbiAgfVxuXG4gIGZuIHBvdzUoeDogZjMyKSAtPiBmMzIge1xuICAgICAgdmFyIHgyID0geCAqIHg7XG4gICAgICByZXR1cm4geDIgKiB4MiAqIHg7XG4gIH1cblxuICBmbiByY3AoIHg6ZjMyICkgLT4gZjMyXG4gIHtcbiAgICAgIHJldHVybiAxLjAgLyB4O1xuICB9XG5cbiAgZm4gcnNxcnQzKCBhIDogdmVjMzxmMzI+ICkgLT4gdmVjMzxmMzI+XG4gIHtcbiAgICByZXR1cm4gcG93KGEsIHZlYzM8ZjMyPigtMC41KSk7XG4gIH1cblxuICBmbiByc3FydCggYSA6IGYzMiApIC0+IGYzMlxuICB7XG4gICAgcmV0dXJuIHBvdyhhLCAtMC41KTtcbiAgfVxuYCxRbj1gXG4gICAgZm4gcGVydHVyYk5vcm1hbCggIHdvcmxkUG9zOnZlYzM8ZjMyPiwgIHN1cmZfbm9ybTp2ZWMzPGYzMj4sICBtYXBOOnZlYzM8ZjMyPiAsIG5vcm1hbFNjYWxlOmYzMiAsIGZhY2U6ZjMyICkgLT4gdmVjMzxmMzI+IHtcbiAgICAgICAgdmFyIHEwID0gdmVjMzxmMzI+KCBkcGR4KCB3b3JsZFBvcy54ICksIGRwZHgoIHdvcmxkUG9zLnkgKSwgZHBkeCggd29ybGRQb3MueiApICk7XG4gICAgICAgIHZhciBxMSA9IHZlYzM8ZjMyPiggZHBkeSggd29ybGRQb3MueCApLCBkcGR5KCB3b3JsZFBvcy55ICksIGRwZHkoIHdvcmxkUG9zLnogKSApO1xuICAgICAgICB2YXIgc3QwID0gZHBkeCggT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ1VWMC54eSApO1xuICAgICAgICB2YXIgc3QxID0gZHBkeSggT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ1VWMC54eSApO1xuICAgICAgICB2YXIgTiA9IHN1cmZfbm9ybTtcbiAgICAgICAgdmFyIHExcGVycCA9IGNyb3NzKCBxMSwgTiApO1xuICAgICAgICB2YXIgcTBwZXJwID0gY3Jvc3MoIE4sIHEwICk7XG5cbiAgICAgICAgI2lmIFVTRV9UQU5HRU5UXG4gICAgICAgICAgICB2YXIgVCA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLlRBTkdFTlQueHl6IDtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgIHZhciBUID0gcTFwZXJwICogc3QwLnggKyBxMHBlcnAgKiBzdDEueDtcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIFxuICAgICAgICB2YXIgQiA9IHExcGVycCAqIHN0MC55ICsgcTBwZXJwICogc3QxLnk7XG5cbiAgICAgICAgdmFyIGRldCA9IG1heCggZG90KCBULCBUICksIGRvdCggQiwgQiApICk7XG4gICAgICAgIHZhciBzY2FsZSA9IDEuMCA7XG4gICAgICAgIGlmKCBkZXQgIT0gMC4wICl7XG4gICAgICAgICAgICBzY2FsZSA9IGludmVyc2VTcXJ0KCBkZXQgKSA7XG4gICAgICAgIH1cbiAgICAgICAgI2lmIFVTRV9UQU5HRU5UXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlICogT1JJX1ZlcnRleFZhcnlpbmcuVEFOR0VOVC53IDtcbiAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgc2NhbGUgKj0gbm9ybWFsU2NhbGU7XG4gICAgICAgIHJldHVybiBub3JtYWxpemUoIChUICogKCAtbWFwTi54ICogc2NhbGUgKSArIEIgKiAoIG1hcE4ueSAqIHNjYWxlICkgKyBOICogbWFwTi56ICkgKiBmYWNlICkgO1xuICAgIH1cblxuICAgIGZuIHVucGFja05vcm1hbE1hcCggbm9ybWFsIDogdmVjMzxmMzI+ICkgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICB2YXIgbm9ybWFsVGV4ID0gdmVjMzxmMzI+KCBub3JtYWwueHl6ICogMi4wIC0gMS4wICkgO1xuICAgICAgICByZXR1cm4gKG5vcm1hbFRleCk7XG4gICAgfVxuXG4gICAgZm4gdW5QYWNrTm9ybWFsKG5vcm1hbCA6IHZlYzM8ZjMyPiAsIGhlaWdodDpmMzIgKSAtPiB2ZWMzPGYzMj57XG4gICAgICAgIHZhciBmYWNlID0gMS4wIDtcbiAgICAgICAgaWYoT1JJX1ZlcnRleFZhcnlpbmcuZmFjZSl7XG4gICAgICAgICAgICBmYWNlID0gMS4wIDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBmYWNlID0gLTEuMCA7XG4gICAgICAgIH1cblxuICAgICAgICAjaWYgVVNFX1JHTk9STUFMXG4gICAgICAgICAgICByZXR1cm4gdW5QYWNrUkdOb3JtYWwobm9ybWFsLGhlaWdodCxmYWNlKTtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgIHZhciBuID0gbm9ybWFsIDtcbiAgICAgICAgICAgICNpZiBVU0VfTk9STUFMRklMUFlcbiAgICAgICAgICAgIG4ueSA9IDEuMCAtIG4ueSA7IFxuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBtYXBOb3JtYWw6IHZlYzM8ZjMyPiA9IHVucGFja05vcm1hbE1hcChuKSA7XG4gICAgICAgICAgICByZXR1cm4gcGVydHVyYk5vcm1hbChPUklfVmVydGV4VmFyeWluZy52V29ybGRQb3MueHl6ICwgT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkTm9ybWFsLnh5eiAsIG1hcE5vcm1hbCAsIGhlaWdodCAsIGZhY2UgICkgO1xuICAgICAgICAjZW5kaWZcbiAgICB9XG5cbiAgICBmbiB1blBhY2tSR05vcm1hbChub3JtYWwgOiB2ZWMzPGYzMj4gLCBoZWlnaHQ6ZjMyICwgZmFjZTpmMzIpIC0+IHZlYzM8ZjMyPiB7XG4gICAgICAgIHZhciBkID0gbm9ybWFsLnJnICogMi4wIC0gMS4wIDtcbiAgICAgICAgdmFyIGwgPSAxLjAgLSBzYXR1cmF0ZShkb3QoZCxkKSk7XG4gICAgICAgIHZhciBzID0gc3FydChsKTtcbiAgICAgICAgdmFyIHJnID0gZCAqIGhlaWdodCA7IFxuICAgICAgICB2YXIgbWFwTm9ybWFsID0gdmVjMzxmMzI+KHJnLHMpO1xuICAgICAgICB2YXIgb3V0TiA9IHBlcnR1cmJOb3JtYWwoT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5eixPUklfVmVydGV4VmFyeWluZy52V29ybGROb3JtYWwsbWFwTm9ybWFsLDEuMCxmYWNlKSA7XG4gICAgICAgIHJldHVybiBvdXROIDtcbiAgICB9XG5gLFZuPWBcbiAgICBzdHJ1Y3QgRnJhZ21lbnRWYXJ5aW5nIHtcbiAgICAgICAgQGxvY2F0aW9uKDApIGZyYWdVVjA6IHZlYzI8ZjMyPixcbiAgICAgICAgQGxvY2F0aW9uKDEpIGZyYWdVVjE6IHZlYzI8ZjMyPixcbiAgICAgICAgQGxvY2F0aW9uKDIpIHZpZXdQb3NpdGlvbjogdmVjNDxmMzI+LFxuICAgICAgICBAbG9jYXRpb24oMykgZnJhZ1Bvc2l0aW9uOiB2ZWM0PGYzMj4sXG4gICAgICAgIEBsb2NhdGlvbig0KSB2V29ybGRQb3M6IHZlYzQ8ZjMyPixcbiAgICAgICAgQGxvY2F0aW9uKDUpIHZXb3JsZE5vcm1hbDogdmVjMzxmMzI+LFxuICAgICAgICBAbG9jYXRpb24oNikgdkNvbG9yOiB2ZWM0PGYzMj4sXG5cbiAgICAgICAgI2lmIFVTRV9TSEFET1dNQVBJTkdcbiAgICAgICAgICAgIEBsb2NhdGlvbig3KSB2U2hhZG93UG9zOiB2ZWM0PGYzMj4sXG4gICAgICAgICNlbmRpZlxuXG4gICAgICAgICNpZiBVU0VfVEFOR0VOVFxuICAgICAgICAgICAgQGxvY2F0aW9uKDgpIFRBTkdFTlQ6IHZlYzQ8ZjMyPixcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIFxuICAgICAgICBAYnVpbHRpbihmcm9udF9mYWNpbmcpIGZhY2U6IGJvb2wsXG4gICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBmcmFnQ29vcmQgOiB2ZWM0PGYzMj5cbiAgICB9O1xuYCxXYT1gXG4gICAgc3RydWN0IEZyYWdtZW50T3V0cHV0IHtcbiAgICAgICAgQGxvY2F0aW9uKDApIGNvbG9yOiB2ZWM0PGYzMj4sXG4gICAgICAgICNpZiBVU0VfV09STERQT1NcbiAgICAgICAgICAgIEBsb2NhdGlvbigxKSB3b3JsZFBvczogdmVjNDxmMzI+LFxuICAgICAgICAjZW5kaWZcbiAgICAgICAgI2lmIFVTRUdCVUZGRVJcbiAgICAgICAgICAgIEBsb2NhdGlvbigyKSB3b3JsZE5vcm1hbDogdmVjNDxmMzI+LFxuICAgICAgICAgICAgQGxvY2F0aW9uKDMpIG1hdGVyaWFsOiB2ZWM0PGYzMj4sXG4gICAgICAgICNlbmRpZlxuXG4gICAgICAgICNpZiBVU0VfT1VUREVQVEhcbiAgICAgICAgICAgIEBidWlsdGluKGZyYWdfZGVwdGgpIG91dF9kZXB0aDogZjMyXG4gICAgICAgICNlbmRpZlxuICAgIH07XG5gLEhuPWBcbiAgICBzdHJ1Y3QgU2hhZGluZ0lucHV0e1xuICAgICAgICBCYXNlQ29sb3I6dmVjNDxmMzI+LFxuICAgICAgICBSb3VnaG5lc3M6ZjMyLFxuICAgICAgICBNZXRhbGxpYzpmMzIsXG4gICAgICAgIFNwZWN1bGFyOmYzMixcbiAgICAgICAgRW1pc3NpdmVDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgIFN1cmZhY2VDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgIE5vcm1hbDp2ZWMzPGYzMj4sXG4gICAgICAgIFRhbmdlbnQ6dmVjNDxmMzI+LFxuICAgICAgICBXb3JsZFBvc2l0aW9uT2Zmc2V0OnZlYzM8ZjMyPixcbiAgICAgICAgQW1iaWVudE9jY2x1c2lvbjpmMzIsXG4gICAgICAgIFBpeGVsRGVwdGhPZmZzZXQ6ZjMyLFxuXG4gICAgICAgIE9wYWNpdHk6ZjMyLFxuICAgICAgICBPcGFjaXR5TWFzazpmMzIsXG5cbiAgICAgICAgUmVmcmFjdGlvbjpmMzIsXG4gICAgICAgIEZyYWdEZXB0aDpmMzJcbiAgICB9XG5gLFluPWBcbiAgICAjaWYgVVNFX0lFU19QUk9GSUxFIFxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIGllc1RleHR1cmVBcnJheU1hcFNhbXBsZXIgOiBzYW1wbGVyO1xuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIGllc1RleHR1cmVBcnJheU1hcDogdGV4dHVyZV8yZF9hcnJheTxmMzI+IDtcbiAgICAjZW5kaWZcblxuICAgIGZuIGdldExpZ2h0SUVTUHJvZmlsZUF0dCggd1BvcyA6IHZlYzM8ZjMyPiAsIGxpZ2h0OkxpZ2h0RGF0YSApIC0+IGYzMlxuICAgIHtcbiAgICAgICAgI2lmIFVTRV9JRVNfUFJPRklMRSBcbiAgICAgICAgICAgIGxldCB0YW5nZW50ID0gdmVjMzxmMzI+KDEuMCwwLjAsMC4wKTtcbiAgICAgICAgICAgIGxldCBsaWdodEJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHRhbmdlbnQsIGxpZ2h0LmRpcmVjdGlvbiApICk7XG4gICAgICAgICAgICBsZXQgbGlnaHRNYXRyaXggPSBtYXQ0eDQoIHZlYzQ8ZjMyPihsaWdodC5kaXJlY3Rpb24ueHl6LCAwLjApLCB2ZWM0PGYzMj4obGlnaHRCaXRhbmdlbnQueHl6LCAwLjApLCB2ZWM0PGYzMj4odGFuZ2VudC54eXosIDAuMCksIHZlYzQ8ZjMyPigwLjAsIDAuMCwgMC4wLCAxLjApICk7XG4gICAgICAgICAgICBsZXQgbGlnaHRNYXRyaXhJbnYgPSB0cmFuc3Bvc2UobGlnaHRNYXRyaXgpO1xuICAgICAgICAgICAgbGV0IGxpZ2h0UG9zID0gbGlnaHQucG9zaXRpb24ueHl6O1xuICAgICAgICAgICAgbGV0IGwgPSBsaWdodFBvcyAtIHdQb3M7IFxuICAgICAgICAgICAgbGV0IHRvTGlnaHQgPSBub3JtYWxpemUobCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxUb0xpZ2h0ID0gKHZlYzQ8ZjMyPih0b0xpZ2h0Lnh5eiwgMC4wKSAqIGxpZ2h0TWF0cml4SW52KS54eXo7XG4gICAgICAgICAgICBsZXQgZG90UHJvZCA9IGRvdCh0b0xpZ2h0LCBsaWdodC5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgbGV0IGFuZ2xlID0gYXNpbihkb3RQcm9kKTtcbiAgICAgICAgICAgIGxldCBub3JtQW5nbGUgPSAoYW5nbGUgLyBQSSkgKyAwLjUgO1xuICAgICAgICAgICAgbGV0IHRhbmdlbnRBbmdsZSA9IGF0YW4yKCAtbG9jYWxUb0xpZ2h0LnosIC1sb2NhbFRvTGlnaHQueCApOyBcbiAgICAgICAgICAgIGxldCBub3JtVGFuZ2VudEFuZ2xlID0gdGFuZ2VudEFuZ2xlIC8gKFBJICogMi4wKSArIDAuNSA7XG4gICAgICAgICAgICBpZihsaWdodC5pZXMgPj0gMC4wKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZVNhbXBsZUxldmVsKGllc1RleHR1cmVBcnJheU1hcCwgaWVzVGV4dHVyZUFycmF5TWFwU2FtcGxlciwgdmVjMjxmMzI+KG5vcm1BbmdsZSAsIG5vcm1UYW5nZW50QW5nbGUpICwgaTMyKGxpZ2h0LmllcykgLCAwLjApLnIgO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgI2Vsc2UgXG4gICAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICAjZW5kaWZcbiAgICB9XG5cbmAsWG49YFxuICAgICNpZiBVU0VfU0hBRE9XTUFQSU5HXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pIHZhciBzaGFkb3dNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKSB2YXIgc2hhZG93TWFwOiB0ZXh0dXJlX2RlcHRoXzJkX2FycmF5O1xuICAgICNlbmRpZlxuXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pIHZhciBwb2ludFNoYWRvd01hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pIHZhciBwb2ludFNoYWRvd01hcDogdGV4dHVyZV9kZXB0aF9jdWJlX2FycmF5O1xuXG4gICAgc3RydWN0IFNoYWRvd1N0cnVjdHtcbiAgICAgIGRpcmVjdFNoYWRvd1Zpc2liaWxpdHk6IGFycmF5PGYzMiwgOD4sXG4gICAgICBwb2ludFNoYWRvd3M6IGFycmF5PGYzMiwgOD4sXG4gICAgfVxuXG4gICAgdmFyPHByaXZhdGU+c2hhZG93U3RydXQ6IFNoYWRvd1N0cnVjdDtcblxuICAgIHN0cnVjdCBTaGFkb3dCdWZmZXJ7XG4gICAgICBuRGlyU2hhZG93U3RhcnQ6IGkzMixcbiAgICAgIG5EaXJTaGFkb3dFbmQ6IGkzMixcbiAgICAgIG5Qb2ludFNoYWRvd1N0YXJ0OiBpMzIsXG4gICAgICBuUG9pbnRTaGFkb3dFbmQ6IGkzMixcbiAgICAgIHNoYWRvd0xpZ2h0czphcnJheTx1MzIsMTY+XG4gICAgfVxuXG4gICAgI2lmIERFQlVHX0NMVVNURVJcbiAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDYpIHZhcjxzdG9yYWdlLHJlYWQ+IHNoYWRvd0J1ZmZlcjogU2hhZG93QnVmZmVyO1xuICAgICNlbHNlXG4gICAgICAgIEBncm91cCgyKSBAYmluZGluZyg1KSB2YXI8c3RvcmFnZSxyZWFkPiBzaGFkb3dCdWZmZXI6IFNoYWRvd0J1ZmZlcjtcbiAgICAjZW5kaWZcblxuICAgIGZuIHVzZVNoYWRvdygpe1xuICAgICAgICBzaGFkb3dTdHJ1dC5kaXJlY3RTaGFkb3dWaXNpYmlsaXR5ID0gYXJyYXk8ZjMyLCA4PiggMS4wLDEuMCwxLjAsMS4wLDEuMCwxLjAsMS4wLDEuMCkgO1xuICAgICAgICBzaGFkb3dTdHJ1dC5wb2ludFNoYWRvd3MgPSBhcnJheTxmMzIsIDg+KCAxLjAsMS4wLDEuMCwxLjAsMS4wLDEuMCwxLjAsMS4wKSA7XG4gICAgICAgIGRpcmVjdFNoYWRvd01hcGluZyhnbG9iYWxVbmlmb3JtLnNoYWRvd0JpYXMpO1xuICAgICAgICBwb2ludFNoYWRvd01hcENvbXBhcmUoZ2xvYmFsVW5pZm9ybS5wb2ludFNoYWRvd0JpYXMpO1xuICAgIH1cblxuICAgIGZuIGNhbGNCYXNpY0JpYXMoc2hhZG93V29ybGRTaXplOmYzMiwgc2hhZG93RGVwdGhUZXhTaXplOmYzMiwgbmVhcjpmMzIsIGZhcjpmMzIpIC0+IGYzMntcbiAgICAgIHZhciBiaWFzID0gc2hhZG93V29ybGRTaXplIC8gc2hhZG93RGVwdGhUZXhTaXplO1xuICAgICAgYmlhcyA9IGJpYXMgLyAoZmFyIC0gbmVhcik7XG4gICAgICByZXR1cm4gYmlhcyAqIDIuMDtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJDb3VudDppMzIgPSA4IDtcbiAgICBjb25zdCBwb2ludENvdW50OmkzMiA9IDggO1xuICAgIGNvbnN0IGNzbUNvdW50OmkzMiA9ICR7bHQuQ2FzY2FkZXN9IDtcbiAgICB2YXI8cHJpdmF0ZT4gY3NtTGV2ZWw6aTMyID0gLTE7XG4gICAgZm4gZGlyZWN0U2hhZG93TWFwaW5nKHNoYWRvd0JpYXM6IGYzMikgIHtcbiAgICAgICNpZiBVU0VfU0hBRE9XTUFQSU5HXG4gICAgICAgIGxldCBlbmFibGVDU006Ym9vbCA9IGdsb2JhbFVuaWZvcm0uZW5hYmxlQ1NNID4gMC41O1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAwOyBpIDwgZGlyQ291bnQgOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBpZiggaSA+PSBzaGFkb3dCdWZmZXIubkRpclNoYWRvd1N0YXJ0ICYmIGkgPCBzaGFkb3dCdWZmZXIubkRpclNoYWRvd0VuZCApe1xuICAgICAgICAgICAgbGV0IGxkeCA9IHNoYWRvd0J1ZmZlci5zaGFkb3dMaWdodHNbaV07XG4gICAgICAgICAgICB2YXIgbGlnaHQgPSBsaWdodEJ1ZmZlcltsZHhdO1xuICAgICAgICAgICAgdmFyIHNoYWRvd0luZGV4ID0gaTMyKGxpZ2h0LmNhc3RTaGFkb3cpO1xuICAgICAgICAgICAgdmFyIHZpc2liaWxpdHkgPSAxLjA7XG4gICAgICAgICAgICB2YXIgc2hhZG93TWF0cml4Om1hdDR4NDxmMzI+O1xuICAgICAgICAgICAgI2lmIFVTRV9DU01cbiAgICAgICAgICAgICAgaWYoZW5hYmxlQ1NNICYmIHNoYWRvd0luZGV4ID09IDApe1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbFdlaWdodCA9IDAuMDtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gMC4wO1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGNzbTppMzIgPSAwOyBjc20gPCBjc21Db3VudDsgY3NtICsrKXtcbiAgICAgICAgICAgICAgICAgIHZhciBjc21TaGFkb3dCaWFzID0gZ2xvYmFsVW5pZm9ybS5jc21TaGFkb3dCaWFzW2NzbV07XG4gICAgICAgICAgICAgICAgICBzaGFkb3dNYXRyaXggPSBnbG9iYWxVbmlmb3JtLmNzbU1hdHJpeFtjc21dO1xuICAgICAgICAgICAgICAgICAgbGV0IGNzbVNoYWRvd1Jlc3VsdCA9IGRpcmVjdFNoYWRvd01hcGluZ0luZGV4KGxpZ2h0LCBzaGFkb3dNYXRyaXgsIGNzbSwgY3NtU2hhZG93Qmlhcyk7XG4gICAgICAgICAgICAgICAgICBpZihjc21TaGFkb3dSZXN1bHQueSA8IDAuNSl7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkQ291bnQgKys7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2ID0gMi4wICogY3NtU2hhZG93UmVzdWx0Lnp3IC0gdmVjMjxmMzI+KDEuMCk7XG4gICAgICAgICAgICAgICAgICAgIHV2ID0gc2F0dXJhdGUodmVjMjxmMzI+KDEuMCkgLSBhYnModXYpKTtcbiAgICAgICAgICAgICAgICAgICAgdXYgLz0gY2xhbXAoZ2xvYmFsVW5pZm9ybS5jc21NYXJnaW4sIDAuMDEsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQ6ZjMyID0gbWluKHV2LngsIDEuMCk7XG4gICAgICAgICAgICAgICAgICAgIHdlaWdodCA9IG1pbih3ZWlnaHQsIHV2LnkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbGlkQ291bnQgPT0gMSAmJiBjc20gPT0gY3NtQ291bnQgLSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gMS4wIC0gd2VpZ2h0ICsgY3NtU2hhZG93UmVzdWx0LnggKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxXZWlnaHQgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgIHdlaWdodCAqPSAxLjAgLSB0b3RhbFdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ICs9IGNzbVNoYWRvd1Jlc3VsdC54ICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZih3ZWlnaHQgPCAxLjApe1xuICAgICAgICAgICAgICAgICAgICAvLyAgIHZpc2liaWxpdHkgKz0gMC4xO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbGlkQ291bnQgPj0gMiB8fCB0b3RhbFdlaWdodCA+PSAwLjk5KXtcbiAgICAgICAgICAgICAgICAgICAgICBjc21MZXZlbCA9IGNzbTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbFdlaWdodCArPSAwLjAwMDE7XG4gICAgICAgICAgICAgICAgaWYodmFsaWRDb3VudCA9PSAwKXtcbiAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSAxLjA7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gdmlzaWJpbGl0eSAvIHRvdGFsV2VpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgc2hhZG93TWF0cml4ID0gZ2xvYmFsVW5pZm9ybS5zaGFkb3dNYXRyaXhbc2hhZG93SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmKGVuYWJsZUNTTSkge1xuICAgICAgICAgICAgICAgICAgc2hhZG93SW5kZXggKz0gY3NtQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gZGlyZWN0U2hhZG93TWFwaW5nSW5kZXgobGlnaHQsIHNoYWRvd01hdHJpeCwgc2hhZG93SW5kZXgsIHNoYWRvd0JpYXMpLng7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgIHNoYWRvd01hdHJpeCA9IGdsb2JhbFVuaWZvcm0uc2hhZG93TWF0cml4W3NoYWRvd0luZGV4XTtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IGRpcmVjdFNoYWRvd01hcGluZ0luZGV4KGxpZ2h0LCBzaGFkb3dNYXRyaXgsIHNoYWRvd0luZGV4LCBzaGFkb3dCaWFzKS54O1xuICAgICAgICAgICAgI2VuZGlmIFxuICAgICAgICAgICAgc2hhZG93U3RydXQuZGlyZWN0U2hhZG93VmlzaWJpbGl0eVtpXSA9IHZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAjZW5kaWZcbiAgICB9XG5cbiAgICBmbiBkaXJlY3RTaGFkb3dNYXBpbmdJbmRleChsaWdodDpMaWdodERhdGEsIG1hdHJpeDptYXQ0eDQ8ZjMyPiwgZGVwdGhUZXhJbmRleDppMzIsIHNoYWRvd0JpYXM6ZjMyKSAtPiB2ZWM0PGYzMj5cbiAgICB7XG4gICAgICB2YXIgdmlzaWJpbGl0eSA9IDEuMDtcbiAgICAgIHZhciBpc091dFNpZGVBcmVhOmYzMiA9IDEuMDtcbiAgICAgIHZhciB2YXJ5aW5nX3NoYWRvd1VWOnZlYzI8ZjMyPiA9IHZlYzI8ZjMyPigwLjApO1xuICAgICAgI2lmIFVTRV9TSEFET1dNQVBJTkdcbiAgICAgICAgdmFyIHNoYWRvd1Bvc1RtcCA9IG1hdHJpeCAqIHZlYzQ8ZjMyPihPUklfVmVydGV4VmFyeWluZy52V29ybGRQb3MueHl6LCAxLjApO1xuICAgICAgICB2YXIgc2hhZG93UG9zID0gc2hhZG93UG9zVG1wLnh5eiAvIHNoYWRvd1Bvc1RtcC53O1xuICAgICAgICB2YXJ5aW5nX3NoYWRvd1VWID0gc2hhZG93UG9zLnh5ICogdmVjMjxmMzI+KDAuNSwgLTAuNSkgKyB2ZWMyPGYzMj4oMC41LCAwLjUpO1xuICAgICAgICBpZiAodmFyeWluZ19zaGFkb3dVVi54IDw9IDEuMFxuICAgICAgICAgICYmIHZhcnlpbmdfc2hhZG93VVYueCA+PSAwLjBcbiAgICAgICAgICAmJiB2YXJ5aW5nX3NoYWRvd1VWLnkgPD0gMS4wXG4gICAgICAgICAgJiYgdmFyeWluZ19zaGFkb3dVVi55ID49IDAuMFxuICAgICAgICAgICYmIHNoYWRvd1Bvc1RtcC56IDw9IDEuMFxuICAgICAgICAgICYmIHNoYWRvd1Bvc1RtcC56ID49IDAuMClcbiAgICAgICAge1xuICAgICAgICAgIHZpc2liaWxpdHkgPSAwLjA7XG4gICAgICAgICAgaXNPdXRTaWRlQXJlYSA9IDAuMDtcbiAgICAgICAgICB2YXIgdXZPbmVQaXhlbCA9IDEuMCAvIHZlYzI8ZjMyPihnbG9iYWxVbmlmb3JtLnNoYWRvd01hcFNpemUpO1xuICAgICAgICAgIHZhciB0b3RhbFdlaWdodCA9IDAuMDtcbiAgICAgICAgICB2YXIgTm9MID0gYWJzKGRvdChub3JtYWxpemUoT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkTm9ybWFsKSwgbm9ybWFsaXplKGxpZ2h0LmRpcmVjdGlvbikpKTtcbiAgICAgICAgICB2YXIgYmlhcyA9IHNoYWRvd0JpYXMgLyBtYXgoTm9MLCAwLjAwMDAwMSk7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IC0xOyB5IDw9IDE7IHkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IC0xOyB4IDw9IDE7IHgrKykge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdmVjMjxmMzI+KGYzMih4KSwgZjMyKHkpKSAqIHV2T25lUGl4ZWw7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyB2aXNpYmlsaXR5ICs9IHRleHR1cmVTYW1wbGVDb21wYXJlKHNoYWRvd01hcCwgc2hhZG93TWFwU2FtcGxlciwgdmFyeWluZ19zaGFkb3dVViArIG9mZnNldCwgZGVwdGhUZXhJbmRleCwgc2hhZG93UG9zLnogLSBiaWFzKTtcbiAgICAgICAgICAgICAgdmFyIGRlcHRoID0gdGV4dHVyZVNhbXBsZUxldmVsKHNoYWRvd01hcCwgc2hhZG93TWFwU2FtcGxlciwgdmFyeWluZ19zaGFkb3dVViArIG9mZnNldCwgZGVwdGhUZXhJbmRleCwgMCk7XG4gICAgICAgICAgICAgIGlmICgoc2hhZG93UG9zLnogLSBiaWFzICkgPCBkZXB0aCkge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgKz0gMS4wIDsvLyogZG90KG9mZnNldERpciwgZGlyLnh5eik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG90YWxXZWlnaHQgKz0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2aXNpYmlsaXR5IC89IHRvdGFsV2VpZ2h0O1xuICAgICAgICAgIHZpc2liaWxpdHkgKz0gMC4wMDE7XG4gICAgICAgIH1cbiAgICAgICNlbmRpZlxuICAgICAgcmV0dXJuIHZlYzQ8ZjMyPih2aXNpYmlsaXR5LCBpc091dFNpZGVBcmVhLCB2YXJ5aW5nX3NoYWRvd1VWKTtcbiAgICB9XG5cbiAgICBmbiBwb2ludFNoYWRvd01hcENvbXBhcmUoc2hhZG93QmlhczogZjMyKXtcbiAgICAgIGxldCB3b3JsZFBvcyA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZFBvcy54eXo7XG4gICAgICBsZXQgb2Zmc2V0ID0gMC4xO1xuXG4gICAgICBmb3IgKHZhciBpOiBpMzIgPSAwOyBpIDwgcG9pbnRDb3VudCA7IGkgPSBpICsgMSkge1xuICAgICAgICBpZiggaSA+PSBzaGFkb3dCdWZmZXIublBvaW50U2hhZG93U3RhcnQgJiYgaSA8IHNoYWRvd0J1ZmZlci5uUG9pbnRTaGFkb3dFbmQgKXtcbiAgICAgICAgICBsZXQgbGR4ID0gc2hhZG93QnVmZmVyLnNoYWRvd0xpZ2h0c1tpXTtcbiAgICAgICAgICBsZXQgbGlnaHQgPSBsaWdodEJ1ZmZlcltsZHhdIDtcblxuICAgICAgICAgICNpZiBVU0VfU0hBRE9XTUFQSU5HXG4gICAgICAgICAgbGV0IGxpZ2h0UG9zID0gbGlnaHQucG9zaXRpb24ueHl6O1xuICAgICAgICAgIHZhciBzaGFkb3cgPSAwLjA7XG4gICAgICAgICAgbGV0IGZyZ1RvTGlnaHQgPSB3b3JsZFBvcyAtIGxpZ2h0UG9zLnh5ejtcbiAgICAgICAgICB2YXIgZGlyOiB2ZWMzPGYzMj4gPSBub3JtYWxpemUoZnJnVG9MaWdodCk7XG4gICAgICAgICAgdmFyIGxlbiA9IGxlbmd0aChmcmdUb0xpZ2h0KTtcbiAgICAgICAgICB2YXIgYmlhcyA9IG1heChzaGFkb3dCaWFzICogZ2xvYmFsVW5pZm9ybS5mYXIgKiAoMS4wIC0gZG90KE9SSV9TaGFkaW5nSW5wdXQuTm9ybWFsLCBkaXIpKSwgMC4wMDUpO1xuICBcbiAgICAgICAgICAjaWYgVVNFX1BDRl9TSEFET1dcbiAgICAgICAgICBsZXQgc2FtcGxlcyA9IDQuMDtcbiAgICAgICAgICBmb3IgKHZhciB4OiBmMzIgPSAtb2Zmc2V0OyB4IDwgb2Zmc2V0OyB4ICs9IG9mZnNldCAvIChzYW1wbGVzICogMC41KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeTogZjMyID0gLW9mZnNldDsgeSA8IG9mZnNldDsgeSArPSBvZmZzZXQgLyAoc2FtcGxlcyAqIDAuNSkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgejogZjMyID0gLW9mZnNldDsgeiA8IG9mZnNldDsgeiArPSBvZmZzZXQgLyAoc2FtcGxlcyAqIDAuNSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0RGlyID0gbm9ybWFsaXplKGRpci54eXogKyB2ZWMzPGYzMj4oeCwgeSwgeikpO1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IHRleHR1cmVTYW1wbGVMZXZlbChwb2ludFNoYWRvd01hcCwgcG9pbnRTaGFkb3dNYXBTYW1wbGVyLCBvZmZzZXREaXIsIGxpZ2h0LmNhc3RTaGFkb3csIDApO1xuICAgICAgICAgICAgICAgIGRlcHRoICo9IGdsb2JhbFVuaWZvcm0uZmFyO1xuICAgICAgICAgICAgICAgIGlmICgobGVuIC0gYmlhcykgPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgc2hhZG93ICs9IDEuMCAqIGRvdChvZmZzZXREaXIsIGRpci54eXopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzaGFkb3cgPSBtaW4obWF4KHNoYWRvdyAvIChzYW1wbGVzICogc2FtcGxlcyAqIHNhbXBsZXMpLCAwLjApLCAxLjApO1xuICAgICAgICAgICNlbmRpZlxuICBcbiAgICAgICAgICAjaWYgVVNFX1NPRlRfU0hBRE9XXG4gICAgICAgICAgbGV0IHZEaXMgPSBsZW5ndGgoZ2xvYmFsVW5pZm9ybS5DYW1lcmFQb3MueHl6IC0gd29ybGRQb3MueHl6KTtcbiAgICAgICAgICBsZXQgc2FtcGxlUmFkaWVzID0gZ2xvYmFsVW5pZm9ybS5zaGFkb3dTb2Z0O1xuICAgICAgICAgIGxldCBzYW1wbGVzID0gMjA7XG4gICAgICAgICAgZm9yICh2YXIgajogaTMyID0gMDsgaiA8IHNhbXBsZXM7IGogKz0gMSkge1xuICAgICAgICAgICAgbGV0IG9mZnNldERpciA9IG5vcm1hbGl6ZShkaXIueHl6ICsgc2FtcGxlT2Zmc2V0RGlyW2pdICogc2FtcGxlUmFkaWVzKTtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IHRleHR1cmVTYW1wbGVMZXZlbChwb2ludFNoYWRvd01hcCwgcG9pbnRTaGFkb3dNYXBTYW1wbGVyLCBvZmZzZXREaXIsIGxpZ2h0LmNhc3RTaGFkb3csIDApO1xuICAgICAgICAgICAgZGVwdGggKj0gZ2xvYmFsVW5pZm9ybS5mYXI7XG4gICAgICAgICAgICBpZiAoKGxlbiAtIGJpYXMpID4gZGVwdGgpIHtcbiAgICAgICAgICAgICAgc2hhZG93ICs9IDEuMCAqIGRvdChvZmZzZXREaXIsIGRpci54eXopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzaGFkb3cgPSBtaW4obWF4KHNoYWRvdyAvIGYzMihzYW1wbGVzKSwgMC4wKSwgMS4wKTtcbiAgICAgICAgICAjZW5kaWZcbiAgXG4gICAgICAgICAgI2lmIFVTRV9IQVJEX1NIQURPV1xuICAgICAgICAgIHZhciBkZXB0aCA9IHRleHR1cmVTYW1wbGVMZXZlbChwb2ludFNoYWRvd01hcCwgcG9pbnRTaGFkb3dNYXBTYW1wbGVyLCBkaXIueHl6LCBsaWdodC5jYXN0U2hhZG93LCAwKTtcbiAgICAgICAgICBkZXB0aCAqPSBnbG9iYWxVbmlmb3JtLmZhcjtcbiAgICAgICAgICBpZiAoKGxlbiAtIGJpYXMpID4gZGVwdGgpIHtcbiAgICAgICAgICAgIHNoYWRvdyA9IDEuMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgI2VuZGlmXG4gIFxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRDb3VudCA7IGorPTEgKSB7XG4gICAgICAgICAgICAgIGlmKGkzMihsaWdodC5jYXN0U2hhZG93KSA9PSBqKXtcbiAgICAgICAgICAgICAgICBzaGFkb3dTdHJ1dC5wb2ludFNoYWRvd3Nbal0gPSAxLjAgLSBzaGFkb3cgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICNlbmRpZlxuICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAjaWYgVVNFX1NPRlRfU0hBRE9XXG4gICAgdmFyPHByaXZhdGU+c2FtcGxlT2Zmc2V0RGlyIDogYXJyYXk8dmVjMzxmMzI+LCAyMD4gPSBhcnJheTx2ZWMzPGYzMj4sIDIwPihcbiAgICAgIHZlYzM8ZjMyPigxLjAsIDEuMCwgMS4wKSwgdmVjMzxmMzI+KDEuMCwgLTEuMCwgMS4wKSwgdmVjMzxmMzI+KC0xLjAsIC0xLjAsIDEuMCksIHZlYzM8ZjMyPigtMS4wLCAxLjAsIDEuMCksXG4gICAgICB2ZWMzPGYzMj4oMS4wLCAxLjAsIC0xLjApLCB2ZWMzPGYzMj4oMS4wLCAtMS4wLCAtMS4wKSwgdmVjMzxmMzI+KC0xLjAsIC0xLjAsIC0xLjApLCB2ZWMzPGYzMj4oLTEuMCwgMS4wLCAtMS4wKSxcbiAgICAgIHZlYzM8ZjMyPigxLjAsIDEuMCwgMC4wKSwgdmVjMzxmMzI+KDEuMCwgLTEuMCwgMC4wKSwgdmVjMzxmMzI+KC0xLjAsIC0xLjAsIDAuMCksIHZlYzM8ZjMyPigtMS4wLCAxLjAsIDAuMCksXG4gICAgICB2ZWMzPGYzMj4oMS4wLCAwLjAsIDEuMCksIHZlYzM8ZjMyPigtMS4wLCAwLjAsIDEuMCksIHZlYzM8ZjMyPigxLjAsIDAuMCwgLTEuMCksIHZlYzM8ZjMyPigtMS4wLCAwLjAsIC0xLjApLFxuICAgICAgdmVjMzxmMzI+KDAuMCwgMS4wLCAxLjApLCB2ZWMzPGYzMj4oMC4wLCAtMS4wLCAxLjApLCB2ZWMzPGYzMj4oMC4wLCAtMS4wLCAtMS4wKSwgdmVjMzxmMzI+KDAuMCwgMS4wLCAtMS4wKSxcbiAgICApO1xuICAgICNlbmRpZlxuYCxXbj1gXG4jaW5jbHVkZSBcIklycmFkaWFuY2VWb2x1bWVEYXRhX2ZyYWdcIlxuICAgIGZuIHBvdzMoICB4IDogZjMyICkgLT4gZjMyXG4gICAge1xuICAgICAgICByZXR1cm4geCp4Kng7XG4gICAgfVxuXG4gICAgc3RydWN0IElycmFkaWFuY2VGaWVsZCB7XG4gICAgICAgIHByb2JlU3RhcnRQb3NpdGlvbjogdmVjNDxmMzI+LFxuICAgICAgICBwcm9iZUNvdW50czp2ZWM0PGYzMj4sXG4gICAgICAgIHByb2JlU3RlcDpmMzIsXG4gICAgICAgIGlycmFkaWFuY2VUZXh0dXJlV2lkdGg6ZjMyLFxuICAgICAgICBpcnJhZGlhbmNlVGV4dHVyZUhlaWdodDpmMzIsXG4gICAgICAgIGlycmFkaWFuY2VQcm9iZVNpZGVMZW5ndGg6ZjMyLFxuICAgIH07XG5cbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgaXJyYWRpYW5jZU1hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgdmFyIGlycmFkaWFuY2VNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgaXJyYWRpYW5jZURlcHRoTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgaXJyYWRpYW5jZURlcHRoTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgQGdyb3VwKDIpIEBiaW5kaW5nKDcpXG4gICAgdmFyPHN0b3JhZ2UscmVhZD4gaXJyYWRpYW5jZURhdGEgOiBJcnJhZGlhbmNlVm9sdW1lRGF0YSA7XG5cbiAgICB2YXI8cHJpdmF0ZT4gaXJyYWRpYW5jZUZpZWxkU3VyZmFjZTogSXJyYWRpYW5jZUZpZWxkO1xuICAgIHZhcjxwcml2YXRlPiBlbmVyZ3lQcmVzZXJ2YXRpb246IGYzMiA9IDAuODU7XG4gICAgdmFyPHByaXZhdGU+IHF1YXRlcm5pb246dmVjNDxmMzI+ID0gdmVjNDxmMzI+KDAuMCwgLTAuNzA3MTA2NzgxMTg2NTQ3NSwgMC43MDcxMDY3ODExODY1NDc1LCAwLjApO1xuXG4gICAgZm4gZ2V0SXJyYWRpYW5jZUZpZWxkU3VyZmFjZSgpIC0+IElycmFkaWFuY2VGaWVsZHtcbiAgICAgICAgbGV0IGRhdGEgPSBpcnJhZGlhbmNlRGF0YSA7XG4gICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVTdGFydFBvc2l0aW9uID0gdmVjNDxmMzI+KGRhdGEuc3RhcnRYLCBkYXRhLnN0YXJ0WSwgZGF0YS5zdGFydFosIDAuMCk7XG4gICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVDb3VudHMgPSB2ZWM0PGYzMj4oZGF0YS5ncmlkWENvdW50LCBkYXRhLmdyaWRZQ291bnQsIGRhdGEuZ3JpZFpDb3VudCwgMC4wKTtcbiAgICAgICAgaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZVN0ZXAgPSBkYXRhLlByb2JlU3BhY2U7XG4gICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVRleHR1cmVXaWR0aCA9IGRhdGEuT2N0UlRNYXhTaXplO1xuICAgICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlSGVpZ2h0ID0gZGF0YS5PY3RSVE1heFNpemU7XG4gICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVByb2JlU2lkZUxlbmd0aCA9IGRhdGEuT2N0UlRTaWRlU2l6ZTtcbiAgICAgICAgcmV0dXJuIGlycmFkaWFuY2VGaWVsZFN1cmZhY2U7XG4gICAgfVxuXG4gICAgZm4gcm90YXRlRGlyKG46dmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj57XG4gICAgICAgcmV0dXJuIG5vcm1hbGl6ZShhcHBseVF1YXRlcm5pb24oLW4sIHF1YXRlcm5pb24pKTtcbiAgICB9XG5cbiAgICBmbiBzcXVhcmUxZih2OmYzMikgLT4gZjMyIHtcbiAgICAgICAgcmV0dXJuIHYgKiB2IDtcbiAgICAgfVxuXG4gICBmbiBzcXVhcmUodjp2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPntcbiAgICAgIHJldHVybiB2KnY7XG4gICB9XG5cbiAgICBmbiBnZXRJcnJhZGlhbmNlKCkgLT4gdmVjNDxmMzI+e1xuICAgICAgICB2YXIgaXJyYWRpYW5jZSA9IHNhbXBsZUlycmFkaWFuY2VGaWVsZCgpO1xuICAgICAgICB2YXIgb3V0ZXJWb2x1bWVGYWN0b3I6ZjMyID0gZ2V0T3V0ZXJWb2x1bWUoaXJyYWRpYW5jZUZpZWxkU3VyZmFjZSwgT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5eik7XG4gICAgICAgIGlycmFkaWFuY2UgKj0gb3V0ZXJWb2x1bWVGYWN0b3I7XG4gICAgICAgcmV0dXJuIGlycmFkaWFuY2UgO1xuICAgIH1cbiAgICBcbiAgICBmbiBkZWJ1Z1Byb2JlKGlkOmkzMikgLT4gdmVjNDxmMzI+e1xuICAgICAgICBnZXRJcnJhZGlhbmNlRmllbGRTdXJmYWNlKCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBub3JtYWxpemUoT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkTm9ybWFsKTtcbiAgICAgICAgZGlyZWN0aW9uID0gYXBwbHlRdWF0ZXJuaW9uKC1kaXJlY3Rpb24sIHF1YXRlcm5pb24pO1xuICAgICAgICB2YXIgcHJvYmVUZXh0dXJlVVYgOiB2ZWMyPGYzMj4gPSB0ZXh0dXJlQ29vcmRGcm9tRGlyZWN0aW9uKG5vcm1hbGl6ZShkaXJlY3Rpb24pLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlV2lkdGgsXG4gICAgICAgICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlSGVpZ2h0LFxuICAgICAgICAgICAgaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5pcnJhZGlhbmNlUHJvYmVTaWRlTGVuZ3RoKTtcblxuICAgICAgICB2YXIgcHJvYmVJcnJhZGlhbmNlOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlTGV2ZWwoaXJyYWRpYW5jZU1hcCwgaXJyYWRpYW5jZU1hcFNhbXBsZXIsIHByb2JlVGV4dHVyZVVWICwwLjApO1xuICAgICAgICByZXR1cm4gcHJvYmVJcnJhZGlhbmNlO1xuICAgIH1cbiAgICBcbiAgICBmbiBkZWJ1Z1Byb2JlRGVwdGgoaWQ6aTMyKSAtPiB2ZWM0PGYzMj57XG4gICAgICAgIGdldElycmFkaWFuY2VGaWVsZFN1cmZhY2UoKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZShPUklfVmVydGV4VmFyeWluZy52V29ybGROb3JtYWwpO1xuICAgICAgICBkaXJlY3Rpb24gPSBhcHBseVF1YXRlcm5pb24oLWRpcmVjdGlvbiwgcXVhdGVybmlvbik7XG4gICAgICAgIHZhciBwcm9iZVRleHR1cmVVViA6IHZlYzI8ZjMyPiA9IHRleHR1cmVDb29yZEZyb21EaXJlY3Rpb24obm9ybWFsaXplKGRpcmVjdGlvbiksXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVRleHR1cmVXaWR0aCxcbiAgICAgICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVRleHR1cmVIZWlnaHQsXG4gICAgICAgICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VQcm9iZVNpZGVMZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHByb2JlSXJyYWRpYW5jZTogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKGlycmFkaWFuY2VEZXB0aE1hcCwgaXJyYWRpYW5jZURlcHRoTWFwU2FtcGxlciwgcHJvYmVUZXh0dXJlVVYgLDAuMCk7XG4gICAgICAgIHByb2JlSXJyYWRpYW5jZS54ID0gcHJvYmVJcnJhZGlhbmNlLnggLyBpcnJhZGlhbmNlRGF0YS5tYXhEaXN0YW5jZTtcbiAgICAgICAgcHJvYmVJcnJhZGlhbmNlLnkgPSAwLjA7XG4gICAgICAgIHByb2JlSXJyYWRpYW5jZS56ID0gMC4wO1xuICAgICAgICBwcm9iZUlycmFkaWFuY2UudyA9IDEuMDtcbiAgICAgICAgcmV0dXJuIHByb2JlSXJyYWRpYW5jZTtcbiAgICB9XG4gICAgXG4gICAgZm4gZ2V0T3V0ZXJWb2x1bWUoTDpJcnJhZGlhbmNlRmllbGQsIHBvc2l0aW9uOnZlYzM8ZjMyPikgLT4gZjMye1xuICAgICAgICBsZXQgaGFsZldpZHRoOnZlYzM8ZjMyPiA9IDAuNSAqIChMLnByb2JlQ291bnRzLnh5eiAtIDEuMCkgKiBMLnByb2JlU3RlcDtcbiAgICAgICAgbGV0IGVkZ2VXaWR0aDp2ZWMzPGYzMj4gPSBoYWxmV2lkdGggKyBMLnByb2JlU3RlcDtcbiAgICAgICAgbGV0IGNlbnRlclBvc2l0aW9uOnZlYzM8ZjMyPiA9IGhhbGZXaWR0aCArIEwucHJvYmVTdGFydFBvc2l0aW9uLnh5ejtcbiAgICAgICAgbGV0IGNsYW1wUG9zID0gbWluKGVkZ2VXaWR0aCwgYWJzKHBvc2l0aW9uIC0gY2VudGVyUG9zaXRpb24pKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBmYWN0b3JYID0gZ2V0T3V0ZXJBeGlzKGNsYW1wUG9zLngsIGVkZ2VXaWR0aC54LCBMLnByb2JlU3RlcCk7XG4gICAgICAgIGxldCBmYWN0b3JZID0gZ2V0T3V0ZXJBeGlzKGNsYW1wUG9zLnksIGVkZ2VXaWR0aC55LCBMLnByb2JlU3RlcCk7XG4gICAgICAgIGxldCBmYWN0b3JaID0gZ2V0T3V0ZXJBeGlzKGNsYW1wUG9zLnosIGVkZ2VXaWR0aC56LCBMLnByb2JlU3RlcCk7XG4gICAgICAgIHJldHVybiBmYWN0b3JYICogZmFjdG9yWSAqIGZhY3Rvclo7XG4gICAgfVxuICAgIFxuICAgIGZuIGdldE91dGVyQXhpcyhjdXJyZW50OmYzMiwgZWRnZTpmMzIsIHNwYWNlOmYzMikgLT4gZjMye1xuICAgICAgICByZXR1cm4gY2xhbXAoKGVkZ2UgLSBjdXJyZW50KSAvIHNwYWNlLCAwLjAsIDEuMCk7XG4gICAgfVxuXG4gICAgZm4gZ2V0QmFzZUdyaWRDb29yZChMOklycmFkaWFuY2VGaWVsZCwgWDp2ZWMzPGYzMj4pIC0+IHZlYzM8aTMyPiB7XG4gICAgICAgIHZhciBvZmZzZXRJbmRleCA9IChYIC0gTC5wcm9iZVN0YXJ0UG9zaXRpb24ueHl6KSAvIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVTdGVwO1xuICAgICAgICByZXR1cm4gY2xhbXAodmVjMzxpMzI+KG9mZnNldEluZGV4Lnh5eiksIHZlYzM8aTMyPigwKSwgdmVjMzxpMzI+KEwucHJvYmVDb3VudHMueHl6KSAtIDEpO1xuICAgIH1cblxuICAgIGZuIGdyaWRDb29yZFRvUHJvYmVJbmRleChMOklycmFkaWFuY2VGaWVsZCwgZ3JpZDp2ZWMzPGkzMj4pIC0+IGkzMlxuICAgIHtcbiAgICAgICAgcmV0dXJuIGdyaWQueCArIGkzMihMLnByb2JlQ291bnRzLngpICogZ3JpZC56ICsgZ3JpZC55ICogaTMyKEwucHJvYmVDb3VudHMueiAqIEwucHJvYmVDb3VudHMueCk7XG4gICAgfVxuXG4gICAgZm4gZ3JpZENvb3JkVG9Qb3NpdGlvbihMOklycmFkaWFuY2VGaWVsZCwgZ3JpZDp2ZWMzPGkzMj4pIC0+IHZlYzM8ZjMyPlxuICAgIHtcbiAgICAgICAgdmFyIHBvczp2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oZ3JpZC54eXopICogTC5wcm9iZVN0ZXAgKyBMLnByb2JlU3RhcnRQb3NpdGlvbi54eXo7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgZm4gdGV4dHVyZUNvb3JkRnJvbURpcmVjdGlvbihkaXI6dmVjMzxmMzI+LCBwcm9iZUluZGV4OmkzMiwgd2lkdGg6ZjMyLCBoZWlnaHQ6ZjMyLCBzaWRlTGVuZ3RoOmYzMikgLT4gdmVjMjxmMzI+XG4gICAge1xuICAgICAgICB2YXIgdXYgPSBnZXRXcml0ZU9jdFVWQnlJRChkaXIsIHUzMihwcm9iZUluZGV4KSwgc2lkZUxlbmd0aCkgO1xuICAgICAgICB1di54ID0gdXYueCAvIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVRleHR1cmVXaWR0aDtcbiAgICAgICAgdXYueSA9IHV2LnkgLyBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlSGVpZ2h0O1xuICAgICAgICByZXR1cm4gdXYgO1xuICAgIH1cblxuICAgIGZuIGdldFdyaXRlT2N0VVZCeUlEKGRpcjp2ZWMzPGYzMj4gLCBwcm9iZUlEOnUzMiwgc2l6ZTogZjMyKSAtPiB2ZWMyPGYzMj5cbiAgICB7XG4gICAgICAgIHZhciBibG9ja0NvdW50ID0gdTMyKGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVDb3VudHMueCAqIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVDb3VudHMueikgO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IChwcm9iZUlEICUgYmxvY2tDb3VudCkgJSB1MzIoaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZUNvdW50cy54KSA7XG4gICAgICAgIHZhciBvZmZzZXRZID0gdTMyKGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVDb3VudHMueiAtIDEuMCkgLSAocHJvYmVJRCAlIGJsb2NrQ291bnQpIC8gdTMyKGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVDb3VudHMueCkgO1xuICAgICAgICB2YXIgb2Zmc2V0WiA9IHByb2JlSUQgLyBibG9ja0NvdW50IDtcblxuICAgICAgICB2YXIgcGl4ZWxDb29yZCA9ICgoIG9jdEVuY29kZShkaXIpICsgMS4wICkgKiAwLjUpICogdmVjMjxmMzI+KHNpemUsc2l6ZSkgO1xuXG4gICAgICAgIHZhciBibG9ja09mZnNldCA9IHZlYzI8ZjMyPigwLjApO1xuICAgICAgICBibG9ja09mZnNldC54ID0gZjMyKG9mZnNldFgpICogc2l6ZTtcbiAgICAgICAgYmxvY2tPZmZzZXQueSA9IGYzMihvZmZzZXRZKSAqIHNpemUgKyBmMzIob2Zmc2V0WikgKiBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLnByb2JlQ291bnRzLnogKiBzaXplO1xuXG4gICAgICAgIGxldCBtYXBIZWlnaHQgPSB1MzIoaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5pcnJhZGlhbmNlVGV4dHVyZUhlaWdodCk7XG4gICAgICAgIHZhciBwcm9iZUNvdW50czp2ZWMzPGYzMj4gPSBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLnByb2JlQ291bnRzLnh5ejtcblxuICAgICAgICB2YXIgZ3JpZE9mZnNldEZyb20gPSB2ZWMyPGkzMj4oYmxvY2tPZmZzZXQpICsgMTtcbiAgICAgICAgdmFyIGdyaWRPZmZzZXRUbyA9IG9mZnNldEJ5Q29sKGdyaWRPZmZzZXRGcm9tLCBzaXplLCBtYXBIZWlnaHQsIHByb2JlQ291bnRzKTtcblxuICAgICAgICBwaXhlbENvb3JkID0gcGl4ZWxDb29yZCArIHZlYzI8ZjMyPihncmlkT2Zmc2V0VG8gLSAxKSArIHZlYzI8ZjMyPih2ZWMyPGkzMj4odmVjMjxmMzI+KGdyaWRPZmZzZXRUbykgLyBzaXplKSAqIDIpO1xuXG4gICAgICAgIHJldHVybiBwaXhlbENvb3JkICsgMS4wIDtcbiAgICB9XG5cbiAgICBmbiBvZmZzZXRCeUNvbChwaXhlbENvb3JkMDp2ZWMyPGkzMj4sIG9jdFNpZGVTaXplOmYzMiwgbWFwSGVpZ2h0OnUzMiwgY291bnRzOnZlYzM8ZjMyPikgLT4gdmVjMjxpMzI+XG4gICAge1xuICAgICAgdmFyIHBpeGVsQ29vcmQgPSBwaXhlbENvb3JkMDtcbiAgICAgIGxldCBibG9ja1NpemU6dmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy54KSwgIGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy56KSk7XG4gICAgICBsZXQgYmxvY2tTaXplWUJvcmRlcjppMzIgPSBpMzIoKG9jdFNpZGVTaXplICsgMi4wKSAqIGNvdW50cy56KTtcbiAgICAgIGxldCBibG9ja01heFJvd0JvcmRlcjppMzIgPSBpMzIobWFwSGVpZ2h0KSAvIGJsb2NrU2l6ZVlCb3JkZXI7XG4gICAgICBsZXQgcGl4ZWxDb3VudFlNYXg6aTMyID0gYmxvY2tNYXhSb3dCb3JkZXIgKiBpMzIob2N0U2lkZVNpemUgKiBjb3VudHMueik7XG4gICAgICBsZXQgY29sOmkzMiA9IHBpeGVsQ29vcmQueSAvIHBpeGVsQ291bnRZTWF4O1xuICAgICAgcGl4ZWxDb29yZC54ID0gY29sICogaTMyKG9jdFNpZGVTaXplICogY291bnRzLngpICsgcGl4ZWxDb29yZC54O1xuICAgICAgcGl4ZWxDb29yZC55ID0gcGl4ZWxDb29yZC55ICUgcGl4ZWxDb3VudFlNYXg7XG4gICAgICByZXR1cm4gcGl4ZWxDb29yZDtcbiAgICB9XG5cbiAgICB2YXI8cHJpdmF0ZT4gd3BOb3JtYWw6dmVjMzxmMzI+IDtcbiAgICBmbiBzYW1wbGVJcnJhZGlhbmNlRmllbGQoKSAtPiB2ZWM0PGYzMj57XG4gICAgICAgIHdwTm9ybWFsID0gT1JJX1NoYWRpbmdJbnB1dC5Ob3JtYWwueHl6IDtcbiAgICAgICAgdmFyIHdvOnZlYzM8ZjMyPiA9IE9SSV9DYW1lcmFXb3JsZERpciA7XG4gICAgICAgIHZhciB3c046dmVjMzxmMzI+ID0gbm9ybWFsaXplKHdwTm9ybWFsKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbjp2ZWMzPGYzMj4gPSB3cE5vcm1hbDtcbiAgICAgICAgdmFyIHdvcmxkUG9zaXRpb246IHZlYzM8ZjMyPiA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZFBvcy54eXo7XG4gICBcbiAgICAgICAgZ2V0SXJyYWRpYW5jZUZpZWxkU3VyZmFjZSgpO1xuXG4gICAgICAgIGxldCBzdXJmYWNlQmlhcyA9ICh3c04gKyAzLjAgKiB3bykgKiBpcnJhZGlhbmNlRGF0YS5ub3JtYWxCaWFzIDtcblxuICAgICAgICB2YXIgaXJyYWRpYW5jZSA9IHZlYzM8ZjMyPigwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGVkV2VpZ2h0cyA9IDAuMDtcbiAgICAgICAgdmFyIGJpYXNlZFdvcmxkUG9zaXRpb24gPSAod29ybGRQb3NpdGlvbiArIHN1cmZhY2VCaWFzKTtcblxuICAgICAgICB2YXIgYmFzZVByb2JlQ29vcmRzOiB2ZWMzPGkzMj4gPSBnZXRCYXNlR3JpZENvb3JkKGlycmFkaWFuY2VGaWVsZFN1cmZhY2UsIHdvcmxkUG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgdmFyIGJhc2VQcm9iZVdvcmxkUG9zaXRpb246IHZlYzM8ZjMyPiA9IGdyaWRDb29yZFRvUG9zaXRpb24oaXJyYWRpYW5jZUZpZWxkU3VyZmFjZSwgYmFzZVByb2JlQ29vcmRzKSA7XG4gICAgICAgIFxuICAgICAgICB2YXIgZ3JpZFNwYWNlRGlzdGFuY2UgPSAoYmlhc2VkV29ybGRQb3NpdGlvbiAtIGJhc2VQcm9iZVdvcmxkUG9zaXRpb24pO1xuXG4gICAgICAgIC8vIGFscGhhIGlzIGhvdyBmYXIgZnJvbSB0aGUgZmxvb3IoY3VycmVudFZlcnRleCkgcG9zaXRpb24uIG9uIFswLCAxXSBmb3IgZWFjaCBheGlzLlxuICAgICAgICB2YXIgYWxwaGE6IHZlYzM8ZjMyPiA9IGNsYW1wKGdyaWRTcGFjZURpc3RhbmNlIC8gKGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVTdGVwKSwgdmVjMzxmMzI+KDAuMCksIHZlYzM8ZjMyPigxLjApKTtcbiAgICAgICAgLy8gbGV0IGlycmFkaWFuY2VEaXIgPSByb3RhdGVEaXIod3NOLnh5eik7XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhZGphY2VudCBwcm9iZSBjYWdlXG4gICAgICAgIGZvciAodmFyIGk6aTMyID0gMDsgaSA8IDg7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgdmFyIGFkamFjZW50UHJvYmVPZmZzZXQgOiB2ZWMzPGkzMj4gPSB2ZWMzPGkzMj4oaSwgaTMyKGYzMihpKSAqIDAuNSksIGkzMihmMzIoaSkgKiAwLjI1KSkgJiB2ZWMzPGkzMj4oMSk7XG4gICAgICAgICAgICB2YXIgYWRqYWNlbnRQcm9iZUNvb3JkczogdmVjMzxpMzI+ID0gY2xhbXAoYmFzZVByb2JlQ29vcmRzICsgYWRqYWNlbnRQcm9iZU9mZnNldCwgdmVjMzxpMzI+KDApLCAgdmVjMzxpMzI+KGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVDb3VudHMueHl6KSAtIDEpIDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGFkamFjZW50UHJvYmVJbmRleCA6aTMyID0gZ3JpZENvb3JkVG9Qcm9iZUluZGV4KGlycmFkaWFuY2VGaWVsZFN1cmZhY2UsIGFkamFjZW50UHJvYmVDb29yZHMpO1xuICAgICAgICAgICAgdmFyIGFkamFjZW50UHJvYmVXb3JsZFBvc2l0aW9uIDp2ZWMzPGYzMj4gPSBncmlkQ29vcmRUb1Bvc2l0aW9uKGlycmFkaWFuY2VGaWVsZFN1cmZhY2UsIGFkamFjZW50UHJvYmVDb29yZHMpIDsvLysgKHdzTiArIDMuMCAqIHdfbykgKiBnbG9iYWxVbmlmb3JtLm5vcm1hbEJpYXM7XG4gICAgICAgICBcbiAgICAgICAgICAgIHZhciB3b3JsZFBvc1RvQWRqUHJvYmUgPSBub3JtYWxpemUoYWRqYWNlbnRQcm9iZVdvcmxkUG9zaXRpb24gLSB3b3JsZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBiaWFzZWRQb3NUb0FkalByb2JlID0gbm9ybWFsaXplKGFkamFjZW50UHJvYmVXb3JsZFBvc2l0aW9uIC0gYmlhc2VkV29ybGRQb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgYmlhc2VkUG9zVG9BZGpQcm9iZURpc3QgPSBsZW5ndGgoYWRqYWNlbnRQcm9iZVdvcmxkUG9zaXRpb24gLSBiaWFzZWRXb3JsZFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgbGV0IHRyaWxpbmVhciA9IG1heCh2ZWMzPGYzMj4oMC4wMDEpLCBtaXgoMS4wIC0gYWxwaGEsIGFscGhhLCB2ZWMzPGYzMj4oYWRqYWNlbnRQcm9iZU9mZnNldCkpKTtcbiAgICAgICAgICAgIGxldCB0cmlsaW5lYXJXZWlnaHQgPSAodHJpbGluZWFyLnggKiB0cmlsaW5lYXIueSAqIHRyaWxpbmVhci56KTtcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSAxLjA7XG5cbiAgICAgICAgICAgIHZhciB3cmFwU2hhZGluZyA9IChkb3Qod29ybGRQb3NUb0FkalByb2JlLCBkaXJlY3Rpb24pICsgMS4wKSAqIDAuNTtcbiAgICAgICAgICAgIHdlaWdodCAqPSAod3JhcFNoYWRpbmcgKiB3cmFwU2hhZGluZykgKyAwLjI7XG5cbiAgICAgICAgICAgIHZhciBkZXB0aERpciA9IC1iaWFzZWRQb3NUb0FkalByb2JlOy8vcHJvYmUgLSB3b3JsZFxuICAgICAgICAgICAgZGVwdGhEaXIgPSBhcHBseVF1YXRlcm5pb24oZGVwdGhEaXIsIHF1YXRlcm5pb24pO1xuICAgICAgICAgICAgdmFyIHByb2JlVGV4dHVyZVVWIDogdmVjMjxmMzI+ID0gdGV4dHVyZUNvb3JkRnJvbURpcmVjdGlvbihkZXB0aERpci54eXosXG4gICAgICAgICAgICAgICAgYWRqYWNlbnRQcm9iZUluZGV4LFxuICAgICAgICAgICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVRleHR1cmVXaWR0aCxcbiAgICAgICAgICAgICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVByb2JlU2lkZUxlbmd0aCk7XG5cbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZERpc3RhbmNlIDogdmVjMjxmMzI+ID0gMi4wICogdGV4dHVyZVNhbXBsZUxldmVsKGlycmFkaWFuY2VEZXB0aE1hcCwgaXJyYWRpYW5jZURlcHRoTWFwU2FtcGxlciwgcHJvYmVUZXh0dXJlVVYsMC4wKS5yZyA7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHZhcmlhbmNlID0gYWJzKChmaWx0ZXJlZERpc3RhbmNlLnggKiBmaWx0ZXJlZERpc3RhbmNlLngpIC0gZmlsdGVyZWREaXN0YW5jZS55KTtcblxuICAgICAgICAgICAgdmFyIGNoZWJ5c2hldldlaWdodCA9IDEuMDtcbiAgICAgICAgICAgIGlmKGJpYXNlZFBvc1RvQWRqUHJvYmVEaXN0ID4gZmlsdGVyZWREaXN0YW5jZS54ICkgLy8gb2NjbHVkZWRcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGJpYXNlZFBvc1RvQWRqUHJvYmVEaXN0IC0gZmlsdGVyZWREaXN0YW5jZS54IDtcbiAgICAgICAgICAgICAgICBjaGVieXNoZXZXZWlnaHQgPSB2YXJpYW5jZSAvICh2YXJpYW5jZSArICh2ICogdikpO1xuICAgICAgICAgICAgICAgIC8vIEluY3JlYXNlIHRoZSBjb250cmFzdCBpbiB0aGUgd2VpZ2h0XG4gICAgICAgICAgICAgICAgY2hlYnlzaGV2V2VpZ2h0ID0gbWF4KChjaGVieXNoZXZXZWlnaHQgKiBjaGVieXNoZXZXZWlnaHQgKiBjaGVieXNoZXZXZWlnaHQpLCAwLjApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ZWlnaHQgKj0gbWF4KDAuMDUsIGNoZWJ5c2hldldlaWdodCk7XG4gICAgICAgICAgICB3ZWlnaHQgPSBtYXgoMC4wMDAwMDEsIHdlaWdodCk7XG5cbiAgICAgICAgICAgIGxldCBjcnVzaFRocmVzaG9sZCA9IDAuMjtcbiAgICAgICAgICAgIGlmICh3ZWlnaHQgPCBjcnVzaFRocmVzaG9sZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgKj0gKHdlaWdodCAqIHdlaWdodCkgKiAoMS4wIC8gKGNydXNoVGhyZXNob2xkICogY3J1c2hUaHJlc2hvbGQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2VpZ2h0ICo9IHRyaWxpbmVhcldlaWdodDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy93b3JsZFBvc1RvQWRqUHJvYmVcbiAgICAgICAgICAgIGxldCByb3RhdGVEaXIgPSBhcHBseVF1YXRlcm5pb24oLWRpcmVjdGlvbiwgcXVhdGVybmlvbik7XG4gICAgICAgICAgICBwcm9iZVRleHR1cmVVViA9IHRleHR1cmVDb29yZEZyb21EaXJlY3Rpb24oKHJvdGF0ZURpciksXG4gICAgICAgICAgICBhZGphY2VudFByb2JlSW5kZXgsXG4gICAgICAgICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlV2lkdGgsXG4gICAgICAgICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlSGVpZ2h0LFxuICAgICAgICAgICAgaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5pcnJhZGlhbmNlUHJvYmVTaWRlTGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIHByb2JlSXJyYWRpYW5jZTogdmVjMzxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKGlycmFkaWFuY2VNYXAsIGlycmFkaWFuY2VNYXBTYW1wbGVyLCBwcm9iZVRleHR1cmVVViAsMC4wKS54eXo7XG5cbiAgICAgICAgICAgIHZhciBleHBvbmVudCA9ICBpcnJhZGlhbmNlRGF0YS5kZGdpR2FtbWEgKiAwLjU7XG4gICAgICAgICAgICBwcm9iZUlycmFkaWFuY2UgPSBwb3cocHJvYmVJcnJhZGlhbmNlLCB2ZWMzPGYzMj4oZXhwb25lbnQpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaXJyYWRpYW5jZSArPSAod2VpZ2h0ICogcHJvYmVJcnJhZGlhbmNlKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkV2VpZ2h0cyArPSB3ZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhY2N1bXVsYXRlZFdlaWdodHMgPT0gMC4wKXtcbiAgICAgICAgICAgIHJldHVybiB2ZWM0PGYzMj4oMC4wLCAwLjAsIDAuMCwxLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgaXJyYWRpYW5jZSAqPSAoMS4wIC8gYWNjdW11bGF0ZWRXZWlnaHRzKTsgICBcbiAgICAgICAgaXJyYWRpYW5jZSAqPSBpcnJhZGlhbmNlOyAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICBpcnJhZGlhbmNlICo9IDYuMjgzMTg1MzA3MTc5NTg2NDtcbiAgICAgICAgaXJyYWRpYW5jZSAqPSBpcnJhZGlhbmNlRGF0YS5pbmRpcmVjdEludGVuc2l0eTtcbiAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPihpcnJhZGlhbmNlLDEuMCkgO1xuICAgIH1cblxuYCxqbj1gXG4jaW5jbHVkZSBcIkNsZWFyY29hdF9mcmFnXCJcbiAgICAjaW5jbHVkZSBcIkVudk1hcF9mcmFnXCJcbiAgICAjaW5jbHVkZSBcIkJyZGZMdXRfZnJhZ1wiXG4gICAgI2luY2x1ZGUgXCJDb2xvclV0aWxfZnJhZ1wiXG4gICAgXG4gICAgc3RydWN0IEZyYWdEYXRhIHtcbiAgICAgICAgQW86IGYzMixcbiAgICAgICAgTWV0YWxsaWM6IGYzMixcbiAgICAgICAgUm91Z2huZXNzOiBmMzIsXG5cbiAgICAgICAgQWxiZWRvOiB2ZWM0PGYzMj4sXG4gICAgICAgIEVtaXNzaXZlOiB2ZWMzPGYzMj4sXG5cbiAgICAgICAgTjogdmVjMzxmMzI+LFxuICAgICAgICBWOiB2ZWMzPGYzMj4sXG4gICAgICAgIFI6IHZlYzM8ZjMyPixcblxuICAgICAgICBGMDogdmVjMzxmMzI+LFxuICAgICAgICBGOiB2ZWMzPGYzMj4sXG4gICAgICAgIEtTOiB2ZWMzPGYzMj4sXG4gICAgICAgIEtEOiB2ZWMzPGYzMj4sXG4gICAgICAgIFNoYWRvdzogZjMyLFxuICAgICAgICBJbmRpcmVjdDogZjMyLFxuICAgICAgICBSZWZsZWN0YW5jZTogZjMyLFxuXG4gICAgICAgIE5vVjogZjMyLFxuICAgICAgICBGYWNlRGlyZWN0aW9uOmYzMixcblxuICAgICAgICBDbGVhcmNvYXRSb3VnaG5lc3M6ZjMyLFxuICAgICAgICBFbnZDb2xvcjogdmVjMzxmMzI+LFxuICAgICAgICBJcnJhZGlhbmNlOiB2ZWMzPGYzMj4sXG5cbiAgICAgICAgTGlnaHRDaGFubmVsOiB2ZWMzPGYzMj4sXG4gICAgICAgIFRhbmdlbnRDaGFubmVsOiB2ZWMzPGYzMj4sXG4gICAgfTtcblxuICAgIHZhcjxwcml2YXRlPiBmcmFnRGF0YTogRnJhZ0RhdGE7XG5cbiAgICBzdHJ1Y3QgQnhERkNvbnRleHRcbiAgICB7XG4gICAgICAgIE5vViA6IGYzMiAsXG4gICAgICAgIE5vTCA6IGYzMiAsXG4gICAgICAgIFZvTCA6IGYzMiAsXG4gICAgICAgIE5vSCA6IGYzMiAsXG4gICAgICAgIFZvSCA6IGYzMlxuICAgIH07XG5cbiAgICBmbiBnZXRDb250ZXh0KCBOOnZlYzM8ZjMyPiwgVjp2ZWMzPGYzMj4sIEg6dmVjMzxmMzI+LCBMOnZlYzM8ZjMyPiApIC0+IEJ4REZDb250ZXh0XG4gICAge1xuICAgICAgICB2YXIgQ29udGV4dDpCeERGQ29udGV4dCA7XG4gICAgICAgIENvbnRleHQuTm9MID0gc2F0dXJhdGUoZG90KE4sIEwpKSAgO1xuICAgICAgICBDb250ZXh0Lk5vViA9IHNhdHVyYXRlKGRvdChOLCBWKSkgIDtcbiAgICAgICAgQ29udGV4dC5Wb0wgPSBzYXR1cmF0ZShkb3QoViwgTCkpIDtcbiAgICAgICAgQ29udGV4dC5Ob0ggPSBzYXR1cmF0ZShkb3QoTiwgSCkpO1xuICAgICAgICBDb250ZXh0LlZvSCA9IHNhdHVyYXRlKGRvdChWLCBIKSk7XG5cbiAgICAgICAgLy8gQ29udGV4dC5Ob0wgPSBtYXgoZG90KE4sIEwpLDAuMCk7XG4gICAgICAgIC8vIENvbnRleHQuTm9WID0gbWF4KGRvdChOLCBWKSwwLjApO1xuICAgICAgICAvLyBDb250ZXh0LlZvTCA9IG1heChkb3QoViwgTCksMC4wKSA7XG4gICAgICAgIC8vIENvbnRleHQuTm9IID0gc2F0dXJhdGUoZG90KE4sIEgpKTtcbiAgICAgICAgLy8gQ29udGV4dC5Wb0ggPSBtYXgoZG90KFYsIEgpLDAuMCk7XG4gICAgICAgIHJldHVybiBDb250ZXh0IDtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHJvdWdobmVzcyB0byBtaXBtYXBMZXZlbFxuICAgIGZuIHJvdWdobmVzc1RvTWlwbWFwTGV2ZWwoIHJvdWdobmVzczogZjMyICwgbWlwbWFwQ291bnQ6aTMyICkgLT4gZjMye1xuICAgICAgICBsZXQgbGV2ZWwgPSByb3VnaG5lc3MgKiAoMS43IC0gMC43ICogcm91Z2huZXNzICk7XG4gICAgICAgIHJldHVybiBsZXZlbCAqIGYzMihtaXBtYXBDb3VudCk7XG4gICAgfVxuXG4gICAgZm4gSU9SVG9GMChpb3I6ZjMyKS0+ZjMye1xuICAgICAgICB2YXIgZGMgPSBpb3IgLSAxLjAgO1xuICAgICAgICBkYyAqPSBkYyA7XG4gICAgICAgIHZhciBkdCA9IGlvciArIDEuMCA7XG4gICAgICAgIGR0ICo9IGR0IDtcbiAgICAgICAgcmV0dXJuIGRjIC8gZHQgO1xuICAgIH1cblxuICAgIGZuIEZkOTAoIE5vTDpmMzIsIHJvdWdobmVzczpmMzIpIC0+IGYzMlxuICAgIHtcbiAgICAgICAgcmV0dXJuICgyLjAgKiBOb0wgKiByb3VnaG5lc3MpICsgMC40O1xuICAgIH1cblxuICAgIGZuIEtEaXNuZXlUZXJtKCBOb0w6ZjMyLCBOb1Y6ZjMyICwgcm91Z2huZXNzOmYzMikgLT4gZjMyXG4gICAge1xuICAgICAgICByZXR1cm4gKDEuMCArIEZkOTAoTm9MLCByb3VnaG5lc3MpICogcG93KDEuMCAtIE5vTCwgNS4wKSkgKiAoMS4wICsgRmQ5MChOb1YsIHJvdWdobmVzcykgKiBwb3coMS4wIC0gTm9WLCA1LjApKTtcbiAgICB9XG5cbiAgICBmbiBGcmVzbmVsU2NobGljayggTm9WOmYzMiwgIEYwOnZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICByZXR1cm4gRjAgKyAoMS4wIC0gRjApICogcG93KDEuMCAtIE5vViwgNS4wKTtcbiAgICB9XG5cbiAgICBmbiBGcmVzbmVsVGVybSggY29zQTpmMzIsICBGMDp2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPlxuICAgIHtcbiAgICAgICAgbGV0IHQgPSBwb3c1KCAxLjAgLSBjb3NBICk7XG4gICAgICAgIHJldHVybiBGMCArICgxLjAgLSBGMCkgKiB0O1xuICAgIH1cblxuICAgIGZuIEZyZXNuZWxMZXJwKCBjb3NBOmYzMiwgRjA6dmVjMzxmMzI+ICwgRjkwOnZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICBsZXQgdCA9IHBvdzUoIDEuMCAtIGNvc0EgKTtcbiAgICAgICAgcmV0dXJuIG1peCggRjAgLEY5MCx0ICkgO1xuICAgIH1cblxuICAgIGZuIEZyZXNuZWxTY2hsaWNrUm91Z2huZXNzKCBOb1Y6ZjMyLCAgRjA6dmVjMzxmMzI+LCAgcm91Z2huZXNzOmYzMikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICByZXR1cm4gRjAgKyAobWF4KHZlYzMocm91Z2huZXNzKSwgRjApIC0gRjApICogcG93KDEuMCAtIE5vViwgNS4wKTtcbiAgICB9XG5cbiAgICBmbiBEaXN0cmlidXRpb25HR1goIE5kb3RIOmYzMiAsICByb3VnaG5lc3M6ZjMyICkgLT4gZjMyXG4gICAge1xuICAgICAgICBsZXQgYWxwaGEgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XG4gICAgICAgIGxldCBhbHBoYTIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XG5cbiAgICAgICAgbGV0IE5kb3RIMiA9IE5kb3RIICogTmRvdEg7XG5cbiAgICAgICAgbGV0IG5vbSAgID0gYWxwaGEyO1xuICAgICAgICB2YXIgZGVub20gPSAoTmRvdEgyICogKGFscGhhMiAtIDEuMCkgKyAxLjApO1xuICAgICAgICBkZW5vbSA9IFBJICogZGVub20gKiBkZW5vbTtcblxuICAgICAgICByZXR1cm4gbm9tIC8gZGVub207XG4gICAgfVxuXG4gICAgLy8gW0hlaXR6IDIwMTQsIFwiVW5kZXJzdGFuZGluZyB0aGUgTWFza2luZy1TaGFkb3dpbmcgRnVuY3Rpb24gaW4gTWljcm9mYWNldC1CYXNlZCBCUkRGc1wiXVxuICAgIGZuIFZpc19TbWl0aEpvaW50KCBOb1YgOiBmMzIgLCAgTm9MIDogZjMyICwgIGEyIDogZjMyKSAtPiBmMzJcbiAgICB7XG4gICAgICAgIHZhciBWaXNfU21pdGhWID0gTm9MICogc3FydChOb1YgKiAoTm9WIC0gTm9WICogYTIpICsgYTIpO1xuICAgICAgICB2YXIgVmlzX1NtaXRoTCA9IE5vViAqIHNxcnQoTm9MICogKE5vTCAtIE5vTCAqIGEyKSArIGEyKTtcbiAgICAgICAgcmV0dXJuIDAuNSAqIHJjcChWaXNfU21pdGhWICsgVmlzX1NtaXRoTCk7XG4gICAgfVxuXG4gICAgZm4gR2VvbWV0cnlTY2hsaWNrR0dYKCBOZG90ViA6IGYzMiAsIHJvdWdobmVzcyA6IGYzMiApIC0+IGYzMlxuICAgIHtcbiAgICAgICAgLy9yb3VnaG5lc3MgY29tcHV0ZSBrc1xuICAgICAgICBsZXQgciA9IChyb3VnaG5lc3MgKyAxLjApO1xuICAgICAgICBsZXQgayA9IChyKnIpIC8gOC4wO1xuXG4gICAgICAgIGxldCBub20gICA9IE5kb3RWO1xuICAgICAgICBsZXQgZGVub20gPSBOZG90ViAqICgxLjAgLSBrKSArIGs7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbm9tIC8gZGVub207XG4gICAgfVxuICAgIFxuICAgIGZuIEdlb21ldHJ5U21pdGgoIE5kb3RWOmYzMiAsIE5kb3RMOmYzMiAsIHJvdWdobmVzcyA6IGYzMikgLT4gZjMyXG4gICAge1xuICAgICAgICAvLyBsZXQgTmRvdFYgPSBtYXgoZG90KE4sIFYpLCAwLjApO1xuICAgICAgICAvLyBsZXQgTmRvdEwgPSBtYXgoZG90KE4sIEwpLCAwLjApO1xuICAgICAgICBsZXQgZ2d4MSA9IEdlb21ldHJ5U2NobGlja0dHWChOZG90Viwgcm91Z2huZXNzKTtcbiAgICAgICAgbGV0IGdneDIgPSBHZW9tZXRyeVNjaGxpY2tHR1goTmRvdEwsIHJvdWdobmVzcyk7XG4gICAgICAgIHJldHVybiBnZ3gxICogZ2d4MjtcbiAgICB9XG5cbiAgICBmbiBHZW9tZXRyeUF0dGVudWF0aW9uR0dYU21pdGgoIE5kb3RMOmYzMiwgIE5kb3RWOmYzMiwgIHJvdWdobmVzczpmMzIpIC0+IGYzMlxuICAgIHtcbiAgICAgICAgdmFyIE5kb3RMMiA9IE5kb3RMICogTmRvdEw7XG4gICAgICAgIHZhciBOZG90VjIgPSBOZG90ViAqIE5kb3RWO1xuICAgICAgICB2YXIga1JvdWdoMiA9IHJvdWdobmVzcyAqIHJvdWdobmVzcyArIDAuMDAwMTtcblxuICAgICAgICB2YXIgZ2d4TCA9ICgyLjAgKiBOZG90TCkgLyAoTmRvdEwgKyBzcXJ0KE5kb3RMMiArIGtSb3VnaDIgKiAoMS4wIC0gTmRvdEwyKSkpO1xuICAgICAgICB2YXIgZ2d4ViA9ICgyLjAgKiBOZG90VikgLyAoTmRvdFYgKyBzcXJ0KE5kb3RWMiArIGtSb3VnaDIgKiAoMS4wIC0gTmRvdFYyKSkpO1xuXG4gICAgICAgIHJldHVybiBnZ3hMICogZ2d4VjtcbiAgICB9XG5cbiAgICBmbiBjb2xvckxpbmVhciggY29sb3JWZWN0b3I6dmVjMzxmMzI+ICkgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICB2YXIgbGluZWFyQ29sb3IgPSBwb3coY29sb3JWZWN0b3IucmdiLCB2ZWMzPGYzMj4oMi4yKSk7XG4gICAgICAgIHJldHVybiBsaW5lYXJDb2xvcjtcbiAgICB9XG5cbiAgICBmbiBjb21wdXRlRnJlc25lbFNjaGxpY2soIE5vVjpmMzIgLCBGMDp2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIEYwICsgKDEuMCAtIEYwKSAqIHBvdyhjbGFtcCgxLjAgLSBOb1YsMC4wLDEuMCksIDUuMCk7XG4gICAgfVxuXG4gICAgZm4gY29tcHV0ZUZyZXNuZWxTY2hsaWNrUm91Z2huZXNzKE5vVjpmMzIgLCBGMDp2ZWMzPGYzMj4sICByb3VnaG5lc3M6ZjMyKSAtPiB2ZWMzPGYzMj5cbiAgICB7XG4gICAgICAgIHJldHVybiBGMCArIChtYXgodmVjMygxLjAgLSByb3VnaG5lc3MpLCBGMCkgLSBGMCkgKiBwb3coY2xhbXAoMS4wIC0gZnJhZ0RhdGEuTm9WLDAuMCwxLjApLCA1LjApO1xuICAgIH1cblxuICAgIGZuIGNvbXB1dGVEaXN0cmlidXRpb25HR1goIE46dmVjMzxmMzI+LCAgSDp2ZWMzPGYzMj4sICByb3VnaG5lc3M6ZjMyKSAtPiBmMzJcbiAgICB7XG4gICAgICAgIHZhciBhbHBoYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcbiAgICAgICAgdmFyIGFscGhhMiA9IGFscGhhICogYWxwaGE7IFxuXG4gICAgICAgIHZhciBOZG90SCA9IHNhdHVyYXRlKGRvdChOLCBIKSk7XG4gICAgICAgIHZhciBOZG90SDIgPSBOZG90SCAqIE5kb3RIO1xuXG4gICAgICAgIHJldHVybiAoYWxwaGEyKSAvIChQSSAqIChOZG90SDIgKiAoYWxwaGEyIC0gMS4wKSArIDEuMCkgKiAoTmRvdEgyICogKGFscGhhMiAtIDEuMCkgKyAxLjApKTtcbiAgICB9XG5cbiAgICBmbiBEX0dHWCggTm9IOmYzMiwgIHJvdWdobmVzczpmMzIgKSAtPiBmMzJcbiAgICB7XG4gICAgICAgIHZhciBkID0gKCBOb0ggKiByb3VnaG5lc3MgLSBOb0ggKSAqIE5vSCArIDEuMDtcdC8vIDIgbWFkXG4gICAgICAgIHJldHVybiByb3VnaG5lc3MgLyAoIFBJKmQqZCApO1x0XHRcdFx0XHQvLyA0IG11bCwgMSByY3BcbiAgICB9XG5cbiAgICBmbiBjb21wdXRlR2VvbWV0cnlBdHRlbnVhdGlvbkdHWFNtaXRoKCBOZG90TDpmMzIgLCAgTmRvdFY6ZjMyLCAgcm91Z2huZXNzOmYzMikgLT4gZjMyXG4gICAge1xuICAgICAgICB2YXIgTmRvdEwyID0gTmRvdEwgKiBOZG90TDtcbiAgICAgICAgdmFyIE5kb3RWMiA9IE5kb3RWICogTmRvdFY7XG4gICAgICAgIHZhciBrUm91Z2gyID0gcm91Z2huZXNzICogcm91Z2huZXNzICsgMC4wMDAxO1xuXG4gICAgICAgIHZhciBnZ3hMID0gKDIuMCAqIE5kb3RMKSAvIChOZG90TCArIHNxcnQoTmRvdEwyICsga1JvdWdoMiAqICgxLjAgLSBOZG90TDIpKSk7XG4gICAgICAgIHZhciBnZ3hWID0gKDIuMCAqIE5kb3RWKSAvIChOZG90ViArIHNxcnQoTmRvdFYyICsga1JvdWdoMiAqICgxLjAgLSBOZG90VjIpKSk7XG5cbiAgICAgICAgcmV0dXJuIGdneEwgKiBnZ3hWO1xuICAgIH1cblxuICAgIGZuIFZpc19TbWl0aCggIE5vTDpmMzIgLCAgTm9WOmYzMiwgIGEyOmYzMiApLT4gZjMyXG4gICAge1xuICAgICAgICB2YXIgVmlzX1NtaXRoViA9IE5vViArIHNxcnQoIE5vViAqIChOb1YgLSBOb1YgKiBhMikgKyBhMiApO1xuICAgICAgICB2YXIgVmlzX1NtaXRoTCA9IE5vTCArIHNxcnQoIE5vTCAqIChOb0wgLSBOb0wgKiBhMikgKyBhMiApO1xuICAgICAgICByZXR1cm4gcmNwKCBWaXNfU21pdGhWICogVmlzX1NtaXRoTCApO1xuICAgIH1cblxuICAgIGZuIHNpbXBsZUJSREYoIGFsYmVkbzp2ZWMzPGYzMj4sIE46dmVjMzxmMzI+LCBWOnZlYzM8ZjMyPixMOnZlYzM8ZjMyPixhdHQ6ZjMyLGxpZ2h0Q29sb3I6dmVjMzxmMzI+LHJvdWdobmVzczpmMzIgLG1ldGFsbGljOmYzMiktPiB2ZWMzPGYzMj57XG4gICAgICAgIGxldCBIID0gbm9ybWFsaXplKFYgKyBMKTtcbiAgICAgICAgbGV0IENvbnRleHQ6QnhERkNvbnRleHQgPSBnZXRDb250ZXh0KE4sVixILEwpO1xuXG4gICAgICAgIGxldCBGMCA9IG1peCh2ZWMzPGYzMj4obWF0ZXJpYWxVbmlmb3JtLm1hdGVyaWFsRjAucmdiKSwgYWxiZWRvICwgbWV0YWxsaWMpO1xuICAgICAgICBsZXQgRCA9IERpc3RyaWJ1dGlvbkdHWCggQ29udGV4dC5Ob0ggLCByb3VnaG5lc3MpO1xuICAgICAgICBsZXQgRyA9IEdlb21ldHJ5U21pdGgoQ29udGV4dC5Ob1YsQ29udGV4dC5Ob0wsIHJvdWdobmVzcyApO1xuICAgICAgICBsZXQgRiA9IEZyZXNuZWxTY2hsaWNrKENvbnRleHQuVm9ILCB2ZWMzPGYzMj4oRjApKTtcbiAgICAgICAgbGV0IHNwZWN1bGFyID0gKCBEICogRyAqIEYgKSAvICg0LjAgKiBDb250ZXh0Lk5vViAqIENvbnRleHQuTm9MICsgMC4wMDEpO1xuICAgICAgICBsZXQga1MgPSBGO1xuICAgICAgICB2YXIga2QgPSAxLjAgLSBrUyA7XG4gICAgICAgIGtkICo9IDEuMCAtIG1ldGFsbGljIDtcbiAgICAgICAgdmFyIGRpZmZ1c2UgPSBrZCAqIChhbGJlZG8ucmdiIC8gUEkgKSA7XG4gICAgICAgIGxldCBhbWJpZW50ID0gc3BlY3VsYXIucmdiIDtcblxuICAgICAgICBmcmFnRGF0YS5LRCArPSBrZDtcbiAgICAgICAgZnJhZ0RhdGEuS1MgKz0gRjtcblxuICAgICAgICB2YXIgY29sID0gKGRpZmZ1c2UgKyBhbWJpZW50KSAqIENvbnRleHQuTm9MICogbGlnaHRDb2xvciAqIGF0dCA7XG4gICAgICAgIC8vIHZhciBjb2wgPSAoZGlmZnVzZSArIGFtYmllbnQpICogQ29udGV4dC5Ob0wgKiBsaWdodENvbG9yIDtcbiAgICAgICAgcmV0dXJuIChjb2wucmdiICkgO1xuICAgIH1cblxuICAgIGZuIGdldFNwZWN1bGFyRG9taW5hbnREaXIgKCAgTiA6IHZlYzM8ZjMyPiAsIFIgOiB2ZWMzPGYzMj4gLCByb3VnaG5lc3MgOiBmMzIgKSAtPiB2ZWMzPGYzMj5cbiAgICB7XG4gICAgICAgIHZhciBzbW9vdGhuZXNzID0gc2F0dXJhdGUgKDEuMCAtIHJvdWdobmVzcyApO1xuICAgICAgICB2YXIgbGVycEZhY3RvciA9IHNtb290aG5lc3MgKiAoIHNxcnQgKCBzbW9vdGhuZXNzICkgKyByb3VnaG5lc3MgKTtcbiAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBub3Qgbm9ybWFsaXplZCBhcyB3ZSBmZXRjaCBpbiBhIGN1YmVtYXBcbiAgICAgICAgcmV0dXJuIG1peCAoTiwgUiwgbGVycEZhY3RvciApO1xuICAgIH1cblxuICAgIGZuIGFwcHJveGltYXRlU3BlY3VsYXJJQkwoIHNwZWN1bGFyQ29sb3I6dmVjMzxmMzI+ICwgcm91Z2huZXNzOmYzMiAsIFI6dmVjMzxmMzI+ICwgTm9WOmYzMiApIC0+IHZlYzM8ZjMyPiB7XG4gICAgICAgXG4gICAgICAgIGxldCBNQVhfUkVGTEVDVElPTl9MT0QgID0gaTMyKHRleHR1cmVOdW1MZXZlbHMocHJlZmlsdGVyTWFwKSkgO1xuICAgICAgICBsZXQgbWlwID0gcm91Z2huZXNzVG9NaXBtYXBMZXZlbChyb3VnaG5lc3MsTUFYX1JFRkxFQ1RJT05fTE9EKTtcbiAgICAgICAgdmFyIHByZWZpbHRlcmVkQ29sb3I6IHZlYzM8ZjMyPiA9ICh0ZXh0dXJlU2FtcGxlTGV2ZWwocHJlZmlsdGVyTWFwLCBwcmVmaWx0ZXJNYXBTYW1wbGVyLCBnZXRTcGVjdWxhckRvbWluYW50RGlyKGZyYWdEYXRhLk4sUixyb3VnaG5lc3MpICwgbWlwICkucmdiKTtcbiAgICAgICAgcHJlZmlsdGVyZWRDb2xvciA9IGdsb2JhbFVuaWZvcm0uc2t5RXhwb3N1cmUgKiAocHJlZmlsdGVyZWRDb2xvcik7XG4gICAgICAgIHZhciBlbnZCUkRGID0gdGV4dHVyZVNhbXBsZUxldmVsKGJyZGZsdXRNYXAsIGJyZGZsdXRNYXBTYW1wbGVyLCB2ZWMyPGYzMj4oTm9WLCByb3VnaG5lc3MpICwgMC4wICkgO1xuICAgICAgICByZXR1cm4gcHJlZmlsdGVyZWRDb2xvciAqIChzcGVjdWxhckNvbG9yLnJnYiAqIGVudkJSREYueCArIHNhdHVyYXRlKCA1MC4wICogc3BlY3VsYXJDb2xvci5nICkgKiBlbnZCUkRGLnkpIDtcbiAgICB9XG5cbiAgICBmbiBmcmVzbmVsX2NvYXQobjp2ZWMzPGYzMj4sdjp2ZWMzPGYzMj4saW9yOmYzMikgLT4gZjMyIHtcbiAgICAgICAgdmFyIGYwID0gKDEuMC1pb3IpLygxLjAraW9yKTtcbiAgICAgICAgZjAgPSBmMCAqIGYwICA7XG4gICAgICAgIGxldCBmciA9IHBvdygoZjAgKyAoMS4wIC0gZjApKigxLjAgLSBhYnMoIG1heChkb3Qobix2KSwwLjApICkpKSAsIDUuMCApIDsgIFxuICAgICAgICByZXR1cm4gZnIgO1xuICAgIH1cblxuICAgIGZuIHJlZmxlY3RFbnZNYXAobjp2ZWMzPGYzMj4gLCB2OnZlYzM8ZjMyPiAsIHJvdWdobmVzczpmMzIpIC0+IHZlYzM8ZjMyPiB7XG4gICAgICAgIGxldCBNQVhfUkVGTEVDVElPTl9MT0QgID0gaTMyKHRleHR1cmVOdW1MZXZlbHMoZW52TWFwKSkgO1xuICAgICAgICBsZXQgbWlwID0gcm91Z2huZXNzVG9NaXBtYXBMZXZlbChyb3VnaG5lc3MsTUFYX1JFRkxFQ1RJT05fTE9EKTtcbiAgICAgICAgbGV0IFIgPSAyLjAgKiBkb3QoIHYgLCBuICkgKiBuIC0gdiA7XG4gICAgICAgIHZhciBwcmVmaWx0ZXJlZENvbG9yOiB2ZWMzPGYzMj4gPSBnbG9iYWxVbmlmb3JtLnNreUV4cG9zdXJlICogKHRleHR1cmVTYW1wbGVMZXZlbChlbnZNYXAsIGVudk1hcFNhbXBsZXIsIFIgLCBtaXAgKS5yZ2IpO1xuICAgICAgICBwcmVmaWx0ZXJlZENvbG9yID0gTGluZWFyVG9HYW1tYVNwYWNlKHByZWZpbHRlcmVkQ29sb3IpO1xuICAgICAgICByZXR1cm4gcHJlZmlsdGVyZWRDb2xvciA7XG4gICAgfVxuXG4gICAgZm4gU3BlY3VsYXJfRF9HR1goIE5vSDpmMzIsICByb3VnaG5lc3M6ZjMyICkgLT4gZjMyXG4gICAge1xuICAgICAgICBsZXQgYTIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3MgO1xuICAgICAgICBsZXQgZiA9IChOb0ggKiBhMiAtIE5vSCkgKiBOb0ggKyAxLjA7XG4gICAgICAgIHJldHVybiBhMiAvIChQSSAqIGYgKiBmKSA7XG4gICAgfVxuXG4gICAgZm4gVl9LZWxlbWVuKCBMb0ggOiBmMzIgKSAtPiBmMzIge1xuICAgICAgICByZXR1cm4gMC4yNSAvIChMb0ggKiBMb0gpO1xuICAgIH1cblxuICAgIGZuIEZfU2NobGljayggZjA6dmVjMzxmMzI+ICwgIGY5MCA6IGYzMiAsICBWb0ggOiBmMzIgKSAtPiB2ZWMzPGYzMj4ge1xuICAgICAgICByZXR1cm4gZjAgKyAoZjkwIC0gZjApICogcG93KDEuMCAtIFZvSCw1LjApO1xuICAgIH1cblxuICAgIGZuIEZfU2NobGljazIoICBTcGVjdWxhckNvbG9yOnZlYzM8ZjMyPiwgIFZvSCA6ZjMyICktPiB2ZWMzPGYzMj4ge1xuICAgICAgICB2YXIgRmMgPSBwb3c1KCAxLjAgLSBWb0ggKTtcbiAgICAgICAgbGV0IHJ0ID0gY2xhbXAoNTAuMCAqIFNwZWN1bGFyQ29sb3IuZywwLjAsMS4wKSA7XG4gICAgICAgIHJldHVybiBydCAqIEZjICsgKDEuMCAtIEZjKSAqIFNwZWN1bGFyQ29sb3I7XG4gICAgfVxuXG4gICAgZm4gb25lTWludXNSZWZsZWN0aXZpdHkgKCBtZXRhbGxpYyA6IGYzMiAsIEYwOmYzMiApIC0+IGYzMiB7XG4gICAgICAgIGxldCByYW5nZSA9IDEuMCAtIEYwO1xuICAgICAgICByZXR1cm4gcmFuZ2UgLSBtZXRhbGxpYyAqIHJhbmdlO1xuICAgIH1cblxuICAgIC8vaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2ZpbGFtZW50L0ZpbGFtZW50Lmh0bWwgbWF0ZXJpYWxzeXN0ZW0vY2xlYXJjb2F0bW9kZWwvY2xlYXJjb2F0cGFyYW1ldGVyaXphdGlvblxuICAgIGZuIENvYXRTcGVjdWxhcl9icmRmKCBmOnZlYzM8ZjMyPiwgczp2ZWMzPGYzMj4sIG46dmVjMzxmMzI+ICwgdjp2ZWMzPGYzMj4gLCBsOnZlYzM8ZjMyPiAsIGF0dDpmMzIgLCBsYXllciA6dmVjMzxmMzI+ICwgY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yOmYzMiApIC0+IHZlYzM8ZjMyPiB7XG4gICAgICAgIGxldCBIID0gbm9ybWFsaXplKHYgKyBsKTsgXG4gICAgICAgIGxldCBWZG90TmMgPSBtYXgoZG90KHYsbiksMC4wKTtcbiAgICAgICAgbGV0IExkb3ROYyA9IG1heChkb3QobCxuKSwwLjApO1xuICAgICAgICBsZXQgTm9IID0gbWF4KGRvdChuLEgpLDAuMCk7XG4gICAgICAgIGxldCBMb0ggPSBzYXR1cmF0ZShkb3QobCwgSCkpICA7XG4gICAgICAgIGxldCBOb0wgPSBtYXgoZG90KG4sbCksMC4wKTtcblxuICAgICAgICBsZXQgRmQgPSBmIDsgXG4gICAgICAgIGxldCBGciA9IHMgOyBcblxuICAgICAgICBsZXQgZmFjdG9yID0gY2xhbXAoY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yLDAuMDg5LDEuMCk7XG4gICAgICAgIGxldCBjbGVhckNvYXRSb3VnaG5lc3MgPSBmYWN0b3IgKiBmYWN0b3IgO1xuXG4gICAgICAgIGxldCBEYyA9IERfR0dYKCBOb0ggLCBmYWN0b3IgKSA7XG4gICAgICAgIGxldCBWYyA9IFZfS2VsZW1lbiggTG9IICkgKiBOb0wgO1xuICAgICAgICBsZXQgRmMgPSBGX1NjaGxpY2sodmVjMzxmMzI+KDAuMDQpLCAyLjAgLCBMb0gpOyBcbiAgICAgICAgbGV0IEZyYyA9IChEYyAqIFZjKSAqIEZjIDtcbiAgICAgICAgLy8gcmV0dXJuIGxheWVyICogdmVjMzxmMzI+KChGZCArIEZyICogKDEuMCAtIEZjKSkgKiAoMS4wIC0gRmMpICsgRnJjKSAqICggMC41ICsgTm9MICogMC41ICkgO1xuICAgICAgICByZXR1cm4gdmVjMzxmMzI+KEZyYykgO1xuICAgIH1cblxuICAgICNpZiBVU0VfQ0xFQVJDT0FUXG4gICAgZm4gYXBwcm94aW1hdGVfY29hdGluZyhiYXNlOnZlYzM8ZjMyPiAsIGNsZWFyQ29sb3I6IHZlYzM8ZjMyPiwgbjp2ZWMzPGYzMj4gLCB2OnZlYzM8ZjMyPiAsIGxpZ2h0OkxpZ2h0RGF0YSAsIGNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcjpmMzIgKSAtPiB2ZWMzPGYzMj4ge1xuICAgICAgICBsZXQgZmFjdG9yID0gY2xhbXAoY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yLDAuMDg0LDEuMCk7XG4gICAgICAgIHZhciBjbGVhcmNvYXRBbHBoYSA9IGZhY3RvciAqIGZhY3RvciArIGZyYWdEYXRhLkNsZWFyY29hdFJvdWdobmVzcztcblxuICAgICAgICAvLyB2YXIgbGlnaHRDb2xvciA9IGdldEhEUkNvbG9yKCBsaWdodENDLnJnYiAsIGxpZ2h0LmxpbmVhciApICA7XG4gICAgICAgIHZhciBhdHQgPSBsaWdodC5pbnRlbnNpdHkgLyBMVU1FTiA7XG4gICAgICAgIGxldCBsID0gbGlnaHQuZGlyZWN0aW9uIDtcbiAgIFxuICAgICAgICBsZXQgTmRvdFYgPSBtYXgoZG90KG4sdiksMC4wKTtcbiAgICAgICAgbGV0IE1BWF9SRUZMRUNUSU9OX0xPRCAgPSBmMzIodGV4dHVyZU51bUxldmVscyhwcmVmaWx0ZXJNYXApKSA7XG4gICAgICAgIC8vIGxldCBtaXAgPSByb3VnaG5lc3NUb01pcG1hcExldmVsKGNsZWFyY29hdEFscGhhLE1BWF9SRUZMRUNUSU9OX0xPRCk7XG4gICAgICAgIGxldCBSID0gMi4wICogZG90KCB2ICwgbiApICogbiAtIHYgO1xuICAgICAgICB2YXIgZW52SUJMOiB2ZWMzPGYzMj4gPSBnbG9iYWxVbmlmb3JtLnNreUV4cG9zdXJlICogKHRleHR1cmVTYW1wbGVMZXZlbChwcmVmaWx0ZXJNYXAsIHByZWZpbHRlck1hcFNhbXBsZXIsIFIgLCBNQVhfUkVGTEVDVElPTl9MT0QgKiBjbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IgKS5yZ2IpIDtcbiAgICAgICAgLy8gZW52SUJMID0gTGluZWFyVG9HYW1tYVNwYWNlKGVudklCTCk7XG5cbiAgICAgICAgbGV0IGNsZWFyQ29hdCA9IG1hdGVyaWFsVW5pZm9ybS5jbGVhcmNvYXRGYWN0b3IgO1xuICAgICAgICAvLyBsZXQgZiA9IEZyZXNuZWxTY2hsaWNrUm91Z2huZXNzKCBtYXgoZG90KG4sdiksMC4wKSAsIHZlYzM8ZjMyPigwLjApICwgY2xlYXJjb2F0QWxwaGEgKSA7XG4gICAgICAgIGxldCBjbGVhcmNvYXRfYnJkZiA9ICBDb2F0U3BlY3VsYXJfYnJkZiggdmVjMzxmMzI+KDAuMDQpICwgdmVjMzxmMzI+KCAwLjA0ICkgLCBuICwgdiAsIC1sICwgYXR0ICwgdmVjMzxmMzI+KCAwLjA0ICkgLCBmYWN0b3IgKSA7XG5cbiAgICAgICAgLy8gcmV0dXJuIGNsZWFyY29hdF9icmRmOysgZnJhZ0RhdGEuQ2xlYXJjb2F0Um91Z2huZXNzIFxuICAgICAgICByZXR1cm4gbWl4KGJhc2UsIGNsZWFyY29hdF9icmRmLG1hdGVyaWFsVW5pZm9ybS5jbGVhcmNvYXRXZWlnaHQgKSA7XG4gICAgfVxuICAgICNlbmRpZlxuICAgXG5gLHFuPWBcbiAgI2luY2x1ZGUgXCJDbGVhcmNvYXRfZnJhZ1wiXG4gICNpbmNsdWRlIFwiQlJERl9mcmFnXCJcbiAgI2luY2x1ZGUgXCJNYXRoU2hhZGVyXCJcbiAgI2luY2x1ZGUgXCJGYXN0TWF0aFNoYWRlclwiXG4gICNpbmNsdWRlIFwiQ29tbW9uX2ZyYWdcIlxuICAjaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuXG4gICNpbmNsdWRlIFwiUGh5c2ljTWF0ZXJpYWxVbmlmb3JtX2ZyYWdcIlxuICAjaW5jbHVkZSBcIk5vcm1hbE1hcF9mcmFnXCJcbiAgI2luY2x1ZGUgXCJMaWdodGluZ0Z1bmN0aW9uX2ZyYWdcIlxuICAjaW5jbHVkZSBcIklycmFkaWFuY2VfZnJhZ1wiXG4gICNpbmNsdWRlIFwiQ29sb3JVdGlsX2ZyYWdcIlxuICAjaW5jbHVkZSBcIkJ4ZGZEZWJ1Z19mcmFnXCJcblxuXG4gXG4gIC8vT1JJX1NoYWRpbmdJbnB1dFxuICBmbiBpbml0RnJhZ0RhdGEoKSB7XG4gICAgICBmcmFnRGF0YS5BbGJlZG8gPSBPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvciAqIE9SSV9TaGFkaW5nSW5wdXQuQmFzZUNvbG9yLmEgO1xuICAgICAgZnJhZ0RhdGEuQW8gPSBPUklfU2hhZGluZ0lucHV0LkFtYmllbnRPY2NsdXNpb24gOyBcbiAgICAgIGZyYWdEYXRhLlJvdWdobmVzcyA9IGNsYW1wKE9SSV9TaGFkaW5nSW5wdXQuUm91Z2huZXNzLDAuMDAzLDEuMCkgOyBcbiAgICAgIGZyYWdEYXRhLk1ldGFsbGljID0gT1JJX1NoYWRpbmdJbnB1dC5NZXRhbGxpYyA7IFxuICAgICAgZnJhZ0RhdGEuRW1pc3NpdmUgPSBPUklfU2hhZGluZ0lucHV0LkVtaXNzaXZlQ29sb3IucmdiIDsgXG4gICAgICBmcmFnRGF0YS5OID0gT1JJX1NoYWRpbmdJbnB1dC5Ob3JtYWw7XG4gICAgICBsZXQgdmlld0RpciA9IG5vcm1hbGl6ZShnbG9iYWxVbmlmb3JtLkNhbWVyYVBvcy54eXogLSBPUklfVmVydGV4VmFyeWluZy52V29ybGRQb3MueHl6KSA7XG4gICAgICBmcmFnRGF0YS5WID0gdmlld0RpciA7XG4gICAgLy8gICBmcmFnRGF0YS5WID0gbm9ybWFsaXplKGdsb2JhbFVuaWZvcm0uY2FtZXJhV29ybGRNYXRyaXhbM10ueHl6IC0gT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5eikgO1xuXG4gICAgICBsZXQgUiA9IDIuMCAqIGRvdCggZnJhZ0RhdGEuViAsIGZyYWdEYXRhLk4gKSAqIGZyYWdEYXRhLk4gLSBmcmFnRGF0YS5WIDtcbiAgICAgIGZyYWdEYXRhLlIgPSBSIDsvL3JlZmxlY3QoIGZyYWdEYXRhLlYgLCBmcmFnRGF0YS5OICkgO1xuXG4gICAgICBmcmFnRGF0YS5Ob1YgPSBzYXR1cmF0ZShkb3QoZnJhZ0RhdGEuTiwgZnJhZ0RhdGEuVikpIDtcblxuICAgICAgZnJhZ0RhdGEuRjAgPSBtaXgodmVjMzxmMzI+KG1hdGVyaWFsVW5pZm9ybS5tYXRlcmlhbEYwLnJnYiksIGZyYWdEYXRhLkFsYmVkby5yZ2IsIGZyYWdEYXRhLk1ldGFsbGljKTtcbiAgICAgIFxuICAgICAgZnJhZ0RhdGEuRiA9IGNvbXB1dGVGcmVzbmVsU2NobGljayhmcmFnRGF0YS5Ob1YsIGZyYWdEYXRhLkYwKTtcbiAgICAgIGZyYWdEYXRhLktEID0gdmVjMzxmMzI+KGZyYWdEYXRhLkYpIDtcbiAgICAgIGZyYWdEYXRhLktTID0gdmVjMzxmMzI+KDAuMCkgO1xuXG4gICAgICBmcmFnRGF0YS5JbmRpcmVjdCA9IDAuMCA7XG4gICAgICBmcmFnRGF0YS5SZWZsZWN0YW5jZSA9IDEuMCA7XG5cbiAgICAgIGZyYWdEYXRhLkNsZWFyY29hdFJvdWdobmVzcyA9IG1hdGVyaWFsVW5pZm9ybS5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IgO1xuICAgICAgI2lmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTXG4gICAgICAgIGZyYWdEYXRhLkNsZWFyY29hdFJvdWdobmVzcyA9IGdldENsZWFyY29hdFJvdWdobmVzcygpICogbWF0ZXJpYWxVbmlmb3JtLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcjtcbiAgICAgICNlbmRpZlxuICB9XG5cbiAgZm4gQnhERlNoYWRpbmcoKXtcbiAgICAgIGluaXRGcmFnRGF0YSgpO1xuXG4gICAgICB2YXIgaXJyYWRpYW5jZSA9IHZlYzM8ZjMyPigwLjApIDtcbiAgICAgICNpZiBVU0VHSVxuICAgICAgICAgIGlycmFkaWFuY2UgKz0gZ2V0SXJyYWRpYW5jZSgpLnJnYiA7XG4gICAgICAjZWxzZVxuICAgICAgICAgIGxldCBNQVhfUkVGTEVDVElPTl9MT0QgID0gZjMyKHRleHR1cmVOdW1MZXZlbHMocHJlZmlsdGVyTWFwKSkgO1xuICAgICAgICAgIGlycmFkaWFuY2UgKz0gKGdsb2JhbFVuaWZvcm0uc2t5RXhwb3N1cmUgKiB0ZXh0dXJlU2FtcGxlTGV2ZWwocHJlZmlsdGVyTWFwLCBwcmVmaWx0ZXJNYXBTYW1wbGVyLCBmcmFnRGF0YS5OLnh5eiwgMC44ICogKE1BWF9SRUZMRUNUSU9OX0xPRCkgKS5yZ2IpO1xuICAgICAgI2VuZGlmXG4gICAgICBpcnJhZGlhbmNlID0gTGluZWFyVG9HYW1tYVNwYWNlKGlycmFkaWFuY2UucmdiKTtcbiAgICAgIGZyYWdEYXRhLklycmFkaWFuY2UgPSBpcnJhZGlhbmNlLnJnYiA7XG5cbiAgICAgICNpZiBVU0VfVEFOR0VOVFxuICAgICAgICBmcmFnRGF0YS5UYW5nZW50Q2hhbm5lbCA9IHZlYzM8ZjMyPihPUklfVmVydGV4VmFyeWluZy5UQU5HRU5ULncpOy8vIE9SSV9WZXJ0ZXhWYXJ5aW5nLlRBTkdFTlQueHl6ICogT1JJX1ZlcnRleFZhcnlpbmcuVEFOR0VOVC53IDtcbiAgICAgICNlbmRpZlxuXG4gICAgICAvLyoqKioqKioqKioqbGlnaHRpbmctUEJSIHBhcnQqKioqKioqKiogXG4gICAgICB2YXIgc3BlY0NvbG9yID0gdmVjMzxmMzI+KDAuMCkgO1xuICAgICAgbGV0IGxpZ2h0SW5kZXggPSBnZXRDbHVzdGVyKCk7XG4gICAgICBsZXQgc3RhcnQgPSBtYXgobGlnaHRJbmRleC5zdGFydCwgMC4wKTtcbiAgICAgIGxldCBjb3VudCA9IG1heChsaWdodEluZGV4LmNvdW50LCAwLjApO1xuICAgICAgbGV0IGVuZCA9IG1heChzdGFydCArIGNvdW50ICwgMC4wKTtcbiAgICAgIGZvcih2YXIgaTppMzIgPSBpMzIoc3RhcnQpIDsgaSA8IGkzMihlbmQpOyBpICs9IDEgKVxuICAgICAge1xuICAgICAgICBsZXQgbGlnaHQgPSBnZXRMaWdodChpMzIoaSkpO1xuXG4gICAgICAgIHN3aXRjaCAobGlnaHQubGlnaHRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBQb2ludExpZ2h0VHlwZToge1xuICAgICAgICAgICAgc3BlY0NvbG9yICs9IHBvaW50TGlnaHRpbmcoIGZyYWdEYXRhLkFsYmVkby5yZ2IsT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5eixmcmFnRGF0YS5OLGZyYWdEYXRhLlYsZnJhZ0RhdGEuUm91Z2huZXNzLGZyYWdEYXRhLk1ldGFsbGljLGxpZ2h0KSA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgRGlyZWN0TGlnaHRUeXBlOiB7XG4gICAgICAgICAgICBzcGVjQ29sb3IgKz0gZGlyZWN0TGlnaHRpbmcoIGZyYWdEYXRhLkFsYmVkby5yZ2IgLGZyYWdEYXRhLk4sZnJhZ0RhdGEuVixmcmFnRGF0YS5Sb3VnaG5lc3MgLGZyYWdEYXRhLk1ldGFsbGljLCBsaWdodCAsIGdsb2JhbFVuaWZvcm0uc2hhZG93QmlhcykgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFNwb3RMaWdodFR5cGU6IHtcbiAgICAgICAgICAgIHNwZWNDb2xvciArPSBzcG90TGlnaHRpbmcoIGZyYWdEYXRhLkFsYmVkby5yZ2IsT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5eixmcmFnRGF0YS5OLGZyYWdEYXRhLlYsZnJhZ0RhdGEuUm91Z2huZXNzLGZyYWdEYXRhLk1ldGFsbGljICwgbGlnaHQgKSA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZyYWdEYXRhLkxpZ2h0Q2hhbm5lbCA9IHNwZWNDb2xvciA7XG5cblxuICAgICAgLy8qKioqKioqKioqKmxpZ2h0aW5nLVBCUiBwYXJ0KioqKioqKioqIFxuICAgICAgdmFyIEYgPSBGcmVzbmVsU2NobGlja1JvdWdobmVzcyhmcmFnRGF0YS5Ob1YsIGZyYWdEYXRhLkYwLCBmcmFnRGF0YS5Sb3VnaG5lc3MpO1xuICAgICAgdmFyIGtTID0gRjtcbiAgICAgIHZhciBrRCA9IHZlYzMoMS4wKSAtIGtTO1xuICAgICAga0QgPSBrRCAqICgxLjAgLSBmcmFnRGF0YS5NZXRhbGxpYyk7XG4gICAgICBsZXQgZW52ID0gIG1hdGVyaWFsVW5pZm9ybS5lbnZJbnRlbnNpdHkgKiBhcHByb3hpbWF0ZVNwZWN1bGFySUJMKCBGICwgZnJhZ0RhdGEuUm91Z2huZXNzICwgZnJhZ0RhdGEuUiAsIGZyYWdEYXRhLk5vViApIDtcbiAgICAgIGZyYWdEYXRhLkVudkNvbG9yID0gZW52IDtcbiAgICAgIC8vKioqKioqKioqKippbmRpcmVjdC1zcGVjdWxhciBwYXJ0KioqKioqKioqIFxuICAgICAgXG4gICAgICB2YXIgc3VyZmFjZVJlZHVjdGlvbiA9IDEuMC8oZnJhZ0RhdGEuUm91Z2huZXNzKmZyYWdEYXRhLlJvdWdobmVzcysxLjApOyAgIC8vUmVkdWNlIHRoZSByZWZsZWN0aW9uIGNvZWZmaWNpZW50IG9mIG5vbi1tZXRhbGxpYyBtYXRlcmlhbHMgICAgIFxuICAgICAgdmFyIG9uZU1pbnVzUmVmbGVjdGl2aXR5ID0gb25lTWludXNSZWZsZWN0aXZpdHkoZnJhZ0RhdGEuTWV0YWxsaWMgLCBtYXRlcmlhbFVuaWZvcm0ubWF0ZXJpYWxGMC5yICk7Ly8gbWF0ZXJpYWxVbmlmb3JtLm1hdGVyaWFsRjAuYSAtIG1hdGVyaWFsVW5pZm9ybS5tYXRlcmlhbEYwLmEgKiBmcmFnRGF0YS5NZXRhbGxpYyA7XG4gICAgICB2YXIgZ3JhemluZ1Rlcm0gPSBjbGFtcCgoMS4wIC0gZnJhZ0RhdGEuUm91Z2huZXNzICkgKyAoMS4wIC0gb25lTWludXNSZWZsZWN0aXZpdHkpLDAuMCwxLjApO1xuICAgICAgdmFyIHQgPSBwb3c1KGZyYWdEYXRhLk5vVik7XG4gICAgICB2YXIgZnJlc25lbExlcnAgPSBGcmVzbmVsTGVycChmcmFnRGF0YS5Ob1YsZnJhZ0RhdGEuRjAucmdiLHZlYzM8ZjMyPihncmF6aW5nVGVybSkpIDsgICAvL0NvbnRyb2xsaW5nIEZyZXNuZWwgYW5kIG1ldGFsbGljIHJlZmxlY3Rpb25zXG4gICAgICB2YXIgaWJsU3BlY3VsYXJSZXN1bHQgPSBzdXJmYWNlUmVkdWN0aW9uKmVudipmcmVzbmVsTGVycCA7XG4gICAgICAvLyoqKioqKioqKioqaW5kaXJlY3Qtc3BlY3VsYXIgcGFydCoqKioqKioqKiBcbiAgICAgIFxuICAgICAgLy8qKioqKioqKioqKmluZGlyZWN0LWFtYmllbnQgcGFydCoqKioqKioqKiBcbiAgICAgIHZhciBrZExhc3QgPSAoMS4wIC0gZnJhZ0RhdGEuRjAucikgKiAoMS4wIC0gZnJhZ0RhdGEuTWV0YWxsaWMpOyAgICAgLy9EaW0gdGhlIGVkZ2VzLCB0aGVyZSBzaG91bGQgYmUgbW9yZSBzcGVjdWxhciByZWZsZWN0aW9uIGF0IHRoZSBlZGdlc1xuICAgICAgdmFyIGlibERpZmZ1c2VSZXN1bHQgPSBpcnJhZGlhbmNlICoga2RMYXN0ICogZnJhZ0RhdGEuQWxiZWRvLnJnYiA7XG4gICAgICAvLyoqKioqKioqKioqaW5kaXJlY3QtYW1iaWVudCBwYXJ0KioqKioqKioqIFxuICAgICAgbGV0IHN1bkxpZ2h0ID0gbGlnaHRCdWZmZXJbMF0gO1xuICAgICAgdmFyIGluZGlyZWN0UmVzdWx0ID0gKGlibFNwZWN1bGFyUmVzdWx0ICsgaWJsRGlmZnVzZVJlc3VsdCkgKiBmcmFnRGF0YS5BbyAqIG1heChzdW5MaWdodC5xdWFkcmF0aWMsMC4wNSkgO1xuICAgICAgLy8gbGV0IHRlc3QgPSBpbmRpcmVjdFJlc3VsdCA7XG5cbiAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPigwLjApO1xuXG4gICAgICAvLyBVc2luZyBzdHJpcHBlZCBkb3duLCAncHVyZSBsb2cnLCBmb3JtdWxhLiBQYXJhbWV0ZXJpemVkIGJ5IGdyZXkgcG9pbnRzIGFuZCBkeW5hbWljIHJhbmdlIGNvdmVyZWQuXG4gICAgICAjaWYgVVNFR0JVRkZFUlxuICAgICAgICAgIHZhciBub3JtYWxfcmdiYTh1bm9ybSA9IChPUklfVmVydGV4VmFyeWluZy52V29ybGROb3JtYWwgKyAxLjApICogMC41O1xuICAgICAgICAgIG5vcm1hbF9yZ2JhOHVub3JtID0gY2xhbXAobm9ybWFsX3JnYmE4dW5vcm0sIHZlYzM8ZjMyPigwLjApLCB2ZWMzPGYzMj4oMS4wKSk7XG4gICAgICAjZW5kaWZcbiAgICAgIFxuICAgICAgLy8gT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KE9SSV9GcmFnbWVudE91dHB1dC5jb2xvci54eXosZnJhZ0RhdGEuQWxiZWRvLmEpIDtcbiAgICAgICNpZiBVU0VfV09STERQT1NcbiAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQud29ybGRQb3MgPSB2ZWM0PGYzMj4oT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5encpO1xuICAgICAgI2VuZGlmXG5cbiAgICAgICNpZiBVU0VHQlVGRkVSXG4gICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LndvcmxkTm9ybWFsID0gdmVjNDxmMzI+KG5vcm1hbF9yZ2JhOHVub3JtLDEuMCk7XG4gICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0Lm1hdGVyaWFsID0gdmVjNDxmMzI+KDEuMCxmcmFnRGF0YS5Sb3VnaG5lc3MsZnJhZ0RhdGEuTWV0YWxsaWMsMS4wKTtcbiAgICAgICNlbmRpZlxuICAgICAgXG4gICAgICB2YXIgY29sb3IgPSBzcGVjQ29sb3IgKyBpbmRpcmVjdFJlc3VsdCA7XG4gICAgICBjb2xvciArPSBmcmFnRGF0YS5FbWlzc2l2ZS54eXogO1xuXG4gICAgICB2YXIgY2xlYXJDb2F0Q29sb3IgPSB2ZWMzPGYzMj4oMC4wKTtcbiAgICAgICNpZiBVU0VfQ0xFQVJDT0FUXG4gICAgICAgIGxldCBjbGVhckNvYXRCYXNlQ29sb3IgPSB2ZWMzPGYzMj4oMS4wKSAqIG1hdGVyaWFsVW5pZm9ybS5iYXNlQ29sb3IucmdiIDtcbiAgICAgICAgbGV0IGNsZWFyTm9ybWFsID0gZnJhZ0RhdGEuTiA7XG4gICAgICAgIGxldCBjbGVhcmNvYXRSb3VnaG5lc3MgPSBmcmFnRGF0YS5DbGVhcmNvYXRSb3VnaG5lc3MgO1xuICAgICAgICBsZXQgYXR0ID0gc3VuTGlnaHQuaW50ZW5zaXR5IC8gTFVNRU4gO1xuICAgICAgICBsZXQgY2xlYXJDb2F0TGF5ZXIgPSBDbGVhckNvYXRfQlJERiggY29sb3IgLCBtYXRlcmlhbFVuaWZvcm0uY2xlYXJjb2F0Q29sb3IucmdiICwgbWF0ZXJpYWxVbmlmb3JtLmlvciAsIGNsZWFyTm9ybWFsICwgLXN1bkxpZ2h0LmRpcmVjdGlvbiAsLWZyYWdEYXRhLlYgLCBtYXRlcmlhbFVuaWZvcm0uY2xlYXJjb2F0V2VpZ2h0ICwgY2xlYXJjb2F0Um91Z2huZXNzICwgYXR0ICk7XG4gICAgICAgIGNvbG9yID0gdmVjMzxmMzI+KGNsZWFyQ29hdExheWVyLnJnYi9mcmFnRGF0YS5BbGJlZG8uYSkgOyBcbiAgICAgICNlbmRpZlxuICAgICAgXG4gICAgICBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4oTGluZWFyVG9HYW1tYVNwYWNlKGNvbG9yLnJnYiksZnJhZ0RhdGEuQWxiZWRvLmEpIDtcblxuICAgICAgLy8gdmFyIGlibFNwZWN1bGFyUmVzdWx0ID0gc3VyZmFjZVJlZHVjdGlvbiplbnYqZnJlc25lbExlcnAgO1xuICAgICAgLy8gT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KHZlYzM8ZjMyPih0ZXN0KSxmcmFnRGF0YS5BbGJlZG8uYSkgO1xuICB9XG5cbiAgYCxLbj1gXG4gICAgI2lmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgdmFyIGNsZWFyQ29hdFJvdWdobmVzc01hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgdmFyIGNsZWFyQ29hdFJvdWdobmVzc01hcDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgZm4gZ2V0Q2xlYXJjb2F0Um91Z2huZXNzKCkgLT4gZjMye1xuICAgICAgICBsZXQgY2xlYXJjb2F0Um91Z2huZXNzID0gdGV4dHVyZVNhbXBsZShjbGVhckNvYXRSb3VnaG5lc3NNYXAsIGNsZWFyQ29hdFJvdWdobmVzc01hcFNhbXBsZXIsIE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdVVjAueHkpLnI7XG4gICAgICAgIHJldHVybiBjbGVhcmNvYXRSb3VnaG5lc3M7XG4gICAgfVxuICAgICNlbHNlXG4gICAgZm4gZ2V0Q2xlYXJjb2F0Um91Z2huZXNzKCkgLT4gZjMye1xuICAgICAgICByZXR1cm4gMS4wO1xuICAgIH1cbiAgICAjZW5kaWZcblxuICAgICNpZiBVU0VfQ0xFQVJDT0FUXG4gICAgZm4gQ2xlYXJDb2F0X0JSREYoIGJhc2VDb2xvcjp2ZWMzPGYzMj4sIGNsZWFyQ29hdENvbG9yOnZlYzM8ZjMyPiAsIGlvcjpmMzIgLE46dmVjMzxmMzI+LCBMOnZlYzM8ZjMyPiAsICBWOnZlYzM8ZjMyPiAsIGNsZWFyQ29hdFN0cmVuZ3RoOmYzMiwgY2xlYXJDb2F0UGVyY2VwdHVhbFJvdWdobmVzczpmMzIgLCBhdHQ6ZjMyKSAtPiB2ZWMzPGYzMj4ge1xuICAgICAgICB2YXIgZmFjdG9yID0gY2xhbXAoY2xlYXJDb2F0UGVyY2VwdHVhbFJvdWdobmVzcywgMC4wMDAxLCAxLjApO1xuICAgICAgICB2YXIgY2xlYXJDb2F0Um91Z2huZXNzID0gZmFjdG9yICogZmFjdG9yO1xuXG4gICAgICAgIGxldCBIID0gbm9ybWFsaXplKC1WICsgTCk7XG4gICAgICAgIGxldCBSID0gMi4wICogZG90KCAtViAsIE4gKSAqIE4gKyBWIDtcbiAgICAgICAgbGV0IExvSCA9IGRvdChMLEgpO1xuICAgICAgICBsZXQgTm9WID0gbWF4KGRvdChOLC1WKSwwLjApO1xuICAgICAgICBsZXQgTm9MID0gbWF4KGRvdChOLEwpLDAuMCk7XG4gICAgICAgIGxldCBOb0ggPSBtYXgoZG90KE4sSCksMC4wMDAwMSk7XG5cbiAgICAgICAgbGV0IEZyID0gRnJlc25lbFNjaGxpY2tSb3VnaG5lc3MoIE5vViAsIHZlYzM8ZjMyPigwLjApICwgY2xlYXJDb2F0Um91Z2huZXNzICkgO1xuICAgICAgICB2YXIgRmQgPSBjbGVhckNvYXRDb2xvciAvIDMuMTQxNTkyNiA7XG4gICAgICAgIGxldCBGMCA9IElPUlRvRjAoaW9yKSA7XG4gICAgICAgIC8vIGNsZWFyIGNvYXQgQlJERlxuICAgICAgICB2YXIgRGMgPSBEX0dHWChOb0gsY2xlYXJDb2F0Um91Z2huZXNzKTtcbiAgICAgICAgdmFyIFZjID0gVl9LZWxlbWVuKExvSCkgKiBOb0w7XG4gICAgICAgIHZhciBGYyA9IEZfU2NobGljayggdmVjMzxmMzI+KEYwKSAsIDEuMCwgTm9WKSAqIG1hdGVyaWFsVW5pZm9ybS5jbGVhcmNvYXRGYWN0b3I7XG4gICAgICAgIHZhciBGcmMgPSAoRGMgKiBWYykgKiBGYztcbiAgICAgICAgLy8gYmFzZSBsYXllciBhdHRlbnVhdGlvbiBmb3IgZW5lcmd5IGNvbXBlbnNhdGlvblxuICAgICAgICBsZXQgb25lTWludXNGYyAgPSAxLjAgLSBGYztcbiAgICAgICAgbGV0IGJyZGZTcGVjdWxhciA9ICgoRmQgKyBGciAqIG9uZU1pbnVzRmMpICogb25lTWludXNGYyArIEZyYykgICogYXR0IDsgXG4gICAgICAgIHZhciBpYmxTcGVjdWxhciA9IHZlYzM8ZjMyPihicmRmU3BlY3VsYXIpO1xuICAgICAgICBpYmxTcGVjdWxhciArPSBhcHByb3hpbWF0ZVNwZWN1bGFySUJMKHZlYzM8ZjMyPigxLjApLGNsZWFyQ29hdFJvdWdobmVzcyxSLCBOb1YpICogRmMgO1xuICAgICAgICByZXR1cm4gdmVjMzxmMzI+KG1peChiYXNlQ29sb3IsaWJsU3BlY3VsYXIsbWF0ZXJpYWxVbmlmb3JtLmNsZWFyY29hdFdlaWdodCkpO1xuICAgIH1cbiAgICAjZW5kaWZcbmAsSm49YFxuICAgICNpbmNsdWRlIFwiQ29tbW9uX3ZlcnRcIlxuICAgICNpbmNsdWRlIFwiQ29tbW9uX2ZyYWdcIlxuICAgICNpbmNsdWRlIFwiQnhERl9mcmFnXCJcblxuICAgIGZuIHZlcnQoaW5wdXREYXRhOlZlcnRleEF0dHJpYnV0ZXMpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgIE9SSV9WZXJ0KGlucHV0RGF0YSkgO1xuICAgICAgICByZXR1cm4gT1JJX1ZlcnRleE91dCA7XG4gICAgfVxuXG4gICAgZm4gZnJhZygpe1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvciA9IG1hdGVyaWFsVW5pZm9ybS5iYXNlQ29sb3IgO1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0LlJvdWdobmVzcyA9IG1hdGVyaWFsVW5pZm9ybS5yb3VnaG5lc3MgIDtcbiAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5NZXRhbGxpYyA9IG1hdGVyaWFsVW5pZm9ybS5tZXRhbGxpYyA7XG4gICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuU3BlY3VsYXIgPSAwLjUgO1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0LkFtYmllbnRPY2NsdXNpb24gPSBtYXRlcmlhbFVuaWZvcm0uYW8gO1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0LkVtaXNzaXZlQ29sb3IgPSB2ZWM0PGYzMj4oMC4wKTtcblxuICAgICAgICBPUklfU2hhZGluZ0lucHV0Lk5vcm1hbCA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZE5vcm1hbC5yZ2IgO1xuXG4gICAgICAgIEJ4REZTaGFkaW5nKCk7XG4gICAgfVxuYCxabj1gXG4gICAgI2luY2x1ZGUgXCJDb21tb25fdmVydFwiXG4gICAgI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiXG4gICAgI2luY2x1ZGUgXCJCeERGX2ZyYWdcIlxuXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKVxuICAgIHZhciBiYXNlTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgbm9ybWFsTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgbm9ybWFsTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgICAjaWYgVVNFX0FSTUNcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgICAgIHZhciBtYXNrTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgICAgIHZhciBtYXNrTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgI2VuZGlmXG5cbiAgICAjaWYgVVNFX01SXG4gICAgICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKVxuICAgICAgICB2YXIgbWFza01hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKVxuICAgICAgICB2YXIgbWFza01hcDogdGV4dHVyZV8yZDxmMzI+O1xuICAgICNlbmRpZlxuXG4gICAgI2lmIFVTRV9BT1RFWFxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIGFvTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgICAgIHZhciBhb21hcE1hcDogdGV4dHVyZV8yZDxmMzI+O1xuICAgICNlbmRpZlxuXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgdmFyIGVtaXNzaXZlTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgZW1pc3NpdmVNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgIGZuIHZlcnQoaW5wdXREYXRhOlZlcnRleEF0dHJpYnV0ZXMpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgIE9SSV9WZXJ0KGlucHV0RGF0YSkgO1xuICAgICAgICByZXR1cm4gT1JJX1ZlcnRleE91dCA7XG4gICAgfVxuXG4gICAgZm4gZnJhZygpe1xuICAgICAgICB2YXIgdHJhbnNmb3JtVVYxID0gbWF0ZXJpYWxVbmlmb3JtLnRyYW5zZm9ybVVWMTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVVWMiA9IG1hdGVyaWFsVW5pZm9ybS50cmFuc2Zvcm1VVjI7XG5cbiAgICAgICAgdmFyIHV2ID0gdHJhbnNmb3JtVVYxLnp3ICogT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ1VWMCArIHRyYW5zZm9ybVVWMS54eTsgXG5cbiAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCB1diApIDtcbiAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSB2ZWM0PGYzMj4oZ2FtbWFUb0xpbmVyKE9SSV9TaGFkaW5nSW5wdXQuQmFzZUNvbG9yLnJnYipPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvci53ICkgKiBtYXRlcmlhbFVuaWZvcm0uYmFzZUNvbG9yLnJnYixPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvci53Km1hdGVyaWFsVW5pZm9ybS5iYXNlQ29sb3IuYSkgIDtcbiAgICAgICAgI2lmIFVTRV9BTFBIQUNVVFxuICAgICAgICAgICAgaWYoIChPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvci5hIC0gbWF0ZXJpYWxVbmlmb3JtLmFscGhhQ3V0b2ZmKSA8PSAwLjAgKXtcbiAgICAgICAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4oMC4wLDAuMCwwLjAsMS4wKTtcbiAgICAgICAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQud29ybGRQb3MgPSB2ZWM0PGYzMj4oMC4wLDAuMCwwLjAsMS4wKTtcbiAgICAgICAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQud29ybGROb3JtYWwgPSB2ZWM0PGYzMj4oMC4wLDAuMCwwLjAsMS4wKTtcbiAgICAgICAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQubWF0ZXJpYWwgPSB2ZWM0PGYzMj4oMC4wLDAuMCwwLjAsMS4wKTtcbiAgICAgICAgICAgICAgICBkaXNjYXJkO1xuICAgICAgICAgICAgfVxuICAgICAgICAjZW5kaWZcblxuICAgICAgICAjaWYgVVNFX1NIQURPV01BUElOR1xuICAgICAgICAgICAgdXNlU2hhZG93KCk7XG4gICAgICAgICNlbmRpZlxuXG4gICAgICAgICNpZiBVU0VfQVJNQ1xuICAgICAgICAgICAgdmFyIG1hc2tUZXggPSB0ZXh0dXJlU2FtcGxlKG1hc2tNYXAsIG1hc2tNYXBTYW1wbGVyLCB1diApIDtcblxuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5BbWJpZW50T2NjbHVzaW9uID0gbWFza1RleC5yICogbWF0ZXJpYWxVbmlmb3JtLmFvIDsgXG5cbiAgICAgICAgICAgICNpZiBVU0VfQU9URVhcbiAgICAgICAgICAgICAgICB2YXIgYW9NYXAgPSB0ZXh0dXJlU2FtcGxlKGFvbWFwTWFwLCBhb01hcFNhbXBsZXIsIHV2ICk7XG4gICAgICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5BbWJpZW50T2NjbHVzaW9uID0gbWl4KDAuMCxhb01hcC5yLG1hdGVyaWFsVW5pZm9ybS5hbykgO1xuICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuUm91Z2huZXNzID0gbWFza1RleC5nICogbWF0ZXJpYWxVbmlmb3JtLnJvdWdobmVzcyA7XG4gICAgICAgICAgICBPUklfU2hhZGluZ0lucHV0Lk1ldGFsbGljID0gIG1hc2tUZXguYiAqIG1hdGVyaWFsVW5pZm9ybS5tZXRhbGxpYyA7XG5cbiAgICAgICAgI2Vsc2VpZiBVU0VfTVJcbiAgICAgICAgICAgIHZhciBtYXNrVGV4ID0gdGV4dHVyZVNhbXBsZShtYXNrTWFwLCBtYXNrTWFwU2FtcGxlciwgdXYgKSA7XG4gICAgICAgICAgICAjaWYgVVNFX0FPVEVYXG4gICAgICAgICAgICAgICAgdmFyIGFvTWFwID0gdGV4dHVyZVNhbXBsZShhb21hcE1hcCwgYW9NYXBTYW1wbGVyLCB1diApO1xuICAgICAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuQW1iaWVudE9jY2x1c2lvbiA9IG1peCgwLjAsYW9NYXAucixtYXRlcmlhbFVuaWZvcm0uYW8pIDtcbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5BbWJpZW50T2NjbHVzaW9uID0gbWF0ZXJpYWxVbmlmb3JtLmFvIDsgXG4gICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5Sb3VnaG5lc3MgPSBtYXNrVGV4LmcgKiBtYXRlcmlhbFVuaWZvcm0ucm91Z2huZXNzIDtcbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuTWV0YWxsaWMgPSAgbWFza1RleC5iICogbWF0ZXJpYWxVbmlmb3JtLm1ldGFsbGljO1xuICAgICAgICAjZWxzZVxuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5Sb3VnaG5lc3MgPSBtYXRlcmlhbFVuaWZvcm0ucm91Z2huZXNzIDtcbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuTWV0YWxsaWMgPSBtYXRlcmlhbFVuaWZvcm0ubWV0YWxsaWMgO1xuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5BbWJpZW50T2NjbHVzaW9uID0gIG1hdGVyaWFsVW5pZm9ybS5hbyA7XG4gICAgICAgICAgICAjaWYgVVNFX0FPVEVYXG4gICAgICAgICAgICAgICAgdmFyIGFvTWFwID0gdGV4dHVyZVNhbXBsZShhb21hcE1hcCwgYW9NYXBTYW1wbGVyLCB1diApO1xuICAgICAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuQW1iaWVudE9jY2x1c2lvbiA9IG1peCgwLjAsYW9NYXAucixtYXRlcmlhbFVuaWZvcm0uYW8pIDtcbiAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAjZW5kaWZcblxuICAgICAgICBPUklfU2hhZGluZ0lucHV0LlJvdWdobmVzcyA9IGNsYW1wKE9SSV9TaGFkaW5nSW5wdXQuUm91Z2huZXNzLDAuMDg0LDEuMCk7XG4gICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuU3BlY3VsYXIgPSAwLjUgO1xuXG4gICAgICAgIHZhciBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZVNhbXBsZShlbWlzc2l2ZU1hcCwgZW1pc3NpdmVNYXBTYW1wbGVyICwgT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ1VWMC54eSkgO1xuICAgICAgICBlbWlzc2l2ZUNvbG9yID0gdmVjNDxmMzI+KGdhbW1hVG9MaW5lcihlbWlzc2l2ZUNvbG9yLnJnYiksZW1pc3NpdmVDb2xvci53KTtcbiAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5FbWlzc2l2ZUNvbG9yID0gdmVjNDxmMzI+KG1hdGVyaWFsVW5pZm9ybS5lbWlzc2l2ZUNvbG9yLnJnYiAqIGVtaXNzaXZlQ29sb3IucmdiICogbWF0ZXJpYWxVbmlmb3JtLmVtaXNzaXZlSW50ZW5zaXR5LDEuMCk7XG5cbiAgICAgICAgdmFyIE5vcm1hbCA9IHRleHR1cmVTYW1wbGUobm9ybWFsTWFwLG5vcm1hbE1hcFNhbXBsZXIsdXYpLnJnYiA7XG4gICAgICAgIC8vIE5vcm1hbC55ID0gMS4wIC0gTm9ybWFsLnkgO1xuICAgICAgICAvLyBsZXQgbm9ybWFsID0gdW5QYWNrTm9ybWFsKE5vcm1hbCwxLjAsbWF0ZXJpYWxVbmlmb3JtLm5vcm1hbFNjYWxlKSA7XG4gICAgICAgIGxldCBub3JtYWwgPSB1blBhY2tOb3JtYWwoTm9ybWFsLG1hdGVyaWFsVW5pZm9ybS5ub3JtYWxTY2FsZSkgOyAgXG4gICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuTm9ybWFsID0gbm9ybWFsIDtcblxuICAgICAgICBCeERGU2hhZGluZygpO1xuICAgIH1cbmAsJG49YFxuI2luY2x1ZGUgXCJDbHVzdGVyRGVidWdfZnJhZ1wiIFxuXG4gICAgICAgIGZuIGRlYnVnUG9zaXRpb24oKXtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPihPUklfVmVydGV4VmFyeWluZy52V29ybGRQb3MueHl6LDEuMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbiBkZWJ1Z01lc2hJRCgpe1xuICAgICAgICAgICAgbGV0IG1lc2hJRENvbG9yID0gdTMyKE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZFBvcy53ICkgO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gY29sb3JTZXRbIG1lc2hJRENvbG9yICUgOXVdIDtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPih2ZWMzPGYzMj4oY29sb3IucmdiKSwxLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm4gZGVidWdOb3JtYWwoKXtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPihPUklfU2hhZGluZ0lucHV0Lk5vcm1hbC54eXosMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnVVYoKXtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPihPUklfVmVydGV4VmFyeWluZy5mcmFnVVYwLnh5LDAuMCwxLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm4gZGVidWdDb2xvcigpe1xuICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KGZyYWdEYXRhLkFsYmVkby5yZ2IsMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnRGlmZnVzZSgpe1xuICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KCBmcmFnRGF0YS5MaWdodENoYW5uZWwucmdiLDEuMCk7XG4gICAgICAgICAgICAvLyBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4oMC4yLDAuMiwwLjIsMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnQW1iaWVudCgpe1xuICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KGZyYWdEYXRhLklycmFkaWFuY2UgKiBmcmFnRGF0YS5BbGJlZG8ucmdiLDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZuIGRlYnVnRW1pc3NpdmUoKXtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPihmcmFnRGF0YS5FbWlzc2l2ZS5yZ2IsMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnRW52bWVudCgpe1xuICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KGZyYWdEYXRhLkVudkNvbG9yLnJnYiwxLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm4gZGVidWdBbygpe1xuICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KHZlYzM8ZjMyPihmcmFnRGF0YS5BbyksMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnUm91Z2huZXNzKCl7XG4gICAgICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4odmVjMzxmMzI+KGZyYWdEYXRhLlJvdWdobmVzcyksMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnTWV0YWxsaWMoKXtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPih2ZWMzPGYzMj4oZnJhZ0RhdGEuTWV0YWxsaWMpLDEuMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbiBkZWJ1Z0lycmFkaWFuY2UoKXtcbiAgICAgICAgICAgIE9SSV9GcmFnbWVudE91dHB1dC5jb2xvciA9IHZlYzQ8ZjMyPih2ZWMzPGYzMj4oZnJhZ0RhdGEuSXJyYWRpYW5jZSksMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnVGFuZ2VudCgpe1xuICAgICAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KHZlYzM8ZjMyPihmcmFnRGF0YS5UYW5nZW50Q2hhbm5lbCksMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIGRlYnVnRnJhZ21lbnRPdXQoKXtcbiAgICAgICAgICAgIGlmKE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZC54ID4gZ2xvYmFsVW5pZm9ybS5yZW5kZXJTdGF0ZV9zcGxpdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2xvYmFsVW5pZm9ybS5yZW5kZXJTdGF0ZV9yaWdodClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnQ29sb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z05vcm1hbCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnSXJyYWRpYW5jZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVGFuZ2VudCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnVGFuZ2VudCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnRW1pc3NpdmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0Vudm1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgODoge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0FvKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdSb3VnaG5lc3MoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdNZXRhbGxpYygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0RpZmZ1c2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdBbWJpZW50KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDEzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTWVzaElEKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICAgICAgICAgICNpZiBERUJVR19DTFVTVEVSXG4gICAgICAgICAgICAgICAgICAgICAgZGVidWdDbHVzdGVyKCBPUklfVmVydGV4VmFyeWluZy5mcmFnQ29vcmQgKTtcbiAgICAgICAgICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgICAgICAgICAgICNpZiBERUJVR19DTFVTVEVSXG4gICAgICAgICAgICAgICAgICAgICAgZGVidWdDbHVzdGVyQm94KCBPUklfVmVydGV4VmFyeWluZy5mcmFnQ29vcmQgKTtcbiAgICAgICAgICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDE2OiB7XG4gICAgICAgICAgICAgICAgICAgICNpZiBERUJVR19DTFVTVEVSXG4gICAgICAgICAgICAgICAgICAgICAgZGVidWdDbHVzdGVyTGlnaHRDb3VudCggdmVjNDxmMzI+KE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZC54eXosMC4wKSk7XG4gICAgICAgICAgICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZ2xvYmFsVW5pZm9ybS5yZW5kZXJTdGF0ZV9sZWZ0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1Bvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdDb2xvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTm9ybWFsKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdJcnJhZGlhbmNlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdUYW5nZW50KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVidWdUYW5nZW50KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdFbWlzc2l2ZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnRW52bWVudCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnQW8oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1JvdWdobmVzcygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z01ldGFsbGljKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIDExOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnRGlmZnVzZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSAxMjoge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0FtYmllbnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdNZXNoSUQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHtcbiAgICAgICAgICAgICAgICAgICAgI2lmIERFQlVHX0NMVVNURVJcbiAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0NsdXN0ZXIoIE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZCApO1xuICAgICAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTU6IHtcbiAgICAgICAgICAgICAgICAgICAgI2lmIERFQlVHX0NMVVNURVJcbiAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0NsdXN0ZXJCb3goIE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZCApO1xuICAgICAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTY6IHtcbiAgICAgICAgICAgICAgICAgICAgI2lmIERFQlVHX0NMVVNURVJcbiAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0NsdXN0ZXJMaWdodENvdW50KCB2ZWM0PGYzMj4oT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ0Nvb3JkLnh5eiwwLjApKTtcbiAgICAgICAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuYCxlbD1gXG4gICAgI2luY2x1ZGUgXCJXb3JsZE1hdHJpeFVuaWZvcm1cIlxuICAgICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG5cbiAgICBzdHJ1Y3QgTWF0ZXJpYWxVbmlmb3JtIHtcbiAgICB4OmYzMixcbiAgICB5OmYzMixcbiAgICB3aWR0aDpmMzIsXG4gICAgaGVpZ2h0OmYzMixcbiAgICB9O1xuXG4gICAgc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgICAgIEBsb2NhdGlvbigwKSBmcmFnVVY6IHZlYzI8ZjMyPixcbiAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj5cbiAgICB9O1xuXG4gICAgQHZlcnRleFxuICAgIGZuIG1haW4oQGJ1aWx0aW4odmVydGV4X2luZGV4KSB2ZXJ0ZXhJbmRleCA6IHUzMiwgQGJ1aWx0aW4oaW5zdGFuY2VfaW5kZXgpIGluZGV4IDogdTMyICkgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgY29uc3QgcG9zID0gYXJyYXkoXG4gICAgICAgIHZlYzIoLTEuMCwgLTEuMCksIHZlYzIoMS4wLCAtMS4wKSwgdmVjMigtMS4wLCAxLjApLFxuICAgICAgICB2ZWMyKC0xLjAsIDEuMCksIHZlYzIoMS4wLCAtMS4wKSwgdmVjMigxLjAsIDEuMCksXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHV2ID0gYXJyYXkoXG4gICAgICAgIHZlYzIoMS4wLCAwLjApLCB2ZWMyKDEuMCwgMS4wKSwgdmVjMigwLjAsIDEuMCksIFxuICAgICAgICB2ZWMyKDEuMCwgMC4wKSwgdmVjMigwLjAsIDEuMCksIHZlYzIoMC4wLCAwLjApLFxuICAgICAgICApO1xuICAgICAgICBsZXQgaWQgPSB1MzIoaW5kZXgpIDtcbiAgICAgICAgdmFyIG91dHB1dCA6IFZlcnRleE91dHB1dDtcbiAgICAgICAgb3V0cHV0LmZyYWdVViA9IHV2W3ZlcnRleEluZGV4XSA7XG4gICAgICAgIG91dHB1dC5wb3NpdGlvbiA9IHZlYzQ8ZjMyPihwb3NbdmVydGV4SW5kZXhdICwgMC4wLCAxLjApIDtcbiAgICAgICAgcmV0dXJuIG91dHB1dCA7XG4gICAgfVxuYCx0bD1gXG4jaW5jbHVkZSBcIldvcmxkTWF0cml4VW5pZm9ybVwiXG4gICAgICAjaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuICAgXG4gICAgICBzdHJ1Y3QgTWF0ZXJpYWxVbmlmb3JtIHtcbiAgICAgICAgeDpmMzIsXG4gICAgICAgIHk6ZjMyLFxuICAgICAgICB3aWR0aDpmMzIsXG4gICAgICAgIGhlaWdodDpmMzIsXG4gICAgICB9O1xuXG4gICAgICBzdHJ1Y3QgVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICBAbG9jYXRpb24oMCkgZnJhZ1VWOiB2ZWMyPGYzMj4sXG4gICAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIG1lbWJlcjogdmVjNDxmMzI+XG4gICAgICB9O1xuXG4gICAgICBAdmVydGV4XG4gICAgICBmbiBtYWluKEBidWlsdGluKGluc3RhbmNlX2luZGV4KSBpbmRleCA6IHUzMixAbG9jYXRpb24oMCkgcG9zaXRpb246IHZlYzM8ZjMyPiwgQGxvY2F0aW9uKDEpIFRFWENPT1JEXzE6IHZlYzI8ZjMyPikgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICBsZXQgaWQgPSB1MzIoaW5kZXgpIDtcbiAgICAgICAgICBsZXQgd29ybGRNYXRyaXggPSBtb2RlbHMubWF0cml4W2lkXTtcblxuICAgICAgICAgIGxldCB3aW5kb3dTaXplID0gdmVjMjxmMzI+KGdsb2JhbFVuaWZvcm0ud2luZG93V2lkdGgsZ2xvYmFsVW5pZm9ybS53aW5kb3dIZWlnaHQpIDtcblxuICAgICAgICAvLyAgIGxldCBwb3MgPSB3b3JsZE1hdHJpeFszXS54eSA7XG5cbiAgICAgICAgICBsZXQgc2l6ZSA9IHZlYzI8ZjMyPih3b3JsZE1hdHJpeFswXS54LHdvcmxkTWF0cml4WzFdLnkpIC8gd2luZG93U2l6ZSA7XG5cbiAgICAgICAgICBsZXQgdXYgPSB2ZWMyKCgoVEVYQ09PUkRfMS54eSAqIDIuMCkgLSB2ZWMyPGYzMj4oMS4wKSkpICA7Ly8gLyB3aW5kb3dTaXplICogc2l6ZSAtIG9mZnNldCA7XG5cbiAgICAgICAgICByZXR1cm4gVmVydGV4T3V0cHV0KFRFWENPT1JEXzEsIHZlYzQ8ZjMyPih1diwgMC4wLCAxLjApKTtcbiAgICAgIH1cbmAsaWw9YFxuICAgIHN0cnVjdCBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIEBsb2NhdGlvbigwKSBvX1RhcmdldDogdmVjNDxmMzI+XG4gICAgfTtcblxuICAgIHZhcjxwcml2YXRlPiBmcmFnVVYxOiB2ZWMyPGYzMj47XG4gICAgdmFyPHByaXZhdGU+IG9fVGFyZ2V0OiB2ZWM0PGYzMj47XG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKDApXG4gICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgxKSBAYmluZGluZygxKVxuICAgIHZhciBiYXNlTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgICBAZnJhZ21lbnRcbiAgICBmbiBtYWluKEBsb2NhdGlvbigwKSBmcmFnVVY6IHZlYzI8ZjMyPikgLT4gRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICB2YXIgdXYgPSBmcmFnVVYgO1xuICAgICAgICB1di55ID0gMS4wIC0gdXYueSA7XG4gICAgICAgIHZhciBjb2xvcjogdmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZShiYXNlTWFwLCBiYXNlTWFwU2FtcGxlciwgdXYgKTtcblxuICAgICAgICByZXR1cm4gRnJhZ21lbnRPdXRwdXQoY29sb3IpO1xuICAgIH1cbmAscmw9YFxuICAgIHN0cnVjdCBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIEBsb2NhdGlvbigwKSBvX1RhcmdldDogdmVjNDxmMzI+XG4gICAgfTsgXG5cbiAgICB2YXI8cHJpdmF0ZT4gZnJhZ1VWMTogdmVjMjxmMzI+O1xuICAgIHZhcjxwcml2YXRlPiBvX1RhcmdldDogdmVjNDxmMzI+O1xuXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKDApXG4gICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgxKSBAYmluZGluZygxKVxuICAgIHZhciBiYXNlTWFwOiB0ZXh0dXJlX2RlcHRoXzJkIDtcblxuICAgIGZuIExpbmVhcjAxRGVwdGgoICB6IDogZjMyICkgLT4gZjMyXG4gICAge1xuICAgICAgICByZXR1cm4gMS4wIC8gKDEuMCAqIHogKyA1MDAwLjApO1xuICAgIH1cblxuICAgIEBmcmFnbWVudFxuICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+KSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIHZhciB1diA9IGZyYWdVViA7XG4gICAgICAgIHV2LnkgPSAxLjAgLSB1di55IDtcbiAgICAgICAgdmFyIGRlcHRoID0gdGV4dHVyZVNhbXBsZShiYXNlTWFwLCBiYXNlTWFwU2FtcGxlciwgdXYgLCB2ZWMyPGkzMj4oMCkgKSA7XG4gICAgICAgIHJldHVybiBGcmFnbWVudE91dHB1dCh2ZWM0PGYzMj4oZGVwdGgsMC4wLDAuMCwxLjApKTtcbiAgICB9XG5gLHNsPWBcbiAgICBzdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICBAbG9jYXRpb24oMCkgb19UYXJnZXQ6IHZlYzQ8ZjMyPlxuICAgIH07XG5cbiAgICB2YXI8cHJpdmF0ZT4gZnJhZ1VWMTogdmVjMjxmMzI+O1xuICAgIHZhcjxwcml2YXRlPiBvX1RhcmdldDogdmVjNDxmMzI+O1xuXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKDApXG4gICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgxKSBAYmluZGluZygxKVxuICAgIHZhciBiYXNlTWFwOiB0ZXh0dXJlX2RlcHRoX2N1YmUgO1xuXG4gICAgZm4gdXZUb1hZWiggZmFjZSA6IGkzMiAsICB1diA6IHZlYzI8ZjMyPiApIC0+IHZlYzM8ZjMyPlxuICAgIHtcbiAgICAgICAgdmFyIG91dCA6IHZlYzM8ZjMyPiA7XG4gICAgICAgIGlmKGZhY2UgPT0gMCl7XG4gICAgICAgICAgICBvdXQgPSB2ZWMzPGYzMj4oIDEuMCwgdXYueSwgLXV2LngpO1xuICAgICAgICB9ZWxzZSBpZihmYWNlID09IDEpe1xuICAgICAgICAgICAgb3V0ID0gdmVjMzxmMzI+KCAtMS4wLCB1di55LCB1di54KTtcbiAgICAgICAgfWVsc2UgaWYoZmFjZSA9PSAyKXtcbiAgICAgICAgICAgIG91dCA9IHZlYzM8ZjMyPiggdXYueCwgLTEuMCwgdXYueSk7XG4gICAgICAgIH1lbHNlIGlmKGZhY2UgPT0gMyl7XG4gICAgICAgICAgICBvdXQgPSB2ZWMzPGYzMj4oIHV2LngsICAxLjAsIC11di55KTtcbiAgICAgICAgfWVsc2UgaWYoZmFjZSA9PSA0KXtcbiAgICAgICAgICAgIG91dCA9IHZlYzM8ZjMyPiggdXYueCwgdXYueSwgMS4wKTtcbiAgICAgICAgfWVsc2V7XHRcbiAgICAgICAgICAgIG91dCA9IHZlYzM8ZjMyPiggLXV2LngsIHV2LnksIC0xLjApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQgO1xuICAgIH1cblxuICAgIEBmcmFnbWVudFxuICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+KSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIHZhciB1diA9IGZyYWdVViA7XG4gICAgICAgIHV2LnkgPSAxLjAgLSB1di55IDtcbiAgICAgICAgdmFyIGlpID0gMC4xNiA7XG4gICAgICAgIHZhciBvdXYgPSB2ZWMzPGYzMj4oMC4wKTtcbiAgICAgICAgaWYodXYueCA8IGlpICogNi4wKXtcbiAgICAgICAgICAgIG91diA9IHV2VG9YWVooNSx1di9paSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXYueCA8IGlpICogNS4wKXtcbiAgICAgICAgICAgIG91diA9IHV2VG9YWVooNCx1di9paSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXYueCA8IGlpICogNC4wKXtcbiAgICAgICAgICAgIG91diA9IHV2VG9YWVooMyx1di9paSk7XG4gICAgICAgIH0gXG4gICAgICAgIGlmKHV2LnggPCBpaSAqIDMuMCl7XG4gICAgICAgICAgICBvdXYgPSB1dlRvWFlaKDIsdXYvaWkpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHV2LnggPCBpaSAqIDIuMCl7XG4gICAgICAgICAgICBvdXYgPSB1dlRvWFlaKDEsdXYvaWkpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHV2LnggPCBpaSAqIDEuMCl7XG4gICAgICAgICAgICBvdXYgPSB1dlRvWFlaKDAsdXYvaWkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXB0aCA9IHRleHR1cmVTYW1wbGUoYmFzZU1hcCwgYmFzZU1hcFNhbXBsZXIsIG91diApIDtcbiAgICAgICAgZGVwdGggPSAxLjAgLSBkZXB0aDsgXG5cbiAgICAgICAgcmV0dXJuIEZyYWdtZW50T3V0cHV0KHZlYzQ8ZjMyPihkZXB0aCwwLjAsMC4wLDEuMCkpO1xuICAgIH1cbmAsWGY9YFxuICAgIHN0cnVjdCBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIEBsb2NhdGlvbigwKSBvX1RhcmdldDogdmVjNDxmMzI+XG4gICAgfTtcblxuICAgIHZhcjxwcml2YXRlPiBmcmFnVVYxOiB2ZWMyPGYzMj47XG4gICAgdmFyPHByaXZhdGU+IG9fVGFyZ2V0OiB2ZWM0PGYzMj47XG5cbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMClcbiAgICB2YXIgYmFzZU1hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKDEpXG4gICAgdmFyIGJhc2VNYXA6IHRleHR1cmVfMmRfYXJyYXkgO1xuXG4gICAgc3RydWN0IE1hdGVyaWFsRGF0YXtcbiAgICAgICAgaW5kZXg6ZjMyO1xuICAgIH1cblxuICAgIEBmcmFnbWVudFxuICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+KSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIHZhciB1diA9IGZyYWdVViA7XG4gICAgICAgIHV2LnkgPSAxLjAgLSB1di55IDtcbiAgICBcbiAgICAgICAgdmFyIGRlcHRoID0gdGV4dHVyZVNhbXBsZShiYXNlTWFwLCBiYXNlTWFwU2FtcGxlciwgb3V2ICkgO1xuICAgICAgICBkZXB0aCA9IDEuMCAtIGRlcHRoOyBcblxuICAgICAgICByZXR1cm4gRnJhZ21lbnRPdXRwdXQodmVjNDxmMzI+KGRlcHRoLDAuMCwwLjAsMS4wKSk7XG4gICAgfVxuYCxqYT1gXG4gICAgZm4gZ2V0SERSQ29sb3IoY29sb3I6IHZlYzM8ZjMyPiwgZXhwb3N1cmU6IGYzMikgLT4gdmVjMyA8IGYzMiA+IHtcbiAgICAgICAgLy8gdmFyIG5ld0NvbG9yID0gY29sb3IgKiAoICAxLjAgLyAyNTUuMCApIDtcbiAgICAgICAgcmV0dXJuIGNvbG9yICogcG93KDIuNCwgZXhwb3N1cmUpIDtcbiAgICB9XG5cbiAgICBmbiBsYW1iZGEycmdiKGxhbWJkYSA6IGYzMikgLT4gdmVjMyA8IGYzMiA+IHtcbiAgICAgICAgbGV0IHVsdHJhdmlvbGV0ID0gNDAwLjA7XG4gICAgICAgIGxldCBpbmZyYXJlZCA9IDcwMC4wO1xuXG4gICAgICAgIHZhciBhID0gKGxhbWJkYSAtIHVsdHJhdmlvbGV0KSAvIChpbmZyYXJlZCAtIHVsdHJhdmlvbGV0KTtcbiAgICAgICAgbGV0IGMgPSAxMC4wO1xuICAgICAgICB2YXIgYiA9IHZlYzM8ZjMyPihhKSAtIHZlYzM8ZjMyPigwLjc1LCAwLjUsIDAuMjUpO1xuICAgICAgICByZXR1cm4gbWF4KCgxLjAgLSBjICogYiAqIGIpLCB2ZWMzPGYzMj4oMC4wKSk7XG4gICAgfVxuXG4gICAgZm4gQ0VUb25lTWFwcGluZyhjb2xvcjogdmVjMzxmMzI+LCBhZGFwdGVkX2x1bTogZjMyKSAtPiB2ZWMzPGYzMj5cbiAgICB7XG4gICAgICAgIHJldHVybiAxLjAgLSBleHAoLWFkYXB0ZWRfbHVtICogY29sb3IpO1xuICAgIH1cblxuICAgIGZuIEFDRVNUb25lTWFwcGluZyhjb2xvcjogdmVjMzxmMzI+LCBhZGFwdGVkX2x1bTogZjMyKSAtPiB2ZWMzPGYzMj5cbiAgICB7XG4gICAgICAgIGxldCBBID0gMi41MTtcbiAgICAgICAgbGV0IEIgPSAwLjAzO1xuICAgICAgICBsZXQgQyA9IDIuNDM7XG4gICAgICAgIGxldCBEID0gMC41OTtcbiAgICAgICAgbGV0IEUgPSAwLjE0O1xuXG4gICAgICAgIHZhciBjb2xvcjIgPSBjb2xvciAqIGFkYXB0ZWRfbHVtO1xuICAgICAgICBjb2xvcjIgPSAoY29sb3IyICogKEEgKiBjb2xvcjIgKyBCKSkgLyAoY29sb3IyICogKEMgKiBjb2xvcjIgKyBEKSArIEUpO1xuICAgICAgICByZXR1cm4gY29sb3IyO1xuICAgIH1cblxuICAgIGZuIGdhbW1hVG9MaW5lcihjb2xvcjogdmVjMzxmMzI+KSAtPiB2ZWMzIDwgZjMyID4ge1xuICAgICAgICBsZXQgZ2FtbWFDb3JyZWN0ID0gMi40O1xuICAgICAgICB2YXIgY29sb3IyID0gcG93KGNvbG9yLCB2ZWMzPGYzMj4oZ2FtbWFDb3JyZWN0KSk7XG4gICAgICAgIHJldHVybiBjb2xvcjIgO1xuICAgIH1cblxuICAgIGZuIGxpbmVyVG9HYW1tYTQoY29sb3I6IHZlYzQ8ZjMyPikgLT4gdmVjNCA8IGYzMiA+IHtcbiAgICAgICAgbGV0IGdhbW1hQ29ycmVjdCA9IDAuNDE2NjY2NjY3O1xuICAgICAgICB2YXIgY29sb3IyID0gcG93KGNvbG9yLCB2ZWM0PGYzMj4oZ2FtbWFDb3JyZWN0KSk7XG4gICAgICAgIHJldHVybiBjb2xvcjIgO1xuICAgIH1cblxuICAgIGZuIGxpbmVyVG9HYW1tYTMoY29sb3I6IHZlYzM8ZjMyPikgLT4gdmVjMyA8IGYzMiA+IHtcbiAgICAgICAgbGV0IGdhbW1hQ29ycmVjdCA9IDAuNDE2NjY2NjY3O1xuICAgICAgICB2YXIgY29sb3IyID0gcG93KGNvbG9yLCB2ZWMzPGYzMj4oZ2FtbWFDb3JyZWN0KSk7XG4gICAgICAgIHJldHVybiBjb2xvcjIgO1xuICAgIH1cblxuICAgIGZuIExpbmVhclRvR2FtbWFTcGFjZShsaW5SR0IwOiB2ZWMzPGYzMj4pIC0+IHZlYzMgPCBmMzIgPiB7XG4gICAgICAgIHZhciBsaW5SR0IgPSBtYXgobGluUkdCMCwgdmVjMygwLjAsIDAuMCwgMC4wKSk7XG4gICAgICAgIGxpblJHQi5yID0gcG93KGxpblJHQi5yLCAwLjQxNjY2NjY2Nyk7XG4gICAgICAgIGxpblJHQi5nID0gcG93KGxpblJHQi5nLCAwLjQxNjY2NjY2Nyk7XG4gICAgICAgIGxpblJHQi5iID0gcG93KGxpblJHQi5iLCAwLjQxNjY2NjY2Nyk7XG4gICAgICAgIHJldHVybiBtYXgoMS4wNTUgKiBsaW5SR0IgLSAwLjA1NSwgdmVjMygwLjAsIDAuMCwgMC4wKSk7XG4gICAgfVxuXG4gICAgdmFyPHByaXZhdGU+c1JHQl8yX0xNU19NQVQ6IG1hdDN4MzxmMzI+ID0gbWF0M3gzPGYzMj4oXG4gICAgICAgIDE3Ljg4MjQsIDQzLjUxNjEsIDQuMTE5MyxcbiAgICAgICAgMy40NTU3LCAyNy4xNTU0LCAzLjg2NzEsXG4gICAgICAgIDAuMDI5OTYsIDAuMTg0MzEsIDEuNDY3MCxcbiAgICApO1xuXG4gICAgdmFyPHByaXZhdGU+TE1TXzJfc1JHQl9NQVQ6IG1hdDN4MzxmMzI+ID0gbWF0M3gzPGYzMj4oXG4gICAgICAgIDAuMDgwOSwgLTAuMTMwNSwgMC4xMTY3LFxuICAgICAgICAtMC4wMTAyLCAwLjA1NDAsIC0wLjExMzYsXG4gICAgICAgIC0wLjAwMDMsIC0wLjAwNDEsIDAuNjkzNSxcbiAgICApO1xuXG4gICAgZm4gc1JHQl8yX0xNUyhSR0I6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICByZXR1cm4gc1JHQl8yX0xNU19NQVQgKiBSR0I7XG4gICAgfVxuXG4gICAgZm4gTE1TXzJfc1JHQihMTVM6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICByZXR1cm4gTE1TXzJfc1JHQl9NQVQgKiBMTVM7XG4gICAgfVxuXG4gICAgZm4gTGluZWFyVG9TcmdiQnJhbmNobGVzcyhsaW46IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICB2YXIgbGluMiA9IG1heCh2ZWMzPGYzMj4oNi4xMDM1MmUtNSksIGxpbik7XG4gICAgICAgIHJldHVybiBtaW4obGluMiAqIDEyLjkyLCBwb3cobWF4KGxpbjIsIHZlYzM8ZjMyPigwLjAwMzEzMDY3KSksIHZlYzM8ZjMyPigwLjQxNjY2NjY2NykpICogdmVjMzxmMzI+KDEuMDU1KSAtIHZlYzM8ZjMyPigwLjA1NSkpO1xuICAgIH1cblxuICAgIGZuIHNSR0JUb0xpbmVhcihjb2xvciA6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICBsZXQgY29sb3IyID0gbWF4KHZlYzM8ZjMyPig2LjEwMzUyZS01KSwgY29sb3IpO1xuICAgICAgICBsZXQgYyA9IDAuMDQwNDU7XG4gICAgICAgIGlmIChjb2xvcjIuciA+IGMgJiYgY29sb3IyLmcgPiBjICYmIGNvbG9yMi5iID4gYykge1xuICAgICAgICAgICAgcmV0dXJuIHBvdyhjb2xvcjIgKiAoMS4wIC8gMS4wNTUpICsgMC4wNTIxMzI3LCB2ZWMzPGYzMj4oMi40KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IyICogKDEuMCAvIDEyLjkyKTtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gICAgIGZuIFJlb3JpZW50ZWRCbGVuZE5vcm1hbCgpe1xuLy8gICAgICAgICB2ZWMzIHQgPSB0ZXh0dXJlKGJhc2VNYXAsICAgdXYpLnh5eiAqIHZlYzMoIDIuMCwgIDIuMCwgMi4wKSArIHZlYzMoLTEuMCwgLTEuMCwgIDAuMCk7XG4vLyB2ZWMzIHUgPSB0ZXh0dXJlKGRldGFpbE1hcCwgdXYpLnh5eiAqIHZlYzMoLTIuMCwgLTIuMCwgMi4wKSArIHZlYzMoIDEuMCwgIDEuMCwgLTEuMCk7XG4vLyB2ZWMzIHIgPSBub3JtYWxpemUodCAqIGRvdCh0LCB1KSAtIHUgKiB0LnopO1xuLy8gcmV0dXJuIHI7XG4vLyAgICAgfVxuXG4vLyAgICAgZm4gVUROQmxlbmROb3JtYWwoKXtcbiAgICAvLyB2ZWMzIHQgPSB0ZXh0dXJlKGJhc2VNYXAsICAgdXYpLnh5eiAqIDIuMCAtIDEuMDtcbiAgICAvLyB2ZWMzIHUgPSB0ZXh0dXJlKGRldGFpbE1hcCwgdXYpLnh5eiAqIDIuMCAtIDEuMDtcbiAgICAvLyB2ZWMzIHIgPSBub3JtYWxpemUodC54eSArIHUueHksIHQueik7XG4gICAgLy8gcmV0dXJuIHI7XG4vLyAgICAgfVxuYCxhbD1gXG4gICAgZm4gbWFkZnJhYyhBOmYzMiwgQjpmMzIpLT4gZjMyIHtcbiAgICAgICAgcmV0dXJuIEEqQi1mbG9vcihBKkIpIDtcbiAgICB9XG5cbiAgICBmbiBzYW1wbGVSYW5kb21EaXIoY291bnQ6dTMyLFNBTVBMRV9DT1VOVDp1MzIpIC0+IHZlYzM8ZjMyPntcbiAgICB2YXIgcmF5X2RpciA9IHNwaGVyaWNhbEZpYm9uYWNjaShmMzIoKGNvdW50KSksIGYzMihTQU1QTEVfQ09VTlQpICk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShyYXlfZGlyKSA7XG4gICAgfVxuXG4gICAgZm4gc3BoZXJpY2FsRmlib25hY2NpKCBpIDogZjMyICwgIG4gOiBmMzIgKSAtPiB2ZWMzPGYzMj57XG4gICAgICAgIGNvbnN0IFBISSA9IHNxcnQoNS4wKSAqIDAuNSArIDAuNTtcbiAgICAgICAgbGV0IHBoaSA9IDIuMCAqIFBJICogbWFkZnJhYyhpLCBQSEkgLSAxKTtcbiAgICAgICAgbGV0IGNvc1RoZXRhID0gMS4wIC0gKDIuMCAqIGkgKyAxLjApICogKDEuMCAvIG4pO1xuICAgICAgICBsZXQgc2luVGhldGEgPSBzcXJ0KHNhdHVyYXRlKDEuMCAtIGNvc1RoZXRhKmNvc1RoZXRhKSk7XG5cbiAgICAgICAgcmV0dXJuIHZlYzM8ZjMyPihcbiAgICAgICAgICAgIGNvcyhwaGkpICogc2luVGhldGEsXG4gICAgICAgICAgICBzaW4ocGhpKSAqIHNpblRoZXRhLFxuICAgICAgICAgICAgY29zVGhldGEpO1xuXG4gICAgfVxuYDtjbGFzcyBOe3N0YXRpYyBpbml0KCl7Ti5yZWdpc3RlcihcIk1hdGhTaGFkZXJcIixCcyksTi5yZWdpc3RlcihcIkZhc3RNYXRoU2hhZGVyXCIsR24pLE4ucmVnaXN0ZXIoXCJNYXRyaXhTaGFkZXJcIixTYyksTi5yZWdpc3RlcihcIkdsb2JhbFVuaWZvcm1cIixUcyksTi5yZWdpc3RlcihcIldvcmxkTWF0cml4VW5pZm9ybVwiLFhhKSxOLnJlZ2lzdGVyKFwiTm9ybWFsTWFwX2ZyYWdcIixRbiksTi5yZWdpc3RlcihcIkxpZ2h0aW5nRnVuY3Rpb25fZnJhZ1wiLEJuKSxOLnJlZ2lzdGVyKFwiUGh5c2ljTWF0ZXJpYWxVbmlmb3JtX2ZyYWdcIixUbiksTi5yZWdpc3RlcihcIlVuTGl0TWF0ZXJpYWxVbmlmb3JtX2ZyYWdcIixNbiksTi5yZWdpc3RlcihcIlZpZGVvVW5pZm9ybV9mcmFnXCIsUm4pLE4ucmVnaXN0ZXIoXCJJbnN0YW5jZVVuaWZvcm1cIix6biksTi5yZWdpc3RlcihcIklubGluZV92ZXJ0XCIsVW4pLE4ucmVnaXN0ZXIoXCJWZXJ0ZXhBdHRyaWJ1dGVzX3ZlcnRcIixQbiksTi5yZWdpc3RlcihcIkNvbW1vbl92ZXJ0XCIsTm4pLE4ucmVnaXN0ZXIoXCJDb21tb25fZnJhZ1wiLE9uKSxOLnJlZ2lzdGVyKFwiRnJhZ21lbnRWYXJ5aW5nXCIsVm4pLE4ucmVnaXN0ZXIoXCJDb2xvclBhc3NGcmFnbWVudE91dHB1dFwiLFdhKSxOLnJlZ2lzdGVyKFwiQ2x1c3RlckxpZ2h0XCIsX2MpLE4ucmVnaXN0ZXIoXCJTaGFkaW5nSW5wdXRcIixIbiksTi5yZWdpc3RlcihcIklFU1Byb2ZpbGVzX2ZyYWdcIixZbiksTi5yZWdpc3RlcihcIlNoYWRvd01hcHBpbmdfZnJhZ1wiLFhuKSxOLnJlZ2lzdGVyKFwiSXJyYWRpYW5jZV9mcmFnXCIsV24pLE4ucmVnaXN0ZXIoXCJJcnJhZGlhbmNlVm9sdW1lRGF0YV9mcmFnXCIsTG4pLE4ucmVnaXN0ZXIoXCJCcmRmTHV0X2ZyYWdcIixGbiksTi5yZWdpc3RlcihcIkVudk1hcF9mcmFnXCIsa24pLE4ucmVnaXN0ZXIoXCJDb2xvclV0aWxfZnJhZ1wiLGphKSxOLnJlZ2lzdGVyKFwiQ29sb3JVdGlsXCIsamEpLE4ucmVnaXN0ZXIoXCJCUkRGX2ZyYWdcIixqbiksTi5yZWdpc3RlcihcIkJ4REZfZnJhZ1wiLHFuKSxOLnJlZ2lzdGVyKFwiVW5MaXRfZnJhZ1wiLERuKSxOLnJlZ2lzdGVyKFwiVW5MaXRcIix0biksTi5yZWdpc3RlcihcIkNsZWFyY29hdF9mcmFnXCIsS24pLE4ucmVnaXN0ZXIoXCJMaXRTaGFkZXJcIixKbiksTi5yZWdpc3RlcihcIlBCUkxJdFNoYWRlclwiLFpuKSxOLnJlZ2lzdGVyKFwiQ2x1c3RlckRlYnVnX2ZyYWdcIixFbiksTi5yZWdpc3RlcihcIkJ4ZGZEZWJ1Z19mcmFnXCIsJG4pLE4ucmVnaXN0ZXIoXCJHZW5lcmF5UmFuZG9tRGlyXCIsYWwpLE4ucmVnaXN0ZXIoXCJRdWFkX3ZlcnRfd2dzbFwiLHRsKSxOLnJlZ2lzdGVyKFwiUXVhZF9mcmFnX3dnc2xcIixpbCksTi5yZWdpc3RlcihcIlF1YWRfZGVwdGgyZF9mcmFnX3dnc2xcIixybCksTi5yZWdpc3RlcihcIlF1YWRfZGVwdGhDdWJlX2ZyYWdfd2dzbFwiLHNsKSxOLnJlZ2lzdGVyKFwic2t5X3ZzX2ZyYWdfd2dzbFwiLFVyLnNreV92c19mcmFnX3dnc2wpLE4ucmVnaXN0ZXIoXCJza3lfZnNfZnJhZ193Z3NsXCIsVXIuc2t5X2ZzX2ZyYWdfd2dzbCksTi5yZWdpc3RlcihcIkJsb29tX0JyaWdodG5lc3NfZnJhZ193Z3NsXCIsQ2kuQmxvb21fQnJpZ2h0bmVzc19mcmFnX3dnc2wpLE4ucmVnaXN0ZXIoXCJCbG9vbV9ibHVyX2ZyYWdfd2dzbFwiLENpLkJsb29tX2JsdXJfZnJhZ193Z3NsKSxOLnJlZ2lzdGVyKFwiQmxvb21fY29tcG9zaXRlX2ZyYWdfd2dzbFwiLENpLkJsb29tX2NvbXBvc2l0ZV9mcmFnX3dnc2wpLE4ucmVnaXN0ZXIoXCJMYW1iZXJ0U2hhZGVyXCIsd2MpLE4ucmVnaXN0ZXIoXCJRdWFkR2xzbF92c1wiLHhjKSxOLnJlZ2lzdGVyKFwiUXVhZEdsc2xfZnNcIix2YyksTi5yZWdpc3RlcihcIlNreUdCdWZmZXJfZnNcIixnYyksTi5yZWdpc3RlcihcImdidWZmZXJfdnNcIiwkbyksTi5yZWdpc3RlcihcImdidWZmZXJfZnNcIiwkbyksTi5yZWdpc3RlcihcImNhc3RQb2ludFNoYWRvd01hcF92ZXJ0XCIsY2MpLE4ucmVnaXN0ZXIoXCJzaGFkb3dDYXN0TWFwX2ZyYWdcIixmYyksTi5yZWdpc3RlcihcInNoYWRvd0Nhc3RNYXBfdmVydFwiLHVjKSxOLnJlZ2lzdGVyKFwiZGlyZWN0aW9uU2hhZG93Q2FzdE1hcF9mcmFnXCIsZGMpLE4ucmVnaXN0ZXIoXCJaUGFzc19zaGFkZXJfdnNcIixBYyksTi5yZWdpc3RlcihcIlpQYXNzX3NoYWRlcl9mc1wiLG1jKX1zdGF0aWMgcmVnaXN0ZXIoZSx0KXtOW2UudG9Mb3dlckNhc2UoKV18fChOW2UudG9Mb3dlckNhc2UoKV09dCl9c3RhdGljIGdldFNoYWRlcihlKXtyZXR1cm4gTltlLnRvTG93ZXJDYXNlKCldLE5bZS50b0xvd2VyQ2FzZSgpXX19Y29uc3QgU2U9Y2xhc3N7Y29uc3RydWN0b3IoaT0wLGU9MCl7byh0aGlzLFwieFwiLDApLG8odGhpcyxcInlcIiwwKSx0aGlzLng9aSx0aGlzLnk9ZX1zdGF0aWMgZ2V0QW5nbGUoaSxlKXtyZXR1cm4gTWF0aC5hdGFuMihlLnktaS55LGUueC1pLngpfXN0YXRpYyBzbGVycChpLGUsdCl7bGV0IHI9bmV3IFNlLHM9aS5kb3QoZSk7aWYoczwwJiYoZS54PS1lLngsZS55PS1lLnkscz0tcykscz4uOTk5NSlyZXR1cm4gci54PWkueCt0KihlLngtaS54KSxyLnk9aS55K3QqKGUueS1pLnkpLHI7bGV0IGE9TWF0aC5hY29zKHMpLG49TWF0aC5zaW4oYSksbD1NYXRoLnNpbigoMS10KSphKS9uLGg9TWF0aC5zaW4odCphKS9uO3JldHVybiByLng9bCppLngraCplLngsci55PWwqaS55K2gqZS55LHJ9c3RhdGljIGxlcnAoaSxlLHQpe3JldHVybiBTZS5IRUxQXzAuY29weUZyb20oaSksU2UuSEVMUF8xLmNvcHlGcm9tKGUpLFNlLkhFTFBfMC5zY2FsZSh0KSxTZS5IRUxQXzEuc2NhbGUoMS10KSxuZXcgU2UoU2UuSEVMUF8wLngrU2UuSEVMUF8xLngsU2UuSEVMUF8wLnkrU2UuSEVMUF8xLnkpfXNldChpPTAsZT0wKXtyZXR1cm4gdGhpcy54PWksdGhpcy55PWUsdGhpc31kaXN0YW5jZShpKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueC1pLngsMikrTWF0aC5wb3codGhpcy55LWkueSwyKSl9YWRkKGksZSl7cmV0dXJuIGU9ZXx8bmV3IFNlLGUueD10aGlzLngraS54LGUueT10aGlzLnkraS55LGV9c3ViKGksZSl7cmV0dXJuIGU9ZXx8bmV3IFNlLGUueD10aGlzLngtaS54LGUueT10aGlzLnktaS55LGV9c2NhbGUoaSl7cmV0dXJuIHRoaXMueD10aGlzLngqaSx0aGlzLnk9dGhpcy55KmksdGhpc31tdWx0aXBseShpLGUpe3JldHVybiBlPWV8fG5ldyBTZSxlLng9dGhpcy54KmksZS55PXRoaXMueSppLGV9bXVsdGlwbHlTY2FsZXIoaSl7cmV0dXJuIHRoaXMueCo9aSx0aGlzLnkqPWksdGhpc31kaXZpZGUoaSxlKXtyZXR1cm4gZT1lfHxuZXcgU2UsZS54PXRoaXMueC9pLGUueT10aGlzLnkvaSxlfW5lZyhpKXtyZXR1cm4gaXx8KGk9bmV3IFNlKSxpLng9LWkueCxpLnk9LWkueSxpfWFicygpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55KX1sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9Z2V0QW5nbGUoaSl7cmV0dXJuIE1hdGguYXRhbjIoaS55LXRoaXMueSxpLngtdGhpcy54KX11bnQoaSl7aT1pfHxuZXcgU2U7bGV0IGU9dGhpcy5hYnMoKTtyZXR1cm4gaS54PXRoaXMueC9lLGkueT10aGlzLnkvZSxpfWFuZ2xlVG8oaSl7bGV0IGU9aS54LXRoaXMueCx0PWkueS10aGlzLnk7cmV0dXJuIE1hdGguYXRhbjIodCxlKX1lcXVhbHMoaSl7cmV0dXJuIE1hdGguYWJzKHRoaXMueC1pLngpPDFlLTYmJk1hdGguYWJzKHRoaXMueS1pLnkpPDFlLTZ9cGFsKGkpe2xldCBlPXRoaXMudW50KCksdD1pLnVudCgpO3JldHVybiBlLmVxdWFscyh0KT8xOmUuZXF1YWxzKHQubmVnKCkpPy0xOjB9Y2xvbmUoKXtyZXR1cm4gbmV3IFNlKHRoaXMueCx0aGlzLnkpfWNvcHlGcm9tKGkpe3JldHVybiB0aGlzLng9aS54LHRoaXMueT1pLnksdGhpc31kb3QoaSl7cmV0dXJuIHRoaXMueCppLngrdGhpcy55KmkueX1ub3JtYWxpemUoKXtsZXQgaT10aGlzLmFicygpO3JldHVybiB0aGlzLng9dGhpcy54L2ksdGhpcy55PXRoaXMueS9pLHRoaXN9YWRkSW5QbGFjZShpKXtyZXR1cm4gdGhpcy54Kz1pLngsdGhpcy55Kz1pLnksdGhpc31hZGRTY2FsYXIoaSl7cmV0dXJuIHRoaXMueCs9aSx0aGlzLnkrPWksdGhpc31jbGFtcFNjYWxhcihpLGUpe3JldHVybiB0aGlzLng9TWF0aC5tYXgoaSxNYXRoLm1pbihlLHRoaXMueCkpLHRoaXMueT1NYXRoLm1heChpLE1hdGgubWluKGUsdGhpcy55KSksdGhpc319O2xldCBaPVNlO28oWixcIkhFTFBfMFwiLG5ldyBTZSksbyhaLFwiSEVMUF8xXCIsbmV3IFNlKSxvKFosXCJaRVJPXCIsbmV3IFNlKDAsMCkpLG8oWixcIlNBRkVfTUFYXCIsbmV3IFNlKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSksbyhaLFwiU0FGRV9NSU5cIixuZXcgU2UoTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKTtjb25zdCBNZT1jbGFzc3tjb25zdHJ1Y3RvcihpPTAsZT0wLHQ9MCxyPTApe28odGhpcyxcInhcIiwwKSxvKHRoaXMsXCJ5XCIsMCksbyh0aGlzLFwielwiLDApLG8odGhpcyxcIndcIiwxKSx0aGlzLng9aSx0aGlzLnk9ZSx0aGlzLno9dCx0aGlzLnc9cn1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy56fWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy53fXN0YXRpYyBjcm9zc1ZlY3RvcnMoaSxlLHQpe3Q9dHx8bmV3IE1lO3ZhciByPWkueCxzPWkueSxhPWkueixuPWUueCxsPWUueSxoPWUuejtyZXR1cm4gdC54PXMqaC1hKmwsdC55PWEqbi1yKmgsdC56PXIqbC1zKm4sdH1zdGF0aWMgZGlzdGFuY2UoaSxlKXtsZXQgdD1pLngtZS54LHI9aS55LWUueSxzPWkuei1lLnosYT1pLnctZS53O3JldHVybiBNYXRoLnNxcnQodCp0K3IqcitzKnMrYSphKX1zZXQoaSxlLHQscil7cmV0dXJuIHRoaXMueD1pLHRoaXMueT1lLHRoaXMuej10LHRoaXMudz1yLHRoaXN9bXVsdGlwbHlTY2FsYXIoaSl7cmV0dXJuIHRoaXMueCo9aSx0aGlzLnkqPWksdGhpcy56Kj1pLHRoaXMudyo9aSx0aGlzfWNvcHlGcm9tKGkpe3JldHVybiB0aGlzLng9aS54LHRoaXMueT1pLnksdGhpcy56PWkueix0aGlzLnc9aS53LHRoaXN9Y2xvbmUoKXtyZXR1cm4gbmV3IE1lKHRoaXMueCx0aGlzLnksdGhpcy56LHRoaXMudyl9fTtsZXQgaj1NZTtvKGosXCJYX0FYSVNcIixuZXcgTWUoMSwwLDApKSxvKGosXCJZX0FYSVNcIixuZXcgTWUoMCwxLDApKSxvKGosXCJaX0FYSVNcIixuZXcgTWUoMCwwLDEpKSxvKGosXCJIRUxQXzBcIixuZXcgTWUpLG8oaixcIkhFTFBfMVwiLG5ldyBNZSksbyhqLFwiSEVMUF8yXCIsbmV3IE1lKSxvKGosXCJFUFNJTE9OXCIsMWUtNSksbyhqLFwiSEVMUF8zXCIsbmV3IE1lKSxvKGosXCJIRUxQXzRcIixuZXcgTWUpLG8oaixcIkhFTFBfNVwiLG5ldyBNZSksbyhqLFwiSEVMUF82XCIsbmV3IE1lKSxvKGosXCJaRVJPXCIsbmV3IE1lKSxvKGosXCJPTkVcIixuZXcgTWUoMSwxLDEsMSkpLG8oaixcIkxFRlRcIixuZXcgTWUoLTEsMCwwKSksbyhqLFwiUklHSFRcIixuZXcgTWUoMSwwLDApKSxvKGosXCJVUFwiLG5ldyBNZSgwLC0xLDApKSxvKGosXCJET1dOXCIsbmV3IE1lKDAsMSwwKSksbyhqLFwiQkFDS1wiLG5ldyBNZSgwLDAsLTEpKSxvKGosXCJGT1JXQVJEXCIsbmV3IE1lKDAsMCwxKSk7dmFyICRlPShpPT4oaVtpLk51bWJlcj0wXT1cIk51bWJlclwiLGlbaS5WZWN0b3IyPTFdPVwiVmVjdG9yMlwiLGlbaS5WZWN0b3IzPTJdPVwiVmVjdG9yM1wiLGlbaS5WZWN0b3I0PTNdPVwiVmVjdG9yNFwiLGlbaS5Db2xvcj00XT1cIkNvbG9yXCIsaVtpLkZsb2F0MzJBcnJheT01XT1cIkZsb2F0MzJBcnJheVwiLGkpKSgkZXx8e30pO2NsYXNzICR7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwic2l6ZVwiKSxvKHRoaXMsXCJtZW1vcnlJbmZvXCIpLG8odGhpcyxcImJpbmRPbkNoYW5nZVwiKSxvKHRoaXMsXCJfZGF0YVwiKSxvKHRoaXMsXCJfdHlwZVwiLCRlLk51bWJlciksbyh0aGlzLFwiX3hcIiwwKSxvKHRoaXMsXCJfeVwiLDApLG8odGhpcyxcIl96XCIsMCksbyh0aGlzLFwiX3dcIiwwKSx0aGlzLmRhdGE9ZX1nZXQgZGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXNldCBkYXRhKGUpe3RoaXMuX2RhdGE9ZSx0aGlzLl90eXBlPSRlLk51bWJlcixlIGluc3RhbmNlb2YgWj8odGhpcy5zaXplPTIsdGhpcy5feD1lLngsdGhpcy5feT1lLnksdGhpcy5fdHlwZT0kZS5WZWN0b3IyKTplIGluc3RhbmNlb2YgZz8odGhpcy5zaXplPTMsdGhpcy5feD1lLngsdGhpcy5feT1lLnksdGhpcy5fej1lLnosdGhpcy5fdHlwZT0kZS5WZWN0b3IzKTplIGluc3RhbmNlb2Ygaj8odGhpcy5zaXplPTQsdGhpcy5feD1lLngsdGhpcy5feT1lLnksdGhpcy5fej1lLnosdGhpcy5fdz1lLncsdGhpcy5fdHlwZT0kZS5WZWN0b3I0KTplIGluc3RhbmNlb2Ygej8odGhpcy5zaXplPTQsdGhpcy5feD1lLnIsdGhpcy5feT1lLmcsdGhpcy5fej1lLmIsdGhpcy5fdz1lLmEsdGhpcy5fdHlwZT0kZS5Db2xvcik6ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT8odGhpcy5zaXplPWUubGVuZ3RoLHRoaXMuX3R5cGU9JGUuRmxvYXQzMkFycmF5KToodGhpcy5zaXplPTEsdGhpcy5feD1lLHRoaXMuX2RhdGE9ZSx0aGlzLl90eXBlPSRlLk51bWJlcil9Z2V0Q29sb3IoZSl7cmV0dXJuIGU/ZS5jb3B5RnJvbSh0aGlzLl9kYXRhKTplPXRoaXMuX2RhdGEsZX1nZXQgY29sb3IoKXtyZXR1cm4gbmV3IHoodGhpcy5fZGF0YS5yLHRoaXMuX2RhdGEuZyx0aGlzLl9kYXRhLmIsdGhpcy5fZGF0YS5hKX1zZXQgY29sb3IoZSl7KHRoaXMuX3ghPWUucnx8dGhpcy5feSE9ZS5nfHx0aGlzLl96IT1lLmJ8fHRoaXMuX3chPWUuYSkmJih0aGlzLl9kYXRhLnI9ZS5yLHRoaXMuX2RhdGEuZz1lLmcsdGhpcy5fZGF0YS5iPWUuYix0aGlzLl9kYXRhLmE9ZS5hLHRoaXMuX3g9ZS5yLHRoaXMuX3k9ZS5nLHRoaXMuX3o9ZS5iLHRoaXMuX3c9ZS5hLHRoaXMub25DaGFuZ2UoKSl9Z2V0IHZhbHVlKCl7cmV0dXJuIHRoaXMuX3h9c2V0IHZhbHVlKGUpe3RoaXMuX3ghPWUmJih0aGlzLl9kYXRhPWUsdGhpcy5feD1lLHRoaXMub25DaGFuZ2UoKSl9Z2V0IHZlY3RvcjIoKXtyZXR1cm4gdGhpcy5fZGF0YX1zZXQgdmVjdG9yMihlKXsodGhpcy5feCE9ZS54fHx0aGlzLl95IT1lLnkpJiYodGhpcy5fZGF0YS54PWUueCx0aGlzLl9kYXRhLnk9ZS55LHRoaXMuX3g9ZS54LHRoaXMuX3k9ZS55LHRoaXMub25DaGFuZ2UoKSl9Z2V0IHZlY3RvcjMoKXtyZXR1cm4gdGhpcy5fZGF0YX1zZXQgdmVjdG9yMyhlKXsodGhpcy5feCE9ZS54fHx0aGlzLl95IT1lLnl8fHRoaXMuX3ohPWUueikmJih0aGlzLl9kYXRhLng9ZS54LHRoaXMuX2RhdGEueT1lLnksdGhpcy5fZGF0YS56PWUueix0aGlzLl94PWUueCx0aGlzLl95PWUueSx0aGlzLl96PWUueix0aGlzLm9uQ2hhbmdlKCkpfWdldCB2ZWN0b3I0KCl7cmV0dXJuIHRoaXMuX2RhdGF9c2V0IHZlY3RvcjQoZSl7KHRoaXMuX3ghPWUueHx8dGhpcy5feSE9ZS55fHx0aGlzLl96IT1lLnp8fHRoaXMuX3chPWUudykmJih0aGlzLl9kYXRhLng9ZS54LHRoaXMuX2RhdGEueT1lLnksdGhpcy5fZGF0YS56PWUueix0aGlzLl9kYXRhLnc9ZS53LHRoaXMuX3g9ZS54LHRoaXMuX3k9ZS55LHRoaXMuX3o9ZS56LHRoaXMuX3c9ZS53LHRoaXMub25DaGFuZ2UoKSl9b25DaGFuZ2UoKXt0aGlzLmJpbmRPbkNoYW5nZSYmdGhpcy5iaW5kT25DaGFuZ2UoKX1mbG9hdDMyQXJyYXkoZSl7dGhpcy5fZGF0YS5zZXQoZSksdGhpcy5vbkNoYW5nZSgpfXVwZGF0ZSgpe3N3aXRjaCh0aGlzLl90eXBlKXtjYXNlICRlLk51bWJlcjp0aGlzLm1lbW9yeUluZm8uZGF0YUJ5dGVzLnNldEZsb2F0MzIoMCpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdGhpcy5fZGF0YSwhMCk7YnJlYWs7Y2FzZSAkZS5WZWN0b3IyOnRoaXMubWVtb3J5SW5mby5zZXRWZWN0b3IyKDAsdGhpcy5fZGF0YSk7YnJlYWs7Y2FzZSAkZS5WZWN0b3IzOnRoaXMubWVtb3J5SW5mby5zZXRWZWN0b3IzKDAsdGhpcy5fZGF0YSk7YnJlYWs7Y2FzZSAkZS5WZWN0b3I0OnRoaXMubWVtb3J5SW5mby5zZXRWZWN0b3I0KDAsdGhpcy5fZGF0YSk7YnJlYWs7Y2FzZSAkZS5Db2xvcjp0aGlzLm1lbW9yeUluZm8uc2V0Q29sb3IoMCx0aGlzLl9kYXRhKTticmVhaztjYXNlICRlLkZsb2F0MzJBcnJheTp0aGlzLm1lbW9yeUluZm8uc2V0RmxvYXQzMkFycmF5KDAsdGhpcy5fZGF0YSk7YnJlYWt9fX1sZXQgQnQ9e2NsYW1wX3RvX2VkZ2U6XCJjbGFtcC10by1lZGdlXCIscmVwZWF0OlwicmVwZWF0XCIsbWlycm9yX3JlcGVhdDpcIm1pcnJvci1yZXBlYXRcIn0sV2Y9e3plcm86XCJ6ZXJvXCIsb25lOlwib25lXCIsc3JjOlwic3JjXCIsb25lX21pbnVzX3NyYzpcIm9uZS1taW51cy1zcmNcIixzcmNfYWxwaGE6XCJzcmMtYWxwaGFcIixvbmVfbWludXNfc3JjX2FscGhhOlwib25lLW1pbnVzLXNyYy1hbHBoYVwiLGRzdDpcImRzdFwiLG9uZV9taW51c19kc3Q6XCJvbmUtbWludXMtZHN0XCIsZHN0X2FscGhhOlwiZHN0LWFscGhhXCIsb25lX21pbnVzX2RzdF9hbHBoYTpcIm9uZS1taW51cy1kc3QtYWxwaGFcIixzcmNfYWxwaGFfc2F0dXJhdGVkOlwic3JjLWFscGhhLXNhdHVyYXRlZFwiLGNvbnN0YW50OlwiY29uc3RhbnRcIixvbmVfbWludXNfY29uc3RhbnQ6XCJvbmUtbWludXMtY29uc3RhbnRcIn07Y29uc3QgamY9e3NyY0ZhY3RvcjpcIm9uZVwiLGRzdEZhY3RvcjpcInplcm9cIixvcGVyYXRpb246XCJhZGRcIn0scWY9e2NvbXBhcmU6XCJhbHdheXNcIixmYWlsT3A6XCJrZWVwXCIsZGVwdGhGYWlsT3A6XCJrZWVwXCIscGFzc09wOlwia2VlcFwifTtsZXQgdnQ9e25ldmVyOlwibmV2ZXJcIixsZXNzOlwibGVzc1wiLGVxdWFsOlwiZXF1YWxcIixsZXNzX2VxdWFsOlwibGVzcy1lcXVhbFwiLGdyZWF0ZXI6XCJncmVhdGVyXCIsbm90X2VxdWFsOlwibm90LWVxdWFsXCIsZ3JlYXRlcl9lcXVhbDpcImdyZWF0ZXItZXF1YWxcIixhbHdheXM6XCJhbHdheXNcIn0sdWk9e25vbmU6XCJub25lXCIsZnJvbnQ6XCJmcm9udFwiLGJhY2s6XCJiYWNrXCJ9LE5yPXtuZWFyZXN0OlwibmVhcmVzdFwiLGxpbmVhcjpcImxpbmVhclwifSxNcz17cG9pbnRfbGlzdDpcInBvaW50LWxpc3RcIixsaW5lX2xpc3Q6XCJsaW5lLWxpc3RcIixsaW5lX3N0cmlwOlwibGluZS1zdHJpcFwiLHRyaWFuZ2xlX2xpc3Q6XCJ0cmlhbmdsZS1saXN0XCIsdHJpYW5nbGVfc3RyaXA6XCJ0cmlhbmdsZS1zdHJpcFwifSxHPXtyOHVub3JtOlwicjh1bm9ybVwiLHI4c25vcm06XCJyOHNub3JtXCIscjh1aW50Olwicjh1aW50XCIscjhzaW50OlwicjhzaW50XCIscjE2dWludDpcInIxNnVpbnRcIixyMTZzaW50OlwicjE2c2ludFwiLHIxNmZsb2F0OlwicjE2ZmxvYXRcIixyZzh1bm9ybTpcInJnOHVub3JtXCIscmc4c25vcm06XCJyZzhzbm9ybVwiLHJnOHVpbnQ6XCJyZzh1aW50XCIscmc4c2ludDpcInJnOHNpbnRcIixyMzJ1aW50OlwicjMydWludFwiLHIzMnNpbnQ6XCJyMzJzaW50XCIscjMyZmxvYXQ6XCJyMzJmbG9hdFwiLHJnMTZ1aW50OlwicmcxNnVpbnRcIixyZzE2c2ludDpcInJnMTZzaW50XCIscmcxNmZsb2F0OlwicmcxNmZsb2F0XCIscmdiYTh1bm9ybTpcInJnYmE4dW5vcm1cIixyZ2JhOHVub3JtX3NyZ2I6XCJyZ2JhOHVub3JtLXNyZ2JcIixyZ2JhOHNub3JtOlwicmdiYThzbm9ybVwiLHJnYmE4dWludDpcInJnYmE4dWludFwiLHJnYmE4c2ludDpcInJnYmE4c2ludFwiLGJncmE4dW5vcm06XCJiZ3JhOHVub3JtXCIsYmdyYTh1bm9ybV9zcmdiOlwiYmdyYTh1bm9ybS1zcmdiXCIscmdiOWU1dWZsb2F0OlwicmdiOWU1dWZsb2F0XCIscmdiMTBhMnVub3JtOlwicmdiMTBhMnVub3JtXCIscmcxMWIxMHVmbG9hdDpcInJnMTFiMTB1ZmxvYXRcIixyZzMydWludDpcInJnMzJ1aW50XCIscmczMnNpbnQ6XCJyZzMyc2ludFwiLHJnMzJmbG9hdDpcInJnMzJmbG9hdFwiLHJnYmExNnVpbnQ6XCJyZ2JhMTZ1aW50XCIscmdiYTE2c2ludDpcInJnYmExNnNpbnRcIixyZ2JhMTZmbG9hdDpcInJnYmExNmZsb2F0XCIscmdiYTMydWludDpcInJnYmEzMnVpbnRcIixyZ2JhMzJzaW50OlwicmdiYTMyc2ludFwiLHJnYmEzMmZsb2F0OlwicmdiYTMyZmxvYXRcIixzdGVuY2lsODpcInN0ZW5jaWw4XCIsZGVwdGgxNnVub3JtOlwiZGVwdGgxNnVub3JtXCIsZGVwdGgyNHBsdXM6XCJkZXB0aDI0cGx1c1wiLGRlcHRoMjRwbHVzX3N0ZW5jaWw4OlwiZGVwdGgyNHBsdXMtc3RlbmNpbDhcIixkZXB0aDMyZmxvYXQ6XCJkZXB0aDMyZmxvYXRcIixiYzFfcmdiYV91bm9ybTpcImJjMS1yZ2JhLXVub3JtXCIsYmMxX3JnYmFfdW5vcm1fc3JnYjpcImJjMS1yZ2JhLXVub3JtLXNyZ2JcIixiYzJfcmdiYV91bm9ybTpcImJjMi1yZ2JhLXVub3JtXCIsYmMyX3JnYmFfdW5vcm1fc3JnYjpcImJjMi1yZ2JhLXVub3JtLXNyZ2JcIixiYzNfcmdiYV91bm9ybTpcImJjMy1yZ2JhLXVub3JtXCIsYmMzX3JnYmFfdW5vcm1fc3JnYjpcImJjMy1yZ2JhLXVub3JtLXNyZ2JcIixiYzRfcl91bm9ybTpcImJjNC1yLXVub3JtXCIsYmM0X3Jfc25vcm06XCJiYzQtci1zbm9ybVwiLGJjNV9yZ191bm9ybTpcImJjNS1yZy11bm9ybVwiLGJjNV9yZ19zbm9ybTpcImJjNS1yZy1zbm9ybVwiLGJjNmhfcmdiX3VmbG9hdDpcImJjNmgtcmdiLXVmbG9hdFwiLGJjNmhfcmdiX2Zsb2F0OlwiYmM2aC1yZ2ItZmxvYXRcIixiYzdfcmdiYV91bm9ybTpcImJjNy1yZ2JhLXVub3JtXCIsYmM3X3JnYmFfdW5vcm1fc3JnYjpcImJjNy1yZ2JhLXVub3JtLXNyZ2JcIixkZXB0aDI0dW5vcm1fc3RlbmNpbDg6XCJkZXB0aDI0dW5vcm0tc3RlbmNpbDhcIixkZXB0aDMyZmxvYXRfc3RlbmNpbDg6XCJkZXB0aDMyZmxvYXQtc3RlbmNpbDhcIn0sRnI9e3VpbnQ4eDI6XCJ1aW50OHgyXCIsdWludDh4NDpcInVpbnQ4eDRcIixzaW50OHgyOlwic2ludDh4MlwiLHNpbnQ4eDQ6XCJzaW50OHg0XCIsdW5vcm04eDI6XCJ1bm9ybTh4MlwiLHVub3JtOHg0OlwidW5vcm04eDRcIixzbm9ybTh4MjpcInNub3JtOHgyXCIsc25vcm04eDQ6XCJzbm9ybTh4NFwiLHVpbnQxNngyOlwidWludDE2eDJcIix1aW50MTZ4NDpcInVpbnQxNng0XCIsc2ludDE2eDI6XCJzaW50MTZ4MlwiLHNpbnQxNng0Olwic2ludDE2eDRcIix1bm9ybTE2eDI6XCJ1bm9ybTE2eDJcIix1bm9ybTE2eDQ6XCJ1bm9ybTE2eDRcIixzbm9ybTE2eDI6XCJzbm9ybTE2eDJcIixzbm9ybTE2eDQ6XCJzbm9ybTE2eDRcIixmbG9hdDE2eDI6XCJmbG9hdDE2eDJcIixmbG9hdDE2eDQ6XCJmbG9hdDE2eDRcIixmbG9hdDMyOlwiZmxvYXQzMlwiLGZsb2F0MzJ4MjpcImZsb2F0MzJ4MlwiLGZsb2F0MzJ4MzpcImZsb2F0MzJ4M1wiLGZsb2F0MzJ4NDpcImZsb2F0MzJ4NFwiLHVpbnQzMjpcInVpbnQzMlwiLHVpbnQzMngyOlwidWludDMyeDJcIix1aW50MzJ4MzpcInVpbnQzMngzXCIsdWludDMyeDQ6XCJ1aW50MzJ4NFwiLHNpbnQzMjpcInNpbnQzMlwiLHNpbnQzMngyOlwic2ludDMyeDJcIixzaW50MzJ4MzpcInNpbnQzMngzXCIsc2ludDMyeDQ6XCJzaW50MzJ4NFwifSxLZj17dmVydGV4OlwidmVydGV4XCIsaW5zdGFuY2U6XCJpbnN0YW5jZVwifTtjbGFzcyBBZXt9byhBZSxcImNvbG9yQnVmZmVyVGV4X05BTUVcIixcImNvbG9yQnVmZmVyVGV4XCIpLG8oQWUsXCJwb3NpdGlvbkJ1ZmZlclRleF9OQU1FXCIsXCJwb3NpdGlvbkJ1ZmZlclRleFwiKSxvKEFlLFwibm9ybWFsQnVmZmVyVGV4X05BTUVcIixcIm5vcm1hbEJ1ZmZlclRleFwiKSxvKEFlLFwibWF0ZXJpYWxCdWZmZXJUZXhfTkFNRVwiLFwibWF0ZXJpYWxCdWZmZXJUZXhcIiksbyhBZSxcInpCdWZmZXJUZXh0dXJlX05BTUVcIixcInpCdWZmZXJUZXh0dXJlXCIpLG8oQWUsXCJ6UHJlRGVwdGhUZXh0dXJlX05BTUVcIixcInpQcmVEZXB0aFRleHR1cmVcIiksbyhBZSxcIm91dFRleF9OQU1FXCIsXCJvdXRUZXhcIik7dmFyIFVlPShpPT4oaVtpLkRlZmF1bHQ9MV09XCJEZWZhdWx0XCIsaVtpLklnbm9yZURlcHRoUGFzcz0yXT1cIklnbm9yZURlcHRoUGFzc1wiLGlbaS5Ta3k9Nl09XCJTa3lcIixpW2kuUGFydGljbGU9MTBdPVwiUGFydGljbGVcIixpW2kuU2tpbm5lZE1lc2g9MTZdPVwiU2tpbm5lZE1lc2hcIixpW2kuTW9ycGhUYXJnZXQ9MzJdPVwiTW9ycGhUYXJnZXRcIixpW2kuVGVycmFpbj02NF09XCJUZXJyYWluXCIsaVtpLlVJPTEyOF09XCJVSVwiLGkpKShVZXx8e30pO2NsYXNzIFR0e3N0YXRpYyBhZGRNYXNrKGUsdCl7cmV0dXJuIGV8dH1zdGF0aWMgcmVtb3ZlTWFzayhlLHQpe3JldHVybiBlJn50fXN0YXRpYyBoYXNNYXNrKGUsdCl7cmV0dXJuKGUmdCk9PXR9fWNvbnN0IGtyPWNsYXNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX19yZWZlY3Rpb25cIiksbyh0aGlzLFwiX19zaXplXCIsMCl9Z2V0VmFsdWVUeXBlKCl7aWYoIXRoaXMuX19yZWZlY3Rpb24pe2xldCBpPXRoaXM7dGhpcy5fX3JlZmVjdGlvbj1bXTtmb3IoY29uc3QgZSBpbiBpKWlmKCFlLmluY2x1ZGVzKFwiX19cIikpe2NvbnN0IHQ9aVtlXTtsZXQgcj17bmFtZTplLHR5cGU6dC5jb25zdHJ1Y3Rvci5uYW1lfTt0aGlzLl9fcmVmZWN0aW9uLnB1c2gocil9fXJldHVybiB0aGlzLl9fcmVmZWN0aW9ufXN0YXRpYyBnZXRWYWx1ZVNpemUoaSl7c3dpdGNoKGkuY29uc3RydWN0b3IubmFtZSl7Y2FzZVwiQm9vbGVhblwiOnJldHVybiAxKjQ7Y2FzZVwiTnVtYmVyXCI6cmV0dXJuIDEqNDtjYXNlXCJmMzJcIjpyZXR1cm4gMSo0O2Nhc2VcImkzMlwiOnJldHVybiAxKjQ7Y2FzZVwidTMyXCI6cmV0dXJuIDEqNDtjYXNlXCJGbG9hdDMyQXJyYXlcIjpyZXR1cm4gaS5ieXRlTGVuZ3RoKjQ7Y2FzZVwiVmVjdG9yMlwiOnJldHVybiAyKjQ7Y2FzZVwiVmVjdG9yM1wiOnJldHVybiA0KjQ7Y2FzZVwiVmVjdG9yNFwiOnJldHVybiA0KjQ7Y2FzZVwiQ29sb3JcIjpyZXR1cm4gNCo0O2Nhc2VcIkFycmF5XCI6bGV0IHQ9MDtmb3IobGV0IHI9MCxzPWkubGVuZ3RoO3I8cztyKyspdCs9a3IuZ2V0VmFsdWVTaXplKGlbcl0pO3JldHVybiB0fXJldHVybiAwfXN0YXRpYyBSZWYoaSl7cmV0dXJuIHRoaXMuR2V0KGkpLmdldFZhbHVlVHlwZSgpfXN0YXRpYyBHZXQoaSl7bGV0IGU9a3IuX19jYWNoZVN0cnVjdC5nZXQoaS5wcm90b3R5cGUpO3JldHVybiBlfHwoZT1uZXcgaSxrci5fX2NhY2hlU3RydWN0LnNldChpLnByb3RvdHlwZSxlKSksZX1zdGF0aWMgR2V0U2l6ZShpKXtsZXQgZT10aGlzLkdldChpKTtpZihlLl9fc2l6ZT09MCl7Zm9yKGNvbnN0IHQgaW4gZSlpZih0LmluZGV4T2YoXCJfX1wiKT09LTEpe2NvbnN0IHI9ZVt0XTtlLl9fc2l6ZSs9a3IuZ2V0VmFsdWVTaXplKHIpfWUuX19zaXplPjQmJihlLl9fc2l6ZT1NYXRoLmNlaWwoZS5fX3NpemUvNCkqNCl9cmV0dXJuIGUuX19zaXplfX07bGV0IHdpPWtyO28od2ksXCJfX2NhY2hlU3RydWN0XCIsbmV3IE1hcCk7Y2xhc3Mgb2x7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJieXRlT2Zmc2V0XCIpLG8odGhpcyxcImJ5dGVTaXplXCIpLG8odGhpcyxcIm9mZnNldFwiLDApLG8odGhpcyxcImRhdGFCeXRlc1wiKX1nZXQgeCgpe3JldHVybiB0aGlzLmRhdGFCeXRlcy5nZXRGbG9hdDMyKDAqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCEwKX1zZXQgeChlKXt0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKDAqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULGUsITApfWdldCB5KCl7cmV0dXJuIHRoaXMuZGF0YUJ5dGVzLmdldEZsb2F0MzIoMSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsITApfXNldCB5KGUpe3RoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoMSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsZSwhMCl9Z2V0IHooKXtyZXR1cm4gdGhpcy5kYXRhQnl0ZXMuZ2V0RmxvYXQzMigyKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwhMCl9c2V0IHooZSl7dGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigyKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxlLCEwKX1nZXQgdygpe3JldHVybiB0aGlzLmRhdGFCeXRlcy5nZXRGbG9hdDMyKDMqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCEwKX1zZXQgdyhlKXt0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKDMqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULGUsITApfXNldFgoZSl7dGhpcy54PWV9c2V0WFkoZSx0KXt0aGlzLng9ZSx0aGlzLnk9dH1zZXRYWVooZSx0LHIpe3RoaXMueD1lLHRoaXMueT10LHRoaXMuej1yfXNldFhZWlcoZSx0LHIscyl7dGhpcy54PWUsdGhpcy55PXQsdGhpcy56PXIsdGhpcy53PXN9c2V0VmVjdG9yMkFycmF5KGUpe2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCByPWVbdF07dGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigodCoyKzApKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxyLngsITApLHRoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKHQqMisxKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsci55LCEwKX19c2V0VmVjdG9yM0FycmF5KGUpe2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCByPWVbdF07dGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigodCozKzApKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxyLngsITApLHRoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKHQqMysxKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsci55LCEwKSx0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKCh0KjMrMikqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHIueiwhMCl9fXNldFZlY3RvcjRBcnJheShlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgcj1lW3RdO3RoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKHQqNCswKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsci54LCEwKSx0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKCh0KjQrMSkqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHIueSwhMCksdGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigodCo0KzIpKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxyLnosITApLHRoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKHQqNCszKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsci53LCEwKX19c2V0Q29sb3JBcnJheShlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgcj1lW3RdO3RoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKHQqNCswKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsci5yLCEwKSx0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKCh0KjQrMSkqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHIuZywhMCksdGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigodCo0KzIpKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxyLmIsITApLHRoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKHQqNCszKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsci5hLCEwKX19c2V0SW50OChlLHQ9MCl7dGhpcy5kYXRhQnl0ZXMuc2V0SW50OCh0KkludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxlKX1nZXRJbnQ4KGU9MCl7cmV0dXJuIHRoaXMuZGF0YUJ5dGVzLmdldEludDgoZSpJbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQpfXNldEludDE2KGUsdD0wKXt0aGlzLmRhdGFCeXRlcy5zZXRJbnQxNih0KkludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQsZSwhMCl9Z2V0SW50MTYoZT0wKXtyZXR1cm4gdGhpcy5kYXRhQnl0ZXMuZ2V0SW50MTYoZSpJbnQxNkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCEwKX1zZXRJbnQzMihlLHQ9MCl7dGhpcy5kYXRhQnl0ZXMuc2V0SW50MzIodCpJbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULGUsITApfWdldEludDMyKGU9MCl7cmV0dXJuIHRoaXMuZGF0YUJ5dGVzLmdldEludDMyKGUqSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwhMCl9c2V0RmxvYXQoZSx0PTApe3RoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIodCpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsZSwhMCl9Z2V0RmxvYXQoZT0wKXtyZXR1cm4gdGhpcy5kYXRhQnl0ZXMuZ2V0RmxvYXQzMihlKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwhMCl9c2V0VWludDgoZSx0PTApe3RoaXMuZGF0YUJ5dGVzLnNldFVpbnQ4KHQqVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxlKX1nZXRVaW50OChlPTApe3JldHVybiB0aGlzLmRhdGFCeXRlcy5nZXRVaW50OChlKlVpbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQpfXNldFVpbnQxNihlLHQ9MCl7dGhpcy5kYXRhQnl0ZXMuc2V0VWludDE2KHQqVWludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQsZSwhMCl9Z2V0VWludDE2KGU9MCl7cmV0dXJuIHRoaXMuZGF0YUJ5dGVzLmdldFVpbnQxNihlKlVpbnQxNkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCEwKX1zZXRVaW50MzIoZSx0PTApe3RoaXMuZGF0YUJ5dGVzLnNldFVpbnQzMih0KlVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULGUsITApfWdldFVpbnQzMihlPTApe3JldHVybiB0aGlzLmRhdGFCeXRlcy5nZXRVaW50MzIoZSpVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwhMCl9c2V0QXJyYXkoZSx0KXtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3Qgcz10W3JdO3RoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKGUrcikqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHMsITApfX1zZXRGbG9hdDMyQXJyYXkoZSx0KXtuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YUJ5dGVzLmJ1ZmZlcix0aGlzLmRhdGFCeXRlcy5ieXRlT2Zmc2V0K2UqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHQubGVuZ3RoKS5zZXQodCl9c2V0QXJyYXlCdWZmZXIoZSx0KXt0IGluc3RhbmNlb2YgVWludDhBcnJheT90aGlzLnNldFVpbnQ4QXJyYXkoZSx0KTp0IGluc3RhbmNlb2YgVWludDE2QXJyYXk/dGhpcy5zZXRVaW50MTZBcnJheShlLHQpOnQgaW5zdGFuY2VvZiBVaW50MzJBcnJheT90aGlzLnNldFVpbnQzMkFycmF5KGUsdCk6dCBpbnN0YW5jZW9mIEludDhBcnJheT90aGlzLnNldEludDhBcnJheShlLHQpOnQgaW5zdGFuY2VvZiBJbnQxNkFycmF5P3RoaXMuc2V0SW50MTZBcnJheShlLHQpOnQgaW5zdGFuY2VvZiBJbnQzMkFycmF5P3RoaXMuc2V0SW50MzJBcnJheShlLHQpOnQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkmJnRoaXMuc2V0RmxvYXQzMkFycmF5KGUsdCl9c2V0SW50OEFycmF5KGUsdCl7bmV3IEludDhBcnJheSh0aGlzLmRhdGFCeXRlcy5idWZmZXIsdGhpcy5kYXRhQnl0ZXMuYnl0ZU9mZnNldCtlKkludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkuc2V0KHQpfXNldEludDE2QXJyYXkoZSx0KXtuZXcgSW50MTZBcnJheSh0aGlzLmRhdGFCeXRlcy5idWZmZXIsdGhpcy5kYXRhQnl0ZXMuYnl0ZU9mZnNldCtlKkludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLnNldCh0KX1zZXRJbnQzMkFycmF5KGUsdCl7bmV3IEludDMyQXJyYXkodGhpcy5kYXRhQnl0ZXMuYnVmZmVyLHRoaXMuZGF0YUJ5dGVzLmJ5dGVPZmZzZXQrZSpJbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKS5zZXQodCl9c2V0VWludDhBcnJheShlLHQpe25ldyBVaW50OEFycmF5KHRoaXMuZGF0YUJ5dGVzLmJ1ZmZlcix0aGlzLmRhdGFCeXRlcy5ieXRlT2Zmc2V0K2UqVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkuc2V0KHQpfXNldFVpbnQxNkFycmF5KGUsdCl7bmV3IFVpbnQxNkFycmF5KHRoaXMuZGF0YUJ5dGVzLmJ1ZmZlcix0aGlzLmRhdGFCeXRlcy5ieXRlT2Zmc2V0K2UqVWludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLnNldCh0KX1zZXRVaW50MzJBcnJheShlLHQpe25ldyBVaW50MzJBcnJheSh0aGlzLmRhdGFCeXRlcy5idWZmZXIsdGhpcy5kYXRhQnl0ZXMuYnl0ZU9mZnNldCtlKlVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKS5zZXQodCl9c2V0RGF0YShlLHQpe3RoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoZSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdCwhMCl9c2V0VmVjdG9yMihlLHQpe3RoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoZSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdC54LCEwKSx0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKChlKzEpKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCx0LnksITApfXNldFZlY3RvcjMoZSx0KXt0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKGUqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHQueCwhMCksdGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigoZSsxKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdC55LCEwKSx0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKChlKzIpKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCx0LnosITApfXNldFZlY3RvcjQoZSx0KXt0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKGUqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHQueCwhMCksdGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigoZSsxKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdC55LCEwKSx0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKChlKzIpKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCx0LnosITApLHRoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKGUrMykqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHQudywhMCl9c2V0Q29sb3IoZSx0KXt0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKGUqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHQuciwhMCksdGhpcy5kYXRhQnl0ZXMuc2V0RmxvYXQzMigoZSsxKSpGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsdC5nLCEwKSx0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKChlKzIpKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCx0LmIsITApLHRoaXMuZGF0YUJ5dGVzLnNldEZsb2F0MzIoKGUrMykqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHQuYSwhMCl9Z2V0RGF0YShlKXtyZXR1cm4gdGhpcy5kYXRhQnl0ZXMuZ2V0RmxvYXQzMihlKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwhMCl9d3JpdGVGbG9hdChlKXt0aGlzLmRhdGFCeXRlcy5zZXRGbG9hdDMyKHRoaXMub2Zmc2V0LGUsITApLHRoaXMub2Zmc2V0Kz1GbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlR9d3JpdGVJbnQ4KGUpe3RoaXMuZGF0YUJ5dGVzLnNldEludDgodGhpcy5vZmZzZXQsZSksdGhpcy5vZmZzZXQrPUludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVH13cml0ZUludDE2KGUpe3RoaXMuZGF0YUJ5dGVzLnNldEludDE2KHRoaXMub2Zmc2V0LGUsITApLHRoaXMub2Zmc2V0Kz1JbnQxNkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UfXdyaXRlSW50MzIoZSl7dGhpcy5kYXRhQnl0ZXMuc2V0SW50MzIodGhpcy5vZmZzZXQsZSwhMCksdGhpcy5vZmZzZXQrPUludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlR9d3JpdGVVaW50OChlKXt0aGlzLmRhdGFCeXRlcy5zZXRVaW50OCh0aGlzLm9mZnNldCxlKSx0aGlzLm9mZnNldCs9VWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVH13cml0ZVVpbnQxNihlKXt0aGlzLmRhdGFCeXRlcy5zZXRVaW50MTYodGhpcy5vZmZzZXQsZSwhMCksdGhpcy5vZmZzZXQrPVVpbnQxNkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UfXdyaXRlVWludDMyKGUpe3RoaXMuZGF0YUJ5dGVzLnNldFVpbnQzMih0aGlzLm9mZnNldCxlLCEwKSx0aGlzLm9mZnNldCs9VWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlR9d3JpdGVWZWN0b3IyKGUpe3RoaXMud3JpdGVGbG9hdChlLngpLHRoaXMud3JpdGVGbG9hdChlLnkpfXdyaXRlVmVjdG9yMyhlKXt0aGlzLndyaXRlRmxvYXQoZS54KSx0aGlzLndyaXRlRmxvYXQoZS55KSx0aGlzLndyaXRlRmxvYXQoZS56KX13cml0ZVZlY3RvcjQoZSl7dGhpcy53cml0ZUZsb2F0KGUueCksdGhpcy53cml0ZUZsb2F0KGUueSksdGhpcy53cml0ZUZsb2F0KGUueiksdGhpcy53cml0ZUZsb2F0KGUudyl9d3JpdGVSR0JDb2xvcihlKXt0aGlzLndyaXRlRmxvYXQoZS5yKSx0aGlzLndyaXRlRmxvYXQoZS5nKSx0aGlzLndyaXRlRmxvYXQoZS5iKX13cml0ZUFycmF5KGUpe2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCByPWVbdF07dGhpcy53cml0ZUZsb2F0KHIpfX13cml0ZUZsb2F0MzJBcnJheShlKXtuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YUJ5dGVzLmJ1ZmZlcix0aGlzLmRhdGFCeXRlcy5ieXRlT2Zmc2V0K3RoaXMub2Zmc2V0KS5zZXQoZSksdGhpcy5vZmZzZXQrPWUuYnl0ZUxlbmd0aH13cml0ZUludDhBcnJheShlKXtuZXcgSW50OEFycmF5KHRoaXMuZGF0YUJ5dGVzLmJ1ZmZlcix0aGlzLmRhdGFCeXRlcy5ieXRlT2Zmc2V0K3RoaXMub2Zmc2V0KS5zZXQoZSksdGhpcy5vZmZzZXQrPWUuYnl0ZUxlbmd0aH13cml0ZUludDE2QXJyYXkoZSl7bmV3IEludDE2QXJyYXkodGhpcy5kYXRhQnl0ZXMuYnVmZmVyLHRoaXMuZGF0YUJ5dGVzLmJ5dGVPZmZzZXQrdGhpcy5vZmZzZXQpLnNldChlKSx0aGlzLm9mZnNldCs9ZS5ieXRlTGVuZ3RofXdyaXRlSW50MzJBcnJheShlKXtuZXcgSW50MzJBcnJheSh0aGlzLmRhdGFCeXRlcy5idWZmZXIsdGhpcy5kYXRhQnl0ZXMuYnl0ZU9mZnNldCt0aGlzLm9mZnNldCkuc2V0KGUpLHRoaXMub2Zmc2V0Kz1lLmJ5dGVMZW5ndGh9d3JpdGVVaW50OEFycmF5KGUpe25ldyBVaW50OEFycmF5KHRoaXMuZGF0YUJ5dGVzLmJ1ZmZlcix0aGlzLmRhdGFCeXRlcy5ieXRlT2Zmc2V0K3RoaXMub2Zmc2V0KS5zZXQoZSksdGhpcy5vZmZzZXQrPWUuYnl0ZUxlbmd0aH13cml0ZVVpbnQxNkFycmF5KGUpe25ldyBVaW50MTZBcnJheSh0aGlzLmRhdGFCeXRlcy5idWZmZXIsdGhpcy5kYXRhQnl0ZXMuYnl0ZU9mZnNldCt0aGlzLm9mZnNldCkuc2V0KGUpLHRoaXMub2Zmc2V0Kz1lLmJ5dGVMZW5ndGh9d3JpdGVVaW50MzJBcnJheShlKXtuZXcgVWludDMyQXJyYXkodGhpcy5kYXRhQnl0ZXMuYnVmZmVyLHRoaXMuZGF0YUJ5dGVzLmJ5dGVPZmZzZXQrdGhpcy5vZmZzZXQpLnNldChlKSx0aGlzLm9mZnNldCs9ZS5ieXRlTGVuZ3RofXJlc2V0KCl7dGhpcy5vZmZzZXQ9MH1kZXN0cm95KCl7dGhpcy5ieXRlT2Zmc2V0PW51bGwsdGhpcy5ieXRlU2l6ZT1udWxsLHRoaXMub2Zmc2V0PW51bGwsdGhpcy5kYXRhQnl0ZXM9bnVsbH19Y2xhc3MgenJ7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJzaGFyZURhdGFCdWZmZXJcIiksbyh0aGlzLFwiX2J5dGVPZmZzZXRcIiwwKX1hbGxvY2F0aW9uKGUpe3RoaXMuc2hhcmVEYXRhQnVmZmVyJiZ0aGlzLnNoYXJlRGF0YUJ1ZmZlci5ieXRlTGVuZ3RoPGU/dGhpcy5fYnl0ZU9mZnNldD0wOnRoaXMuc2hhcmVEYXRhQnVmZmVyPW5ldyBBcnJheUJ1ZmZlcihlKX1hbGxvY2F0aW9uX25vZGUoZSl7aWYodGhpcy5fYnl0ZU9mZnNldCtlPnRoaXMuc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJtZW1vcnkgbm90IGVub3VnaCFcIix0aGlzLl9ieXRlT2Zmc2V0LGUsdGhpcy5zaGFyZURhdGFCdWZmZXIuYnl0ZUxlbmd0aCksbnVsbDtsZXQgdD1uZXcgb2w7cmV0dXJuIHQuYnl0ZU9mZnNldD10aGlzLl9ieXRlT2Zmc2V0LHQuYnl0ZVNpemU9ZSx0LmRhdGFCeXRlcz1uZXcgRGF0YVZpZXcodGhpcy5zaGFyZURhdGFCdWZmZXIsdGhpcy5fYnl0ZU9mZnNldCx0LmJ5dGVTaXplKSx0aGlzLl9ieXRlT2Zmc2V0Kz10LmJ5dGVTaXplLHR9YWxsb2NhdGlvbl9tZW1vcnkoZSl7cmV0dXJuIHRoaXMuX2J5dGVPZmZzZXQrZS5ieXRlU2l6ZT50aGlzLnNoYXJlRGF0YUJ1ZmZlci5ieXRlTGVuZ3RoPyhjb25zb2xlLmVycm9yKFwibWVtb3J5IG5vdCBlbm91Z2ghXCIsdGhpcy5fYnl0ZU9mZnNldCxlLmJ5dGVTaXplLHRoaXMuc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgpLG51bGwpOihlLmJ5dGVPZmZzZXQ9dGhpcy5fYnl0ZU9mZnNldCxlLmRhdGFCeXRlcz1uZXcgRGF0YVZpZXcodGhpcy5zaGFyZURhdGFCdWZmZXIsdGhpcy5fYnl0ZU9mZnNldCxlLmJ5dGVTaXplKSx0aGlzLl9ieXRlT2Zmc2V0Kz1lLmJ5dGVTaXplLGUpfXJlc2V0KCl7dGhpcy5fYnl0ZU9mZnNldD0wfWRlc3Ryb3koZSl7dGhpcy5zaGFyZURhdGFCdWZmZXI9bnVsbCx0aGlzLl9ieXRlT2Zmc2V0PTB9fWNsYXNzIEp0e2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiYnVmZmVyVHlwZVwiKSxvKHRoaXMsXCJidWZmZXJcIiksbyh0aGlzLFwibWVtb3J5XCIpLG8odGhpcyxcIm1lbW9yeU5vZGVzXCIpLG8odGhpcyxcInNlZWtcIiksbyh0aGlzLFwib3V0RmxvYXQzMkFycmF5XCIpLG8odGhpcyxcImJ5dGVTaXplXCIpLG8odGhpcyxcInVzYWdlXCIpLG8odGhpcyxcInZpc2liaWxpdHlcIixHUFVTaGFkZXJTdGFnZS5WRVJURVh8R1BVU2hhZGVyU3RhZ2UuRlJBR01FTlR8R1BVU2hhZGVyU3RhZ2UuQ09NUFVURSksbyh0aGlzLFwibWFwQXN5bmNCdWZmZXJzT3V0c3RhbmRpbmdcIiwwKSxvKHRoaXMsXCJtYXBBc3luY1JlYWR5XCIpLG8odGhpcyxcIl9yZWFkQnVmZmVyXCIpLG8odGhpcyxcIl9kYXRhVmlld1wiKSxvKHRoaXMsXCJfcmVhZEZsYWdcIiwhMSksdGhpcy5tYXBBc3luY1JlYWR5PVtdLHRoaXMubWVtb3J5PW5ldyB6cix0aGlzLm1lbW9yeU5vZGVzPW5ldyBNYXAsdGhpcy5fZGF0YVZpZXc9bmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lbW9yeS5zaGFyZURhdGFCdWZmZXIpfWRlYnVnKCl7fXJlc2V0KGU9ITEsdD0wLHIpe3RoaXMuc2Vlaz0wLHRoaXMubWVtb3J5LnJlc2V0KCksZSYmdGhpcy5jcmVhdGVCdWZmZXIodGhpcy51c2FnZSx0LHIpfXNldEJvb2xlYW4oZSx0KXtsZXQgcj10aGlzLm1lbW9yeU5vZGVzLmdldChlKTtyfHwocj10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUoMSo0KSx0aGlzLm1lbW9yeU5vZGVzLnNldChlLHIpKSxyLnNldFgodD8xOjApfXNldEZsb2F0KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKDEqNCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRYKHQpfXNldEludDgoZSx0KXtsZXQgcj10aGlzLm1lbW9yeU5vZGVzLmdldChlKTtyfHwocj10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUoMSoxKSx0aGlzLm1lbW9yeU5vZGVzLnNldChlLHIpKSxyLnNldEludDgodCl9c2V0SW50MTYoZSx0KXtsZXQgcj10aGlzLm1lbW9yeU5vZGVzLmdldChlKTtyfHwocj10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUoMSoyKSx0aGlzLm1lbW9yeU5vZGVzLnNldChlLHIpKSxyLnNldEludDE2KHQpfXNldEludDMyKGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKDEqNCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRJbnQzMih0KX1zZXRVaW50OChlLHQpe2xldCByPXRoaXMubWVtb3J5Tm9kZXMuZ2V0KGUpO3J8fChyPXRoaXMubWVtb3J5LmFsbG9jYXRpb25fbm9kZSgxKjEpLHRoaXMubWVtb3J5Tm9kZXMuc2V0KGUscikpLHIuc2V0VWludDgodCl9c2V0VWludDE2KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKDEqMiksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRVaW50MTYodCl9c2V0VWludDMyKGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKDEqNCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRVaW50MzIodCl9c2V0VmVjdG9yMihlLHQpe2xldCByPXRoaXMubWVtb3J5Tm9kZXMuZ2V0KGUpO3J8fChyPXRoaXMubWVtb3J5LmFsbG9jYXRpb25fbm9kZSgyKjQpLHRoaXMubWVtb3J5Tm9kZXMuc2V0KGUscikpLHIuc2V0WFkodC54LHQueSl9c2V0VmVjdG9yMyhlLHQpe2xldCByPXRoaXMubWVtb3J5Tm9kZXMuZ2V0KGUpO3J8fChyPXRoaXMubWVtb3J5LmFsbG9jYXRpb25fbm9kZSgzKjQpLHRoaXMubWVtb3J5Tm9kZXMuc2V0KGUscikpLHIuc2V0WFlaKHQueCx0LnksdC56KX1zZXRWZWN0b3I0KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKDQqNCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRYWVpXKHQueCx0LnksdC56LHQudyl9c2V0VmVjdG9yNEFycmF5KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKDQqNCp0Lmxlbmd0aCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRWZWN0b3I0QXJyYXkodCl9c2V0Q29sb3IoZSx0KXtsZXQgcj10aGlzLm1lbW9yeU5vZGVzLmdldChlKTtyfHwocj10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUoNCo0KSx0aGlzLm1lbW9yeU5vZGVzLnNldChlLHIpKSxyLnNldFhZWlcodC5yLHQuZyx0LmIsdC5hKX1zZXRDb2xvckFycmF5KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKDQqNCp0Lmxlbmd0aCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRDb2xvckFycmF5KHQpfXNldE1hdHJpeChlLHQpe2xldCByPXRoaXMubWVtb3J5Tm9kZXMuZ2V0KGUpO3J8fChyPXRoaXMubWVtb3J5LmFsbG9jYXRpb25fbm9kZSgxNio0KSx0aGlzLm1lbW9yeU5vZGVzLnNldChlLHIpKSxyLnNldEZsb2F0MzJBcnJheSgwLHQucmF3RGF0YSl9c2V0TWF0cml4QXJyYXkoZSx0KXtsZXQgcj10aGlzLm1lbW9yeU5vZGVzLmdldChlKTtyfHwocj10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUoMTYqNCp0Lmxlbmd0aCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IGE9dFtzXTtyLnNldEZsb2F0MzJBcnJheShzKjE2LGEucmF3RGF0YSl9fXNldEFycmF5KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKHQubGVuZ3RoKjQpLHRoaXMubWVtb3J5Tm9kZXMuc2V0KGUscikpLHIuc2V0QXJyYXkoMCx0KX1zZXRGbG9hdDMyQXJyYXkoZSx0KXtsZXQgcj10aGlzLm1lbW9yeU5vZGVzLmdldChlKTtyfHwocj10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUodC5sZW5ndGgqNCksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoZSxyKSksci5zZXRGbG9hdDMyQXJyYXkoMCx0KX1zZXRJbnQzMkFycmF5KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKHQubGVuZ3RoKjQpLHRoaXMubWVtb3J5Tm9kZXMuc2V0KGUscikpLHIuc2V0SW50MzJBcnJheSgwLHQpfXNldFVpbnQzMkFycmF5KGUsdCl7bGV0IHI9dGhpcy5tZW1vcnlOb2Rlcy5nZXQoZSk7cnx8KHI9dGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKHQubGVuZ3RoKjQpLHRoaXMubWVtb3J5Tm9kZXMuc2V0KGUscikpLHIuc2V0VWludDMyQXJyYXkoMCx0KX1zZXRTdHJ1Y3QoZSx0LHIscyl7bGV0IGE9d2kuUmVmKGUpO3dpLkdldFNpemUoZSk7bGV0IG49dCxsPXRoaXMubWVtb3J5Tm9kZXMuZ2V0KG4pO2wucmVzZXQoKTtsZXQgaD1yO3MmJihoPWhbc10pO2ZvcihsZXQgdT0wO3U8YS5sZW5ndGg7dSsrKXtjb25zdCBjPWFbdV07bGV0IGY9aFtjLm5hbWVdO3N3aXRjaChjLnR5cGUpe2Nhc2VcIkJvb2xlYW5cIjpsLndyaXRlRmxvYXQoZik7YnJlYWs7Y2FzZVwiTnVtYmVyXCI6bC53cml0ZUZsb2F0KGYpO2JyZWFrO2Nhc2VcIkZsb2F0MzJBcnJheVwiOmwud3JpdGVGbG9hdDMyQXJyYXkoZik7YnJlYWs7Y2FzZVwiVmVjdG9yMlwiOmwud3JpdGVWZWN0b3IyKGYpO2JyZWFrO2Nhc2VcIlZlY3RvcjNcIjpsLndyaXRlVmVjdG9yMyhmKTticmVhaztjYXNlXCJWZWN0b3I0XCI6bC53cml0ZVZlY3RvcjQoZik7YnJlYWs7Y2FzZVwiQ29sb3JcIjpsLndyaXRlUkdCQ29sb3IoZik7YnJlYWs7Y2FzZVwiQXJyYXlcIjpsLndyaXRlQXJyYXkoZik7YnJlYWt9fX1zZXRTdHJ1Y3RBcnJheShlLHQscil7bGV0IHM9dC5sZW5ndGg7Zm9yKGxldCBhPTA7YTxzO2ErKyl7Y29uc3Qgbj10W2FdO3RoaXMuc2V0U3RydWN0KGUsYSxuLHIpfX1jbGVhbigpe3RoaXMuX2RhdGFWaWV3LmZpbGwoMCwwLHRoaXMuX2RhdGFWaWV3Lmxlbmd0aCl9YXBwbHkoKXtTLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcih0aGlzLmJ1ZmZlciwwLHRoaXMubWVtb3J5LnNoYXJlRGF0YUJ1ZmZlcil9YXBwbHlNYXBBc3luYygpe3RoaXMubWFwQXN5bmNXcml0ZShuZXcgRmxvYXQzMkFycmF5KHRoaXMubWVtb3J5LnNoYXJlRGF0YUJ1ZmZlciksdGhpcy5tZW1vcnkuc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgvNCl9bWFwQXN5bmNXcml0ZShlLHQpe2xldCByPVMuZGV2aWNlO2lmKGUubGVuZ3RoPjApe2xldCBzPW51bGw7Zm9yKDt0aGlzLm1hcEFzeW5jUmVhZHkubGVuZ3RoJiYocz10aGlzLm1hcEFzeW5jUmVhZHkuc2hpZnQoKSxzLnVzZWRTaXplIT1lLmJ5dGVMZW5ndGgpOylzLmRlc3Ryb3koKSx0aGlzLm1hcEFzeW5jQnVmZmVyc091dHN0YW5kaW5nLS0scz1udWxsO3N8fChzPXIuY3JlYXRlQnVmZmVyKHtzaXplOmUuYnl0ZUxlbmd0aCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEUsbWFwcGVkQXRDcmVhdGlvbjohMH0pLHMudXNlZFNpemU9ZS5ieXRlTGVuZ3RoLHRoaXMubWFwQXN5bmNCdWZmZXJzT3V0c3RhbmRpbmcrKyx0aGlzLm1hcEFzeW5jQnVmZmVyc091dHN0YW5kaW5nPjEwJiZjb25zb2xlLndhcm4oYCBXYXJuaW5nOiBtYXBBc3luYyByZXF1ZXN0cyBmcm9tICR7dGhpcy5tYXBBc3luY0J1ZmZlcnNPdXRzdGFuZGluZ30gZnJhbWVzIGFnbyBoYXZlIG5vdCByZXNvbHZlZCB5ZXQuICBNQiBvZiBzdGFnaW5nIGJ1ZmZlcnMgYWxsb2NhdGVkLmApKTtsZXQgYT1uZXcgRmxvYXQzMkFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCx0KTtuZXcgRmxvYXQzMkFycmF5KHMuZ2V0TWFwcGVkUmFuZ2UoMCx0KjQpKS5zZXQoYSkscy51bm1hcCgpO2NvbnN0IGw9ci5jcmVhdGVDb21tYW5kRW5jb2RlcigpO2wuY29weUJ1ZmZlclRvQnVmZmVyKHMsMCx0aGlzLmJ1ZmZlciwwLHQqNCksci5xdWV1ZS5zdWJtaXQoW2wuZmluaXNoKCldKSxzLm1hcEFzeW5jKEdQVU1hcE1vZGUuV1JJVEUpLnRoZW4oKCk9PnRoaXMubWFwQXN5bmNSZWFkeS5wdXNoKHMpKX19ZGVzdHJveShlKXt0aGlzLm1lbW9yeU5vZGVzJiZ0aGlzLm1lbW9yeU5vZGVzLmZvckVhY2godD0+e3QuZGVzdHJveSgpfSksdGhpcy5idWZmZXJUeXBlPW51bGwsdGhpcy5zZWVrPW51bGwsdGhpcy5ieXRlU2l6ZT1udWxsLHRoaXMudXNhZ2U9bnVsbCx0aGlzLnZpc2liaWxpdHk9bnVsbCx0aGlzLm91dEZsb2F0MzJBcnJheT1udWxsLHRoaXMuYnVmZmVyJiZ0aGlzLmJ1ZmZlci5kZXN0cm95KCksdGhpcy5idWZmZXI9bnVsbCx0aGlzLm1lbW9yeSYmdGhpcy5tZW1vcnkuZGVzdHJveSgpLHRoaXMubWVtb3J5PW51bGwsdGhpcy5fcmVhZEJ1ZmZlciYmdGhpcy5fcmVhZEJ1ZmZlci5kZXN0cm95KCl9Y3JlYXRlQnVmZmVyKGUsdCxyKXtsZXQgcz1TLmRldmljZTt0aGlzLmJ5dGVTaXplPXQqNCx0aGlzLnVzYWdlPWUsdGhpcy5idWZmZXImJnRoaXMuZGVzdHJveSgpLHRoaXMuYnVmZmVyPXMuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMuYnl0ZVNpemUsdXNhZ2U6ZSxtYXBwZWRBdENyZWF0aW9uOiExfSksdGhpcy5tZW1vcnkuYWxsb2NhdGlvbih0aGlzLmJ5dGVTaXplKSxyJiYodGhpcy5tZW1vcnkuYWxsb2NhdGlvbl9ub2RlKHIubGVuZ3RoKjQpLnNldEFycmF5QnVmZmVyKDAsciksdGhpcy5hcHBseSgpKX1jcmVhdGVOZXdCdWZmZXIoZSx0KXtsZXQgcj1TLmRldmljZSxzPXQqNCxhPWU7cmV0dXJuIHRoaXMuYnVmZmVyJiZ0aGlzLmRlc3Ryb3koKSxyLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpzLHVzYWdlOmEsbWFwcGVkQXRDcmVhdGlvbjohMX0pfWNyZWF0ZUJ1ZmZlckJ5U3RydWN0KGUsdCxyKXtsZXQgcz13aS5HZXRTaXplKHQpLGE9cypyLG49Uy5kZXZpY2U7dGhpcy5idWZmZXI9bi5jcmVhdGVCdWZmZXIoe3NpemU6YSx1c2FnZTplLG1hcHBlZEF0Q3JlYXRpb246ITF9KSx0aGlzLm1lbW9yeS5hbGxvY2F0aW9uKGEpO2ZvcihsZXQgbD0wO2w8cjtsKyspe2xldCBoPWwsdT10aGlzLm1lbW9yeU5vZGVzLmdldChoKTt1fHwodT10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUocyksdGhpcy5tZW1vcnlOb2Rlcy5zZXQoaCx1KSl9fXJlYWRCdWZmZXIoKXtyZXR1cm4gdGhpcy5vdXRGbG9hdDMyQXJyYXl8fCh0aGlzLm91dEZsb2F0MzJBcnJheT1uZXcgRmxvYXQzMkFycmF5KHRoaXMubWVtb3J5LnNoYXJlRGF0YUJ1ZmZlci5ieXRlTGVuZ3RoLzQpKSx0aGlzLl9yZWFkQnVmZmVyfHwodGhpcy5fcmVhZEJ1ZmZlcj1TLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5tZW1vcnkuc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQsbWFwcGVkQXRDcmVhdGlvbjohMX0pKSx0aGlzLl9yZWFkRmxhZ3x8dGhpcy5yZWFkKCksdGhpcy5vdXRGbG9hdDMyQXJyYXl9YXN5bmMgcmVhZCgpe3RoaXMuX3JlYWRGbGFnPSEwO2xldCBlPVMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7ZS5jb3B5QnVmZmVyVG9CdWZmZXIodGhpcy5idWZmZXIsMCx0aGlzLl9yZWFkQnVmZmVyLDAsdGhpcy5tZW1vcnkuc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgpLFMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZS5maW5pc2goKV0pLGF3YWl0IHRoaXMuX3JlYWRCdWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtjb25zdCB0PXRoaXMuX3JlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKTt0aGlzLm91dEZsb2F0MzJBcnJheS5zZXQobmV3IEZsb2F0MzJBcnJheSh0KSwwKSx0aGlzLl9yZWFkQnVmZmVyLnVubWFwKCksdGhpcy5fcmVhZEZsYWc9ITF9fXZhciBNdD0oaT0+KGlbaS5JbmRpY2VzR1BVQnVmZmVyPTBdPVwiSW5kaWNlc0dQVUJ1ZmZlclwiLGlbaS5WZXJ0ZXhHUFVCdWZmZXI9MV09XCJWZXJ0ZXhHUFVCdWZmZXJcIixpW2kuVW5pZm9ybUdQVUJ1ZmZlcj0yXT1cIlVuaWZvcm1HUFVCdWZmZXJcIixpW2kuU3RvcmFnZUdQVUJ1ZmZlcj0zXT1cIlN0b3JhZ2VHUFVCdWZmZXJcIixpW2kuQ29tcHV0ZUdQVUJ1ZmZlcj00XT1cIkNvbXB1dGVHUFVCdWZmZXJcIixpW2kuTWF0ZXJpYWxEYXRhVW5pZm9ybUdQVUJ1ZmZlcj01XT1cIk1hdGVyaWFsRGF0YVVuaWZvcm1HUFVCdWZmZXJcIixpW2kuU3RydWN0U3RvcmFnZUdQVUJ1ZmZlcj02XT1cIlN0cnVjdFN0b3JhZ2VHUFVCdWZmZXJcIixpKSkoTXR8fHt9KTtjbGFzcyBnZSBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKGUsdD0wLHIpe3N1cGVyKCksdGhpcy5idWZmZXJUeXBlPU10LlN0b3JhZ2VHUFVCdWZmZXIsdGhpcy5jcmVhdGVCdWZmZXIoR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHx0LGUscil9fWNsYXNzIER0IGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMuYnVmZmVyVHlwZT1NdC5Vbmlmb3JtR1BVQnVmZmVyLHRoaXMuY3JlYXRlQnVmZmVyKEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk18R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMsZSx0KX1nZW5Vbmlmb3JtTm9kZXMoKXt9fWxldCBQdD1mdW5jdGlvbihpPTE2LGU9MTYpe3ZhciB0PVwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5zcGxpdChcIlwiKSxyPVtdLHM7aWYoZT1lfHx0Lmxlbmd0aCxpKWZvcihzPTA7czxpO3MrKylyW3NdPXRbMHxNYXRoLnJhbmRvbSgpKmVdO2Vsc2V7dmFyIGE7Zm9yKHJbOF09clsxM109clsxOF09clsyM109XCItXCIsclsxNF09XCI0XCIscz0wO3M8MzY7cysrKXJbc118fChhPTB8TWF0aC5yYW5kb20oKSoxNixyW3NdPXRbcz09MTk/YSYzfDg6YV0pfXJldHVybiByLmpvaW4oXCJcIil9LG5sPTFlNixxYT1mdW5jdGlvbigpe3JldHVybiBubCsrLG5sfSxKZj1mdW5jdGlvbihpLGUpe2xldCB0PTAscj1pLmxlbmd0aDtmb3IodD0wO3Q8cjt0KyspaWYoaVt0XT09ZSlyZXR1cm4hMDtyZXR1cm4hMX0sWmY9ZnVuY3Rpb24oaSxlKXtsZXQgdD0wLHI9aS5sZW5ndGg7Zm9yKHQ9MDt0PHI7dCsrKWlmKGlbdF09PWUpcmV0dXJuIHQ7cmV0dXJuLTF9O2NsYXNzIEthe2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiaW5zdGFuY2VJRFwiKSxvKHRoaXMsXCJzaGFkZXJWYXJpYW50XCIpLG8odGhpcyxcInZzRW50cnlQb2ludFwiLFwibWFpblwiKSxvKHRoaXMsXCJmc0VudHJ5UG9pbnRcIixcIm1haW5cIiksbyh0aGlzLFwiYmluZEdyb3Vwc1wiKSxvKHRoaXMsXCJzaGFkZXJSZWZsZWN0aW9uXCIpLG8odGhpcyxcImRlZmluZVZhbHVlXCIpLG8odGhpcyxcImNvbnN0VmFsdWVzXCIpLG8odGhpcyxcInVuaWZvcm1zXCIpLG8odGhpcyxcIl9idWZmZXJEaWNcIiksbyh0aGlzLFwiX3NoYWRlckNoYW5nZVwiLCEwKSxvKHRoaXMsXCJfdmFsdWVDaGFuZ2VcIiwhMSksdGhpcy5pbnN0YW5jZUlEPVB0KCksdGhpcy5kZWZpbmVWYWx1ZT17fSx0aGlzLmNvbnN0VmFsdWVzPXt9LHRoaXMudW5pZm9ybXM9e30sdGhpcy5fYnVmZmVyRGljPW5ldyBNYXB9bm90aWNlU2hhZGVyQ2hhbmdlKCl7dGhpcy5fc2hhZGVyQ2hhbmdlPSEwfW5vdGljZVZhbHVlQ2hhbmdlKCl7dGhpcy5fdmFsdWVDaGFuZ2U9ITB9c2V0U3RvcmFnZUJ1ZmZlcihlLHQpe3RoaXMuX2J1ZmZlckRpYy5oYXMoZSk/dGhpcy5fYnVmZmVyRGljLnNldChlLHQpOih0aGlzLl9idWZmZXJEaWMuc2V0KGUsdCksdGhpcy5ub3RpY2VCdWZmZXJDaGFuZ2UoZSkpfXNldFN0cnVjdFN0b3JhZ2VCdWZmZXIoZSx0KXt0aGlzLl9idWZmZXJEaWMuaGFzKGUpPyh0aGlzLl9idWZmZXJEaWMuc2V0KGUsdCksdGhpcy5ub3RpY2VCdWZmZXJDaGFuZ2UoZSkpOnRoaXMuX2J1ZmZlckRpYy5zZXQoZSx0KX1zZXRVbmlmb3JtQnVmZmVyKGUsdCl7dGhpcy5fYnVmZmVyRGljLmhhcyhlKT8odGhpcy5fYnVmZmVyRGljLnNldChlLHQpLHRoaXMubm90aWNlQnVmZmVyQ2hhbmdlKGUpKTp0aGlzLl9idWZmZXJEaWMuc2V0KGUsdCl9c2V0RGVmaW5lKGUsdCl7KHRoaXMuZGVmaW5lVmFsdWVbZV09PW51bGx8fHRoaXMuZGVmaW5lVmFsdWVbZV0hPXQpJiYodGhpcy5kZWZpbmVWYWx1ZVtlXT10LHRoaXMubm90aWNlVmFsdWVDaGFuZ2UoKSx0aGlzLm5vdGljZVNoYWRlckNoYW5nZSgpKSx0aGlzLmRlZmluZVZhbHVlW2VdPXR9aGFzRGVmaW5lKGUpe3JldHVybiB0aGlzLmRlZmluZVZhbHVlW2VdIT1udWxsfWRlbGV0ZURlZmluZShlKXtkZWxldGUgdGhpcy5kZWZpbmVWYWx1ZVtlXSx0aGlzLm5vdGljZVNoYWRlckNoYW5nZSgpfXNldFVuaWZvcm1GbG9hdChlLHQpe3RoaXMudW5pZm9ybXNbZV0/dGhpcy51bmlmb3Jtc1tlXS52YWx1ZT10Oih0aGlzLnVuaWZvcm1zW2VdPW5ldyAkKHQpLHRoaXMubm90aWNlVmFsdWVDaGFuZ2UoKSl9c2V0VW5pZm9ybVZlY3RvcjIoZSx0KXt0aGlzLnVuaWZvcm1zW2VdP3RoaXMudW5pZm9ybXNbZV0udmVjdG9yMj10Oih0aGlzLnVuaWZvcm1zW2VdPW5ldyAkKHQpLHRoaXMubm90aWNlVmFsdWVDaGFuZ2UoKSl9c2V0VW5pZm9ybVZlY3RvcjMoZSx0KXt0aGlzLnVuaWZvcm1zW2VdP3RoaXMudW5pZm9ybXNbZV0udmVjdG9yMz10OnRoaXMudW5pZm9ybXNbZV09bmV3ICQodCl9c2V0VW5pZm9ybVZlY3RvcjQoZSx0KXt0aGlzLnVuaWZvcm1zW2VdP3RoaXMudW5pZm9ybXNbZV0udmVjdG9yND10OnRoaXMudW5pZm9ybXNbZV09bmV3ICQodCl9c2V0VW5pZm9ybUNvbG9yKGUsdCl7dGhpcy51bmlmb3Jtc1tlXT90aGlzLnVuaWZvcm1zW2VdLmNvbG9yPXQ6dGhpcy51bmlmb3Jtc1tlXT1uZXcgJCh0KX1zZXRVbmlmb3JtQXJyYXkoZSx0KXt0aGlzLnVuaWZvcm1zW2VdP3RoaXMudW5pZm9ybXNbZV0uZmxvYXQzMkFycmF5KHQpOnRoaXMudW5pZm9ybXNbZV09bmV3ICQodCl9c2V0VW5pZm9ybShlLHQpe3RoaXMudW5pZm9ybXNbZV0/dGhpcy51bmlmb3Jtc1tlXS5kYXRhPXQ6dGhpcy51bmlmb3Jtc1tlXT1uZXcgJCh0KX1nZXRVbmlmb3JtKGUpe3JldHVybiB0aGlzLnVuaWZvcm1zW2VdLmRhdGF9bm90aWNlQnVmZmVyQ2hhbmdlKGUpe31kZXN0cm95KGUpe319dmFyIGJpPShpPT4oaVtpLnUzMj0xXT1cInUzMlwiLGlbaS5mMzI9MV09XCJmMzJcIixpW2lbXCJ2ZWMyPGYzMj5cIl09Ml09XCJ2ZWMyPGYzMj5cIixpW2lbXCJ2ZWMzPGYzMj5cIl09M109XCJ2ZWMzPGYzMj5cIixpW2lbXCJ2ZWM0PGYzMj5cIl09NF09XCJ2ZWM0PGYzMj5cIixpW2kuZmxvYXQzMj0xXT1cImZsb2F0MzJcIixpW2kuZmxvYXQzMngyPTJdPVwiZmxvYXQzMngyXCIsaVtpLmZsb2F0MzJ4Mz0zXT1cImZsb2F0MzJ4M1wiLGlbaS5mbG9hdDMyeDQ9NF09XCJmbG9hdDMyeDRcIixpKSkoYml8fHt9KTtsZXQgbGw9W251bGwsRnIuZmxvYXQzMixGci5mbG9hdDMyeDIsRnIuZmxvYXQzMngzLEZyLmZsb2F0MzJ4NF07Y2xhc3MgdXR7c3RhdGljIHBhcnNlKGUsdCl7cmV0dXJuIGU9dGhpcy5maWx0ZXJDb21tZW50KGUpLGU9dGhpcy5wYXJzZVByZXByb2Nlc3MobmV3IGhsLGUsdCksZT10aGlzLnBhcnNlQXV0b0JpbmRpbmdGb3JHcm91cFgoZSwxKSxlfXN0YXRpYyBwYXJzZUNvbXB1dGVTaGFkZXIoZSx0KXtyZXR1cm4gZT10aGlzLmZpbHRlckNvbW1lbnQoZSksZT10aGlzLnBhcnNlUHJlcHJvY2VzcyhuZXcgaGwsZSx0KSxlfXN0YXRpYyBwYXJzZVByZXByb2Nlc3MoZSx0LHIpe2xldCBzPXQuaW5kZXhPZihcIiNcIik7aWYocz09LTEpcmV0dXJuIHQ7bGV0IGE9dC5zdWJzdHJpbmcoMCxzKSxuPXQuaW5kZXhPZihgXG5gLHQubGFzdEluZGV4T2YoXCIjXCIpKSxsPXQuc3Vic3RyaW5nKHMsbiksaD10LnN1YnN0cmluZyhuKTtyZXR1cm4gYSt0aGlzLnBhcnNlUHJlcHJvY2Vzc0NvbW1hbmQoZSxsLHIpK2h9c3RhdGljIHBhcnNlQXV0b0JpbmRpbmdGb3JHcm91cFgoZSx0KXtsZXQgcj0wLHM9XCJcIixhPW5ldyBNYXA7Zm9yKDtyPGUubGVuZ3RoOyl7bGV0IG49ZS5pbmRleE9mKFwiQGdyb3VwKFwiLHIpO2lmKG49PS0xKXtzKz1lLnN1YnN0cmluZyhyKTticmVha31sZXQgbD1lLmluZGV4T2YoXCIpXCIsbiksaD1OdW1iZXIucGFyc2VJbnQoZS5zdWJzdHJpbmcobis3LGwpKTtpZihuPWUuaW5kZXhPZihcIkBiaW5kaW5nKFwiLGwpLGw9ZS5pbmRleE9mKFwiKVwiLG4pLHMrPWUuc3Vic3RyaW5nKHIsbiksaD09dClpZihhLmhhcyhoKSl7bGV0IHU9YS5nZXQoaCkrMTtzKz1gQGJpbmRpbmcoJHt1fSlgLGEuc2V0KGgsdSl9ZWxzZSBzKz1cIkBiaW5kaW5nKDApXCIsYS5zZXQoaCwwKTtlbHNlIHMrPWUuc3Vic3RyaW5nKG4sbCsxKTtyPWwrMX1yZXR1cm4gc31zdGF0aWMgcGFyc2VQcmVwcm9jZXNzQ29tbWFuZChlLHQscil7bGV0IHM9XCJcIixhPXQuc3BsaXQoYFxuYCksbj1bITFdLGw9WyExXTtmb3IobGV0IGg9MDtoPGEubGVuZ3RoO2grKyl7bGV0IHU9YVtoXSxjPW5bbi5sZW5ndGgtMV07aWYodS50cmltKCkuaW5kZXhPZihcIiNcIikhPTApe2N8fChzKz11K2BcbmApO2NvbnRpbnVlfWxldCBmPXUudHJpbSgpO2lmKGYuaW5kZXhPZihcIiNpZlwiKSE9LTEpe2lmKGMmJm4ubGVuZ3RoPjEpe24ucHVzaChjKTtjb250aW51ZX1sZXQgZD1mLnN1YnN0cmluZygzKS50cmltKCk7Yz0hdGhpcy5wYXJzZUNvbmRpdGlvbihkLHIpLG4ucHVzaChjKSxsLnB1c2goIWMpO2NvbnRpbnVlfWVsc2UgaWYoZi5pbmRleE9mKFwiI2Vsc2VpZlwiKSE9LTF8fGYuaW5kZXhPZihcIiNlbHNlXCIpIT0tMSYmZi5pbmRleE9mKFwiIGlmXCIpIT0tMSl7aWYobFtsLmxlbmd0aC0xXSl7bi5wb3AoKSxjPSEwLG4ucHVzaChjKTtjb250aW51ZX1pZihuLnBvcCgpLGM9bltuLmxlbmd0aC0xXSxjJiZuLmxlbmd0aD4xKXtuLnB1c2goYyk7Y29udGludWV9bGV0IHA9Zi5zdWJzdHJpbmcoZi5pbmRleE9mKFwiaWZcIikrMikudHJpbSgpO3A9PVwiXCImJmNvbnNvbGUuZXJyb3IoYHByZXByb2Nlc3MgY29tbWFuZCBlcnJvciwgY29uZGl0aW9ucyBtaXNzaW5nOiAke2Z9YCksYz0hdGhpcy5wYXJzZUNvbmRpdGlvbihwLHIpLG4ucHVzaChjKSxsLnB1c2goIWMpO2NvbnRpbnVlfWVsc2UgaWYoZi5pbmRleE9mKFwiI2Vsc2VcIikhPS0xKXtuLnBvcCgpLGMmJm4ubGVuZ3RoPjEmJm5bbi5sZW5ndGgtMV0/bi5wdXNoKGMpOm4ucHVzaCghYyk7Y29udGludWV9ZWxzZSBpZihmLmluZGV4T2YoXCIjZW5kaWZcIikhPS0xKXtuLnBvcCgpLGwucG9wKCk7Y29udGludWV9ZWxzZSBpZihmLmluZGV4T2YoXCIjaW5jbHVkZVwiKSE9LTEpe2xldCBkPVwiXCIscD1mLmNoYXJBdChmLmxlbmd0aC0xKTtpZihwPT1cIj5cIj9kPXRoaXMuZXh0cmFjdChmLFwiPFwiLFwiPlwiKTpkPXRoaXMuZXh0cmFjdChmLHAscCksIWUuaW5jbHVkZU1hcC5oYXMoZCkpe2UuaW5jbHVkZU1hcC5zZXQoZCwhMCk7bGV0IG09Ti5nZXRTaGFkZXIoZCk7aWYoIW0pdGhyb3dgJHtmfSBlcnJvcjogJyR7ZH0nIG5vdCBmb3VuZGA7bT10aGlzLmZpbHRlckNvbW1lbnQobSksbT10aGlzLnBhcnNlUHJlcHJvY2VzcyhlLG0scikscys9bStgXFxyXG5gfWNvbnRpbnVlfWVsc2UgaWYoZi5pbmRleE9mKFwiI2RlZmluZSBcIikhPS0xKXtsZXQgZD1mLnN1YnN0cmluZyhmLmluZGV4T2YoXCIjZGVmaW5lIFwiKSs4KS50cmltKCkscD1kLmluZGV4T2YoXCIgXCIpLG09ZCxfPVwiXCI7cCE9LTEmJihtPWQuc3Vic3RyaW5nKDAscCkudHJpbSgpLF89ZC5zdWJzdHJpbmcocCsxKS50cmltKCkpLHJbbV09Xztjb250aW51ZX1lbHNlIHRocm93XCJub25zdXBwb3J0OiBcIitmfXJldHVybiBzfXN0YXRpYyBwYXJzZUNvbmRpdGlvbihlLHQpe2xldCByPXRbZV07cmV0dXJuIHI9PW51bGw/ITE6cj09ITB8fHIhPTB9c3RhdGljIGZpbHRlckNvbW1lbnQoZSl7bGV0IHQ9XCJcIixyPSEwLHM9ITA7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDspe2xldCBuPXI/ZS5pbmRleE9mKFwiLy9cIixhKTotMSxsPXM/ZS5pbmRleE9mKFwiLypcIixhKTotMTtpZihuPT0tMSYmbD09LTEpe3QrPWUuc3Vic3RyaW5nKGEpO2JyZWFrfXI9biE9LTEscz1sIT0tMSxuIT0tMSYmbCE9LTEmJihuPGw/bD0tMTpuPS0xKSxuIT0tMT8obD1lLmluZGV4T2YoYFxuYCxuKSx0Kz1lLnN1YnN0cmluZyhhLG4pLGE9bCE9LTE/bDplLmxlbmd0aCk6bCE9LTEmJihuPWUuaW5kZXhPZihcIiovXCIsbCksdCs9ZS5zdWJzdHJpbmcoYSxsKSxhPW4rMil9cmV0dXJuIHR9c3RhdGljIGV4dHJhY3QoZSx0LHIpe2xldCBzPWUuaW5kZXhPZih0KSt0Lmxlbmd0aCxhPWUuaW5kZXhPZihyLHMpO3JldHVybiBlLnN1YnN0cmluZyhzLGEpLnRyaW0oKX19Y2xhc3MgaGx7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJpbmNsdWRlTWFwXCIsbmV3IE1hcCl9fWNvbnN0IERzPWNsYXNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiYXR0cmlidXRlc1wiLFtdKSxvKHRoaXMsXCJ2c192YXJpYWJsZXNcIixbXSksbyh0aGlzLFwiZnNfdmFyaWFibGVzXCIsW10pLG8odGhpcyxcImNzX3ZhcmlhYmxlc1wiLFtdKSxvKHRoaXMsXCJncm91cHNcIixbXSksbyh0aGlzLFwidmFyaWFibGVzXCIse30pLG8odGhpcyxcInVzZVNwbGl0XCIsITEpfXN0YXRpYyBwYXJzZXIoaSxlKXtlLnNoYWRlclJlZmxlY3Rpb258fChlLnNoYWRlclJlZmxlY3Rpb249bmV3IERzKSxpLmluZGV4T2YoXCJAdmVydGV4XCIpIT0tMT8oZS5zaGFkZXJSZWZsZWN0aW9uLmF0dHJpYnV0ZXM9dGhpcy5wYXJzZXJWZXJ0ZXhPbGQoaSksZS5zaGFkZXJSZWZsZWN0aW9uLnZzX3ZhcmlhYmxlcz10aGlzLnBhcnNlclZhcmlhYmxlcyhpKSk6aS5pbmRleE9mKFwiQGZyYWdtZW50XCIpIT0tMT9lLnNoYWRlclJlZmxlY3Rpb24uZnNfdmFyaWFibGVzPXRoaXMucGFyc2VyVmFyaWFibGVzKGkpOmkuaW5kZXhPZihcIkBjb21wdXRlXCIpIT0tMSYmKGUuc2hhZGVyUmVmbGVjdGlvbi5jc192YXJpYWJsZXM9dGhpcy5wYXJzZXJWYXJpYWJsZXMoaSkpfXN0YXRpYyBwYXJzZXIyKGksZSl7ZS5zaGFkZXJSZWZsZWN0aW9ufHwoZS5zaGFkZXJSZWZsZWN0aW9uPW5ldyBEcyk7bGV0IHQ9ZS5zaGFkZXJSZWZsZWN0aW9uO2kuaW5kZXhPZihcIkB2ZXJ0ZXhcIikhPS0xPyh0LmF0dHJpYnV0ZXM9dGhpcy5wYXJzZXJWZXJ0ZXgoZS52c0VudHJ5UG9pbnQsaSksdC52c192YXJpYWJsZXM9dGhpcy5wYXJzZXJWYXJpYWJsZXMoaSkpOmkuaW5kZXhPZihcIkBmcmFnbWVudFwiKSE9LTE/dC5mc192YXJpYWJsZXM9dGhpcy5wYXJzZXJWYXJpYWJsZXMoaSk6aS5pbmRleE9mKFwiQGNvbXB1dGVcIikhPS0xJiYodC5jc192YXJpYWJsZXM9dGhpcy5wYXJzZXJWYXJpYWJsZXMoaSkpLGkuaW5kZXhPZihcInNwbGl0VGV4dHVyZVwiKSE9LTEmJih0LnVzZVNwbGl0PSEwKX1zdGF0aWMgY29tYmluZVNoYWRlclJlZmxlY3Rpb25WYXJJbmZvKGksZSl7Zm9yKGNvbnN0IHQgb2YgZSl7aS5ncm91cHNbdC5ncm91cF18fChpLmdyb3Vwc1t0Lmdyb3VwXT1bXSk7bGV0IHI9dDtpZihpLmdyb3Vwc1t0Lmdyb3VwXVt0LmJpbmRpbmddKXtsZXQgcz1pLmdyb3Vwc1t0Lmdyb3VwXVt0LmJpbmRpbmddLGE9dDtpZihzLmRhdGFGaWVsZHMpZm9yKGxldCBuPTA7bjxzLmRhdGFGaWVsZHMubGVuZ3RoO24rKylzLmRhdGFGaWVsZHNbbl07aWYoYS5kYXRhRmllbGRzKWZvcihsZXQgbj0wO248YS5kYXRhRmllbGRzLmxlbmd0aDtuKyspYS5kYXRhRmllbGRzW25dfWkuZ3JvdXBzW3QuZ3JvdXBdW3QuYmluZGluZ109cixpLnZhcmlhYmxlc1t0LnZhck5hbWVdPXJ9fXN0YXRpYyBmaW5hbChpKXtsZXQgZT1pLnNoYWRlclJlZmxlY3Rpb247dGhpcy5fc2hhZGVyUmVmbGVjdGlvbk1hcC5zZXQoaS5zaGFkZXJWYXJpYW50LGUpLHRoaXMuY29tYmluZVNoYWRlclJlZmxlY3Rpb25WYXJJbmZvKGUsZS52c192YXJpYWJsZXMpLHRoaXMuY29tYmluZVNoYWRlclJlZmxlY3Rpb25WYXJJbmZvKGUsZS5mc192YXJpYWJsZXMpfXN0YXRpYyBnZXRTaGFkZXJSZWZsZWN0aW9uMihpLGUpe2lmKGUuc2hhZGVyVmFyaWFudCE9bnVsbCl7bGV0IHQ9dXQucGFyc2UoaSxlLmRlZmluZVZhbHVlKTtEcy5wYXJzZXIyKHQsZSl9fXN0YXRpYyBwb29sR2V0UmVmbGVjdGlvbihpKXtyZXR1cm4gdGhpcy5fc2hhZGVyUmVmbGVjdGlvbk1hcC5nZXQoaSl9c3RhdGljIGdlblNoYWRlclZhcihpKXtsZXQgZT1gJHtpLnZzfSR7aS5mc30ke2kuY29tcHV0ZX1gO2UrPVwifFwiO2Zvcihjb25zdCB0IGluIGkudW5pZm9ybXMpZSs9dCtcIjpcIjtlKz1cInxcIjtmb3IoY29uc3QgdCBpbiBpLmNvbnN0VmFsdWVzKWUrPXQrXCI6XCIsZSs9aS5jb25zdFZhbHVlc1t0XTtlKz1cInxcIjtmb3IoY29uc3QgdCBpbiBpLmRlZmluZXMpZSs9dCtcIjpcIixlKz1pLmRlZmluZXNbdF07ZSs9XCJ8XCI7Zm9yKGNvbnN0IHQgaW4gaS5zaGFkZXJTdGF0ZSllKz10K1wiOlwiLGUrPWkuc2hhZGVyU3RhdGVbdF0rXCI7XCI7cmV0dXJuIGV9c3RhdGljIGdlblNoYWRlclZhcmlhbnQoaSl7bGV0IGU9XCJcIjtmb3IoY29uc3QgdCBpbiBpLnVuaWZvcm1zKWUrPXQrXCI6XCI7ZSs9XCJ8XCI7Zm9yKGNvbnN0IHQgaW4gaS5jb25zdFZhbHVlcyllKz10K1wiOlwiLGUrPWkuY29uc3RWYWx1ZXNbdF07ZSs9XCJ8XCI7Zm9yKGNvbnN0IHQgaW4gaS5kZWZpbmVWYWx1ZSllKz10K1wiOlwiLGUrPWkuZGVmaW5lVmFsdWVbdF07cmV0dXJuIGV9c3RhdGljIGdlblJlbmRlclNoYWRlclZhcmlhbnQoaSl7bGV0IGU9YFJlbmRlclNoYWRlcigke2kudnNOYW1lfSwke2kuZnNOYW1lfSlgO2UrPVwifFwiLGUrPXRoaXMuZ2VuU2hhZGVyVmFyaWFudChpKSxlKz1cInxcIjtmb3IoY29uc3QgdCBpbiBpLnNoYWRlclN0YXRlKWUrPXQrXCI6XCIsZSs9aS5zaGFkZXJTdGF0ZVt0XStcIjtcIjtyZXR1cm4gZX1zdGF0aWMgZ2VuQ29tcHV0ZVNoYWRlclZhcmlhbnQoaSl7bGV0IGU9YENvbXB1dGVTaGFkZXIoJHtpLmluc3RhbmNlSUR9KWA7cmV0dXJuIGUrPVwifFwiLGUrPXRoaXMuZ2VuU2hhZGVyVmFyaWFudChpKSxlfWNvbWJpbmUoaSl7bGV0IGU9aS5zaGFkZXJSZWZsZWN0aW9uLHQ9aS5kZWZpbmVzLHI9e307Zm9yKGxldCBhPTA7YTx0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoO2ErKyl7bGV0IG49dGhpcy5hdHRyaWJ1dGVzW2FdO3Rbbi5uYW1lXSYmKHJbbi5uYW1lXT1uKX1sZXQgcz1lLmF0dHJpYnV0ZXMubGVuZ3RoO2ZvcihsZXQgYT0wO2E8czthKyspe2NvbnN0IG49ZS5hdHRyaWJ1dGVzW2FdO2lmKCFyW24ubmFtZV0pdGhpcy5hdHRyaWJ1dGVzLnB1c2gobik7ZWxzZXtsZXQgbD1yW24ubmFtZV07bC5sb2NhdGlvbj09bi5sb2NhdGlvbiYmbC5uYW1lIT1uLm5hbWUmJmNvbnNvbGUubG9nKFwibG9jYXRpb24gbXVzdCBzYW1lIVwiKX19fXN0YXRpYyBwYXJzZXJWYXJpYWJsZXMoaSl7bGV0IGU9MCx0PVtdO2Zvcig7ZTxpLmxlbmd0aDspe2xldCByPWkuaW5kZXhPZihcIkBncm91cChcIixlKTtpZihyPDApYnJlYWs7bGV0IHM9aS5pbmRleE9mKFwiO1wiLHIpO2U9cztsZXQgYT1pLnN1YnN0cmluZyhyLHMpLG49dGhpcy5leHRyYWN0KGEsXCJAZ3JvdXAoXCIsXCIpXCIpLGw9dGhpcy5leHRyYWN0KGEsXCJAYmluZGluZyhcIixcIilcIiksaD1cIlwiLHU9XCJ2YXJcIjthLmluZGV4T2YoXCJ2YXI8XCIpIT0tMT8oaD10aGlzLmV4dHJhY3QoYSxcIj5cIixcIjpcIiksdT10aGlzLmV4dHJhY3QoYSxcInZhcjxcIixcIj5cIikucmVwbGFjZShcIixcIixcIi1cIikucmVwbGFjZUFsbChcIiBcIixcIlwiKSk6aD10aGlzLmV4dHJhY3QoYSxcInZhclwiLFwiOlwiKTtsZXQgYz1hLnN1YnN0cmluZyhhLmxhc3RJbmRleE9mKFwiOlwiKSsxKS50cmltKCksZj17Z3JvdXA6MCxiaW5kaW5nOjAsdmFyVHlwZTpcIlwiLHZhck5hbWU6XCJcIixkYXRhVHlwZTpcIlwiLGRhdGFJc0J1aWx0aW5UeXBlOiEwLGRhdGFGaWVsZHM6bnVsbH07Zi5ncm91cD1OdW1iZXIucGFyc2VJbnQobiksZi5iaW5kaW5nPU51bWJlci5wYXJzZUludChsKSxmLnZhclR5cGU9dSxmLnZhck5hbWU9aCxmLmRhdGFUeXBlPWMsZi5kYXRhSXNCdWlsdGluVHlwZT10aGlzLmlzQnVpbHRpblR5cGVzKGYuZGF0YVR5cGUpLGYuZGF0YUlzQnVpbHRpblR5cGV8fChmLmRhdGFGaWVsZHM9dGhpcy5wYXJzZXJTdHJ1Y3RGaWVsZHMoaSxmLmRhdGFUeXBlKSksdC5wdXNoKGYpfXJldHVybiB0fXN0YXRpYyBleHRyYWN0KGksZSx0KXtsZXQgcj1pLmluZGV4T2YoZSkrZS5sZW5ndGgscz1pLmluZGV4T2YodCxyKTtyZXR1cm4gaS5zdWJzdHJpbmcocixzKS50cmltKCl9c3RhdGljIGlzQnVpbHRpblR5cGVzKGkpe3N3aXRjaChpKXtjYXNlXCJpMzJcIjpyZXR1cm4hMDtjYXNlXCJ1MzJcIjpyZXR1cm4hMDtjYXNlXCJmMzJcIjpyZXR1cm4hMDtkZWZhdWx0OmxldCBlPWkuaW5kZXhPZihcIjxcIik7aWYoZSE9LTEpc3dpdGNoKGkuc3Vic3RyaW5nKDAsZSkpe2Nhc2VcInZlYzJcIjpyZXR1cm4hMDtjYXNlXCJ2ZWMzXCI6cmV0dXJuITA7Y2FzZVwidmVjNFwiOnJldHVybiEwO2Nhc2VcIm1hdDNcIjpyZXR1cm4hMDtjYXNlXCJtYXQ0XCI6cmV0dXJuITA7Y2FzZVwiYXJyYXlcIjpyZXR1cm4gdGhpcy5pc0J1aWx0aW5UeXBlcyhpLnN1YnN0cmluZyhlKzEsaS5sYXN0SW5kZXhPZihcIj5cIikpKX1icmVha31yZXR1cm4hMX1zdGF0aWMgcGFyc2VyU3RydWN0RmllbGRzKGksZSl7bGV0IHQ9W10scj0wO2Zvcig7cjxpLmxlbmd0aDspe2xldCBzPWkuaW5kZXhPZihcInN0cnVjdCBcIixyKTtpZihzPDApYnJlYWs7bGV0IGE9aS5pbmRleE9mKFwie1wiLHMpO2lmKHI9YSxpLnN1YnN0cmluZyhzKzYsYSkudHJpbSgpPT09ZSl7cz1pLmluZGV4T2YoXCJ7XCIscyksYT1pLmluZGV4T2YoXCJ9XCIscyk7bGV0IGg9aS5zdWJzdHJpbmcocysxLGEpLnNwbGl0KFwiLFwiKTtmb3IobGV0IHUgb2YgaCl7bGV0IGM9dS5pbmRleE9mKFwiOlwiKTtpZihjIT0tMSl7bGV0IGY9e25hbWU6dS5zdWJzdHJpbmcoMCxjKS50cmltKCksdHlwZTp1LnN1YnN0cmluZyhjKzEpLnRyaW0oKX07dC5wdXNoKGYpfX1icmVha319cmV0dXJuIHR9c3RhdGljIHBhcnNlclZlcnRleE9sZChpKXtsZXQgZT1bXSxyPWkuc3BsaXQoXCJmbiBtYWluKFwiKVsxXS5zcGxpdChcIi0+XCIpWzBdLHM9ci5zcGxpdChcIkBcIik7aWYocyYmcy5sZW5ndGg+MSlmb3IobGV0IG49MTtuPHMubGVuZ3RoO24rKyl7bGV0IGg9c1tuXS5yZXBsYWNlKC9cXHMqJC9nLFwiXCIpO2g9aC5yZXBsYWNlQWxsKFwiLFwiLFwiXCIpLGg9aC5yZXBsYWNlQWxsKGBcbmAsXCJcIiksaD1oLnJlcGxhY2VBbGwoXCIgIFwiLFwiIFwiKSx0aGlzLnBhcnNlckF0dHJpYnV0ZShoLGUpfWVsc2V7dmFyIGE9ci5zcGxpdChcIjpcIilbMV07YT1hLnJlcGxhY2VBbGwoXCIgIFwiLFwiXCIpLGE9YS5yZXBsYWNlQWxsKFwiIFwiLFwiXCIpLGE9YS5yZXBsYWNlQWxsKFwiKVwiLFwiXCIpLGE9aS5zcGxpdChgc3RydWN0ICR7YX1gKVsxXTtsZXQgbD1hLmluZGV4T2YoXCJ7XCIpLGg9YS5pbmRleE9mKFwifVwiKTthPWEuc2xpY2UobCxoKSxzPWEuc3BsaXQoXCJAXCIpO2ZvcihsZXQgdT0xO3U8cy5sZW5ndGg7dSsrKXtsZXQgZj1zW3VdLnJlcGxhY2UoL1xccyokL2csXCJcIik7Zj1mLnJlcGxhY2VBbGwoYFxuYCxcIlwiKSxmPWYuc3BsaXQoXCIsXCIpWzBdLGY9Zi5yZXBsYWNlQWxsKFwiICBcIixcIiBcIiksdGhpcy5wYXJzZXJBdHRyaWJ1dGUoZixlKX19cmV0dXJuIGV9c3RhdGljIHBhcnNlclZlcnRleChpLGUpe2xldCB0PVtdLHM9ZS5zcGxpdChgZm4gJHtpfShgKVsxXS5zcGxpdChcIi0+XCIpWzBdLGE9cy5zcGxpdChcIkBcIik7aWYoYSYmYS5sZW5ndGg+MSlmb3IobGV0IGw9MTtsPGEubGVuZ3RoO2wrKyl7bGV0IHU9YVtsXS5yZXBsYWNlKC9cXHMqJC9nLFwiXCIpO3U9dS5yZXBsYWNlQWxsKFwiLFwiLFwiXCIpLHU9dS5yZXBsYWNlQWxsKGBcbmAsXCJcIiksdT11LnJlcGxhY2VBbGwoXCIgIFwiLFwiIFwiKSx0aGlzLnBhcnNlckF0dHJpYnV0ZSh1LHQpfWVsc2V7dmFyIG49cy5zcGxpdChcIjpcIilbMV07bj1uLnJlcGxhY2VBbGwoXCIgIFwiLFwiXCIpLG49bi5yZXBsYWNlQWxsKFwiIFwiLFwiXCIpLG49bi5yZXBsYWNlQWxsKFwiKVwiLFwiXCIpLG49ZS5zcGxpdChgc3RydWN0ICR7bn1gKVsxXTtsZXQgaD1uLmluZGV4T2YoXCJ7XCIpLHU9bi5pbmRleE9mKFwifVwiKTtuPW4uc2xpY2UoaCx1KSxhPW4uc3BsaXQoXCJAXCIpO2ZvcihsZXQgYz0xO2M8YS5sZW5ndGg7YysrKXtsZXQgZD1hW2NdLnJlcGxhY2UoL1xccyokL2csXCJcIik7ZD1kLnJlcGxhY2VBbGwoYFxuYCxcIlwiKSxkPWQuc3BsaXQoXCIsXCIpWzBdLGQ9ZC5yZXBsYWNlQWxsKFwiICBcIixcIiBcIiksdGhpcy5wYXJzZXJBdHRyaWJ1dGUoZCx0KX19cmV0dXJuIHR9c3RhdGljIHBhcnNlckF0dHJpYnV0ZShpLGUpe2xldCB0PXtuYW1lOlwiXCIsZ3JvdXA6MCxsb2NhdGlvbjowLHR5cGU6XCJcIix2YWx1ZVR5cGU6XCJcIix2YWx1ZTowLHNpemU6MCxmb3JtYXQ6XCJmbG9hdDMyXCJ9O2lmKGkuaW5kZXhPZihcImJ1aWx0aW5cIikhPS0xKXt0LnR5cGU9XCJidWlsdGluXCI7dmFyIHI9aS5tYXRjaCgvXFwoKC4rPylcXCkvZylbMF07cj1pLm1hdGNoKC9cXCgoLis/KVxcKS9nKVswXSxyPXIucmVwbGFjZShcIihcIixcIlwiKSxyPXIucmVwbGFjZUFsbChcIilcIixcIlwiKSx0LmxvY2F0aW9uPXBhcnNlSW50KHIpO2xldCBzPWkuc3BsaXQoXCI6XCIpO3QubmFtZT1zWzBdLnNwbGl0KFwiIFwiKVsxXSx0Lm5hbWU9dC5uYW1lLnJlcGxhY2VBbGwoXCIgIFwiLFwiIFwiKSx0Lm5hbWU9dC5uYW1lLnJlcGxhY2VBbGwoXCIgXCIsXCJcIiksdC52YWx1ZVR5cGU9c1sxXSx0LnZhbHVlVHlwZT10LnZhbHVlVHlwZS5yZXBsYWNlQWxsKFwiICBcIixcIiBcIiksdC52YWx1ZVR5cGU9dC52YWx1ZVR5cGUucmVwbGFjZUFsbChcIiBcIixcIlwiKSx0LnZhbHVlVHlwZT10LnZhbHVlVHlwZS5yZXBsYWNlQWxsKFwiXFxyXCIsXCJcIiksdC52YWx1ZVR5cGU9dC52YWx1ZVR5cGUucmVwbGFjZUFsbChcIilcIixcIlwiKSx0LnZhbHVlVHlwZT10LnZhbHVlVHlwZS5yZXBsYWNlQWxsKFwiKVwiLFwiXCIpLHQuc2l6ZT1iaVt0LnZhbHVlVHlwZV0sZS5wdXNoKHQpfWVsc2UgaWYoaS5pbmRleE9mKFwibG9jYXRpb25cIikhPS0xKXt0LnR5cGU9XCJsb2NhdGlvblwiO3ZhciByPWkubWF0Y2goL1xcKCguKz8pXFwpL2cpWzBdO3I9aS5tYXRjaCgvXFwoKC4rPylcXCkvZylbMF0scj1yLnJlcGxhY2UoXCIoXCIsXCJcIikscj1yLnJlcGxhY2VBbGwoXCIpXCIsXCJcIiksdC5sb2NhdGlvbj1wYXJzZUludChyKTtsZXQgYT1pLnNwbGl0KFwiOlwiKTt0Lm5hbWU9YVswXS5zcGxpdChcIiBcIilbMV0sdC5uYW1lPXQubmFtZS5yZXBsYWNlQWxsKFwiICBcIixcIiBcIiksdC5uYW1lPXQubmFtZS5yZXBsYWNlQWxsKFwiIFwiLFwiXCIpLHQudmFsdWVUeXBlPWFbMV0sdC52YWx1ZVR5cGU9dC52YWx1ZVR5cGUucmVwbGFjZUFsbChcIiAgXCIsXCIgXCIpLHQudmFsdWVUeXBlPXQudmFsdWVUeXBlLnJlcGxhY2VBbGwoXCIgXCIsXCJcIiksdC52YWx1ZVR5cGU9dC52YWx1ZVR5cGUucmVwbGFjZUFsbChcIlxcclwiLFwiXCIpLHQudmFsdWVUeXBlPXQudmFsdWVUeXBlLnJlcGxhY2VBbGwoXCIpXCIsXCJcIiksdC52YWx1ZVR5cGU9dC52YWx1ZVR5cGUucmVwbGFjZUFsbChcIilcIixcIlwiKSx0LnNpemU9YmlbdC52YWx1ZVR5cGVdLGUucHVzaCh0KX10LmZvcm1hdD1sbFtiaVt0LnZhbHVlVHlwZV1dfX07bGV0IGN0PURzO28oY3QsXCJfc2hhZGVyUmVmbGVjdGlvbk1hcFwiLG5ldyBNYXApO2NsYXNzIGJlIGV4dGVuZHMgS2F7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSxvKHRoaXMsXCJlbnRyeVBvaW50XCIsXCJDc01haW5cIiksbyh0aGlzLFwid29ya2VyU2l6ZVhcIiwxKSxvKHRoaXMsXCJ3b3JrZXJTaXplWVwiLDApLG8odGhpcyxcIndvcmtlclNpemVaXCIsMCksbyh0aGlzLFwiX2NvbXB1dGVQaXBlbGluZVwiKSxvKHRoaXMsXCJfY3NTaGFkZXJNb2R1bGVcIiksbyh0aGlzLFwiX2Rlc3RDU1wiKSxvKHRoaXMsXCJfc291cmNlQ1NcIiksbyh0aGlzLFwiX3N0b3JhZ2VUZXh0dXJlRGljXCIpLG8odGhpcyxcIl9zYW1wbGVUZXh0dXJlRGljXCIpLG8odGhpcyxcIl9ncm91cHNTaGFkZXJSZWZsZWN0aW9uVmFySW5mb3NcIiksbyh0aGlzLFwiX2dyb3VwQ2FjaGVcIix7fSksdGhpcy5fc291cmNlQ1M9ZSxjdC5nZXRTaGFkZXJSZWZsZWN0aW9uMihlLHRoaXMpLHRoaXMuX3N0b3JhZ2VUZXh0dXJlRGljPW5ldyBNYXAsdGhpcy5fc2FtcGxlVGV4dHVyZURpYz1uZXcgTWFwfXNldFN0b3JhZ2VUZXh0dXJlKGUsdCl7dGhpcy5fc3RvcmFnZVRleHR1cmVEaWMuaGFzKGUpfHx0aGlzLl9zdG9yYWdlVGV4dHVyZURpYy5zZXQoZSx0KX1zZXRTYW1wbGVyVGV4dHVyZShlLHQpe3RoaXMuX3NhbXBsZVRleHR1cmVEaWMuc2V0KGUsdCl9Y29tcHV0ZShlKXt0aGlzLl9jb21wdXRlUGlwZWxpbmV8fHRoaXMuZ2VuQ29tcHV0ZVBpcGVsaW5lKCksZS5zZXRQaXBlbGluZSh0aGlzLl9jb21wdXRlUGlwZWxpbmUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5iaW5kR3JvdXBzLmxlbmd0aDsrK3QpZS5zZXRCaW5kR3JvdXAodCx0aGlzLmJpbmRHcm91cHNbdF0pO3RoaXMud29ya2VyU2l6ZVgmJnRoaXMud29ya2VyU2l6ZVkmJnRoaXMud29ya2VyU2l6ZVo/ZS5kaXNwYXRjaFdvcmtncm91cHModGhpcy53b3JrZXJTaXplWCx0aGlzLndvcmtlclNpemVZLHRoaXMud29ya2VyU2l6ZVopOnRoaXMud29ya2VyU2l6ZVgmJnRoaXMud29ya2VyU2l6ZVk/ZS5kaXNwYXRjaFdvcmtncm91cHModGhpcy53b3JrZXJTaXplWCx0aGlzLndvcmtlclNpemVZKTplLmRpc3BhdGNoV29ya2dyb3Vwcyh0aGlzLndvcmtlclNpemVYKX1jcmVhdGVCdWZmZXJCaW5kR3JvdXAoZSx0LHIscyl7bGV0IGE9dGhpcy5fYnVmZmVyRGljLmdldCh0KTtpZihhKXtsZXQgbj17YmluZGluZzpyLHJlc291cmNlOntidWZmZXI6YS5idWZmZXIsb2Zmc2V0OjAsc2l6ZTphLm1lbW9yeS5zaGFyZURhdGFCdWZmZXIuYnl0ZUxlbmd0aH19O3MucHVzaChuKX1lbHNlIGNvbnNvbGUuZXJyb3IoYENvbXB1dGVTaGFkZXIoJHt0aGlzLmluc3RhbmNlSUR9KWAsYGJ1ZmZlciAke3R9IGlzIG1pc3NpbmchYCl9bm90aWNlQnVmZmVyQ2hhbmdlKGUpe2xldCB0PXRoaXMuX2dyb3VwQ2FjaGVbZV07dCYmdGhpcy5nZW5Hcm91cHModC5ncm91cEluZGV4LHQuaW5mb3MsITApfWdlbkdyb3VwcyhlLHQscj0hMSl7aWYoIXRoaXMuYmluZEdyb3Vwc1tlXXx8cil7Y29uc3Qgcz10W2VdO2xldCBhPVtdO2ZvcihsZXQgbD0wO2w8cy5sZW5ndGg7KytsKXtjb25zdCBoPXNbbF07aWYoaClzd2l0Y2goaC52YXJUeXBlKXtjYXNlXCJ1bmlmb3JtXCI6Y2FzZVwic3RvcmFnZS1yZWFkXCI6Y2FzZVwic3RvcmFnZS1yZWFkX3dyaXRlXCI6dGhpcy5jcmVhdGVCdWZmZXJCaW5kR3JvdXAoZSxoLnZhck5hbWUsaC5iaW5kaW5nLGEpLHRoaXMuX2dyb3VwQ2FjaGVbaC52YXJOYW1lXT17Z3JvdXBJbmRleDplLGluZm9zOnR9O2JyZWFrO2Nhc2VcInZhclwiOmlmKGguZGF0YVR5cGU9PVwic2FtcGxlclwiKXtsZXQgdT1oLnZhck5hbWUucmVwbGFjZShcIlNhbXBsZXJcIixcIlwiKSxjPXRoaXMuX3NhbXBsZVRleHR1cmVEaWMuZ2V0KHUpO2lmKGMpe2xldCBmPXtiaW5kaW5nOmguYmluZGluZyxyZXNvdXJjZTpjLmdwdVNhbXBsZXJ9O2EucHVzaChmKX1lbHNlIGNvbnNvbGUuZXJyb3IoYENvbXB1dGVTaGFkZXIoJHt0aGlzLmluc3RhbmNlSUR9KWAsYHRleHR1cmUgJHtoLnZhck5hbWV9IGlzIG1pc3NpbmchIGApfWVsc2UgaWYoaC5kYXRhVHlwZT09XCJzYW1wbGVyX2NvbXBhcmlzb25cIil7bGV0IHU9aC52YXJOYW1lLnJlcGxhY2UoXCJTYW1wbGVyXCIsXCJcIiksYz10aGlzLl9zYW1wbGVUZXh0dXJlRGljLmdldCh1KTtpZihjKXtsZXQgZj17YmluZGluZzpoLmJpbmRpbmcscmVzb3VyY2U6Yy5ncHVTYW1wbGVyX2NvbXBhcmlzb259O2EucHVzaChmKX1lbHNlIGNvbnNvbGUuZXJyb3IoYENvbXB1dGVTaGFkZXIoJHt0aGlzLmluc3RhbmNlSUR9KWAsYHRleHR1cmUgJHtoLnZhck5hbWV9IGlzIG1pc3NpbmchIGApfWVsc2UgaWYoaC5kYXRhVHlwZS5pbmRleE9mKFwidGV4dHVyZV9zdG9yYWdlXCIpIT0tMSl7bGV0IHU9dGhpcy5fc3RvcmFnZVRleHR1cmVEaWMuZ2V0KGgudmFyTmFtZSk7aWYodSl7bGV0IGM9e2JpbmRpbmc6aC5iaW5kaW5nLHJlc291cmNlOnUuZ2V0R1BVVmlldygpfTthLnB1c2goYyksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZCh1LHRoaXMpfWVsc2UgY29uc29sZS5lcnJvcihgQ29tcHV0ZVNoYWRlcigke3RoaXMuaW5zdGFuY2VJRH0pYCxgdGV4dHVyZSAke2gudmFyTmFtZX0gaXMgbWlzc2luZyEgYCl9ZWxzZSBpZihoLmRhdGFUeXBlLmluZGV4T2YoXCJ0ZXh0dXJlXCIpIT0tMSl7bGV0IHU9dGhpcy5fc2FtcGxlVGV4dHVyZURpYy5nZXQoaC52YXJOYW1lKTtpZih1KXtsZXQgYz17YmluZGluZzpoLmJpbmRpbmcscmVzb3VyY2U6dS5nZXRHUFVWaWV3KCl9O2EucHVzaChjKSxzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKHUsdGhpcyl9ZWxzZSBjb25zb2xlLmVycm9yKGBDb21wdXRlU2hhZGVyKCR7dGhpcy5pbnN0YW5jZUlEfSlgLGB0ZXh0dXJlICR7aC52YXJOYW1lfSBpcyBtaXNzaW5nISBgKX1icmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoXCJ1bnByb2Nlc3NlZCB0eXBlOlwiLGgudmFyVHlwZSk7YnJlYWt9fWxldCBuPVMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnRoaXMuX2NvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoZSksZW50cmllczphfSk7dGhpcy5iaW5kR3JvdXBzW2VdPW59fWdlbkNvbXB1dGVQaXBlbGluZSgpe3RoaXMucHJlQ29tcGlsZVNoYWRlcih0aGlzLl9zb3VyY2VDUyksdGhpcy5nZW5SZWZsZWN0aW9uKCksdGhpcy5fY29tcHV0ZVBpcGVsaW5lPVMuZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7bGF5b3V0OlwiYXV0b1wiLGNvbXB1dGU6e21vZHVsZTp0aGlzLmNvbXBpbGVTaGFkZXIoKSxlbnRyeVBvaW50OnRoaXMuZW50cnlQb2ludH19KSx0aGlzLl9ncm91cHNTaGFkZXJSZWZsZWN0aW9uVmFySW5mb3M9W107bGV0IGU9dGhpcy5zaGFkZXJSZWZsZWN0aW9uO3RoaXMuYmluZEdyb3Vwcz1bXTtmb3IobGV0IHQ9MDt0PGUuZ3JvdXBzLmxlbmd0aDsrK3Qpe2xldCByPWUuZ3JvdXBzW3RdO3RoaXMuX2dyb3Vwc1NoYWRlclJlZmxlY3Rpb25WYXJJbmZvc1t0XT1yLHRoaXMuZ2VuR3JvdXBzKHQsdGhpcy5fZ3JvdXBzU2hhZGVyUmVmbGVjdGlvblZhckluZm9zKX19cHJlQ29tcGlsZVNoYWRlcihlKXtmb3IoY29uc3QgdCBpbiB0aGlzLmNvbnN0VmFsdWVzKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnN0VmFsdWVzLHQpKXtjb25zdCByPXRoaXMuY29uc3RWYWx1ZXNbdF07ZT1lLnJlcGxhY2VBbGwoYCYke3R9YCxyLnRvU3RyaW5nKCkpfXRoaXMuX2Rlc3RDUz11dC5wYXJzZUNvbXB1dGVTaGFkZXIoZSx0aGlzLmRlZmluZVZhbHVlKX1jb21waWxlU2hhZGVyKCl7bGV0IGU9Uy5kZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtsYWJlbDpgQ29tcHV0ZVNoYWRlcigke3RoaXMuaW5zdGFuY2VJRH0pYCxjb2RlOnRoaXMuX2Rlc3RDU30pO3JldHVybiBlLmdldENvbXBpbGF0aW9uSW5mbygpLnRoZW4odD0+e3QubWVzc2FnZXMubGVuZ3RoPjAmJmNvbnNvbGUubG9nKHRoaXMuX2Rlc3RDUyl9KSx0aGlzLl9jc1NoYWRlck1vZHVsZT1lLGV9Z2VuUmVmbGVjdGlvbigpe3RoaXMuc2hhZGVyVmFyaWFudCs9Y3QuZ2VuQ29tcHV0ZVNoYWRlclZhcmlhbnQodGhpcyk7bGV0IGU9Y3QucG9vbEdldFJlZmxlY3Rpb24odGhpcy5zaGFkZXJWYXJpYW50KTtlP3RoaXMuc2hhZGVyUmVmbGVjdGlvbj1lOihjdC5nZXRTaGFkZXJSZWZsZWN0aW9uMih0aGlzLl9kZXN0Q1MsdGhpcyksY3QuY29tYmluZVNoYWRlclJlZmxlY3Rpb25WYXJJbmZvKHRoaXMuc2hhZGVyUmVmbGVjdGlvbix0aGlzLnNoYWRlclJlZmxlY3Rpb24uY3NfdmFyaWFibGVzKSl9fWNsYXNzIGZ0e3N0YXRpYyBzdGFydChlKXtsZXQgdD10aGlzLnByb2ZpbGVyTGFiZWxNYXAuZ2V0KGUpO3R8fCh0PXtsYWJsZTplLHN0YXJ0OjAsZW5kOjAsdG90YWw6MCxjb3VudDowLGNoaWxkOm5ldyBNYXB9LHRoaXMucHJvZmlsZXJMYWJlbE1hcC5zZXQoZSx0KSksdC5zdGFydD1wZXJmb3JtYW5jZS5ub3coKSx0LmVuZD1wZXJmb3JtYW5jZS5ub3coKSx0LmNvdW50PTAsdC5jaGlsZC5jbGVhcigpfXN0YXRpYyBlbmQoZSl7bGV0IHQ9dGhpcy5wcm9maWxlckxhYmVsTWFwLmdldChlKTt0JiYodC5lbmQ9cGVyZm9ybWFuY2Uubm93KCksdC50b3RhbD10LmVuZC10LnN0YXJ0KX1zdGF0aWMgY291bnRTdGFydChlLHQ9XCJcIil7bGV0IHI9dGhpcy5wcm9maWxlckxhYmVsTWFwLmdldChlKTtpZihyJiYoci5jb3VudCsrLHQhPVwiXCIpKXtsZXQgcz1yLmNoaWxkLmdldCh0KTtzfHwocz17bGFibGU6dCxzdGFydDowLGVuZDowLHRvdGFsOjAsY291bnQ6MH0pLHMuc3RhcnQ9cGVyZm9ybWFuY2Uubm93KCkscy5lbmQ9cGVyZm9ybWFuY2Uubm93KCkscy5jb3VudD0wLHIuY2hpbGQuc2V0KHQscyl9fXN0YXRpYyBjb3VudEVuZChlLHQpe2xldCByPXRoaXMucHJvZmlsZXJMYWJlbE1hcC5nZXQoZSk7aWYociYmdCE9XCJcIil7bGV0IHM9ci5jaGlsZC5nZXQodCk7c3x8KHM9e2xhYmxlOnQsc3RhcnQ6MCxlbmQ6MCx0b3RhbDowLGNvdW50OjB9KSxzLmVuZD1wZXJmb3JtYW5jZS5ub3coKSxzLnRvdGFsPXMuZW5kLXMuc3RhcnQscy5jb3VudCsrfX1zdGF0aWMgcHJpbnQoZSl7bGV0IHQ9dGhpcy5wcm9maWxlckxhYmVsTWFwLmdldChlKTt0JiZjb25zb2xlLmxvZyhcInBlcmZvcm1hbmNlXCIsZSx0LnRvdGFsK1wiIG1zXCIpfX1vKGZ0LFwicHJvZmlsZXJMYWJlbE1hcFwiLG5ldyBNYXApO2NvbnN0ICRmPWB2YXIgTW9kdWxlPXR5cGVvZiBNb2R1bGUhPVwidW5kZWZpbmVkXCI/TW9kdWxlOnt9O3ZhciBtb2R1bGVPdmVycmlkZXM9T2JqZWN0LmFzc2lnbih7fSxNb2R1bGUpO3ZhciBhcmd1bWVudHNfPVtdO3ZhciB0aGlzUHJvZ3JhbT1cIi4vdGhpcy5wcm9ncmFtXCI7dmFyIHF1aXRfPShzdGF0dXMsdG9UaHJvdyk9Pnt0aHJvdyB0b1Rocm93fTt2YXIgRU5WSVJPTk1FTlRfSVNfV0VCPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCI7dmFyIEVOVklST05NRU5UX0lTX1dPUktFUj10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiO3ZhciBFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIjt2YXIgc2NyaXB0RGlyZWN0b3J5PVwiXCI7ZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKXtpZihNb2R1bGVbXCJsb2NhdGVGaWxlXCJdKXtyZXR1cm4gTW9kdWxlW1wibG9jYXRlRmlsZVwiXShwYXRoLHNjcmlwdERpcmVjdG9yeSl9cmV0dXJuIHNjcmlwdERpcmVjdG9yeStwYXRofXZhciByZWFkXyxyZWFkQXN5bmMscmVhZEJpbmFyeSxzZXRXaW5kb3dUaXRsZTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXt2YXIgZnM9cmVxdWlyZShcImZzXCIpO3ZhciBub2RlUGF0aD1yZXF1aXJlKFwicGF0aFwiKTtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3NjcmlwdERpcmVjdG9yeT1ub2RlUGF0aC5kaXJuYW1lKHNjcmlwdERpcmVjdG9yeSkrXCIvXCJ9ZWxzZXtzY3JpcHREaXJlY3Rvcnk9X19kaXJuYW1lK1wiL1wifXJlYWRfPShmaWxlbmFtZSxiaW5hcnkpPT57ZmlsZW5hbWU9aXNGaWxlVVJJKGZpbGVuYW1lKT9uZXcgVVJMKGZpbGVuYW1lKTpub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO3JldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsYmluYXJ5P3VuZGVmaW5lZDpcInV0ZjhcIil9O3JlYWRCaW5hcnk9ZmlsZW5hbWU9Pnt2YXIgcmV0PXJlYWRfKGZpbGVuYW1lLHRydWUpO2lmKCFyZXQuYnVmZmVyKXtyZXQ9bmV3IFVpbnQ4QXJyYXkocmV0KX1yZXR1cm4gcmV0fTtyZWFkQXN5bmM9KGZpbGVuYW1lLG9ubG9hZCxvbmVycm9yLGJpbmFyeT10cnVlKT0+e2ZpbGVuYW1lPWlzRmlsZVVSSShmaWxlbmFtZSk/bmV3IFVSTChmaWxlbmFtZSk6bm9kZVBhdGgubm9ybWFsaXplKGZpbGVuYW1lKTtmcy5yZWFkRmlsZShmaWxlbmFtZSxiaW5hcnk/dW5kZWZpbmVkOlwidXRmOFwiLCgoZXJyLGRhdGEpPT57aWYoZXJyKW9uZXJyb3IoZXJyKTtlbHNlIG9ubG9hZChiaW5hcnk/ZGF0YS5idWZmZXI6ZGF0YSl9KSl9O2lmKCFNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXSYmcHJvY2Vzcy5hcmd2Lmxlbmd0aD4xKXt0aGlzUHJvZ3JhbT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIil9YXJndW1lbnRzXz1wcm9jZXNzLmFyZ3Yuc2xpY2UoMik7aWYodHlwZW9mIG1vZHVsZSE9XCJ1bmRlZmluZWRcIil7bW9kdWxlW1wiZXhwb3J0c1wiXT1Nb2R1bGV9cHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGV4PT57aWYoZXghPT1cInVud2luZFwiJiYhKGV4IGluc3RhbmNlb2YgRXhpdFN0YXR1cykmJiEoZXguY29udGV4dCBpbnN0YW5jZW9mIEV4aXRTdGF0dXMpKXt0aHJvdyBleH19KSk7cXVpdF89KHN0YXR1cyx0b1Rocm93KT0+e3Byb2Nlc3MuZXhpdENvZGU9c3RhdHVzO3Rocm93IHRvVGhyb3d9O01vZHVsZVtcImluc3BlY3RcIl09KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn1lbHNlIGlmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKXtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3NjcmlwdERpcmVjdG9yeT1zZWxmLmxvY2F0aW9uLmhyZWZ9ZWxzZSBpZih0eXBlb2YgZG9jdW1lbnQhPVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3NjcmlwdERpcmVjdG9yeT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31pZihzY3JpcHREaXJlY3RvcnkuaW5kZXhPZihcImJsb2I6XCIpIT09MCl7c2NyaXB0RGlyZWN0b3J5PXNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCxzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSl9ZWxzZXtzY3JpcHREaXJlY3Rvcnk9XCJcIn17cmVhZF89dXJsPT57dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5zZW5kKG51bGwpO3JldHVybiB4aHIucmVzcG9uc2VUZXh0fTtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3JlYWRCaW5hcnk9dXJsPT57dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfX1yZWFkQXN5bmM9KHVybCxvbmxvYWQsb25lcnJvcik9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCx0cnVlKTt4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjt4aHIub25sb2FkPSgpPT57aWYoeGhyLnN0YXR1cz09MjAwfHx4aHIuc3RhdHVzPT0wJiZ4aHIucmVzcG9uc2Upe29ubG9hZCh4aHIucmVzcG9uc2UpO3JldHVybn1vbmVycm9yKCl9O3hoci5vbmVycm9yPW9uZXJyb3I7eGhyLnNlbmQobnVsbCl9fXNldFdpbmRvd1RpdGxlPXRpdGxlPT5kb2N1bWVudC50aXRsZT10aXRsZX1lbHNle312YXIgb3V0PU1vZHVsZVtcInByaW50XCJdfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBlcnI9TW9kdWxlW1wicHJpbnRFcnJcIl18fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKE1vZHVsZSxtb2R1bGVPdmVycmlkZXMpO21vZHVsZU92ZXJyaWRlcz1udWxsO2lmKE1vZHVsZVtcImFyZ3VtZW50c1wiXSlhcmd1bWVudHNfPU1vZHVsZVtcImFyZ3VtZW50c1wiXTtpZihNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXSl0aGlzUHJvZ3JhbT1Nb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXTtpZihNb2R1bGVbXCJxdWl0XCJdKXF1aXRfPU1vZHVsZVtcInF1aXRcIl07dmFyIHdhc21CaW5hcnk7aWYoTW9kdWxlW1wid2FzbUJpbmFyeVwiXSl3YXNtQmluYXJ5PU1vZHVsZVtcIndhc21CaW5hcnlcIl07dmFyIG5vRXhpdFJ1bnRpbWU9TW9kdWxlW1wibm9FeGl0UnVudGltZVwiXXx8dHJ1ZTtpZih0eXBlb2YgV2ViQXNzZW1ibHkhPVwib2JqZWN0XCIpe2Fib3J0KFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKX12YXIgd2FzbU1lbW9yeTt2YXIgQUJPUlQ9ZmFsc2U7dmFyIEVYSVRTVEFUVVM7dmFyIEhFQVA4LEhFQVBVOCxIRUFQMTYsSEVBUFUxNixIRUFQMzIsSEVBUFUzMixIRUFQRjMyLEhFQVBGNjQ7ZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKXt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjtNb2R1bGVbXCJIRUFQOFwiXT1IRUFQOD1uZXcgSW50OEFycmF5KGIpO01vZHVsZVtcIkhFQVAxNlwiXT1IRUFQMTY9bmV3IEludDE2QXJyYXkoYik7TW9kdWxlW1wiSEVBUDMyXCJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShiKTtNb2R1bGVbXCJIRUFQVThcIl09SEVBUFU4PW5ldyBVaW50OEFycmF5KGIpO01vZHVsZVtcIkhFQVBVMTZcIl09SEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYik7TW9kdWxlW1wiSEVBUFUzMlwiXT1IRUFQVTMyPW5ldyBVaW50MzJBcnJheShiKTtNb2R1bGVbXCJIRUFQRjMyXCJdPUhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShiKTtNb2R1bGVbXCJIRUFQRjY0XCJdPUhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShiKX12YXIgd2FzbVRhYmxlO3ZhciBfX0FUUFJFUlVOX189W107dmFyIF9fQVRJTklUX189W107dmFyIF9fQVRNQUlOX189W107dmFyIF9fQVRQT1NUUlVOX189W107dmFyIHJ1bnRpbWVJbml0aWFsaXplZD1mYWxzZTt2YXIgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXI9MDtmdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCl7cmV0dXJuIG5vRXhpdFJ1bnRpbWV8fHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyPjB9ZnVuY3Rpb24gcHJlUnVuKCl7aWYoTW9kdWxlW1wicHJlUnVuXCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicHJlUnVuXCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlUnVuXCJdPVtNb2R1bGVbXCJwcmVSdW5cIl1dO3doaWxlKE1vZHVsZVtcInByZVJ1blwiXS5sZW5ndGgpe2FkZE9uUHJlUnVuKE1vZHVsZVtcInByZVJ1blwiXS5zaGlmdCgpKX19Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKX1mdW5jdGlvbiBpbml0UnVudGltZSgpe3J1bnRpbWVJbml0aWFsaXplZD10cnVlO2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pfWZ1bmN0aW9uIHByZU1haW4oKXtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUTUFJTl9fKX1mdW5jdGlvbiBwb3N0UnVuKCl7aWYoTW9kdWxlW1wicG9zdFJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInBvc3RSdW5cIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwb3N0UnVuXCJdPVtNb2R1bGVbXCJwb3N0UnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwb3N0UnVuXCJdLmxlbmd0aCl7YWRkT25Qb3N0UnVuKE1vZHVsZVtcInBvc3RSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pfWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Jbml0KGNiKXtfX0FUSU5JVF9fLnVuc2hpZnQoY2IpfWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKX12YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGw7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcysrO2lmKE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0pe01vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKX19ZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzLS07aWYoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSl7TW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpfWlmKHJ1bkRlcGVuZGVuY2llcz09MCl7aWYocnVuRGVwZW5kZW5jeVdhdGNoZXIhPT1udWxsKXtjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtydW5EZXBlbmRlbmN5V2F0Y2hlcj1udWxsfWlmKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCl7dmFyIGNhbGxiYWNrPWRlcGVuZGVuY2llc0Z1bGZpbGxlZDtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtjYWxsYmFjaygpfX19ZnVuY3Rpb24gYWJvcnQod2hhdCl7aWYoTW9kdWxlW1wib25BYm9ydFwiXSl7TW9kdWxlW1wib25BYm9ydFwiXSh3aGF0KX13aGF0PVwiQWJvcnRlZChcIit3aGF0K1wiKVwiO2Vycih3aGF0KTtBQk9SVD10cnVlO0VYSVRTVEFUVVM9MTt3aGF0Kz1cIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIjt2YXIgZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO3Rocm93IGV9dmFyIGRhdGFVUklQcmVmaXg9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7ZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKXtyZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KX1mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpe3JldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKX12YXIgd2FzbUJpbmFyeUZpbGU7d2FzbUJpbmFyeUZpbGU9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCZkJSZ0FYOEJmMkFCZndCZ0EzOS9md0YvWUFOL2YzOEFZQUFBWUFWL2YzOS9md0JnQkg5L2YzOEFZQVovZjM5L2YzOEFZQUFCZjJBQ2YzOEJmMkFFZjM5L2Z3Ri9ZQUY4QVgxZ0FueC9BWHhnQW45L0FHQUJmUUY5WUFOL2YzMEFZQUorZndGL1lBWi9mSDkvZjM4QmYyQUNmWDhCZjJBRGYzNS9BWDRDSHdVQllRRmhBQW9CWVFGaUFBTUJZUUZqQUFBQllRRmtBQVFCWVFGbEFBTURTRWNEQlFzTEFnRUFFQUVBREFFRERRNENBQTRQQkFRQUJBQUJBQVlEQ1FBQUFBa1JBd0FLREFBQ0FSSU5BUUFBQVFBQUFBQUhCd1VGQVFZR0FnRUJFd0FDQ1E4QkNBZ0lDQVFGQVhBQklDQUZCd0VCZ0FLQWdBSUdDQUYvQVVIZ3R3UUxCelVOQVdZQ0FBRm5BQnNCYUFFQUFXa0FNQUZxQUVzQmF3QktBV3dBU1FGdEFFZ0JiZ0JIQVc4QVJnRndBRVVCY1FBeEFYSUFOd2tsQVFCQkFRc2ZJaDVCUUR3elEwUkNKaUlOTFMwL09EbytEVGs3UFEwMURUUU5OaDB5SFFyeXZnRkhGd0FnQUMwQUFFRWdjVVVFUUNBQklBSWdBQkFVR2dzTGJnRUJmeU1BUVlBQ2F5SUZKQUFDUUNBQ0lBTk1EUUFnQkVHQXdBUnhEUUFnQlNBQlFmOEJjU0FDSUFOcklnTkJnQUlnQTBHQUFra2lBUnNRRVNBQlJRUkFBMEFnQUNBRlFZQUNFQVVnQTBHQUFtc2lBMEgvQVVzTkFBc0xJQUFnQlNBREVBVUxJQVZCZ0FKcUpBQUxTd0VDZkNBQUlBQ2lJZ0VnQUtJaUFpQUJJQUdpb2lBQlJLZEdPNHlIemNZK29rUjA1OHJpK1FBcXY2Q2lJQUlnQVVTeSsyNkpFQkdCUDZKRWQ2ekxWRlZWeGIrZ29pQUFvS0MyQzA4QkFYd2dBQ0FBb2lJQUlBQWdBS0lpQWFJZ0FFUnBVTzdnUXBQNVBxSkVKeDRQNklmQVZyK2dvaUFCUkVJNkJlRlRWYVUvb2lBQVJJRmVEUDMvLzkrL29rUUFBQUFBQUFEd1A2Q2dvTFlMZEFFQmZ5QUNSUVJBSUFBb0FnUWdBU2dDQkVZUEN5QUFJQUZHQkVCQkFROExJQUVvQWdRaUFpMEFBQ0VCQWtBZ0FDZ0NCQ0lETFFBQUlnQkZEUUFnQUNBQlJ3MEFBMEFnQWkwQUFTRUJJQU10QUFFaUFFVU5BU0FDUVFGcUlRSWdBMEVCYWlFRElBQWdBVVlOQUFzTElBQWdBVVlMMGdzQkIzOENRQ0FBUlEwQUlBQkJDR3NpQWlBQVFRUnJLQUlBSWdGQmVIRWlBR29oQlFKQUlBRkJBWEVOQUNBQlFRTnhSUTBCSUFJZ0FpZ0NBQ0lCYXlJQ1FmZ3pLQUlBU1EwQklBQWdBV29oQUFKQUFrQkIvRE1vQWdBZ0FrY0VRQ0FCUWY4QlRRUkFJQUZCQTNZaEJDQUNLQUlNSWdFZ0FpZ0NDQ0lEUmdSQVFlZ3pRZWd6S0FJQVFYNGdCSGR4TmdJQURBVUxJQU1nQVRZQ0RDQUJJQU0yQWdnTUJBc2dBaWdDR0NFR0lBSWdBaWdDRENJQlJ3UkFJQUlvQWdnaUF5QUJOZ0lNSUFFZ0F6WUNDQXdEQ3lBQ1FSUnFJZ1FvQWdBaUEwVUVRQ0FDS0FJUUlnTkZEUUlnQWtFUWFpRUVDd05BSUFRaEJ5QURJZ0ZCRkdvaUJDZ0NBQ0lERFFBZ0FVRVFhaUVFSUFFb0FoQWlBdzBBQ3lBSFFRQTJBZ0FNQWdzZ0JTZ0NCQ0lCUVFOeFFRTkhEUUpCOERNZ0FEWUNBQ0FGSUFGQmZuRTJBZ1FnQWlBQVFRRnlOZ0lFSUFVZ0FEWUNBQThMUVFBaEFRc2dCa1VOQUFKQUlBSW9BaHdpQTBFQ2RFR1lObW9pQkNnQ0FDQUNSZ1JBSUFRZ0FUWUNBQ0FCRFFGQjdETkI3RE1vQWdCQmZpQURkM0UyQWdBTUFnc2dCa0VRUVJRZ0JpZ0NFQ0FDUmh0cUlBRTJBZ0FnQVVVTkFRc2dBU0FHTmdJWUlBSW9BaEFpQXdSQUlBRWdBellDRUNBRElBRTJBaGdMSUFJb0FoUWlBMFVOQUNBQklBTTJBaFFnQXlBQk5nSVlDeUFDSUFWUERRQWdCU2dDQkNJQlFRRnhSUTBBQWtBQ1FBSkFBa0FnQVVFQ2NVVUVRRUdBTkNnQ0FDQUZSZ1JBUVlBMElBSTJBZ0JCOUROQjlETW9BZ0FnQUdvaUFEWUNBQ0FDSUFCQkFYSTJBZ1FnQWtIOE15Z0NBRWNOQmtId00wRUFOZ0lBUWZ3elFRQTJBZ0FQQzBIOE15Z0NBQ0FGUmdSQVFmd3pJQUkyQWdCQjhETkI4RE1vQWdBZ0FHb2lBRFlDQUNBQ0lBQkJBWEkyQWdRZ0FDQUNhaUFBTmdJQUR3c2dBVUY0Y1NBQWFpRUFJQUZCL3dGTkJFQWdBVUVEZGlFRUlBVW9BZ3dpQVNBRktBSUlJZ05HQkVCQjZETkI2RE1vQWdCQmZpQUVkM0UyQWdBTUJRc2dBeUFCTmdJTUlBRWdBellDQ0F3RUN5QUZLQUlZSVFZZ0JTQUZLQUlNSWdGSEJFQkIrRE1vQWdBYUlBVW9BZ2dpQXlBQk5nSU1JQUVnQXpZQ0NBd0RDeUFGUVJScUlnUW9BZ0FpQTBVRVFDQUZLQUlRSWdORkRRSWdCVUVRYWlFRUN3TkFJQVFoQnlBRElnRkJGR29pQkNnQ0FDSUREUUFnQVVFUWFpRUVJQUVvQWhBaUF3MEFDeUFIUVFBMkFnQU1BZ3NnQlNBQlFYNXhOZ0lFSUFJZ0FFRUJjallDQkNBQUlBSnFJQUEyQWdBTUF3dEJBQ0VCQ3lBR1JRMEFBa0FnQlNnQ0hDSURRUUowUVpnMmFpSUVLQUlBSUFWR0JFQWdCQ0FCTmdJQUlBRU5BVUhzTTBIc015Z0NBRUYrSUFOM2NUWUNBQXdDQ3lBR1FSQkJGQ0FHS0FJUUlBVkdHMm9nQVRZQ0FDQUJSUTBCQ3lBQklBWTJBaGdnQlNnQ0VDSURCRUFnQVNBRE5nSVFJQU1nQVRZQ0dBc2dCU2dDRkNJRFJRMEFJQUVnQXpZQ0ZDQURJQUUyQWhnTElBSWdBRUVCY2pZQ0JDQUFJQUpxSUFBMkFnQWdBa0g4TXlnQ0FFY05BRUh3TXlBQU5nSUFEd3NnQUVIL0FVMEVRQ0FBUVhoeFFaQTBhaUVCQW45QjZETW9BZ0FpQTBFQklBQkJBM1owSWdCeFJRUkFRZWd6SUFBZ0EzSTJBZ0FnQVF3QkN5QUJLQUlJQ3lFQUlBRWdBallDQ0NBQUlBSTJBZ3dnQWlBQk5nSU1JQUlnQURZQ0NBOExRUjhoQXlBQVFmLy8vd2ROQkVBZ0FFRW1JQUJCQ0habklnRnJka0VCY1NBQlFRRjBhMEUrYWlFREN5QUNJQU0yQWh3Z0FrSUFOd0lRSUFOQkFuUkJtRFpxSVFFQ1FBSkFBa0JCN0RNb0FnQWlCRUVCSUFOMElnZHhSUVJBUWV3eklBUWdCM0kyQWdBZ0FTQUNOZ0lBSUFJZ0FUWUNHQXdCQ3lBQVFSa2dBMEVCZG10QkFDQURRUjlIRzNRaEF5QUJLQUlBSVFFRFFDQUJJZ1FvQWdSQmVIRWdBRVlOQWlBRFFSMTJJUUVnQTBFQmRDRURJQVFnQVVFRWNXb2lCMEVRYWlnQ0FDSUJEUUFMSUFjZ0FqWUNFQ0FDSUFRMkFoZ0xJQUlnQWpZQ0RDQUNJQUkyQWdnTUFRc2dCQ2dDQ0NJQUlBSTJBZ3dnQkNBQ05nSUlJQUpCQURZQ0dDQUNJQVEyQWd3Z0FpQUFOZ0lJQzBHSU5FR0lOQ2dDQUVFQmF5SUFRWDhnQUJzMkFnQUxDMDhCQW45QjJDa29BZ0FpQVNBQVFRZHFRWGh4SWdKcUlRQUNRQ0FDUVFBZ0FDQUJUUnNOQUNBQVB3QkJFSFJMQkVBZ0FCQUNSUTBCQzBIWUtTQUFOZ0lBSUFFUEMwR29Na0V3TmdJQVFYOExnd0VDQTM4QmZnSkFJQUJDZ0lDQWdCQlVCRUFnQUNFRkRBRUxBMEFnQVVFQmF5SUJJQUFnQUVJS2dDSUZRZ3ArZmFkQk1ISTZBQUFnQUVMLy8vLy9ud0ZXSVFJZ0JTRUFJQUlOQUFzTElBV25JZ0lFUUFOQUlBRkJBV3NpQVNBQ0lBSkJDbTRpQTBFS2JHdEJNSEk2QUFBZ0FrRUpTeUVFSUFNaEFpQUVEUUFMQ3lBQkN3WUFJQUFRQ2dzMUFRRi9RUUVnQUNBQVFRRk5HeUVBQWtBRFFDQUFFQ1FpQVEwQlFkZzNLQUlBSWdFRVFDQUJFUVFBREFFTEN4QURBQXNnQVF1b0FRQUNRQ0FCUVlBSVRnUkFJQUJFQUFBQUFBQUE0SCtpSVFBZ0FVSC9EMGtFUUNBQlFmOEhheUVCREFJTElBQkVBQUFBQUFBQTRIK2lJUUJCL1JjZ0FTQUJRZjBYVGh0Qi9nOXJJUUVNQVFzZ0FVR0JlRW9OQUNBQVJBQUFBQUFBQUdBRG9pRUFJQUZCdUhCTEJFQWdBVUhKQjJvaEFRd0JDeUFBUkFBQUFBQUFBR0FEb2lFQVFmQm9JQUVnQVVId2FFd2JRWklQYWlFQkN5QUFJQUZCL3dkcXJVSTBocitpQ3dZQUlBQVFDZ3Z3QWdJQ2Z3RitBa0FnQWtVTkFDQUFJQUU2QUFBZ0FDQUNhaUlEUVFGcklBRTZBQUFnQWtFRFNRMEFJQUFnQVRvQUFpQUFJQUU2QUFFZ0EwRURheUFCT2dBQUlBTkJBbXNnQVRvQUFDQUNRUWRKRFFBZ0FDQUJPZ0FESUFOQkJHc2dBVG9BQUNBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQURZQ0FDQURJQUlnQkd0QmZIRWlBbW9pQVVFRWF5QUFOZ0lBSUFKQkNVa05BQ0FESUFBMkFnZ2dBeUFBTmdJRUlBRkJDR3NnQURZQ0FDQUJRUXhySUFBMkFnQWdBa0VaU1EwQUlBTWdBRFlDR0NBRElBQTJBaFFnQXlBQU5nSVFJQU1nQURZQ0RDQUJRUkJySUFBMkFnQWdBVUVVYXlBQU5nSUFJQUZCR0dzZ0FEWUNBQ0FCUVJ4cklBQTJBZ0FnQWlBRFFRUnhRUmh5SWdGcklnSkJJRWtOQUNBQXJVS0JnSUNBRUg0aEJTQUJJQU5xSVFFRFFDQUJJQVUzQXhnZ0FTQUZOd01RSUFFZ0JUY0RDQ0FCSUFVM0F3QWdBVUVnYWlFQklBSkJJR3NpQWtFZlN3MEFDd3NMTWdBZ0FDQUJLZ0lBSUFBcUFnQ1NPQUlBSUFBZ0FTb0NCQ0FBS2dJRWtqZ0NCQ0FBSUFFcUFnZ2dBQ29DQ0pJNEFnZ0wvZ0lDQTM4QmZDTUFRUkJySWdFa0FBSkFJQUM4SWdOQi8vLy8vd2R4SWdKQjJwK2srZ05OQkVBZ0FrR0FnSURNQTBrTkFTQUF1eEFISVFBTUFRc2dBa0hScCsyREJFMEVRQ0FBdXlFRUlBSkI0NWZiZ0FSTkJFQWdBMEVBU0FSQUlBUkVHQzFFVlBzaCtUK2dFQWlNSVFBTUF3c2dCRVFZTFVSVSt5SDV2NkFRQ0NFQURBSUxSQmd0UkZUN0lRbkFSQmd0UkZUN0lRbEFJQU5CQUU0YklBU2dtaEFISVFBTUFRc2dBa0hWNDRpSEJFMEVRQ0FDUWQvYnY0VUVUUVJBSUFDN0lRUWdBMEVBU0FSQUlBUkUwaUV6ZjN6WkVrQ2dFQWdoQUF3REN5QUVSTkloTTM5ODJSTEFvQkFJakNFQURBSUxSQmd0UkZUN0lSbEFSQmd0UkZUN0lSbkFJQU5CQUVnYklBQzdvQkFISVFBTUFRc2dBa0dBZ0lEOEIwOEVRQ0FBSUFDVElRQU1BUXNDUUFKQUFrQUNRQ0FBSUFGQkNHb1FMa0VEY1E0REFBRUNBd3NnQVNzRENCQUhJUUFNQXdzZ0FTc0RDQkFJSVFBTUFnc2dBU3NEQ0pvUUJ5RUFEQUVMSUFFckF3Z1FDSXdoQUFzZ0FVRVFhaVFBSUFBTHdBRUJBMzhDUUNBQklBSW9BaEFpQXdSL0lBTUZJQUlRRlEwQklBSW9BaEFMSUFJb0FoUWlCV3RMQkVBZ0FpQUFJQUVnQWlnQ0pCRUNBQThMQWtBZ0FpZ0NVRUVBU0FSQVFRQWhBd3dCQ3lBQklRUURRQ0FFSWdORkJFQkJBQ0VEREFJTElBQWdBMEVCYXlJRWFpMEFBRUVLUncwQUN5QUNJQUFnQXlBQ0tBSWtFUUlBSWdRZ0Ewa05BU0FBSUFOcUlRQWdBU0FEYXlFQklBSW9BaFFoQlFzZ0JTQUFJQUVRTEJvZ0FpQUNLQUlVSUFGcU5nSVVJQUVnQTJvaEJBc2dCQXRaQVFGL0lBQWdBQ2dDU0NJQlFRRnJJQUZ5TmdKSUlBQW9BZ0FpQVVFSWNRUkFJQUFnQVVFZ2NqWUNBRUYvRHdzZ0FFSUFOd0lFSUFBZ0FDZ0NMQ0lCTmdJY0lBQWdBVFlDRkNBQUlBRWdBQ2dDTUdvMkFoQkJBQXZvQWdJRGZ3RjhJd0JCRUdzaUFTUUFBbjBnQUx3aUEwSC8vLy8vQjNFaUFrSGFuNlQ2QTAwRVFFTUFBSUEvSUFKQmdJQ0F6QU5KRFFFYUlBQzdFQWdNQVFzZ0FrSFJwKzJEQkUwRVFDQUNRZVNYMjRBRVR3UkFSQmd0UkZUN0lRbEFSQmd0UkZUN0lRbkFJQU5CQUVnYklBQzdvQkFJakF3Q0N5QUF1eUVFSUFOQkFFZ0VRQ0FFUkJndFJGVDdJZmsvb0JBSERBSUxSQmd0UkZUN0lmay9JQVNoRUFjTUFRc2dBa0hWNDRpSEJFMEVRQ0FDUWVEYnY0VUVUd1JBUkJndFJGVDdJUmxBUkJndFJGVDdJUm5BSUFOQkFFZ2JJQUM3b0JBSURBSUxJQU5CQUVnRVFFVFNJVE4vZk5rU3dDQUF1NkVRQnd3Q0N5QUF1MFRTSVROL2ZOa1N3S0FRQnd3QkN5QUFJQUNUSUFKQmdJQ0EvQWRQRFFBYUFrQUNRQUpBQWtBZ0FDQUJRUWhxRUM1QkEzRU9Bd0FCQWdNTElBRXJBd2dRQ0F3REN5QUJLd01JbWhBSERBSUxJQUVyQXdnUUNJd01BUXNnQVNzRENCQUhDeUVBSUFGQkVHb2tBQ0FBQ3pNQkFuMGdBU29DQUNBQ2xDRURJQUVxQWdRZ0FwUWhCQ0FBSUFFcUFnZ2dBcFE0QWdnZ0FDQUVPQUlFSUFBZ0F6Z0NBQXNxQVFGL1FRUVFJeUlBUWVRbU5nSUFJQUJCdkNZMkFnQWdBRUhRSmpZQ0FDQUFRY0FuUVFFUUFRQUxYd0VEZjBFSUVDTWlBRUhrSmpZQ0FDQUFRZFFuTmdJQVFaMElFQ3NpQVVFTmFoQU9JZ0pCQURZQ0NDQUNJQUUyQWdRZ0FpQUJOZ0lBSUFBZ0FrRU1ha0dkQ0NBQlFRRnFFQ3cyQWdRZ0FFR0VLRFlDQUNBQVFhUW9RUUlRQVFBTGZ3QWdBUDBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQWlRZ0FQME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBaFFnQVAwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFnUWdBRUdBZ0lEOEF6WUNQQ0FBUVlDQWdQd0ROZ0lBSUFCQ0FEY0NOQ0FBUVlDQWdQd0ROZ0lvSUFCQmdJQ0EvQU0yQWhRZ0FBdFRBRUhzS1VFQU5nSUFRZVFwUWdBM0FnQkIrQ2xCQURZQ0FFSHdLVUlBTndJQVFZUXFRUUEyQWdCQi9DbENBRGNDQUVHUUtrRUFOZ0lBUVlncVFnQTNBZ0JCeEROQnpESTJBZ0JCL0RKQktqWUNBQXY4QndNSWZ3NTlFSHNqQUVGQWFpSUNKQUJCNUNrb0FnQWdBRUVHZEdvaEFVSDhLU2dDQUNBQVFRUjBhaUlGS0FJQUJFQWdCU2dDQkNFREl3QkJFR3NpQmlRQUlBQkJKR3dpQkVId0tTZ0NBR29pQUVFWWFpRUhJQUJCREdvaENDQURCRUFnQmtFRWFpSURRWWdxS0FJQUlBUnFJZ1JCNENrcUFnQVFGeUFBSUFNUUVpQURJQVJCREdwQjRDa3FBZ0FRRnlBSUlBTVFFaUFESUFSQkdHcEI0Q2txQWdBUUZ5QUhJQU1RRWdzZ0FDb0NGQ0VKSUFBcUFoQWhDaUFBS2dJQUlSSWdBQ29DQkNFVElBQXFBZ2doRUNBSUtnSUFJUXdnQVVFQU5nSXNJQUZCQURZQ0hDQUJRUUEyQWd3Z0RFTTErbzQ4bEVNQUFBQS9sQ0lNRUJNaERpQUtRelg2amp5VVF3QUFBRCtVSWdvUUV5RVJJQWxETmZxT1BKUkRBQUFBUDVRaURSQVRJUWtnREJBV0lRc2dDaEFXSVE4Z0FTQVFJQXNnRVpRaUZDQU5FQllpQ3BRZ0NTQU9JQStVSWcyVWtpSU1JQWtnQ3lBUGxDSUxsQ0FLSUE0Z0VaUWlENVNUSWhFZ0VaSWlEcFFpRlNBTElBcVVJQThnQ1pTU0lnc2dEU0FLbENBSklCU1VreUlKSUFtU0lnK1VJZzJUbERnQ0pDQUJJQkFnQ1NBT2xDSVVJQXNnRENBTWtpSUtsQ0lXa3BRNEFpQWdBU0FUSUJVZ0RaS1VPQUlZSUFFZ0V5QUpJQXFVSWcwZ0N5QU9sQ0lMazVRNEFoQWdBU0FTSUJRZ0ZwT1VPQUlJSUFFZ0VpQU5JQXVTbERnQ0JDQUJJQkJEQUFDQVB5QUpJQStVSWdrZ0RDQUtsQ0lRa3BPVU9BSW9JQUVnRTBNQUFJQS9JQWtnRVNBT2xDSUprcE9VT0FJVUlBRWdFa01BQUlBL0lCQWdDWktUbERnQ0FDQUJJQWNxQWdBNEFqQWdBU0FBS2dJY09BSTBJQUFxQWlBaENTQUJRWUNBZ1B3RE5nSThJQUVnQ1RnQ09DQUdRUkJxSkFBZ0JTZ0NDQ0lBUVg5SEJFQWdBQkFjSVFBZ0FoQWFHaUFCL1FrQ0RDRWJJQUg5Q1FJSUlSd2dBZjBKQWdBaEhTQUIvUWtDQkNFZUlBSDlDUUljSVI4Z0FmMEpBaGdoSUNBQi9Ra0NFQ0VoSUFIOUNRSVVJU0lnQWYwSkFpd2hJeUFCL1FrQ0tDRWtJQUg5Q1FJZ0lTVWdBZjBKQWlRaEppQUNJQUQ5QUFJd0loY2dBZjBKQWp6OTVnRWdBUDBBQWlBaUdDQUIvUWtDT1AzbUFTQUEvUUFDQUNJWklBSDlDUUl3L2VZQklBRDlBQUlRSWhvZ0FmMEpBalQ5NWdIOTVBSDk1QUg5NUFIOUN3SXdJQUlnRnlBai9lWUJJQmdnSlAzbUFTQVpJQ1g5NWdFZ0dpQW0vZVlCL2VRQi9lUUIvZVFCL1FzQ0lDQUNJQmNnSC8zbUFTQVlJQ0Q5NWdFZ0dTQWgvZVlCSUJvZ0l2M21BZjNrQWYza0FmM2tBZjBMQWhBZ0FpQVhJQnY5NWdFZ0dDQWMvZVlCSUJrZ0hmM21BU0FlSUJyOTVnSDk1QUg5NUFIOTVBSDlDd0lBSUFFZ0F2MEFBakQ5Q3dJd0lBRWdBdjBBQWlEOUN3SWdJQUVnQXYwQUFoRDlDd0lRSUFFZ0F2MEFBZ0Q5Q3dJQUN5QUZRUUEyQWdBTElBSkJRR3NrQUNBQkN3c0FJQUFRSGhvZ0FCQUtDekVCQW44Z0FFSFVKellDQUNBQUtBSUVRUXhySWdFZ0FTZ0NDRUVCYXlJQ05nSUlJQUpCQUVnRVFDQUJFQkFMSUFBTG1nRUFJQUJCQVRvQU5RSkFJQUFvQWdRZ0FrY05BQ0FBUVFFNkFEUUNRQ0FBS0FJUUlnSkZCRUFnQUVFQk5nSWtJQUFnQXpZQ0dDQUFJQUUyQWhBZ0EwRUJSdzBDSUFBb0FqQkJBVVlOQVF3Q0N5QUJJQUpHQkVBZ0FDZ0NHQ0lDUVFKR0JFQWdBQ0FETmdJWUlBTWhBZ3NnQUNnQ01FRUJSdzBDSUFKQkFVWU5BUXdDQ3lBQUlBQW9BaVJCQVdvMkFpUUxJQUJCQVRvQU5nc0xYUUVCZnlBQUtBSVFJZ05GQkVBZ0FFRUJOZ0lrSUFBZ0FqWUNHQ0FBSUFFMkFoQVBDd0pBSUFFZ0EwWUVRQ0FBS0FJWVFRSkhEUUVnQUNBQ05nSVlEd3NnQUVFQk9nQTJJQUJCQWpZQ0dDQUFJQUFvQWlSQkFXbzJBaVFMQzdrQ0FRTi9Jd0JCUUdvaUFpUUFJQUFvQWdBaUEwRUVheWdDQUNFRUlBTkJDR3NvQWdBaEF5QUNRZ0EzQWlBZ0FrSUFOd0lvSUFKQ0FEY0NNQ0FDUWdBM0FEY2dBa0lBTndJWUlBSkJBRFlDRkNBQ1FaUWtOZ0lRSUFJZ0FEWUNEQ0FDSUFFMkFnZ2dBQ0FEYWlFQVFRQWhBd0pBSUFRZ0FVRUFFQWtFUUNBQ1FRRTJBamdnQkNBQ1FRaHFJQUFnQUVFQlFRQWdCQ2dDQUNnQ0ZCRUhBQ0FBUVFBZ0FpZ0NJRUVCUmhzaEF3d0JDeUFFSUFKQkNHb2dBRUVCUVFBZ0JDZ0NBQ2dDR0JFRkFBSkFBa0FnQWlnQ0xBNENBQUVDQ3lBQ0tBSWNRUUFnQWlnQ0tFRUJSaHRCQUNBQ0tBSWtRUUZHRzBFQUlBSW9BakJCQVVZYklRTU1BUXNnQWlnQ0lFRUJSd1JBSUFJb0FqQU5BU0FDS0FJa1FRRkhEUUVnQWlnQ0tFRUJSdzBCQ3lBQ0tBSVlJUU1MSUFKQlFHc2tBQ0FEQ3dRQUlBQUxEZ0FnQUVIUUFHb1FKRUhRQUdvTG5DZ0JDMzhqQUVFUWF5SUxKQUFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjlBRk5CRUJCNkRNb0FnQWlCa0VRSUFCQkMycEJlSEVnQUVFTFNSc2lCVUVEZGlJQWRpSUJRUU54QkVBQ1FDQUJRWDl6UVFGeElBQnFJZ0pCQTNRaUFVR1FOR29pQUNBQlFaZzBhaWdDQUNJQktBSUlJZ1JHQkVCQjZETWdCa0YrSUFKM2NUWUNBQXdCQ3lBRUlBQTJBZ3dnQUNBRU5nSUlDeUFCUVFocUlRQWdBU0FDUVFOMElnSkJBM0kyQWdRZ0FTQUNhaUlCSUFFb0FnUkJBWEkyQWdRTUR3c2dCVUh3TXlnQ0FDSUhUUTBCSUFFRVFBSkFRUUlnQUhRaUFrRUFJQUpyY2lBQklBQjBjU0lBUVFBZ0FHdHhhQ0lCUVFOMElnQkJrRFJxSWdJZ0FFR1lOR29vQWdBaUFDZ0NDQ0lFUmdSQVFlZ3pJQVpCZmlBQmQzRWlCallDQUF3QkN5QUVJQUkyQWd3Z0FpQUVOZ0lJQ3lBQUlBVkJBM0kyQWdRZ0FDQUZhaUlJSUFGQkEzUWlBU0FGYXlJRVFRRnlOZ0lFSUFBZ0FXb2dCRFlDQUNBSEJFQWdCMEY0Y1VHUU5Hb2hBVUg4TXlnQ0FDRUNBbjhnQmtFQklBZEJBM1owSWdOeFJRUkFRZWd6SUFNZ0JuSTJBZ0FnQVF3QkN5QUJLQUlJQ3lFRElBRWdBallDQ0NBRElBSTJBZ3dnQWlBQk5nSU1JQUlnQXpZQ0NBc2dBRUVJYWlFQVFmd3pJQWcyQWdCQjhETWdCRFlDQUF3UEMwSHNNeWdDQUNJS1JRMEJJQXBCQUNBS2EzRm9RUUowUVpnMmFpZ0NBQ0lDS0FJRVFYaHhJQVZySVFNZ0FpRUJBMEFDUUNBQktBSVFJZ0JGQkVBZ0FTZ0NGQ0lBUlEwQkN5QUFLQUlFUVhoeElBVnJJZ0VnQXlBQklBTkpJZ0ViSVFNZ0FDQUNJQUViSVFJZ0FDRUJEQUVMQ3lBQ0tBSVlJUWtnQWlBQ0tBSU1JZ1JIQkVCQitETW9BZ0FhSUFJb0FnZ2lBQ0FFTmdJTUlBUWdBRFlDQ0F3T0N5QUNRUlJxSWdFb0FnQWlBRVVFUUNBQ0tBSVFJZ0JGRFFNZ0FrRVFhaUVCQ3dOQUlBRWhDQ0FBSWdSQkZHb2lBU2dDQUNJQURRQWdCRUVRYWlFQklBUW9BaEFpQUEwQUN5QUlRUUEyQWdBTURRdEJmeUVGSUFCQnYzOUxEUUFnQUVFTGFpSUFRWGh4SVFWQjdETW9BZ0FpQ0VVTkFFRUFJQVZySVFNQ1FBSkFBa0FDZjBFQUlBVkJnQUpKRFFBYVFSOGdCVUgvLy84SFN3MEFHaUFGUVNZZ0FFRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFDeUlIUVFKMFFaZzJhaWdDQUNJQlJRUkFRUUFoQUF3QkMwRUFJUUFnQlVFWklBZEJBWFpyUVFBZ0IwRWZSeHQwSVFJRFFBSkFJQUVvQWdSQmVIRWdCV3NpQmlBRFR3MEFJQUVoQkNBR0lnTU5BRUVBSVFNZ0FTRUFEQU1MSUFBZ0FTZ0NGQ0lHSUFZZ0FTQUNRUjEyUVFSeGFpZ0NFQ0lCUmhzZ0FDQUdHeUVBSUFKQkFYUWhBaUFCRFFBTEN5QUFJQVJ5UlFSQVFRQWhCRUVDSUFkMElnQkJBQ0FBYTNJZ0NIRWlBRVVOQXlBQVFRQWdBR3R4YUVFQ2RFR1lObW9vQWdBaEFBc2dBRVVOQVFzRFFDQUFLQUlFUVhoeElBVnJJZ0lnQTBraEFTQUNJQU1nQVJzaEF5QUFJQVFnQVJzaEJDQUFLQUlRSWdFRWZ5QUJCU0FBS0FJVUN5SUFEUUFMQ3lBRVJRMEFJQU5COERNb0FnQWdCV3RQRFFBZ0JDZ0NHQ0VISUFRZ0JDZ0NEQ0lDUndSQVFmZ3pLQUlBR2lBRUtBSUlJZ0FnQWpZQ0RDQUNJQUEyQWdnTURBc2dCRUVVYWlJQktBSUFJZ0JGQkVBZ0JDZ0NFQ0lBUlEwRElBUkJFR29oQVFzRFFDQUJJUVlnQUNJQ1FSUnFJZ0VvQWdBaUFBMEFJQUpCRUdvaEFTQUNLQUlRSWdBTkFBc2dCa0VBTmdJQURBc0xJQVZCOERNb0FnQWlCRTBFUUVIOE15Z0NBQ0VBQWtBZ0JDQUZheUlCUVJCUEJFQWdBQ0FGYWlJQ0lBRkJBWEkyQWdRZ0FDQUVhaUFCTmdJQUlBQWdCVUVEY2pZQ0JBd0JDeUFBSUFSQkEzSTJBZ1FnQUNBRWFpSUJJQUVvQWdSQkFYSTJBZ1JCQUNFQ1FRQWhBUXRCOERNZ0FUWUNBRUg4TXlBQ05nSUFJQUJCQ0dvaEFBd05DeUFGUWZRektBSUFJZ0pKQkVCQjlETWdBaUFGYXlJQk5nSUFRWUEwUVlBMEtBSUFJZ0FnQldvaUFqWUNBQ0FDSUFGQkFYSTJBZ1FnQUNBRlFRTnlOZ0lFSUFCQkNHb2hBQXdOQzBFQUlRQWdCVUV2YWlJREFuOUJ3RGNvQWdBRVFFSElOeWdDQUF3QkMwSE1OMEovTndJQVFjUTNRb0NnZ0lDQWdBUTNBZ0JCd0RjZ0MwRU1ha0Z3Y1VIWXF0V3FCWE0yQWdCQjFEZEJBRFlDQUVHa04wRUFOZ0lBUVlBZ0N5SUJhaUlHUVFBZ0FXc2lDSEVpQVNBRlRRME1RYUEzS0FJQUlnUUVRRUdZTnlnQ0FDSUhJQUZxSWdrZ0IwME5EU0FFSUFsSkRRMExBa0JCcERjdEFBQkJCSEZGQkVBQ1FBSkFBa0FDUUVHQU5DZ0NBQ0lFQkVCQnFEY2hBQU5BSUFRZ0FDZ0NBQ0lIVHdSQUlBY2dBQ2dDQkdvZ0JFc05Bd3NnQUNnQ0NDSUFEUUFMQzBFQUVBc2lBa0YvUmcwRElBRWhCa0hFTnlnQ0FDSUFRUUZySWdRZ0FuRUVRQ0FCSUFKcklBSWdCR3BCQUNBQWEzRnFJUVlMSUFVZ0JrOE5BMEdnTnlnQ0FDSUFCRUJCbURjb0FnQWlCQ0FHYWlJSUlBUk5EUVFnQUNBSVNRMEVDeUFHRUFzaUFDQUNSdzBCREFVTElBWWdBbXNnQ0hFaUJoQUxJZ0lnQUNnQ0FDQUFLQUlFYWtZTkFTQUNJUUFMSUFCQmYwWU5BU0FGUVRCcUlBWk5CRUFnQUNFQ0RBUUxRY2czS0FJQUlnSWdBeUFHYTJwQkFDQUNhM0VpQWhBTFFYOUdEUUVnQWlBR2FpRUdJQUFoQWd3REN5QUNRWDlIRFFJTFFhUTNRYVEzS0FJQVFRUnlOZ0lBQ3lBQkVBc2hBa0VBRUFzaEFDQUNRWDlHRFFVZ0FFRi9SZzBGSUFBZ0FrME5CU0FBSUFKcklnWWdCVUVvYWswTkJRdEJtRGRCbURjb0FnQWdCbW9pQURZQ0FFR2NOeWdDQUNBQVNRUkFRWnczSUFBMkFnQUxBa0JCZ0RRb0FnQWlBd1JBUWFnM0lRQURRQ0FDSUFBb0FnQWlBU0FBS0FJRUlnUnFSZzBDSUFBb0FnZ2lBQTBBQ3d3RUMwSDRNeWdDQUNJQVFRQWdBQ0FDVFJ0RkJFQkIrRE1nQWpZQ0FBdEJBQ0VBUWF3M0lBWTJBZ0JCcURjZ0FqWUNBRUdJTkVGL05nSUFRWXcwUWNBM0tBSUFOZ0lBUWJRM1FRQTJBZ0FEUUNBQVFRTjBJZ0ZCbURScUlBRkJrRFJxSWdRMkFnQWdBVUdjTkdvZ0JEWUNBQ0FBUVFGcUlnQkJJRWNOQUF0QjlETWdCa0VvYXlJQVFYZ2dBbXRCQjNGQkFDQUNRUWhxUVFkeEd5SUJheUlFTmdJQVFZQTBJQUVnQW1vaUFUWUNBQ0FCSUFSQkFYSTJBZ1FnQUNBQ2FrRW9OZ0lFUVlRMFFkQTNLQUlBTmdJQURBUUxJQUlnQTAwTkFpQUJJQU5MRFFJZ0FDZ0NERUVJY1EwQ0lBQWdCQ0FHYWpZQ0JFR0FOQ0FEUVhnZ0EydEJCM0ZCQUNBRFFRaHFRUWR4R3lJQWFpSUJOZ0lBUWZRelFmUXpLQUlBSUFacUlnSWdBR3NpQURZQ0FDQUJJQUJCQVhJMkFnUWdBaUFEYWtFb05nSUVRWVEwUWRBM0tBSUFOZ0lBREFNTFFRQWhCQXdLQzBFQUlRSU1DQXRCK0RNb0FnQWdBa3NFUUVINE15QUNOZ0lBQ3lBQ0lBWnFJUUZCcURjaEFBSkFBa0FDUUFOQUlBRWdBQ2dDQUVjRVFDQUFLQUlJSWdBTkFRd0NDd3NnQUMwQURFRUljVVVOQVF0QnFEY2hBQU5BSUFNZ0FDZ0NBQ0lCVHdSQUlBRWdBQ2dDQkdvaUJDQURTdzBEQ3lBQUtBSUlJUUFNQUFzQUN5QUFJQUkyQWdBZ0FDQUFLQUlFSUFacU5nSUVJQUpCZUNBQ2EwRUhjVUVBSUFKQkNHcEJCM0ViYWlJSElBVkJBM0kyQWdRZ0FVRjRJQUZyUVFkeFFRQWdBVUVJYWtFSGNSdHFJZ1lnQlNBSGFpSUZheUVBSUFNZ0JrWUVRRUdBTkNBRk5nSUFRZlF6UWZRektBSUFJQUJxSWdBMkFnQWdCU0FBUVFGeU5nSUVEQWdMUWZ3ektBSUFJQVpHQkVCQi9ETWdCVFlDQUVId00wSHdNeWdDQUNBQWFpSUFOZ0lBSUFVZ0FFRUJjallDQkNBQUlBVnFJQUEyQWdBTUNBc2dCaWdDQkNJRFFRTnhRUUZIRFFZZ0EwRjRjU0VKSUFOQi93Rk5CRUFnQmlnQ0RDSUJJQVlvQWdnaUFrWUVRRUhvTTBIb015Z0NBRUYrSUFOQkEzWjNjVFlDQUF3SEN5QUNJQUUyQWd3Z0FTQUNOZ0lJREFZTElBWW9BaGdoQ0NBR0lBWW9BZ3dpQWtjRVFDQUdLQUlJSWdFZ0FqWUNEQ0FDSUFFMkFnZ01CUXNnQmtFVWFpSUJLQUlBSWdORkJFQWdCaWdDRUNJRFJRMEVJQVpCRUdvaEFRc0RRQ0FCSVFRZ0F5SUNRUlJxSWdFb0FnQWlBdzBBSUFKQkVHb2hBU0FDS0FJUUlnTU5BQXNnQkVFQU5nSUFEQVFMUWZReklBWkJLR3NpQUVGNElBSnJRUWR4UVFBZ0FrRUlha0VIY1JzaUFXc2lDRFlDQUVHQU5DQUJJQUpxSWdFMkFnQWdBU0FJUVFGeU5nSUVJQUFnQW1wQktEWUNCRUdFTkVIUU55Z0NBRFlDQUNBRElBUkJKeUFFYTBFSGNVRUFJQVJCSjJ0QkIzRWJha0V2YXlJQUlBQWdBMEVRYWtrYklnRkJHellDQkNBQlFiQTNLUUlBTndJUUlBRkJxRGNwQWdBM0FnaEJzRGNnQVVFSWFqWUNBRUdzTnlBR05nSUFRYWczSUFJMkFnQkJ0RGRCQURZQ0FDQUJRUmhxSVFBRFFDQUFRUWMyQWdRZ0FFRUlhaUVDSUFCQkJHb2hBQ0FDSUFSSkRRQUxJQUVnQTBZTkFDQUJJQUVvQWdSQmZuRTJBZ1FnQXlBQklBTnJJZ0pCQVhJMkFnUWdBU0FDTmdJQUlBSkIvd0ZOQkVBZ0FrRjRjVUdRTkdvaEFBSi9RZWd6S0FJQUlnRkJBU0FDUVFOMmRDSUNjVVVFUUVIb015QUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hBU0FBSUFNMkFnZ2dBU0FETmdJTUlBTWdBRFlDRENBRElBRTJBZ2dNQVF0Qkh5RUFJQUpCLy8vL0IwMEVRQ0FDUVNZZ0FrRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUUFMSUFNZ0FEWUNIQ0FEUWdBM0FoQWdBRUVDZEVHWU5tb2hBUUpBQWtCQjdETW9BZ0FpQkVFQklBQjBJZ1p4UlFSQVFld3pJQVFnQm5JMkFnQWdBU0FETmdJQURBRUxJQUpCR1NBQVFRRjJhMEVBSUFCQkgwY2JkQ0VBSUFFb0FnQWhCQU5BSUFRaUFTZ0NCRUY0Y1NBQ1JnMENJQUJCSFhZaEJDQUFRUUYwSVFBZ0FTQUVRUVJ4YWlJR0tBSVFJZ1FOQUFzZ0JpQUROZ0lRQ3lBRElBRTJBaGdnQXlBRE5nSU1JQU1nQXpZQ0NBd0JDeUFCS0FJSUlnQWdBellDRENBQklBTTJBZ2dnQTBFQU5nSVlJQU1nQVRZQ0RDQURJQUEyQWdnTFFmUXpLQUlBSWdBZ0JVME5BRUgwTXlBQUlBVnJJZ0UyQWdCQmdEUkJnRFFvQWdBaUFDQUZhaUlDTmdJQUlBSWdBVUVCY2pZQ0JDQUFJQVZCQTNJMkFnUWdBRUVJYWlFQURBZ0xRYWd5UVRBMkFnQkJBQ0VBREFjTFFRQWhBZ3NnQ0VVTkFBSkFJQVlvQWh3aUFVRUNkRUdZTm1vaUJDZ0NBQ0FHUmdSQUlBUWdBallDQUNBQ0RRRkI3RE5CN0RNb0FnQkJmaUFCZDNFMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBR1JodHFJQUkyQWdBZ0FrVU5BUXNnQWlBSU5nSVlJQVlvQWhBaUFRUkFJQUlnQVRZQ0VDQUJJQUkyQWhnTElBWW9BaFFpQVVVTkFDQUNJQUUyQWhRZ0FTQUNOZ0lZQ3lBQUlBbHFJUUFnQmlBSmFpSUdLQUlFSVFNTElBWWdBMEYrY1RZQ0JDQUZJQUJCQVhJMkFnUWdBQ0FGYWlBQU5nSUFJQUJCL3dGTkJFQWdBRUY0Y1VHUU5Hb2hBUUovUWVnektBSUFJZ0pCQVNBQVFRTjJkQ0lBY1VVRVFFSG9NeUFBSUFKeU5nSUFJQUVNQVFzZ0FTZ0NDQXNoQUNBQklBVTJBZ2dnQUNBRk5nSU1JQVVnQVRZQ0RDQUZJQUEyQWdnTUFRdEJIeUVESUFCQi8vLy9CMDBFUUNBQVFTWWdBRUVJZG1jaUFXdDJRUUZ4SUFGQkFYUnJRVDVxSVFNTElBVWdBellDSENBRlFnQTNBaEFnQTBFQ2RFR1lObW9oQVFKQUFrQkI3RE1vQWdBaUFrRUJJQU4wSWdSeFJRUkFRZXd6SUFJZ0JISTJBZ0FnQVNBRk5nSUFEQUVMSUFCQkdTQURRUUYyYTBFQUlBTkJIMGNiZENFRElBRW9BZ0FoQWdOQUlBSWlBU2dDQkVGNGNTQUFSZzBDSUFOQkhYWWhBaUFEUVFGMElRTWdBU0FDUVFSeGFpSUVLQUlRSWdJTkFBc2dCQ0FGTmdJUUN5QUZJQUUyQWhnZ0JTQUZOZ0lNSUFVZ0JUWUNDQXdCQ3lBQktBSUlJZ0FnQlRZQ0RDQUJJQVUyQWdnZ0JVRUFOZ0lZSUFVZ0FUWUNEQ0FGSUFBMkFnZ0xJQWRCQ0dvaEFBd0NDd0pBSUFkRkRRQUNRQ0FFS0FJY0lnQkJBblJCbURacUlnRW9BZ0FnQkVZRVFDQUJJQUkyQWdBZ0FnMEJRZXd6SUFoQmZpQUFkM0VpQ0RZQ0FBd0NDeUFIUVJCQkZDQUhLQUlRSUFSR0cyb2dBallDQUNBQ1JRMEJDeUFDSUFjMkFoZ2dCQ2dDRUNJQUJFQWdBaUFBTmdJUUlBQWdBallDR0FzZ0JDZ0NGQ0lBUlEwQUlBSWdBRFlDRkNBQUlBSTJBaGdMQWtBZ0EwRVBUUVJBSUFRZ0F5QUZhaUlBUVFOeU5nSUVJQUFnQkdvaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFRZ0JVRURjallDQkNBRUlBVnFJZ0lnQTBFQmNqWUNCQ0FDSUFOcUlBTTJBZ0FnQTBIL0FVMEVRQ0FEUVhoeFFaQTBhaUVBQW45QjZETW9BZ0FpQVVFQklBTkJBM1owSWdOeFJRUkFRZWd6SUFFZ0EzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFQklBQWdBallDQ0NBQklBSTJBZ3dnQWlBQU5nSU1JQUlnQVRZQ0NBd0JDMEVmSVFBZ0EwSC8vLzhIVFFSQUlBTkJKaUFEUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFBc2dBaUFBTmdJY0lBSkNBRGNDRUNBQVFRSjBRWmcyYWlFQkFrQUNRQ0FJUVFFZ0FIUWlCbkZGQkVCQjdETWdCaUFJY2pZQ0FDQUJJQUkyQWdBTUFRc2dBMEVaSUFCQkFYWnJRUUFnQUVFZlJ4dDBJUUFnQVNnQ0FDRUZBMEFnQlNJQktBSUVRWGh4SUFOR0RRSWdBRUVkZGlFR0lBQkJBWFFoQUNBQklBWkJCSEZxSWdZb0FoQWlCUTBBQ3lBR0lBSTJBaEFMSUFJZ0FUWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBRUxJQUVvQWdnaUFDQUNOZ0lNSUFFZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFCTmdJTUlBSWdBRFlDQ0FzZ0JFRUlhaUVBREFFTEFrQWdDVVVOQUFKQUlBSW9BaHdpQUVFQ2RFR1lObW9pQVNnQ0FDQUNSZ1JBSUFFZ0JEWUNBQ0FFRFFGQjdETWdDa0YrSUFCM2NUWUNBQXdDQ3lBSlFSQkJGQ0FKS0FJUUlBSkdHMm9nQkRZQ0FDQUVSUTBCQ3lBRUlBazJBaGdnQWlnQ0VDSUFCRUFnQkNBQU5nSVFJQUFnQkRZQ0dBc2dBaWdDRkNJQVJRMEFJQVFnQURZQ0ZDQUFJQVEyQWhnTEFrQWdBMEVQVFFSQUlBSWdBeUFGYWlJQVFRTnlOZ0lFSUFBZ0Ftb2lBQ0FBS0FJRVFRRnlOZ0lFREFFTElBSWdCVUVEY2pZQ0JDQUNJQVZxSWdRZ0EwRUJjallDQkNBRElBUnFJQU0yQWdBZ0J3UkFJQWRCZUhGQmtEUnFJUUJCL0RNb0FnQWhBUUovUVFFZ0IwRURkblFpQlNBR2NVVUVRRUhvTXlBRklBWnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEJpQUFJQUUyQWdnZ0JpQUJOZ0lNSUFFZ0FEWUNEQ0FCSUFZMkFnZ0xRZnd6SUFRMkFnQkI4RE1nQXpZQ0FBc2dBa0VJYWlFQUN5QUxRUkJxSkFBZ0FBdVhBZ0FnQUVVRVFFRUFEd3NDZndKQUlBQUVmeUFCUWY4QVRRMEJBa0JCeERNb0FnQW9BZ0JGQkVBZ0FVR0FmM0ZCZ0w4RFJnMEREQUVMSUFGQi93OU5CRUFnQUNBQlFUOXhRWUFCY2pvQUFTQUFJQUZCQm5aQndBRnlPZ0FBUVFJTUJBc2dBVUdBUUhGQmdNQURSeUFCUVlDd0EwOXhSUVJBSUFBZ0FVRS9jVUdBQVhJNkFBSWdBQ0FCUVF4MlFlQUJjam9BQUNBQUlBRkJCblpCUDNGQmdBRnlPZ0FCUVFNTUJBc2dBVUdBZ0FSclFmLy9QMDBFUUNBQUlBRkJQM0ZCZ0FGeU9nQURJQUFnQVVFU2RrSHdBWEk2QUFBZ0FDQUJRUVoyUVQ5eFFZQUJjam9BQWlBQUlBRkJESFpCUDNGQmdBRnlPZ0FCUVFRTUJBc0xRYWd5UVJrMkFnQkJmd1ZCQVFzTUFRc2dBQ0FCT2dBQVFRRUxDNVlZQXhKL0FYd0NmaU1BUWJBRWF5SU1KQUFnREVFQU5nSXNBa0FnQWIwaUdVSUFVd1JBUVFFaEVFR0tDQ0VUSUFHYUlnRzlJUmtNQVFzZ0JFR0FFSEVFUUVFQklSQkJqUWdoRXd3QkMwR1FDRUdMQ0NBRVFRRnhJaEFiSVJNZ0VFVWhGUXNDUUNBWlFvQ0FnSUNBZ0lENC93Q0RRb0NBZ0lDQWdJRDQvd0JSQkVBZ0FFRWdJQUlnRUVFRGFpSURJQVJCLy85N2NSQUdJQUFnRXlBUUVBVWdBRUd6Q0VIMkNDQUZRU0J4SWdVYlFjd0lRZm9JSUFVYklBRWdBV0liUVFNUUJTQUFRU0FnQWlBRElBUkJnTUFBY3hBR0lBTWdBaUFDSUFOSUd5RUpEQUVMSUF4QkVHb2hFUUpBQW44Q1FDQUJJQXhCTEdvUUtpSUJJQUdnSWdGRUFBQUFBQUFBQUFCaUJFQWdEQ0FNS0FJc0lnWkJBV3MyQWl3Z0JVRWdjaUlPUWVFQVJ3MEJEQU1MSUFWQklISWlEa0hoQUVZTkFpQU1LQUlzSVFwQkJpQURJQU5CQUVnYkRBRUxJQXdnQmtFZGF5SUtOZ0lzSUFGRUFBQUFBQUFBc0VHaUlRRkJCaUFESUFOQkFFZ2JDeUVMSUF4Qk1HcEJvQUpCQUNBS1FRQk9HMm9pRFNFSEEwQWdCd0ovSUFGRUFBQUFBQUFBOEVGaklBRkVBQUFBQUFBQUFBQm1jUVJBSUFHckRBRUxRUUFMSWdNMkFnQWdCMEVFYWlFSElBRWdBN2loUkFBQUFBQmx6YzFCb2lJQlJBQUFBQUFBQUFBQVlnMEFDd0pBSUFwQkFFd0VRQ0FLSVFNZ0J5RUdJQTBoQ0F3QkN5QU5JUWdnQ2lFREEwQkJIU0FESUFOQkhVNGJJUU1DUUNBSFFRUnJJZ1lnQ0VrTkFDQURyU0VhUWdBaEdRTkFJQVlnR1VMLy8vLy9ENE1nQmpVQ0FDQWFobndpR1NBWlFvQ1U2OXdEZ0NJWlFvQ1U2OXdEZm4wK0FnQWdCa0VFYXlJR0lBaFBEUUFMSUJtbklnWkZEUUFnQ0VFRWF5SUlJQVkyQWdBTEEwQWdDQ0FISWdaSkJFQWdCa0VFYXlJSEtBSUFSUTBCQ3dzZ0RDQU1LQUlzSUFOcklnTTJBaXdnQmlFSElBTkJBRW9OQUFzTElBTkJBRWdFUUNBTFFSbHFRUWx1UVFGcUlROGdEa0htQUVZaEVnTkFRUWxCQUNBRGF5SURJQU5CQ1U0YklRa0NRQ0FHSUFoTkJFQWdDQ2dDQUNFSERBRUxRWUNVNjl3RElBbDJJUlJCZnlBSmRFRi9jeUVXUVFBaEF5QUlJUWNEUUNBSElBTWdCeWdDQUNJWElBbDJhallDQUNBV0lCZHhJQlJzSVFNZ0IwRUVhaUlISUFaSkRRQUxJQWdvQWdBaEJ5QURSUTBBSUFZZ0F6WUNBQ0FHUVFScUlRWUxJQXdnRENnQ0xDQUphaUlETmdJc0lBMGdDQ0FIUlVFQ2RHb2lDQ0FTR3lJSElBOUJBblJxSUFZZ0JpQUhhMEVDZFNBUFNoc2hCaUFEUVFCSURRQUxDMEVBSVFNQ1FDQUdJQWhORFFBZ0RTQUlhMEVDZFVFSmJDRURRUW9oQnlBSUtBSUFJZ2xCQ2trTkFBTkFJQU5CQVdvaEF5QUpJQWRCQ213aUIwOE5BQXNMSUFzZ0EwRUFJQTVCNWdCSEcyc2dEa0huQUVZZ0MwRUFSM0ZySWdjZ0JpQU5hMEVDZFVFSmJFRUphMGdFUUVFRVFhUUNJQXBCQUVnYklBeHFJQWRCZ01nQWFpSUpRUWx0SWc5QkFuUnFRZEFmYXlFS1FRb2hCeUFKSUE5QkNXeHJJZ2xCQjB3RVFBTkFJQWRCQ213aEJ5QUpRUUZxSWdsQkNFY05BQXNMQWtBZ0NpZ0NBQ0lTSUJJZ0IyNGlEeUFIYkdzaUNVVWdDa0VFYWlJVUlBWkdjUTBBQWtBZ0QwRUJjVVVFUUVRQUFBQUFBQUJBUXlFQklBZEJnSlRyM0FOSERRRWdDQ0FLVHcwQklBcEJCR3N0QUFCQkFYRkZEUUVMUkFFQUFBQUFBRUJESVFFTFJBQUFBQUFBQU9BL1JBQUFBQUFBQVBBL1JBQUFBQUFBQVBnL0lBWWdGRVliUkFBQUFBQUFBUGcvSUFrZ0IwRUJkaUlVUmhzZ0NTQVVTUnNoR0FKQUlCVU5BQ0FUTFFBQVFTMUhEUUFnR0pvaEdDQUJtaUVCQ3lBS0lCSWdDV3NpQ1RZQ0FDQUJJQmlnSUFGaERRQWdDaUFISUFscUlnTTJBZ0FnQTBHQWxPdmNBMDhFUUFOQUlBcEJBRFlDQUNBSUlBcEJCR3NpQ2tzRVFDQUlRUVJySWdoQkFEWUNBQXNnQ2lBS0tBSUFRUUZxSWdNMkFnQWdBMEgvayt2Y0Ewc05BQXNMSUEwZ0NHdEJBblZCQ1d3aEEwRUtJUWNnQ0NnQ0FDSUpRUXBKRFFBRFFDQURRUUZxSVFNZ0NTQUhRUXBzSWdkUERRQUxDeUFLUVFScUlnY2dCaUFHSUFkTEd5RUdDd05BSUFZaUJ5QUlUU0lKUlFSQUlBZEJCR3NpQmlnQ0FFVU5BUXNMQWtBZ0RrSG5BRWNFUUNBRVFRaHhJUW9NQVFzZ0EwRi9jMEYvSUF0QkFTQUxHeUlHSUFOS0lBTkJlMHB4SWdvYklBWnFJUXRCZjBGK0lBb2JJQVZxSVFVZ0JFRUljU0lLRFFCQmR5RUdBa0FnQ1EwQUlBZEJCR3NvQWdBaURrVU5BRUVLSVFsQkFDRUdJQTVCQ25BTkFBTkFJQVlpQ2tFQmFpRUdJQTRnQ1VFS2JDSUpjRVVOQUFzZ0NrRi9jeUVHQ3lBSElBMXJRUUoxUVFsc0lRa2dCVUZmY1VIR0FFWUVRRUVBSVFvZ0N5QUdJQWxxUVFscklnWkJBQ0FHUVFCS0d5SUdJQVlnQzBvYklRc01BUXRCQUNFS0lBc2dBeUFKYWlBR2FrRUpheUlHUVFBZ0JrRUFTaHNpQmlBR0lBdEtHeUVMQzBGL0lRa2dDMEg5Ly8vL0IwSCsvLy8vQnlBS0lBdHlJaEliU2cwQklBc2dFa0VBUjJwQkFXb2hEZ0pBSUFWQlgzRWlGVUhHQUVZRVFDQURJQTVCLy8vLy93ZHpTZzBESUFOQkFDQURRUUJLR3lFR0RBRUxJQkVnQXlBRFFSOTFJZ1p6SUFacnJTQVJFQXdpQm10QkFVd0VRQU5BSUFaQkFXc2lCa0V3T2dBQUlCRWdCbXRCQWtnTkFBc0xJQVpCQW1zaUR5QUZPZ0FBSUFaQkFXdEJMVUVySUFOQkFFZ2JPZ0FBSUJFZ0Qyc2lCaUFPUWYvLy8vOEhjMG9OQWdzZ0JpQU9haUlESUJCQi8vLy8vd2R6U2cwQklBQkJJQ0FDSUFNZ0VHb2lCU0FFRUFZZ0FDQVRJQkFRQlNBQVFUQWdBaUFGSUFSQmdJQUVjeEFHQWtBQ1FBSkFJQlZCeGdCR0JFQWdERUVRYWlJR1FRaHlJUU1nQmtFSmNpRUtJQTBnQ0NBSUlBMUxHeUlKSVFnRFFDQUlOUUlBSUFvUURDRUdBa0FnQ0NBSlJ3UkFJQVlnREVFUWFrME5BUU5BSUFaQkFXc2lCa0V3T2dBQUlBWWdERUVRYWtzTkFBc01BUXNnQmlBS1J3MEFJQXhCTURvQUdDQURJUVlMSUFBZ0JpQUtJQVpyRUFVZ0NFRUVhaUlJSUExTkRRQUxJQklFUUNBQVFmNElRUUVRQlFzZ0J5QUlUUTBCSUF0QkFFd05BUU5BSUFnMUFnQWdDaEFNSWdZZ0RFRVFha3NFUUFOQUlBWkJBV3NpQmtFd09nQUFJQVlnREVFUWFrc05BQXNMSUFBZ0JrRUpJQXNnQzBFSlRoc1FCU0FMUVFscklRWWdDRUVFYWlJSUlBZFBEUU1nQzBFSlNpRURJQVloQ3lBRERRQUxEQUlMQWtBZ0MwRUFTQTBBSUFjZ0NFRUVhaUFISUFoTEd5RUpJQXhCRUdvaUJrRUljaUVESUFaQkNYSWhEU0FJSVFjRFFDQU5JQWMxQWdBZ0RSQU1JZ1pHQkVBZ0RFRXdPZ0FZSUFNaEJnc0NRQ0FISUFoSEJFQWdCaUFNUVJCcVRRMEJBMEFnQmtFQmF5SUdRVEE2QUFBZ0JpQU1RUkJxU3cwQUN3d0JDeUFBSUFaQkFSQUZJQVpCQVdvaEJpQUtJQXR5UlEwQUlBQkIvZ2hCQVJBRkN5QUFJQVlnRFNBR2F5SUdJQXNnQmlBTFNCc1FCU0FMSUFacklRc2dCMEVFYWlJSElBbFBEUUVnQzBFQVRnMEFDd3NnQUVFd0lBdEJFbXBCRWtFQUVBWWdBQ0FQSUJFZ0Qyc1FCUXdDQ3lBTElRWUxJQUJCTUNBR1FRbHFRUWxCQUJBR0N5QUFRU0FnQWlBRklBUkJnTUFBY3hBR0lBVWdBaUFDSUFWSUd5RUpEQUVMSUJNZ0JVRWFkRUVmZFVFSmNXb2hDQUpBSUFOQkMwc05BRUVNSUFOcklRWkVBQUFBQUFBQU1FQWhHQU5BSUJoRUFBQUFBQUFBTUVDaUlSZ2dCa0VCYXlJR0RRQUxJQWd0QUFCQkxVWUVRQ0FZSUFHYUlCaWhvSm9oQVF3QkN5QUJJQmlnSUJpaElRRUxJQkVnRENnQ0xDSUdJQVpCSDNVaUJuTWdCbXV0SUJFUURDSUdSZ1JBSUF4Qk1Eb0FEeUFNUVE5cUlRWUxJQkJCQW5JaEN5QUZRU0J4SVEwZ0RDZ0NMQ0VISUFaQkFtc2lDaUFGUVE5cU9nQUFJQVpCQVd0QkxVRXJJQWRCQUVnYk9nQUFJQVJCQ0hFaEJpQU1RUkJxSVFjRFFDQUhJZ1VDZnlBQm1VUUFBQUFBQUFEZ1FXTUVRQ0FCcWd3QkMwR0FnSUNBZUFzaUIwSGdJMm90QUFBZ0RYSTZBQUFnQVNBSHQ2RkVBQUFBQUFBQU1FQ2lJUUVDUUNBRlFRRnFJZ2NnREVFUWFtdEJBVWNOQUFKQUlBWU5BQ0FEUVFCS0RRQWdBVVFBQUFBQUFBQUFBR0VOQVFzZ0JVRXVPZ0FCSUFWQkFtb2hCd3NnQVVRQUFBQUFBQUFBQUdJTkFBdEJmeUVKUWYzLy8vOEhJQXNnRVNBS2F5SUdhaUlOYXlBRFNBMEFJQUJCSUNBQ0lBMGdBMEVDYWlBSElBeEJFR29pQjJzaUJTQUZRUUpySUFOSUd5QUZJQU1iSWdscUlnTWdCQkFHSUFBZ0NDQUxFQVVnQUVFd0lBSWdBeUFFUVlDQUJITVFCaUFBSUFjZ0JSQUZJQUJCTUNBSklBVnJRUUJCQUJBR0lBQWdDaUFHRUFVZ0FFRWdJQUlnQXlBRVFZREFBSE1RQmlBRElBSWdBaUFEU0JzaENRc2dERUd3Qkdva0FDQUpDN1FDQUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBVUVKYXc0U0FBZ0pDZ2dKQVFJREJBb0pDZ29JQ1FVR0J3c2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJLQUlBTmdJQUR3c2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJNZ0VBTndNQUR3c2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJNd0VBTndNQUR3c2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJNQUFBTndNQUR3c2dBaUFDS0FJQUlnRkJCR28yQWdBZ0FDQUJNUUFBTndNQUR3c2dBaUFDS0FJQVFRZHFRWGh4SWdGQkNHbzJBZ0FnQUNBQkt3TUFPUU1BRHdzQUN3OExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVFFDQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVFVDQURjREFBOExJQUlnQWlnQ0FFRUhha0Y0Y1NJQlFRaHFOZ0lBSUFBZ0FTa0RBRGNEQUF0eUFRTi9JQUFvQWdBc0FBQkJNR3RCQ2s4RVFFRUFEd3NEUUNBQUtBSUFJUU5CZnlFQklBSkJ6Sm16NWdCTkJFQkJmeUFETEFBQVFUQnJJZ0VnQWtFS2JDSUNhaUFCSUFKQi8vLy8vd2R6U2hzaEFRc2dBQ0FEUVFGcU5nSUFJQUVoQWlBRExBQUJRVEJyUVFwSkRRQUxJQUlMa1JRQ0UzOEJma0dIQ1NFTEl3QkIwQUJySWdVa0FDQUZRWWNKTmdKTUlBVkJOMm9oRlNBRlFUaHFJUkFDUUFKQUFrQUNRQU5BSUFzaENpQUVJQXhCLy8vLy93ZHpTZzBCSUFRZ0RHb2hEQUpBQWtBQ1FDQUtJZ1F0QUFBaUJnUkFBMEFDUUFKQUlBWkIvd0Z4SWd0RkJFQWdCQ0VMREFFTElBdEJKVWNOQVNBRUlRWURRQ0FHTFFBQlFTVkhCRUFnQmlFTERBSUxJQVJCQVdvaEJDQUdMUUFDSVFjZ0JrRUNhaUlMSVFZZ0IwRWxSZzBBQ3dzZ0JDQUtheUlFSUF4Qi8vLy8vd2R6SWhaS0RRY2dBQVJBSUFBZ0NpQUVFQVVMSUFRTkJpQUZJQXMyQWt3Z0MwRUJhaUVFUVg4aERRSkFJQXNzQUFGQk1HdEJDazhOQUNBTExRQUNRU1JIRFFBZ0MwRURhaUVFSUFzc0FBRkJNR3NoRFVFQklSRUxJQVVnQkRZQ1RFRUFJUWdDUUNBRUxBQUFJZ1pCSUdzaUMwRWZTd1JBSUFRaEJ3d0JDeUFFSVFkQkFTQUxkQ0lMUVluUkJIRkZEUUFEUUNBRklBUkJBV29pQnpZQ1RDQUlJQXR5SVFnZ0JDd0FBU0lHUVNCcklndEJJRThOQVNBSElRUkJBU0FMZENJTFFZblJCSEVOQUFzTEFrQWdCa0VxUmdSQUFuOENRQ0FITEFBQlFUQnJRUXBQRFFBZ0J5MEFBa0VrUncwQUlBY3NBQUZCQW5RZ0EycEJ3QUZyUVFvMkFnQWdCMEVEYWlFR1FRRWhFU0FITEFBQlFRTjBJQUpxUVlBRGF5Z0NBQXdCQ3lBUkRRWWdCMEVCYWlFR0lBQkZCRUFnQlNBR05nSk1RUUFoRVVFQUlRNE1Bd3NnQVNBQktBSUFJZ1JCQkdvMkFnQkJBQ0VSSUFRb0FnQUxJUTRnQlNBR05nSk1JQTVCQUU0TkFVRUFJQTVySVE0Z0NFR0F3QUJ5SVFnTUFRc2dCVUhNQUdvUUtDSU9RUUJJRFFnZ0JTZ0NUQ0VHQzBFQUlRUkJmeUVKQW44Z0JpMEFBRUV1UndSQUlBWWhDMEVBREFFTElBWXRBQUZCS2tZRVFBSi9Ba0FnQml3QUFrRXdhMEVLVHcwQUlBWXRBQU5CSkVjTkFDQUdMQUFDUVFKMElBTnFRY0FCYTBFS05nSUFJQVpCQkdvaEN5QUdMQUFDUVFOMElBSnFRWUFEYXlnQ0FBd0JDeUFSRFFZZ0JrRUNhaUVMUVFBZ0FFVU5BQm9nQVNBQktBSUFJZ2RCQkdvMkFnQWdCeWdDQUFzaENTQUZJQXMyQWt3Z0NVRi9jMEVmZGd3QkN5QUZJQVpCQVdvMkFrd2dCVUhNQUdvUUtDRUpJQVVvQWt3aEMwRUJDeUVTQTBBZ0JDRVBRUndoQnlBTEloUXNBQUFpQkVIN0FHdEJSa2tOQ1NBVVFRRnFJUXNnQkNBUFFUcHNha0hQSDJvdEFBQWlCRUVCYTBFSVNRMEFDeUFGSUFzMkFrd0NRQUpBSUFSQkcwY0VRQ0FFUlEwTElBMUJBRTRFUUNBRElBMUJBblJxSUFRMkFnQWdCU0FDSUExQkEzUnFLUU1BTndOQURBSUxJQUJGRFFnZ0JVRkFheUFFSUFFUUp3d0NDeUFOUVFCT0RRb0xRUUFoQkNBQVJRMEhDeUFJUWYvL2UzRWlCaUFJSUFoQmdNQUFjUnNoQ0VFQUlRMUJnQWdoRXlBUUlRY0NRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBVUxBQUFJZ1JCWDNFZ0JDQUVRUTl4UVFOR0d5QUVJQThiSWdSQjJBQnJEaUVFRkJRVUZCUVVGQlFPRkE4R0RnNE9GQVlVRkJRVUFnVURGQlFKRkFFVUZBUUFDd0pBSUFSQndRQnJEZ2NPRkFzVURnNE9BQXNnQkVIVEFFWU5DUXdUQ3lBRktRTkFJUmRCZ0FnTUJRdEJBQ0VFQWtBQ1FBSkFBa0FDUUFKQUFrQWdEMEgvQVhFT0NBQUJBZ01FR2dVR0dnc2dCU2dDUUNBTU5nSUFEQmtMSUFVb0FrQWdERFlDQUF3WUN5QUZLQUpBSUF5c053TUFEQmNMSUFVb0FrQWdERHNCQUF3V0N5QUZLQUpBSUF3NkFBQU1GUXNnQlNnQ1FDQU1OZ0lBREJRTElBVW9Ba0FnREt3M0F3QU1Fd3RCQ0NBSklBbEJDRTBiSVFrZ0NFRUljaUVJUWZnQUlRUUxJQkFoQ2lBRktRTkFJaGRDQUZJRVFDQUVRU0J4SVFZRFFDQUtRUUZySWdvZ0Y2ZEJEM0ZCNENOcUxRQUFJQVp5T2dBQUlCZENEMVloRHlBWFFnU0lJUmNnRHcwQUN3c2dCU2tEUUZBTkF5QUlRUWh4UlEwRElBUkJCSFpCZ0FocUlSTkJBaUVOREFNTElCQWhCQ0FGS1FOQUloZENBRklFUUFOQUlBUkJBV3NpQkNBWHAwRUhjVUV3Y2pvQUFDQVhRZ2RXSVFvZ0YwSURpQ0VYSUFvTkFBc0xJQVFoQ2lBSVFRaHhSUTBDSUFrZ0VDQUtheUlFUVFGcUlBUWdDVWdiSVFrTUFnc2dCU2tEUUNJWFFnQlRCRUFnQlVJQUlCZDlJaGMzQTBCQkFTRU5RWUFJREFFTElBaEJnQkJ4QkVCQkFTRU5RWUVJREFFTFFZSUlRWUFJSUFoQkFYRWlEUnNMSVJNZ0Z5QVFFQXdoQ2dzZ0VrRUFJQWxCQUVnYkRRNGdDRUgvLzN0eElBZ2dFaHNoQ0FKQUlBVXBBMEFpRjBJQVVnMEFJQWtOQUNBUUlRcEJBQ0VKREF3TElBa2dGMUFnRUNBS2Eyb2lCQ0FFSUFsSUd5RUpEQXNMQW45Qi8vLy8vd2NnQ1NBSlFmLy8vLzhIVHhzaUR5SUhRUUJISVFnQ1FBSkFBa0FnQlNnQ1FDSUVRWUFKSUFRYklnb2lCRUVEY1VVTkFDQUhSUTBBQTBBZ0JDMEFBRVVOQWlBSFFRRnJJZ2RCQUVjaENDQUVRUUZxSWdSQkEzRkZEUUVnQncwQUN3c2dDRVVOQVFKQUlBUXRBQUJGRFFBZ0IwRUVTUTBBQTBBZ0JDZ0NBQ0lJUVg5eklBaEJnWUtFQ0d0eFFZQ0Jnb1I0Y1EwQ0lBUkJCR29oQkNBSFFRUnJJZ2RCQTBzTkFBc0xJQWRGRFFFTEEwQWdCQ0FFTFFBQVJRMENHaUFFUVFGcUlRUWdCMEVCYXlJSERRQUxDMEVBQ3lJRUlBcHJJQThnQkJzaUJDQUthaUVISUFsQkFFNEVRQ0FHSVFnZ0JDRUpEQXNMSUFZaENDQUVJUWtnQnkwQUFBME5EQW9MSUFrRVFDQUZLQUpBREFJTFFRQWhCQ0FBUVNBZ0RrRUFJQWdRQmd3Q0N5QUZRUUEyQWd3Z0JTQUZLUU5BUGdJSUlBVWdCVUVJYWlJRU5nSkFRWDhoQ1NBRUN5RUdRUUFoQkFKQUEwQWdCaWdDQUNJS1JRMEJBa0FnQlVFRWFpQUtFQ1VpQ2tFQVNDSUhEUUFnQ2lBSklBUnJTdzBBSUFaQkJHb2hCaUFFSUFwcUlnUWdDVWtOQVF3Q0N3c2dCdzBOQzBFOUlRY2dCRUVBU0EwTElBQkJJQ0FPSUFRZ0NCQUdJQVJGQkVCQkFDRUVEQUVMUVFBaEJ5QUZLQUpBSVFZRFFDQUdLQUlBSWdwRkRRRWdCVUVFYWlBS0VDVWlDaUFIYWlJSElBUkxEUUVnQUNBRlFRUnFJQW9RQlNBR1FRUnFJUVlnQkNBSFN3MEFDd3NnQUVFZ0lBNGdCQ0FJUVlEQUFITVFCaUFPSUFRZ0JDQU9TQnNoQkF3SUN5QVNRUUFnQ1VFQVNCc05DRUU5SVFjZ0FDQUZLd05BSUE0Z0NTQUlJQVFRSmlJRVFRQk9EUWNNQ1FzZ0JTQUZLUU5BUEFBM1FRRWhDU0FWSVFvZ0JpRUlEQVFMSUFRdEFBRWhCaUFFUVFGcUlRUU1BQXNBQ3lBQURRY2dFVVVOQWtFQklRUURRQ0FESUFSQkFuUnFLQUlBSWdBRVFDQUNJQVJCQTNScUlBQWdBUkFuUVFFaERDQUVRUUZxSWdSQkNrY05BUXdKQ3d0QkFTRU1JQVJCQ2s4TkJ3TkFJQU1nQkVFQ2RHb29BZ0FOQVNBRVFRRnFJZ1JCQ2tjTkFBc01Cd3RCSENFSERBUUxJQWtnQnlBS2F5SVBJQWtnRDBvYklna2dEVUgvLy8vL0IzTktEUUpCUFNFSElBNGdDU0FOYWlJR0lBWWdEa2diSWdRZ0Zrb05BeUFBUVNBZ0JDQUdJQWdRQmlBQUlCTWdEUkFGSUFCQk1DQUVJQVlnQ0VHQWdBUnpFQVlnQUVFd0lBa2dEMEVBRUFZZ0FDQUtJQThRQlNBQVFTQWdCQ0FHSUFoQmdNQUFjeEFHREFFTEMwRUFJUXdNQXd0QlBTRUhDMEdvTWlBSE5nSUFDMEYvSVF3TElBVkIwQUJxSkFBZ0RBdCtBZ0YvQVg0Z0FMMGlBMEkwaUtkQi93OXhJZ0pCL3c5SEJId2dBa1VFUUNBQklBQkVBQUFBQUFBQUFBQmhCSDlCQUFVZ0FFUUFBQUFBQUFEd1E2SWdBUkFxSVFBZ0FTZ0NBRUZBYWdzMkFnQWdBQThMSUFFZ0FrSCtCMnMyQWdBZ0EwTC8vLy8vLy8vL2g0Qi9nMEtBZ0lDQWdJQ0E4RCtFdndVZ0FBc0xlZ0VEZndKQUFrQWdBQ0lCUVFOeFJRMEFJQUF0QUFCRkJFQkJBQThMQTBBZ0FVRUJhaUlCUVFOeFJRMEJJQUV0QUFBTkFBc01BUXNEUUNBQklnSkJCR29oQVNBQ0tBSUFJZ05CZjNNZ0EwR0Jnb1FJYTNGQmdJR0NoSGh4UlEwQUN3TkFJQUlpQVVFQmFpRUNJQUV0QUFBTkFBc0xJQUVnQUdzTGdBUUJBMzhnQWtHQUJFOEVRQ0FBSUFFZ0FoQUVJQUFQQ3lBQUlBSnFJUU1DUUNBQUlBRnpRUU54UlFSQUFrQWdBRUVEY1VVRVFDQUFJUUlNQVFzZ0FrVUVRQ0FBSVFJTUFRc2dBQ0VDQTBBZ0FpQUJMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJZ0pCQTNGRkRRRWdBaUFEU1EwQUN3c0NRQ0FEUVh4eElnUkJ3QUJKRFFBZ0FpQUVRVUJxSWdWTERRQURRQ0FDSUFFb0FnQTJBZ0FnQWlBQktBSUVOZ0lFSUFJZ0FTZ0NDRFlDQ0NBQ0lBRW9BZ3cyQWd3Z0FpQUJLQUlRTmdJUUlBSWdBU2dDRkRZQ0ZDQUNJQUVvQWhnMkFoZ2dBaUFCS0FJY05nSWNJQUlnQVNnQ0lEWUNJQ0FDSUFFb0FpUTJBaVFnQWlBQktBSW9OZ0lvSUFJZ0FTZ0NMRFlDTENBQ0lBRW9BakEyQWpBZ0FpQUJLQUkwTmdJMElBSWdBU2dDT0RZQ09DQUNJQUVvQWp3MkFqd2dBVUZBYXlFQklBSkJRR3NpQWlBRlRRMEFDd3NnQWlBRVR3MEJBMEFnQWlBQktBSUFOZ0lBSUFGQkJHb2hBU0FDUVFScUlnSWdCRWtOQUFzTUFRc2dBMEVFU1FSQUlBQWhBZ3dCQ3lBQUlBTkJCR3NpQkVzRVFDQUFJUUlNQVFzZ0FDRUNBMEFnQWlBQkxRQUFPZ0FBSUFJZ0FTMEFBVG9BQVNBQ0lBRXRBQUk2QUFJZ0FpQUJMUUFET2dBRElBRkJCR29oQVNBQ1FRUnFJZ0lnQkUwTkFBc0xJQUlnQTBrRVFBTkFJQUlnQVMwQUFEb0FBQ0FCUVFGcUlRRWdBa0VCYWlJQ0lBTkhEUUFMQ3lBQUN3TUFBUXY0RHdJVWZ3TjhJd0JCRUdzaUN5UUFBa0FnQUx3aUVVSC8vLy8vQjNFaUEwSGFuNlR1QkUwRVFDQUJJQUM3SWhjZ0YwU0R5TWx0TUYva1A2SkVBQUFBQUFBQU9FT2dSQUFBQUFBQUFEakRvQ0lXUkFBQUFGRDdJZm0vb3FBZ0ZrUmpZaHBodEJCUnZxS2dJaGc1QXdBZ0dFUUFBQUJnK3lIcHYyTWhBZ0ovSUJhWlJBQUFBQUFBQU9CQll3UkFJQmFxREFFTFFZQ0FnSUI0Q3lFRElBSUVRQ0FCSUJjZ0ZrUUFBQUFBQUFEd3Y2QWlGa1FBQUFCUSt5SDV2NktnSUJaRVkySWFZYlFRVWI2aW9Ea0RBQ0FEUVFGcklRTU1BZ3NnR0VRQUFBQmcreUhwUDJSRkRRRWdBU0FYSUJaRUFBQUFBQUFBOEQrZ0loWkVBQUFBVVBzaCtiK2lvQ0FXUkdOaUdtRzBFRkcrb3FBNUF3QWdBMEVCYWlFRERBRUxJQU5CZ0lDQS9BZFBCRUFnQVNBQUlBQ1R1emtEQUVFQUlRTU1BUXNnQ3lBRElBTkJGM1pCbGdGcklnTkJGM1JydnJzNUF3Z2dDMEVJYWlFT0l3QkJzQVJySWdVa0FDQURJQU5CQTJ0QkdHMGlBa0VBSUFKQkFFb2JJZzFCYUd4cUlRWkI4QWtvQWdBaUIwRUFUZ1JBSUFkQkFXb2hBeUFOSVFJRFFDQUZRY0FDYWlBRVFRTjBhaUFDUVFCSUJIeEVBQUFBQUFBQUFBQUZJQUpCQW5SQmdBcHFLQUlBdHdzNUF3QWdBa0VCYWlFQ0lBUkJBV29pQkNBRFJ3MEFDd3NnQmtFWWF5RUlRUUFoQXlBSFFRQWdCMEVBU2hzaEJBTkFRUUFoQWtRQUFBQUFBQUFBQUNFV0EwQWdEaUFDUVFOMGFpc0RBQ0FGUWNBQ2FpQURJQUpyUVFOMGFpc0RBS0lnRnFBaEZpQUNRUUZxSWdKQkFVY05BQXNnQlNBRFFRTjBhaUFXT1FNQUlBTWdCRVloQWlBRFFRRnFJUU1nQWtVTkFBdEJMeUFHYXlFU1FUQWdCbXNoRHlBR1FSbHJJUk1nQnlFREFrQURRQ0FGSUFOQkEzUnFLd01BSVJaQkFDRUNJQU1oQkNBRFFRQk1JZ2xGQkVBRFFDQUZRZUFEYWlBQ1FRSjBhZ0ovQW44Z0ZrUUFBQUFBQUFCd1BxSWlGNWxFQUFBQUFBQUE0RUZqQkVBZ0Y2b01BUXRCZ0lDQWdIZ0x0eUlYUkFBQUFBQUFBSERCb2lBV29DSVdtVVFBQUFBQUFBRGdRV01FUUNBV3Fnd0JDMEdBZ0lDQWVBczJBZ0FnQlNBRVFRRnJJZ1JCQTNScUt3TUFJQmVnSVJZZ0FrRUJhaUlDSUFOSERRQUxDd0ovSUJZZ0NCQVBJaFlnRmtRQUFBQUFBQURBUDZLY1JBQUFBQUFBQUNEQW9xQWlGcGxFQUFBQUFBQUE0RUZqQkVBZ0Zxb01BUXRCZ0lDQWdIZ0xJUW9nRmlBS3Q2RWhGZ0pBQWtBQ1FBSi9JQWhCQUV3aUZFVUVRQ0FEUVFKMElBVnFJZ0lnQWlnQzNBTWlBaUFDSUE5MUlnSWdEM1JySWdRMkF0d0RJQUlnQ21vaENpQUVJQkoxREFFTElBZ05BU0FEUVFKMElBVnFLQUxjQTBFWGRRc2lERUVBVEEwQ0RBRUxRUUloRENBV1JBQUFBQUFBQU9BL1pnMEFRUUFoREF3QkMwRUFJUUpCQUNFRUlBbEZCRUFEUUNBRlFlQURhaUFDUVFKMGFpSVZLQUlBSVFsQi8vLy9CeUVRQW44Q1FDQUVEUUJCZ0lDQUNDRVFJQWtOQUVFQURBRUxJQlVnRUNBSmF6WUNBRUVCQ3lFRUlBSkJBV29pQWlBRFJ3MEFDd3NDUUNBVURRQkIvLy8vQXlFQ0FrQUNRQ0FURGdJQkFBSUxRZi8vL3dFaEFnc2dBMEVDZENBRmFpSUpJQWtvQXR3RElBSnhOZ0xjQXdzZ0NrRUJhaUVLSUF4QkFrY05BRVFBQUFBQUFBRHdQeUFXb1NFV1FRSWhEQ0FFUlEwQUlCWkVBQUFBQUFBQThEOGdDQkFQb1NFV0N5QVdSQUFBQUFBQUFBQUFZUVJBUVFBaEJBSkFJQWNnQXlJQ1RnMEFBMEFnQlVIZ0Eyb2dBa0VCYXlJQ1FRSjBhaWdDQUNBRWNpRUVJQUlnQjBvTkFBc2dCRVVOQUNBSUlRWURRQ0FHUVJocklRWWdCVUhnQTJvZ0EwRUJheUlEUVFKMGFpZ0NBRVVOQUFzTUF3dEJBU0VDQTBBZ0FpSUVRUUZxSVFJZ0JVSGdBMm9nQnlBRWEwRUNkR29vQWdCRkRRQUxJQU1nQkdvaEJBTkFJQVZCd0FKcUlBTkJBV29pQTBFRGRHb2dBeUFOYWtFQ2RFR0FDbW9vQWdDM09RTUFRUUFoQWtRQUFBQUFBQUFBQUNFV0EwQWdEaUFDUVFOMGFpc0RBQ0FGUWNBQ2FpQURJQUpyUVFOMGFpc0RBS0lnRnFBaEZpQUNRUUZxSWdKQkFVY05BQXNnQlNBRFFRTjBhaUFXT1FNQUlBTWdCRWdOQUFzZ0JDRUREQUVMQ3dKQUlCWkJHQ0FHYXhBUEloWkVBQUFBQUFBQWNFRm1CRUFnQlVIZ0Eyb2dBMEVDZEdvQ2Z3Si9JQlpFQUFBQUFBQUFjRDZpSWhlWlJBQUFBQUFBQU9CQll3UkFJQmVxREFFTFFZQ0FnSUI0Q3lJQ3QwUUFBQUFBQUFCd3dhSWdGcUFpRnBsRUFBQUFBQUFBNEVGakJFQWdGcW9NQVF0QmdJQ0FnSGdMTmdJQUlBTkJBV29oQXd3QkN3Si9JQmFaUkFBQUFBQUFBT0JCWXdSQUlCYXFEQUVMUVlDQWdJQjRDeUVDSUFnaEJnc2dCVUhnQTJvZ0EwRUNkR29nQWpZQ0FBdEVBQUFBQUFBQThEOGdCaEFQSVJZQ1FDQURRUUJJRFFBZ0F5RUNBMEFnQlNBQ0lnUkJBM1JxSUJZZ0JVSGdBMm9nQWtFQ2RHb29BZ0Mzb2prREFDQUNRUUZySVFJZ0ZrUUFBQUFBQUFCd1BxSWhGaUFFRFFBTElBTkJBRWdOQUNBRElRUURRRVFBQUFBQUFBQUFBQ0VXUVFBaEFpQUhJQU1nQkdzaUJpQUdJQWRLR3lJSVFRQk9CRUFEUUNBQ1FRTjBRZEFmYWlzREFDQUZJQUlnQkdwQkEzUnFLd01Bb2lBV29DRVdJQUlnQ0VjaERTQUNRUUZxSVFJZ0RRMEFDd3NnQlVHZ0FXb2dCa0VEZEdvZ0Zqa0RBQ0FFUVFCS0lRSWdCRUVCYXlFRUlBSU5BQXNMUkFBQUFBQUFBQUFBSVJZZ0EwRUFUZ1JBQTBBZ0F5SUNRUUZySVFNZ0ZpQUZRYUFCYWlBQ1FRTjBhaXNEQUtBaEZpQUNEUUFMQ3lBTElCYWFJQllnREJzNUF3QWdCVUd3Qkdva0FDQUtRUWR4SVFNZ0N5c0RBQ0VXSUJGQkFFZ0VRQ0FCSUJhYU9RTUFRUUFnQTJzaEF3d0JDeUFCSUJZNUF3QUxJQXRCRUdva0FDQURDL1lFQVFoL0lBRWdBQ2dDQ0NJRUlBQW9BZ1FpQW10QkpHMU5CRUFnQUNBQkJIOGdBaUFCUVNSc2FpRUFBMEFnQXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFnQWdBa0VBTmdJZ0lBTDlEQUFBQUFBQUFBQUFBQUFBQUFBQUFBRDlDd0lRSUFKQkFEWUNDQ0FDUWdBM0FnQWdBa0VNYWlJQlFRQTJBZ2dnQVVJQU53SUFJQUpCR0dvaUFVRUFOZ0lJSUFGQ0FEY0NBQ0FDUVNScUlnSWdBRWNOQUFzZ0FBVWdBZ3MyQWdRUEN3SkFJQUlnQUNnQ0FDSUNhMEVrYlNJR0lBRnFJZ05CeU9QeE9Fa0VRRUhINC9FNElBUWdBbXRCSkcwaUFrRUJkQ0lFSUFNZ0F5QUVTUnNnQWtIajhiZ2NUeHNpQkFSQUlBUkJ5T1B4T0U4TkFpQUVRU1JzRUE0aEJRc2dCU0FHUVNSc2FpSURJQUZCSkd4cUlRWWdBeUVDQTBBZ0F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBZ0FnQWtFQU5nSWdJQUw5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ5Q3dJUUlBSkJBRFlDQ0NBQ1FnQTNBZ0FnQWtFTWFpSUJRUUEyQWdnZ0FVSUFOd0lBSUFKQkdHb2lBVUVBTmdJSUlBRkNBRGNDQUNBQ1FTUnFJZ0lnQmtjTkFBc2dCU0FFUVNSc2FpRUlBa0FnQUNnQ0JDSUNJQUFvQWdBaUNVWUVRQ0FESVFVTUFRc0RRQ0FEUVNScklnVWdBa0VrYXlJQktnSUFPQUlBSUFVZ0FTb0NCRGdDQkNBRklBRXFBZ2c0QWdnZ0EwRVlheUlFSUFKQkdHc2lCeW9DQURnQ0FDQUVJQWNxQWdRNEFnUWdCQ0FIS2dJSU9BSUlJQU5CREdzaUF5QUNRUXhySWdJcUFnQTRBZ0FnQXlBQ0tnSUVPQUlFSUFNZ0Fpb0NDRGdDQ0NBRklRTWdBU0lDSUFsSERRQUxJQUFvQWdBaEFnc2dBQ0FJTmdJSUlBQWdCallDQkNBQUlBVTJBZ0FnQWdSQUlBSVFDZ3NQQ3hBWkFBc1FHQUFMcmdvQkNIOENRRUhvS1NnQ0FFSGtLU2dDQUNJQ2EwRUdkU0lCSUFCSkJFQWdBQ0FCYXlJRFFld3BLQUlBSWdSQjZDa29BZ0FpQVd0QkJuVk5CRUJCNkNrZ0F3Ui9JQUVnQTBFR2RHb2hBZ05BSUFFUUdrRkFheUlCSUFKSERRQUxJQUlGSUFFTE5nSUFEQUlMQWtBZ0FVSGtLU2dDQUNJQ2EwRUdkU0lHSUFOcUlnVkJnSUNBSUVrRVFFSC8vLzhmSUFRZ0Ftc2lBVUVGZFNJQ0lBVWdBaUFGU3hzZ0FVSEEvLy8vQjA4YklnY0VmeUFIUVlDQWdDQlBEUUlnQjBFR2RCQU9CVUVBQ3lJRUlBWkJCblJxSWdJZ0EwRUdkR29oQlNBQ0lRRURRQ0FCRUJwQlFHc2lBU0FGUncwQUMwSG9LU2dDQUNJQlFlUXBLQUlBSWdaSEJFQURRQ0FDUVVCcUlnTWdBVUZBYWlJQklnTDlBQUlBL1FzQ0FDQURJQUw5QUFJdy9Rc0NNQ0FESUFMOUFBSWcvUXNDSUNBRElBTDlBQUlRL1FzQ0VDQURJUUlnQVNBR1J3MEFDMEhrS1NnQ0FDRUJDMEhzS1NBRUlBZEJCblJxTmdJQVFlZ3BJQVUyQWdCQjVDa2dBallDQUNBQkJFQWdBUkFRQ3d3REN4QVpBQXNRR0FBTElBQWdBVThOQUVIb0tTQUNJQUJCQm5ScU5nSUFDd0pBUWZRcEtBSUFRZkFwS0FJQUlnSnJRU1J0SWdFZ0FFa0VRRUh3S1NBQUlBRnJFQzhNQVFzZ0FDQUJUdzBBUWZRcElBSWdBRUVrYkdvMkFnQUxBa0JCZ0Nvb0FnQkIvQ2tvQWdBaUFtdEJCSFVpQVNBQVNRUkFRUUFoQkVFQUlRY2dBQ0FCYXlJRFFZUXFLQUlBSWdaQmdDb29BZ0FpQW10QkJIVk5CRUFDUUNBRFJRMEFJQUloQVNBRFFRZHhJZ2dFUUFOQUlBRkMvLy8vL3c4M0FnZ2dBVUlBTndJQUlBRkJFR29oQVNBRVFRRnFJZ1FnQ0VjTkFBc0xJQU5CQkhRZ0Ftb2hBaUFEUVFGclFmLy8vLzhBY1VFSFNRMEFBMEFnQVVJQU53SndJQUZDQURjQ1lDQUJRZ0EzQWxBZ0FVSUFOd0pBSUFGQ0FEY0NNQ0FCUWdBM0FpQWdBVUlBTndJUUlBRkMvLy8vL3c4M0FnZ2dBVUlBTndJQUlBRkMvLy8vL3c4M0FuZ2dBVUwvLy8vL0R6Y0NhQ0FCUXYvLy8vOFBOd0pZSUFGQy8vLy8vdzgzQWtnZ0FVTC8vLy8vRHpjQ09DQUJRdi8vLy84UE53SW9JQUZDLy8vLy93ODNBaGdnQVVHQUFXb2lBU0FDUncwQUN3dEJnQ29nQWpZQ0FBd0NDd0pBSUFKQi9Da29BZ0FpQVd0QkJIVWlCQ0FEYWlJRlFZQ0FnSUFCU1FSQVFmLy8vLzhBSUFZZ0FXc2lCa0VEZFNJQklBVWdBU0FGU3hzZ0JrSHcvLy8vQjA4YklnVUVRQ0FGUVlDQWdJQUJUdzBDSUFWQkJIUVFEaUVIQ3lBSElBUkJCSFJxSWdRaEFTQURRUWR4SWdZRVFBTkFJQUZDLy8vLy93ODNBZ2dnQVVJQU53SUFJQUZCRUdvaEFTQUlRUUZxSWdnZ0JrY05BQXNMSUFOQkJIUWdCR29oQ0NBRFFRRnJRZi8vLy84QWNVRUhUd1JBQTBBZ0FVSUFOd0p3SUFGQ0FEY0NZQ0FCUWdBM0FsQWdBVUlBTndKQUlBRkNBRGNDTUNBQlFnQTNBaUFnQVVJQU53SVFJQUZDLy8vLy93ODNBZ2dnQVVJQU53SUFJQUZDLy8vLy93ODNBbmdnQVVMLy8vLy9EemNDYUNBQlF2Ly8vLzhQTndKWUlBRkMvLy8vL3c4M0FrZ2dBVUwvLy8vL0R6Y0NPQ0FCUXYvLy8vOFBOd0lvSUFGQy8vLy8vdzgzQWhnZ0FVR0FBV29pQVNBSVJ3MEFDd3RCL0Nrb0FnQWlBU0FDUndSQUEwQWdCRUVRYXlJRUlBSkJFR3NpQXYwQUFnRDlDd0lBSUFFZ0FrY05BQXRCL0Nrb0FnQWhBZ3RCaENvZ0J5QUZRUVIwYWpZQ0FFR0FLaUFJTmdJQVFmd3BJQVEyQWdBZ0FnUkFJQUlRRUFzTUF3c1FHUUFMRUJnQUN5QUFJQUZQRFFCQmdDb2dBaUFBUVFSMGFqWUNBQXRCakNvb0FnQkJpQ29vQWdBaUFtdEJKRzBpQVNBQVNRUkFRWWdxSUFBZ0FXc1FMdzhMSUFBZ0FVa0VRRUdNS2lBQ0lBQkJKR3hxTmdJQUN3c1FBQ01BSUFCclFYQnhJZ0FrQUNBQUN3Y0FJQUFvQWdRTEdRQkJpQ29vQWdBaUFBUkFRWXdxSUFBMkFnQWdBQkFLQ3dzRkFFRzNDQXNGQUVIbkNBc0ZBRUdrQ0FzVkFDQUFSUVJBUVFBUEN5QUFRYVFsRUNGQkFFY0xHZ0FnQUNBQktBSUlJQVVRQ1FSQUlBRWdBaUFESUFRUUh3c0xOd0FnQUNBQktBSUlJQVVRQ1FSQUlBRWdBaUFESUFRUUh3OExJQUFvQWdnaUFDQUJJQUlnQXlBRUlBVWdBQ2dDQUNnQ0ZCRUhBQXVuQVFBZ0FDQUJLQUlJSUFRUUNRUkFBa0FnQVNnQ0JDQUNSdzBBSUFFb0FoeEJBVVlOQUNBQklBTTJBaHdMRHdzQ1FDQUFJQUVvQWdBZ0JCQUpSUTBBQWtBZ0FpQUJLQUlRUndSQUlBRW9BaFFnQWtjTkFRc2dBMEVCUncwQklBRkJBVFlDSUE4TElBRWdBallDRkNBQklBTTJBaUFnQVNBQktBSW9RUUZxTmdJb0FrQWdBU2dDSkVFQlJ3MEFJQUVvQWhoQkFrY05BQ0FCUVFFNkFEWUxJQUZCQkRZQ0xBc0xpQUlBSUFBZ0FTZ0NDQ0FFRUFrRVFBSkFJQUVvQWdRZ0FrY05BQ0FCS0FJY1FRRkdEUUFnQVNBRE5nSWNDdzhMQWtBZ0FDQUJLQUlBSUFRUUNRUkFBa0FnQWlBQktBSVFSd1JBSUFFb0FoUWdBa2NOQVFzZ0EwRUJSdzBDSUFGQkFUWUNJQThMSUFFZ0F6WUNJQUpBSUFFb0FpeEJCRVlOQUNBQlFRQTdBVFFnQUNnQ0NDSUFJQUVnQWlBQ1FRRWdCQ0FBS0FJQUtBSVVFUWNBSUFFdEFEVUVRQ0FCUVFNMkFpd2dBUzBBTkVVTkFRd0RDeUFCUVFRMkFpd0xJQUVnQWpZQ0ZDQUJJQUVvQWloQkFXbzJBaWdnQVNnQ0pFRUJSdzBCSUFFb0FoaEJBa2NOQVNBQlFRRTZBRFlQQ3lBQUtBSUlJZ0FnQVNBQ0lBTWdCQ0FBS0FJQUtBSVlFUVVBQ3dzWkFFSDhLU2dDQUNJQUJFQkJnQ29nQURZQ0FDQUFFQW9MQ3pFQUlBQWdBU2dDQ0VFQUVBa0VRQ0FCSUFJZ0F4QWdEd3NnQUNnQ0NDSUFJQUVnQWlBRElBQW9BZ0FvQWh3UkJnQUxHQUFnQUNBQktBSUlRUUFRQ1FSQUlBRWdBaUFERUNBTEM1c0JBUUYvSXdCQlFHb2lBeVFBQW45QkFTQUFJQUZCQUJBSkRRQWFRUUFnQVVVTkFCcEJBQ0FCUWNRa0VDRWlBVVVOQUJvZ0EwRU1ha0VBUVRRUUVTQURRUUUyQWpnZ0EwRi9OZ0lVSUFNZ0FEWUNFQ0FESUFFMkFnZ2dBU0FEUVFocUlBSW9BZ0JCQVNBQktBSUFLQUljRVFZQUlBTW9BaUFpQUVFQlJnUkFJQUlnQXlnQ0dEWUNBQXNnQUVFQlJnc2hBQ0FEUVVCckpBQWdBQXNaQUVId0tTZ0NBQ0lBQkVCQjlDa2dBRFlDQUNBQUVBb0xDeGtBUWVRcEtBSUFJZ0FFUUVIb0tTQUFOZ0lBSUFBUUNnc0xCQUJDQUFzRUFFRUFDL1FDQVFkL0l3QkJJR3NpQXlRQUlBTWdBQ2dDSENJRU5nSVFJQUFvQWhRaEJTQURJQUkyQWh3Z0F5QUJOZ0lZSUFNZ0JTQUVheUlCTmdJVUlBRWdBbW9oQlVFQ0lRY0Nmd0pBQWtBQ1FDQUFLQUk4SUFOQkVHb2lBVUVDSUFOQkRHb1FBQ0lFQkg5QnFESWdCRFlDQUVGL0JVRUFDd1JBSUFFaEJBd0JDd05BSUFVZ0F5Z0NEQ0lHUmcwQ0lBWkJBRWdFUUNBQklRUU1CQXNnQVNBR0lBRW9BZ1FpQ0VzaUNVRURkR29pQkNBR0lBaEJBQ0FKRzJzaUNDQUVLQUlBYWpZQ0FDQUJRUXhCQkNBSkcyb2lBU0FCS0FJQUlBaHJOZ0lBSUFVZ0Jtc2hCU0FBS0FJOElBUWlBU0FISUFscklnY2dBMEVNYWhBQUlnWUVmMEdvTWlBR05nSUFRWDhGUVFBTFJRMEFDd3NnQlVGL1J3MEJDeUFBSUFBb0Fpd2lBVFlDSENBQUlBRTJBaFFnQUNBQklBQW9BakJxTmdJUUlBSU1BUXNnQUVFQU5nSWNJQUJDQURjREVDQUFJQUFvQWdCQklISTJBZ0JCQUNBSFFRSkdEUUFhSUFJZ0JDZ0NCR3NMSVFBZ0EwRWdhaVFBSUFBTGh3SUFRWlFwS0FJQUdnSkFRWDlCQUFKL1FkQUlFQ3NpQUFKL1FaUXBLQUlBUVFCSUJFQkIwQWdnQUVISUtCQVVEQUVMUWRBSUlBQkJ5Q2dRRkFzaUFTQUFSZzBBR2lBQkN5QUFSeHRCQUVnTkFBSkFRWmdwS0FJQVFRcEdEUUJCM0Nnb0FnQWlBRUhZS0NnQ0FFWU5BRUhjS0NBQVFRRnFOZ0lBSUFCQkNqb0FBQXdCQ3lNQVFSQnJJZ0FrQUNBQVFRbzZBQThDUUFKQVFkZ29LQUlBSWdFRWZ5QUJCVUhJS0JBVkRRSkIyQ2dvQWdBTFFkd29LQUlBSWdGR0RRQkJtQ2tvQWdCQkNrWU5BRUhjS0NBQlFRRnFOZ0lBSUFGQkNqb0FBQXdCQzBISUtDQUFRUTlxUVFGQjdDZ29BZ0FSQWdCQkFVY05BQ0FBTFFBUEdnc2dBRUVRYWlRQUMwRUFDeVlBUWVBcElBSTRBZ0FnQUNBQlNBUkFBMEFnQUJBY0dpQUFRUUZxSWdBZ0FVY05BQXNMQytVRUFnWi9EMzBqQUVHQUFXc2lBU1FBUWVRcEtBSUFJQUJCQm5ScUlnQXFBZ0FoQnlBQUtnSUVJUWdnQUNvQ0NDRUpJQUFxQWd3aENpQUFLZ0lRSVFzZ0FDb0NGQ0VNSUFBcUFoZ2hEU0FBS2dJY0lRNGdBQ29DSUNFUElBQXFBaVFoRUNBQUtnSW9JUkVnQUNvQ0xDRVNJQUFxQWpBaEV5QUFLZ0kwSVJRZ0FDb0NPQ0VWSUFFZ0FDb0NQTHM1QTNnZ0FTQVZ1emtEY0NBQklCUzdPUU5vSUFFZ0U3czVBMkFnQVNBU3V6a0RXQ0FCSUJHN09RTlFJQUVnRUxzNUEwZ2dBVUZBYXlBUHV6a0RBQ0FCSUE2N09RTTRJQUVnRGJzNUF6QWdBU0FNdXprREtDQUJJQXU3T1FNZ0lBRWdDcnM1QXhnZ0FTQUp1emtERUNBQklBaTdPUU1JSUFFZ0I3czVBd0FqQUVFUWF5SUVKQUFnQkNBQk5nSU1Jd0JCMEFGcklnQWtBQ0FBSUFFMkFzd0JJQUJCb0FGcUlnSkJBRUVvRUJFZ0FDQUFLQUxNQVRZQ3lBRUNRRUVBSUFCQnlBRnFJQUJCMEFCcUlBSVFLVUVBU0EwQVFaUXBLQUlBUVFCT0lRVkJ5Q2dvQWdBaEFrR1FLU2dDQUVFQVRBUkFRY2dvSUFKQlgzRTJBZ0FMQW44Q1FBSkFRZmdvS0FJQVJRUkFRZmdvUWRBQU5nSUFRZVFvUVFBMkFnQkIyQ2hDQURjREFFSDBLQ2dDQUNFRFFmUW9JQUEyQWdBTUFRdEIyQ2dvQWdBTkFRdEJmMEhJS0JBVkRRRWFDMEhJS0NBQVFjZ0JhaUFBUWRBQWFpQUFRYUFCYWhBcEN5RUdJQU1FZjBISUtFRUFRUUJCN0Nnb0FnQVJBZ0FhUWZnb1FRQTJBZ0JCOUNnZ0F6WUNBRUhrS0VFQU5nSUFRZHdvS0FJQUdrSFlLRUlBTndNQVFRQUZJQVlMR2tISUtFSElLQ2dDQUNBQ1FTQnhjallDQUNBRlJRMEFDeUFBUWRBQmFpUUFJQVJCRUdva0FDQUJRWUFCYWlRQUN3Z0FRWWdxS0FJQUN3Z0FRZndwS0FJQUN3Z0FRZkFwS0FJQUN3Z0FRZVFwS0FJQUN3dm5IeFFBUVlBSUM4Y1hMU3NnSUNBd1dEQjRBQzB3V0Nzd1dDQXdXQzB3ZUNzd2VDQXdlQUIyWldOMGIzSUFjM1JrT2pwbGVHTmxjSFJwYjI0QWJtRnVBR0poWkY5aGNuSmhlVjl1WlhkZmJHVnVaM1JvQUdsdVpnQmxiWE5qY21sd2RHVnVJR2hoZG1VZ2JHOWhaR1ZrQUhOMFpEbzZZbUZrWDJGc2JHOWpBRTVCVGdCSlRrWUFMZ0FvYm5Wc2JDa0FXeVV1TW1Zc0lDVXVNbVlzSUNVdU1tWXNJQ1V1TW1aZERRcGJKUzR5Wml3Z0pTNHlaaXdnSlM0eVppd2dKUzR5WmwwTkNsc2xMakptTENBbExqSm1MQ0FsTGpKbUxDQWxMakptWFEwS1d5VXVNbVlzSUNVdU1tWXNJQ1V1TW1Zc0lDVXVNbVpkRFFvQUF3QUFBQVFBQUFBRUFBQUFCZ0FBQUlQNW9nQkVUbTRBL0NrVkFORlhKd0RkTlBVQVl0dkFBRHlabFFCQmtFTUFZMUgrQUx2ZXF3QzNZY1VBT200a0FOSk5RZ0JKQnVBQUNlb3VBQnlTMFFEckhmNEFLYkVjQU9nK3B3RDFOWUlBUkxzdUFKenBoQUMwSm5BQVFYNWZBTmFST1FCVGd6a0FuUFE1QUl0ZmhBQW8rYjBBK0I4N0FONy9sd0FQbUFVQUVTL3ZBQXBhaXdCdEgyMEF6MzQyQUFuTEp3QkdUN2NBbm1ZL0FDM3FYd0M2SjNVQTVldkhBRDE3OFFEM09RY0FrbEtLQVB0cjZnQWZzVjhBQ0YyTkFEQURWZ0I3L0VZQThLdHJBQ0M4endBMjlKb0E0NmtkQUY1aGtRQUlHK1lBaFpsbEFLQVVYd0NOUUdnQWdOai9BQ2R6VFFBR0JqRUF5bFlWQU1tb2N3Qjc0bUFBYTR6QUFCbkVSd0ROWjhNQUNlamNBRm1ES2dDTGRzUUFwaHlXQUVTdjNRQVpWOUVBcFQ0RkFBVUgvd0F6Zmo4QXdqTG9BSmhQM2dDN2ZUSUFKajNEQUI1cjd3Q2YrRjRBTlI4NkFIL3l5Z0R4aHgwQWZKQWhBR29rZkFEVmJ2b0FNQzEzQUJVN1F3QzFGTVlBd3htZEFLM0V3Z0FzVFVFQURBQmRBSVo5UmdEamNTMEFtOGFhQUROaUFBQzAwbndBdEtlWEFEZFYxUURYUHZZQW94QVlBRTEyL0FCa25Tb0FjTmVyQUdOOCtBQjZzRmNBRnhYbkFNQkpWZ0E3MXRrQXA0UTRBQ1FqeXdEV2luY0FXbFFqQUFBZnVRRHhDaHNBR2M3ZkFKOHgvd0JtSG1vQW1WZGhBS3o3UndCK2Y5Z0FJbVczQURMb2lRRG12MkFBNzhUTkFHdzJDUUJkUDlRQUZ0N1hBRmc3M2dEZW01SUEwaUlvQUNpRzZBRGlXRTBBeHNveUFBampGZ0RnZmNzQUY4QlFBUE1kcHdBWTRGc0FMaE0wQUlNU1lnQ0RTQUVBOVk1YkFLMndmd0FlNmZJQVNFcERBQkJuMHdDcTNkZ0FybDlDQUdwaHpnQUtLS1FBMDVtMEFBYW04Z0JjZDM4QW84S0RBR0U4aUFDS2MzZ0FyNHhhQUcvWHZRQXRwbU1BOUwvTEFJMkI3d0Ftd1djQVZjcEZBTXJaTmdBb3FOSUF3bUdOQUJMSmR3QUVKaFFBRWthYkFNUlp4QURJeFVRQVRiS1JBQUFYOHdEVVE2MEFLVW5sQVAzVkVBQUF2dndBSHBUTUFIRE83Z0FUUHZVQTdQR0FBTFBud3dESCtDZ0Frd1dVQU1GeFBnQXVDYk1BQzBYekFJZ1NuQUNySUhzQUxyV2ZBRWVTd2dCN01pOEFERlZ0QUhLbmtBQnI1eDhBTWN1V0FIa1dTZ0JCZWVJQTlOK0pBT2lVbHdEaTVvUUFtVEdYQUlqdGF3QmZYellBdS8wT0FFaWF0QUJucEd3QWNYSkNBSTFkTWdDZkZiZ0F2T1VKQUkweEpRRDNkRGtBTUFVY0FBME1BUUJMQ0dnQUxPNVlBRWVxa0FCMDV3SUF2ZFlrQVBkOXBnQnVTSElBbnhidkFJNlVwZ0Mwa2ZZQTBWTlJBTThLOGdBZ21ETUE5VXQrQUxKamFBRGRQbDhBUUYwREFJV0pmd0JWVWlrQU4yVEFBRzNZRUFBeVNESUFXMHgxQUU1eDFBQkZWRzRBQ3duQkFDcjFhUUFVWnRVQUp3ZWRBRjBFVUFDME85c0E2bmJGQUlmNUZ3QkphMzBBSFNlNkFKWnBLUURHekt3QXJSUlVBSkRpYWdDSTJZa0FMSEpRQUFTa3ZnQjNCNVFBOHpCd0FBRDhKd0RxY2FnQVpzSkpBR1RnUFFDWDNZTUFveitYQUVPVS9RQU5ob3dBTVVIZUFKSTVuUURkY0l3QUY3Zm5BQWpmT3dBVk55c0FYSUNnQUZxQWt3QVFFWklBRCtqWUFHeUFyd0RiLzBzQU9KQVBBRmtZZGdCaXBSVUFZY3U3QU1lSnVRQVFRTDBBMHZJRUFFbDFKd0RydHZZQTJ5SzdBQW9VcWdDSkppOEFaSU4yQUFrN013QU9sQm9BVVRxcUFCMmp3Z0N2N2E0QVhDWVNBRzNDVFFBdGVwd0F3RmFYQUFNL2d3QUo4UFlBSzBDTUFHMHhtUUE1dEFjQURDQVZBTmpEV3dEMWtzUUF4cTFMQUU3S3BRQ25OODBBNXFrMkFLdVNsQURkUW1nQUdXUGVBSGFNN3dCb2kxSUEvTnMzQUs2aHF3RGZGVEVBQUs2aEFBejcyZ0JrVFdZQTdRVzNBQ2xsTUFCWFZyOEFSLzg2QUdyNXVRQjF2dk1BS0pQZkFLdUFNQUJtalBZQUJNc1ZBUG9pQmdEWjVCMEFQYk9rQUZjYmp3QTJ6UWtBVGtMcEFCTytwQUF6STdVQThLb2FBRTlscUFEU3dhVUFDejhQQUZ0NHpRQWorWFlBZTRzRUFJa1hjZ0RHcGxNQWIyN2lBTy9yQUFDYlNsZ0F4TnEzQUtwbXVnQjJ6ODhBMFFJZEFMSHhMUUNNbWNFQXc2MTNBSVpJMmdEM1hhQUF4b0QwQUt6d0x3RGQ3Sm9BUDF5OEFORGViUUNReHg4QUt0dTJBS01sT2dBQXI1b0FyVk9UQUxaWEJBQXBMYlFBUzRCK0FOb0hwd0IycWc0QWUxbWhBQllTS2dEY3R5MEErdVg5QUluYi9nQ0p2djBBNUhac0FBYXAvQUErZ0hBQWhXNFZBUDJIL3dBb1BnY0FZV2N6QUNvWWhnQk52ZW9BcytldkFJOXRiZ0NWWnprQU1iOWJBSVRYU0FBdzN4WUF4eTFEQUNWaE5RREpjTTRBTU11NEFMOXMvUUNrQUtJQUJXemtBRnJkb0FBaGIwY0FZaExTQUxsY2hBQndZVWtBYTFiZ0FKbFNBUUJRVlRjQUh0VzNBRFB4eEFBVGJsOEFYVERrQUlVdXFRQWRzc01Bb1RJMkFBaTNwQURxc2RRQUZ2Y2hBSTlwNUFBbi8zY0FEQU9BQUkxQUxRQlB6YUFBSUtXWkFMT2kwd0F2WFFvQXRQbENBQkhheXdCOXZ0QUFtOXZCQUtzWHZRREtvb0VBQ0dwY0FDNVZGd0FuQUZVQWZ4VHdBT0VIaGdBVUMyUUFsa0dOQUllKzNnRGEvU29BYXlXMkFIdUpOQUFGOC80QXViK2VBR2hxVHdCS0txZ0FUOFJhQUMzNHZBRFhXcGdBOU1lVkFBMU5qUUFnT3FZQXBGZGZBQlEvc1FDQU9KVUF6Q0FCQUhIZGhnREozcllBdjJEMUFFMWxFUUFCQjJzQWpMQ3NBTExBMEFCUlZVZ0FIdnNPQUpWeXd3Q2pCanNBd0VBMUFBYmNld0RnUmN3QVRpbjZBTmJLeUFEbzgwRUFmR1RlQUp0azJBRFp2akVBcEpmREFIZFkxQUJwNDhVQThOb1RBTG82UEFCR0dFWUFWWFZmQU5LOTlRQnVrc1lBckM1ZEFBNUU3UUFjUGtJQVljU0hBQ245NlFEbjF2TUFJbnpLQUcrUk5RQUk0TVVBLzllTkFHNXE0Z0N3L2NZQWt3akJBSHhkZEFCcnJiSUF6VzZkQUQ1eWV3REdFV29BOTgrcEFDbHozd0MxeWJvQXR3QlJBT0t5RFFCMHVpUUE1WDFnQUhUWWlnQU5GU3dBZ1JnTUFINW1sQUFCS1JZQW4zcDJBUDM5dmdCV1JlOEEyWDQyQU96WkV3Q0x1cmtBeEpmOEFER29Kd0R4YnNNQWxNVTJBTmlvVmdDMHFMVUF6OHdPQUJLSkxRQnZWelFBTEZhSkFKbk80d0RXSUxrQWExNnFBRDRxbkFBUlg4d0EvUXRLQU9IMCt3Q09PMjBBNG9Zc0FPblVoQUQ4dEtrQTcrN1JBQzQxeVFBdk9XRUFPQ0ZFQUJ2WnlBQ0IvQW9BKzBwcUFDOGMyQUJUdElRQVRwbU1BRlFpekFBcVZkd0F3TWJXQUFzWmxnQWFjTGdBYVpWa0FDWmFZQUEvVXU0QWZ4RVBBUFMxRVFEOHkvVUFOTHd0QURTODdnRG9YY3dBM1Y1Z0FHZU9td0NTTSs4QXlSZTRBR0ZZbXdEaFY3d0FVWVBHQU5nK0VBRGRjVWdBTFJ6ZEFLOFlvUUFoTEVZQVdmUFhBTmw2bUFDZVZNQUFUNGI2QUZZRy9BRGxlYTRBaVNJMkFEaXRJZ0Juazl3QVZlaXFBSUltT0FESzU1c0FVUTJrQUprenNRQ3AxdzRBYVFWSUFHV3k4QUIvaUtjQWlFeVhBUG5STmdBaGtyTUFlNEpLQUpqUElRQkFuOXdBM0VkVkFPRjBPZ0JuNjBJQS9wM2ZBRjdVWHdCN1o2UUF1cXg2QUZYMm9nQXJpQ01BUWJwVkFGbHVDQUFoS29ZQU9VZURBSW5qNWdEbG50UUFTZnRBQVA5VzZRQWNEOG9BeFZtS0FKVDZLd0RUd2NVQUQ4WFBBTnRhcmdCSHhZWUFoVU5pQUNHR093QXNlWlFBRUdHSEFDcE1ld0NBTEJvQVE3OFNBSWdta0FCNFBJa0FxTVRrQU9YYmV3REVPc0lBSnZUcUFQZG5pZ0FOa3I4QVphTXJBRDJUc1FDOWZBc0FwRkhjQUNmZFl3QnA0ZDBBbXBRWkFLZ3BsUUJvemlnQUNlMjBBRVNmSUFCT21Nb0FjSUpqQUg1OEl3QVB1VElBcC9XT0FCUlc1d0FoOFFnQXRaMHFBRzkrVFFDbEdWRUF0Zm1yQUlMZjFnQ1czV0VBRmpZQ0FNUTZud0NEb3FFQWN1MXRBRG1OZWdDQ3VLa0FhekpjQUVZbld3QUFOTzBBMGdCM0FQejBWUUFCV1UwQTRIR0FBRUhUSHd0K1FQc2grVDhBQUFBQUxVUjBQZ0FBQUlDWVJ2ZzhBQUFBWUZITWVEc0FBQUNBZ3h2d09RQUFBRUFnSlhvNEFBQUFnQ0tDNHpZQUFBQUFIZk5wTlJrQUNnQVpHUmtBQUFBQUJRQUFBQUFBQUFrQUFBQUFDd0FBQUFBQUFBQUFHUUFSQ2hrWkdRTUtCd0FCQUFrTEdBQUFDUVlMQUFBTEFBWVpBQUFBR1JrWkFFSGhJQXNoRGdBQUFBQUFBQUFBR1FBS0RSa1pHUUFOQUFBQ0FBa09BQUFBQ1FBT0FBQU9BRUdiSVFzQkRBQkJweUVMRlJNQUFBQUFFd0FBQUFBSkRBQUFBQUFBREFBQURBQkIxU0VMQVJBQVFlRWhDeFVQQUFBQUJBOEFBQUFBQ1JBQUFBQUFBQkFBQUJBQVFZOGlDd0VTQUVHYklnc2VFUUFBQUFBUkFBQUFBQWtTQUFBQUFBQVNBQUFTQUFBYUFBQUFHaG9hQUVIU0lnc09HZ0FBQUJvYUdnQUFBQUFBQUFrQVFZTWpDd0VVQUVHUEl3c1ZGd0FBQUFBWEFBQUFBQWtVQUFBQUFBQVVBQUFVQUVHOUl3c0JGZ0JCeVNNTC9RUVZBQUFBQUJVQUFBQUFDUllBQUFBQUFCWUFBQllBQURBeE1qTTBOVFkzT0RsQlFrTkVSVVpPTVRCZlgyTjRlR0ZpYVhZeE1UWmZYM05vYVcxZmRIbHdaVjlwYm1adlJRQUFBQURnRWdBQThCRUFBRUFVQUFCT01UQmZYMk40ZUdGaWFYWXhNVGRmWDJOc1lYTnpYM1I1Y0dWZmFXNW1iMFVBQUFEZ0VnQUFJQklBQUJRU0FBQk9NVEJmWDJONGVHRmlhWFl4TVRkZlgzQmlZWE5sWDNSNWNHVmZhVzVtYjBVQUFBRGdFZ0FBVUJJQUFCUVNBQUJPTVRCZlgyTjRlR0ZpYVhZeE1UbGZYM0J2YVc1MFpYSmZkSGx3WlY5cGJtWnZSUURnRWdBQWdCSUFBSFFTQUFBQUFBQUFSQklBQUFzQUFBQU1BQUFBRFFBQUFBNEFBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFBQUFBQUNnVEFBQUxBQUFBRXdBQUFBMEFBQUFPQUFBQUR3QUFBQlFBQUFBVkFBQUFGZ0FBQUU0eE1GOWZZM2g0WVdKcGRqRXlNRjlmYzJsZlkyeGhjM05mZEhsd1pWOXBibVp2UlFBQUFBRGdFZ0FBQUJNQUFFUVNBQUFBQUFBQW1CTUFBQUVBQUFBWEFBQUFHQUFBQUFBQUFBREFFd0FBQVFBQUFCa0FBQUFhQUFBQUFBQUFBSUFUQUFBQkFBQUFHd0FBQUJ3QUFBQlRkRGxsZUdObGNIUnBiMjRBQUFBQXVCSUFBSEFUQUFCVGREbGlZV1JmWVd4c2IyTUFBQUFBNEJJQUFJZ1RBQUNBRXdBQVUzUXlNR0poWkY5aGNuSmhlVjl1WlhkZmJHVnVaM1JvQUFBQUFPQVNBQUNrRXdBQW1CTUFBQUFBQUFEd0V3QUFBZ0FBQUIwQUFBQWVBQUFBVTNReE1XeHZaMmxqWDJWeWNtOXlBT0FTQUFEZ0V3QUFnQk1BQUFBQUFBQWtGQUFBQWdBQUFCOEFBQUFlQUFBQVUzUXhNbXhsYm1kMGFGOWxjbkp2Y2dBQUFBRGdFZ0FBRUJRQUFQQVRBQUJUZERsMGVYQmxYMmx1Wm04QUFBQUF1QklBQURBVUFFSElLQXNCQlFCQjFDZ0xBUWNBUWV3b0N3NElBQUFBQ1FBQUFDZ1ZBQUFBQkFCQmhDa0xBUUVBUVpRcEN3WC8vLy8vQ2dCQjJDa0xBK0FiQVE9PVwiO2lmKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKXt3YXNtQmluYXJ5RmlsZT1sb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKX1mdW5jdGlvbiBnZXRCaW5hcnlTeW5jKGZpbGUpe2lmKGZpbGU9PXdhc21CaW5hcnlGaWxlJiZ3YXNtQmluYXJ5KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSl9aWYocmVhZEJpbmFyeSl7cmV0dXJuIHJlYWRCaW5hcnkoZmlsZSl9dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKXtpZighd2FzbUJpbmFyeSYmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFpc0ZpbGVVUkkoYmluYXJ5RmlsZSkpe3JldHVybiBmZXRjaChiaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChyZXNwb25zZT0+e2lmKCFyZXNwb25zZVtcIm9rXCJdKXt0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrYmluYXJ5RmlsZStcIidcIn1yZXR1cm4gcmVzcG9uc2VbXCJhcnJheUJ1ZmZlclwiXSgpfSkpLmNhdGNoKCgoKT0+Z2V0QmluYXJ5U3luYyhiaW5hcnlGaWxlKSkpfWVsc2UgaWYocmVhZEFzeW5jKXtyZXR1cm4gbmV3IFByb21pc2UoKChyZXNvbHZlLHJlamVjdCk9PntyZWFkQXN5bmMoYmluYXJ5RmlsZSwocmVzcG9uc2U9PnJlc29sdmUobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSkscmVqZWN0KX0pKX19cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCgpPT5nZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMscmVjZWl2ZXIpe3JldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oKGJpbmFyeT0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LGltcG9ydHMpKSkudGhlbigoaW5zdGFuY2U9Pmluc3RhbmNlKSkudGhlbihyZWNlaXZlciwocmVhc29uPT57ZXJyKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrcmVhc29uKTthYm9ydChyZWFzb24pfSkpfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoYmluYXJ5LGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl7aWYoIWJpbmFyeSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT1cImZ1bmN0aW9uXCImJiFpc0RhdGFVUkkoYmluYXJ5RmlsZSkmJiFpc0ZpbGVVUkkoYmluYXJ5RmlsZSkmJiFFTlZJUk9OTUVOVF9JU19OT0RFJiZ0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZldGNoKGJpbmFyeUZpbGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKHJlc3BvbnNlPT57dmFyIHJlc3VsdD1XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSxpbXBvcnRzKTtyZXR1cm4gcmVzdWx0LnRoZW4oY2FsbGJhY2ssKGZ1bmN0aW9uKHJlYXNvbil7ZXJyKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3JlYXNvbik7ZXJyKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7cmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKX0pKX0pKX1yZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spfWZ1bmN0aW9uIGNyZWF0ZVdhc20oKXt2YXIgaW5mbz17XCJhXCI6d2FzbUltcG9ydHN9O2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSxtb2R1bGUpe3ZhciBleHBvcnRzPWluc3RhbmNlLmV4cG9ydHM7TW9kdWxlW1wiYXNtXCJdPWV4cG9ydHM7d2FzbU1lbW9yeT1Nb2R1bGVbXCJhc21cIl1bXCJmXCJdO3VwZGF0ZU1lbW9yeVZpZXdzKCk7d2FzbVRhYmxlPU1vZHVsZVtcImFzbVwiXVtcImhcIl07YWRkT25Jbml0KE1vZHVsZVtcImFzbVwiXVtcImdcIl0pO3JlbW92ZVJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO3JldHVybiBleHBvcnRzfWFkZFJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCl7cmVjZWl2ZUluc3RhbmNlKHJlc3VsdFtcImluc3RhbmNlXCJdKX1pZihNb2R1bGVbXCJpbnN0YW50aWF0ZVdhc21cIl0pe3RyeXtyZXR1cm4gTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKGluZm8scmVjZWl2ZUluc3RhbmNlKX1jYXRjaChlKXtlcnIoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitlKTtyZXR1cm4gZmFsc2V9fWluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSx3YXNtQmluYXJ5RmlsZSxpbmZvLHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtyZXR1cm57fX1mdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cyl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiO3RoaXMubWVzc2FnZT1cXGBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFxcJHtzdGF0dXN9KVxcYDt0aGlzLnN0YXR1cz1zdGF0dXN9dmFyIGNhbGxSdW50aW1lQ2FsbGJhY2tzPWNhbGxiYWNrcz0+e3doaWxlKGNhbGxiYWNrcy5sZW5ndGg+MCl7Y2FsbGJhY2tzLnNoaWZ0KCkoTW9kdWxlKX19O2Z1bmN0aW9uIEV4Y2VwdGlvbkluZm8oZXhjUHRyKXt0aGlzLmV4Y1B0cj1leGNQdHI7dGhpcy5wdHI9ZXhjUHRyLTI0O3RoaXMuc2V0X3R5cGU9ZnVuY3Rpb24odHlwZSl7SEVBUFUzMlt0aGlzLnB0cis0Pj4yXT10eXBlfTt0aGlzLmdldF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIrND4+Ml19O3RoaXMuc2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oZGVzdHJ1Y3Rvcil7SEVBUFUzMlt0aGlzLnB0cis4Pj4yXT1kZXN0cnVjdG9yfTt0aGlzLmdldF9kZXN0cnVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIrOD4+Ml19O3RoaXMuc2V0X2NhdWdodD1mdW5jdGlvbihjYXVnaHQpe2NhdWdodD1jYXVnaHQ/MTowO0hFQVA4W3RoaXMucHRyKzEyPj4wXT1jYXVnaHR9O3RoaXMuZ2V0X2NhdWdodD1mdW5jdGlvbigpe3JldHVybiBIRUFQOFt0aGlzLnB0cisxMj4+MF0hPTB9O3RoaXMuc2V0X3JldGhyb3duPWZ1bmN0aW9uKHJldGhyb3duKXtyZXRocm93bj1yZXRocm93bj8xOjA7SEVBUDhbdGhpcy5wdHIrMTM+PjBdPXJldGhyb3dufTt0aGlzLmdldF9yZXRocm93bj1mdW5jdGlvbigpe3JldHVybiBIRUFQOFt0aGlzLnB0cisxMz4+MF0hPTB9O3RoaXMuaW5pdD1mdW5jdGlvbih0eXBlLGRlc3RydWN0b3Ipe3RoaXMuc2V0X2FkanVzdGVkX3B0cigwKTt0aGlzLnNldF90eXBlKHR5cGUpO3RoaXMuc2V0X2Rlc3RydWN0b3IoZGVzdHJ1Y3Rvcil9O3RoaXMuc2V0X2FkanVzdGVkX3B0cj1mdW5jdGlvbihhZGp1c3RlZFB0cil7SEVBUFUzMlt0aGlzLnB0cisxNj4+Ml09YWRqdXN0ZWRQdHJ9O3RoaXMuZ2V0X2FkanVzdGVkX3B0cj1mdW5jdGlvbigpe3JldHVybiBIRUFQVTMyW3RoaXMucHRyKzE2Pj4yXX07dGhpcy5nZXRfZXhjZXB0aW9uX3B0cj1mdW5jdGlvbigpe3ZhciBpc1BvaW50ZXI9X19fY3hhX2lzX3BvaW50ZXJfdHlwZSh0aGlzLmdldF90eXBlKCkpO2lmKGlzUG9pbnRlcil7cmV0dXJuIEhFQVBVMzJbdGhpcy5leGNQdHI+PjJdfXZhciBhZGp1c3RlZD10aGlzLmdldF9hZGp1c3RlZF9wdHIoKTtpZihhZGp1c3RlZCE9PTApcmV0dXJuIGFkanVzdGVkO3JldHVybiB0aGlzLmV4Y1B0cn19dmFyIGV4Y2VwdGlvbkxhc3Q9MDt2YXIgdW5jYXVnaHRFeGNlcHRpb25Db3VudD0wO2Z1bmN0aW9uIF9fX2N4YV90aHJvdyhwdHIsdHlwZSxkZXN0cnVjdG9yKXt2YXIgaW5mbz1uZXcgRXhjZXB0aW9uSW5mbyhwdHIpO2luZm8uaW5pdCh0eXBlLGRlc3RydWN0b3IpO2V4Y2VwdGlvbkxhc3Q9cHRyO3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQrKzt0aHJvdyBleGNlcHRpb25MYXN0fXZhciBfYWJvcnQ9KCk9PnthYm9ydChcIlwiKX07dmFyIF9lbXNjcmlwdGVuX21lbWNweV9iaWc9KGRlc3Qsc3JjLG51bSk9PkhFQVBVOC5jb3B5V2l0aGluKGRlc3Qsc3JjLHNyYytudW0pO3ZhciBnZXRIZWFwTWF4PSgpPT4yMTQ3NDgzNjQ4O3ZhciBncm93TWVtb3J5PXNpemU9Pnt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjt2YXIgcGFnZXM9c2l6ZS1iLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7d2FzbU1lbW9yeS5ncm93KHBhZ2VzKTt1cGRhdGVNZW1vcnlWaWV3cygpO3JldHVybiAxfWNhdGNoKGUpe319O3ZhciBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcD1yZXF1ZXN0ZWRTaXplPT57dmFyIG9sZFNpemU9SEVBUFU4Lmxlbmd0aDtyZXF1ZXN0ZWRTaXplPj4+PTA7dmFyIG1heEhlYXBTaXplPWdldEhlYXBNYXgoKTtpZihyZXF1ZXN0ZWRTaXplPm1heEhlYXBTaXplKXtyZXR1cm4gZmFsc2V9dmFyIGFsaWduVXA9KHgsbXVsdGlwbGUpPT54KyhtdWx0aXBsZS14JW11bHRpcGxlKSVtdWx0aXBsZTtmb3IodmFyIGN1dERvd249MTtjdXREb3duPD00O2N1dERvd24qPTIpe3ZhciBvdmVyR3Jvd25IZWFwU2l6ZT1vbGRTaXplKigxKy4yL2N1dERvd24pO292ZXJHcm93bkhlYXBTaXplPU1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLHJlcXVlc3RlZFNpemUrMTAwNjYzMjk2KTt2YXIgbmV3U2l6ZT1NYXRoLm1pbihtYXhIZWFwU2l6ZSxhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsb3Zlckdyb3duSGVhcFNpemUpLDY1NTM2KSk7dmFyIHJlcGxhY2VtZW50PWdyb3dNZW1vcnkobmV3U2l6ZSk7aWYocmVwbGFjZW1lbnQpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O3ZhciBwcmludENoYXJCdWZmZXJzPVtudWxsLFtdLFtdXTt2YXIgVVRGOERlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT1cInVuZGVmaW5lZFwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dW5kZWZpbmVkO3ZhciBVVEY4QXJyYXlUb1N0cmluZz0oaGVhcE9yQXJyYXksaWR4LG1heEJ5dGVzVG9SZWFkKT0+e3ZhciBlbmRJZHg9aWR4K21heEJ5dGVzVG9SZWFkO3ZhciBlbmRQdHI9aWR4O3doaWxlKGhlYXBPckFycmF5W2VuZFB0cl0mJiEoZW5kUHRyPj1lbmRJZHgpKSsrZW5kUHRyO2lmKGVuZFB0ci1pZHg+MTYmJmhlYXBPckFycmF5LmJ1ZmZlciYmVVRGOERlY29kZXIpe3JldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LGVuZFB0cikpfXZhciBzdHI9XCJcIjt3aGlsZShpZHg8ZW5kUHRyKXt2YXIgdTA9aGVhcE9yQXJyYXlbaWR4KytdO2lmKCEodTAmMTI4KSl7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtjb250aW51ZX12YXIgdTE9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyMjQpPT0xOTIpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgodTAmMzEpPDw2fHUxKTtjb250aW51ZX12YXIgdTI9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyNDApPT0yMjQpe3UwPSh1MCYxNSk8PDEyfHUxPDw2fHUyfWVsc2V7dTA9KHUwJjcpPDwxOHx1MTw8MTJ8dTI8PDZ8aGVhcE9yQXJyYXlbaWR4KytdJjYzfWlmKHUwPDY1NTM2KXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApfWVsc2V7dmFyIGNoPXUwLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyl9fXJldHVybiBzdHJ9O3ZhciBwcmludENoYXI9KHN0cmVhbSxjdXJyKT0+e3ZhciBidWZmZXI9cHJpbnRDaGFyQnVmZmVyc1tzdHJlYW1dO2lmKGN1cnI9PT0wfHxjdXJyPT09MTApeyhzdHJlYW09PT0xP291dDplcnIpKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwwKSk7YnVmZmVyLmxlbmd0aD0wfWVsc2V7YnVmZmVyLnB1c2goY3Vycil9fTt2YXIgVVRGOFRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT5wdHI/VVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LHB0cixtYXhCeXRlc1RvUmVhZCk6XCJcIjt2YXIgU1lTQ0FMTFM9e3ZhcmFyZ3M6dW5kZWZpbmVkLGdldCgpe1NZU0NBTExTLnZhcmFyZ3MrPTQ7dmFyIHJldD1IRUFQMzJbU1lTQ0FMTFMudmFyYXJncy00Pj4yXTtyZXR1cm4gcmV0fSxnZXRTdHIocHRyKXt2YXIgcmV0PVVURjhUb1N0cmluZyhwdHIpO3JldHVybiByZXR9fTt2YXIgX2ZkX3dyaXRlPShmZCxpb3YsaW92Y250LHBudW0pPT57dmFyIG51bT0wO2Zvcih2YXIgaT0wO2k8aW92Y250O2krKyl7dmFyIHB0cj1IRUFQVTMyW2lvdj4+Ml07dmFyIGxlbj1IRUFQVTMyW2lvdis0Pj4yXTtpb3YrPTg7Zm9yKHZhciBqPTA7ajxsZW47aisrKXtwcmludENoYXIoZmQsSEVBUFU4W3B0citqXSl9bnVtKz1sZW59SEVBUFUzMltwbnVtPj4yXT1udW07cmV0dXJuIDB9O3ZhciBfcHJvY19leGl0PWNvZGU9PntFWElUU1RBVFVTPWNvZGU7aWYoIWtlZXBSdW50aW1lQWxpdmUoKSl7aWYoTW9kdWxlW1wib25FeGl0XCJdKU1vZHVsZVtcIm9uRXhpdFwiXShjb2RlKTtBQk9SVD10cnVlfXF1aXRfKGNvZGUsbmV3IEV4aXRTdGF0dXMoY29kZSkpfTt2YXIgZXhpdEpTPShzdGF0dXMsaW1wbGljaXQpPT57RVhJVFNUQVRVUz1zdGF0dXM7X3Byb2NfZXhpdChzdGF0dXMpfTt2YXIgaGFuZGxlRXhjZXB0aW9uPWU9PntpZihlIGluc3RhbmNlb2YgRXhpdFN0YXR1c3x8ZT09XCJ1bndpbmRcIil7cmV0dXJuIEVYSVRTVEFUVVN9cXVpdF8oMSxlKX07dmFyIGxlbmd0aEJ5dGVzVVRGOD1zdHI9Pnt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGM9c3RyLmNoYXJDb2RlQXQoaSk7aWYoYzw9MTI3KXtsZW4rK31lbHNlIGlmKGM8PTIwNDcpe2xlbis9Mn1lbHNlIGlmKGM+PTU1Mjk2JiZjPD01NzM0Myl7bGVuKz00OysraX1lbHNle2xlbis9M319cmV0dXJuIGxlbn07dmFyIHN0cmluZ1RvVVRGOEFycmF5PShzdHIsaGVhcCxvdXRJZHgsbWF4Qnl0ZXNUb1dyaXRlKT0+e2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXt2YXIgdTE9c3RyLmNoYXJDb2RlQXQoKytpKTt1PTY1NTM2KygodSYxMDIzKTw8MTApfHUxJjEwMjN9aWYodTw9MTI3KXtpZihvdXRJZHg+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT11fWVsc2UgaWYodTw9MjA0Nyl7aWYob3V0SWR4KzE+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0xOTJ8dT4+NjtoZWFwW291dElkeCsrXT0xMjh8dSY2M31lbHNlIGlmKHU8PTY1NTM1KXtpZihvdXRJZHgrMj49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTIyNHx1Pj4xMjtoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2M31lbHNle2lmKG91dElkeCszPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjQwfHU+PjE4O2hlYXBbb3V0SWR4KytdPTEyOHx1Pj4xMiY2MztoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2M319aGVhcFtvdXRJZHhdPTA7cmV0dXJuIG91dElkeC1zdGFydElkeH07dmFyIHN0cmluZ1RvVVRGOD0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT5zdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUFU4LG91dFB0cixtYXhCeXRlc1RvV3JpdGUpO3ZhciBzdHJpbmdUb1VURjhPblN0YWNrPXN0cj0+e3ZhciBzaXplPWxlbmd0aEJ5dGVzVVRGOChzdHIpKzE7dmFyIHJldD1zdGFja0FsbG9jKHNpemUpO3N0cmluZ1RvVVRGOChzdHIscmV0LHNpemUpO3JldHVybiByZXR9O3ZhciB3YXNtSW1wb3J0cz17YjpfX19jeGFfdGhyb3csZDpfYWJvcnQsZTpfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLGM6X2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsYTpfZmRfd3JpdGV9O3ZhciBhc209Y3JlYXRlV2FzbSgpO3ZhciBfX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oX19fd2FzbV9jYWxsX2N0b3JzPU1vZHVsZVtcImFzbVwiXVtcImdcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9hbGxvY2F0aW9uPU1vZHVsZVtcIl9hbGxvY2F0aW9uXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9hbGxvY2F0aW9uPU1vZHVsZVtcIl9hbGxvY2F0aW9uXCJdPU1vZHVsZVtcImFzbVwiXVtcImlcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9nZXRNYXRyaXhCdWZmZXJQdHI9TW9kdWxlW1wiX2dldE1hdHJpeEJ1ZmZlclB0clwiXT1mdW5jdGlvbigpe3JldHVybihfZ2V0TWF0cml4QnVmZmVyUHRyPU1vZHVsZVtcIl9nZXRNYXRyaXhCdWZmZXJQdHJcIl09TW9kdWxlW1wiYXNtXCJdW1wialwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2dldFNSVFB0cj1Nb2R1bGVbXCJfZ2V0U1JUUHRyXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9nZXRTUlRQdHI9TW9kdWxlW1wiX2dldFNSVFB0clwiXT1Nb2R1bGVbXCJhc21cIl1bXCJrXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZ2V0SW5mb1B0cj1Nb2R1bGVbXCJfZ2V0SW5mb1B0clwiXT1mdW5jdGlvbigpe3JldHVybihfZ2V0SW5mb1B0cj1Nb2R1bGVbXCJfZ2V0SW5mb1B0clwiXT1Nb2R1bGVbXCJhc21cIl1bXCJsXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZ2V0Q29udGludWVkU1JUUHRyPU1vZHVsZVtcIl9nZXRDb250aW51ZWRTUlRQdHJcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2dldENvbnRpbnVlZFNSVFB0cj1Nb2R1bGVbXCJfZ2V0Q29udGludWVkU1JUUHRyXCJdPU1vZHVsZVtcImFzbVwiXVtcIm1cIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9wcmludE1hdHJpeD1Nb2R1bGVbXCJfcHJpbnRNYXRyaXhcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX3ByaW50TWF0cml4PU1vZHVsZVtcIl9wcmludE1hdHJpeFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJuXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfdXBkYXRlQWxsTWF0cml4Q29udGludWVUcmFuc2Zvcm09TW9kdWxlW1wiX3VwZGF0ZUFsbE1hdHJpeENvbnRpbnVlVHJhbnNmb3JtXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF91cGRhdGVBbGxNYXRyaXhDb250aW51ZVRyYW5zZm9ybT1Nb2R1bGVbXCJfdXBkYXRlQWxsTWF0cml4Q29udGludWVUcmFuc2Zvcm1cIl09TW9kdWxlW1wiYXNtXCJdW1wib1wiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX21haW49TW9kdWxlW1wiX21haW5cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21haW49TW9kdWxlW1wiX21haW5cIl09TW9kdWxlW1wiYXNtXCJdW1wicFwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19fZXJybm9fbG9jYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4oX19fZXJybm9fbG9jYXRpb249TW9kdWxlW1wiYXNtXCJdW1wiX19lcnJub19sb2NhdGlvblwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihzdGFja0FsbG9jPU1vZHVsZVtcImFzbVwiXVtcInFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4oX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1Nb2R1bGVbXCJhc21cIl1bXCJyXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBjYWxsZWRSdW47ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPWZ1bmN0aW9uIHJ1bkNhbGxlcigpe2lmKCFjYWxsZWRSdW4pcnVuKCk7aWYoIWNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyfTtmdW5jdGlvbiBjYWxsTWFpbihhcmdzPVtdKXt2YXIgZW50cnlGdW5jdGlvbj1fbWFpbjthcmdzLnVuc2hpZnQodGhpc1Byb2dyYW0pO3ZhciBhcmdjPWFyZ3MubGVuZ3RoO3ZhciBhcmd2PXN0YWNrQWxsb2MoKGFyZ2MrMSkqNCk7dmFyIGFyZ3ZfcHRyPWFyZ3Y+PjI7YXJncy5mb3JFYWNoKChhcmc9PntIRUFQMzJbYXJndl9wdHIrK109c3RyaW5nVG9VVEY4T25TdGFjayhhcmcpfSkpO0hFQVAzMlthcmd2X3B0cl09MDt0cnl7dmFyIHJldD1lbnRyeUZ1bmN0aW9uKGFyZ2MsYXJndik7ZXhpdEpTKHJldCx0cnVlKTtyZXR1cm4gcmV0fWNhdGNoKGUpe3JldHVybiBoYW5kbGVFeGNlcHRpb24oZSl9fWZ1bmN0aW9uIHJ1bihhcmdzPWFyZ3VtZW50c18pe2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59cHJlUnVuKCk7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1mdW5jdGlvbiBkb1J1bigpe2lmKGNhbGxlZFJ1bilyZXR1cm47Y2FsbGVkUnVuPXRydWU7TW9kdWxlW1wiY2FsbGVkUnVuXCJdPXRydWU7aWYoQUJPUlQpcmV0dXJuO2luaXRSdW50aW1lKCk7cHJlTWFpbigpO2lmKE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKU1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7aWYoc2hvdWxkUnVuTm93KWNhbGxNYWluKGFyZ3MpO3Bvc3RSdW4oKX1pZihNb2R1bGVbXCJzZXRTdGF0dXNcIl0pe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlJ1bm5pbmcuLi5cIik7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlwiKX0pLDEpO2RvUnVuKCl9KSwxKX1lbHNle2RvUnVuKCl9fWlmKE1vZHVsZVtcInByZUluaXRcIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlSW5pdFwiXT1bTW9kdWxlW1wicHJlSW5pdFwiXV07d2hpbGUoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGg+MCl7TW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpfX12YXIgc2hvdWxkUnVuTm93PXRydWU7aWYoTW9kdWxlW1wibm9Jbml0aWFsUnVuXCJdKXNob3VsZFJ1bk5vdz1mYWxzZTtydW4oKTtcblxuaWYgKCFNb2R1bGVbJ0VOVklST05NRU5UX0lTX1BUSFJFQUQnXSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiaXMgbWFpblwiKTtcbiAgICB3aW5kb3dbJ3dhc21NYXRyaXgnXSA9IE1vZHVsZTtcbn1cbiAgICAgICAgYCxTaT1jbGFzc3tzdGF0aWMgYXN5bmMgaW5pdChpKXthd2FpdCBuZXcgUHJvbWlzZShlPT57Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO3QuYXN5bmM9ITAsdC50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIsdC5zcmM9VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJGZdKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0KSx0Lm9ubG9hZD0oKT0+e2xldCByPSgpPT57dGhpcy53YXNtPXdpbmRvdy53YXNtTWF0cml4LHRoaXMud2FzbSYmdGhpcy53YXNtLmNhbGxlZFJ1bj9lKCEwKTpzZXRUaW1lb3V0KHIsMjApfTtyKCl9fSksdGhpcy5hbGxvY01hdHJpeChpKX1zdGF0aWMgYWxsb2NNYXRyaXgoaSl7aT5WLm1heENvdW50JiZjb25zb2xlLmVycm9yKGBUaGUgbWF4aW11bSBhbGxvY2F0aW9uIHNpemUgaXMgZXhjZWVkZWQhIGN1cnJlbnQ6JHtpfSwgbGltaXQ6JHtWLm1heENvdW50fWApLHRoaXMud2FzbS5fYWxsb2NhdGlvbihpKSx0aGlzLm1hdHJpeEJ1ZmZlclB0cj10aGlzLndhc20uX2dldE1hdHJpeEJ1ZmZlclB0cigpLHRoaXMubWF0cml4U1JUQnVmZmVyUHRyPXRoaXMud2FzbS5fZ2V0U1JUUHRyKCksdGhpcy5tYXRyaXhTdGF0ZUJ1ZmZlclB0cj10aGlzLndhc20uX2dldEluZm9QdHIoKSx0aGlzLm1hdHJpeENvbnRpbnVlZFNSVEJ1ZmZlclB0cj10aGlzLndhc20uX2dldENvbnRpbnVlZFNSVFB0cigpLHRoaXMubWF0cml4QnVmZmVyPW5ldyBGbG9hdDMyQXJyYXkodGhpcy53YXNtLkhFQVBGMzIuYnVmZmVyLHRoaXMubWF0cml4QnVmZmVyUHRyLDE2KmkpLHRoaXMubWF0cml4U1JUQnVmZmVyPW5ldyBGbG9hdDMyQXJyYXkodGhpcy53YXNtLkhFQVBGMzIuYnVmZmVyLHRoaXMubWF0cml4U1JUQnVmZmVyUHRyLDMqMyppKSx0aGlzLm1hdHJpeENvbnRpbnVlZFNSVEJ1ZmZlcj1uZXcgRmxvYXQzMkFycmF5KHRoaXMud2FzbS5IRUFQRjMyLmJ1ZmZlcix0aGlzLm1hdHJpeENvbnRpbnVlZFNSVEJ1ZmZlclB0ciwzKjMqaSksdGhpcy5tYXRyaXhTdGF0ZUJ1ZmZlcj1uZXcgSW50MzJBcnJheSh0aGlzLndhc20uSEVBUDMyLmJ1ZmZlcix0aGlzLm1hdHJpeFN0YXRlQnVmZmVyUHRyLFNpLnN0YXRlU3RydWN0KmkpLFYuYWxsb2NNYXRyaXgoaSl9c3RhdGljIHVwZGF0ZUFsbENvbnRpbnVlVHJhbnNmb3JtKGksZSx0KXt0aGlzLndhc20uX3VwZGF0ZUFsbE1hdHJpeENvbnRpbnVlVHJhbnNmb3JtKGksZSx0KX1zdGF0aWMgc2V0UGFyZW50KGksZSx0KXt0aGlzLm1hdHJpeFN0YXRlQnVmZmVyW2kqU2kuc3RhdGVTdHJ1Y3QrMl09ZT49MD9lOi0xLHRoaXMubWF0cml4U3RhdGVCdWZmZXJbaSpTaS5zdGF0ZVN0cnVjdCszXT10fXN0YXRpYyBzZXRUcmFuc2xhdGUoaSxlLHQscil7dGhpcy5tYXRyaXhTUlRCdWZmZXJbaSo5KzZdPWUsdGhpcy5tYXRyaXhTUlRCdWZmZXJbaSo5KzddPXQsdGhpcy5tYXRyaXhTUlRCdWZmZXJbaSo5KzhdPXJ9c3RhdGljIHNldFJvdGF0aW9uKGksZSx0LHIpe3RoaXMubWF0cml4U1JUQnVmZmVyW2kqOSszXT1lJTM2MCx0aGlzLm1hdHJpeFNSVEJ1ZmZlcltpKjkrNF09dCUzNjAsdGhpcy5tYXRyaXhTUlRCdWZmZXJbaSo5KzVdPXIlMzYwfXN0YXRpYyBzZXRTY2FsZShpLGUsdCxyKXt0aGlzLm1hdHJpeFNSVEJ1ZmZlcltpKjkrMF09ZSx0aGlzLm1hdHJpeFNSVEJ1ZmZlcltpKjkrMV09dCx0aGlzLm1hdHJpeFNSVEJ1ZmZlcltpKjkrMl09cn1zdGF0aWMgc2V0Q29udGludWVUcmFuc2xhdGUoaSxlLHQscil7KGUhPTB8fHQhPTB8fHIhPTApJiYodGhpcy5tYXRyaXhDb250aW51ZWRTUlRCdWZmZXJbaSo5KzZdPWUsdGhpcy5tYXRyaXhDb250aW51ZWRTUlRCdWZmZXJbaSo5KzddPXQsdGhpcy5tYXRyaXhDb250aW51ZWRTUlRCdWZmZXJbaSo5KzhdPXIsdGhpcy5tYXRyaXhTdGF0ZUJ1ZmZlcltpKlNpLnN0YXRlU3RydWN0KzFdPTEpfXN0YXRpYyBzZXRDb250aW51ZVJvdGF0aW9uKGksZSx0LHIpeyhlIT0wfHx0IT0wfHxyIT0wKSYmKHRoaXMubWF0cml4Q29udGludWVkU1JUQnVmZmVyW2kqOSszXT1lLHRoaXMubWF0cml4Q29udGludWVkU1JUQnVmZmVyW2kqOSs0XT10LHRoaXMubWF0cml4Q29udGludWVkU1JUQnVmZmVyW2kqOSs1XT1yLHRoaXMubWF0cml4U3RhdGVCdWZmZXJbaSpTaS5zdGF0ZVN0cnVjdCsxXT0xKX1zdGF0aWMgc2V0Q29udGludWVTY2FsZShpLGUsdCxyKXsoZSE9MHx8dCE9MHx8ciE9MCkmJih0aGlzLm1hdHJpeENvbnRpbnVlZFNSVEJ1ZmZlcltpKjkrMF09ZSx0aGlzLm1hdHJpeENvbnRpbnVlZFNSVEJ1ZmZlcltpKjkrMV09dCx0aGlzLm1hdHJpeENvbnRpbnVlZFNSVEJ1ZmZlcltpKjkrMl09cix0aGlzLm1hdHJpeFN0YXRlQnVmZmVyW2kqU2kuc3RhdGVTdHJ1Y3QrMV09MSl9fTtsZXQgZWU9U2k7byhlZSxcIm1hdHJpeEJ1ZmZlclwiKSxvKGVlLFwibWF0cml4U1JUQnVmZmVyXCIpLG8oZWUsXCJtYXRyaXhDb250aW51ZWRTUlRCdWZmZXJcIiksbyhlZSxcIm1hdHJpeFN0YXRlQnVmZmVyXCIpLG8oZWUsXCJtYXRyaXhCdWZmZXJQdHJcIiksbyhlZSxcIm1hdHJpeFNSVEJ1ZmZlclB0clwiKSxvKGVlLFwibWF0cml4Q29udGludWVkU1JUQnVmZmVyUHRyXCIpLG8oZWUsXCJtYXRyaXhTdGF0ZUJ1ZmZlclB0clwiKSxvKGVlLFwid2FzbVwiKSxvKGVlLFwic3RhdGVTdHJ1Y3RcIiw0KTtjbGFzcyB5dHt9byh5dCxcIkFYSVNfQU5HTEVcIixcImF4aXNBbmdsZVwiKSxvKHl0LFwiRVVMRVJfQU5HTEVTXCIsXCJldWxlckFuZ2xlc1wiKSxvKHl0LFwiUVVBVEVSTklPTlwiLFwicXVhdGVybmlvblwiKTtjb25zdCBkdD1jbGFzc3tjb25zdHJ1Y3RvcihpPTAsZT0wLHQ9MCxyPTEpe28odGhpcyxcInhcIiwwKSxvKHRoaXMsXCJ5XCIsMCksbyh0aGlzLFwielwiLDApLG8odGhpcyxcIndcIiwxKSx0aGlzLng9aSx0aGlzLnk9ZSx0aGlzLno9dCx0aGlzLnc9cn1zdGF0aWMgaWRlbnRpdHkoKXtyZXR1cm4gZHQuX3plcm99c3RhdGljIHF1YXRlcm5pb25Ub01hdHJpeChpLGUpe2xldCB0PWkueCoyLHI9aS55KjIscz1pLnoqMixhPWkueCp0LG49aS55KnIsbD1pLnoqcyxoPWkueCpyLHU9aS54KnMsYz1pLnkqcyxmPWkudyp0LGQ9aS53KnIscD1pLncqcztlLnJhd0RhdGFbMF09MS0obitsKSxlLnJhd0RhdGFbMV09aCtwLGUucmF3RGF0YVsyXT11LWQsZS5yYXdEYXRhWzNdPTAsZS5yYXdEYXRhWzRdPWgtcCxlLnJhd0RhdGFbNV09MS0oYStsKSxlLnJhd0RhdGFbNl09YytmLGUucmF3RGF0YVs3XT0wLGUucmF3RGF0YVs4XT11K2QsZS5yYXdEYXRhWzldPWMtZixlLnJhd0RhdGFbMTBdPTEtKGErbiksZS5yYXdEYXRhWzExXT0wLGUucmF3RGF0YVsxMl09MCxlLnJhd0RhdGFbMTNdPTAsZS5yYXdEYXRhWzE0XT0wLGUucmF3RGF0YVsxNV09MX1nZXQgbWFnbml0dWRlKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLncqdGhpcy53K3RoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56KX1zZXQoaT0wLGU9MCx0PTAscj0xKXt0aGlzLng9aSx0aGlzLnk9ZSx0aGlzLno9dCx0aGlzLnc9cn1kaXZpZGUoaSl7cmV0dXJuIGkgaW5zdGFuY2VvZiBkdD9uZXcgZHQodGhpcy54L2kueCx0aGlzLnkvaS55LHRoaXMuei9pLnopOih0aGlzLng9dGhpcy54L2ksdGhpcy55PXRoaXMueS9pLHRoaXMuej10aGlzLnovaSx0aGlzKX1zZXRGcm9tQXJyYXkoaSl7cmV0dXJuIHRoaXMueD1pWzBdLHRoaXMueT1pWzFdLHRoaXMuej1pWzJdLHRoaXMudz1pWzNdLHRoaXN9bXVsdGlwbHkoaSxlKXt2YXIgdD1pLncscj1pLngscz1pLnksYT1pLnosbj1lLncsbD1lLngsaD1lLnksdT1lLno7dGhpcy53PXQqbi1yKmwtcypoLWEqdSx0aGlzLng9dCpsK3IqbitzKnUtYSpoLHRoaXMueT10Kmgtcip1K3MqbithKmwsdGhpcy56PXQqdStyKmgtcypsK2Eqbn1tdWx0aXBseVZlY3RvcihpLGU9bnVsbCl7ZXx8KGU9bmV3IGR0KTt2YXIgdD1pLngscj1pLnkscz1pLno7cmV0dXJuIGUudz0tdGhpcy54KnQtdGhpcy55KnItdGhpcy56KnMsZS54PXRoaXMudyp0K3RoaXMueSpzLXRoaXMueipyLGUueT10aGlzLncqci10aGlzLngqcyt0aGlzLnoqdCxlLno9dGhpcy53KnMrdGhpcy54KnItdGhpcy55KnQsZX1mcm9tQXhpc0FuZ2xlKGksZSl7ZSo9TWF0aC5QSS8xODA7dmFyIHQ9ZSouNSxyPU1hdGguc2luKHQpO3RoaXMudz1NYXRoLmNvcyh0KSx0aGlzLng9aS54KnIsdGhpcy55PWkueSpyLHRoaXMuej1pLnoqcix0aGlzLm5vcm1hbGl6ZSgpfXRvQXhpc0FuZ2xlKGkpe3ZhciBlPXRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56LHQ9MDtyZXR1cm4gZT4wPyh0PTIqTWF0aC5hY29zKHRoaXMudyksZT0xL01hdGguc3FydChlKSxpLng9dGhpcy54KmUsaS55PXRoaXMueSplLGkuej10aGlzLnoqZSk6KHQ9MCxpLng9MSxpLnk9MCxpLno9MCksdH1zbGVycChpLGUsdCl7dmFyIHI9aS53LHM9aS54LGE9aS55LG49aS56LGw9ZS53LGg9ZS54LHU9ZS55LGM9ZS56LGY9cipsK3MqaCthKnUrbipjO2lmKGY8MCYmKGY9LWYsbD0tbCxoPS1oLHU9LXUsYz0tYyksZjwuOTUpe3ZhciBkPU1hdGguYWNvcyhmKSxwPTEvTWF0aC5zaW4oZCksbT1NYXRoLnNpbihkKigxLXQpKSpwLF89TWF0aC5zaW4oZCp0KSpwO3RoaXMudz1yKm0rbCpfLHRoaXMueD1zKm0raCpfLHRoaXMueT1hKm0rdSpfLHRoaXMuej1uKm0rYypffWVsc2V7dGhpcy53PXIrdCoobC1yKSx0aGlzLng9cyt0KihoLXMpLHRoaXMueT1hK3QqKHUtYSksdGhpcy56PW4rdCooYy1uKTt2YXIgdj0xL01hdGguc3FydCh0aGlzLncqdGhpcy53K3RoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56KTt0aGlzLncqPXYsdGhpcy54Kj12LHRoaXMueSo9dix0aGlzLnoqPXZ9fWxlcnAoaSxlLHQpe3ZhciByPWkudyxzPWkueCxhPWkueSxuPWkueixsPWUudyxoPWUueCx1PWUueSxjPWUueixmO3IqbCtzKmgrYSp1K24qYzwwJiYobD0tbCxoPS1oLHU9LXUsYz0tYyksdGhpcy53PXIrdCoobC1yKSx0aGlzLng9cyt0KihoLXMpLHRoaXMueT1hK3QqKHUtYSksdGhpcy56PW4rdCooYy1uKSxmPTEvTWF0aC5zcXJ0KHRoaXMudyp0aGlzLncrdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopLHRoaXMudyo9Zix0aGlzLngqPWYsdGhpcy55Kj1mLHRoaXMueio9Zn1mcm9tRXVsZXJBbmdsZXMoaSxlLHQpe2kqPV9lLGUqPV9lLHQqPV9lO3ZhciByPWkqLjUscz1lKi41LGE9dCouNSxuPU1hdGguY29zKHIpLGw9TWF0aC5zaW4ociksaD1NYXRoLmNvcyhzKSx1PU1hdGguc2luKHMpLGM9TWF0aC5jb3MoYSksZj1NYXRoLnNpbihhKTtyZXR1cm4gdGhpcy53PW4qaCpjK2wqdSpmLHRoaXMueD1sKmgqYy1uKnUqZix0aGlzLnk9bip1KmMrbCpoKmYsdGhpcy56PW4qaCpmLWwqdSpjLHRoaXN9c2V0RnJvbVJvdGF0aW9uTWF0cml4KGkpe2NvbnN0IGU9aS5yYXdEYXRhLHQ9ZVswXSxyPWVbNF0scz1lWzhdLGE9ZVsxXSxuPWVbNV0sbD1lWzldLGg9ZVsyXSx1PWVbNl0sYz1lWzEwXSxmPXQrbitjO2lmKGY+MCl7Y29uc3QgZD0uNS9NYXRoLnNxcnQoZisxKTt0aGlzLnc9LjI1L2QsdGhpcy54PSh1LWwpKmQsdGhpcy55PShzLWgpKmQsdGhpcy56PShhLXIpKmR9ZWxzZSBpZih0Pm4mJnQ+Yyl7Y29uc3QgZD0yKk1hdGguc3FydCgxK3Qtbi1jKTt0aGlzLnc9KHUtbCkvZCx0aGlzLng9LjI1KmQsdGhpcy55PShyK2EpL2QsdGhpcy56PShzK2gpL2R9ZWxzZSBpZihuPmMpe2NvbnN0IGQ9MipNYXRoLnNxcnQoMStuLXQtYyk7dGhpcy53PShzLWgpL2QsdGhpcy54PShyK2EpL2QsdGhpcy55PS4yNSpkLHRoaXMuej0obCt1KS9kfWVsc2V7Y29uc3QgZD0yKk1hdGguc3FydCgxK2MtdC1uKTt0aGlzLnc9KGEtcikvZCx0aGlzLng9KHMraCkvZCx0aGlzLnk9KGwrdSkvZCx0aGlzLno9LjI1KmR9cmV0dXJuIHRoaXN9Z2V0RXVsZXJBbmdsZXMoaSl7dmFyIGUsdCxyLHMsYSxuLGwsaDtyZXR1cm4gaXx8KGk9bmV3IGcpLHM9dGhpcy54LGE9dGhpcy55LG49dGhpcy56LGw9dGhpcy53LGg9MioobCphLXMqbiksaDw9LS45OTk5OT8oZT0yKk1hdGguYXRhbjIocyxsKSx0PS1NYXRoLlBJLzIscj0wKTpoPj0uOTk5OTk/KGU9MipNYXRoLmF0YW4yKHMsbCksdD1NYXRoLlBJLzIscj0wKTooZT1NYXRoLmF0YW4yKDIqKGwqcythKm4pLDEtMioocypzK2EqYSkpLHQ9TWF0aC5hc2luKGgpLHI9TWF0aC5hdGFuMigyKihsKm4rcyphKSwxLTIqKGEqYStuKm4pKSksaS5zZXQoZSx0LHIpLnNjYWxlQnkocWkpfW5vcm1hbGl6ZShpPTEpe3ZhciBlPWkvTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpO3RoaXMueCo9ZSx0aGlzLnkqPWUsdGhpcy56Kj1lLHRoaXMudyo9ZX10b1N0cmluZygpe3JldHVyblwie3g6XCIrdGhpcy54K1wiIHk6XCIrdGhpcy55K1wiIHo6XCIrdGhpcy56K1wiIHc6XCIrdGhpcy53K1wifVwifWZyb21NYXRyaXgoaSl7dmFyIGU9aS5kZWNvbXBvc2UoeXQuUVVBVEVSTklPTilbMV07dGhpcy54PWUueCx0aGlzLnk9ZS55LHRoaXMuej1lLnosdGhpcy53PWUud31pbnZlcnNlKGk9bnVsbCl7aXx8KGk9bmV3IGR0KTt2YXIgZT10aGlzLncqdGhpcy53K3RoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56O2lmKGU+MCl7dmFyIHQ9MS9lO2kudz10aGlzLncqdCxpLng9LXRoaXMueCp0LGkueT0tdGhpcy55KnQsaS56PS10aGlzLnoqdH1yZXR1cm4gaX1jbG9uZSgpe3JldHVybiBuZXcgZHQodGhpcy54LHRoaXMueSx0aGlzLnosdGhpcy53KX10cmFuc2Zvcm1WZWN0b3IoaSxlPW51bGwpe3ZhciB0LHIscyxhLG49aS54LGw9aS55LGg9aS56O3JldHVybiBlfHwoZT1uZXcgZyksYT0tdGhpcy54Km4tdGhpcy55KmwtdGhpcy56KmgsdD10aGlzLncqbit0aGlzLnkqaC10aGlzLnoqbCxyPXRoaXMudypsLXRoaXMueCpoK3RoaXMueipuLHM9dGhpcy53KmgrdGhpcy54KmwtdGhpcy55Km4sZS54PS1hKnRoaXMueCt0KnRoaXMudy1yKnRoaXMueitzKnRoaXMueSxlLnk9LWEqdGhpcy55K3QqdGhpcy56K3IqdGhpcy53LXMqdGhpcy54LGUuej0tYSp0aGlzLnotdCp0aGlzLnkrcip0aGlzLngrcyp0aGlzLncsZX1jb3B5RnJvbShpKXt2YXIgZT10aGlzO3JldHVybiBlLng9aS54LGUueT1pLnksZS56PWkueixlLnc9aS53LHRoaXN9bXVsKGksZSx0KXtsZXQgcj10fHxuZXcgZHQ7cmV0dXJuIHIueD1pLncqZS54K2kueCplLncraS55KmUuei1pLnoqZS55LHIueT1pLncqZS55K2kueSplLncraS56KmUueC1pLngqZS56LHIuej1pLncqZS56K2kueiplLncraS54KmUueS1pLnkqZS54LHIudz1pLncqZS53LWkueCplLngtaS55KmUueS1pLnoqZS56LHJ9Y2xhbXBmKGksZSx0KXtpZihlPnQpe3ZhciByPWU7ZT10LHQ9cn1yZXR1cm4gaTxlP2U6aTx0P2k6dH19O2xldCBxPWR0O28ocSxcIkhFTFBfMFwiLG5ldyBkdCgwLDAsMCwxKSksbyhxLFwiSEVMUF8xXCIsbmV3IGR0KDAsMCwwLDEpKSxvKHEsXCJIRUxQXzJcIixuZXcgZHQoMCwwLDAsMSkpLG8ocSxcIl96ZXJvXCIsbmV3IGR0KDAsMCwwLDEpKSxvKHEsXCJDQUxDVUxBVElPTl9RVUFURVJOSU9OXCIsbmV3IGR0KTtmdW5jdGlvbiBlZChpLGUsdCl7bGV0IHI9aS54KjIscz1pLnkqMixhPWkueioyLG49aS54KnIsbD1pLnkqcyxoPWkueiphLHU9aS54KnMsYz1pLngqYSxmPWkueSphLGQ9aS53KnIscD1pLncqcyxtPWkudyphLF89dHx8bmV3IGc7cmV0dXJuIF8ueD0oMS0obCtoKSkqZS54Kyh1LW0pKmUueSsoYytwKSplLnosXy55PSh1K20pKmUueCsoMS0obitoKSkqZS55KyhmLWQpKmUueixfLno9KGMtcCkqZS54KyhmK2QpKmUueSsoMS0obitsKSkqZS56LF99Y2xhc3MgQXN7Y29uc3RydWN0b3IoZT0wKXtvKHRoaXMsXCJfeFwiLDApLG8odGhpcyxcIl95XCIsMCksbyh0aGlzLFwiX3pcIiwwKSxvKHRoaXMsXCJfd1wiLDApLHRoaXMuc2VlZD1lfWdldCBzZWVkKCl7cmV0dXJuIHRoaXMuX3h9c2V0IHNlZWQoZSl7dGhpcy5feD1lLHRoaXMuX3k9dGhpcy5feCoxODEyNDMzMjUzKzEsdGhpcy5fej10aGlzLl95KjE4MTI0MzMyNTMrMSx0aGlzLl93PXRoaXMuX3oqMTgxMjQzMzI1MysxfXN0YXRpYyBnZXRGbG9hdEZyb21JbnQoZSl7cmV0dXJuIE1hdGguZmxvb3IoKGUmODM4ODYwNykqKDEvODM4ODYwNykpfXN0YXRpYyBnZXRCeXRlRnJvbUludChlKXtyZXR1cm4gZT4+MjMtOH1jbG9uZSgpe2xldCBlPW5ldyBBcztyZXR1cm4gZS5feD10aGlzLl94LGUuX3k9dGhpcy5feSxlLl96PXRoaXMuX3osZS5fdz10aGlzLl93LGV9Z2V0KCl7bGV0IGU9dGhpcy5feF50aGlzLl94PDwxMTtyZXR1cm4gdGhpcy5feD10aGlzLl95LHRoaXMuX3k9dGhpcy5feix0aGlzLl96PXRoaXMuX3csdGhpcy5fdz10aGlzLl93XnRoaXMuX3c+PjE5XihlXmU+PjgpfWdldEZsb2F0KCl7cmV0dXJuIGZsKHRoaXMuZ2V0KCkpfWdldFNpZ25lZEZsb2F0KCl7cmV0dXJuIHRoaXMuZ2V0RmxvYXQoKSoyLTF9fWxldCBxaT0xODAvTWF0aC5QSSxfZT1NYXRoLlBJLzE4MCx0ZD0yMTQ3NDgzNjQ3LGlkPS0yMTQ3NDgzNjQ3O2Z1bmN0aW9uIEsoaSxlLHQpe3JldHVybiBNYXRoLm1heChlLE1hdGgubWluKHQsaSkpfWNsYXNzIHN0e3N0YXRpYyBnYXVzc0Z1bmN0aW9uKGUsdCxyLHMpe2xldCBhPU1hdGgucG93KGUtciwyKSxuPTIqTWF0aC5wb3cocywyKSxsPS0xKihhL24pLGg9TWF0aC5wb3coTWF0aC5FLGwpO3JldHVybiBNYXRoLnJvdW5kKGgqdCl9c3RhdGljIGNvbXB1dGVHYXVzc2lhbihlLHQpe3JldHVybiAxL01hdGguc3FydCgyKk1hdGguUEkqdCkqTWF0aC5leHAoLShlKmUpLygyKnQqdCkpfXN0YXRpYyBnYXVzc0NvZWYoZSl7ZTwuNSYmKGU9LjUpO2xldCB0PU1hdGguZXhwKC43MjYqLjcyNikvZSxyPU1hdGguZXhwKC10KSxzPU1hdGguZXhwKC0yKnQpLGE9KDEtcikqKDEtcikvKDErMip0KnItcyksbj1hLGw9YSoodC0xKSpyLGg9YSoodCsxKSpyLHU9LWEqcyxjPTIqcixmPS1zLGQ9KG4rbCkvKDEtYy1mKSxwPShoK3UpLygxLWMtZik7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW24sbCxoLHUsYyxmLGQscF0pfXN0YXRpYyBjbGFtcGYoZSx0LHIpe2lmKHQ+cil7bGV0IHM9dDt0PXIscj1zfXJldHVybiBlPHQ/dDplPHI/ZTpyfXN0YXRpYyBub3JtYWxpemVBbmdsZShlKXtmb3IoO2U+MTgwOyllLT0zNjA7Zm9yKDtlPC0xODA7KWUrPTM2MDtyZXR1cm4gZX1zdGF0aWMgZnJhY3QoZSl7cmV0dXJuIGUtTWF0aC5mbG9vcihlKX1zdGF0aWMgZ2V0UmFuZERpclhaKGUpe2xldCB0PWUqTWF0aC5yYW5kb20oKSxyPTM2MCpNYXRoLnJhbmRvbSgpKl9lLHM9TWF0aC5jb3MocikqdCxhPU1hdGguc2luKHIpKnQ7cmV0dXJue3g6cyx6OmF9fXN0YXRpYyBnZXRSYW5kRGlyWFlaKGUpe2xldCB0PWUqTWF0aC5yYW5kb20oKSxyPTM2MCpNYXRoLnJhbmRvbSgpKl9lLHM9TWF0aC5jb3MocikqdCxhPU1hdGgudGFuKHIpKnQsbj1NYXRoLnNpbihyKSp0O3JldHVybiBuZXcgZyhzLGEsbil9c3RhdGljIGdldEN5Y2xlWFlaKGUpe2xldCB0PWUqTWF0aC5yYW5kb20oKSxyPTM2MCpNYXRoLnJhbmRvbSgpKl9lLHM9TWF0aC5jb3MocikqdCxhPWUqTWF0aC5yYW5kb20oKS1lKi41LG49TWF0aC5zaW4ocikqdDtyZXR1cm4gbmV3IGcocyxhLG4pfXN0YXRpYyBhbmdsZShlLHQpe2xldCByPVouSEVMUF8wLHM9Wi5IRUxQXzE7cmV0dXJuIHIuc2V0KGUueCxlLnopLHMuc2V0KHQueCx0LnopLE1hdGguYWNvcygoci54KnMueCtyLnkqcy55KS8oci5hYnMoKSpzLmFicygpKSl9c3RhdGljIGFuZ2xlXzM2MChlLHQpe2xldCByPWcuSEVMUF8wO3JldHVybiBlLmNyb3NzUHJvZHVjdCh0LHIpLHIuej4wP3N0LmFuZ2xlKGUsdCk6MzYwLXN0LmFuZ2xlKGUsdCl9Z2V0Um90YXRpb25ZKGUpe3JldHVybiBzdC5ub3JtYWxpemVBbmdsZShNYXRoLmF0YW4yKGUueixlLngpKnFpKX1zdGF0aWMgZnJvbVRvUm90YXRpb24oZSx0LHI9bnVsbCl7cnx8KHI9bmV3IHEpO2xldCBzPVYuaGVscF9tYXRyaXhfMjtyZXR1cm4gVi5mcm9tVG9Sb3RhdGlvbihlLHQscyksci5mcm9tTWF0cml4KHMpLHJ9c3RhdGljIGdldEV1bGFyRGlyX3lVcChlKXtsZXQgdD1xLkhFTFBfMDtyZXR1cm4gdC5mcm9tRXVsZXJBbmdsZXMoMCxlLDApLHQudHJhbnNmb3JtVmVjdG9yKGcuWl9BWElTLGcuSEVMUF81KSxnLkhFTFBfNX1zdGF0aWMgdHJhbnNmb3JtVmVjdG9yKGUsdCxyPW51bGwpe3J8fChyPW5ldyBnKTtsZXQgcz1lLnJhd0RhdGEsYT1zWzBdLG49c1sxXSxsPXNbMl0saD1zWzNdLHU9c1s0XSxjPXNbNV0sZj1zWzZdLGQ9c1s3XSxwPXNbOF0sbT1zWzldLF89c1sxMF0sdj1zWzExXSx5PXNbMTJdLEM9c1sxM10sQj1zWzE0XSxUPXNbMTVdLE09dC54LEQ9dC55LFA9dC56O3JldHVybiByLng9YSpNK3UqRCtwKlAreSxyLnk9bipNK2MqRCttKlArQyxyLno9bCpNK2YqRCtfKlArQixyLnc9aCpNK2QqRCt2KlArVCxyfX1sZXQgSWk9ZnVuY3Rpb24oaSxlLHQpe3JldHVybiBpKigxLXQpK2UqdH07ZnVuY3Rpb24gcmQoaSxlLHQpe2xldCByPW5ldyBnLHM9aS54LGE9aS55LG49aS56LGw9aS53LGg9ZS54LHU9ZS55LGM9ZS56LGY9ZS53O3JldHVybiByLng9KGgtcykqdCtzLHIueT0odS1hKSp0K2Esci56PShjLW4pKnQrbixyLnc9KGYtbCkqdCtsLHJ9ZnVuY3Rpb24gc2QoaSxlLHQpe2xldCByPW5ldyB6O3JldHVybiByLnI9KDEtdCkqaS5yK3QqZS5yLHIuZz0oMS10KSppLmcrdCplLmcsci5iPSgxLXQpKmkuYit0KmUuYixyLmE9KDEtdCkqaS5hK3QqZS5hLHJ9ZnVuY3Rpb24gYWQoaSxlLHQpe3JldHVybiBpKygoZS1pKSp0Pj44KSYyNTV9bGV0IEphPWZ1bmN0aW9uKGksZSx0KXtsZXQgcj10LWU7cmV0dXJuIE1hdGguZmxvb3IoaS9yKSUyPT0wP2klcitlOnQtaSVyK2V9LFphPWZ1bmN0aW9uKGksZSx0KXtsZXQgcj10LWU7cmV0dXJuIGklcitlfSxvZD1mdW5jdGlvbihpLGUpe2xldCB0PTA7Zm9yKGxldCByIGluIGkpcj09ZSYmdCsrO3JldHVybiB0fTtjbGFzcyBuZHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcInhcIiwwKSxvKHRoaXMsXCJ5XCIsMCksbyh0aGlzLFwielwiLDApLG8odGhpcyxcIndcIiwwKSxvKHRoaXMsXCJyYW5kU2VlZExpc3RcIiksdGhpcy5yYW5kU2VlZExpc3Q9W119cmVzZXQoKXt0aGlzLng9TWF0aC5yYW5kb20oKSoxLHRoaXMueT1NYXRoLnJhbmRvbSgpKjEsdGhpcy56PU1hdGgucmFuZG9tKCkqMSx0aGlzLnc9TWF0aC5yYW5kb20oKSoxLHRoaXMucmFuZFNlZWRMaXN0Lmxlbmd0aD0wO2ZvcihsZXQgZT0wO2U8MjA7ZSsrKXRoaXMucmFuZFNlZWRMaXN0LnB1c2goTWF0aC5yYW5kb20oKSoxKX19ZnVuY3Rpb24gZXQoaSxlKXtyZXR1cm4gaSBpbnN0YW5jZW9mIGcmJmUgaW5zdGFuY2VvZiBnfHxpIGluc3RhbmNlb2YgcSYmZSBpbnN0YW5jZW9mIHE/aS54KmUueCtpLnkqZS55K2kueiplLno6aS54KmUueCtpLnkqZS55fWZ1bmN0aW9uICRhKGksZSl7cmV0dXJuIG5ldyBnKGkueCplLngsaS55KmUueSxpLnoqZS56KX1mdW5jdGlvbiB1bChpKXtyZXR1cm4gTWF0aC5zcXJ0KGkpfWZ1bmN0aW9uIGVvKGkpe3JldHVybiB1bChldChpLGkpKX1mdW5jdGlvbiBjbChpLGUpe2lmKGVvKGkpPmcuRVBTSUxPTilyZXR1cm4gaS5kaXZpZGUoZW8oaSkpO2lmKGkgaW5zdGFuY2VvZiBaKXJldHVybiBuZXcgWjtpZihpIGluc3RhbmNlb2YgZylyZXR1cm4gbmV3IGc7aWYoaSBpbnN0YW5jZW9mIHEpcmV0dXJuIG5ldyBxfWZ1bmN0aW9uIGZsKGkpe3JldHVybihpJjgzODg2MDcpKigxLzgzODg2MDcpfWZ1bmN0aW9uIEtpKGkpe3JldHVybiBpLmdldEZsb2F0KCl9ZnVuY3Rpb24gcWUoaSxlLHQpe2xldCByPWkuZ2V0RmxvYXQoKTtyZXR1cm4gcj1lKnIrKDEtcikqdCxyfWZ1bmN0aW9uIGxkKGksZSx0KXtsZXQgcjtpZihlPHQpe3I9dC1lO2xldCBzPWkuZ2V0KCklcjtyZXR1cm4gcys9ZSxzfWVsc2UgaWYoZT50KXtyPWUtdDtsZXQgcz1pLmdldCgpJXI7cmV0dXJuIHM9ZS1zLHN9ZWxzZSByZXR1cm4gZX1mdW5jdGlvbiBQcyhpKXtsZXQgZT1xZShpLC0xLDEpLHQ9cWUoaSwwLDIqTWF0aC5QSSkscj1NYXRoLnNxcnQoMS1lKmUpLHM9cipNYXRoLmNvcyh0KSxhPXIqTWF0aC5zaW4odCk7cmV0dXJuIG5ldyBnKHMsYSxlKX1mdW5jdGlvbiBkbChpKXtsZXQgZT1xZShpLDAsMipNYXRoLlBJKSx0PU1hdGguY29zKGUpLHI9TWF0aC5zaW4oZSk7cmV0dXJuIG5ldyBaKHQscil9ZnVuY3Rpb24gaGQoaSl7bGV0IGU9bmV3IHE7cmV0dXJuIGUueD1xZShpLC0xLDEpLGUueT1xZShpLC0xLDEpLGUuej1xZShpLC0xLDEpLGUudz1xZShpLC0xLDEpLGU9Y2woZSksZXQoZSxxLmlkZW50aXR5KCkpPDA/LWU6ZX1mdW5jdGlvbiB1ZChpKXtjb25zdCBlPTIqTWF0aC5QSTtsZXQgdD1xZShpLDAsMSkscj1xZShpLDAsZSkscz1xZShpLDAsZSksYT1NYXRoLnNxcnQoMS10KSxuPU1hdGguc3FydCh0KSxsPW5ldyBxKGEqTWF0aC5zaW4ociksYSpNYXRoLmNvcyhyKSxuKk1hdGguc2luKHMpLG4qTWF0aC5jb3MocykpO3JldHVybiBldChsLHEuaWRlbnRpdHkoKSk8MD8tbDpsfWZ1bmN0aW9uIGNkKGksZSl7cmV0dXJuIG5ldyBnKHFlKGksLWUueCxlLngpLHFlKGksLWUueSxlLnkpLHFlKGksLWUueixlLnopKX1mdW5jdGlvbiBnbChpKXtsZXQgZT1QcyhpKTtyZXR1cm4gZS5zY2FsZUJ5KE1hdGgucG93KEtpKGkpLDEvMykpLGV9ZnVuY3Rpb24gZmQoaSxlKXtyZXR1cm4gJGEoZ2woaSksZSl9ZnVuY3Rpb24gZGQoaSxlLHQpe2xldCByPVBzKGkpLHM9TWF0aC5wb3cocWUoaSwwLDEpLDEvMyk7cmV0dXJuIHIuc2NhbGVCeShlKyh0LWUpKnMpLHJ9ZnVuY3Rpb24gZ2QoaSl7bGV0IGU9ZGwoaSk7cmV0dXJuIGUubXVsdGlwbHkoTWF0aC5wb3cocWUoaSwwLDEpLDEvMiksZSksZX1mdW5jdGlvbiBwZChpLGUsdCl7bGV0IHI9JGEoUHMoaSksZSkscz1NYXRoLnBvdyhxZShpLHQsMSksMS8zKTtyZXR1cm4gci5zY2FsZUJ5KHMpLHJ9ZnVuY3Rpb24gbWQoaSl7bGV0IGU9aS5nZXRGbG9hdCgpLHQ9aS5nZXRGbG9hdCgpO2UrdD4xJiYoZT0xLWUsdD0xLXQpO2xldCByPTEtZS10O3JldHVybiBuZXcgZyhlLHQscil9ZnVuY3Rpb24gQWQoaSl7cmV0dXJuIGkvMzYwKjIqTWF0aC5QSX1mdW5jdGlvbiBfZChpKXtyZXR1cm4gMTgwKmkvTWF0aC5QSX1mdW5jdGlvbiB4ZChpKXtyZXR1cm4gTWF0aC5zaW4oaSl9ZnVuY3Rpb24gdmQoaSl7cmV0dXJuIE1hdGguY29zKGkpfWxldCBwbD00OTE5O2Z1bmN0aW9uIHlkKCl7cmV0dXJuKytwbH1mdW5jdGlvbiBDZChpLGUsdCl7bGV0IHI9aVtlXSxzPWlbdF07aVtlXT1zLGlbdF09cn1mdW5jdGlvbiBtbChpKXtyZXR1cm4gTWF0aC5mbG9vcihpKX1mdW5jdGlvbiB0byhpKXtyZXR1cm4gbWwoaSsuNSl9ZnVuY3Rpb24gd2QoaSl7cmV0dXJuIGk9TWF0aC5tYXgoaSwwKSxpPU1hdGgubWluKGksMSksdG8oaSo2NTUzNSl9ZnVuY3Rpb24gYmQoaSl7cmV0dXJuIGk9TWF0aC5tYXgoaSwwKSxpPU1hdGgubWluKGksMSksdG8oaSoyNTUpfWZ1bmN0aW9uIEFsKGkpe3JldHVybiBNYXRoLmFicyhpKT09MD9pOjEvTWF0aC5zcXJ0KGkpfWZ1bmN0aW9uIFNkKGkpe2xldCBlPWlvKGkpO3JldHVybiBpLnNjYWxlQnkoQWwoZSkpfWZ1bmN0aW9uIElkKGksZSl7cmV0dXJuIGkuY3Jvc3NQcm9kdWN0KGUpfWZ1bmN0aW9uIGlvKGkpe3JldHVybiBldChpLGkpfWZ1bmN0aW9uIEVkKGkpe2xldCBlPW5ldyBBcyhpKTtyZXR1cm4gS2koZSl9ZnVuY3Rpb24gQmQoaSxlKXtsZXQgdD1uZXcgQXMoZSk7aS54PUtpKHQpLGkueT1LaSh0KSxpLno9S2kodCl9ZnVuY3Rpb24gVGQoaSxlLHQpe3JldHVybiBpPGU/dDppPnQ/ZTppfWZ1bmN0aW9uIHJvKGksZSl7cmV0dXJuIGktTWF0aC5mbG9vcihpL2UpKmV9Y29uc3QgTWQ9MWUtNixGPWNsYXNze2NvbnN0cnVjdG9yKGk9ITEpe2lmKG8odGhpcyxcImluZGV4XCIsMCksbyh0aGlzLFwib2Zmc2V0XCIsMCksbyh0aGlzLFwicmF3RGF0YVwiKSxvKHRoaXMsXCJfcG9zaXRpb25cIiksRi51c2VDb3VudD49Ri5hbGxvY0NvdW50KXtsZXQgZT1GLmFsbG9jQ291bnQrRi5hbGxvY09uY2VDb3VudDtlZS5hbGxvY01hdHJpeChlKX10aGlzLmluZGV4PUYudXNlQ291bnQsdGhpcy5vZmZzZXQ9Ri53YXNtTWF0cml4UHRyK3RoaXMuaW5kZXgqRi5ibG9ja0J5dGVzLEYuZHluYW1pY0dsb2JhbE1hdHJpeFJlZlt0aGlzLmluZGV4XT10aGlzLEYudXNlQ291bnQrKyx0aGlzLnJhd0RhdGE9bmV3IEZsb2F0MzJBcnJheShGLmR5bmFtaWNNYXRyaXhCeXRlcy5idWZmZXIsdGhpcy5vZmZzZXQsMTYpLHRoaXMuX3Bvc2l0aW9uPW5ldyBnLHRoaXMuaWRlbnRpdHkoKX1zdGF0aWMgYWxsb2NNYXRyaXgoaSl7dGhpcy5hbGxvY0NvdW50PWksRi5keW5hbWljTWF0cml4Qnl0ZXM9ZWUubWF0cml4QnVmZmVyLEYuYnVmZmVyPUYuZHluYW1pY01hdHJpeEJ5dGVzLmJ1ZmZlcixGLndhc21NYXRyaXhQdHI9ZWUubWF0cml4QnVmZmVyUHRyLHRoaXMuZHluYW1pY0dsb2JhbE1hdHJpeFJlZnx8KHRoaXMuZHluYW1pY0dsb2JhbE1hdHJpeFJlZj1bXSksdGhpcy5keW5hbWljR2xvYmFsTWF0cml4UmVmLmZvckVhY2goZT0+e2Uub2Zmc2V0PUYud2FzbU1hdHJpeFB0citlLmluZGV4KkYuYmxvY2tCeXRlcyxlLnJhd0RhdGE9bmV3IEZsb2F0MzJBcnJheShGLmR5bmFtaWNNYXRyaXhCeXRlcy5idWZmZXIsZS5vZmZzZXQsMTYpfSksRi5oZWxwX21hdHJpeF8wfHwoRi5oZWxwX21hdHJpeF8wPW5ldyBGKSxGLmhlbHBfbWF0cml4XzF8fChGLmhlbHBfbWF0cml4XzE9bmV3IEYpLEYuaGVscF9tYXRyaXhfMnx8KEYuaGVscF9tYXRyaXhfMj1uZXcgRiksRi5oZWxwTWF0cml4fHwoRi5oZWxwTWF0cml4PW5ldyBGKSxGLmhlbHBNYXRyaXgyfHwoRi5oZWxwTWF0cml4Mj1uZXcgRiksRi5fZ2V0RXVsZXJNYXRyaXh8fChGLl9nZXRFdWxlck1hdHJpeD1uZXcgRiksRi5fZ2V0RXVsZXJNYXRyaXguaWRlbnRpdHkoKX1zdGF0aWMgZnJvbVRvUm90YXRpb24oaSxlLHQpe3JldHVybiB0fHwodD1uZXcgRiksdC50cmFuc2Zvcm1EaXIoaSxlKSx0fXN0YXRpYyBnZXRBeGlzUm90YXRpb24oaSxlLHQscil7bGV0IHM9bmV3IEYsYT1yKihNYXRoLlBJLzE4MCksbj1NYXRoLmNvcyhhKSxsPU1hdGguc2luKGEpLGg9MS1uLHUsYztyZXR1cm4gcy5yYXdEYXRhWzBdPW4raSppKmgscy5yYXdEYXRhWzVdPW4rZSplKmgscy5yYXdEYXRhWzEwXT1uK3QqdCpoLHU9aSplKmgsYz10Kmwscy5yYXdEYXRhWzFdPXUrYyxzLnJhd0RhdGFbNF09dS1jLHU9aSp0KmgsYz1lKmwscy5yYXdEYXRhWzhdPXUrYyxzLnJhd0RhdGFbMl09dS1jLHU9ZSp0KmgsYz1pKmwscy5yYXdEYXRhWzldPXUtYyxzLnJhd0RhdGFbNl09dStjLHN9c3RhdGljIHNhbml0aXplRXVsZXIoaSl7Ri5tYWtlUG9zaXRpdmUoaSl9c3RhdGljIG1ha2VQb3NpdGl2ZShpKXtsZXQgZT0tMWUtNCx0PU1hdGguUEkqMi0xZS00O2kueDxlP2kueCs9MipNYXRoLlBJOmkueD50JiYoaS54LT0yKk1hdGguUEkpLGkueTxlP2kueSs9MipNYXRoLlBJOmkueT50JiYoaS55LT0yKk1hdGguUEkpLGkuejxlP2kueis9MipNYXRoLlBJOmkuej50JiYoaS56LT0yKk1hdGguUEkpfXN0YXRpYyBtYXRyaXhUb0V1bGVyKGksZSl7cmV0dXJuIGkuZ2V0KDEsMik8Ljk5OT9pLmdldCgxLDIpPi0uOTk5PyhlLng9TWF0aC5hc2luKC1pLmdldCgxLDIpKSxlLnk9TWF0aC5hdGFuMihpLmdldCgwLDIpLGkuZ2V0KDIsMikpLGUuej1NYXRoLmF0YW4yKGkuZ2V0KDEsMCksaS5nZXQoMSwxKSksRi5zYW5pdGl6ZUV1bGVyKGUpLCEwKTooZS54PU1hdGguUEkqLjUsZS55PU1hdGguYXRhbjIoaS5nZXQoMCwxKSxpLmdldCgwLDApKSxlLno9MCxGLnNhbml0aXplRXVsZXIoZSksITEpOihlLng9LU1hdGguUEkqLjUsZS55PU1hdGguYXRhbjIoLWkuZ2V0KDAsMSksaS5nZXQoMCwwKSksZS56PTAsRi5zYW5pdGl6ZUV1bGVyKGUpLCExKX1zdGF0aWMgbWF0cml4TXVsdGlwbHkoaSxlLHQpe0Yud2FzbS5NYXRyaXhfTXVsdGlwbHkoaS5pbmRleCxlLmluZGV4LHQuaW5kZXgpfXN0YXRpYyBtYXRyaXhBcHBlbmQoaSxlLHQpe0Yud2FzbS5NYXRyaXhfQXBwZW5kKGkuaW5kZXgsZS5pbmRleCx0LmluZGV4KX1zdGF0aWMgbWF0cml4Um90YXRlWShpLGUpe0Yud2FzbS5NYXRyaXhfQXBwZW5kKGksZS5pbmRleCl9c3RhdGljIG1hdHJpeFJvdGF0ZShpLGUsdCl7Ri53YXNtLk1hdHJpeF9Sb3RhdGUoaSxlLHQuaW5kZXgpfWxvb2tBdChpLGUsdD1nLllfQVhJUyl7bGV0IHI9dGhpcy5yYXdEYXRhLHM9ZS5zdWJ0cmFjdChpLGcuSEVMUF8wKTtzLmxlbmd0aDwxZS00JiYocy56PTEpLHMubm9ybWFsaXplKCk7bGV0IGE9dC5jcm9zc1Byb2R1Y3QocyxnLkhFTFBfMSk7YS5sZW5ndGg8MWUtNCYmKE1hdGguYWJzKHQueik+Ljk5OTk/cy54Kz0xZS00OnMueis9MWUtNCxzLm5vcm1hbGl6ZSgpKSxhPXQuY3Jvc3NQcm9kdWN0KHMsYSkubm9ybWFsaXplKCk7bGV0IG49cy5jcm9zc1Byb2R1Y3QoYSxnLkhFTFBfMikubm9ybWFsaXplKCk7clswXT1hLngsclsxXT1uLngsclsyXT1zLngsclszXT0wLHJbNF09YS55LHJbNV09bi55LHJbNl09cy55LHJbN109MCxyWzhdPWEueixyWzldPW4ueixyWzEwXT1zLnosclsxMV09MCxyWzEyXT0tYS5kb3RQcm9kdWN0KGkpLHJbMTNdPS1uLmRvdFByb2R1Y3QoaSksclsxNF09LXMuZG90UHJvZHVjdChpKSxyWzE1XT0xfW11bHRpcGx5KGkpe2xldCBlPXRoaXMucmF3RGF0YSx0PWkucmF3RGF0YSxyPUYuZmxvYXQzMkFycmF5O3JbMF09ZVswXSp0WzBdK2VbMV0qdFs0XStlWzJdKnRbOF0rZVszXSp0WzEyXSxyWzFdPWVbMF0qdFsxXStlWzFdKnRbNV0rZVsyXSp0WzldK2VbM10qdFsxM10sclsyXT1lWzBdKnRbMl0rZVsxXSp0WzZdK2VbMl0qdFsxMF0rZVszXSp0WzE0XSxyWzNdPWVbMF0qdFszXStlWzFdKnRbN10rZVsyXSp0WzExXStlWzNdKnRbMTVdLHJbNF09ZVs0XSp0WzBdK2VbNV0qdFs0XStlWzZdKnRbOF0rZVs3XSp0WzEyXSxyWzVdPWVbNF0qdFsxXStlWzVdKnRbNV0rZVs2XSp0WzldK2VbN10qdFsxM10scls2XT1lWzRdKnRbMl0rZVs1XSp0WzZdK2VbNl0qdFsxMF0rZVs3XSp0WzE0XSxyWzddPWVbNF0qdFszXStlWzVdKnRbN10rZVs2XSp0WzExXStlWzddKnRbMTVdLHJbOF09ZVs4XSp0WzBdK2VbOV0qdFs0XStlWzEwXSp0WzhdK2VbMTFdKnRbMTJdLHJbOV09ZVs4XSp0WzFdK2VbOV0qdFs1XStlWzEwXSp0WzldK2VbMTFdKnRbMTNdLHJbMTBdPWVbOF0qdFsyXStlWzldKnRbNl0rZVsxMF0qdFsxMF0rZVsxMV0qdFsxNF0sclsxMV09ZVs4XSp0WzNdK2VbOV0qdFs3XStlWzEwXSp0WzExXStlWzExXSp0WzE1XSxyWzEyXT1lWzEyXSp0WzBdK2VbMTNdKnRbNF0rZVsxNF0qdFs4XStlWzE1XSp0WzEyXSxyWzEzXT1lWzEyXSp0WzFdK2VbMTNdKnRbNV0rZVsxNF0qdFs5XStlWzE1XSp0WzEzXSxyWzE0XT1lWzEyXSp0WzJdK2VbMTNdKnRbNl0rZVsxNF0qdFsxMF0rZVsxNV0qdFsxNF0sclsxNV09ZVsxMl0qdFszXStlWzEzXSp0WzddK2VbMTRdKnRbMTFdK2VbMTVdKnRbMTVdLGVbMF09clswXSxlWzFdPXJbMV0sZVsyXT1yWzJdLGVbM109clszXSxlWzRdPXJbNF0sZVs1XT1yWzVdLGVbNl09cls2XSxlWzddPXJbN10sZVs4XT1yWzhdLGVbOV09cls5XSxlWzEwXT1yWzEwXSxlWzExXT1yWzExXSxlWzEyXT1yWzEyXSxlWzEzXT1yWzEzXSxlWzE0XT1yWzE0XSxlWzE1XT1yWzE1XX1tdWx0aXBseU1hdHJpY2VzKGksZSl7Y29uc3QgdD1pLnJhd0RhdGEscj1lLnJhd0RhdGEscz10aGlzLnJhd0RhdGEsYT10WzBdLG49dFs0XSxsPXRbOF0saD10WzEyXSx1PXRbMV0sYz10WzVdLGY9dFs5XSxkPXRbMTNdLHA9dFsyXSxtPXRbNl0sXz10WzEwXSx2PXRbMTRdLHk9dFszXSxDPXRbN10sQj10WzExXSxUPXRbMTVdLE09clswXSxEPXJbNF0sUD1yWzhdLEw9clsxMl0sST1yWzFdLE89cls1XSxrPXJbOV0sSD1yWzEzXSxXPXJbMl0sbmU9cls2XSxmZT1yWzEwXSx3ZT1yWzE0XSx6ZT1yWzNdLFJlPXJbN10sdWU9clsxMV0sZGU9clsxNV07cmV0dXJuIHNbMF09YSpNK24qSStsKlcraCp6ZSxzWzRdPWEqRCtuKk8rbCpuZStoKlJlLHNbOF09YSpQK24qaytsKmZlK2gqdWUsc1sxMl09YSpMK24qSCtsKndlK2gqZGUsc1sxXT11Kk0rYypJK2YqVytkKnplLHNbNV09dSpEK2MqTytmKm5lK2QqUmUsc1s5XT11KlArYyprK2YqZmUrZCp1ZSxzWzEzXT11KkwrYypIK2Yqd2UrZCpkZSxzWzJdPXAqTSttKkkrXypXK3YqemUsc1s2XT1wKkQrbSpPK18qbmUrdipSZSxzWzEwXT1wKlArbSprK18qZmUrdip1ZSxzWzE0XT1wKkwrbSpIK18qd2UrdipkZSxzWzNdPXkqTStDKkkrQipXK1QqemUsc1s3XT15KkQrQypPK0IqbmUrVCpSZSxzWzExXT15KlArQyprK0IqZmUrVCp1ZSxzWzE1XT15KkwrQypIK0Iqd2UrVCpkZSx0aGlzfW11bHRpcGx5UG9pbnQzKGksZSl7ZXx8KGU9bmV3IGcpO2xldCB0PXRoaXMucmF3RGF0YTtyZXR1cm4gZS54PXRbMF0qaS54K3RbNF0qaS55K3RbOF0qaS56K3RbMTJdLGUueT10WzFdKmkueCt0WzVdKmkueSt0WzldKmkueit0WzEzXSxlLno9dFsyXSppLngrdFs2XSppLnkrdFsxMF0qaS56K3RbMTRdLGV9bXVsdGlwbHlWZWN0b3I0KGksZSl7ZXx8KGU9bmV3IGcpO2xldCB0PXRoaXMucmF3RGF0YSxyPWkueCxzPWkueSxhPWkueixuPXRbM10qcit0WzddKnMrdFsxMV0qYSt0WzE1XTtyZXR1cm4gbj1ufHwxLGUueD0odFswXSpyK3RbNF0qcyt0WzhdKmErdFsxMl0pL24sZS55PSh0WzFdKnIrdFs1XSpzK3RbOV0qYSt0WzEzXSkvbixlLno9KHRbMl0qcit0WzZdKnMrdFsxMF0qYSt0WzE0XSkvbixlLnc9MSxlfXRyYW5zZm9ybVZlY3RvcjQoaSxlKXtsZXQgdD10aGlzLnJhd0RhdGE7ZXx8KGU9bmV3IGcpO2xldCByPWkueCxzPWkueSxhPWkueixuPWkudztyZXR1cm4gZS54PXIqdFswXStzKnRbNF0rYSp0WzhdK24qdFsxMl0sZS55PXIqdFsxXStzKnRbNV0rYSp0WzldK24qdFsxM10sZS56PXIqdFsyXStzKnRbNl0rYSp0WzEwXStuKnRbMTRdLGUudz1yKnRbM10rcyp0WzddK2EqdFsxMV0rbip0WzE1XSxlfXBlcnNwZWN0aXZlTXVsdGlwbHlQb2ludDMoaSxlKXtsZXQgdD1nLkhFTFBfMixyLHM9dGhpcy5yYXdEYXRhO2lmKHQueD1zWzBdKmkueCtzWzRdKmkueStzWzhdKmkueitzWzEyXSx0Lnk9c1sxXSppLngrc1s1XSppLnkrc1s5XSppLnorc1sxM10sdC56PXNbMl0qaS54K3NbNl0qaS55K3NbMTBdKmkueitzWzE0XSxyPXNbM10qaS54K3NbN10qaS55K3NbMTFdKmkueitzWzE1XSxNYXRoLmFicyhyKT4xZS03KXtsZXQgYT0xL3I7cmV0dXJuIGUueD10LngqYSxlLnk9dC55KmEsZS56PXQueiphLCEwfWVsc2UgcmV0dXJuIGUueD0wLGUueT0wLGUuej0wLCExfXBlcnNwZWN0aXZlKGksZSx0LHIpe2xldCBzPXRoaXMucmF3RGF0YSxhPWkqX2UvMixuPU1hdGguY29zKGEpL01hdGguc2luKGEpO3NbMF09LW4vZSxzWzFdPTAsc1syXT0wLHNbM109MCxzWzRdPTAsc1s1XT1uLHNbNl09MCxzWzddPTAsc1s4XT0wLHNbOV09MCxzWzEwXT1yLyhyLXQpLHNbMTFdPTEsc1sxMl09MCxzWzEzXT0wLHNbMTRdPS10KnIvKHItdCksc1sxNV09MH1wZXJzcGVjdGl2ZTMoaSxlLHQscil7dmFyIHM9TWF0aC50YW4oaSpNYXRoLlBJLzM2MCkqdCxhPXMqZTt0aGlzLmZydXN0dW0oLWEsYSwtcyxzLHQscil9ZnJ1c3R1bShpLGUsdCxyLHMsYSl7dmFyIG49dGhpcy5yYXdEYXRhO25bMF09LTIqcy8oZS1pKSxuWzFdPTAsblsyXT0wLG5bM109MCxuWzRdPTAsbls1XT0yKnMvKHItdCksbls2XT0wLG5bN109MCxuWzhdPShlK2kpLyhlLWkpLG5bOV09KHIrdCkvKHItdCksblsxMF09YS8oYS1zKSxuWzExXT0xLG5bMTJdPTAsblsxM109MCxuWzE0XT0tYSpzLyhhLXMpLG5bMTVdPTB9b3J0aG8oaSxlLHQscil7bGV0IHM9dGhpcy5yYXdEYXRhO3JldHVybiBzWzBdPTIvaSxzWzFdPTAsc1syXT0wLHNbM109MCxzWzRdPTAsc1s1XT0yL2Usc1s2XT0wLHNbN109MCxzWzhdPTAsc1s5XT0wLHNbMTBdPTEvKHItdCksc1sxMV09MCxzWzEyXT0wLHNbMTNdPTAsc1sxNF09dC8odC1yKSxzWzE1XT0xLHRoaXN9b3J0aG9aTyhpLGUsdCxyLHMsYSl7bGV0IG49dGhpcy5yYXdEYXRhLGw9MS8oaS1lKSxoPTEvKHQtciksdT0xLyhzLWEpO3JldHVybiBuWzBdPS0yKmwsblsxXT0wLG5bMl09MCxuWzNdPTAsbls0XT0wLG5bNV09LTIqaCxuWzZdPTAsbls3XT0wLG5bOF09MCxuWzldPTAsblsxMF09dSxuWzExXT0wLG5bMTJdPShpK2UpKmwsblsxM109KHIrdCkqaCxuWzE0XT1zKnUsblsxNV09MSx0aGlzfW9ydGhvT2ZmQ2VudGVyKGksZSx0LHIscyxhKXtsZXQgbj10aGlzLnJhd0RhdGE7blswXT0yLyhlLWkpLG5bMV09MCxuWzJdPTAsblszXT0wLG5bNF09MCxuWzVdPTIvKHItdCksbls2XT0wLG5bN109MCxuWzhdPTAsbls5XT0wLG5bMTBdPTEvKGEtcyksblsxMV09MCxuWzEyXT0oaStlKS8oaS1lKSxuWzEzXT0ocit0KS8odC1yKSxuWzE0XT1zLyhzLWEpLG5bMTVdPTF9dHJhbnNmb3JtRGlyKGksZSl7bGV0IHQ9dGhpcy5yYXdEYXRhLHI9MWUtNixzPWcuWkVSTztlLmNyb3NzUHJvZHVjdChpLHMpO2xldCBhPWUuZG90UHJvZHVjdChpKTtpZihhPjEtcil0aGlzLmlkZW50aXR5KCk7ZWxzZXtsZXQgbixsLGgsdSxjLGY9cy5kb3RQcm9kdWN0KHMpLGQ9KDEtYSkvZjtuPWQqcy54LGw9ZCpzLnosaD1uKnMueSx1PW4qcy56LGM9bCpzLnksdFswXT1hK24qcy54LHRbMV09aC1zLnosdFsyXT11K3MueSx0WzRdPWgrcy56LHRbNV09YStkKnMueSpzLnksdFs2XT1jLXMueCx0WzhdPXUtcy55LHRbOV09YytzLngsdFsxMF09YStsKnMueix0WzNdPTAsdFs3XT0wLHRbMTFdPTAsdFsxNV09MX19YXBwZW5kKGkpe2xldCBlPXRoaXMucmF3RGF0YSx0PWVbMF0scj1lWzRdLHM9ZVs4XSxhPWVbMTJdLG49ZVsxXSxsPWVbNV0saD1lWzldLHU9ZVsxM10sYz1lWzJdLGY9ZVs2XSxkPWVbMTBdLHA9ZVsxNF0sbT1lWzNdLF89ZVs3XSx2PWVbMTFdLHk9ZVsxNV07ZVswXT10KmkucmF3RGF0YVswXStuKmkucmF3RGF0YVs0XStjKmkucmF3RGF0YVs4XSttKmkucmF3RGF0YVsxMl0sZVsxXT10KmkucmF3RGF0YVsxXStuKmkucmF3RGF0YVs1XStjKmkucmF3RGF0YVs5XSttKmkucmF3RGF0YVsxM10sZVsyXT10KmkucmF3RGF0YVsyXStuKmkucmF3RGF0YVs2XStjKmkucmF3RGF0YVsxMF0rbSppLnJhd0RhdGFbMTRdLGVbM109dCppLnJhd0RhdGFbM10rbippLnJhd0RhdGFbN10rYyppLnJhd0RhdGFbMTFdK20qaS5yYXdEYXRhWzE1XSxlWzRdPXIqaS5yYXdEYXRhWzBdK2wqaS5yYXdEYXRhWzRdK2YqaS5yYXdEYXRhWzhdK18qaS5yYXdEYXRhWzEyXSxlWzVdPXIqaS5yYXdEYXRhWzFdK2wqaS5yYXdEYXRhWzVdK2YqaS5yYXdEYXRhWzldK18qaS5yYXdEYXRhWzEzXSxlWzZdPXIqaS5yYXdEYXRhWzJdK2wqaS5yYXdEYXRhWzZdK2YqaS5yYXdEYXRhWzEwXStfKmkucmF3RGF0YVsxNF0sZVs3XT1yKmkucmF3RGF0YVszXStsKmkucmF3RGF0YVs3XStmKmkucmF3RGF0YVsxMV0rXyppLnJhd0RhdGFbMTVdLGVbOF09cyppLnJhd0RhdGFbMF0raCppLnJhd0RhdGFbNF0rZCppLnJhd0RhdGFbOF0rdippLnJhd0RhdGFbMTJdLGVbOV09cyppLnJhd0RhdGFbMV0raCppLnJhd0RhdGFbNV0rZCppLnJhd0RhdGFbOV0rdippLnJhd0RhdGFbMTNdLGVbMTBdPXMqaS5yYXdEYXRhWzJdK2gqaS5yYXdEYXRhWzZdK2QqaS5yYXdEYXRhWzEwXSt2KmkucmF3RGF0YVsxNF0sZVsxMV09cyppLnJhd0RhdGFbM10raCppLnJhd0RhdGFbN10rZCppLnJhd0RhdGFbMTFdK3YqaS5yYXdEYXRhWzE1XSxlWzEyXT1hKmkucmF3RGF0YVswXSt1KmkucmF3RGF0YVs0XStwKmkucmF3RGF0YVs4XSt5KmkucmF3RGF0YVsxMl0sZVsxM109YSppLnJhd0RhdGFbMV0rdSppLnJhd0RhdGFbNV0rcCppLnJhd0RhdGFbOV0reSppLnJhd0RhdGFbMTNdLGVbMTRdPWEqaS5yYXdEYXRhWzJdK3UqaS5yYXdEYXRhWzZdK3AqaS5yYXdEYXRhWzEwXSt5KmkucmF3RGF0YVsxNF0sZVsxNV09YSppLnJhd0RhdGFbM10rdSppLnJhd0RhdGFbN10rcCppLnJhd0RhdGFbMTFdK3kqaS5yYXdEYXRhWzE1XX1hZGQoaSl7bGV0IGU9dGhpcy5yYXdEYXRhLHQ9ZVswXSxyPWVbNF0scz1lWzhdLGE9ZVsxMl0sbj1lWzFdLGw9ZVs1XSxoPWVbOV0sdT1lWzEzXSxjPWVbMl0sZj1lWzZdLGQ9ZVsxMF0scD1lWzE0XSxtPWVbM10sXz1lWzddLHY9ZVsxMV0seT1lWzE1XSxDPWkucmF3RGF0YVswXSxCPWkucmF3RGF0YVs0XSxUPWkucmF3RGF0YVs4XSxNPWkucmF3RGF0YVsxMl0sRD1pLnJhd0RhdGFbMV0sUD1pLnJhd0RhdGFbNV0sTD1pLnJhd0RhdGFbOV0sST1pLnJhd0RhdGFbMTNdLE89aS5yYXdEYXRhWzJdLGs9aS5yYXdEYXRhWzZdLEg9aS5yYXdEYXRhWzEwXSxXPWkucmF3RGF0YVsxNF0sbmU9aS5yYXdEYXRhWzNdLGZlPWkucmF3RGF0YVs3XSx3ZT1pLnJhd0RhdGFbMTFdLHplPWkucmF3RGF0YVsxNV07cmV0dXJuIGVbMF09dCtDLGVbMV09bitELGVbMl09YytPLGVbM109bStuZSxlWzRdPXIrQixlWzVdPWwrUCxlWzZdPWYrayxlWzddPV8rZmUsZVs4XT1zK1QsZVs5XT1oK0wsZVsxMF09ZCtILGVbMTFdPXYrd2UsZVsxMl09YStNLGVbMTNdPXUrSSxlWzE0XT1wK1csZVsxNV09eSt6ZSx0aGlzfXN1YihpKXtsZXQgZT10aGlzLnJhd0RhdGEsdD1lWzBdLHI9ZVs0XSxzPWVbOF0sYT1lWzEyXSxuPWVbMV0sbD1lWzVdLGg9ZVs5XSx1PWVbMTNdLGM9ZVsyXSxmPWVbNl0sZD1lWzEwXSxwPWVbMTRdLG09ZVszXSxfPWVbN10sdj1lWzExXSx5PWVbMTVdLEM9aS5yYXdEYXRhWzBdLEI9aS5yYXdEYXRhWzRdLFQ9aS5yYXdEYXRhWzhdLE09aS5yYXdEYXRhWzEyXSxEPWkucmF3RGF0YVsxXSxQPWkucmF3RGF0YVs1XSxMPWkucmF3RGF0YVs5XSxJPWkucmF3RGF0YVsxM10sTz1pLnJhd0RhdGFbMl0saz1pLnJhd0RhdGFbNl0sSD1pLnJhd0RhdGFbMTBdLFc9aS5yYXdEYXRhWzE0XSxuZT1pLnJhd0RhdGFbM10sZmU9aS5yYXdEYXRhWzddLHdlPWkucmF3RGF0YVsxMV0semU9aS5yYXdEYXRhWzE1XTtyZXR1cm4gZVswXT10LUMsZVsxXT1uLUQsZVsyXT1jLU8sZVszXT1tLW5lLGVbNF09ci1CLGVbNV09bC1QLGVbNl09Zi1rLGVbN109Xy1mZSxlWzhdPXMtVCxlWzldPWgtTCxlWzEwXT1kLUgsZVsxMV09di13ZSxlWzEyXT1hLU0sZVsxM109dS1JLGVbMTRdPXAtVyxlWzE1XT15LXplLHRoaXN9bXVsdChpKXtsZXQgZT10aGlzLnJhd0RhdGE7cmV0dXJuIGVbMF0qPWksZVsxXSo9aSxlWzJdKj1pLGVbM10qPWksZVs0XSo9aSxlWzVdKj1pLGVbNl0qPWksZVs3XSo9aSxlWzhdKj1pLGVbOV0qPWksZVsxMF0qPWksZVsxMV0qPWksZVsxMl0qPWksZVsxM10qPWksZVsxNF0qPWksZVsxNV0qPWksdGhpc31hcHBlbmRSb3RhdGlvbihpLGUpe2xldCB0PUYuZ2V0QXhpc1JvdGF0aW9uKGUueCxlLnksZS56LGkpO3RoaXMuYXBwZW5kKHQpfWNyZWF0ZUJ5Um90YXRpb24oaSxlKXtsZXQgdD1GLmhlbHBNYXRyaXgscixzLGE9aSpfZTtyPU1hdGguc2luKGEpLHM9TWF0aC5jb3MoYSksZS54PT0xJiYodC5yYXdEYXRhWzBdPTEsdC5yYXdEYXRhWzFdPTAsdC5yYXdEYXRhWzJdPTAsdC5yYXdEYXRhWzNdPTAsdC5yYXdEYXRhWzRdPTAsdC5yYXdEYXRhWzVdPXMsdC5yYXdEYXRhWzZdPXIsdC5yYXdEYXRhWzddPTAsdC5yYXdEYXRhWzhdPTAsdC5yYXdEYXRhWzldPS1yLHQucmF3RGF0YVsxMF09cyx0LnJhd0RhdGFbMTFdPTAsdC5yYXdEYXRhWzEyXT0wLHQucmF3RGF0YVsxM109MCx0LnJhd0RhdGFbMTRdPTAsdC5yYXdEYXRhWzE1XT0xKSxlLnk9PTEmJih0LnJhd0RhdGFbMF09cyx0LnJhd0RhdGFbMV09MCx0LnJhd0RhdGFbMl09LXIsdC5yYXdEYXRhWzNdPTAsdC5yYXdEYXRhWzRdPTAsdC5yYXdEYXRhWzVdPTEsdC5yYXdEYXRhWzZdPTAsdC5yYXdEYXRhWzddPTAsdC5yYXdEYXRhWzhdPXIsdC5yYXdEYXRhWzldPTAsdC5yYXdEYXRhWzEwXT1zLHQucmF3RGF0YVsxMV09MCx0LnJhd0RhdGFbMTJdPTAsdC5yYXdEYXRhWzEzXT0wLHQucmF3RGF0YVsxNF09MCx0LnJhd0RhdGFbMTVdPTEpLGUuej09MSYmKHQucmF3RGF0YVswXT1zLHQucmF3RGF0YVsxXT1yLHQucmF3RGF0YVsyXT0wLHQucmF3RGF0YVszXT0wLHQucmF3RGF0YVs0XT0tcix0LnJhd0RhdGFbNV09cyx0LnJhd0RhdGFbNl09MCx0LnJhd0RhdGFbN109MCx0LnJhd0RhdGFbOF09MCx0LnJhd0RhdGFbOV09MCx0LnJhd0RhdGFbMTBdPTEsdC5yYXdEYXRhWzExXT0wLHQucmF3RGF0YVsxMl09MCx0LnJhd0RhdGFbMTNdPTAsdC5yYXdEYXRhWzE0XT0wLHQucmF3RGF0YVsxNV09MSksdGhpcy5hcHBlbmQodCl9YXBwZW5kU2NhbGUoaSxlLHQpe0YuaGVscE1hdHJpeC5jcmVhdGVCeVNjYWxlKGksZSx0KSx0aGlzLmFwcGVuZChGLmhlbHBNYXRyaXgpfWNyZWF0ZUJ5U2NhbGUoaSxlLHQpe2xldCByPXRoaXMucmF3RGF0YTtyWzBdPWksclsxXT0wLHJbMl09MCxyWzNdPTAscls0XT0wLHJbNV09ZSxyWzZdPTAscls3XT0wLHJbOF09MCxyWzldPTAsclsxMF09dCxyWzExXT0wLHJbMTJdPTAsclsxM109MCxyWzE0XT0wLHJbMTVdPTF9YXBwZW5kVHJhbnNsYXRpb24oaSxlLHQpe2xldCByPXRoaXMucmF3RGF0YTtyWzEyXSs9aSxyWzEzXSs9ZSxyWzE0XSs9dH1jbG9uZSgpe2xldCBpPW5ldyBGO3JldHVybiBpLmNvcHlGcm9tKHRoaXMpLGl9Y29weVJvd0Zyb20oaSxlKXtsZXQgdD10aGlzLnJhd0RhdGE7c3dpdGNoKGkpe2Nhc2UgMDp0WzBdPWUueCx0WzFdPWUueSx0WzJdPWUueix0WzNdPWUudzticmVhaztjYXNlIDE6dFs0XT1lLngsdFs1XT1lLnksdFs2XT1lLnosdFs3XT1lLnc7YnJlYWs7Y2FzZSAyOnRbOF09ZS54LHRbOV09ZS55LHRbMTBdPWUueix0WzExXT1lLnc7YnJlYWs7Y2FzZSAzOnRbMTJdPWUueCx0WzEzXT1lLnksdFsxNF09ZS56LHRbMTVdPWUudzticmVha319Y29weVJvd1RvKGksZSl7bGV0IHQ9dGhpcy5yYXdEYXRhO3N3aXRjaChpKXtjYXNlIDA6ZS54PXRbMF0sZS55PXRbMV0sZS56PXRbMl0sZS53PXRbM107YnJlYWs7Y2FzZSAxOmUueD10WzRdLGUueT10WzVdLGUuej10WzZdLGUudz10WzddO2JyZWFrO2Nhc2UgMjplLng9dFs4XSxlLnk9dFs5XSxlLno9dFsxMF0sZS53PXRbMTFdO2JyZWFrO2Nhc2UgMzplLng9dFsxMl0sZS55PXRbMTNdLGUuej10WzE0XSxlLnc9dFsxNV07YnJlYWt9fWNvcHlGcm9tKGkpe2xldCBlPXRoaXMucmF3RGF0YTtyZXR1cm4gZVswXT1pLnJhd0RhdGFbMF0sZVsxXT1pLnJhd0RhdGFbMV0sZVsyXT1pLnJhd0RhdGFbMl0sZVszXT1pLnJhd0RhdGFbM10sZVs0XT1pLnJhd0RhdGFbNF0sZVs1XT1pLnJhd0RhdGFbNV0sZVs2XT1pLnJhd0RhdGFbNl0sZVs3XT1pLnJhd0RhdGFbN10sZVs4XT1pLnJhd0RhdGFbOF0sZVs5XT1pLnJhd0RhdGFbOV0sZVsxMF09aS5yYXdEYXRhWzEwXSxlWzExXT1pLnJhd0RhdGFbMTFdLGVbMTJdPWkucmF3RGF0YVsxMl0sZVsxM109aS5yYXdEYXRhWzEzXSxlWzE0XT1pLnJhd0RhdGFbMTRdLGVbMTVdPWkucmF3RGF0YVsxNV0sdGhpc31jb3B5UmF3RGF0YVRvKGksZT0wLHQ9ITEpe2xldCByPXRoaXMucmF3RGF0YTtpWzArZV09clswXSxpWzErZV09clsxXSxpWzIrZV09clsyXSxpWzMrZV09clszXSxpWzQrZV09cls0XSxpWzUrZV09cls1XSxpWzYrZV09cls2XSxpWzcrZV09cls3XSxpWzgrZV09cls4XSxpWzkrZV09cls5XSxpWzEwK2VdPXJbMTBdLGlbMTErZV09clsxMV0saVsxMitlXT1yWzEyXSxpWzEzK2VdPXJbMTNdLGlbMTQrZV09clsxNF0saVsxNStlXT1yWzE1XX1jb3B5Q29sRnJvbShpLGUpe2xldCB0PXRoaXMucmF3RGF0YTtzd2l0Y2goaSl7Y2FzZSAwOnRbMF09ZS54LHRbNF09ZS55LHRbOF09ZS56LHRbMTJdPWUudzticmVhaztjYXNlIDE6dFsxXT1lLngsdFs1XT1lLnksdFs5XT1lLnosdFsxM109ZS53O2JyZWFrO2Nhc2UgMjp0WzJdPWUueCx0WzZdPWUueSx0WzEwXT1lLnosdFsxNF09ZS53O2JyZWFrO2Nhc2UgMzp0WzNdPWUueCx0WzddPWUueSx0WzExXT1lLnosdFsxNV09ZS53O2JyZWFrfX1jb3B5Q29sVG8oaSxlKXtsZXQgdD10aGlzLnJhd0RhdGE7c3dpdGNoKGkpe2Nhc2UgMDplLng9dFswXSxlLnk9dFs0XSxlLno9dFs4XSxlLnc9dFsxMl07YnJlYWs7Y2FzZSAxOmUueD10WzFdLGUueT10WzVdLGUuej10WzldLGUudz10WzEzXTticmVhaztjYXNlIDI6ZS54PXRbMl0sZS55PXRbNl0sZS56PXRbMTBdLGUudz10WzE0XTticmVhaztjYXNlIDM6ZS54PXRbM10sZS55PXRbN10sZS56PXRbMTFdLGUudz10WzE1XTticmVha319Y29weVRvTWF0cml4M0QoaSl7aS5yYXdEYXRhPXRoaXMucmF3RGF0YS5zbGljZSgwKX1tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihpKXtyZXR1cm4gdGhpcy5jb21wb3NlKEYuX3plcm8saSxGLl9vbmUpLHRoaXN9ZGVjb21wb3NlKGk9XCJldWxlckFuZ2xlc1wiLGUpe2xldCB0PXEuQ0FMQ1VMQVRJT05fUVVBVEVSTklPTixyPWV8fEYuX3Byczt0aGlzLmNvcHlSYXdEYXRhVG8oRi5kZWNvbXBvc2VSYXdEYXRhKTtsZXQgcz1GLmRlY29tcG9zZVJhd0RhdGEsYT1yWzBdO2EueD1zWzEyXSxhLnk9c1sxM10sYS56PXNbMTRdLHNbMTJdPTAsc1sxM109MCxzWzE0XT0wO2xldCBuPXJbMl07bi54PU1hdGguc3FydChzWzBdKnNbMF0rc1sxXSpzWzFdK3NbMl0qc1syXSksbi55PU1hdGguc3FydChzWzRdKnNbNF0rc1s1XSpzWzVdK3NbNl0qc1s2XSksbi56PU1hdGguc3FydChzWzhdKnNbOF0rc1s5XSpzWzldK3NbMTBdKnNbMTBdKSxzWzBdKihzWzVdKnNbMTBdLXNbNl0qc1s5XSktc1sxXSooc1s0XSpzWzEwXS1zWzZdKnNbOF0pK3NbMl0qKHNbNF0qc1s5XS1zWzVdKnNbOF0pPDAmJihuLno9LW4ueiksc1swXS89bi54LHNbMV0vPW4ueCxzWzJdLz1uLngsc1s0XS89bi55LHNbNV0vPW4ueSxzWzZdLz1uLnksc1s4XS89bi56LHNbOV0vPW4ueixzWzEwXS89bi56O2xldCBsPXJbMV0saDtzd2l0Y2goaSl7Y2FzZSB5dC5BWElTX0FOR0xFOmwudz1NYXRoLmFjb3MoKHNbMF0rc1s1XStzWzEwXS0xKS8yKTtsZXQgdT1NYXRoLnNxcnQoKHNbNl0tc1s5XSkqKHNbNl0tc1s5XSkrKHNbOF0tc1syXSkqKHNbOF0tc1syXSkrKHNbMV0tc1s0XSkqKHNbMV0tc1s0XSkpO2wueD0oc1s2XS1zWzldKS91LGwueT0oc1s4XS1zWzJdKS91LGwuej0oc1sxXS1zWzRdKS91O2JyZWFrO2Nhc2UgeXQuUVVBVEVSTklPTjpoPXNbMF0rc1s1XStzWzEwXSxoPjA/KGwudz1NYXRoLnNxcnQoMStoKS8yLGwueD0oc1s2XS1zWzldKS8oNCpsLncpLGwueT0oc1s4XS1zWzJdKS8oNCpsLncpLGwuej0oc1sxXS1zWzRdKS8oNCpsLncpKTpzWzBdPnNbNV0mJnNbMF0+c1sxMF0/KGwueD1NYXRoLnNxcnQoMStzWzBdLXNbNV0tc1sxMF0pLzIsbC53PShzWzZdLXNbOV0pLyg0KmwueCksbC55PShzWzFdK3NbNF0pLyg0KmwueCksbC56PShzWzhdK3NbMl0pLyg0KmwueCkpOnNbNV0+c1sxMF0/KGwueT1NYXRoLnNxcnQoMStzWzVdLXNbMF0tc1sxMF0pLzIsbC54PShzWzFdK3NbNF0pLyg0KmwueSksbC53PShzWzhdLXNbMl0pLyg0KmwueSksbC56PShzWzZdK3NbOV0pLyg0KmwueSkpOihsLno9TWF0aC5zcXJ0KDErc1sxMF0tc1swXS1zWzVdKS8yLGwueD0oc1s4XStzWzJdKS8oNCpsLnopLGwueT0oc1s2XStzWzldKS8oNCpsLnopLGwudz0oc1sxXS1zWzRdKS8oNCpsLnopKTticmVhaztjYXNlIHl0LkVVTEVSX0FOR0xFUzpoPXNbMF0rc1s1XStzWzEwXSxoPjA/KHQudz1NYXRoLnNxcnQoMStoKS8yLHQueD0oc1s2XS1zWzldKS8oNCp0LncpLHQueT0oc1s4XS1zWzJdKS8oNCp0LncpLHQuej0oc1sxXS1zWzRdKS8oNCp0LncpKTpzWzBdPnNbNV0mJnNbMF0+c1sxMF0/KHQueD1NYXRoLnNxcnQoMStzWzBdLXNbNV0tc1sxMF0pLzIsdC53PShzWzZdLXNbOV0pLyg0KnQueCksdC55PShzWzFdK3NbNF0pLyg0KnQueCksdC56PShzWzhdK3NbMl0pLyg0KnQueCkpOnNbNV0+c1sxMF0/KGwueT1NYXRoLnNxcnQoMStzWzVdLXNbMF0tc1sxMF0pLzIsdC54PShzWzFdK3NbNF0pLyg0KnQueSksdC53PShzWzhdLXNbMl0pLyg0KnQueSksdC56PShzWzZdK3NbOV0pLyg0KnQueSkpOih0Lno9TWF0aC5zcXJ0KDErc1sxMF0tc1swXS1zWzVdKS8yLHQueD0oc1s4XStzWzJdKS8oNCp0LnopLHQueT0oc1s2XStzWzldKS8oNCp0LnopLHQudz0oc1sxXS1zWzRdKS8oNCp0LnopKSx0LmdldEV1bGVyQW5nbGVzKGwpO2JyZWFrfXJldHVybiByWzBdPWEsclsxXT1sLHJbMl09bixyfXN0YXRpYyBnZXRFdWxlcihpLGUsdD0hMCxyKXtyZXR1cm4gaXx8KGk9bmV3IGcpLEYuX2dldEV1bGVyTWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGUpLm1ha2VFdWxlcihpLHQsciksaX1jb21wb3NlKGksZSx0KXtjb25zdCByPXRoaXMucmF3RGF0YSxzPWUueCxhPWUueSxuPWUueixsPWUudyxoPXMrcyx1PWErYSxjPW4rbixmPXMqaCxkPXMqdSxwPXMqYyxtPWEqdSxfPWEqYyx2PW4qYyx5PWwqaCxDPWwqdSxCPWwqYyxUPXQueCxNPXQueSxEPXQuejtyZXR1cm4gclswXT0oMS0obSt2KSkqVCxyWzFdPShkK0IpKlQsclsyXT0ocC1DKSpULHJbM109MCxyWzRdPShkLUIpKk0scls1XT0oMS0oZit2KSkqTSxyWzZdPShfK3kpKk0scls3XT0wLHJbOF09KHArQykqRCxyWzldPShfLXkpKkQsclsxMF09KDEtKGYrbSkpKkQsclsxMV09MCxyWzEyXT1pLngsclsxM109aS55LHJbMTRdPWkueixyWzE1XT0xLHRoaXN9ZGVsdGFUcmFuc2Zvcm1WZWN0b3IoaSxlKXtlfHwoZT1uZXcgZyk7bGV0IHQ9dGhpcy5yYXdEYXRhLHI9aS54LHM9aS55LGE9aS56O3JldHVybiBlLng9cip0WzBdK3MqdFs0XSthKnRbOF0sZS55PXIqdFsxXStzKnRbNV0rYSp0WzldLGUuej1yKnRbMl0rcyp0WzZdK2EqdFsxMF0sZS53PXIqdFszXStzKnRbN10rYSp0WzExXSxlfWlkZW50aXR5KCl7bGV0IGk9dGhpcy5yYXdEYXRhO3JldHVybiBpWzBdPTEsaVsxXT0wLGlbMl09MCxpWzNdPTAsaVs0XT0wLGlbNV09MSxpWzZdPTAsaVs3XT0wLGlbOF09MCxpWzldPTAsaVsxMF09MSxpWzExXT0wLGlbMTJdPTAsaVsxM109MCxpWzE0XT0wLGlbMTVdPTEsdGhpc31maWxsKGkpe2xldCBlPXRoaXMucmF3RGF0YTtlWzFdPWksZVsyXT1pLGVbM109aSxlWzRdPWksZVs2XT1pLGVbN109aSxlWzhdPWksZVs5XT1pLGVbMTFdPWksZVsxMl09aSxlWzEzXT1pLGVbMTRdPWksZVswXT1pLGVbNV09aSxlWzEwXT1pLGVbMTVdPWl9aW52ZXJzMzMoKXtsZXQgaT10aGlzLnJhd0RhdGEsZT1pWzVdKmlbMTBdLWlbOV0qaVs2XSx0PWlbOF0qaVs2XS1pWzRdKmlbMTBdLHI9aVs0XSppWzldLWlbOF0qaVs1XSxzPWlbOV0qaVsyXS1pWzFdKmlbMTBdLGE9aVswXSppWzEwXS1pWzhdKmlbMl0sbj1pWzhdKmlbMV0taVswXSppWzldLGw9aVsxXSppWzZdLWlbNV0qaVsyXSxoPWlbNF0qaVsyXS1pWzBdKmlbNl0sdT1pWzBdKmlbNV0taVs0XSppWzFdLGM9aVswXSplK2lbNF0qcytpWzhdKmw7aWYoTWF0aC5hYnMoYyk+MWUtMTEpe2xldCBmPTEvYztpWzBdPWYqZSxpWzRdPWYqdCxpWzhdPWYqcixpWzFdPWYqcyxpWzVdPWYqYSxpWzldPWYqbixpWzJdPWYqbCxpWzZdPWYqaCxpWzEwXT1mKnV9fWludmVydCgpe2xldCBpPXRoaXMuZGV0ZXJtaW5hbnQsZT1NYXRoLmFicyhpKT4xZS0xMSx0PXRoaXMucmF3RGF0YTtpZihlKXtpPTEvaTtsZXQgcj10WzBdLHM9dFs0XSxhPXRbOF0sbj10WzEyXSxsPXRbMV0saD10WzVdLHU9dFs5XSxjPXRbMTNdLGY9dFsyXSxkPXRbNl0scD10WzEwXSxtPXRbMTRdLF89dFszXSx2PXRbN10seT10WzExXSxDPXRbMTVdO3RbMF09aSooaCoocCpDLW0qeSktdSooZCpDLW0qdikrYyooZCp5LXAqdikpLHRbMV09LWkqKGwqKHAqQy1tKnkpLXUqKGYqQy1tKl8pK2MqKGYqeS1wKl8pKSx0WzJdPWkqKGwqKGQqQy1tKnYpLWgqKGYqQy1tKl8pK2MqKGYqdi1kKl8pKSx0WzNdPS1pKihsKihkKnktcCp2KS1oKihmKnktcCpfKSt1KihmKnYtZCpfKSksdFs0XT0taSoocyoocCpDLW0qeSktYSooZCpDLW0qdikrbiooZCp5LXAqdikpLHRbNV09aSoocioocCpDLW0qeSktYSooZipDLW0qXykrbiooZip5LXAqXykpLHRbNl09LWkqKHIqKGQqQy1tKnYpLXMqKGYqQy1tKl8pK24qKGYqdi1kKl8pKSx0WzddPWkqKHIqKGQqeS1wKnYpLXMqKGYqeS1wKl8pK2EqKGYqdi1kKl8pKSx0WzhdPWkqKHMqKHUqQy1jKnkpLWEqKGgqQy1jKnYpK24qKGgqeS11KnYpKSx0WzldPS1pKihyKih1KkMtYyp5KS1hKihsKkMtYypfKStuKihsKnktdSpfKSksdFsxMF09aSoociooaCpDLWMqdiktcyoobCpDLWMqXykrbioobCp2LWgqXykpLHRbMTFdPS1pKihyKihoKnktdSp2KS1zKihsKnktdSpfKSthKihsKnYtaCpfKSksdFsxMl09LWkqKHMqKHUqbS1jKnApLWEqKGgqbS1jKmQpK24qKGgqcC11KmQpKSx0WzEzXT1pKihyKih1Km0tYypwKS1hKihsKm0tYypmKStuKihsKnAtdSpmKSksdFsxNF09LWkqKHIqKGgqbS1jKmQpLXMqKGwqbS1jKmYpK24qKGwqZC1oKmYpKSx0WzE1XT1pKihyKihoKnAtdSpkKS1zKihsKnAtdSpmKSthKihsKmQtaCpmKSl9cmV0dXJuIGV9dHJhbnNmb3JtUG9pbnQoaSxlKXtsZXQgdD10aGlzLnJhd0RhdGE7ZXx8KGU9bmV3IGcpO2xldCByPWkueCxzPWkueSxhPWkuejtyZXR1cm4gZS54PXIqdFswXStzKnRbNF0rYSp0WzhdK3RbMTJdLGUueT1yKnRbMV0rcyp0WzVdK2EqdFs5XSt0WzEzXSxlLno9cip0WzJdK3MqdFs2XSthKnRbMTBdK3RbMTRdLGV9dHJhbnNmb3JtVmVjdG9yKGksZSl7bGV0IHQ9dGhpcy5yYXdEYXRhO2V8fChlPW5ldyBnKTtsZXQgcj1pLngscz1pLnksYT1pLno7cmV0dXJuIGUueD1yKnRbMF0rcyp0WzRdK2EqdFs4XSxlLnk9cip0WzFdK3MqdFs1XSthKnRbOV0sZS56PXIqdFsyXStzKnRbNl0rYSp0WzEwXSxlfXRyYW5zcG9zZSgpe2xldCBpPXRoaXMucmF3RGF0YTtmb3IobGV0IGU9MDtlPEYuaGVscE1hdHJpeC5yYXdEYXRhLmxlbmd0aDtlKyspRi5oZWxwTWF0cml4LnJhd0RhdGFbZV09aVtlXTtpWzFdPUYuaGVscE1hdHJpeC5yYXdEYXRhWzRdLGlbMl09Ri5oZWxwTWF0cml4LnJhd0RhdGFbOF0saVszXT1GLmhlbHBNYXRyaXgucmF3RGF0YVsxMl0saVs0XT1GLmhlbHBNYXRyaXgucmF3RGF0YVsxXSxpWzZdPUYuaGVscE1hdHJpeC5yYXdEYXRhWzldLGlbN109Ri5oZWxwTWF0cml4LnJhd0RhdGFbMTNdLGlbOF09Ri5oZWxwTWF0cml4LnJhd0RhdGFbMl0saVs5XT1GLmhlbHBNYXRyaXgucmF3RGF0YVs2XSxpWzExXT1GLmhlbHBNYXRyaXgucmF3RGF0YVsxNF0saVsxMl09Ri5oZWxwTWF0cml4LnJhd0RhdGFbM10saVsxM109Ri5oZWxwTWF0cml4LnJhd0RhdGFbN10saVsxNF09Ri5oZWxwTWF0cml4LnJhd0RhdGFbMTFdfWdldCBkZXRlcm1pbmFudCgpe2xldCBpPXRoaXMucmF3RGF0YTtyZXR1cm4oaVswXSppWzVdLWlbNF0qaVsxXSkqKGlbMTBdKmlbMTVdLWlbMTRdKmlbMTFdKS0oaVswXSppWzldLWlbOF0qaVsxXSkqKGlbNl0qaVsxNV0taVsxNF0qaVs3XSkrKGlbMF0qaVsxM10taVsxMl0qaVsxXSkqKGlbNl0qaVsxMV0taVsxMF0qaVs3XSkrKGlbNF0qaVs5XS1pWzhdKmlbNV0pKihpWzJdKmlbMTVdLWlbMTRdKmlbM10pLShpWzRdKmlbMTNdLWlbMTJdKmlbNV0pKihpWzJdKmlbMTFdLWlbMTBdKmlbM10pKyhpWzhdKmlbMTNdLWlbMTJdKmlbOV0pKihpWzJdKmlbN10taVs2XSppWzNdKX1nZXRQb3NpdGlvbihpKXtpfHwoaT1uZXcgZyk7bGV0IGU9dGhpcy5yYXdEYXRhO3JldHVybiBpLng9ZVsxMl0saS55PWVbMTNdLGkuej1lWzE0XSxpfWdldCBwb3NpdGlvbigpe3JldHVybiB0aGlzLl9wb3NpdGlvbi5zZXQodGhpcy5yYXdEYXRhWzEyXSx0aGlzLnJhd0RhdGFbMTNdLHRoaXMucmF3RGF0YVsxNF0pLHRoaXMuX3Bvc2l0aW9ufXNldCBwb3NpdGlvbihpKXtsZXQgZT10aGlzLnJhd0RhdGE7ZVsxMl09aS54LGVbMTNdPWkueSxlWzE0XT1pLnp9Z2V0IHNjYWxlKCl7bGV0IGk9dGhpcy5yYXdEYXRhO3JldHVybiBuZXcgZyhpWzBdLGlbNV0saVsxMF0pfXNldCBzY2FsZShpKXtsZXQgZT10aGlzLnJhd0RhdGE7ZVswXT1pLngsZVs1XT1pLnksZVsxMF09aS56fXRvU3RyaW5nKCl7bGV0IGk9dGhpcy5yYXdEYXRhO3JldHVyblwibWF0cml4M2QoXCIrTWF0aC5yb3VuZChpWzBdKjFlMykvMWUzK1wiLFwiK01hdGgucm91bmQoaVsxXSoxZTMpLzFlMytcIixcIitNYXRoLnJvdW5kKGlbMl0qMWUzKS8xZTMrXCIsXCIrTWF0aC5yb3VuZChpWzNdKjFlMykvMWUzK1wiLFwiK01hdGgucm91bmQoaVs0XSoxZTMpLzFlMytcIixcIitNYXRoLnJvdW5kKGlbNV0qMWUzKS8xZTMrXCIsXCIrTWF0aC5yb3VuZChpWzZdKjFlMykvMWUzK1wiLFwiK01hdGgucm91bmQoaVs3XSoxZTMpLzFlMytcIixcIitNYXRoLnJvdW5kKGlbOF0qMWUzKS8xZTMrXCIsXCIrTWF0aC5yb3VuZChpWzldKjFlMykvMWUzK1wiLFwiK01hdGgucm91bmQoaVsxMF0qMWUzKS8xZTMrXCIsXCIrTWF0aC5yb3VuZChpWzExXSoxZTMpLzFlMytcIixcIitNYXRoLnJvdW5kKGlbMTJdKjFlMykvMWUzK1wiLFwiK01hdGgucm91bmQoaVsxM10qMWUzKS8xZTMrXCIsXCIrTWF0aC5yb3VuZChpWzE0XSoxZTMpLzFlMytcIixcIitNYXRoLnJvdW5kKGlbMTVdKjFlMykvMWUzK1wiKVwifWxlcnAoaSxlLHQpe3RoaXMuY29weUZyb20oZSkuc3ViKGkpLm11bHQodCkuYWRkKGkpfWdldChpLGUpe3JldHVybiB0aGlzLnJhd0RhdGFbaStlKjRdfXNldChpLGUsdCl7dGhpcy5yYXdEYXRhW2krZSo0XT10fWdldE1heFNjYWxlT25BeGlzKCl7bGV0IGk9dGhpcy5yYXdEYXRhLGU9aVswXSppWzBdK2lbMV0qaVsxXStpWzJdKmlbMl0sdD1pWzRdKmlbNF0raVs1XSppWzVdK2lbNl0qaVs2XSxyPWlbOF0qaVs4XStpWzldKmlbOV0raVsxMF0qaVsxMF07cmV0dXJuIE1hdGguc3FydChNYXRoLm1heChlLHQscikpfXRyYW5zbGF0ZShpKXtsZXQgZT10aGlzLmdldCgwLDApKmkueCt0aGlzLmdldCgwLDEpKmkueSt0aGlzLmdldCgwLDIpKmkueit0aGlzLmdldCgwLDMpLHQ9dGhpcy5nZXQoMSwwKSppLngrdGhpcy5nZXQoMSwxKSppLnkrdGhpcy5nZXQoMSwyKSppLnordGhpcy5nZXQoMSwzKSxyPXRoaXMuZ2V0KDIsMCkqaS54K3RoaXMuZ2V0KDIsMSkqaS55K3RoaXMuZ2V0KDIsMikqaS56K3RoaXMuZ2V0KDIsMykscz10aGlzLmdldCgzLDApKmkueCt0aGlzLmdldCgzLDEpKmkueSt0aGlzLmdldCgzLDIpKmkueit0aGlzLmdldCgzLDMpO3JldHVybiB0aGlzLnNldCgwLDMsZSksdGhpcy5zZXQoMSwzLHQpLHRoaXMuc2V0KDIsMyxyKSx0aGlzLnNldCgzLDMscyksdGhpc31zZXRUUkludmVyc2UoaSxlKXtlPWUuaW52ZXJzZSgpLHEucXVhdGVybmlvblRvTWF0cml4KGUsdGhpcyksdGhpcy50cmFuc2xhdGUobmV3IGcoLWkueCwtaS55LC1pLnopKX1zZXRTY2FsZShpKXtyZXR1cm4gdGhpcy5zZXQoMCwwLGkueCksdGhpcy5zZXQoMCwxLDApLHRoaXMuc2V0KDAsMiwwKSx0aGlzLnNldCgwLDMsMCksdGhpcy5zZXQoMSwwLDApLHRoaXMuc2V0KDEsMSxpLnkpLHRoaXMuc2V0KDEsMiwwKSx0aGlzLnNldCgxLDMsMCksdGhpcy5zZXQoMiwwLDApLHRoaXMuc2V0KDIsMSwwKSx0aGlzLnNldCgyLDIsaS56KSx0aGlzLnNldCgyLDMsMCksdGhpcy5zZXQoMywwLDApLHRoaXMuc2V0KDMsMSwwKSx0aGlzLnNldCgzLDIsMCksdGhpcy5zZXQoMywzLDEpLHRoaXN9bWFrZUJhc2lzKGksZSx0KXtyZXR1cm4gdGhpcy5zZXRFbGVtZW50cyhpLngsZS54LHQueCwwLGkueSxlLnksdC55LDAsaS56LGUueix0LnosMCwwLDAsMCwxKSx0aGlzfW1ha2VSb3RhdGlvbkF4aXMoaSxlKXtjb25zdCB0PU1hdGguY29zKGUpLHI9TWF0aC5zaW4oZSkscz0xLXQsYT1pLngsbj1pLnksbD1pLnosaD1zKmEsdT1zKm47cmV0dXJuIHRoaXMuc2V0RWxlbWVudHMoaCphK3QsaCpuLXIqbCxoKmwrcipuLDAsaCpuK3IqbCx1Km4rdCx1KmwtciphLDAsaCpsLXIqbix1KmwrciphLHMqbCpsK3QsMCwwLDAsMCwxKSx0aGlzfXN0YXRpYyB0cmFuc3Bvc2UoaSxlKXtlfHwoZT1uZXcgRik7bGV0IHQ9aS5yYXdEYXRhLHI9ZS5yYXdEYXRhO3JldHVybiByWzBdPXRbMF0sclsxXT10WzRdLHJbMl09dFs4XSxyWzNdPXRbMTJdLHJbNF09dFsxXSxyWzVdPXRbNV0scls2XT10WzldLHJbN109dFsxM10scls4XT10WzJdLHJbOV09dFs2XSxyWzEwXT10WzEwXSxyWzExXT10WzE0XSxyWzEyXT10WzNdLHJbMTNdPXRbN10sclsxNF09dFsxMV0sclsxNV09dFsxNV0sZX1zdGF0aWMgaW52ZXJzZShpLGUpe2V8fChlPW5ldyBGKTtsZXQgdD1pLnJhd0RhdGEscj1lLnJhd0RhdGE7clswXT10WzVdKnRbMTBdKnRbMTVdLXRbNV0qdFsxNF0qdFsxMV0tdFs2XSp0WzldKnRbMTVdK3RbNl0qdFsxM10qdFsxMV0rdFs3XSp0WzldKnRbMTRdLXRbN10qdFsxM10qdFsxMF0sclsxXT0tdFsxXSp0WzEwXSp0WzE1XSt0WzFdKnRbMTRdKnRbMTFdK3RbMl0qdFs5XSp0WzE1XS10WzJdKnRbMTNdKnRbMTFdLXRbM10qdFs5XSp0WzE0XSt0WzNdKnRbMTNdKnRbMTBdLHJbMl09dFsxXSp0WzZdKnRbMTVdLXRbMV0qdFsxNF0qdFs3XS10WzJdKnRbNV0qdFsxNV0rdFsyXSp0WzEzXSp0WzddK3RbM10qdFs1XSp0WzE0XS10WzNdKnRbMTNdKnRbNl0sclszXT0tdFsxXSp0WzZdKnRbMTFdK3RbMV0qdFsxMF0qdFs3XSt0WzJdKnRbNV0qdFsxMV0tdFsyXSp0WzldKnRbN10tdFszXSp0WzVdKnRbMTBdK3RbM10qdFs5XSp0WzZdLHJbNF09LXRbNF0qdFsxMF0qdFsxNV0rdFs0XSp0WzE0XSp0WzExXSt0WzZdKnRbOF0qdFsxNV0tdFs2XSp0WzEyXSp0WzExXS10WzddKnRbOF0qdFsxNF0rdFs3XSp0WzEyXSp0WzEwXSxyWzVdPXRbMF0qdFsxMF0qdFsxNV0tdFswXSp0WzE0XSp0WzExXS10WzJdKnRbOF0qdFsxNV0rdFsyXSp0WzEyXSp0WzExXSt0WzNdKnRbOF0qdFsxNF0tdFszXSp0WzEyXSp0WzEwXSxyWzZdPS10WzBdKnRbNl0qdFsxNV0rdFswXSp0WzE0XSp0WzddK3RbMl0qdFs0XSp0WzE1XS10WzJdKnRbMTJdKnRbN10tdFszXSp0WzRdKnRbMTRdK3RbM10qdFsxMl0qdFs2XSxyWzddPXRbMF0qdFs2XSp0WzExXS10WzBdKnRbMTBdKnRbN10tdFsyXSp0WzRdKnRbMTFdK3RbMl0qdFs4XSp0WzddK3RbM10qdFs0XSp0WzEwXS10WzNdKnRbOF0qdFs2XSxyWzhdPXRbNF0qdFs5XSp0WzE1XS10WzRdKnRbMTNdKnRbMTFdLXRbNV0qdFs4XSp0WzE1XSt0WzVdKnRbMTJdKnRbMTFdK3RbN10qdFs4XSp0WzEzXS10WzddKnRbMTJdKnRbOV0scls5XT0tdFswXSp0WzldKnRbMTVdK3RbMF0qdFsxM10qdFsxMV0rdFsxXSp0WzhdKnRbMTVdLXRbMV0qdFsxMl0qdFsxMV0tdFszXSp0WzhdKnRbMTNdK3RbM10qdFsxMl0qdFs5XSxyWzEwXT10WzBdKnRbNV0qdFsxNV0tdFswXSp0WzEzXSp0WzddLXRbMV0qdFs0XSp0WzE1XSt0WzFdKnRbMTJdKnRbN10rdFszXSp0WzRdKnRbMTNdLXRbM10qdFsxMl0qdFs1XSxyWzExXT0tdFswXSp0WzVdKnRbMTFdK3RbMF0qdFs5XSp0WzddK3RbMV0qdFs0XSp0WzExXS10WzFdKnRbOF0qdFs3XS10WzNdKnRbNF0qdFs5XSt0WzNdKnRbOF0qdFs1XSxyWzEyXT0tdFs0XSp0WzldKnRbMTRdK3RbNF0qdFsxM10qdFsxMF0rdFs1XSp0WzhdKnRbMTRdLXRbNV0qdFsxMl0qdFsxMF0tdFs2XSp0WzhdKnRbMTNdK3RbNl0qdFsxMl0qdFs5XSxyWzEzXT10WzBdKnRbOV0qdFsxNF0tdFswXSp0WzEzXSp0WzEwXS10WzFdKnRbOF0qdFsxNF0rdFsxXSp0WzEyXSp0WzEwXSt0WzJdKnRbOF0qdFsxM10tdFsyXSp0WzEyXSp0WzldLHJbMTRdPS10WzBdKnRbNV0qdFsxNF0rdFswXSp0WzEzXSp0WzZdK3RbMV0qdFs0XSp0WzE0XS10WzFdKnRbMTJdKnRbNl0tdFsyXSp0WzRdKnRbMTNdK3RbMl0qdFsxMl0qdFs1XSxyWzE1XT10WzBdKnRbNV0qdFsxMF0tdFswXSp0WzldKnRbNl0tdFsxXSp0WzRdKnRbMTBdK3RbMV0qdFs4XSp0WzZdK3RbMl0qdFs0XSp0WzldLXRbMl0qdFs4XSp0WzVdO2xldCBzPXRbMF0qclswXSt0WzFdKnJbNF0rdFsyXSpyWzhdK3RbM10qclsxMl07Zm9yKGxldCBhPTA7YTwxNjthKyspclthXS89cztyZXR1cm4gZX1tYWtlRXVsZXIoaSxlLHQ9XCJYWVpcIil7Y29uc3Qgcj10aGlzLnJhd0RhdGEscz1yWzBdLGE9cls0XSxuPXJbOF0sbD1yWzFdLGg9cls1XSx1PXJbOV0sYz1yWzJdLGY9cls2XSxkPXJbMTBdO3N3aXRjaCh0KXtjYXNlXCJYWVpcIjppLnk9TWF0aC5hc2luKEsobiwtMSwxKSksTWF0aC5hYnMobik8Ljk5OTk5OTk/KGkueD1NYXRoLmF0YW4yKC11LGQpLGkuej1NYXRoLmF0YW4yKC1hLHMpKTooaS54PU1hdGguYXRhbjIoZixoKSxpLno9MCk7YnJlYWs7Y2FzZVwiWVhaXCI6aS54PU1hdGguYXNpbigtSyh1LC0xLDEpKSxNYXRoLmFicyh1KTwuOTk5OTk5OT8oaS55PU1hdGguYXRhbjIobixkKSxpLno9TWF0aC5hdGFuMihsLGgpKTooaS55PU1hdGguYXRhbjIoLWMscyksaS56PTApO2JyZWFrO2Nhc2VcIlpYWVwiOmkueD1NYXRoLmFzaW4oSyhmLC0xLDEpKSxNYXRoLmFicyhmKTwuOTk5OTk5OT8oaS55PU1hdGguYXRhbjIoLWMsZCksaS56PU1hdGguYXRhbjIoLWEsaCkpOihpLnk9MCxpLno9TWF0aC5hdGFuMihsLHMpKTticmVhaztjYXNlXCJaWVhcIjppLnk9TWF0aC5hc2luKC1LKGMsLTEsMSkpLE1hdGguYWJzKGMpPC45OTk5OTk5PyhpLng9TWF0aC5hdGFuMihmLGQpLGkuej1NYXRoLmF0YW4yKGwscykpOihpLng9MCxpLno9TWF0aC5hdGFuMigtYSxoKSk7YnJlYWs7Y2FzZVwiWVpYXCI6aS56PU1hdGguYXNpbihLKGwsLTEsMSkpLE1hdGguYWJzKGwpPC45OTk5OTk5PyhpLng9TWF0aC5hdGFuMigtdSxoKSxpLnk9TWF0aC5hdGFuMigtYyxzKSk6KGkueD0wLGkueT1NYXRoLmF0YW4yKG4sZCkpO2JyZWFrO2Nhc2VcIlhaWVwiOmkuej1NYXRoLmFzaW4oLUsoYSwtMSwxKSksTWF0aC5hYnMoYSk8Ljk5OTk5OTk/KGkueD1NYXRoLmF0YW4yKGYsaCksaS55PU1hdGguYXRhbjIobixzKSk6KGkueD1NYXRoLmF0YW4yKC11LGQpLGkueT0wKTticmVha31yZXR1cm4gZSYmaS5tdWx0aXBseVNjYWxhcihxaSksaX1zZXRFbGVtZW50cyhpLGUsdCxyLHMsYSxuLGwsaCx1LGMsZixkLHAsbSxfKXtjb25zdCB2PXRoaXMucmF3RGF0YTtyZXR1cm4gdlswXT1pLHZbNF09ZSx2WzhdPXQsdlsxMl09cix2WzFdPXMsdls1XT1hLHZbOV09bix2WzEzXT1sLHZbMl09aCx2WzZdPXUsdlsxMF09Yyx2WzE0XT1mLHZbM109ZCx2WzddPXAsdlsxMV09bSx2WzE1XT1fLHRoaXN9bWFrZU1hdHJpeDQ0QnlRdWF0ZXJuaW9uKGksZSx0KXt0aGlzLmlkZW50aXR5KCkscS5xdWF0ZXJuaW9uVG9NYXRyaXgodCx0aGlzKSx0aGlzLmFwcGVuZFRyYW5zbGF0aW9uKGkueCxpLnksaS56KSx0aGlzLmFwcGVuZFNjYWxlKGUueCxlLnksZS56KX19O2xldCBWPUY7byhWLFwiYmxvY2tCeXRlc1wiLDE2KjQpLG8oVixcImJsb2NrXCIsMTYpLG8oVixcImFsbG9jQ291bnRcIiwxZTMpLG8oVixcImFsbG9jT25jZUNvdW50XCIsMWUzKSxvKFYsXCJtYXhDb3VudFwiLDUwKjFlNCksbyhWLFwidXNlQ291bnRcIiwwKSxvKFYsXCJidWZmZXJcIiksbyhWLFwid2FzbU1hdHJpeFB0clwiLDApLG8oVixcImR5bmFtaWNNYXRyaXhCeXRlc1wiKSxvKFYsXCJkeW5hbWljR2xvYmFsTWF0cml4UmVmXCIpLG8oVixcIndhc21cIiksbyhWLFwiaGVscF9tYXRyaXhfMFwiKSxvKFYsXCJoZWxwX21hdHJpeF8xXCIpLG8oVixcImhlbHBfbWF0cml4XzJcIiksbyhWLFwiaGVscE1hdHJpeFwiKSxvKFYsXCJoZWxwTWF0cml4MlwiKSxvKFYsXCJfZ2V0RXVsZXJNYXRyaXhcIiksbyhWLFwiX3plcm9cIixuZXcgZygwLDAsMCkpLG8oVixcIl9vbmVcIixuZXcgZygxLDEsMSkpLG8oVixcIl9wcnNcIixbbmV3IGcsbmV3IGcsbmV3IGddKSxvKFYsXCJmbG9hdDMyQXJyYXlcIixuZXcgRmxvYXQzMkFycmF5KDE2KS5maWxsKDApKSxvKFYsXCJkZWNvbXBvc2VSYXdEYXRhXCIsbmV3IEZsb2F0MzJBcnJheSgxNikuZmlsbCgwKSk7ZnVuY3Rpb24gX2woaSxlLHQpe2ZvcihsZXQgcj0wO3I8NDtyKyspdC5yYXdEYXRhW3JdPWkucmF3RGF0YVtyXSplLnJhd0RhdGFbMF0raS5yYXdEYXRhW3IrNF0qZS5yYXdEYXRhWzFdK2kucmF3RGF0YVtyKzhdKmUucmF3RGF0YVsyXStpLnJhd0RhdGFbcisxMl0qZS5yYXdEYXRhWzNdLHQucmF3RGF0YVtyKzRdPWkucmF3RGF0YVtyXSplLnJhd0RhdGFbNF0raS5yYXdEYXRhW3IrNF0qZS5yYXdEYXRhWzVdK2kucmF3RGF0YVtyKzhdKmUucmF3RGF0YVs2XStpLnJhd0RhdGFbcisxMl0qZS5yYXdEYXRhWzddLHQucmF3RGF0YVtyKzhdPWkucmF3RGF0YVtyXSplLnJhd0RhdGFbOF0raS5yYXdEYXRhW3IrNF0qZS5yYXdEYXRhWzldK2kucmF3RGF0YVtyKzhdKmUucmF3RGF0YVsxMF0raS5yYXdEYXRhW3IrMTJdKmUucmF3RGF0YVsxMV0sdC5yYXdEYXRhW3IrMTJdPWkucmF3RGF0YVtyXSplLnJhd0RhdGFbMTJdK2kucmF3RGF0YVtyKzRdKmUucmF3RGF0YVsxM10raS5yYXdEYXRhW3IrOF0qZS5yYXdEYXRhWzE0XStpLnJhd0RhdGFbcisxMl0qZS5yYXdEYXRhWzE1XX1mdW5jdGlvbiBScyhpLGUsdCxyKXtsZXQgcz1yLnJhd0RhdGEsYT1pLngqX2Usbj1pLnkqX2UsbD1pLnoqX2UsaD0wLHU9YSouNSxjPW4qLjUsZj1sKi41LGQ9TWF0aC5jb3ModSkscD1NYXRoLnNpbih1KSxtPU1hdGguY29zKGMpLF89TWF0aC5zaW4oYyksdj1NYXRoLmNvcyhmKSx5PU1hdGguc2luKGYpO2g9ZCptKnYrcCpfKnksYT1wKm0qdi1kKl8qeSxuPWQqXyp2K3AqbSp5LGw9ZCptKnktcCpfKnY7bGV0IEM9YSthLEI9bituLFQ9bCtsLE09YSpDLEQ9YSpCLFA9YSpULEw9bipCLEk9bipULE89bCpULGs9aCpDLEg9aCpCLFc9aCpULG5lPXQueCxmZT10Lnksd2U9dC56O3NbMF09KDEtKEwrTykpKm5lLHNbMV09KEQrVykqbmUsc1syXT0oUC1IKSpuZSxzWzNdPTAsc1s0XT0oRC1XKSpmZSxzWzVdPSgxLShNK08pKSpmZSxzWzZdPShJK2spKmZlLHNbN109MCxzWzhdPShQK0gpKndlLHNbOV09KEktaykqd2Usc1sxMF09KDEtKE0rTCkpKndlLHNbMTFdPTAsc1sxMl09ZS54LHNbMTNdPWUueSxzWzE0XT1lLnosc1sxNV09MX1mdW5jdGlvbiB4bChpLGUsdCl7bGV0IHI9aS5yYXdEYXRhLHM9dC5yYXdEYXRhLGE9clswXSxuPXJbNF0sbD1yWzhdLGg9clsxMl0sdT1yWzFdLGM9cls1XSxmPXJbOV0sZD1yWzEzXSxwPXJbMl0sbT1yWzZdLF89clsxMF0sdj1yWzE0XSx5PXJbM10sQz1yWzddLEI9clsxMV0sVD1yWzE1XTtzWzBdPWEqZS5yYXdEYXRhWzBdK3UqZS5yYXdEYXRhWzRdK3AqZS5yYXdEYXRhWzhdK3kqZS5yYXdEYXRhWzEyXSxzWzFdPWEqZS5yYXdEYXRhWzFdK3UqZS5yYXdEYXRhWzVdK3AqZS5yYXdEYXRhWzldK3kqZS5yYXdEYXRhWzEzXSxzWzJdPWEqZS5yYXdEYXRhWzJdK3UqZS5yYXdEYXRhWzZdK3AqZS5yYXdEYXRhWzEwXSt5KmUucmF3RGF0YVsxNF0sc1szXT1hKmUucmF3RGF0YVszXSt1KmUucmF3RGF0YVs3XStwKmUucmF3RGF0YVsxMV0reSplLnJhd0RhdGFbMTVdLHNbNF09biplLnJhd0RhdGFbMF0rYyplLnJhd0RhdGFbNF0rbSplLnJhd0RhdGFbOF0rQyplLnJhd0RhdGFbMTJdLHNbNV09biplLnJhd0RhdGFbMV0rYyplLnJhd0RhdGFbNV0rbSplLnJhd0RhdGFbOV0rQyplLnJhd0RhdGFbMTNdLHNbNl09biplLnJhd0RhdGFbMl0rYyplLnJhd0RhdGFbNl0rbSplLnJhd0RhdGFbMTBdK0MqZS5yYXdEYXRhWzE0XSxzWzddPW4qZS5yYXdEYXRhWzNdK2MqZS5yYXdEYXRhWzddK20qZS5yYXdEYXRhWzExXStDKmUucmF3RGF0YVsxNV0sc1s4XT1sKmUucmF3RGF0YVswXStmKmUucmF3RGF0YVs0XStfKmUucmF3RGF0YVs4XStCKmUucmF3RGF0YVsxMl0sc1s5XT1sKmUucmF3RGF0YVsxXStmKmUucmF3RGF0YVs1XStfKmUucmF3RGF0YVs5XStCKmUucmF3RGF0YVsxM10sc1sxMF09bCplLnJhd0RhdGFbMl0rZiplLnJhd0RhdGFbNl0rXyplLnJhd0RhdGFbMTBdK0IqZS5yYXdEYXRhWzE0XSxzWzExXT1sKmUucmF3RGF0YVszXStmKmUucmF3RGF0YVs3XStfKmUucmF3RGF0YVsxMV0rQiplLnJhd0RhdGFbMTVdLHNbMTJdPWgqZS5yYXdEYXRhWzBdK2QqZS5yYXdEYXRhWzRdK3YqZS5yYXdEYXRhWzhdK1QqZS5yYXdEYXRhWzEyXSxzWzEzXT1oKmUucmF3RGF0YVsxXStkKmUucmF3RGF0YVs1XSt2KmUucmF3RGF0YVs5XStUKmUucmF3RGF0YVsxM10sc1sxNF09aCplLnJhd0RhdGFbMl0rZCplLnJhd0RhdGFbNl0rdiplLnJhd0RhdGFbMTBdK1QqZS5yYXdEYXRhWzE0XSxzWzE1XT1oKmUucmF3RGF0YVszXStkKmUucmF3RGF0YVs3XSt2KmUucmF3RGF0YVsxMV0rVCplLnJhd0RhdGFbMTVdfWZ1bmN0aW9uIERkKGksZSl7bGV0IHQ9ZS54LHI9ZS55LHM9ZS56LGE9ZS53LG49aS5yYXdEYXRhLGw9Mip0KnIsaD0yKnQqcyx1PTIqdCphLGM9MipyKnMsZj0yKnIqYSxkPTIqcyphLHA9dCp0LG09cipyLF89cypzLHY9YSphO3JldHVybiBuWzBdPXAtbS1fK3Ysbls0XT1sLWQsbls4XT1oK2YsblsxMl09MCxuWzFdPWwrZCxuWzVdPS1wK20tXyt2LG5bOV09Yy11LG5bMTNdPTAsblsyXT1oLWYsbls2XT1jK3UsblsxMF09LXAtbStfK3YsblsxNF09MCxuWzNdPTAsbls3XT0wLG5bMTFdPTAsblsxNV09MSxpfWZ1bmN0aW9uIFBkKGksZSl7bGV0IHQ9ZS5yYXdEYXRhLHI9TWF0aC5zaW4oaSkscz1NYXRoLmNvcyhpKTtyZXR1cm4gdFswXT1zLHRbMV09MCx0WzJdPS1yLHRbM109MCx0WzhdPXIsdFs5XT0wLHRbMTBdPXMsdFsxMV09MCx0fWZ1bmN0aW9uIFJkKGksZSx0KXtsZXQgcj1lLngscz1lLnksYT1lLnosbj1NYXRoLmh5cG90KHIscyxhKSxsLGgsdSxjLGYsZCxwLG0sXyx2LHksQztpZihuPE1kKXJldHVybiBudWxsO249MS9uLHIqPW4scyo9bixhKj1uLGw9TWF0aC5zaW4oaSksaD1NYXRoLmNvcyhpKSx1PTEtaCxjPXIqcip1K2gsZj1zKnIqdSthKmwsZD1hKnIqdS1zKmwscD1yKnMqdS1hKmwsbT1zKnMqdStoLF89YSpzKnUrcipsLHY9ciphKnUrcypsLHk9cyphKnUtcipsLEM9YSphKnUraDtsZXQgQj10LnJhd0RhdGE7cmV0dXJuIEJbMF09YyxCWzFdPWYsQlsyXT1kLEJbM109MCxCWzRdPXAsQls1XT1tLEJbNl09XyxCWzddPTAsQls4XT12LEJbOV09eSxCWzEwXT1DLEJbMTFdPTAsQlsxMl09MCxCWzEzXT0wLEJbMTRdPTAsQlsxNV09MSxCfWZ1bmN0aW9uIHNvKGksZSx0KXtsZXQgcj1pLnJhd0RhdGEscz1yWzBdLGE9clsxXSxuPXJbMl0sbD1yWzNdLGg9cls0XSx1PXJbNV0sYz1yWzZdLGY9cls3XSxkPXJbOF0scD1yWzldLG09clsxMF0sXz1yWzExXSx2PXJbMTJdLHk9clsxM10sQz1yWzE0XSxCPXJbMTVdLFQ9ZS5yYXdEYXRhLE09dC5yYXdEYXRhLEQ9VFswXSxQPVRbMV0sTD1UWzJdLEk9VFszXTtyZXR1cm4gTVswXT1EKnMrUCpoK0wqZCtJKnYsTVsxXT1EKmErUCp1K0wqcCtJKnksTVsyXT1EKm4rUCpjK0wqbStJKkMsTVszXT1EKmwrUCpmK0wqXytJKkIsRD1UWzRdLFA9VFs1XSxMPVRbNl0sST1UWzddLE1bNF09RCpzK1AqaCtMKmQrSSp2LE1bNV09RCphK1AqdStMKnArSSp5LE1bNl09RCpuK1AqYytMKm0rSSpDLE1bN109RCpsK1AqZitMKl8rSSpCLEQ9VFs4XSxQPVRbOV0sTD1UWzEwXSxJPVRbMTFdLE1bOF09RCpzK1AqaCtMKmQrSSp2LE1bOV09RCphK1AqdStMKnArSSp5LE1bMTBdPUQqbitQKmMrTCptK0kqQyxNWzExXT1EKmwrUCpmK0wqXytJKkIsRD1UWzEyXSxQPVRbMTNdLEw9VFsxNF0sST1UWzE1XSxNWzEyXT1EKnMrUCpoK0wqZCtJKnYsTVsxM109RCphK1AqdStMKnArSSp5LE1bMTRdPUQqbitQKmMrTCptK0kqQyxNWzE1XT1EKmwrUCpmK0wqXytJKkIsTX12YXIgUWU9KGk9PihpW2kuTm9uZT0wXT1cIk5vbmVcIixpW2kuUG9pbnRMaWdodD0xXT1cIlBvaW50TGlnaHRcIixpW2kuRGlyZWN0aW9uTGlnaHQ9Ml09XCJEaXJlY3Rpb25MaWdodFwiLGlbaS5TcG90TGlnaHQ9M109XCJTcG90TGlnaHRcIixpW2kuU2t5TGlnaHQ9NF09XCJTa3lMaWdodFwiLGkpKShRZXx8e30pO2NsYXNzIEdyIGV4dGVuZHMgd2l7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcImluZGV4XCIsLTEpLG8odGhpcyxcImxpZ2h0VHlwZVwiLC0xKSxvKHRoaXMsXCJyYWRpdXNcIiwuNSksbyh0aGlzLFwibGluZWFyXCIsMSksbyh0aGlzLFwibGlnaHRQb3NpdGlvblwiLG5ldyBnKSxvKHRoaXMsXCJsaWdodE1hdHJpeEluZGV4XCIsLTEpLG8odGhpcyxcImRpcmVjdGlvblwiLG5ldyBnKSxvKHRoaXMsXCJxdWFkcmF0aWNcIiwuMDMyKSxvKHRoaXMsXCJsaWdodENvbG9yXCIsbmV3IHooMSwxLDEsMSkpLG8odGhpcyxcImludGVuc2l0eVwiLDEpLG8odGhpcyxcImlubmVyQW5nbGVcIiwwKSxvKHRoaXMsXCJvdXRlckFuZ2xlXCIsMSksbyh0aGlzLFwicmFuZ2VcIiwxMDApLG8odGhpcyxcImNhc3RTaGFkb3dJbmRleFwiLC0xKSxvKHRoaXMsXCJsaWdodFRhbmdlbnRcIixnLkZPUldBUkQpLG8odGhpcyxcImllc0luZGV4XCIsLTEpfX1vKEdyLFwibGlnaHRTaXplXCIsMjQpO2NvbnN0IHZsPWNsYXNze3N0YXRpYyBpbml0KCl7dGhpcy5faW5pdHx8KHRoaXMuX2luaXQ9ITAsdGhpcy5jb21wb25lbnRzVXBkYXRlTGlzdD1uZXcgTWFwLHRoaXMuY29tcG9uZW50c0xhdGVVcGRhdGVMaXN0PW5ldyBNYXAsdGhpcy5jb21wb25lbnRzQmVmb3JlVXBkYXRlTGlzdD1uZXcgTWFwLHRoaXMuY29tcG9uZW50c0NvbXB1dGVMaXN0PW5ldyBNYXAsdGhpcy5jb21wb25lbnRzRW5hYmxlUGlja2VyTGlzdD1uZXcgTWFwLHRoaXMuZ3JhcGhpY0NvbXBvbmVudD1uZXcgTWFwLHRoaXMud2FpdFN0YXJ0Q29tcG9uZW50PW5ldyBNYXApfXN0YXRpYyBiaW5kVXBkYXRlKGksZSx0KXt0aGlzLmluaXQoKTtsZXQgcj10aGlzLmNvbXBvbmVudHNVcGRhdGVMaXN0LmdldChpKTtyfHwocj1uZXcgTWFwLHRoaXMuY29tcG9uZW50c1VwZGF0ZUxpc3Quc2V0KGkscikpLHIuc2V0KGUsdCl9c3RhdGljIHVuQmluZFVwZGF0ZShpLGUpe3RoaXMuaW5pdCgpO2xldCB0PXRoaXMuY29tcG9uZW50c1VwZGF0ZUxpc3QuZ2V0KGkpO3QmJnQuZGVsZXRlKGUpfXN0YXRpYyBiaW5kTGF0ZVVwZGF0ZShpLGUsdCl7dGhpcy5pbml0KCk7bGV0IHI9dGhpcy5jb21wb25lbnRzTGF0ZVVwZGF0ZUxpc3QuZ2V0KGkpO3J8fChyPW5ldyBNYXAsdGhpcy5jb21wb25lbnRzTGF0ZVVwZGF0ZUxpc3Quc2V0KGkscikpLHIuc2V0KGUsdCl9c3RhdGljIHVuQmluZExhdGVVcGRhdGUoaSxlKXt0aGlzLmluaXQoKTtsZXQgdD10aGlzLmNvbXBvbmVudHNMYXRlVXBkYXRlTGlzdC5nZXQoaSk7dCYmdC5kZWxldGUoZSl9c3RhdGljIGJpbmRCZWZvcmVVcGRhdGUoaSxlLHQpe3RoaXMuaW5pdCgpO2xldCByPXRoaXMuY29tcG9uZW50c0JlZm9yZVVwZGF0ZUxpc3QuZ2V0KGkpO3J8fChyPW5ldyBNYXAsdGhpcy5jb21wb25lbnRzQmVmb3JlVXBkYXRlTGlzdC5zZXQoaSxyKSksci5zZXQoZSx0KX1zdGF0aWMgdW5CaW5kQmVmb3JlVXBkYXRlKGksZSl7dGhpcy5pbml0KCk7bGV0IHQ9dGhpcy5jb21wb25lbnRzQmVmb3JlVXBkYXRlTGlzdC5nZXQoaSk7dCYmdC5kZWxldGUoZSl9c3RhdGljIGJpbmRDb21wdXRlKGksZSx0KXt0aGlzLmluaXQoKTtsZXQgcj10aGlzLmNvbXBvbmVudHNDb21wdXRlTGlzdC5nZXQoaSk7cnx8KHI9bmV3IE1hcCx0aGlzLmNvbXBvbmVudHNDb21wdXRlTGlzdC5zZXQoaSxyKSksci5zZXQoZSx0KX1zdGF0aWMgdW5CaW5kQ29tcHV0ZShpLGUpe3RoaXMuaW5pdCgpO2xldCB0PXRoaXMuY29tcG9uZW50c0NvbXB1dGVMaXN0LmdldChpKTt0JiZ0LmRlbGV0ZShlKX1zdGF0aWMgYmluZEdyYXBoaWMoaSxlLHQpe3RoaXMuaW5pdCgpO2xldCByPXRoaXMuZ3JhcGhpY0NvbXBvbmVudC5nZXQoaSk7cnx8KHI9bmV3IE1hcCx0aGlzLmdyYXBoaWNDb21wb25lbnQuc2V0KGkscikpLHIuc2V0KGUsdCl9c3RhdGljIHVuQmluZEdyYXBoaWMoaSxlKXt0aGlzLmluaXQoKTtsZXQgdD10aGlzLmdyYXBoaWNDb21wb25lbnQuZ2V0KGkpO3QmJnQuZGVsZXRlKGUpfXN0YXRpYyBhcHBlbmRXYWl0U3RhcnQoaSl7dGhpcy5pbml0KCk7bGV0IGU9dGhpcy53YWl0U3RhcnRDb21wb25lbnQuZ2V0KGkub2JqZWN0M0QpO2U/ZS5pbmRleE9mKGkpPT0tMSYmZS5wdXNoKGkpOnRoaXMud2FpdFN0YXJ0Q29tcG9uZW50LnNldChpLm9iamVjdDNELFtpXSl9c3RhdGljIHJlbW92ZVdhaXRTdGFydChpLGUpe3RoaXMuaW5pdCgpO2xldCB0PXZsLndhaXRTdGFydENvbXBvbmVudC5nZXQoaSk7aWYodCl7bGV0IHI9dC5pbmRleE9mKGUpO3IhPS0xJiZ0LnNwbGljZShyKX19c3RhdGljIGJpbmRFbmFibGVQaWNrKGksZSx0KXt0aGlzLmluaXQoKTtsZXQgcj10aGlzLmNvbXBvbmVudHNFbmFibGVQaWNrZXJMaXN0LmdldChpKTtyfHwocj1uZXcgTWFwLHRoaXMuY29tcG9uZW50c0VuYWJsZVBpY2tlckxpc3Quc2V0KGkscikpLHIuc2V0KGUsdCl9c3RhdGljIHVuQmluZEVuYWJsZVBpY2soaSxlKXt0aGlzLmluaXQoKTtsZXQgdD10aGlzLmNvbXBvbmVudHNFbmFibGVQaWNrZXJMaXN0LmdldChpKTt0JiZ0LmRlbGV0ZShlKX19O2xldCBhZT12bDtvKGFlLFwiY29tcG9uZW50c1VwZGF0ZUxpc3RcIiksbyhhZSxcImNvbXBvbmVudHNMYXRlVXBkYXRlTGlzdFwiKSxvKGFlLFwiY29tcG9uZW50c0JlZm9yZVVwZGF0ZUxpc3RcIiksbyhhZSxcImNvbXBvbmVudHNDb21wdXRlTGlzdFwiKSxvKGFlLFwiY29tcG9uZW50c0VuYWJsZVBpY2tlckxpc3RcIiksbyhhZSxcImdyYXBoaWNDb21wb25lbnRcIiksbyhhZSxcIndhaXRTdGFydENvbXBvbmVudFwiKSxvKGFlLFwiX2luaXRcIiwhMSk7Y2xhc3MgRWV7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJvYmplY3QzRFwiLG51bGwpLG8odGhpcyxcIl9ldmVudERpc3BhdGNoZXJcIiksbyh0aGlzLFwiX2VuYWJsZVwiLCEwKSxvKHRoaXMsXCJfX2lzU3RhcnRcIiwhMSksbyh0aGlzLFwiaXNEZXN0cm95ZWRcIil9Z2V0IGV2ZW50RGlzcGF0Y2hlcigpe3JldHVybiB0aGlzLl9ldmVudERpc3BhdGNoZXJ8fCh0aGlzLl9ldmVudERpc3BhdGNoZXI9bmV3IGhpKSx0aGlzLl9ldmVudERpc3BhdGNoZXJ9c2V0IGV2ZW50RGlzcGF0Y2hlcihlKXtjb25zb2xlLmVycm9yKFwiVGhlIGV2ZW50RGlzcGF0Y2hlciBzaG91bGQgbm90IGJlIHNldCBleHRlcm5hbGx5IVwiKX1nZXQgaXNTdGFydCgpe3JldHVybiB0aGlzLl9faXNTdGFydH1nZXQgdHJhbnNmb3JtKCl7cmV0dXJuIHRoaXMub2JqZWN0M0QudHJhbnNmb3JtfXNldCBlbmFibGUoZSl7dmFyIHQscjt0aGlzLl9lbmFibGUhPWUmJih0aGlzLl9lbmFibGU9ZSx0aGlzLl9lbmFibGU/KHQ9dGhpcy5vbkVuYWJsZSk9PW51bGx8fHQuY2FsbCh0aGlzLHRoaXMudHJhbnNmb3JtLnZpZXczRCk6KHI9dGhpcy5vbkRpc2FibGUpPT1udWxsfHxyLmNhbGwodGhpcyx0aGlzLnRyYW5zZm9ybS52aWV3M0QpKX1nZXQgZW5hYmxlKCl7cmV0dXJuIHRoaXMuX2VuYWJsZX1fX2luaXQoZSl7dGhpcy5pbml0KGUpfV9fc3RhcnQoKXt2YXIgZSx0O3RoaXMudHJhbnNmb3JtJiZ0aGlzLnRyYW5zZm9ybS5zY2VuZTNEJiZ0aGlzLl9lbmFibGUmJigoZT10aGlzLm9uRW5hYmxlKT09bnVsbHx8ZS5jYWxsKHRoaXMsdGhpcy50cmFuc2Zvcm0udmlldzNEKSksdGhpcy50cmFuc2Zvcm0mJnRoaXMudHJhbnNmb3JtLnNjZW5lM0QmJnRoaXMuX19pc1N0YXJ0PT0hMSYmKCh0PXRoaXMuc3RhcnQpPT1udWxsfHx0LmNhbGwodGhpcyksdGhpcy5fX2lzU3RhcnQ9ITApLHRoaXMub25VcGRhdGUmJnRoaXMuX29uVXBkYXRlKHRoaXMub25VcGRhdGUuYmluZCh0aGlzKSksdGhpcy5vbkxhdGVVcGRhdGUmJnRoaXMuX29uTGF0ZVVwZGF0ZSh0aGlzLm9uTGF0ZVVwZGF0ZS5iaW5kKHRoaXMpKSx0aGlzLm9uQmVmb3JlVXBkYXRlJiZ0aGlzLl9vbkJlZm9yZVVwZGF0ZSh0aGlzLm9uQmVmb3JlVXBkYXRlLmJpbmQodGhpcykpLHRoaXMub25Db21wdXRlJiZ0aGlzLl9vbkNvbXB1dGUodGhpcy5vbkNvbXB1dGUuYmluZCh0aGlzKSksdGhpcy5vbkdyYXBoaWMmJnRoaXMuX29uR3JhcGhpYyh0aGlzLm9uR3JhcGhpYy5iaW5kKHRoaXMpKX1fX3N0b3AoKXt2YXIgZTt0aGlzLnRyYW5zZm9ybSYmdGhpcy50cmFuc2Zvcm0uc2NlbmUzRCYmKChlPXRoaXMub25EaXNhYmxlKT09bnVsbHx8ZS5jYWxsKHRoaXMsdGhpcy50cmFuc2Zvcm0udmlldzNEKSksdGhpcy5fb25VcGRhdGUobnVsbCksdGhpcy5fb25MYXRlVXBkYXRlKG51bGwpLHRoaXMuX29uQmVmb3JlVXBkYXRlKG51bGwpLHRoaXMuX29uQ29tcHV0ZShudWxsKSx0aGlzLl9vbkdyYXBoaWMobnVsbCl9aW5pdChlKXt9c3RhcnQoKXt9c3RvcCgpe31jbG9uZVRvKGUpe31jb3B5Q29tcG9uZW50KGUpe3JldHVybiB0aGlzfV9vblVwZGF0ZShlKXtlIT1udWxsP2FlLmJpbmRVcGRhdGUodGhpcy50cmFuc2Zvcm0udmlldzNELHRoaXMsZSk6YWUudW5CaW5kVXBkYXRlKHRoaXMudHJhbnNmb3JtLnZpZXczRCx0aGlzKX1fb25MYXRlVXBkYXRlKGUpe2UhPW51bGw/YWUuYmluZExhdGVVcGRhdGUodGhpcy50cmFuc2Zvcm0udmlldzNELHRoaXMsZSk6YWUudW5CaW5kTGF0ZVVwZGF0ZSh0aGlzLnRyYW5zZm9ybS52aWV3M0QsdGhpcyl9X29uQmVmb3JlVXBkYXRlKGUpe2UhPW51bGw/YWUuYmluZEJlZm9yZVVwZGF0ZSh0aGlzLnRyYW5zZm9ybS52aWV3M0QsdGhpcyxlKTphZS51bkJpbmRCZWZvcmVVcGRhdGUodGhpcy50cmFuc2Zvcm0udmlldzNELHRoaXMpfV9vbkNvbXB1dGUoZSl7ZSE9bnVsbD9hZS5iaW5kQ29tcHV0ZSh0aGlzLnRyYW5zZm9ybS52aWV3M0QsdGhpcyxlKTphZS51bkJpbmRDb21wdXRlKHRoaXMudHJhbnNmb3JtLnZpZXczRCx0aGlzKX1fb25HcmFwaGljKGUpe2UhPW51bGw/YWUuYmluZEdyYXBoaWModGhpcy50cmFuc2Zvcm0udmlldzNELHRoaXMsZSk6YWUudW5CaW5kR3JhcGhpYyh0aGlzLnRyYW5zZm9ybS52aWV3M0QsdGhpcyl9YmVmb3JlRGVzdHJveShlKXthZS5yZW1vdmVXYWl0U3RhcnQodGhpcy5vYmplY3QzRCx0aGlzKX1kZXN0cm95KGUpe3RoaXMuaXNEZXN0cm95ZWR8fCh0aGlzLmlzRGVzdHJveWVkPSEwLHRoaXMuZW5hYmxlPSExLHRoaXMuc3RvcCgpLHRoaXMuX29uQmVmb3JlVXBkYXRlKG51bGwpLHRoaXMuX29uVXBkYXRlKG51bGwpLHRoaXMuX29uTGF0ZVVwZGF0ZShudWxsKSx0aGlzLm9uRW5hYmxlPW51bGwsdGhpcy5vbkRpc2FibGU9bnVsbCx0aGlzLm9uVXBkYXRlPW51bGwsdGhpcy5vbkxhdGVVcGRhdGU9bnVsbCx0aGlzLm9uQmVmb3JlVXBkYXRlPW51bGwsdGhpcy5vbkNvbXB1dGU9bnVsbCx0aGlzLm9uR3JhcGhpYz1udWxsKX19Y2xhc3MgTHN7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJ2YWx1ZVwiLDApLG8odGhpcyxcImludl9iYXNlXCIsMCl9c3RhdGljIGdldChlLHQpe2xldCByPTAscz0xL3Q7Zm9yKDtlPjA7KXIrPWUldCpzLGUvPXQscy89dDtyZXR1cm4gcn1nZXRCYXNlKGUsdCl7bGV0IHI9dGhpcy5pbnZfYmFzZT0xL3Q7Zm9yKDtlPjA7KXRoaXMudmFsdWUrPXIqKGUldCksZS89dCxyKj10aGlzLmludl9iYXNlfW5leHQoKXtsZXQgZT0xLXRoaXMudmFsdWUtMWUtNztpZih0aGlzLmludl9iYXNlPGUpdGhpcy52YWx1ZSs9dGhpcy5pbnZfYmFzZTtlbHNle2xldCB0PXRoaXMuaW52X2Jhc2UscjtkbyByPXQsdCo9dGhpcy5pbnZfYmFzZTt3aGlsZSh0Pj1lKTt0aGlzLnZhbHVlKz1yK3QtMX19Z2V0KCl7cmV0dXJuIHRoaXMudmFsdWV9fWNvbnN0IEppPWNsYXNze2NvbnN0cnVjdG9yKGksZSl7byh0aGlzLFwib3JpZ2luXCIsbmV3IGcpLG8odGhpcyxcImxlbmd0aFwiLE51bWJlci5NQVhfVkFMVUUpLG8odGhpcyxcIl92ZWN0b3JcIixuZXcgZyksbyh0aGlzLFwiX2RpclwiLG5ldyBnKSxvKHRoaXMsXCJfdjBcIixuZXcgZyksbyh0aGlzLFwiX3YxXCIsbmV3IGcpLG8odGhpcyxcIl92MlwiLG5ldyBnKSxvKHRoaXMsXCJfRTFcIixuZXcgZyksbyh0aGlzLFwiX0UyXCIsbmV3IGcpLG8odGhpcyxcIl9QXCIsbmV3IGcpLG8odGhpcyxcIl9UXCIsbmV3IGcpLG8odGhpcyxcIl9RXCIsbmV3IGcpLHRoaXMub3JpZ2luLmNvcHlGcm9tKGl8fG5ldyBnKSx0aGlzLl9kaXIuY29weUZyb20oZXx8bmV3IGcpLHRoaXMuX2Rpci5ub3JtYWxpemUoKX1nZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpcn1zZXQgZGlyZWN0aW9uKGkpe3RoaXMuX2Rpci5jb3B5RnJvbShpKSx0aGlzLl9kaXIubm9ybWFsaXplKCl9Y2xvbmUoKXtyZXR1cm4gbmV3IEppKHRoaXMub3JpZ2luLHRoaXMuZGlyZWN0aW9uKX1pbnRlcnNlY3RCb3goaSxlKXtsZXQgdD10aGlzLmRpcmVjdGlvbixyPXRoaXMub3JpZ2luLHMsYSxuLGwsaCx1O2NvbnN0IGM9MS90LngsZj0xL3QueSxkPTEvdC56LHA9aS5taW4sbT1pLm1heDtyZXR1cm4gcz0oKGM+PTA/cC54Om0ueCktci54KSpjLGE9KChjPj0wP20ueDpwLngpLXIueCkqYyxuPSgoZj49MD9wLnk6bS55KS1yLnkpKmYsbD0oKGY+PTA/bS55OnAueSktci55KSpmLHM+bHx8bj5hfHwobj5zJiYocz1uKSxsPGEmJihhPWwpLGg9KChkPj0wP3AuejptLnopLXIueikqZCx1PSgoZD49MD9tLno6cC56KS1yLnopKmQscz51fHxoPmEpfHwoaD5zJiYocz1oKSx1PGEmJihhPXUpLGE8MCk/bnVsbDooZXx8KGU9bmV3IGcpLHRoaXMucG9pbnRBdChzPj0wP3M6YSxlKSl9cG9pbnRBdChpLGUpe3JldHVybiBlfHwoZT1uZXcgZyksZS5jb3B5KHRoaXMuZGlyZWN0aW9uKSxlLm11bHRpcGx5U2NhbGFyKGkpLGUuYWRkKHRoaXMub3JpZ2luLGUpLGV9Y29weShpKXtyZXR1cm4gdGhpcy5vcmlnaW4uY29weShpLm9yaWdpbiksdGhpcy5kaXJlY3Rpb24uY29weShpLmRpcmVjdGlvbiksdGhpcy5fZGlyLmNvcHkoaS5fZGlyKSx0aGlzLmxlbmd0aD1pLmxlbmd0aCx0aGlzfXNldEFwcHJveERpcmVjdGlvbihpKXt0aGlzLl9kaXI9aS5ub3JtYWxpemUoKX1zZXRPcmlnaW4oaSl7dGhpcy5vcmlnaW4uY29weUZyb20oaSl9Z2V0T3JpZ2luKCl7cmV0dXJuIHRoaXMub3JpZ2lufWdldFBvaW50KGkpe3JldHVybiB0aGlzLl9kaXIuc2NhbGVCeShpKSx0aGlzLm9yaWdpbi5hZGQodGhpcy5fZGlyKX1zcXJEaXN0VG9Qb2ludChpKXtsZXQgZT10aGlzLl9kaXIsdD1pLnN1YnRyYWN0KHRoaXMub3JpZ2luKSxyPWV0KHQsZSkscz1ldChlLGUpLGE9ci9zLG49dGhpcy5nZXRQb2ludChhKTtyZXR1cm4gaW8oaS5zdWJ0cmFjdChuKSl9YXBwbHlNYXRyaXgoaSl7dGhpcy5vcmlnaW49aS50cmFuc2Zvcm1Qb2ludCh0aGlzLm9yaWdpbiksdGhpcy5fZGlyPWkudHJhbnNmb3JtVmVjdG9yKHRoaXMuX2Rpcil9cG9pbnRJblRyaWFuZ2xlKGksZSx0LHIpe2xldCBzPXRoaXMuX3YwLGE9dGhpcy5fdjEsbj10aGlzLl92MjtyLnN1YnRyYWN0KGUscyksdC5zdWJ0cmFjdChlLGEpLGkuc3VidHJhY3QoZSxuKTtsZXQgbD1nLmRvdChzLHMpLGg9Zy5kb3QocyxhKSx1PWcuZG90KHMsbiksYz1nLmRvdChhLGEpLGY9Zy5kb3QoYSxuKSxkPTEvKGwqYy1oKmgpLHA9KGMqdS1oKmYpKmQsbT0obCpmLWgqdSkqZDtyZXR1cm4gcD49MCYmbT49MCYmcCttPDF9aW50ZXJzZWN0VHJpYW5nbGUoaSxlLHQpe2xldCByPXQudjEscz10LnYyLGE9dC52MztzLnN1YnRyYWN0KHIsdGhpcy5fRTEpLGEuc3VidHJhY3Qocix0aGlzLl9FMiksZS5jcm9zc1Byb2R1Y3QodGhpcy5fRTIsdGhpcy5fUCk7bGV0IG49dGhpcy5fRTEuZG90UHJvZHVjdCh0aGlzLl9QKTtpZihuPjA/aS5zdWJ0cmFjdChyLHRoaXMuX1QpOihyLnN1YnRyYWN0KGksdGhpcy5fVCksbj0tbiksbjwxZS00fHwodC51PXRoaXMuX1QuZG90UHJvZHVjdCh0aGlzLl9QKSx0LnU8MHx8dC51Pm4pfHwodGhpcy5fVC5jcm9zc1Byb2R1Y3QodGhpcy5fRTEsdGhpcy5fUSksdC52PWUuZG90UHJvZHVjdCh0aGlzLl9RKSx0LnY8MHx8dC51K3Qudj5uKSlyZXR1cm4gbnVsbDtsZXQgbD1uZXcgZzt0LnQwPXQudD10aGlzLl9FMi5kb3RQcm9kdWN0KHRoaXMuX1EpO2xldCBoPTEvbjtyZXR1cm4gdC50Kj1oLHQudSo9aCx0LnYqPWgsbC54PWkueCt0LnQqZS54LGwueT1pLnkrdC50KmUueSxsLno9aS56K3QudCplLnosbH1pbnRlcnNlY3RTcGhlcmUoaSxlLHQscil7bGV0IHM9aS5zdWJ0cmFjdCh0KSxhPWcuZG90KGUsZSksbj0yKmcuZG90KHMsZSksbD1nLmRvdChzLHMpLXIqcixoPW4qbi00KmEqbCx1PWcuSEVMUF8zO2lmKGg8MClyZXR1cm4gbnVsbDt7bGV0IGM9KC1uLU1hdGguc3FydChoKSkvKGEqMik7cmV0dXJuIGM8MD9udWxsOih1Lng9aS54K2MqZS54LHUueT1pLnkrYyplLnksdS56PWkueitjKmUueix1KX19aW50ZXJzZWN0aW9uU2VnbWVudChpLGUsdCl7Y29uc3Qgcj10aGlzLm9yaWdpbixzPWcuSEVMUF8wLGE9Zy5IRUxQXzEsbj1nLkhFTFBfMixsPWcuSEVMUF8zO2Uuc3VidHJhY3QoaSxzKSx0aGlzLl9kaXIuc2NhbGVUb1JlZihKaS5fcmF5bCxuKSxyLmFkZChuLGEpLGkuc3VidHJhY3QocixsKTt2YXIgaD1nLmRvdChzLHMpLHU9Zy5kb3QocyxuKSxjPWcuZG90KG4sbiksZj1nLmRvdChzLGwpLGQ9Zy5kb3QobixsKSxwPWgqYy11KnUsbSxfLHY9cCx5LEMsQj1wO3A8SmkuX3NtYWxsbnVtPyhfPTAsdj0xLEM9ZCxCPWMpOihfPXUqZC1jKmYsQz1oKmQtdSpmLF88MD8oXz0wLEM9ZCxCPWMpOl8+diYmKF89dixDPWQrdSxCPWMpKSxDPDA/KEM9MCwtZjwwP189MDotZj5oP189djooXz0tZix2PWgpKTpDPkImJihDPUIsLWYrdTwwP189MDotZit1Pmg/Xz12OihfPS1mK3Usdj1oKSksbT1NYXRoLmFicyhfKTxKaS5fc21hbGxudW0/MDpfL3YseT1NYXRoLmFicyhDKTxKaS5fc21hbGxudW0/MDpDL0I7Y29uc3QgVD1nLkhFTFBfNDtuLnNjYWxlVG9SZWYoeSxUKTtjb25zdCBNPWcuSEVMUF81O3Muc2NhbGVUb1JlZihtLE0pLE0uYWRkKGwsTSk7Y29uc3QgRD1nLkhFTFBfNjtNLnN1YnRyYWN0KFQsRCk7dmFyIFA9eT4wJiZ5PD10aGlzLl9kaXIubGVuZ3RoJiZELmxlbmd0aFNxdWFyZWQ8dCp0O2lmKFApe2xldCBMPW5ldyBnO3JldHVybiBMLmNvcHlGcm9tKGUuc3VidHJhY3QoaSkpLEwuc2NhbGVCeShtKSxMLmFkZChpLEwpLHtvdXQ6TCxsZW5ndGg6TS5sZW5ndGh9fXJldHVybntvdXQ6bnVsbCxsZW5ndGg6LTF9fWdldF92ZWMoaSxlKXtsZXQgdD1nLkhFTFBfMTtyZXR1cm4gdC54PWkueC1lLngsdC55PWkueS1lLnksdC56PWkuei1lLnosdH19O2xldCBjaT1KaTtvKGNpLFwiX3JheWxcIiwxZTkpLG8oY2ksXCJfc21hbGxudW1cIiwxZS04KTtjbGFzcyBic3tjb25zdHJ1Y3RvcihlPTAsdD0wLHI9MCxzPTApe28odGhpcyxcInhcIiksbyh0aGlzLFwieVwiKSxvKHRoaXMsXCJ3XCIpLG8odGhpcyxcImhcIiksdGhpcy54PWUsdGhpcy55PXQsdGhpcy53PXIsdGhpcy5oPXN9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMud31zZXQgd2lkdGgoZSl7dGhpcy53PWV9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLmh9c2V0IGhlaWdodChlKXt0aGlzLmg9ZX1zdGF0aWMgcG9pbnRJblJlY3QoZSx0LHIscyxhLG4pe3JldHVybiEoZTxyfHxlPmF8fHQ8c3x8dD5uKX1jbG9uZSgpe3JldHVybiBuZXcgYnModGhpcy54LHRoaXMueSx0aGlzLncsdGhpcy5oKX1jb3B5RnJvbShlKXt0aGlzLng9ZS54LHRoaXMueT1lLnksdGhpcy53PWUudyx0aGlzLmg9ZS5ofWNvcHlUbyhlKXtlLmNvcHlGcm9tKHRoaXMpfWlubmVyKGUsdCl7cmV0dXJuIShlPHRoaXMueHx8ZT50aGlzLngrdGhpcy53aWR0aHx8dDx0aGlzLnl8fHQ+dGhpcy55K3RoaXMuaGVpZ2h0KX1lcXVhbChlKXtyZXR1cm4hKHRoaXMueCE9ZS54fHx0aGlzLnkhPWUueXx8dGhpcy53aWR0aCE9ZS53aWR0aHx8dGhpcy5oZWlnaHQhPWUuaGVpZ2h0KX1lcXVhbEFyZWEoZSx0LHIscyl7cmV0dXJuISh0aGlzLnghPWV8fHRoaXMueSE9dHx8dGhpcy53aWR0aCE9cnx8dGhpcy5oZWlnaHQhPXMpfWVxdWFsSW5uZXJBcmVhKGUpe3ZhciB0PXRoaXMueCxyPXRoaXMueSxzPXRoaXMueCt0aGlzLndpZHRoLGE9dGhpcy55K3RoaXMuaGVpZ2h0LG49ZS54LGw9ZS55LGg9ZS54K2Uud2lkdGgsdT1lLnkrZS5oZWlnaHQ7cmV0dXJuIE1hdGgubWF4KHQsbik8PU1hdGgubWluKHMsaCkmJk1hdGgubWF4KHIsbCk8PU1hdGgubWluKGEsdSl9aW5uZXJBcmVhKGUsdCl7dD10fHxuZXcgYnM7dmFyIHI9dGhpcy54LHM9dGhpcy55LGE9dGhpcy54K3RoaXMud2lkdGgsbj10aGlzLnkrdGhpcy5oZWlnaHQsbD1lLngsaD1lLnksdT1lLngrZS53aWR0aCxjPWUueStlLmhlaWdodCxmPU1hdGgubWF4KHMsaCksZD1NYXRoLm1pbihuLGMpLHA9TWF0aC5tYXgocixsKSxtPU1hdGgubWluKHUsYSk7cmV0dXJuIGY+PTAmJmQ+PTAmJmQtZj49MCYmbS1wPjA/KHQueD1wLHQueT1mLHQud2lkdGg9bS1wLHQuaGVpZ2h0PWQtZik6KHQueD0wLHQueT0wLHQud2lkdGg9MCx0LmhlaWdodD0wKSx0fXNldFRvKGUsdCxyLHMpe3RoaXMueD1lLHRoaXMueT10LHRoaXMud2lkdGg9cix0aGlzLmhlaWdodD1zfX1jb25zdCBRcj1jbGFzc3tjb25zdHJ1Y3RvcihpLGUpe28odGhpcyxcImNlbnRlclwiKSxvKHRoaXMsXCJleHRlbnRzXCIpLG8odGhpcyxcIm1heFwiKSxvKHRoaXMsXCJtaW5cIiksbyh0aGlzLFwic2l6ZVwiKSxpfHwoaT1nLlpFUk8uY2xvbmUoKSksZXx8KGU9Zy5aRVJPLmNsb25lKCkpLHRoaXMuc2V0RnJvbUNlbnRlckFuZFNpemUoaSxlKX1tYWtlRW1wdHkoKXtyZXR1cm4gdGhpcy5zZXRGcm9tTWluTWF4KFFyLm1heFZlY3RvcjMsUXIubWluVmVjdG9yMyksdGhpc31zZXRGcm9tTWluTWF4KGksZSl7cmV0dXJuIHRoaXMuaW5pdCgpLGUuc3VidHJhY3QoaSx0aGlzLnNpemUpLGkuYWRkKGUsdGhpcy5jZW50ZXIpLm11bHRpcGx5U2NhbGFyKC41KSx0aGlzLmV4dGVudHMuY29weUZyb20odGhpcy5zaXplKS5tdWx0aXBseVNjYWxhciguNSksdGhpcy5taW4uY29weUZyb20oaSksdGhpcy5tYXguY29weUZyb20oZSksdGhpc31pbml0KCl7cmV0dXJuIHRoaXMubWlufHwodGhpcy5taW49bmV3IGcpLHRoaXMubWF4fHwodGhpcy5tYXg9bmV3IGcpLHRoaXMuc2l6ZXx8KHRoaXMuc2l6ZT1uZXcgZyksdGhpcy5jZW50ZXJ8fCh0aGlzLmNlbnRlcj1uZXcgZyksdGhpcy5leHRlbnRzfHwodGhpcy5leHRlbnRzPW5ldyBnKSx0aGlzfXNldEZyb21DZW50ZXJBbmRTaXplKGksZSl7cmV0dXJuIHRoaXMuc2l6ZT1lLHRoaXMuY2VudGVyPWksdGhpcy5pbml0KCksdGhpcy5leHRlbnRzLmNvcHkoZSkubXVsdGlwbHlTY2FsYXIoLjUpLHRoaXMuY2VudGVyLnN1YnRyYWN0KHRoaXMuZXh0ZW50cyx0aGlzLm1pbiksdGhpcy5jZW50ZXIuYWRkKHRoaXMuZXh0ZW50cyx0aGlzLm1heCksdGhpc31pbkZydXN0dW0oaSxlKXtyZXR1cm4gZS5jb250YWluc0JveChpLmJvdW5kKX1tZXJnZShpKXtpLm1pbi54PHRoaXMubWluLngmJih0aGlzLm1pbi54PWkubWluLngpLGkubWluLnk8dGhpcy5taW4ueSYmKHRoaXMubWluLnk9aS5taW4ueSksaS5taW4uejx0aGlzLm1pbi56JiYodGhpcy5taW4uej1pLm1pbi56KSxpLm1heC54PnRoaXMubWF4LngmJih0aGlzLm1heC54PWkubWF4LngpLGkubWF4Lnk+dGhpcy5tYXgueSYmKHRoaXMubWF4Lnk9aS5tYXgueSksaS5tYXguej50aGlzLm1heC56JiYodGhpcy5tYXguej1pLm1heC56KSx0aGlzLnNpemUueD1pLm1heC54LWkubWluLngsdGhpcy5zaXplLnk9aS5tYXgueS1pLm1pbi55LHRoaXMuc2l6ZS56PWkubWF4LnotaS5taW4ueix0aGlzLmV4dGVudHMueD10aGlzLnNpemUueCouNSx0aGlzLmV4dGVudHMueT10aGlzLnNpemUueSouNSx0aGlzLmV4dGVudHMuej10aGlzLnNpemUueiouNSx0aGlzLmNlbnRlci54PXRoaXMuZXh0ZW50cy54K2kubWluLngsdGhpcy5jZW50ZXIueT10aGlzLmV4dGVudHMueStpLm1pbi55LHRoaXMuY2VudGVyLno9dGhpcy5leHRlbnRzLnoraS5taW4uen1pbnRlcnNlY3RzKGkpe3JldHVybiB0aGlzLm1pbi54PD1pLm1heC54JiZ0aGlzLm1heC54Pj1pLm1pbi54JiZ0aGlzLm1pbi55PD1pLm1heC55JiZ0aGlzLm1heC55Pj1pLm1pbi55JiZ0aGlzLm1pbi56PD1pLm1heC56JiZ0aGlzLm1heC56Pj1pLm1pbi56fWludGVyc2VjdHNTcGhlcmUoaSl7cmV0dXJuIHRoaXMubWluLng8PWkubWF4LngmJnRoaXMubWF4Lng+PWkubWluLngmJnRoaXMubWluLnk8PWkubWF4LnkmJnRoaXMubWF4Lnk+PWkubWluLnkmJnRoaXMubWluLno8PWkubWF4LnomJnRoaXMubWF4Lno+PWkubWluLnp9aW50ZXJzZWN0c0JveChpKXtyZXR1cm4gdGhpcy5taW4ueDw9aS5tYXgueCYmdGhpcy5tYXgueD49aS5taW4ueCYmdGhpcy5taW4ueTw9aS5tYXgueSYmdGhpcy5tYXgueT49aS5taW4ueSYmdGhpcy5taW4uejw9aS5tYXgueiYmdGhpcy5tYXguej49aS5taW4uen1lcXVhbHMoaSl7cmV0dXJuIHRoaXMuY2VudGVyLmVxdWFscyhpLmNlbnRlcikmJnRoaXMuZXh0ZW50cy5lcXVhbHMoaS5leHRlbnRzKX1leHBhbmRCeVBvaW50KGkpe2kueDx0aGlzLm1pbi54JiYodGhpcy5taW4ueD1pLngpLGkueD50aGlzLm1heC54JiYodGhpcy5tYXgueD1pLngpLGkueTx0aGlzLm1pbi55JiYodGhpcy5taW4ueT1pLnkpLGkueT50aGlzLm1heC55JiYodGhpcy5tYXgueT1pLnkpLGkuejx0aGlzLm1pbi56JiYodGhpcy5taW4uej1pLnopLGkuej50aGlzLm1heC56JiYodGhpcy5tYXguej1pLnopfXN0YXRpYyBmcm9tUG9pbnRzKGkpe2Zvcih2YXIgZT1uZXcgUXIobmV3IGcsbmV3IGcpLHQ9MDt0PGkubGVuZ3RoO3QrKyllLmV4cGFuZEJ5UG9pbnQoaVt0XSk7cmV0dXJuIGV9Y2FsY3VsYXRlVHJhbnNmb3JtKGkpe31jbG9uZSgpe3ZhciBpPW5ldyBRcih0aGlzLmNlbnRlci5jbG9uZSgpLHRoaXMuc2l6ZS5jbG9uZSgpKTtyZXR1cm4gaX1pbnRlcnNlY3RzUmF5KGksZSl7dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIil9Y29udGFpbnNQb2ludChpKXtyZXR1cm4gdGhpcy5taW4ueDw9aS54JiZ0aGlzLm1heC54Pj1pLngmJnRoaXMubWluLnk8PWkueSYmdGhpcy5tYXgueT49aS55JiZ0aGlzLm1pbi56PD1pLnomJnRoaXMubWF4Lno+PWkuen1jb250YWluc0JveChpKXtsZXQgZT10aGlzLm1pbix0PXRoaXMubWF4O3JldHVybiBlLng8PWkubWluLngmJmUueTw9aS5taW4ueSYmZS56PD1pLm1pbi56JiZ0Lng+PWkubWF4LngmJnQueT49aS5tYXgueSYmdC56Pj1pLm1heC56fXVwZGF0ZUJvdW5kKCl7fWRlc3Ryb3koaSl7dGhpcy5jZW50ZXI9bnVsbCx0aGlzLmV4dGVudHM9bnVsbCx0aGlzLm1pbj1udWxsLHRoaXMubWF4PW51bGwsdGhpcy5zaXplPW51bGx9fTtsZXQgQmU9UXI7byhCZSxcIm1heFZlY3RvcjNcIixuZXcgZygxLDEsMSkubXVsdGlwbHlTY2FsYXIoTnVtYmVyLk1BWF9WQUxVRSouMSkpLG8oQmUsXCJtaW5WZWN0b3IzXCIsbmV3IGcoMSwxLDEpLm11bHRpcGx5U2NhbGFyKC1OdW1iZXIuTUFYX1ZBTFVFKi4xKSk7Y2xhc3MgeWx7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJwbGFuZXNcIiksbyh0aGlzLFwiY29ybmVyc1wiKSxvKHRoaXMsXCJib3VuZGluZ0JveFwiLG5ldyBCZSksdGhpcy5wbGFuZXM9W10sdGhpcy5jb3JuZXJzPVtdO2Zvcih2YXIgZT0wO2U8NjtlKyspdGhpcy5wbGFuZXNbZV09bmV3IGc7Zm9yKHZhciBlPTA7ZTwyKjIqMjtlKyspdGhpcy5jb3JuZXJzW2VdPW5ldyBnfXVwZGF0ZUJvdW5kQm94KGUpe3RoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7bGV0IHQ9dGhpcy5ib3VuZGluZ0JveC5taW4scj10aGlzLmJvdW5kaW5nQm94Lm1heCxzPTA7Zm9yKGxldCBhPTA7YTwyOysrYSlmb3IobGV0IG49MDtuPDI7KytuKWZvcihsZXQgbD0wO2w8MjsrK2wpe2xldCBoPXRoaXMuY29ybmVyc1tzXTtzKyssaC5zZXQoMiphLTEsMipuLTEsbCwxKSxlLnRyYW5zZm9ybVZlY3RvcjQoaCxoKSxoLmRpdihoLncsaCksdC54PU1hdGgubWluKGgueCx0LngpLHQueT1NYXRoLm1pbihoLnksdC55KSx0Lno9TWF0aC5taW4oaC56LHQueiksci54PU1hdGgubWF4KGgueCxyLngpLHIueT1NYXRoLm1heChoLnksci55KSxyLno9TWF0aC5tYXgoaC56LHIueil9cmV0dXJuIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbU1pbk1heCh0LHIpLHRoaXN9c2V0RnJ1c3R1bUNvcm5lcnMoZSl7bGV0IHQ9MDtmb3IobGV0IHI9MDtyPDI7KytyKWZvcihsZXQgcz0wO3M8MjsrK3MpZm9yKGxldCBhPTA7YTwyOysrYSl7bGV0IG49dGhpcy5jb3JuZXJzW3RdO24uc2V0KDIqci0xLDIqcy0xLGEsMSksZS50cmFuc2Zvcm1WZWN0b3I0KG4sbiksbi5kaXYobi53LG4pLHQrK319dXBkYXRlKGUpe3ZhciB0PWUucmF3RGF0YTt0aGlzLnBsYW5lc1swXS54PXRbM10tdFswXSx0aGlzLnBsYW5lc1swXS55PXRbN10tdFs0XSx0aGlzLnBsYW5lc1swXS56PXRbMTFdLXRbOF0sdGhpcy5wbGFuZXNbMF0udz10WzE1XS10WzEyXTt2YXIgcj1NYXRoLnNxcnQodGhpcy5wbGFuZXNbMF0ueCp0aGlzLnBsYW5lc1swXS54K3RoaXMucGxhbmVzWzBdLnkqdGhpcy5wbGFuZXNbMF0ueSt0aGlzLnBsYW5lc1swXS56KnRoaXMucGxhbmVzWzBdLnopO3RoaXMucGxhbmVzWzBdLngvPXIsdGhpcy5wbGFuZXNbMF0ueS89cix0aGlzLnBsYW5lc1swXS56Lz1yLHRoaXMucGxhbmVzWzBdLncvPXIsdGhpcy5wbGFuZXNbMV0ueD10WzNdK3RbMF0sdGhpcy5wbGFuZXNbMV0ueT10WzddK3RbNF0sdGhpcy5wbGFuZXNbMV0uej10WzExXSt0WzhdLHRoaXMucGxhbmVzWzFdLnc9dFsxNV0rdFsxMl0scj1NYXRoLnNxcnQodGhpcy5wbGFuZXNbMV0ueCp0aGlzLnBsYW5lc1sxXS54K3RoaXMucGxhbmVzWzFdLnkqdGhpcy5wbGFuZXNbMV0ueSt0aGlzLnBsYW5lc1sxXS56KnRoaXMucGxhbmVzWzFdLnopLHRoaXMucGxhbmVzWzFdLngvPXIsdGhpcy5wbGFuZXNbMV0ueS89cix0aGlzLnBsYW5lc1sxXS56Lz1yLHRoaXMucGxhbmVzWzFdLncvPXIsdGhpcy5wbGFuZXNbMl0ueD10WzNdK3RbMV0sdGhpcy5wbGFuZXNbMl0ueT10WzddK3RbNV0sdGhpcy5wbGFuZXNbMl0uej10WzExXSt0WzldLHRoaXMucGxhbmVzWzJdLnc9dFsxNV0rdFsxM10scj1NYXRoLnNxcnQodGhpcy5wbGFuZXNbMl0ueCp0aGlzLnBsYW5lc1syXS54K3RoaXMucGxhbmVzWzJdLnkqdGhpcy5wbGFuZXNbMl0ueSt0aGlzLnBsYW5lc1syXS56KnRoaXMucGxhbmVzWzJdLnopLHRoaXMucGxhbmVzWzJdLngvPXIsdGhpcy5wbGFuZXNbMl0ueS89cix0aGlzLnBsYW5lc1syXS56Lz1yLHRoaXMucGxhbmVzWzJdLncvPXIsdGhpcy5wbGFuZXNbM10ueD10WzNdLXRbMV0sdGhpcy5wbGFuZXNbM10ueT10WzddLXRbNV0sdGhpcy5wbGFuZXNbM10uej10WzExXS10WzldLHRoaXMucGxhbmVzWzNdLnc9dFsxNV0tdFsxM10scj1NYXRoLnNxcnQodGhpcy5wbGFuZXNbM10ueCp0aGlzLnBsYW5lc1szXS54K3RoaXMucGxhbmVzWzNdLnkqdGhpcy5wbGFuZXNbM10ueSt0aGlzLnBsYW5lc1szXS56KnRoaXMucGxhbmVzWzNdLnopLHRoaXMucGxhbmVzWzNdLngvPXIsdGhpcy5wbGFuZXNbM10ueS89cix0aGlzLnBsYW5lc1szXS56Lz1yLHRoaXMucGxhbmVzWzNdLncvPXIsdGhpcy5wbGFuZXNbNF0ueD10WzNdLXRbMl0sdGhpcy5wbGFuZXNbNF0ueT10WzddLXRbNl0sdGhpcy5wbGFuZXNbNF0uej10WzExXS10WzEwXSx0aGlzLnBsYW5lc1s0XS53PXRbMTVdLXRbMTRdLHI9TWF0aC5zcXJ0KHRoaXMucGxhbmVzWzRdLngqdGhpcy5wbGFuZXNbNF0ueCt0aGlzLnBsYW5lc1s0XS55KnRoaXMucGxhbmVzWzRdLnkrdGhpcy5wbGFuZXNbNF0ueip0aGlzLnBsYW5lc1s0XS56KSx0aGlzLnBsYW5lc1s0XS54Lz1yLHRoaXMucGxhbmVzWzRdLnkvPXIsdGhpcy5wbGFuZXNbNF0uei89cix0aGlzLnBsYW5lc1s0XS53Lz1yLHRoaXMucGxhbmVzWzVdLng9dFszXSt0WzJdLHRoaXMucGxhbmVzWzVdLnk9dFs3XSt0WzZdLHRoaXMucGxhbmVzWzVdLno9dFsxMV0rdFsxMF0sdGhpcy5wbGFuZXNbNV0udz10WzE1XSt0WzE0XSxyPU1hdGguc3FydCh0aGlzLnBsYW5lc1s1XS54KnRoaXMucGxhbmVzWzVdLngrdGhpcy5wbGFuZXNbNV0ueSp0aGlzLnBsYW5lc1s1XS55K3RoaXMucGxhbmVzWzVdLnoqdGhpcy5wbGFuZXNbNV0ueiksdGhpcy5wbGFuZXNbNV0ueC89cix0aGlzLnBsYW5lc1s1XS55Lz1yLHRoaXMucGxhbmVzWzVdLnovPXIsdGhpcy5wbGFuZXNbNV0udy89cn1jb250YWluc1BvaW50KGUpe2Zvcih2YXIgdD0wO3Q8Njt0KyspaWYodGhpcy5wbGFuZXNbdF0ueCplLngrdGhpcy5wbGFuZXNbdF0ueSplLnkrdGhpcy5wbGFuZXNbdF0ueiplLnordGhpcy5wbGFuZXNbdF0udzw9MClyZXR1cm4hMTtyZXR1cm4hMH1jb250YWluc1NwaGVyZShlKXtsZXQgdD1lLmJvdW5kLHI9MCxzLGE9ZS50cmFuc2Zvcm0ud29ybGRQb3NpdGlvbixuPXQucmFkaXVzLGw9dC5jZW50ZXIueCthLngsaD10LmNlbnRlci55K2EueSx1PXQuY2VudGVyLnorYS56O2ZvcihsZXQgYyBvZiB0aGlzLnBsYW5lcyl7aWYocz1jLngqbCtjLnkqaCtjLnoqdStjLncsczw9LW4pcmV0dXJuIDA7cz5uJiZyKyt9cmV0dXJuIHI9PT02PzI6MX1jb250YWluc0JveChlKXtsZXQgdD0wLHIsYT1NYXRoLm1heChlLnNpemUueCxlLnNpemUueSxlLnNpemUueikqMixuPWUuY2VudGVyLngsbD1lLmNlbnRlci55LGg9ZS5jZW50ZXIuejtmb3IobGV0IHUgb2YgdGhpcy5wbGFuZXMpe2lmKHI9dS54Km4rdS55KmwrdS56KmgrdS53LHI8PS1hKXJldHVybiAwO3I+YSYmdCsrfXJldHVybiB0PT09Nj8yOjF9Y29udGFpbnNCb3gyKGUpe2xldCB0PTAscixzPTEuNzQqTWF0aC5tYXgoZS5leHRlbnRzLngsZS5leHRlbnRzLnksZS5leHRlbnRzLnopO2ZvcihsZXQgYSBvZiB0aGlzLnBsYW5lcyl7aWYocj1hLngqZS5jZW50ZXIueCthLnkqZS5jZW50ZXIueSthLnoqZS5jZW50ZXIueithLncscjw9LXMpcmV0dXJuIDA7cj5zJiZ0Kyt9cmV0dXJuIHQ9PT02PzI6MX19dmFyIEllPShpPT4oaVtpLm9ydGhvPTBdPVwib3J0aG9cIixpW2kucGVyc3BlY3RpdmU9MV09XCJwZXJzcGVjdGl2ZVwiLGlbaS5zaGFkb3c9Ml09XCJzaGFkb3dcIixpKSkoSWV8fHt9KTtjbGFzcyBMZHtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJjb3JuZXJzXCIpLG8odGhpcyxcImluZGV4XCIpLHRoaXMuaW5kZXg9ZSx0aGlzLmNvcm5lcnM9W107Zm9yKGxldCB0PTA7dDw0O3QrKyl0aGlzLmNvcm5lcnMucHVzaChuZXcgZyl9fWNsYXNzIFVke2NvbnN0cnVjdG9yKGUsdCxyKXtvKHRoaXMsXCJib3VuZFwiKSxvKHRoaXMsXCJ0d29TZWN0aW9uc1wiKSxvKHRoaXMsXCJuYW1lXCIpLG8odGhpcyxcImNvbG9yXCIpLG8odGhpcyxcInNoYWRvd0NhbWVyYVwiKSxvKHRoaXMsXCJpbmRleFwiKSx0aGlzLmJvdW5kPW5ldyBCZSx0aGlzLnNoYWRvd0NhbWVyYT1OZS5jcmVhdGVDYW1lcmEzRE9iamVjdChudWxsLFwiY3NtU2hhZG93Q2FtZXJhX1wiK3IpLHRoaXMuc2hhZG93Q2FtZXJhLmlzU2hhZG93Q2FtZXJhPSEwLHRoaXMuc2hhZG93Q2FtZXJhLm9ydGhvT2ZmQ2VudGVyKDEwMCwtMTAwLDEwMCwtMTAwLDEsMWU0KSx0aGlzLnR3b1NlY3Rpb25zPVtlLHRdLHRoaXMuaW5kZXg9cixyPT0wP3RoaXMuY29sb3I9bmV3IHooMSwwLDAsMSk6cj09MT90aGlzLmNvbG9yPW5ldyB6KDAsMSwwLDEpOnI9PTI/dGhpcy5jb2xvcj1uZXcgeigwLDAsMSwxKTpyPT0zJiYodGhpcy5jb2xvcj1uZXcgeigwLDEsMSwxKSksdGhpcy5uYW1lPVwiY2hpbGRfXCIrcn11cGRhdGVCb3VuZCgpe3RoaXMuYm91bmQubWFrZUVtcHR5KCk7bGV0IGU9dGhpcy5ib3VuZC5taW4sdD10aGlzLmJvdW5kLm1heDtmb3IobGV0IHIgb2YgdGhpcy50d29TZWN0aW9ucylmb3IobGV0IHMgb2Ygci5jb3JuZXJzKWUueD1NYXRoLm1pbihzLngsZS54KSxlLnk9TWF0aC5taW4ocy55LGUueSksZS56PU1hdGgubWluKHMueixlLnopLHQueD1NYXRoLm1heChzLngsdC54KSx0Lnk9TWF0aC5tYXgocy55LHQueSksdC56PU1hdGgubWF4KHMueix0LnopO3JldHVybiB0aGlzLmJvdW5kLnNldEZyb21NaW5NYXgoZSx0KSx0aGlzfX1jbGFzcyBDbHtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJzZWN0aW9uc1wiKSxvKHRoaXMsXCJjaGlsZHJlblwiKSxvKHRoaXMsXCJuYW1lXCIpLHRoaXMuc2VjdGlvbnM9W107bGV0IHQ9ZSsxO2ZvcihsZXQgcj0wO3I8dDtyKyspdGhpcy5zZWN0aW9ucy5wdXNoKG5ldyBMZChyKSk7dGhpcy5jaGlsZHJlbj1bXTtmb3IobGV0IHI9MDtyPGU7cisrKXRoaXMuY2hpbGRyZW4ucHVzaChuZXcgVWQodGhpcy5zZWN0aW9uc1tyXSx0aGlzLnNlY3Rpb25zW3IrMV0scikpfXVwZGF0ZShlLHQscixzLGEpe2xldCBuPXRoaXMuc2VjdGlvbnMubGVuZ3RoLTE7Zm9yKGxldCBsPTA7bDw9bjsrK2wpe2xldCBoPXRoaXMuc2VjdGlvbnNbbF0sdT0wLGM9dGhpcy5sb2dTcGxpdChyLHMsbCx0aGlzLnNlY3Rpb25zLmxlbmd0aCk7e2xldCBkPShjLXIpL3M7ZD1kKiphLmNzbVNjYXR0ZXJpbmdFeHAsYz0ocy1yKSpkK3J9Yyo9YS5jc21BcmVhU2NhbGU7bGV0IGY9KGUucmF3RGF0YVsxMF0qYytlLnJhd0RhdGFbMTRdKS9jO2ZvcihsZXQgZD0wO2Q8MjsrK2QpZm9yKGxldCBwPTA7cDwyOysrcCl7bGV0IG09aC5jb3JuZXJzW3VdO3UrKyxtLnNldCgyKmQtMSwyKnAtMSxmLDEpLHQudHJhbnNmb3JtVmVjdG9yNChtLG0pLG0uZGl2KG0udyxtKX19Zm9yKGxldCBsIG9mIHRoaXMuY2hpbGRyZW4pbC51cGRhdGVCb3VuZCgpO3JldHVybiB0aGlzfXNxdWFyZVNwbGl0KGUsdCxyLHMpe3JldHVybihyLyhzLTEpKSoqNCoodC1lKStlfXVuaWZvcm1TcGxpdChlLHQscixzKXtyZXR1cm4gci8ocy0xKSoodC1lKStlfWxvZ1NwbGl0KGUsdCxyLHMpe3JldHVybiBlKih0L2UpKiooci8ocy0xKSl9fWNsYXNzIFppIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcImZvdlwiLDEpLG8odGhpcyxcIm5hbWVcIiksbyh0aGlzLFwiYXNwZWN0XCIsMSksbyh0aGlzLFwibmVhclwiLDEpLG8odGhpcyxcImZhclwiLDVlMyksbyh0aGlzLFwidmlld1BvcnRcIixuZXcgYnMpLG8odGhpcyxcImZydXN0dW1cIiksbyh0aGlzLFwiaXNTaGFkb3dDYW1lcmFcIiwhMSksbyh0aGlzLFwiX3Byb2plY3Rpb25NYXRyaXhJbnZcIixuZXcgViksbyh0aGlzLFwiX3Byb2plY3Rpb25NYXRyaXhcIixuZXcgViksbyh0aGlzLFwiX3ZpZXdNYXRyaXhcIixuZXcgViksbyh0aGlzLFwiX3VucHJvamVjdGlvblwiLG5ldyBWKSxvKHRoaXMsXCJfcHZNYXRyaXhJbnZcIixuZXcgViksbyh0aGlzLFwiX3B2TWF0cml4XCIsbmV3IFYpLG8odGhpcyxcIl9oYWxmd1wiKSxvKHRoaXMsXCJfaGFsZmhcIiksbyh0aGlzLFwiX3JheVwiKSxvKHRoaXMsXCJfZW5hYmxlQ1NNXCIsITEpLG8odGhpcyxcImxvb2tUYXJnZXRcIiksbyh0aGlzLFwidHlwZVwiLEllLnBlcnNwZWN0aXZlKSxvKHRoaXMsXCJjc21cIiksbyh0aGlzLFwiY3ViZVNoYWRvd0NhbWVyYXNcIixbXSksbyh0aGlzLFwiX2hhbHRvblNlcVwiKSxvKHRoaXMsXCJfaml0dGVyT2Zmc2V0TGlzdFwiKSxvKHRoaXMsXCJfdXNlSml0dGVyUHJvamVjdGlvblwiLCExKSxvKHRoaXMsXCJfaml0dGVyRnJhbWVJbmRleFwiLDApLG8odGhpcyxcIl9zYW1wbGVJbmRleFwiLDApLG8odGhpcyxcIl9qaXR0ZXJYXCIsMCksbyh0aGlzLFwiX2ppdHRlcllcIiwwKX1nZXQgcHJvamVjdGlvbk1hdHJpeCgpe3JldHVybiB0aGlzLl9wcm9qZWN0aW9uTWF0cml4fWdldCBlbmFibGVDU00oKXtyZXR1cm4gdGhpcy5fZW5hYmxlQ1NNfXNldCBlbmFibGVDU00oZSl7ZSYmIXRoaXMuY3NtJiYodGhpcy5jc209bmV3IENsKGx0LkNhc2NhZGVzKSksdGhpcy5fZW5hYmxlQ1NNPWV9aW5pdCgpe3N1cGVyLmluaXQoKSx0aGlzLl9yYXk9bmV3IGNpLHRoaXMuZnJ1c3R1bT1uZXcgeWwsdGhpcy52aWV3UG9ydC54PTAsdGhpcy52aWV3UG9ydC55PTAsdGhpcy52aWV3UG9ydC53PVMucHJlc2VudGF0aW9uU2l6ZVswXSx0aGlzLnZpZXdQb3J0Lmg9Uy5wcmVzZW50YXRpb25TaXplWzFdLHRoaXMubG9va1RhcmdldD1uZXcgZygwLDAsMCl9Z2V0U2hhZG93QmlhcyhlKXtsZXQgdD0yKnRoaXMuZ2V0U2hhZG93V29ybGRFeHRlbnRzKCkvZSxyPXRoaXMuZmFyLXRoaXMubmVhcjtyZXR1cm4gdC9yfWdldFNoYWRvd1dvcmxkRXh0ZW50cygpe2xldCBlPUEuc2V0dGluZy5zaGFkb3cuc2hhZG93Qm91bmQ7cmV0dXJuIGU/ZSo9LjU6ZT1NYXRoLnJvdW5kKC4wNSp0aGlzLmZydXN0dW0uYm91bmRpbmdCb3guZXh0ZW50cy5sZW5ndGgpLGV9Z2V0Q1NNU2hhZG93QmlhcyhlLHQpe2xldCByPTIqdGhpcy5nZXRDU01TaGFkb3dXb3JsZEV4dGVudHMoZSkvdCxzPXRoaXMuZmFyLXRoaXMubmVhcjtyZXR1cm4gci9zfWdldENTTVNoYWRvd1dvcmxkRXh0ZW50cyhlKXtyZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmNzbS5jaGlsZHJlbltlXS5ib3VuZC5leHRlbnRzLmxlbmd0aCl9cGVyc3BlY3RpdmUoZSx0LHIscyl7dGhpcy5mb3Y9ZSx0aGlzLmFzcGVjdD10LHRoaXMubmVhcj1yLHRoaXMuZmFyPXMsdGhpcy5fcHJvamVjdGlvbk1hdHJpeC5wZXJzcGVjdGl2ZShlLHQscixzKSx0aGlzLnR5cGU9SWUucGVyc3BlY3RpdmV9cmVzZXRQZXJzcGVjdGl2ZShlKXt0aGlzLnR5cGU9PUllLnBlcnNwZWN0aXZlJiZ0aGlzLl9wcm9qZWN0aW9uTWF0cml4LnBlcnNwZWN0aXZlKHRoaXMuZm92LGUsdGhpcy5uZWFyLHRoaXMuZmFyKX1vcnRobyhlLHQscixzKXt0aGlzLm5lYXI9TWF0aC5tYXgociwuMSksdGhpcy5mYXI9cyx0aGlzLl9wcm9qZWN0aW9uTWF0cml4Lm9ydGhvKGUsdCxyLHMpLHRoaXMudHlwZT1JZS5vcnRob31vcnRob09mZkNlbnRlcihlLHQscixzLGEsbil7dGhpcy5uZWFyPU1hdGgubWF4KGEsLjAxKSx0aGlzLmZhcj1uLHRoaXMuX3Byb2plY3Rpb25NYXRyaXgub3J0aG9PZmZDZW50ZXIoZSx0LHIscyxhLG4pLHRoaXMudHlwZT1JZS5vcnRob31vcnRob1pvKGUsdCxyLHMsYSxuKXt0aGlzLm5lYXI9TWF0aC5tYXgoYSwuMDEpLHRoaXMuZmFyPW4sdGhpcy5fcHJvamVjdGlvbk1hdHJpeC5vcnRob1pPKGUsdCxyLHMsYSxuKSx0aGlzLnR5cGU9SWUub3J0aG99Z2V0IHZpZXdNYXRyaXgoKXtyZXR1cm4gdGhpcy5fdmlld01hdHJpeC5jb3B5RnJvbSh0aGlzLnRyYW5zZm9ybS53b3JsZE1hdHJpeCksdGhpcy5fdmlld01hdHJpeC5pbnZlcnQoKSx0aGlzLl92aWV3TWF0cml4fWdldCBzaGFkb3dWaWV3TWF0cml4KCl7cmV0dXJuIHRoaXMuX3ZpZXdNYXRyaXguY29weUZyb20odGhpcy50cmFuc2Zvcm0ud29ybGRNYXRyaXgpLHRoaXMuX3ZpZXdNYXRyaXguYXBwZW5kU2NhbGUoMSwxLDEpLHRoaXMuX3ZpZXdNYXRyaXguaW52ZXJ0KCksdGhpcy5fdmlld01hdHJpeH1vYmplY3QzRFRvU2NyZWVuUmF5KGUsdD1udWxsKXtyZXR1cm4gdHx8KHQ9bmV3IGcoMCwwLDAsMSkpLHRoaXMuX2hhbGZ3PXRoaXMudmlld1BvcnQud2lkdGgqLjUsdGhpcy5faGFsZmg9dGhpcy52aWV3UG9ydC5oZWlnaHQqLjUsc3QudHJhbnNmb3JtVmVjdG9yKHRoaXMudmlld01hdHJpeCxlLHQpLHRoaXMucHJvamVjdCh0LHQpLHQueD10aGlzLl9oYWxmdyt0LngqdGhpcy5faGFsZncsdC55PXRoaXMudmlld1BvcnQuaGVpZ2h0LSh0aGlzLl9oYWxmaC10LnkqdGhpcy5faGFsZmgpLHR9c2NyZWVuUmF5VG9PYmplY3QzRChlLHQ9bnVsbCl7dHx8KHQ9bmV3IGcpLHRoaXMuX2hhbGZ3PXRoaXMudmlld1BvcnQud2lkdGgqLjUsdGhpcy5faGFsZmg9dGhpcy52aWV3UG9ydC5oZWlnaHQqLjU7bGV0IHI9ZS54LHM9ZS55O3JldHVybiB0Lng9ci90aGlzLnZpZXdQb3J0LndpZHRoLS4yNSx0Lnk9cy90aGlzLnZpZXdQb3J0LmhlaWdodC0uMjUsdGhpcy51blByb2plY3QodC54LHQueSxlLnosdCksdH1nZXQgcHZNYXRyaXgoKXtyZXR1cm4gc28odGhpcy5fcHJvamVjdGlvbk1hdHJpeCx0aGlzLnZpZXdNYXRyaXgsdGhpcy5fcHZNYXRyaXgpLHRoaXMuX3B2TWF0cml4fWdldCBwdk1hdHJpeDIoKXtzbyh0aGlzLl9wcm9qZWN0aW9uTWF0cml4LHRoaXMudHJhbnNmb3JtLndvcmxkTWF0cml4LHRoaXMuX3B2TWF0cml4KTtsZXQgZT10aGlzLl9wdk1hdHJpeEludi5jb3B5RnJvbSh0aGlzLnB2TWF0cml4KTtyZXR1cm4gZS5pbnZlcnQoKSxlfWdldCBwdk1hdHJpeEludigpe2xldCBlPXRoaXMuX3B2TWF0cml4SW52LmNvcHlGcm9tKHRoaXMucHZNYXRyaXgpO3JldHVybiBlLmludmVydCgpLGV9Z2V0IHByb2plY3Rpb25NYXRyaXhJbnYoKXtyZXR1cm4gdGhpcy5fcHJvamVjdGlvbk1hdHJpeEludi5jb3B5RnJvbSh0aGlzLl9wcm9qZWN0aW9uTWF0cml4KSx0aGlzLl9wcm9qZWN0aW9uTWF0cml4SW52LmludmVydCgpLHRoaXMuX3Byb2plY3Rpb25NYXRyaXhJbnZ9dW5Qcm9qZWN0KGUsdCxyLHMpe3JldHVybiBzfHwocz1uZXcgZykscy54PWUscy55PS10LHMuej1yLHMudz0xLHMueCo9cixzLnkqPXIsdGhpcy5fdW5wcm9qZWN0aW9uLmNvcHlGcm9tKHRoaXMuX3Byb2plY3Rpb25NYXRyaXgpLHRoaXMuX3VucHJvamVjdGlvbi5pbnZlcnQoKSxzdC50cmFuc2Zvcm1WZWN0b3IodGhpcy5fdW5wcm9qZWN0aW9uLHMscykscy56PXIsc31wcm9qZWN0KGUsdCl7cmV0dXJuIHRoaXMuX3Byb2plY3Rpb25NYXRyaXgucGVyc3BlY3RpdmVNdWx0aXBseVBvaW50MyhlLHQpLHQueD10LngvdC53LHQueT0tdC55L3Qudyx0Lno9ZS56LHR9c2NyZWVuUG9pbnRUb1JheShlLHQpe2xldCByPXRoaXMuX3JheSxzPU5lLlVuUHJvamVjdGlvbihlLHQsLjAxLHRoaXMpLGE9TmUuVW5Qcm9qZWN0aW9uKGUsdCwxLHRoaXMpO3JldHVybiBhPWEuc3VidHJhY3Qocykubm9ybWFsaXplKCksci5vcmlnaW4uY29weUZyb20ocyksci5kaXJlY3Rpb249YSxyfXNjcmVlblBvaW50VG9Xb3JsZChlLHQscil7cmV0dXJuIE5lLlVuUHJvamVjdGlvbihlLHQscix0aGlzKX13b3JsZFRvU2NyZWVuUG9pbnQoZSx0KXtyZXR1cm4gTmUuUHJvamVjdGlvbihlLHRoaXMsdCl9bG9va0F0KGUsdCxyPWcuWV9BWElTKXt0aGlzLnRyYW5zZm9ybS5sb29rQXQoZSx0LHIpLHQmJnRoaXMubG9va1RhcmdldC5jb3B5RnJvbSh0KX1yZXNldFByb2plY3RNYXRyaXgoKXt0aGlzLnBlcnNwZWN0aXZlKHRoaXMuZm92LHRoaXMuYXNwZWN0LHRoaXMubmVhcix0aGlzLmZhcil9b25VcGRhdGUoKXt2YXIgZTt0aGlzLnR5cGU9PUllLnBlcnNwZWN0aXZlJiYodGhpcy5hc3BlY3Q9Uy5hc3BlY3QsdGhpcy5yZXNldFByb2plY3RNYXRyaXgoKSksdGhpcy5fdXNlSml0dGVyUHJvamVjdGlvbiYmdGhpcy5nZXRKaXR0ZXJlZFByb2plY3Rpb25NYXRyaXgoKSx0aGlzLmZydXN0dW0udXBkYXRlKHRoaXMucHZNYXRyaXgpLHRoaXMuZnJ1c3R1bS51cGRhdGVCb3VuZEJveCh0aGlzLnB2TWF0cml4SW52KTtsZXQgdD1BLnNldHRpbmcuc2hhZG93O3RoaXMuZW5hYmxlQ1NNJiYoKGU9dGhpcy5jc20pPT1udWxsfHxlLnVwZGF0ZSh0aGlzLl9wcm9qZWN0aW9uTWF0cml4LHRoaXMuX3B2TWF0cml4SW52LHRoaXMubmVhcix0aGlzLmZhcix0KSl9Z2V0IGppdHRlckZyYW1lSW5kZXgoKXtyZXR1cm4gdGhpcy5faml0dGVyRnJhbWVJbmRleH1nZXQgaml0dGVyWCgpe3JldHVybiB0aGlzLl9qaXR0ZXJYfWdldCBqaXR0ZXJZKCl7cmV0dXJuIHRoaXMuX2ppdHRlcll9ZW5hYmxlSml0dGVyUHJvamVjdGlvbihlKXt0aGlzLl9qaXR0ZXJGcmFtZUluZGV4PTAsdGhpcy5fdXNlSml0dGVyUHJvamVjdGlvbj1lLHRoaXMuX2hhbHRvblNlcXx8KHRoaXMuX2hhbHRvblNlcT1uZXcgTHMpLHRoaXMuX2ppdHRlck9mZnNldExpc3Q9W107Zm9yKGxldCB0PTA7dDw4O3QrKyl7bGV0IHI9dGhpcy5nZW5lcmF0ZVJhbmRvbU9mZnNldCgpO3RoaXMuX2ppdHRlck9mZnNldExpc3QucHVzaChyKX10aGlzLl9qaXR0ZXJPZmZzZXRMaXN0LnJldmVyc2UoKX1nZW5lcmF0ZVJhbmRvbU9mZnNldCgpe2xldCBlPW5ldyBaKExzLmdldCgodGhpcy5fc2FtcGxlSW5kZXgmMTAyMykrMSwyKS0uNSxMcy5nZXQoKHRoaXMuX3NhbXBsZUluZGV4JjEwMjMpKzEsMyktLjUpO2NvbnN0IHQ9ODtyZXR1cm4rK3RoaXMuX3NhbXBsZUluZGV4Pj10JiYodGhpcy5fc2FtcGxlSW5kZXg9MCksZX1nZXRKaXR0ZXJlZFByb2plY3Rpb25NYXRyaXgoKXtsZXQgZT1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYSx0PXRoaXMuX3Byb2plY3Rpb25NYXRyaXgscj1lLnRlbXBvcmFsSml0dGVyU2NhbGUscz10aGlzLl9qaXR0ZXJGcmFtZUluZGV4JWUuaml0dGVyU2VlZENvdW50LGE9dGhpcy5faml0dGVyT2Zmc2V0TGlzdFtzXS54KnIsbj10aGlzLl9qaXR0ZXJPZmZzZXRMaXN0W3NdLnkqcixsPXQuZ2V0KDAsMiksaD10LmdldCgxLDIpO3RoaXMuX2ppdHRlclg9YS90aGlzLnZpZXdQb3J0LndpZHRoLHRoaXMuX2ppdHRlclk9bi90aGlzLnZpZXdQb3J0LmhlaWdodCxsKz10aGlzLl9qaXR0ZXJYLGgrPXRoaXMuX2ppdHRlclksdC5zZXQoMCwyLGwpLHQuc2V0KDEsMixoKSx0aGlzLl9qaXR0ZXJGcmFtZUluZGV4Kyt9Z2V0V29ybGREaXJlY3Rpb24oZSl7ZXx8KGU9bmV3IGcpO2NvbnN0IHQ9dGhpcy50cmFuc2Zvcm0uX3dvcmxkTWF0cml4LnJhd0RhdGE7cmV0dXJuIGUuc2V0KC10WzhdLC10WzldLC10WzEwXSkubm9ybWFsaXplKCl9fWNvbnN0IFZyPWNsYXNzIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcImV2ZW50UG9zaXRpb25DaGFuZ2VcIixuZXcgamUoVnIuUE9TSVRJT05fT05DSEFOR0UpKSxvKHRoaXMsXCJldmVudFJvdGF0aW9uQ2hhbmdlXCIsbmV3IGplKFZyLlJPVEFUSU9OX09OQ0hBTkdFKSksbyh0aGlzLFwiZXZlbnRTY2FsZUNoYW5nZVwiLG5ldyBqZShWci5TQ0FMRV9PTkNIQU5HRSkpLG8odGhpcyxcImV2ZW50TG9jYWxDaGFuZ2VcIixuZXcgamUoVnIuTE9DQUxfT05DSEFOR0UpKSxvKHRoaXMsXCJvblBvc2l0aW9uQ2hhbmdlXCIpLG8odGhpcyxcIm9uUm90YXRpb25DaGFuZ2VcIiksbyh0aGlzLFwib25TY2FsZUNoYW5nZVwiKSxvKHRoaXMsXCJfc2NlbmUzZFwiKSxvKHRoaXMsXCJfcGFyZW50XCIpLG8odGhpcyxcIl9sb2NhbFBvc1wiKSxvKHRoaXMsXCJfbG9jYWxSb3RcIiksbyh0aGlzLFwiX2xvY2FsUm90UXVhdFwiKSxvKHRoaXMsXCJfbG9jYWxTY2FsZVwiKSxvKHRoaXMsXCJfbG9jYWxEZXRhaWxQb3NcIiksbyh0aGlzLFwiX2xvY2FsRGV0YWlsUm90XCIpLG8odGhpcyxcIl9sb2NhbERldGFpbFNjYWxlXCIpLG8odGhpcyxcImluZGV4XCIpLG8odGhpcyxcImluZGV4MlwiKSxvKHRoaXMsXCJfZm9yd2FyZFwiLG5ldyBnKSxvKHRoaXMsXCJfYmFja1wiLG5ldyBnKSxvKHRoaXMsXCJfcmlnaHRcIixuZXcgZyksbyh0aGlzLFwiX2xlZnRcIixuZXcgZyksbyh0aGlzLFwiX3VwXCIsbmV3IGcpLG8odGhpcyxcIl9kb3duXCIsbmV3IGcpLG8odGhpcyxcIl93b3JsZE1hdHJpeFwiKSxvKHRoaXMsXCJfdGFyZ2V0UG9zXCIpLG8odGhpcyxcInN0YXRpY1wiLCExKSxvKHRoaXMsXCJkZXB0aE9yZGVyXCIsMCksdGhpcy5fd29ybGRNYXRyaXg9bmV3IFYoITApLHRoaXMuaW5kZXg9dGhpcy5fd29ybGRNYXRyaXguaW5kZXgsdGhpcy5pbmRleDI9dGhpcy5fd29ybGRNYXRyaXguaW5kZXgqZWUuc3RhdGVTdHJ1Y3QsdGhpcy5fbG9jYWxQb3M9bmV3IGcsdGhpcy5fbG9jYWxSb3Q9bmV3IGcsdGhpcy5fbG9jYWxSb3RRdWF0PW5ldyBxLHRoaXMuX2xvY2FsU2NhbGU9bmV3IGcoMSwxLDEpLGVlLnNldFNjYWxlKHRoaXMuaW5kZXgsdGhpcy5fbG9jYWxTY2FsZS54LHRoaXMuX2xvY2FsU2NhbGUueSx0aGlzLl9sb2NhbFNjYWxlLnopLGVlLnNldFJvdGF0aW9uKHRoaXMuaW5kZXgsdGhpcy5fbG9jYWxSb3QueCx0aGlzLl9sb2NhbFJvdC55LHRoaXMuX2xvY2FsUm90LnopLGVlLnNldFRyYW5zbGF0ZSh0aGlzLmluZGV4LHRoaXMuX2xvY2FsUG9zLngsdGhpcy5fbG9jYWxQb3MueSx0aGlzLl9sb2NhbFBvcy56KX1nZXQgbG9jYWxDaGFuZ2UoKXtyZXR1cm4gZWUubWF0cml4U3RhdGVCdWZmZXJbdGhpcy5pbmRleDJdIT0wfXNldCBsb2NhbENoYW5nZShpKXtlZS5tYXRyaXhTdGF0ZUJ1ZmZlclt0aGlzLmluZGV4Ml09aT8xOjB9Z2V0IHRhcmdldFBvcygpe3JldHVybiB0aGlzLl90YXJnZXRQb3N9c2V0IHRhcmdldFBvcyhpKXt0aGlzLl90YXJnZXRQb3M9aX1nZXQgcGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudH1zZXQgcGFyZW50KGkpe3ZhciBlO2xldCB0PShlPXRoaXMuX3BhcmVudCk9PW51bGw/dm9pZCAwOmUub2JqZWN0M0Q7aWYodGhpcy5fcGFyZW50PWksdGhpcy5kZXB0aE9yZGVyPWk/aS5kZXB0aE9yZGVyKzE6MCxlZS5zZXRQYXJlbnQodGhpcy5pbmRleCxpP2kud29ybGRNYXRyaXguaW5kZXg6LTEsdGhpcy5kZXB0aE9yZGVyKSx0aGlzLmxvY2FsQ2hhbmdlPSEwLHRoaXMub2JqZWN0M0Qpe2xldCByPWk/aS5zY2VuZTNEOm51bGw7cj8odGhpcy5fc2NlbmUzZD1yLHRoaXMub2JqZWN0M0QuY29tcG9uZW50cy5mb3JFYWNoKHM9PnthZS5hcHBlbmRXYWl0U3RhcnQocyl9KSk6dGhpcy5vYmplY3QzRC5jb21wb25lbnRzLmZvckVhY2gocz0+e3MuX19zdG9wKCl9KTtmb3IobGV0IHMgb2YgdGhpcy5vYmplY3QzRC5lbnRpdHlDaGlsZHJlbilzLnRyYW5zZm9ybS5wYXJlbnQ9aT90aGlzOm51bGw7dGhpcy5vYmplY3QzRC5jb21wb25lbnRzLmZvckVhY2gocz0+e3ZhciBhLG47KG49cy5vblBhcmVudENoYW5nZSk9PW51bGx8fG4uY2FsbChzLHQsKGE9dGhpcy5fcGFyZW50KT09bnVsbD92b2lkIDA6YS5vYmplY3QzRCl9KX10aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCl9c2V0IGVuYWJsZShpKXt0aGlzLnRyYW5zZm9ybS5fc2NlbmUzZCYmaT9zdXBlci5lbmFibGU9ITA6c3VwZXIuZW5hYmxlPSExO2ZvcihsZXQgZSBvZiB0aGlzLm9iamVjdDNELmVudGl0eUNoaWxkcmVuKWUudHJhbnNmb3JtLmVuYWJsZT1pfWdldCBlbmFibGUoKXtyZXR1cm4gdGhpcy5fZW5hYmxlfWdldCBzY2VuZTNEKCl7cmV0dXJuIHRoaXMuX3NjZW5lM2R9c2V0IHNjZW5lM0QoaSl7dGhpcy5fc2NlbmUzZD1pfWdldCB2aWV3M0QoKXtyZXR1cm4gdGhpcy5fc2NlbmUzZCYmdGhpcy5fc2NlbmUzZC52aWV3P3RoaXMuX3NjZW5lM2QudmlldzpudWxsfWF3YWtlKCl7fXN0YXJ0KCl7fXN0b3AoKXt9bm90aWZ5TG9jYWxDaGFuZ2UoKXtpZih0aGlzLmxvY2FsQ2hhbmdlPSEwLHRoaXMub2JqZWN0M0Qpe2xldCBpPXRoaXMub2JqZWN0M0QuZW50aXR5Q2hpbGRyZW4sZT0wLHQ9aS5sZW5ndGg7Zm9yKGU9MDtlPHQ7ZSsrKWlbZV0udHJhbnNmb3JtLm5vdGlmeUxvY2FsQ2hhbmdlKCl9dGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50TG9jYWxDaGFuZ2UpfWdldCB1cCgpe3JldHVybiB0aGlzLndvcmxkTWF0cml4LnRyYW5zZm9ybVZlY3RvcihnLlVQLHRoaXMuX3VwKSx0aGlzLl91cH1zZXQgdXAoaSl7dGhpcy5fdXAuY29weUZyb20oaSksc3QuZnJvbVRvUm90YXRpb24oZy5VUCx0aGlzLl91cCxxLkhFTFBfMCksdGhpcy50cmFuc2Zvcm0ubG9jYWxSb3RRdWF0PXEuSEVMUF8wfWdldCBkb3duKCl7cmV0dXJuIHRoaXMud29ybGRNYXRyaXgudHJhbnNmb3JtVmVjdG9yKGcuRE9XTix0aGlzLl9kb3duKSx0aGlzLl9kb3dufXNldCBkb3duKGkpe3ZhciBlO3RoaXMuX2Rvd24uY29weUZyb20oaSksc3QuZnJvbVRvUm90YXRpb24oZy5ET1dOLHRoaXMuX2Rvd24scS5IRUxQXzApLHRoaXMudHJhbnNmb3JtLmxvY2FsUm90UXVhdD1xLkhFTFBfMCx0aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCksKGU9dGhpcy5vblJvdGF0aW9uQ2hhbmdlKT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50Um90YXRpb25DaGFuZ2UpfWdldCBmb3J3YXJkKCl7cmV0dXJuIHRoaXMud29ybGRNYXRyaXgudHJhbnNmb3JtVmVjdG9yKGcuRk9SV0FSRCx0aGlzLl9mb3J3YXJkKSx0aGlzLl9mb3J3YXJkfXNldCBmb3J3YXJkKGkpe3ZhciBlO3RoaXMuX2ZvcndhcmQuY29weUZyb20oaSksc3QuZnJvbVRvUm90YXRpb24oZy5GT1JXQVJELHRoaXMuX2ZvcndhcmQscS5IRUxQXzApLHRoaXMudHJhbnNmb3JtLmxvY2FsUm90UXVhdD1xLkhFTFBfMCx0aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCksKGU9dGhpcy5vblJvdGF0aW9uQ2hhbmdlKT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50Um90YXRpb25DaGFuZ2UpfWdldCBiYWNrKCl7cmV0dXJuIHRoaXMud29ybGRNYXRyaXgudHJhbnNmb3JtVmVjdG9yKGcuQkFDSyx0aGlzLl9iYWNrKSx0aGlzLl9iYWNrfXNldCBiYWNrKGkpe3RoaXMuX2JhY2suY29weUZyb20oaSksc3QuZnJvbVRvUm90YXRpb24oZy5CQUNLLHRoaXMuX2JhY2sscS5IRUxQXzApLHRoaXMudHJhbnNmb3JtLmxvY2FsUm90UXVhdD1xLkhFTFBfMH1nZXQgbGVmdCgpe3JldHVybiB0aGlzLndvcmxkTWF0cml4LnRyYW5zZm9ybVZlY3RvcihnLm5lZ19YX0FYSVMsdGhpcy5fbGVmdCksdGhpcy5fbGVmdH1zZXQgbGVmdChpKXt0aGlzLl9sZWZ0LmNvcHlGcm9tKGkpLHN0LmZyb21Ub1JvdGF0aW9uKGcuTEVGVCx0aGlzLl9sZWZ0LHEuSEVMUF8wKSx0aGlzLnRyYW5zZm9ybS5sb2NhbFJvdFF1YXQ9cS5IRUxQXzB9Z2V0IHJpZ2h0KCl7cmV0dXJuIHRoaXMud29ybGRNYXRyaXgudHJhbnNmb3JtVmVjdG9yKGcuWF9BWElTLHRoaXMuX3JpZ2h0KSx0aGlzLl9yaWdodH1zZXQgcmlnaHQoaSl7dmFyIGU7dGhpcy5fcmlnaHQuY29weUZyb20oaSksc3QuZnJvbVRvUm90YXRpb24oZy5SSUdIVCx0aGlzLl9yaWdodCxxLkhFTFBfMCksdGhpcy50cmFuc2Zvcm0ubG9jYWxSb3RRdWF0PXEuSEVMUF8wLHRoaXMubm90aWZ5TG9jYWxDaGFuZ2UoKSwoZT10aGlzLm9uUm90YXRpb25DaGFuZ2UpPT1udWxsfHxlLmNhbGwodGhpcyksdGhpcy5ldmVudFJvdGF0aW9uQ2hhbmdlJiZ0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSl9Z2V0IGxvY2FsUm90UXVhdCgpe3JldHVybiB0aGlzLl9sb2NhbFJvdFF1YXR9c2V0IGxvY2FsUm90UXVhdChpKXt2YXIgZTsoaS54IT10aGlzLl9sb2NhbFJvdFF1YXQueHx8aS55IT10aGlzLl9sb2NhbFJvdFF1YXQueXx8aS56IT10aGlzLl9sb2NhbFJvdFF1YXQuenx8aS53IT10aGlzLl9sb2NhbFJvdFF1YXQudykmJih0aGlzLl9sb2NhbFJvdFF1YXQuY29weUZyb20oaSksdGhpcy5fbG9jYWxSb3RRdWF0LmdldEV1bGVyQW5nbGVzKHRoaXMuX2xvY2FsUm90KSxlZS5zZXRSb3RhdGlvbih0aGlzLmluZGV4LHRoaXMuX2xvY2FsUm90LngsdGhpcy5fbG9jYWxSb3QueSx0aGlzLl9sb2NhbFJvdC56KSx0aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCksKGU9dGhpcy5vblJvdGF0aW9uQ2hhbmdlKT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50Um90YXRpb25DaGFuZ2UpKX1ub3RpZnlDaGFuZ2UoKXt2YXIgaSxlLHQ7dGhpcy5ub3RpZnlMb2NhbENoYW5nZSgpLChpPXRoaXMub25Sb3RhdGlvbkNoYW5nZSk9PW51bGx8fGkuY2FsbCh0aGlzKSwoZT10aGlzLm9uU2NhbGVDaGFuZ2UpPT1udWxsfHxlLmNhbGwodGhpcyksKHQ9dGhpcy5vblBvc2l0aW9uQ2hhbmdlKT09bnVsbHx8dC5jYWxsKHRoaXMpLHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50Um90YXRpb25DaGFuZ2UpLHRoaXMuZXZlbnRQb3NpdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50UG9zaXRpb25DaGFuZ2UpLHRoaXMuZXZlbnRTY2FsZUNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50U2NhbGVDaGFuZ2UpfWdldCB3b3JsZE1hdHJpeCgpe3JldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCksdGhpcy5fd29ybGRNYXRyaXh9dXBkYXRlV29ybGRNYXRyaXgoaT0hMSl7KHRoaXMubG9jYWxDaGFuZ2V8fGkpJiYodGhpcy5wYXJlbnQ/KFJzKHRoaXMuX2xvY2FsUm90LHRoaXMuX2xvY2FsUG9zLHRoaXMuX2xvY2FsU2NhbGUsdGhpcy5fd29ybGRNYXRyaXgpLHhsKHRoaXMuX3dvcmxkTWF0cml4LHRoaXMucGFyZW50LndvcmxkTWF0cml4LHRoaXMuX3dvcmxkTWF0cml4KSk6UnModGhpcy5fbG9jYWxSb3QsdGhpcy5fbG9jYWxQb3MsdGhpcy5fbG9jYWxTY2FsZSx0aGlzLl93b3JsZE1hdHJpeCksdGhpcy5sb2NhbENoYW5nZT0hMSl9dXBkYXRlQ2hpbGRUcmFuc2Zvcm0oKXtsZXQgaT10aGlzO2lmKGkubG9jYWxDaGFuZ2UmJmkudXBkYXRlV29ybGRNYXRyaXgoKSxpLm9iamVjdDNELm51bUNoaWxkcmVuPjApZm9yKGNvbnN0IGUgb2YgaS5vYmplY3QzRC5lbnRpdHlDaGlsZHJlbillLnRyYW5zZm9ybS51cGRhdGVDaGlsZFRyYW5zZm9ybSgpfWxvb2tUYXJnZXQoaSxlPWcuVVApe3RoaXMubG9va0F0KHRoaXMudHJhbnNmb3JtLndvcmxkUG9zaXRpb24saSxlKX1sb29rQXQoaSxlLHQ9Zy5VUCl7dGhpcy5fdGFyZ2V0UG9zfHwodGhpcy5fdGFyZ2V0UG9zPW5ldyBnKSx0aGlzLl90YXJnZXRQb3MuY29weUZyb20oZSksdGhpcy5sb2NhbFBvc2l0aW9uPWksVi5oZWxwTWF0cml4Lmxvb2tBdChpLGUsdCksVi5oZWxwTWF0cml4LmludmVydCgpO3ZhciByPVYuaGVscE1hdHJpeC5kZWNvbXBvc2UoeXQuUVVBVEVSTklPTik7dGhpcy5sb2NhbFJvdFF1YXQ9cS5DQUxDVUxBVElPTl9RVUFURVJOSU9OLmNvcHlGcm9tKHJbMV0pfWRlY29tcG9zZUZyb21NYXRyaXgoaSxlPVwiZXVsZXJBbmdsZXNcIil7bGV0IHQ9aS5kZWNvbXBvc2UoZSkscj10aGlzLnRyYW5zZm9ybTtyZXR1cm4gci5sb2NhbFJvdFF1YXQuY29weUZyb20odFsxXSksci5sb2NhbFJvdFF1YXQ9ci5sb2NhbFJvdFF1YXQsci5sb2NhbFBvc2l0aW9uLmNvcHlGcm9tKHRbMF0pLHIubG9jYWxQb3NpdGlvbj1yLmxvY2FsUG9zaXRpb24sci5sb2NhbFNjYWxlLmNvcHlGcm9tKHRbMl0pLHIubG9jYWxTY2FsZT1yLmxvY2FsU2NhbGUsdGhpc31jbG9uZVRvKGkpe2kudHJhbnNmb3JtLmxvY2FsUG9zaXRpb249dGhpcy5sb2NhbFBvc2l0aW9uLGkudHJhbnNmb3JtLmxvY2FsUm90YXRpb249dGhpcy5sb2NhbFJvdGF0aW9uLGkudHJhbnNmb3JtLmxvY2FsU2NhbGU9dGhpcy5sb2NhbFNjYWxlfXNldCB4KGkpe3ZhciBlO3RoaXMuX2xvY2FsUG9zLnghPWkmJih0aGlzLl9sb2NhbFBvcy54PWksZWUuc2V0VHJhbnNsYXRlKHRoaXMuaW5kZXgsdGhpcy5fbG9jYWxQb3MueCx0aGlzLl9sb2NhbFBvcy55LHRoaXMuX2xvY2FsUG9zLnopLHRoaXMubm90aWZ5TG9jYWxDaGFuZ2UoKSwoZT10aGlzLm9uUG9zaXRpb25DaGFuZ2UpPT1udWxsfHxlLmNhbGwodGhpcyksdGhpcy5ldmVudFBvc2l0aW9uQ2hhbmdlJiZ0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KHRoaXMuZXZlbnRQb3NpdGlvbkNoYW5nZSkpfWdldCB4KCl7cmV0dXJuIHRoaXMuX2xvY2FsUG9zLnh9c2V0IHkoaSl7dmFyIGU7dGhpcy5fbG9jYWxQb3MueSE9aSYmKHRoaXMuX2xvY2FsUG9zLnk9aSxlZS5zZXRUcmFuc2xhdGUodGhpcy5pbmRleCx0aGlzLl9sb2NhbFBvcy54LHRoaXMuX2xvY2FsUG9zLnksdGhpcy5fbG9jYWxQb3MueiksdGhpcy5ub3RpZnlMb2NhbENoYW5nZSgpLChlPXRoaXMub25Qb3NpdGlvbkNoYW5nZSk9PW51bGx8fGUuY2FsbCh0aGlzKSx0aGlzLmV2ZW50UG9zaXRpb25DaGFuZ2UmJnRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQodGhpcy5ldmVudFBvc2l0aW9uQ2hhbmdlKSl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5fbG9jYWxQb3MueX1zZXQgeihpKXt2YXIgZTt0aGlzLl9sb2NhbFBvcy56IT1pJiYodGhpcy5fbG9jYWxQb3Muej1pLGVlLnNldFRyYW5zbGF0ZSh0aGlzLmluZGV4LHRoaXMuX2xvY2FsUG9zLngsdGhpcy5fbG9jYWxQb3MueSx0aGlzLl9sb2NhbFBvcy56KSx0aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCksKGU9dGhpcy5vblBvc2l0aW9uQ2hhbmdlKT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuZXZlbnRQb3NpdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50UG9zaXRpb25DaGFuZ2UpKX1nZXQgeigpe3JldHVybiB0aGlzLl9sb2NhbFBvcy56fXNldCBzY2FsZVgoaSl7dmFyIGU7dGhpcy5fbG9jYWxTY2FsZS54IT1pJiYodGhpcy5fbG9jYWxTY2FsZS54PWksZWUuc2V0U2NhbGUodGhpcy5pbmRleCx0aGlzLl9sb2NhbFNjYWxlLngsdGhpcy5fbG9jYWxTY2FsZS55LHRoaXMuX2xvY2FsU2NhbGUueiksdGhpcy5ub3RpZnlMb2NhbENoYW5nZSgpLChlPXRoaXMub25TY2FsZUNoYW5nZSk9PW51bGx8fGUuY2FsbCh0aGlzKSx0aGlzLmV2ZW50U2NhbGVDaGFuZ2UmJnRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQodGhpcy5ldmVudFNjYWxlQ2hhbmdlKSl9Z2V0IHNjYWxlWCgpe3JldHVybiB0aGlzLl9sb2NhbFNjYWxlLnh9c2V0IHNjYWxlWShpKXt2YXIgZTt0aGlzLl9sb2NhbFNjYWxlLnkhPWkmJih0aGlzLl9sb2NhbFNjYWxlLnk9aSxlZS5zZXRTY2FsZSh0aGlzLmluZGV4LHRoaXMuX2xvY2FsU2NhbGUueCx0aGlzLl9sb2NhbFNjYWxlLnksdGhpcy5fbG9jYWxTY2FsZS56KSx0aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCksKGU9dGhpcy5vblNjYWxlQ2hhbmdlKT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuZXZlbnRTY2FsZUNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50U2NhbGVDaGFuZ2UpKX1nZXQgc2NhbGVZKCl7cmV0dXJuIHRoaXMuX2xvY2FsU2NhbGUueX1zZXQgc2NhbGVaKGkpe3ZhciBlO3RoaXMuX2xvY2FsU2NhbGUueiE9aSYmKHRoaXMuX2xvY2FsU2NhbGUuej1pLGVlLnNldFNjYWxlKHRoaXMuaW5kZXgsdGhpcy5fbG9jYWxTY2FsZS54LHRoaXMuX2xvY2FsU2NhbGUueSx0aGlzLl9sb2NhbFNjYWxlLnopLHRoaXMubm90aWZ5TG9jYWxDaGFuZ2UoKSwoZT10aGlzLm9uU2NhbGVDaGFuZ2UpPT1udWxsfHxlLmNhbGwodGhpcyksdGhpcy5ldmVudFNjYWxlQ2hhbmdlJiZ0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KHRoaXMuZXZlbnRTY2FsZUNoYW5nZSkpfWdldCBzY2FsZVooKXtyZXR1cm4gdGhpcy5fbG9jYWxTY2FsZS56fXNldCByb3RhdGlvblgoaSl7dmFyIGU7dGhpcy5fbG9jYWxSb3QueCE9aSYmKHRoaXMuX2xvY2FsUm90Lng9aSxlZS5zZXRSb3RhdGlvbih0aGlzLmluZGV4LHRoaXMuX2xvY2FsUm90LngsdGhpcy5fbG9jYWxSb3QueSx0aGlzLl9sb2NhbFJvdC56KSx0aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCksKGU9dGhpcy5vblJvdGF0aW9uQ2hhbmdlKT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50Um90YXRpb25DaGFuZ2UpKX1nZXQgcm90YXRpb25YKCl7cmV0dXJuIHRoaXMuX2xvY2FsUm90Lnh9c2V0IHJvdGF0aW9uWShpKXt2YXIgZTt0aGlzLl9sb2NhbFJvdC55IT1pJiYodGhpcy5fbG9jYWxSb3QueT1pLGVlLnNldFJvdGF0aW9uKHRoaXMuaW5kZXgsdGhpcy5fbG9jYWxSb3QueCx0aGlzLl9sb2NhbFJvdC55LHRoaXMuX2xvY2FsUm90LnopLHRoaXMubm90aWZ5TG9jYWxDaGFuZ2UoKSwoZT10aGlzLm9uUm90YXRpb25DaGFuZ2UpPT1udWxsfHxlLmNhbGwodGhpcyksdGhpcy5ldmVudFJvdGF0aW9uQ2hhbmdlJiZ0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSkpfWdldCByb3RhdGlvblkoKXtyZXR1cm4gdGhpcy5fbG9jYWxSb3QueX1zZXQgcm90YXRpb25aKGkpe3ZhciBlO3RoaXMuX2xvY2FsUm90LnohPWkmJih0aGlzLl9sb2NhbFJvdC56PWksZWUuc2V0Um90YXRpb24odGhpcy5pbmRleCx0aGlzLl9sb2NhbFJvdC54LHRoaXMuX2xvY2FsUm90LnksdGhpcy5fbG9jYWxSb3QueiksdGhpcy5ub3RpZnlMb2NhbENoYW5nZSgpLChlPXRoaXMub25Sb3RhdGlvbkNoYW5nZSk9PW51bGx8fGUuY2FsbCh0aGlzKSx0aGlzLmV2ZW50Um90YXRpb25DaGFuZ2UmJnRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQodGhpcy5ldmVudFJvdGF0aW9uQ2hhbmdlKSl9Z2V0IHJvdGF0aW9uWigpe3JldHVybiB0aGlzLl9sb2NhbFJvdC56fWdldCB3b3JsZFBvc2l0aW9uKCl7cmV0dXJuIHRoaXMubG9jYWxDaGFuZ2UmJnRoaXMudXBkYXRlV29ybGRNYXRyaXgoKSx0aGlzLl93b3JsZE1hdHJpeC5wb3NpdGlvbn1zZXQgbG9jYWxQb3NpdGlvbihpKXt2YXIgZTt0aGlzLl9sb2NhbFBvcy5jb3B5RnJvbShpKSxlZS5zZXRUcmFuc2xhdGUodGhpcy5pbmRleCxpLngsaS55LGkueiksdGhpcy5ub3RpZnlMb2NhbENoYW5nZSgpLChlPXRoaXMub25Qb3NpdGlvbkNoYW5nZSk9PW51bGx8fGUuY2FsbCh0aGlzKSx0aGlzLmV2ZW50UG9zaXRpb25DaGFuZ2UmJnRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQodGhpcy5ldmVudFBvc2l0aW9uQ2hhbmdlKX1nZXQgbG9jYWxQb3NpdGlvbigpe3JldHVybiB0aGlzLl9sb2NhbFBvc31zZXQgbG9jYWxSb3RhdGlvbihpKXt2YXIgZTtlZS5zZXRSb3RhdGlvbih0aGlzLmluZGV4LGkueCxpLnksaS56KSx0aGlzLl9sb2NhbFJvdC5jb3B5RnJvbShpKSx0aGlzLm5vdGlmeUxvY2FsQ2hhbmdlKCksKGU9dGhpcy5vblJvdGF0aW9uQ2hhbmdlKT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuZXZlbnRSb3RhdGlvbkNoYW5nZSYmdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLmV2ZW50Um90YXRpb25DaGFuZ2UpfWdldCBsb2NhbFJvdGF0aW9uKCl7cmV0dXJuIHRoaXMuX2xvY2FsUm90fXNldCBsb2NhbFNjYWxlKGkpe3ZhciBlO2VlLnNldFNjYWxlKHRoaXMuaW5kZXgsaS54LGkueSxpLnopLHRoaXMuX2xvY2FsU2NhbGUuY29weUZyb20oaSksdGhpcy5ub3RpZnlMb2NhbENoYW5nZSgpLChlPXRoaXMub25TY2FsZUNoYW5nZSk9PW51bGx8fGUuY2FsbCh0aGlzKSx0aGlzLmV2ZW50U2NhbGVDaGFuZ2UmJnRoaXMuZXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQodGhpcy5ldmVudFNjYWxlQ2hhbmdlKX1nZXQgbG9jYWxTY2FsZSgpe3JldHVybiB0aGlzLl9sb2NhbFNjYWxlfWdldCBsb2NhbERldGFpbFNjYWxlKCl7cmV0dXJuIHRoaXMuX2xvY2FsRGV0YWlsU2NhbGV9c2V0IGxvY2FsRGV0YWlsU2NhbGUoaSl7dGhpcy5fbG9jYWxEZXRhaWxTY2FsZT1pLGVlLnNldENvbnRpbnVlU2NhbGUodGhpcy5pbmRleCxpLngsaS55LGkueil9Z2V0IGxvY2FsRGV0YWlsUm90KCl7cmV0dXJuIHRoaXMuX2xvY2FsRGV0YWlsUm90fXNldCBsb2NhbERldGFpbFJvdChpKXt0aGlzLl9sb2NhbERldGFpbFJvdD1pLGVlLnNldENvbnRpbnVlUm90YXRpb24odGhpcy5pbmRleCxpLngsaS55LGkueil9Z2V0IGxvY2FsRGV0YWlsUG9zKCl7cmV0dXJuIHRoaXMuX2xvY2FsRGV0YWlsUG9zfXNldCBsb2NhbERldGFpbFBvcyhpKXt0aGlzLl9sb2NhbERldGFpbFBvcz1pLGVlLnNldENvbnRpbnVlVHJhbnNsYXRlKHRoaXMuaW5kZXgsaS54LGkueSxpLnopfWJlZm9yZURlc3Ryb3koaSl7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50Lm9iamVjdDNEJiZ0aGlzLnBhcmVudC5vYmplY3QzRC5yZW1vdmVDaGlsZCh0aGlzLm9iamVjdDNEKSxzdXBlci5iZWZvcmVEZXN0cm95KGkpfWRlc3Ryb3koKXtzdXBlci5kZXN0cm95KCksdGhpcy5zY2VuZTNEPW51bGwsdGhpcy5ldmVudFBvc2l0aW9uQ2hhbmdlPW51bGwsdGhpcy5ldmVudFJvdGF0aW9uQ2hhbmdlPW51bGwsdGhpcy5ldmVudFNjYWxlQ2hhbmdlPW51bGwsdGhpcy5vblBvc2l0aW9uQ2hhbmdlPW51bGwsdGhpcy5vblJvdGF0aW9uQ2hhbmdlPW51bGwsdGhpcy5vblNjYWxlQ2hhbmdlPW51bGwsdGhpcy5fc2NlbmUzZD1udWxsLHRoaXMuX3BhcmVudD1udWxsLHRoaXMuX2xvY2FsUG9zPW51bGwsdGhpcy5fbG9jYWxSb3Q9bnVsbCx0aGlzLl9sb2NhbFJvdFF1YXQ9bnVsbCx0aGlzLl9sb2NhbFNjYWxlPW51bGwsdGhpcy5fZm9yd2FyZD1udWxsLHRoaXMuX2JhY2s9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl91cD1udWxsLHRoaXMuX2Rvd249bnVsbCx0aGlzLmxvY2FsQ2hhbmdlPW51bGwsdGhpcy5fdGFyZ2V0UG9zPW51bGx9fTtsZXQgT2U9VnI7byhPZSxcIkxJTUlUXCIsMSksbyhPZSxcIkNPTVBPTkVOVF9OQU1FXCIsXCJVVVRyYW5zZm9ybVwiKSxvKE9lLFwiQ09NUE9ORU5UX1RZUEVcIixcIlRyYW5zZm9ybVwiKSxvKE9lLFwiUE9TSVRJT05fT05DSEFOR0VcIixcIlBPU0lUSU9OX09OQ0hBTkdFXCIpLG8oT2UsXCJST1RBVElPTl9PTkNIQU5HRVwiLFwiUk9UQVRJT05fT05DSEFOR0VcIiksbyhPZSxcIlNDQUxFX09OQ0hBTkdFXCIsXCJTQ0FMRV9PTkNIQU5HRVwiKSxvKE9lLFwiUEFSRU5UX09OQ0hBTkdFXCIsXCJQQVJFTlRfT05DSEFOR0VcIiksbyhPZSxcIkNISUxEUkVOX09OQ0hBTkdFXCIsXCJDSElMRFJFTl9PTkNIQU5HRVwiKSxvKE9lLFwiQUREX09OQ0hBTkdFXCIsXCJBRERfT05DSEFOR0VcIiksbyhPZSxcIkxPQ0FMX09OQ0hBTkdFXCIsXCJMT0NBTF9PTkNIQU5HRVwiKTtjb25zdCB3bD1jbGFzc3tzdGF0aWMgZ2VuTWVzaEJvdW5kcyhpLGUpe2xldCB0PXRoaXMuZ2VuTWVzaE1pblZlY3RvcixyPXRoaXMuZ2VuTWVzaE1heFZlY3RvcixzPXRoaXMuZ2VuTWVzaFZlY3Rvckxpc3Q4O2V8fChlPW5ldyBCZShnLlpFUk8sZy5aRVJPKSksZS5zZXRGcm9tTWluTWF4KHRoaXMubWF4VmVjdG9yLHRoaXMubWluVmVjdG9yKTtsZXQgYT1pLmdldENvbXBvbmVudHMoY2UpO2Zvcihjb25zdCBuIG9mIGEpaWYobiYmbi5nZW9tZXRyeSl7bGV0IGw9bi5vYmplY3QzRC50cmFuc2Zvcm0ud29ybGRNYXRyaXg7dC5jb3B5KG4uZ2VvbWV0cnkuYm91bmRzLm1pbiksci5jb3B5KG4uZ2VvbWV0cnkuYm91bmRzLm1heCksc1swXS5zZXQodC54LHQueSx0LnopLHNbMV0uc2V0KHQueCx0Lnksci56KSxzWzJdLnNldCh0Lngsci55LHQueiksc1szXS5zZXQodC54LHIueSxyLnopLHNbNF0uc2V0KHIueCx0LnksdC56KSxzWzVdLnNldChyLngsdC55LHIueiksc1s2XS5zZXQoci54LHIueSx0LnopLHNbN10uc2V0KHIueCxyLnksci56KTtmb3IoY29uc3QgaCBvZiBzKWwudHJhbnNmb3JtUG9pbnQoaCxoKSxlLmV4cGFuZEJ5UG9pbnQoaCl9cmV0dXJuIHIuY29weUZyb20oZS5tYXgpLHQuY29weUZyb20oZS5taW4pLGUuc2V0RnJvbU1pbk1heCh0LHIpLGV9c3RhdGljIHRyYW5zZm9ybUJvdW5kKGksZSx0KXtsZXQgcj10aGlzLmdlbk1lc2hNaW5WZWN0b3IuY29weUZyb20oZS5taW4pLHM9dGhpcy5nZW5NZXNoTWF4VmVjdG9yLmNvcHlGcm9tKGUubWF4KSxhPXRoaXMuZ2VuTWVzaFZlY3Rvckxpc3Q4O3R8fCh0PW5ldyBCZShnLlpFUk8sZy5aRVJPKSksdC5zZXRGcm9tTWluTWF4KHRoaXMubWF4VmVjdG9yLHRoaXMubWluVmVjdG9yKSxhWzBdLnNldChyLngsci55LHIueiksYVsxXS5zZXQoci54LHIueSxzLnopLGFbMl0uc2V0KHIueCxzLnksci56KSxhWzNdLnNldChyLngscy55LHMueiksYVs0XS5zZXQocy54LHIueSxyLnopLGFbNV0uc2V0KHMueCxyLnkscy56KSxhWzZdLnNldChzLngscy55LHIueiksYVs3XS5zZXQocy54LHMueSxzLnopO2Zvcihjb25zdCBuIG9mIGEpaS50cmFuc2Zvcm1Qb2ludChuLG4pLHQuZXhwYW5kQnlQb2ludChuKTtyZXR1cm4gcy5jb3B5RnJvbSh0Lm1heCksci5jb3B5RnJvbSh0Lm1pbiksdC5zZXRGcm9tTWluTWF4KHIscyksdH19O2xldCBadD13bDtvKFp0LFwibWF4VmVjdG9yXCIsbmV3IGcoTnVtYmVyLk1BWF9WQUxVRSouMSxOdW1iZXIuTUFYX1ZBTFVFKi4xLE51bWJlci5NQVhfVkFMVUUqLjEpKSxvKFp0LFwibWluVmVjdG9yXCIsd2wubWF4VmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLTEpKSxvKFp0LFwiZ2VuTWVzaE1heFZlY3RvclwiLGcuWkVSTy5jbG9uZSgpKSxvKFp0LFwiZ2VuTWVzaE1pblZlY3RvclwiLGcuWkVSTy5jbG9uZSgpKSxvKFp0LFwiZ2VuTWVzaFZlY3Rvckxpc3Q4XCIsW25ldyBnLG5ldyBnLG5ldyBnLG5ldyBnLG5ldyBnLG5ldyBnLG5ldyBnLG5ldyBnXSk7Y2xhc3MgYmwgZXh0ZW5kcyBoaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwibmFtZVwiLFwiXCIpLG8odGhpcyxcIl9pbnN0YW5jZUlEXCIsXCJcIiksbyh0aGlzLFwiX251bUNoaWxkcmVuXCIpLG8odGhpcyxcInRyYW5zZm9ybVwiKSxvKHRoaXMsXCJyZW5kZXJOb2RlXCIpLG8odGhpcyxcImVudGl0eUNoaWxkcmVuXCIpLG8odGhpcyxcImNvbXBvbmVudHNcIiksbyh0aGlzLFwid2FpdERpc3Bvc2VDb21wb25lbnRzXCIpLG8odGhpcyxcIl9ib3VuZFwiKSxvKHRoaXMsXCJfYm91bmRXb3JsZFwiKSxvKHRoaXMsXCJfaXNCb3VuZENoYW5nZVwiLCEwKSxvKHRoaXMsXCJfZGlzcG9zZVwiLCExKSx0aGlzLmVudGl0eUNoaWxkcmVuPVtdLHRoaXMuY29tcG9uZW50cz1uZXcgTWFwLHRoaXMuX2luc3RhbmNlSUQ9cWEoKS50b1N0cmluZygpLHRoaXMud2FpdERpc3Bvc2VDb21wb25lbnRzPVtdfWdldCBpbnN0YW5jZUlEKCl7cmV0dXJuIHRoaXMuX2luc3RhbmNlSUR9Z2V0T2JqZWN0QnlOYW1lKGUpe2lmKGUuaW5kZXhPZihcIi9cIik+PTApe2xldCByPWUuc3BsaXQoXCIvXCIpLHM9dGhpcztmb3IoO3IubGVuZ3RoPjAmJnM7KXtsZXQgYT1yLnNoaWZ0KCk7aWYocz1zLmdldENoaWxkQnlOYW1lKGEsITEpLCFzKXJldHVybiBudWxsfXJldHVybiBzfWVsc2UgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRCeU5hbWUoZSwhMSl9Z2V0IG51bUNoaWxkcmVuKCl7cmV0dXJuIHRoaXMuX251bUNoaWxkcmVufWFkZENoaWxkKGUpe3JldHVybiBlPT1udWxsP25ldyBjb25zb2xlLmVycm9yKFwiY2hpbGQgaXMgbnVsbCFcIik6ZT09PXRoaXM/bmV3IGNvbnNvbGUuZXJyb3IoXCJjaGlsZCBpcyBzZWxmIVwiKTp0aGlzLmVudGl0eUNoaWxkcmVuLmluZGV4T2YoZSk9PS0xPyhlLnJlbW92ZUZyb21QYXJlbnQoKSxlLnRyYW5zZm9ybS5wYXJlbnQ9dGhpcy50cmFuc2Zvcm0sdGhpcy5lbnRpdHlDaGlsZHJlbi5wdXNoKGUpLHRoaXMuX251bUNoaWxkcmVuPXRoaXMuZW50aXR5Q2hpbGRyZW4ubGVuZ3RoLGUpOm51bGx9cmVtb3ZlQ2hpbGQoZSl7aWYoZT09PW51bGwpcmV0dXJuIG5ldyBjb25zb2xlLmVycm9yKFwicmVtb3ZlIGNoaWxkIGlzIG51bGwhXCIpO2lmKGU9PT10aGlzKXJldHVybiBuZXcgY29uc29sZS5lcnJvcihcImFkZCBjaGlsZCBpcyBzZWxmIVwiKTtsZXQgdD10aGlzLmVudGl0eUNoaWxkcmVuLmluZGV4T2YoZSk7dCE9LTEmJih0aGlzLmVudGl0eUNoaWxkcmVuLnNwbGljZSh0LDEpLGUudHJhbnNmb3JtLnBhcmVudD1udWxsLHRoaXMuX251bUNoaWxkcmVuPXRoaXMuZW50aXR5Q2hpbGRyZW4ubGVuZ3RoKX1yZW1vdmVBbGxDaGlsZCgpe2Zvcig7dGhpcy5udW1DaGlsZHJlbj4wOyl0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZW50aXR5Q2hpbGRyZW5bMF0pfXJlbW92ZVNlbGYoKXtyZXR1cm4gdGhpcy5yZW1vdmVGcm9tUGFyZW50KCl9cmVtb3ZlQ2hpbGRCeUluZGV4KGUpe2U+PTAmJmU8dGhpcy5lbnRpdHlDaGlsZHJlbi5sZW5ndGg/dGhpcy5yZW1vdmVDaGlsZCh0aGlzLmVudGl0eUNoaWxkcmVuW2VdKTpjb25zb2xlLmVycm9yKFwicmVtb3ZlIGNoaWxkIGJ5IGluZGV4ICwgaW5kZXggb3V0IG9mIHJhbmdlXCIpfWhhc0NoaWxkKGUpe3JldHVybiB0aGlzLmVudGl0eUNoaWxkcmVuLmluZGV4T2YoZSkhPS0xfXJlbW92ZUZyb21QYXJlbnQoKXtsZXQgZT10aGlzLnRyYW5zZm9ybS5wYXJlbnQ7cmV0dXJuIGUmJmUub2JqZWN0M0QmJmUub2JqZWN0M0QucmVtb3ZlQ2hpbGQodGhpcyksdGhpc31nZXRDaGlsZEJ5SW5kZXgoZSl7bGV0IHQ9bnVsbDtyZXR1cm4gZTx0aGlzLmVudGl0eUNoaWxkcmVuLmxlbmd0aCYmKHQ9dGhpcy5lbnRpdHlDaGlsZHJlbltlXSksdH1nZXRDaGlsZEJ5TmFtZShlLHQ9ITApe2xldCByPW51bGw7Zm9yKGNvbnN0IHMgb2YgdGhpcy5lbnRpdHlDaGlsZHJlbil7aWYocy5uYW1lPT1lKXJldHVybiByPXMscjtpZih0JiYocj1zLmdldENoaWxkQnlOYW1lKGUsdCkscikpcmV0dXJuIHJ9cmV0dXJuIHJ9dXBkYXRlKCl7fWluc3RhbnRpYXRlKCl7cmV0dXJuIG51bGx9b25UcmFuc2Zvcm1Mb2NhbENoYW5nZShlKXt0aGlzLl9pc0JvdW5kQ2hhbmdlPSEwfWdldCBib3VuZCgpe3JldHVybih0aGlzLl9pc0JvdW5kQ2hhbmdlfHwhdGhpcy5fYm91bmQpJiZ0aGlzLnVwZGF0ZUJvdW5kKCksdGhpcy5fYm91bmRXb3JsZH1zZXQgYm91bmQoZSl7dGhpcy5fYm91bmQ9ZSx0aGlzLl9ib3VuZFdvcmxkPXRoaXMuX2JvdW5kLmNsb25lKCksdGhpcy5faXNCb3VuZENoYW5nZT0hMH11cGRhdGVCb3VuZCgpe3JldHVybiB0aGlzLl9ib3VuZHx8KHRoaXMuX2JvdW5kPW5ldyBCZSx0aGlzLl9ib3VuZFdvcmxkPXRoaXMuX2JvdW5kLmNsb25lKCksdGhpcy5faXNCb3VuZENoYW5nZT0hMCksdGhpcy5faXNCb3VuZENoYW5nZSYmKFp0LnRyYW5zZm9ybUJvdW5kKHRoaXMudHJhbnNmb3JtLndvcmxkTWF0cml4LHRoaXMuX2JvdW5kLHRoaXMuX2JvdW5kV29ybGQpLHRoaXMuX2lzQm91bmRDaGFuZ2U9ITEpLHRoaXMuX2JvdW5kV29ybGR9d2FpdFVwZGF0ZSgpe3RoaXMuX2Rpc3Bvc2U/KHRoaXMudHJhbnNmb3JtLnBhcmVudCYmdGhpcy50cmFuc2Zvcm0ucGFyZW50Lm9iamVjdDNELnJlbW92ZUNoaWxkKHRoaXMpLHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKChlLHQpPT57ZS5lbmFibGU9ITEsZS5kZXN0cm95KCl9KSx0aGlzLmNvbXBvbmVudHMuY2xlYXIoKSk6YWUud2FpdFN0YXJ0Q29tcG9uZW50LmZvckVhY2goKGUsdCk9Pntmb3IoO2UubGVuZ3RoPjA7KWUuc2hpZnQoKS5fX3N0YXJ0KCk7YWUud2FpdFN0YXJ0Q29tcG9uZW50LmRlbGV0ZSh0KX0pfWRlc3Ryb3koZSl7dGhpcy5fZGlzcG9zZXx8KHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKHQ9Pnt0LmJlZm9yZURlc3Ryb3koZSl9KSx0aGlzLmNvbXBvbmVudHMuZm9yRWFjaCh0PT57dC5kZXN0cm95KGUpfSksdGhpcy5jb21wb25lbnRzLmNsZWFyKCksdGhpcy5lbnRpdHlDaGlsZHJlbi5mb3JFYWNoKHQ9Pnt0LmRlc3Ryb3koZSl9KSx0aGlzLnJlbW92ZUFsbENoaWxkKCksdGhpcy50cmFuc2Zvcm0ucGFyZW50PW51bGwsdGhpcy5fZGlzcG9zZT0hMCxzdXBlci5kZXN0cm95KCkpfX12YXIgT2Q9T2JqZWN0LmRlZmluZVByb3BlcnR5LE5kPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsRmQ9KGksZSx0LHIpPT57Zm9yKHZhciBzPXI+MT92b2lkIDA6cj9OZChlLHQpOmUsYT1pLmxlbmd0aC0xLG47YT49MDthLS0pKG49aVthXSkmJihzPShyP24oZSx0LHMpOm4ocykpfHxzKTtyZXR1cm4gciYmcyYmT2QoZSx0LHMpLHN9O2xldCB0ZT1jbGFzcyBleHRlbmRzIGJse2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJfaXNTY2VuZTNEXCIpLG8odGhpcyxcInByZWZhYlJlZlwiKSxvKHRoaXMsXCJzZXJpYWxpemVUYWdcIiksdGhpcy50cmFuc2Zvcm09dGhpcy5hZGRDb21wb25lbnQoT2UpLHRoaXMudHJhbnNmb3JtLmV2ZW50RGlzcGF0Y2hlci5hZGRFdmVudExpc3RlbmVyKE9lLkxPQ0FMX09OQ0hBTkdFLHRoaXMub25UcmFuc2Zvcm1Mb2NhbENoYW5nZSx0aGlzKX1nZXQgaXNTY2VuZTNEKCl7cmV0dXJuIHRoaXMuX2lzU2NlbmUzRH1mb3JDaGlsZChpKXt0aGlzLmVudGl0eUNoaWxkcmVuLmZvckVhY2goZT0+e2koZSksZS5mb3JDaGlsZChpKX0pfWFkZENvbXBvbmVudChpLGUpe2xldCB0PWkubmFtZTtpZighdGhpcy5jb21wb25lbnRzLmhhcyh0KSl7bGV0IHI9bmV3IGk7cmV0dXJuIHIub2JqZWN0M0Q9dGhpcyx0aGlzLmNvbXBvbmVudHMuc2V0KHQsciksci5fX2luaXQoZSksYWUuYXBwZW5kV2FpdFN0YXJ0KHIpLHJ9cmV0dXJuIG51bGx9Z2V0T3JBZGRDb21wb25lbnQoaSl7bGV0IGU9aS5uYW1lLHQ9dGhpcy5jb21wb25lbnRzLmdldChlKTtyZXR1cm4gdHx8KHQ9dGhpcy5hZGRDb21wb25lbnQoaSkpLHR9cmVtb3ZlQ29tcG9uZW50KGkpe2xldCBlPWkubmFtZTtpZih0aGlzLmNvbXBvbmVudHMuaGFzKGUpKXtsZXQgdD10aGlzLmNvbXBvbmVudHMuZ2V0KGUpO2FlLnJlbW92ZVdhaXRTdGFydCh0aGlzLHQpLHRoaXMuY29tcG9uZW50cy5kZWxldGUoZSksdC5fX3N0b3AoKSx0LmJlZm9yZURlc3Ryb3koKSx0LmRlc3Ryb3koKX19aGFzQ29tcG9uZW50KGkpe2xldCBlPWkubmFtZTtyZXR1cm4gdGhpcy5jb21wb25lbnRzLmhhcyhlKX1nZXRDb21wb25lbnQoaSl7bGV0IGU9aS5uYW1lO3JldHVybiB0aGlzLmNvbXBvbmVudHMuZ2V0KGUpfWdldENvbXBvbmVudEZyb21QYXJlbnQoaSl7aWYoIXRoaXMucGFyZW50KXJldHVybiBudWxsO2xldCBlPXRoaXMucGFyZW50Lm9iamVjdDNELmdldENvbXBvbmVudChpKTtyZXR1cm4gZXx8dGhpcy5wYXJlbnQub2JqZWN0M0QuZ2V0Q29tcG9uZW50RnJvbVBhcmVudChpKX1nZXRDb21wb25lbnRzSW5DaGlsZChpKXtsZXQgZT1bXSx0PWkubmFtZSxyPXRoaXMuY29tcG9uZW50cy5nZXQodCk7ciYmZS5wdXNoKHIpO2ZvcihsZXQgcz0wO3M8dGhpcy5lbnRpdHlDaGlsZHJlbi5sZW5ndGg7cysrKXtsZXQgbj10aGlzLmVudGl0eUNoaWxkcmVuW3NdLmdldENvbXBvbmVudHNJbkNoaWxkKGkpO2UucHVzaCguLi5uKX1yZXR1cm4gZX1nZXRDb21wb25lbnRzKGksZSx0KXtlfHwoZT1bXSk7bGV0IHI9dGhpcy5nZXRDb21wb25lbnQoaSk7ciYmKHIuZW5hYmxlfHx0KSYmZS5wdXNoKHIpO2ZvcihsZXQgcz0wLGE9dGhpcy5lbnRpdHlDaGlsZHJlbi5sZW5ndGg7czxhO3MrKyl7bGV0IG49dGhpcy5lbnRpdHlDaGlsZHJlbltzXTtuJiZuIGluc3RhbmNlb2YgdGUmJm4uZ2V0Q29tcG9uZW50cyhpLGUsdCl9cmV0dXJuIGV9Z2V0Q29tcG9uZW50c0V4dChpLGUsdCl7ZXx8KGU9W10pO2xldCByPXRoaXMuY29tcG9uZW50cy5nZXQoaS5uYW1lKTtpZihyJiYoci5lbmFibGV8fHQpKWUucHVzaChyKTtlbHNlIGZvcihjb25zdCBzIG9mIHRoaXMuZW50aXR5Q2hpbGRyZW4pcyBpbnN0YW5jZW9mIHRlJiZzLmdldENvbXBvbmVudHNFeHQoaSxlLHQpO3JldHVybiBlfWdldENvbXBvbmVudHNCeVByb3BlcnR5KGksZSx0PSEwLHIscyl7cnx8KHI9W10pO2xldCBhO2Zvcihjb25zdCBuIG9mIHRoaXMuY29tcG9uZW50cy52YWx1ZXMoKSluJiYobi5lbmFibGV8fHMpJiZuW2ldPT1lJiYoci5wdXNoKG4pLGE9ITApO2lmKCEoYSYmdCkpZm9yKGNvbnN0IG4gb2YgdGhpcy5lbnRpdHlDaGlsZHJlbiluIGluc3RhbmNlb2YgdGUmJm4uZ2V0Q29tcG9uZW50c0J5UHJvcGVydHkoaSxlLHQscixzKTtyZXR1cm4gcn1jbG9uZSgpe3JldHVybiB0aGlzLmluc3RhbnRpYXRlKCl9aW5zdGFudGlhdGUoKXtsZXQgaT1uZXcgdGU7cmV0dXJuIGkubmFtZT10aGlzLm5hbWUsaS5zZXJpYWxpemVUYWc9dGhpcy5zZXJpYWxpemVUYWcsaS5wcmVmYWJSZWY9dGhpcy5wcmVmYWJSZWYsdGhpcy5lbnRpdHlDaGlsZHJlbi5mb3JFYWNoKChlLHQpPT57bGV0IHI9ZS5pbnN0YW50aWF0ZSgpO2kuYWRkQ2hpbGQocil9KSx0aGlzLmNvbXBvbmVudHMuZm9yRWFjaCgoZSx0KT0+e2UuY2xvbmVUbyhpKX0pLGl9Z2V0IGxvY2FsUG9zaXRpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbn1zZXQgbG9jYWxQb3NpdGlvbihpKXt0aGlzLnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uPWl9Z2V0IGxvY2FsUm90YXRpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbn1zZXQgbG9jYWxSb3RhdGlvbihpKXt0aGlzLnRyYW5zZm9ybS5sb2NhbFJvdGF0aW9uPWl9Z2V0IGxvY2FsU2NhbGUoKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYWxTY2FsZX1zZXQgbG9jYWxTY2FsZShpKXt0aGlzLnRyYW5zZm9ybS5sb2NhbFNjYWxlPWl9Z2V0IGxvY2FsUXVhdGVybmlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhbFJvdFF1YXR9c2V0IGxvY2FsUXVhdGVybmlvbihpKXt0aGlzLnRyYW5zZm9ybS5sb2NhbFJvdFF1YXQ9aX1ub3RpZnlDaGFuZ2UoKXt0aGlzLnRyYW5zZm9ybS5ub3RpZnlDaGFuZ2UoKX1nZXQgcGFyZW50KCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtLnBhcmVudH1nZXQgcGFyZW50T2JqZWN0KCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtLnBhcmVudC5vYmplY3QzRH1zZXQgeChpKXt0aGlzLnRyYW5zZm9ybS54PWl9Z2V0IHgoKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0ueH1zZXQgeShpKXt0aGlzLnRyYW5zZm9ybS55PWl9Z2V0IHkoKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0ueX1zZXQgeihpKXt0aGlzLnRyYW5zZm9ybS56PWl9Z2V0IHooKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0uen1zZXQgc2NhbGVYKGkpe3RoaXMudHJhbnNmb3JtLnNjYWxlWD1pfWdldCBzY2FsZVgoKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2NhbGVYfXNldCBzY2FsZVkoaSl7dGhpcy50cmFuc2Zvcm0uc2NhbGVZPWl9Z2V0IHNjYWxlWSgpe3JldHVybiB0aGlzLnRyYW5zZm9ybS5zY2FsZVl9c2V0IHNjYWxlWihpKXt0aGlzLnRyYW5zZm9ybS5zY2FsZVo9aX1nZXQgc2NhbGVaKCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtLnNjYWxlWn1zZXQgcm90YXRpb25YKGkpe3RoaXMudHJhbnNmb3JtLnJvdGF0aW9uWD1pfWdldCByb3RhdGlvblgoKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb25YfXNldCByb3RhdGlvblkoaSl7dGhpcy50cmFuc2Zvcm0ucm90YXRpb25ZPWl9Z2V0IHJvdGF0aW9uWSgpe3JldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbll9c2V0IHJvdGF0aW9uWihpKXt0aGlzLnRyYW5zZm9ybS5yb3RhdGlvblo9aX1nZXQgcm90YXRpb25aKCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uWn1maXhlZFVwZGF0ZSgpe31sYXRlVXBkYXRlKCl7fXRyYXZlcnNlKGkpe2kodGhpcyk7Zm9yKGxldCBlPTAsdD10aGlzLmVudGl0eUNoaWxkcmVuLmxlbmd0aDtlPHQ7ZSsrKXtsZXQgcj10aGlzLmVudGl0eUNoaWxkcmVuW2VdO3IgaW5zdGFuY2VvZiB0ZSYmci50cmF2ZXJzZShpKX19ZGVzdHJveShpKXt0aGlzLnRyYW5zZm9ybS5ldmVudERpc3BhdGNoZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihPZS5MT0NBTF9PTkNIQU5HRSx0aGlzLm9uVHJhbnNmb3JtTG9jYWxDaGFuZ2UsdGhpcyksc3VwZXIuZGVzdHJveShpKX19O3RlPUZkKFtrZF0sdGUpO2Z1bmN0aW9uIGtkKGksZSl7cmV0dXJuIGNsYXNzIGV4dGVuZHMgdGV7c2V0IGFjdGl2ZSh0KXt0aGlzLnRyYW5zZm9ybS5lbmFibGU9dD4wfWdldCBhY3RpdmUoKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0uZW5hYmxlPzE6MH1nZXQgbWF0ZXJpYWxDb2xvcigpe3ZhciB0O2xldCByPXRoaXMuZ2V0Q29tcG9uZW50KGNlKTtyZXR1cm4odD1yPy5tYXRlcmlhbCk9PW51bGw/dm9pZCAwOnQuZGVmYXVsdFBhc3MuYmFzZUNvbG9yfXNldCBtYXRlcmlhbENvbG9yKHQpe3ZhciByO2xldCBzPShyPXRoaXMuZ2V0Q29tcG9uZW50KGNlKSk9PW51bGw/dm9pZCAwOnIubWF0ZXJpYWw7cyYmKHMuZGVmYXVsdFBhc3MuYmFzZUNvbG9yPXQpfW5vdGlmeU1hdGVyaWFsQ29sb3JDaGFuZ2UodCxyKXt2YXIgcztsZXQgYT10aGlzLmdldENvbXBvbmVudChjZSkubWF0ZXJpYWxzOyhzPWE/Llt0XSk9PW51bGx8fHMuZGVmYXVsdFBhc3MudW5pZm9ybXNbcl0ub25DaGFuZ2UoKX19fWNsYXNzIE5le3N0YXRpYyBjcmVhdGVDYW1lcmEzRE9iamVjdChlLHQpe3JldHVybiB0aGlzLmNyZWF0ZUNhbWVyYTNEKG51bGwsZSx0KX1zdGF0aWMgY3JlYXRlQ2FtZXJhM0QoZSx0LHIpe3JldHVybiBlfHwoZT1uZXcgdGUpLHQmJnQuYWRkQ2hpbGQoZSksciYmKGUubmFtZT1yKSxlLmdldE9yQWRkQ29tcG9uZW50KFppKX1zdGF0aWMgVW5Qcm9qZWN0aW9uKGUsdCxyPTEscyl7bGV0IGE9bmV3IGcoZSx0LDApLG49MSxsPWcuSEVMUF8wLGg9Uy5jYW52YXMub2Zmc2V0TGVmdCx1PVMuY2FudmFzLm9mZnNldFRvcCxjPVMuY2FudmFzLmNsaWVudFdpZHRoLGY9Uy5jYW52YXMuY2xpZW50SGVpZ2h0O2wueD0oKGEueC1oKSpuL2MtLjUpKjIsbC55PS0oKGEueS11KSpuL2YtLjUpKjIsbC56PXI7bGV0IGQ9bmV3IGcoMCwwLDApLHA9Vi5oZWxwTWF0cml4MjtwLmNvcHlGcm9tKHMucHJvamVjdGlvbk1hdHJpeCkscC5pbnZlcnQoKTtsZXQgbT1WLmhlbHBNYXRyaXg7cmV0dXJuIG0uaWRlbnRpdHkoKSxtLm11bHRpcGx5KHApLG0ubXVsdGlwbHkocy50cmFuc2Zvcm0ud29ybGRNYXRyaXgpLG0ucGVyc3BlY3RpdmVNdWx0aXBseVBvaW50MyhsLGQpLGR9c3RhdGljIFByb2plY3Rpb24oZSx0LHIpe2xldCBzPXJ8fG5ldyBnKDAsMCwwKSxhPVYuaGVscE1hdHJpeDthLmNvcHlGcm9tKHQudmlld01hdHJpeCksYS5tdWx0aXBseSh0LnByb2plY3Rpb25NYXRyaXgpLGEucGVyc3BlY3RpdmVNdWx0aXBseVBvaW50MyhlLHMpO2xldCBuPVMuY2FudmFzLmNsaWVudFdpZHRoLzIsbD1TLmNhbnZhcy5jbGllbnRIZWlnaHQvMjtyZXR1cm4gcy54PXMueCpuK24scy55PWwtcy55Kmwsc31zdGF0aWMgVW5Qcm9qZWN0aW9uMihlLHQscixzLGEpe2xldCBuPWF8fG5ldyBnKDAsMCwwKSxsPVYuaGVscE1hdHJpeDtsLmNvcHlGcm9tKHMucHZNYXRyaXhJbnYpO2xldCBoPVMuY2FudmFzLmNsaWVudFdpZHRoLzIsdT1TLmNhbnZhcy5jbGllbnRIZWlnaHQvMjtyZXR1cm4gbi54PShlLWgpL2gsbi55PSh1LXQpL3Usbi56PXIsbC5wZXJzcGVjdGl2ZU11bHRpcGx5UG9pbnQzKG4sbiksbn19Y29uc3QgYW89Y2xhc3N7c3RhdGljIGluaXQoKXt0aGlzLmRpcmVjdGlvbkxpZ2h0TGlzdD1uZXcgTWFwLHRoaXMucG9pbnRMaWdodExpc3Q9bmV3IE1hcCx0aGlzLnNoYWRvd0J1ZmZlcj1uZXcgTWFwLHRoaXMuc2hhZG93TGlnaHRzPW5ldyBNYXB9c3RhdGljIGNyZWF0ZUJ1ZmZlcihpKXtpZighdGhpcy5zaGFkb3dCdWZmZXIuaGFzKGkpKXtsZXQgZT1uZXcgZ2UoMjApO2UudmlzaWJpbGl0eT1HUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCx0aGlzLnNoYWRvd0J1ZmZlci5zZXQoaSxlKSxlLnNldEludDMyKFwibkRpclNoYWRvd1N0YXJ0XCIsMCksZS5zZXRJbnQzMihcIm5EaXJTaGFkb3dFbmRcIiwxKSxlLnNldEludDMyKFwiblBvaW50U2hhZG93U3RhcnRcIiwwKSxlLnNldEludDMyKFwiblBvaW50U2hhZG93RW5kXCIsMCk7bGV0IHQ9bmV3IFVpbnQzMkFycmF5KDE2KTt0aGlzLnNoYWRvd0xpZ2h0cy5zZXQoaSx0KSxlLnNldFVpbnQzMkFycmF5KFwic2hhZG93TGlnaHRzXCIsdCksZS5hcHBseSgpfX1zdGF0aWMgZ2V0U2hhZG93TGlnaHRMaXN0KGkpe2lmKCFpLnRyYW5zZm9ybS52aWV3M0QpcmV0dXJuIG51bGw7aWYoaS5saWdodERhdGEubGlnaHRUeXBlPT1RZS5EaXJlY3Rpb25MaWdodCl7bGV0IGU9dGhpcy5kaXJlY3Rpb25MaWdodExpc3QuZ2V0KGkudHJhbnNmb3JtLnZpZXczRC5zY2VuZSk7cmV0dXJuIGV8fChlPVtdLHRoaXMuZGlyZWN0aW9uTGlnaHRMaXN0LnNldChpLnRyYW5zZm9ybS52aWV3M0Quc2NlbmUsZSkpLGV9ZWxzZSBpZihpLmxpZ2h0RGF0YS5saWdodFR5cGU9PVFlLlBvaW50TGlnaHQpe2xldCBlPXRoaXMucG9pbnRMaWdodExpc3QuZ2V0KGkudHJhbnNmb3JtLnZpZXczRC5zY2VuZSk7cmV0dXJuIGV8fChlPVtdLHRoaXMucG9pbnRMaWdodExpc3Quc2V0KGkudHJhbnNmb3JtLnZpZXczRC5zY2VuZSxlKSksZX1lbHNlIGlmKGkubGlnaHREYXRhLmxpZ2h0VHlwZT09UWUuU3BvdExpZ2h0KXtsZXQgZT10aGlzLnBvaW50TGlnaHRMaXN0LmdldChpLnRyYW5zZm9ybS52aWV3M0Quc2NlbmUpO3JldHVybiBlfHwoZT1bXSx0aGlzLnBvaW50TGlnaHRMaXN0LnNldChpLnRyYW5zZm9ybS52aWV3M0Quc2NlbmUsZSkpLGV9fXN0YXRpYyBnZXRTaGFkb3dMaWdodFdoaWNoU2NlbmUoaSxlKXtpZihlPT1RZS5EaXJlY3Rpb25MaWdodCl7bGV0IHQ9dGhpcy5kaXJlY3Rpb25MaWdodExpc3QuZ2V0KGkpO3JldHVybiB0fHwodD1bXSx0aGlzLmRpcmVjdGlvbkxpZ2h0TGlzdC5zZXQoaSx0KSksdH1lbHNlIGlmKGU9PVFlLlBvaW50TGlnaHQpe2xldCB0PXRoaXMucG9pbnRMaWdodExpc3QuZ2V0KGkpO3JldHVybiB0fHwodD1bXSx0aGlzLnBvaW50TGlnaHRMaXN0LnNldChpLHQpKSx0fX1zdGF0aWMgZ2V0RGlyZWN0U2hhZG93TGlnaHRXaGljaFNjZW5lKGkpe2xldCBlPXRoaXMuZGlyZWN0aW9uTGlnaHRMaXN0LmdldChpKTtyZXR1cm4gZXx8KGU9W10sdGhpcy5kaXJlY3Rpb25MaWdodExpc3Quc2V0KGksZSkpLGV9c3RhdGljIGdldFBvaW50U2hhZG93TGlnaHRXaGljaFNjZW5lKGkpe2xldCBlPXRoaXMucG9pbnRMaWdodExpc3QuZ2V0KGkpO3JldHVybiBlfHwoZT1bXSx0aGlzLnBvaW50TGlnaHRMaXN0LnNldChpLGUpKSxlfXN0YXRpYyBhZGRTaGFkb3dMaWdodChpKXtpZighaS50cmFuc2Zvcm0udmlldzNEKXJldHVybiBudWxsO2xldCBlPWkudHJhbnNmb3JtLnZpZXczRC5zY2VuZTtpZihpLmxpZ2h0RGF0YS5saWdodFR5cGU9PVFlLkRpcmVjdGlvbkxpZ2h0KXtsZXQgdD10aGlzLmRpcmVjdGlvbkxpZ2h0TGlzdC5nZXQoZSk7aWYodHx8KHQ9W10sdGhpcy5kaXJlY3Rpb25MaWdodExpc3Quc2V0KGUsdCkpLCFpLnNoYWRvd0NhbWVyYSl7aS5zaGFkb3dDYW1lcmE9TmUuY3JlYXRlQ2FtZXJhM0RPYmplY3QobnVsbCxcInNoYWRvd0NhbWVyYVwiKSxpLnNoYWRvd0NhbWVyYS5pc1NoYWRvd0NhbWVyYT0hMDtsZXQgcj0tMWUzO2kuc2hhZG93Q2FtZXJhLm9ydGhvT2ZmQ2VudGVyKHIsLXIsciwtciwxLDFlNCl9cmV0dXJuIHQuaW5kZXhPZihpKT09LTEmJnQucHVzaChpKSx0fWVsc2UgaWYoaS5saWdodERhdGEubGlnaHRUeXBlPT1RZS5Qb2ludExpZ2h0fHxpLmxpZ2h0RGF0YS5saWdodFR5cGU9PVFlLlNwb3RMaWdodCl7bGV0IHQ9dGhpcy5wb2ludExpZ2h0TGlzdC5nZXQoZSk7cmV0dXJuIHQmJnQubGVuZ3RoPj04fHwodHx8KHQ9W10sdGhpcy5wb2ludExpZ2h0TGlzdC5zZXQoZSx0KSksdC5pbmRleE9mKGkpPT0tMSYmdC5wdXNoKGkpKSx0fX1zdGF0aWMgcmVtb3ZlU2hhZG93TGlnaHQoaSl7aWYoaS5saWdodERhdGEuY2FzdFNoYWRvd0luZGV4PS0xLCFpLnRyYW5zZm9ybS52aWV3M0QpcmV0dXJuIG51bGw7aWYoaS5saWdodERhdGEubGlnaHRUeXBlPT1RZS5EaXJlY3Rpb25MaWdodCl7bGV0IGU9dGhpcy5kaXJlY3Rpb25MaWdodExpc3QuZ2V0KGkudHJhbnNmb3JtLnZpZXczRC5zY2VuZSk7aWYoZSl7bGV0IHQ9ZS5pbmRleE9mKGkpO3QhPS0xJiZlLnNwbGljZSh0LDEpfXJldHVybiBpLmxpZ2h0RGF0YS5jYXN0U2hhZG93SW5kZXg9LTEsZX1lbHNlIGlmKGkubGlnaHREYXRhLmxpZ2h0VHlwZT09UWUuUG9pbnRMaWdodHx8aS5saWdodERhdGEubGlnaHRUeXBlPT1RZS5TcG90TGlnaHQpe2xldCBlPXRoaXMucG9pbnRMaWdodExpc3QuZ2V0KGkudHJhbnNmb3JtLnZpZXczRC5zY2VuZSk7aWYoZSl7bGV0IHQ9ZS5pbmRleE9mKGkpO3QhPS0xJiZlLnNwbGljZSh0LDEpfXJldHVybiBpLmxpZ2h0RGF0YS5jYXN0U2hhZG93SW5kZXg9LTEsZX19c3RhdGljIHVwZGF0ZShpKXtsZXQgZT10aGlzLnNoYWRvd0J1ZmZlci5nZXQoaSksdD10aGlzLnNoYWRvd0xpZ2h0cy5nZXQoaSkscj1hby5kaXJlY3Rpb25MaWdodExpc3QuZ2V0KGkpLHM9YW8ucG9pbnRMaWdodExpc3QuZ2V0KGkpLGE9MCxuPTAsbD0wLGg9MDtpZih0LmZpbGwoMCkscil7bGV0IHU9MDtmb3IobGV0IGM9MDtjPHIubGVuZ3RoO2MrKyl7Y29uc3QgZj1yW2NdO3RbY109Zi5saWdodERhdGEuaW5kZXgsZi5saWdodERhdGEuY2FzdFNoYWRvd0luZGV4PXUrK31uPXIubGVuZ3RofWlmKGUuc2V0SW50MzIoXCJuRGlyU2hhZG93U3RhcnRcIixhKSxlLnNldEludDMyKFwibkRpclNoYWRvd0VuZFwiLG4pLHMpe2w9bjtsZXQgdT0wO2ZvcihsZXQgYz1sO2M8cy5sZW5ndGg7YysrKXtjb25zdCBmPXNbY107dFtjXT1mLmxpZ2h0RGF0YS5pbmRleCxmLmxpZ2h0RGF0YS5jYXN0U2hhZG93SW5kZXg9dSsrfWg9bCtzLmxlbmd0aH1lLnNldEludDMyKFwiblBvaW50U2hhZG93U3RhcnRcIixsKSxlLnNldEludDMyKFwiblBvaW50U2hhZG93RW5kXCIsaCksZS5zZXRVaW50MzJBcnJheShcInNoYWRvd0xpZ2h0c1wiLHQpLGUuYXBwbHkoKX19O2xldCBWZT1hbztvKFZlLFwibWF4TnVtRGlyZWN0aW9uU2hhZG93XCIsOCksbyhWZSxcIm1heE51bVBvaW50U2hhZG93XCIsOCksbyhWZSxcImRpcmVjdGlvbkxpZ2h0TGlzdFwiKSxvKFZlLFwicG9pbnRMaWdodExpc3RcIiksbyhWZSxcInNoYWRvd0J1ZmZlclwiKSxvKFZlLFwic2hhZG93TGlnaHRzXCIpO2NsYXNzIEhye3N0YXRpYyBnZXRHbG9iYWxEYXRhQmluZEdyb3VwTGF5b3V0KCl7aWYodGhpcy5fZ2xvYmFsRGF0YUJpbmRHcm91cExheW91dClyZXR1cm4gdGhpcy5fZ2xvYmFsRGF0YUJpbmRHcm91cExheW91dDtsZXQgZT1bXTtyZXR1cm4gZS5wdXNoKHtiaW5kaW5nOjAsdmlzaWJpbGl0eTpHUFVTaGFkZXJTdGFnZS5WRVJURVh8R1BVU2hhZGVyU3RhZ2UuRlJBR01FTlR8R1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxidWZmZXI6e3R5cGU6XCJ1bmlmb3JtXCJ9fSksZS5wdXNoKHtiaW5kaW5nOjEsdmlzaWJpbGl0eTpHUFVTaGFkZXJTdGFnZS5WRVJURVh8R1BVU2hhZGVyU3RhZ2UuRlJBR01FTlR8R1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxidWZmZXI6e3R5cGU6XCJyZWFkLW9ubHktc3RvcmFnZVwifX0pLHRoaXMuX2dsb2JhbERhdGFCaW5kR3JvdXBMYXlvdXQ9Uy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtlbnRyaWVzOmV9KSx0aGlzLl9nbG9iYWxEYXRhQmluZEdyb3VwTGF5b3V0fX1vKEhyLFwiX2dsb2JhbERhdGFCaW5kR3JvdXBMYXlvdXRcIik7Y2xhc3MgU2x7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwidXVpZFwiKSxvKHRoaXMsXCJ1c2FnZVwiKSxvKHRoaXMsXCJnbG9iYWxCaW5kR3JvdXBcIiksbyh0aGlzLFwidW5pZm9ybUdQVUJ1ZmZlclwiKSxvKHRoaXMsXCJtYXRyaXhCaW5kR3JvdXBcIiksbyh0aGlzLFwidW5pZm9ybUJ5dGVMZW5ndGhcIiksbyh0aGlzLFwibWF0cml4ZXNCeXRlTGVuZ3RoXCIpLG8odGhpcyxcInNoYWRvd01hdHJpeFJhd1wiLG5ldyBGbG9hdDMyQXJyYXkoOCoxNikpLG8odGhpcyxcImNzbU1hdHJpeFJhd1wiLG5ldyBGbG9hdDMyQXJyYXkobHQuQ2FzY2FkZXMqMTYpKSxvKHRoaXMsXCJjc21TaGFkb3dCaWFzXCIsbmV3IEZsb2F0MzJBcnJheSg0KSksdGhpcy51dWlkPVB0KCksdGhpcy51c2FnZT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNfEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsdGhpcy51bmlmb3JtR1BVQnVmZmVyPW5ldyBEdCgzMio0KjQrMyo0KjQrOCoxNitsdC5DYXNjYWRlcyoxNis0KzQpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci52aXNpYmlsaXR5PUdQVVNoYWRlclN0YWdlLlZFUlRFWHxHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVHxHUFVTaGFkZXJTdGFnZS5DT01QVVRFLHRoaXMubWF0cml4QmluZEdyb3VwPWUsdGhpcy5jcmVhdGVCaW5kR3JvdXAoKX1jcmVhdGVCaW5kR3JvdXAoKXt0aGlzLnVuaWZvcm1CeXRlTGVuZ3RoPXRoaXMudW5pZm9ybUdQVUJ1ZmZlci5tZW1vcnkuc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgsdGhpcy5tYXRyaXhlc0J5dGVMZW5ndGg9Vi5ibG9ja0J5dGVzKlYubWF4Q291bnQsdGhpcy5nbG9iYWxCaW5kR3JvdXA9Uy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtsYWJlbDpcImdsb2JhbF9iaW5kR3JvdXBMYXlvdXRcIixsYXlvdXQ6SHIuZ2V0R2xvYmFsRGF0YUJpbmRHcm91cExheW91dCgpLGVudHJpZXM6W3tiaW5kaW5nOjAscmVzb3VyY2U6e2J1ZmZlcjp0aGlzLnVuaWZvcm1HUFVCdWZmZXIuYnVmZmVyLG9mZnNldDowLHNpemU6dGhpcy51bmlmb3JtQnl0ZUxlbmd0aH19LHtiaW5kaW5nOjEscmVzb3VyY2U6e2J1ZmZlcjp0aGlzLm1hdHJpeEJpbmRHcm91cC5tYXRyaXhCdWZmZXJEc3QuYnVmZmVyLG9mZnNldDowLHNpemU6dGhpcy5tYXRyaXhlc0J5dGVMZW5ndGh9fV19KX1zZXRDYW1lcmEoZSl7dGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldE1hdHJpeChcIl9wcm9qZWN0aW9uTWF0cml4XCIsZS5wcm9qZWN0aW9uTWF0cml4KSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0TWF0cml4KFwiX3ZpZXdNYXRyaXhcIixlLnZpZXdNYXRyaXgpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRNYXRyaXgoXCJfY2FtZXJhV29ybGRNYXRyaXhcIixlLnRyYW5zZm9ybS53b3JsZE1hdHJpeCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldE1hdHJpeChcInB2TWF0cml4SW52XCIsZS5wcm9qZWN0aW9uTWF0cml4SW52KTtsZXQgdD1WZS5nZXREaXJlY3RTaGFkb3dMaWdodFdoaWNoU2NlbmUoZS50cmFuc2Zvcm0uc2NlbmUzRCk7dGhpcy5jc21TaGFkb3dCaWFzLmZpbGwoMWUtNCksdGhpcy5zaGFkb3dNYXRyaXhSYXcuZmlsbCgwKSx0aGlzLmNzbU1hdHJpeFJhdy5maWxsKDApO2ZvcihsZXQgbj0wO248ODtuKyspaWYobjx0Lmxlbmd0aCl7bGV0IGw9dFtuXS5zaGFkb3dDYW1lcmE7dGhpcy5zaGFkb3dNYXRyaXhSYXcuc2V0KGwucHZNYXRyaXgucmF3RGF0YSxuKjE2KX1lbHNlIHRoaXMuc2hhZG93TWF0cml4UmF3LnNldChlLnRyYW5zZm9ybS53b3JsZE1hdHJpeC5yYXdEYXRhLG4qMTYpO3RoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdDMyQXJyYXkoXCJzaGFkb3dNYXRyaXhcIix0aGlzLnNoYWRvd01hdHJpeFJhdyk7bGV0IHI9QS5zZXR0aW5nLnNoYWRvdy5zaGFkb3dTaXplO2lmKGx0LkNhc2NhZGVzPjEmJmUuZW5hYmxlQ1NNJiZ0WzBdKWZvcihsZXQgbj0wO248bHQuQ2FzY2FkZXM7bisrKXtsZXQgbD1lLmNzbS5jaGlsZHJlbltuXS5zaGFkb3dDYW1lcmE7dGhpcy5jc21NYXRyaXhSYXcuc2V0KGwucHZNYXRyaXgucmF3RGF0YSxuKjE2KSx0aGlzLmNzbVNoYWRvd0JpYXNbbl09ZS5nZXRDU01TaGFkb3dCaWFzKG4scil9dGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0MzJBcnJheShcImNzbVNoYWRvd0JpYXNcIix0aGlzLmNzbVNoYWRvd0JpYXMpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdDMyQXJyYXkoXCJjc21NYXRyaXhcIix0aGlzLmNzbU1hdHJpeFJhdyksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldFZlY3RvcjMoXCJDYW1lcmFQb3NcIixlLnRyYW5zZm9ybS53b3JsZFBvc2l0aW9uKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJmcmFtZVwiLGhlLmZyYW1lKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJ0aW1lXCIsaGUuZnJhbWUpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcImRlbHRhXCIsaGUuZGVsdGEpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInNoYWRvd0JpYXNcIixlLmdldFNoYWRvd0JpYXMocikpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInNreUV4cG9zdXJlXCIsQS5zZXR0aW5nLnNreS5za3lFeHBvc3VyZSksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwicmVuZGVyUGFzc1N0YXRlXCIsQS5zZXR0aW5nLnJlbmRlci5yZW5kZXJQYXNzU3RhdGUpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInF1YWRTY2FsZVwiLEEuc2V0dGluZy5yZW5kZXIucXVhZFNjYWxlKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJoZHJFeHBvc3VyZVwiLEEuc2V0dGluZy5yZW5kZXIuaGRyRXhwb3N1cmUpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRJbnQzMihcInJlbmRlclN0YXRlX2xlZnRcIixBLnNldHRpbmcucmVuZGVyLnJlbmRlclN0YXRlX2xlZnQpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRJbnQzMihcInJlbmRlclN0YXRlX3JpZ2h0XCIsQS5zZXR0aW5nLnJlbmRlci5yZW5kZXJTdGF0ZV9yaWdodCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwicmVuZGVyU3RhdGVfc3BsaXRcIixBLnNldHRpbmcucmVuZGVyLnJlbmRlclN0YXRlX3NwbGl0KTtsZXQgcz1BLmlucHV0U3lzdGVtLm1vdXNlWCpTLnBpeGVsUmF0aW8sYT1BLmlucHV0U3lzdGVtLm1vdXNlWSpTLnBpeGVsUmF0aW87dGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwibW91c2VYXCIscyksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwibW91c2VZXCIsYSksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwid2luZG93V2lkdGhcIixTLndpbmRvd1dpZHRoKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJ3aW5kb3dIZWlnaHRcIixTLndpbmRvd0hlaWdodCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwibmVhclwiLGUubmVhciksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwiZmFyXCIsZS5mYXIpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInBvaW50U2hhZG93Qmlhc1wiLEEuc2V0dGluZy5zaGFkb3cucG9pbnRTaGFkb3dCaWFzKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJzaGFkb3dNYXBTaXplXCIsciksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwic2hhZG93U29mdFwiLEEuc2V0dGluZy5zaGFkb3cuc2hhZG93U29mdCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwiZW5hYmxlQ1NNXCIsZS5lbmFibGVDU00/MTowKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJjc21NYXJnaW5cIixBLnNldHRpbmcuc2hhZG93LmNzbU1hcmdpbiksdGhpcy51bmlmb3JtR1BVQnVmZmVyLmFwcGx5KCl9c2V0U2hhZG93Q2FtZXJhKGUpe3RoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRNYXRyaXgoXCJfcHJvamVjdGlvbk1hdHJpeFwiLGUucHJvamVjdGlvbk1hdHJpeCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldE1hdHJpeChcIl92aWV3TWF0cml4XCIsZS52aWV3TWF0cml4KSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0TWF0cml4KFwiX3B2TWF0cml4XCIsZS5wdk1hdHJpeCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldE1hdHJpeChcInB2TWF0cml4SW52XCIsZS5wcm9qZWN0aW9uTWF0cml4SW52KSx0aGlzLmNzbVNoYWRvd0JpYXMuZmlsbCgxZS00KSx0aGlzLnNoYWRvd01hdHJpeFJhdy5maWxsKDApLHRoaXMuY3NtTWF0cml4UmF3LmZpbGwoMCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0MzJBcnJheShcInNoYWRvd0NhbWVyYVwiLHRoaXMuc2hhZG93TWF0cml4UmF3KSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQzMkFycmF5KFwiY3NtU2hhZG93Qmlhc1wiLHRoaXMuY3NtU2hhZG93QmlhcyksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0MzJBcnJheShcImNzbU1hdHJpeFwiLHRoaXMuY3NtTWF0cml4UmF3KSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0VmVjdG9yMyhcIkNhbWVyYVBvc1wiLGUudHJhbnNmb3JtLndvcmxkUG9zaXRpb24pLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcImZyYW1lXCIsaGUuZnJhbWUpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInRpbWVcIixoZS5mcmFtZSksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwiZGVsdGFcIixoZS5kZWx0YSksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwic2hhZG93Qmlhc1wiLDFlLTQpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInNreUV4cG9zdXJlXCIsQS5zZXR0aW5nLnNreS5za3lFeHBvc3VyZSksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwicmVuZGVyUGFzc1N0YXRlXCIsQS5zZXR0aW5nLnJlbmRlci5yZW5kZXJQYXNzU3RhdGUpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInF1YWRTY2FsZVwiLEEuc2V0dGluZy5yZW5kZXIucXVhZFNjYWxlKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJoZHJFeHBvc3VyZVwiLEEuc2V0dGluZy5yZW5kZXIuaGRyRXhwb3N1cmUpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRJbnQzMihcInJlbmRlclN0YXRlX2xlZnRcIixBLnNldHRpbmcucmVuZGVyLnJlbmRlclN0YXRlX2xlZnQpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRJbnQzMihcInJlbmRlclN0YXRlX3JpZ2h0XCIsQS5zZXR0aW5nLnJlbmRlci5yZW5kZXJTdGF0ZV9yaWdodCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwicmVuZGVyU3RhdGVfc3BsaXRcIixBLnNldHRpbmcucmVuZGVyLnJlbmRlclN0YXRlX3NwbGl0KTtsZXQgdD1BLmlucHV0U3lzdGVtLm1vdXNlWCpTLnBpeGVsUmF0aW8scj1BLmlucHV0U3lzdGVtLm1vdXNlWSpTLnBpeGVsUmF0aW87dGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwibW91c2VYXCIsdCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwibW91c2VZXCIsciksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwid2luZG93V2lkdGhcIixTLndpbmRvd1dpZHRoKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJ3aW5kb3dIZWlnaHRcIixTLndpbmRvd0hlaWdodCksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwibmVhclwiLGUubmVhciksdGhpcy51bmlmb3JtR1BVQnVmZmVyLnNldEZsb2F0KFwiZmFyXCIsZS5mYXIpLHRoaXMudW5pZm9ybUdQVUJ1ZmZlci5zZXRGbG9hdChcInBvaW50U2hhZG93Qmlhc1wiLEEuc2V0dGluZy5zaGFkb3cucG9pbnRTaGFkb3dCaWFzKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJzaGFkb3dNYXBTaXplXCIsQS5zZXR0aW5nLnNoYWRvdy5zaGFkb3dTaXplKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJzaGFkb3dTb2Z0XCIsQS5zZXR0aW5nLnNoYWRvdy5zaGFkb3dTb2Z0KSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJlbmFibGVDU01cIiwwKSx0aGlzLnVuaWZvcm1HUFVCdWZmZXIuc2V0RmxvYXQoXCJjc21NYXJnaW5cIixBLnNldHRpbmcuc2hhZG93LmNzbU1hcmdpbiksdGhpcy51bmlmb3JtR1BVQnVmZmVyLmFwcGx5KCl9YWRkVW5pZm9ybU5vZGUoKXt9fWNvbnN0ICRpPWNsYXNze2NvbnN0cnVjdG9yKGksZT0wLHQ9bnVsbCxyPTApe28odGhpcyxcImVudGl0aWVzXCIpLG8odGhpcyxcImJveFwiKSxvKHRoaXMsXCJzdWJUcmVlc1wiLFtdKSxvKHRoaXMsXCJwYXJlbnRcIiksbyh0aGlzLFwibGV2ZWxcIiksbyh0aGlzLFwiaW5kZXhcIiksbyh0aGlzLFwidXVpZFwiKSxvKHRoaXMsXCJfX3JheUNhc3RUZW1wVmVjdG9yXCIsbmV3IGcpLHRoaXMucGFyZW50PXQsdGhpcy5ib3g9aS5jbG9uZSgpLHRoaXMubGV2ZWw9cix0aGlzLmluZGV4PWUsdGhpcy51dWlkPXIrXCJfXCIrZSx0aGlzLmVudGl0aWVzPW5ldyBNYXB9dHJ5SW5zZXJ0RW50aXR5KGkpe2xldCBlPWkucmVuZGVyZXIub2JqZWN0M0QuYm91bmQ7aWYodGhpcy5sZXZlbD09MHx8dGhpcy5ib3guY29udGFpbnNCb3goZSkpe3RoaXMuc3ViVHJlZXMubGVuZ3RoPT0wJiZ0aGlzLmxldmVsPCRpLm1heFNwbGl0TGV2ZWwmJnRoaXMuc3BsaXRUcmVlKCk7bGV0IHQ7aWYodGhpcy5zdWJUcmVlcy5sZW5ndGg+MCl7Zm9yKGxldCByIG9mIHRoaXMuc3ViVHJlZXMpaWYoci50cnlJbnNlcnRFbnRpdHkoaSkpe3Q9ITA7YnJlYWt9fXJldHVybiB0fHxpLmVudGVyTm9kZSh0aGlzKSwhMH1yZXR1cm4hMX1zcGxpdFRyZWUoKXtpZih0aGlzLnN1YlRyZWVzLmxlbmd0aD09MCl7Y29uc3QgaT0kaS5fdjEsZT10aGlzLmJveC5leHRlbnRzLmNsb25lKCk7bGV0IHQ9dGhpcy5sZXZlbCsxLHI9MDtmb3IobGV0IHM9MDtzPDI7cysrKWZvcihsZXQgYT0wO2E8MjthKyspZm9yKGxldCBuPTA7bjwyO24rKyl7Y29uc3QgbD1uZXcgQmU7dGhpcy5ib3gubWluLmFkZChpLnNldChzLGEsbikubXVsdGlwbHkoZSksbC5taW4pLGwubWluLmFkZChlLGwubWF4KSxsLnNldEZyb21NaW5NYXgobC5taW4sbC5tYXgpO2xldCBoPW5ldyAkaShsLHIrKyx0aGlzLHQpO3RoaXMuc3ViVHJlZXMucHVzaChoKX19fXJheUNhc3RzKGksZSl7aWYodGhpcy5sZXZlbD09MHx8aS5pbnRlcnNlY3RCb3godGhpcy5ib3gsdGhpcy5fX3JheUNhc3RUZW1wVmVjdG9yKSl7dGhpcy5lbnRpdGllcy5zaXplPjAmJmUucHVzaCguLi50aGlzLmVudGl0aWVzLnZhbHVlcygpKTtmb3IobGV0IHQgb2YgdGhpcy5zdWJUcmVlcyl0LnJheUNhc3RzKGksZSk7cmV0dXJuITB9cmV0dXJuITF9ZnJ1c3R1bUNhc3RzKGksZSl7aWYodGhpcy5sZXZlbD09MHx8aS5jb250YWluc0JveDIodGhpcy5ib3gpPjApe2lmKHRoaXMuZW50aXRpZXMuc2l6ZT4wKWZvcihjb25zdCB0IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpKHRoaXMubGV2ZWw+JGkuYXV0b1NwbGl0TGV2ZWx8fGkuY29udGFpbnNCb3gyKHQucmVuZGVyZXIub2JqZWN0M0QuYm91bmQpPjApJiZlLnB1c2godCk7Zm9yKGxldCB0IG9mIHRoaXMuc3ViVHJlZXMpdC5mcnVzdHVtQ2FzdHMoaSxlKTtyZXR1cm4hMH1yZXR1cm4hMX1nZXRSZW5kZXJOb2RlKGksZSl7aWYodGhpcy5sZXZlbD09MHx8aS5jb250YWluc0JveDIodGhpcy5ib3gpPjApe2lmKHRoaXMuZW50aXRpZXMuc2l6ZT4wKWZvcihjb25zdCB0IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpKHRoaXMubGV2ZWw+JGkuYXV0b1NwbGl0TGV2ZWx8fGkuY29udGFpbnNCb3gyKHQucmVuZGVyZXIub2JqZWN0M0QuYm91bmQpPjApJiYodC5yZW5kZXJlci5yZW5kZXJPcmRlcjwzZTM/ZS5vcGFxdWVMaXN0LnB1c2godC5yZW5kZXJlcik6dC5yZW5kZXJlci5yZW5kZXJPcmRlcj49M2UzJiZlLnRyYW5zcGFyZW50TGlzdC5wdXNoKHQucmVuZGVyZXIpKTtmb3IobGV0IHQgb2YgdGhpcy5zdWJUcmVlcyl0LmdldFJlbmRlck5vZGUoaSxlKTtyZXR1cm4hMH1yZXR1cm4hMX1ib3hDYXN0cyhpLGUpe2lmKGkuaW50ZXJzZWN0c0JveCh0aGlzLmJveCkpe3RoaXMuZW50aXRpZXMuc2l6ZT4wJiZlLnB1c2goLi4udGhpcy5lbnRpdGllcy52YWx1ZXMoKSk7Zm9yKGxldCB0IG9mIHRoaXMuc3ViVHJlZXMpdC5ib3hDYXN0cyhpLGUpO3JldHVybiEwfXJldHVybiExfWNsZWFuKCl7Zm9yKGxldCBpIG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpaS5sZWF2ZU5vZGUoKTtyZXR1cm4gdGhpcy5lbnRpdGllcy5jbGVhcigpLHRoaXN9fTtsZXQgZXI9JGk7byhlcixcIl92MVwiLG5ldyBnKSxvKGVyLFwiX3YyXCIsbmV3IGcpLG8oZXIsXCJtYXhTcGxpdExldmVsXCIsNiksbyhlcixcImF1dG9TcGxpdExldmVsXCIsMyk7Y2xhc3MgSWx7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJfcG9vbFwiLFtdKSxvKHRoaXMsXCJfd29ybGRQb3NpdGlvblwiLG5ldyBnKSxvKHRoaXMsXCJfdmlld1Bvc2l0aW9uXCIsbmV3IGcpLG8odGhpcyxcIl96U29ydExpc3RcIixbXSl9cG9wKCl7cmV0dXJuIHRoaXMuX3Bvb2wucG9wKCl8fHt9fXJlY3ljbGUoKXtmb3IobGV0IGUgb2YgdGhpcy5felNvcnRMaXN0KWUuej0wLGUudXNlckRhdGE9bnVsbCxlLm9iajNkPW51bGwsdGhpcy5fcG9vbC5wdXNoKGUpO3RoaXMuX3pTb3J0TGlzdC5sZW5ndGg9MH1zb3J0KGUsdCxyLHMpe3RoaXMuX3pTb3J0TGlzdD1bXTtmb3IobGV0IGEgb2YgdCl7bGV0IG49dGhpcy5wb3AoKTtuLnVzZXJEYXRhPWEsbi5vYmozZD1yKGEpLG4uej10aGlzLndvcmxkVG9DYW1lcmFEZXB0aChuLm9iajNkLGUpLHRoaXMuX3pTb3J0TGlzdC5wdXNoKG4pfXRoaXMuX3pTb3J0TGlzdC5zb3J0KChhLG4pPT5hLnotbi56PjA/MTotMSksc3x8KHM9W10pO2ZvcihsZXQgYSBvZiB0aGlzLl96U29ydExpc3Qpcy5wdXNoKGEudXNlckRhdGEpO3JldHVybiB0aGlzLnJlY3ljbGUoKSxzfXdvcmxkVG9DYW1lcmFEZXB0aChlLHQpe3R8fCh0PWUudHJhbnNmb3JtLnZpZXczRC5jYW1lcmEpO2xldCByPTA7cmV0dXJuIHQmJih0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHlGcm9tKGUudHJhbnNmb3JtLndvcmxkUG9zaXRpb24pLHQud29ybGRUb1NjcmVlblBvaW50KHRoaXMuX3dvcmxkUG9zaXRpb24sdGhpcy5fdmlld1Bvc2l0aW9uKSxyPXRoaXMuX3ZpZXdQb3NpdGlvbi56KSxyfX1sZXQgRWw9bmV3IElsO3ZhciBZcj0oaT0+KGlbaS5Ob25lPTJdPVwiTm9uZVwiLGlbaS5TdGF0aWNCYXRjaD00XT1cIlN0YXRpY0JhdGNoXCIsaVtpLkR5bmFtaWNCYXRjaD04XT1cIkR5bmFtaWNCYXRjaFwiLGkpKShZcnx8e30pO2NsYXNzIG9ve3N0YXRpYyBhZGRNYXNrKGUsdCl7cmV0dXJuIGV8dH1zdGF0aWMgcmVtb3ZlTWFzayhlLHQpe3JldHVybiBlJn50fXN0YXRpYyBoYXNNYXNrKGUsdCl7cmV0dXJuKGUmdCkhPTB9fWZ1bmN0aW9uIHpkKGksZSl7bGV0IHQ9aS5fX05vblNlcmlhbGl6ZV9fO3R8fCh0PWkuX19Ob25TZXJpYWxpemVfXz17fSx0Ll9fTm9uU2VyaWFsaXplX189ITApLHRbZV09ITB9ZnVuY3Rpb24gR2QoaSxlKXtsZXQgdDtmb3IoO2kmJihpPWkuX19wcm90b19fLGkmJih0PWkuX19Ob25TZXJpYWxpemVfXyksIXQpOyk7cmV0dXJuIHQmJnRbZV19ZnVuY3Rpb24gVnQoaSxlLHQscixzKXtsZXQgYT1pLl9fRWRpdG9ySW5zcGVjdG9yX187YXx8KGE9aS5fX0VkaXRvckluc3BlY3Rvcl9fPW5ldyBNYXApO2xldCBuPWEuZ2V0KGkuY29uc3RydWN0b3IubmFtZSk7bnx8KG49bmV3IE1hcCxhLnNldChpLmNvbnN0cnVjdG9yLm5hbWUsbikpLG4uc2V0KGUse3AxOnQscDI6cixwMzpzfSl9ZnVuY3Rpb24gUWQoaSl7bGV0IGUsdD1pLHI9W107Zm9yKDt0Oyl7aWYoci5pbmRleE9mKHQuY29uc3RydWN0b3IubmFtZSkhPS0xKXt0PXQuX19wcm90b19fO2NvbnRpbnVlfXIucHVzaCh0LmNvbnN0cnVjdG9yLm5hbWUpLHQ9dC5fX3Byb3RvX199Zm9yKHI9ci5yZXZlcnNlKCksdD1pO3QmJih0PXQuX19wcm90b19fLHQmJihlPXQuX19FZGl0b3JJbnNwZWN0b3JfXyksIWUpOyk7bGV0IHM9bmV3IE1hcDtpZihlKWZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKXtjb25zdCBuPXJbYV07bGV0IGw9ZS5nZXQobik7bCYmbC5mb3JFYWNoKChoLHUpPT57cy5zZXQodSxoKX0pfXJldHVybiBzfWZ1bmN0aW9uIFZkKGksZSx0LHIscyl7bGV0IGE9d2luZG93Ll9fQ29tcG9uZW50X187YXx8KGE9d2luZG93Ll9fQ29tcG9uZW50X189e30pLGFbaS5uYW1lXT1pfXZhciByZT0oaT0+KGlbaS5DT0xPUj0xXT1cIkNPTE9SXCIsaVtpLk5PUk1BTD0yXT1cIk5PUk1BTFwiLGlbaS5QT1NJVElPTj00XT1cIlBPU0lUSU9OXCIsaVtpLkdSQVBISUM9OF09XCJHUkFQSElDXCIsaVtpLkdJPTE2XT1cIkdJXCIsaVtpLkNsdXN0ZXI9MzJdPVwiQ2x1c3RlclwiLGlbaS5TSEFET1c9NjRdPVwiU0hBRE9XXCIsaVtpLlBPSU5UX1NIQURPVz0xMjhdPVwiUE9JTlRfU0hBRE9XXCIsaVtpLlBPU1Q9MjU2XT1cIlBPU1RcIixpW2kuREVQVEg9NTEyXT1cIkRFUFRIXCIsaVtpLlJFRkxFQ1RJT049MTAyNF09XCJSRUZMRUNUSU9OXCIsaSkpKHJlfHx7fSk7Y2xhc3MgbGV7fW8obGUsXCJHTFRGX05PREVfSU5ERVhfUFJPUEVSVFlcIiksbyhsZSxcIkJBU0VfQ09MT1JfVU5JRk9STVwiLFwidV9iYXNlQ29sb3JGYWN0b3JcIiksbyhsZSxcIkJBU0VfQ09MT1JfVEVYVFVSRV9VTklGT1JNXCIsXCJ1X2Jhc2VDb2xvclNhbXBsZXJcIiksbyhsZSxcIk1FVEFMUk9VR0hORVNTX1VOSUZPUk1cIixcInVfbWV0YWxsaWNSb3VnaG5lc3NWYWx1ZXNcIiksbyhsZSxcIk1FVEFMUk9VR0hORVNTX1RFWFRVUkVfVU5JRk9STVwiLFwidV9tZXRhbGxpY1JvdWdobmVzc1NhbXBsZXJcIiksbyhsZSxcIk5PUk1BTF9URVhUVVJFX1VOSUZPUk1cIixcInVfbm9ybWFsU2FtcGxlclwiKSxvKGxlLFwiTk9STUFMX1NDQUxFX1VOSUZPUk1cIixcInVfbm9ybWFsU2NhbGVcIiksbyhsZSxcIkVNSVNTSVZFX1RFWFRVUkVfVU5JRk9STVwiLFwidV9lbWlzc2l2ZVNhbXBsZXJcIiksbyhsZSxcIkVNSVNTSVZFX0ZBQ1RPUl9VTklGT1JNXCIsXCJ1X2VtaXNzaXZlRmFjdG9yXCIpLG8obGUsXCJPQ0NMVVNJT05fVEVYVFVSRV9VTklGT1JNXCIsXCJ1X29jY2x1c2lvblNhbXBsZXJcIiksbyhsZSxcIk9DQ0xVU0lPTl9GQUNUT1JfVU5JRk9STVwiLFwidV9vY2NsdXNpb25GYWN0b3JcIiksbyhsZSxcIk1BWF9NT1JQSF9UQVJHRVRTXCIsOCksbyhsZSxcIk1PUlBIX1BPU0lUSU9OX1BSRUZJWFwiLFwiYV9tb3JwaFBvc2l0aW9uc19cIiksbyhsZSxcIk1PUlBIX05PUk1BTF9QUkVGSVhcIixcImFfbW9ycGhOb3JtYWxzX1wiKSxvKGxlLFwiTU9SUEhfVEFOR0VOVF9QUkVGSVhcIixcImFfbW9ycGhUYW5nZW50c19cIiksbyhsZSxcIk1PUlBIX1dFSUdIVF9VTklGT1JNXCIsXCJ1X21vcnBoV2VpZ2h0c1wiKSxvKGxlLFwiU0NFTkVfUk9PVF9TS0VMRVRPTlwiLFwiU0NFTkVfUk9PVFwiKSxvKGxlLFwiSURFTlRJVFlfSU5WRVJTRV9CSU5EX01BVFJJQ0VTXCIsXCJJREVOVElUWV9JQk1cIiksbyhsZSxcIkpPSU5UX01BVFJJQ0VTX1VOSUZPUk1cIixcInVfam9pbnRNYXRyaXhcIiksbyhsZSxcIkFMUEhBX0NVVE9GRl9VTklGT1JNXCIsXCJ1X2FscGhhQ3V0b2ZmXCIpO2NsYXNzIFhye3N0YXRpYyBjcmVhdGVHSVBhc3MoZSx0KXtpZihUdC5oYXNNYXNrKGUucmVuZGVyZXJNYXNrLFVlLlNreSkpe2xldCByPXQuZ2V0UGFzcyhyZS5DT0xPUilbMF0scz1uZXcgQmY7cy5zZXRUZXh0dXJlKFwiYmFzZU1hcFwiLHIuZ2V0VGV4dHVyZShcImJhc2VNYXBcIikpLHMuY3VsbE1vZGU9ci5jdWxsTW9kZSxzLmZyb250RmFjZT1yLmZyb250RmFjZSx0LmFkZFBhc3MocmUuR0kscywwKSxzLnByZUNvbXBpbGUoZS5nZW9tZXRyeSl9ZWxzZSB0aGlzLmNhc3RHQnVmZmVyUGFzcyhlLHQpfXN0YXRpYyBjYXN0R0J1ZmZlclBhc3MoZSx0KXtsZXQgcj10LmdldFBhc3MocmUuQ09MT1IpO2ZvcihsZXQgcz0wO3M8ci5sZW5ndGg7cysrKXtjb25zdCBhPXJbc107bGV0IG49dC5nZXRQYXNzKHJlLkdJKTtpZighbnx8bi5sZW5ndGg8cyl7bGV0IGw9bmV3IEVmO2wuc2V0VGV4dHVyZShcImJhc2VNYXBcIixhLmdldFRleHR1cmUoXCJiYXNlTWFwXCIpKSxsLnNldFRleHR1cmUoXCJub3JtYWxNYXBcIixhLmdldFRleHR1cmUoXCJub3JtYWxNYXBcIikpLGwuc2V0VGV4dHVyZShcImVtaXNzaXZlTWFwXCIsYS5nZXRUZXh0dXJlKFwiZW1pc3NpdmVNYXBcIikpLGwuc2V0VW5pZm9ybShcImJhc2VDb2xvclwiLGEuZ2V0VW5pZm9ybShcImJhc2VDb2xvclwiKSksbC5zZXRVbmlmb3JtKFwiZW52SW50ZW5zaXR5XCIsYS5nZXRVbmlmb3JtKFwiZW52SW50ZW5zaXR5XCIpKSxsLnNldFVuaWZvcm0oXCJlbWlzc2l2ZUNvbG9yXCIsYS5nZXRVbmlmb3JtKFwiZW1pc3NpdmVDb2xvclwiKSksbC5zZXRVbmlmb3JtKFwiZW1pc3NpdmVJbnRlbnNpdHlcIixhLmdldFVuaWZvcm0oXCJlbWlzc2l2ZUludGVuc2l0eVwiKSksbC5zZXRVbmlmb3JtKFwiYWxwaGFDdXRvZmZcIixhLmdldFVuaWZvcm0oXCJhbHBoYUN1dG9mZlwiKSksbC5jdWxsTW9kZT1hLmN1bGxNb2RlLGwuZnJvbnRGYWNlPWEuZnJvbnRGYWNlLGwucHJlQ29tcGlsZShlLmdlb21ldHJ5KSx0LmFkZFBhc3MocmUuR0ksbCl9fX1zdGF0aWMgY3JlYXRlU2hhZG93UGFzcyhlLHQpe2xldCByPVR0Lmhhc01hc2soZS5yZW5kZXJlck1hc2ssVWUuU2tpbm5lZE1lc2gpLHM9ZS5nZW9tZXRyeS5oYXNBdHRyaWJ1dGUoXCJUQU5HRU5UXCIpLGE9ZS5nZW9tZXRyeS5oYXNBdHRyaWJ1dGUobGUuTU9SUEhfUE9TSVRJT05fUFJFRklYK1wiMFwiKSxuPWUuZ2VvbWV0cnkuaGFzQXR0cmlidXRlKGxlLk1PUlBIX05PUk1BTF9QUkVGSVgrXCIwXCIpLGw9dC5nZXRQYXNzKHJlLkNPTE9SKTtmb3IobGV0IGg9MDtoPGwubGVuZ3RoO2grKyl7Y29uc3QgdT1sW2hdO2xldCBjPXQuZ2V0UGFzcyhyZS5TSEFET1cpO2lmKCFjfHxjLmxlbmd0aDxoKXtsZXQgZD1uZXcgU2Y7ZC5zZXRUZXh0dXJlKFwiYmFzZU1hcFwiLHUuZ2V0VGV4dHVyZShcImJhc2VNYXBcIikpLGQuc2V0VW5pZm9ybShcImFscGhhQ3V0b2ZmXCIsdS5nZXRVbmlmb3JtKFwiYWxwaGFDdXRvZmZcIikpLHMmJmQuc2V0RGVmaW5lKFwiVVNFX1RBTkdFTlRcIixzKSxyJiZkLnNldERlZmluZShcIlVTRV9TS0VMRVRPTlwiLHIpLGEmJmQuc2V0RGVmaW5lKFwiVVNFX01PUlBIVEFSR0VUU1wiLGEpLG4mJmQuc2V0RGVmaW5lKFwiVVNFX01PUlBITk9STUFMU1wiLG4pLHUuY3VsbE1vZGU9PVwibm9uZVwiP2Quc2hhZGVyU3RhdGUuY3VsbE1vZGU9XCJub25lXCI6dS5jdWxsTW9kZT09XCJiYWNrXCI/ZC5zaGFkZXJTdGF0ZS5jdWxsTW9kZT1cImZyb250XCI6dS5jdWxsTW9kZT09XCJmcm9udFwiJiYoZC5zaGFkZXJTdGF0ZS5jdWxsTW9kZT1cImJhY2tcIiksZC5wcmVDb21waWxlKGUuZ2VvbWV0cnkpLHQuYWRkUGFzcyhyZS5TSEFET1csZCl9aWYoIXQuZ2V0UGFzcyhyZS5QT0lOVF9TSEFET1cpKXtsZXQgZD1uZXcgYmY7ZC5zZXRUZXh0dXJlKFwiYmFzZU1hcFwiLHUuZ2V0VGV4dHVyZShcImJhc2VNYXBcIikpLGQuc2V0VW5pZm9ybShcImFscGhhQ3V0b2ZmXCIsdS5nZXRVbmlmb3JtKFwiYWxwaGFDdXRvZmZcIikpLGQuc2V0RGVmaW5lKFwiVVNFX0FMUEhBQ1VUXCIsMSk7Zm9yKGxldCBwPTA7cDwxO3ArKylzJiZkLnNldERlZmluZShcIlVTRV9UQU5HRU5UXCIscyksciYmZC5zZXREZWZpbmUoXCJVU0VfU0tFTEVUT05cIixyKSxhJiZkLnNldERlZmluZShcIlVTRV9NT1JQSFRBUkdFVFNcIixhKSxuJiZkLnNldERlZmluZShcIlVTRV9NT1JQSE5PUk1BTFNcIixuKSxkLnNoYWRlclN0YXRlLmN1bGxNb2RlPVwiZnJvbnRcIixkLnByZUNvbXBpbGUoZS5nZW9tZXRyeSk7dC5hZGRQYXNzKHJlLlBPSU5UX1NIQURPVyxkKX19fXN0YXRpYyBjcmVhdGVSZWZsZWN0aW9uUGFzcyhlLHQpe31zdGF0aWMgY3JlYXRlRGVwdGhQYXNzKGUsdCl7bGV0IHI9dC5nZXRQYXNzKHJlLkNPTE9SKSxzPWUuZ2VvbWV0cnkuaGFzQXR0cmlidXRlKFwiVEFOR0VOVFwiKSxhPWUuZ2VvbWV0cnkuaGFzQXR0cmlidXRlKGxlLk1PUlBIX1BPU0lUSU9OX1BSRUZJWCtcIjBcIiksbj1lLmdlb21ldHJ5Lmhhc0F0dHJpYnV0ZShsZS5NT1JQSF9OT1JNQUxfUFJFRklYK1wiMFwiKSxsPVR0Lmhhc01hc2soZS5yZW5kZXJlck1hc2ssVWUuU2tpbm5lZE1lc2gpO2ZvcihsZXQgaD0wO2g8ci5sZW5ndGg7aCsrKXtjb25zdCB1PXJbaF07bGV0IGM9dC5nZXRQYXNzKHJlLkRFUFRIKTtpZighYyYmdS5zaGFkZXJTdGF0ZS51c2VaJiYoIWN8fGMubGVuZ3RoPGgpKXtsZXQgZj1uZXcgSWY7Zi5zZXRUZXh0dXJlKFwiYmFzZU1hcFwiLHUuZ2V0VGV4dHVyZShcImJhc2VNYXBcIikpLHN8fGYuc2V0RGVmaW5lKFwiVVNFX1RBTkdFTlRcIixzKSxsJiZmLnNldERlZmluZShcIlVTRV9TS0VMRVRPTlwiLGwpLGEmJmYuc2V0RGVmaW5lKFwiVVNFX01PUlBIVEFSR0VUU1wiLGEpLG4mJmYuc2V0RGVmaW5lKFwiVVNFX01PUlBITk9STUFMU1wiLG4pLGYuY3VsbE1vZGU9dS5jdWxsTW9kZSxmLmZyb250RmFjZT11LmZyb250RmFjZSxmLnByZUNvbXBpbGUoZS5nZW9tZXRyeSksdC5hZGRQYXNzKHJlLkRFUFRILGYpfX19fWNvbnN0IEJsPWNsYXNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwicmVmZXJlbmNlXCIpfXN0YXRpYyBnZXRJbnN0YW5jZSgpe3JldHVybiB0aGlzLl9pbnN8fCh0aGlzLl9pbnM9bmV3IEJsKSx0aGlzLl9pbnN9YXR0YWNoZWQoaSxlKXt0aGlzLnJlZmVyZW5jZXx8KHRoaXMucmVmZXJlbmNlPW5ldyBNYXApO2xldCB0PXRoaXMucmVmZXJlbmNlLmdldChpKTt0fHwodD1uZXcgTWFwKSx0LnNldChlLGkpLHRoaXMucmVmZXJlbmNlLnNldChpLHQpfWRldGFjaGVkKGksZSl7bGV0IHQ9dGhpcy5yZWZlcmVuY2UuZ2V0KGkpO3QmJnQuZGVsZXRlKGUpfWhhc1JlZmVyZW5jZShpKXtsZXQgZT10aGlzLnJlZmVyZW5jZS5nZXQoaSk7cmV0dXJuIGU/ZS5zaXplPjA6ITF9Z2V0UmVmZXJlbmNlQ291bnQoaSl7bGV0IGU9dGhpcy5yZWZlcmVuY2UuZ2V0KGkpO3JldHVybiBlP2Uuc2l6ZTowfWdldFJlZmVyZW5jZShpKXtsZXQgZT10aGlzLnJlZmVyZW5jZS5nZXQoaSk7cmV0dXJuIGV8fG51bGx9fTtsZXQgc2U9Qmw7byhzZSxcIl9pbnNcIik7Y29uc3QgZmk9Y2xhc3N7c3RhdGljIGdldE1pcG1hcFBpcGVsaW5lKGkpe2xldCBlPWkuZm9ybWF0LHQ9Uy5kZXZpY2Uscj1maS5waXBlbGluZUNhY2hlW2kuZm9ybWF0XSxzO2lmKCFyKXtzPXQuY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmZpLm1pcG1hcFNoYWRlcn0pO2xldCBhPXQuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtlbnRyaWVzOlt7YmluZGluZzowLHZpc2liaWxpdHk6aS52aXNpYmlsaXR5LHNhbXBsZXI6aS5zYW1wbGVyQmluZGluZ0xheW91dH0se2JpbmRpbmc6MSx2aXNpYmlsaXR5OmkudmlzaWJpbGl0eSx0ZXh0dXJlOmkudGV4dHVyZUJpbmRpbmdMYXlvdXR9XX0pLG49Uy5kZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoe2JpbmRHcm91cExheW91dHM6W2FdfSk7cj13LmNyZWF0ZVBpcGVsaW5lKHtsYXlvdXQ6bix2ZXJ0ZXg6e21vZHVsZTpzLGVudHJ5UG9pbnQ6XCJ2ZXJ0ZXhNYWluXCJ9LGZyYWdtZW50Onttb2R1bGU6cyxlbnRyeVBvaW50OlwiZnJhZ21lbnRNYWluXCIsdGFyZ2V0czpbe2Zvcm1hdDplfV19fSksZmkucGlwZWxpbmVDYWNoZVtlXT1yfXJldHVybiByfXN0YXRpYyB3ZWJHUFVHZW5lcmF0ZU1pcG1hcChpKXtsZXQgZT1TLmRldmljZSx0PWkudGV4dHVyZURlc2NyaXB0b3I7aWYoIWZpLnBpcGVsaW5lKXtjb25zdCBuPWUuY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmBcbiAgICAgICAgdmFyPHByaXZhdGU+IHBvcyA6IGFycmF5PHZlYzI8ZjMyPiwgND4gPSBhcnJheTx2ZWMyPGYzMj4sIDQ+KFxuICAgICAgICAgIHZlYzI8ZjMyPigtMS4wLCAxLjApLCB2ZWMyPGYzMj4oMS4wLCAxLjApLFxuICAgICAgICAgIHZlYzI8ZjMyPigtMS4wLCAtMS4wKSwgdmVjMjxmMzI+KDEuMCwgLTEuMCkpO1xuXG4gICAgICAgIHN0cnVjdCBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbiA6IHZlYzQ8ZjMyPixcbiAgICAgICAgICBAbG9jYXRpb24oMCkgdGV4Q29vcmQgOiB2ZWMyPGYzMj5cbiAgICAgICAgfTtcblxuICAgICAgICBAdmVydGV4XG4gICAgICAgIGZuIHZlcnRleE1haW4oQGJ1aWx0aW4odmVydGV4X2luZGV4KSB2ZXJ0ZXhJbmRleCA6IHUzMikgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICB2YXIgb3V0cHV0IDogVmVydGV4T3V0cHV0O1xuICAgICAgICAgIG91dHB1dC50ZXhDb29yZCA9IHBvc1t2ZXJ0ZXhJbmRleF0gKiB2ZWMyPGYzMj4oMC41LCAtMC41KSArIHZlYzI8ZjMyPigwLjUpO1xuICAgICAgICAgIG91dHB1dC5wb3NpdGlvbiA9IHZlYzQ8ZjMyPihwb3NbdmVydGV4SW5kZXhdLCAwLjAsIDEuMCk7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIEBiaW5kaW5nKDApIEBncm91cCgwKSB2YXIgaW1nU2FtcGxlciA6IHNhbXBsZXI7XG4gICAgICAgIEBiaW5kaW5nKDEpIEBncm91cCgwKSB2YXIgaW1nIDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgICAgIEBmcmFnbWVudFxuICAgICAgICBmbiBmcmFnbWVudE1haW4oQGxvY2F0aW9uKDApIHRleENvb3JkIDogdmVjMjxmMzI+KSAtPiBAbG9jYXRpb24oMCkgdmVjNDxmMzI+IHtcbiAgICAgICAgICB2YXIgb3V0Q29sb3I6IHZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGUoaW1nLCBpbWdTYW1wbGVyLCB0ZXhDb29yZCk7XG4gICAgICAgICAgcmV0dXJuIG91dENvbG9yO1xuICAgICAgICB9XG4gICAgICBgfSk7ZmkucGlwZWxpbmU9ZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh7bGF5b3V0OlwiYXV0b1wiLHZlcnRleDp7bW9kdWxlOm4sZW50cnlQb2ludDpcInZlcnRleE1haW5cIn0sZnJhZ21lbnQ6e21vZHVsZTpuLGVudHJ5UG9pbnQ6XCJmcmFnbWVudE1haW5cIix0YXJnZXRzOlt7Zm9ybWF0OnQuZm9ybWF0fV19LHByaW1pdGl2ZTp7dG9wb2xvZ3k6XCJ0cmlhbmdsZS1zdHJpcFwiLHN0cmlwSW5kZXhGb3JtYXQ6XCJ1aW50MzJcIn19KX1sZXQgcjtpLmZvcm1hdD09XCJyZ2JhMTZmbG9hdFwiP3I9ZS5jcmVhdGVTYW1wbGVyKHttaW5GaWx0ZXI6XCJuZWFyZXN0XCIsbWFnRmlsdGVyOlwibGluZWFyXCJ9KTpyPWUuY3JlYXRlU2FtcGxlcih7bWluRmlsdGVyOlwibGluZWFyXCIsbWFnRmlsdGVyOlwibGluZWFyXCJ9KTtsZXQgcz1pLmdldEdQVVRleHR1cmUoKS5jcmVhdGVWaWV3KHtiYXNlTWlwTGV2ZWw6MCxtaXBMZXZlbENvdW50OjF9KTtjb25zdCBhPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO2ZvcihsZXQgbj0xO248dC5taXBMZXZlbENvdW50Oysrbil7Y29uc3QgbD1pLmdldEdQVVRleHR1cmUoKS5jcmVhdGVWaWV3KHtiYXNlTWlwTGV2ZWw6bixtaXBMZXZlbENvdW50OjF9KSxoPWEuYmVnaW5SZW5kZXJQYXNzKHtjb2xvckF0dGFjaG1lbnRzOlt7dmlldzpsLGNsZWFyVmFsdWU6WzAsMCwwLDBdLGxvYWRPcDpcImNsZWFyXCIsc3RvcmVPcDpcInN0b3JlXCJ9XX0pLHU9ZS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDpmaS5waXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczpbe2JpbmRpbmc6MCxyZXNvdXJjZTpyfSx7YmluZGluZzoxLHJlc291cmNlOnN9XX0pO2guc2V0UGlwZWxpbmUoZmkucGlwZWxpbmUpLGguc2V0QmluZEdyb3VwKDAsdSksaC5kcmF3KDQpLGguZW5kKCkscz1sfXcuZW5kQ29tbWFuZEVuY29kZXIoYSl9fTtsZXQgSHQ9Zmk7byhIdCxcIm1pcG1hcFNoYWRlclwiLGBcbiAgICB2YXI8cHJpdmF0ZT4gcG9zIDogYXJyYXk8dmVjMjxmMzI+LCAzPiA9IGFycmF5PHZlYzI8ZjMyPiwgMz4oXG4gICAgICAgIHZlYzI8ZjMyPigtMS4wLCAtMS4wKSwgdmVjMjxmMzI+KC0xLjAsIDMuMCksIHZlYzI8ZjMyPigzLjAsIC0xLjApKTtcbiAgICAgIHN0cnVjdCBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICBAYnVpbHRpbihwb3NpdGlvbikgcG9zaXRpb24gOiB2ZWM0PGYzMj47XG4gICAgICAgIEBsb2NhdGlvbigwKSB0ZXhDb29yZCA6IHZlYzI8ZjMyPjtcbiAgICAgIH07XG4gICAgICBAdmVydGV4XG4gICAgICBmbiB2ZXJ0ZXhNYWluKEBidWlsdGluKHZlcnRleF9pbmRleCkgdmVydGV4SW5kZXggOiB1MzIpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgIHZhciBvdXRwdXQgOiBWZXJ0ZXhPdXRwdXQ7XG4gICAgICAgIG91dHB1dC50ZXhDb29yZCA9IHBvc1t2ZXJ0ZXhJbmRleF0gKiB2ZWMyPGYzMj4oMC41LCAtMC41KSArIHZlYzI8ZjMyPigwLjUpO1xuICAgICAgICBvdXRwdXQucG9zaXRpb24gPSB2ZWM0PGYzMj4ocG9zW3ZlcnRleEluZGV4XSwgMC4wLCAxLjApO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgICAgQGJpbmRpbmcoMCkgQGdyb3VwKDApIHZhciBpbWdTYW1wbGVyIDogc2FtcGxlcjtcbiAgICAgIEBiaW5kaW5nKDEpIEBncm91cCgwKSB2YXIgaW1nIDogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgQGZyYWdtZW50XG4gICAgICBmbiBmcmFnbWVudE1haW4oQGxvY2F0aW9uKDApIHRleENvb3JkIDogdmVjMjxmMzI+KSAtPiBAbG9jYXRpb24oMCkgdmVjNDxmMzI+IHtcbiAgICAgICAgdmFyIG91dENvbG9yOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlKGltZywgaW1nU2FtcGxlciwgdGV4Q29vcmQpO1xuICAgICAgICByZXR1cm4gb3V0Q29sb3IgO1xuICAgICAgfWApLG8oSHQsXCJwaXBlbGluZUNhY2hlXCIse30pLG8oSHQsXCJwaXBlbGluZVwiKTtjbGFzcyBhdHtjb25zdHJ1Y3RvcihlPTMyLHQ9MzIscj0xKXtvKHRoaXMsXCJuYW1lXCIpLG8odGhpcyxcInVybFwiKSxvKHRoaXMsXCJncHVUZXh0dXJlXCIpLG8odGhpcyxcInBpZFwiKSxvKHRoaXMsXCJ2aWV3XCIpLG8odGhpcyxcImdwdVNhbXBsZXJcIiksbyh0aGlzLFwiZ3B1U2FtcGxlcl9jb21wYXJpc29uXCIpLG8odGhpcyxcImZvcm1hdFwiKSxvKHRoaXMsXCJ1c2FnZVwiKSxvKHRoaXMsXCJ3aWR0aFwiLDQpLG8odGhpcyxcImhlaWdodFwiLDQpLG8odGhpcyxcImRlcHRoT3JBcnJheUxheWVyc1wiLDEpLG8odGhpcyxcIm51bWJlckxheWVyXCIsMSksbyh0aGlzLFwidmlld0Rlc2NyaXB0b3JcIiksbyh0aGlzLFwidGV4dHVyZURlc2NyaXB0b3JcIiksbyh0aGlzLFwidmlzaWJpbGl0eVwiLEdQVVNoYWRlclN0YWdlLkNPTVBVVEV8R1BVU2hhZGVyU3RhZ2UuVkVSVEVYfEdQVVNoYWRlclN0YWdlLkZSQUdNRU5UKSxvKHRoaXMsXCJ0ZXh0dXJlQmluZGluZ0xheW91dFwiLHt2aWV3RGltZW5zaW9uOlwiMmRcIixtdWx0aXNhbXBsZWQ6ITF9KSxvKHRoaXMsXCJzYW1wbGVyQmluZGluZ0xheW91dFwiLHt0eXBlOlwiZmlsdGVyaW5nXCJ9KSxvKHRoaXMsXCJzYW1wbGVyX2NvbXBhcmlzb25CaW5kaW5nTGF5b3V0XCIse3R5cGU6XCJjb21wYXJpc29uXCJ9KSxvKHRoaXMsXCJmbGlwWVwiKSxvKHRoaXMsXCJpc1ZpZGVvVGV4dHVyZVwiKSxvKHRoaXMsXCJpc0hEUlRleHR1cmVcIiksbyh0aGlzLFwiX3VzZU1pcG1hcFwiLCExKSxvKHRoaXMsXCJfc291cmNlSW1hZ2VEYXRhXCIpLG8odGhpcyxcIl9hZGRyZXNzTW9kZVVcIiksbyh0aGlzLFwiX2FkZHJlc3NNb2RlVlwiKSxvKHRoaXMsXCJfYWRkcmVzc01vZGVXXCIpLG8odGhpcyxcIl9tYWdGaWx0ZXJcIiksbyh0aGlzLFwiX21pbkZpbHRlclwiKSxvKHRoaXMsXCJfbWlwbWFwRmlsdGVyXCIpLG8odGhpcyxcIl9sb2RNaW5DbGFtcFwiKSxvKHRoaXMsXCJfbG9kTWF4Q2xhbXBcIiksbyh0aGlzLFwiX2NvbXBhcmVcIiksbyh0aGlzLFwiX21heEFuaXNvdHJvcHlcIiksbyh0aGlzLFwibWlwbWFwQ291bnRcIiwxKSxvKHRoaXMsXCJfdGV4dHVyZUNoYW5nZVwiLCExKSxvKHRoaXMsXCJfc3RhdGVDaGFuZ2VSZWZcIixuZXcgTWFwKSx0aGlzLndpZHRoPWUsdGhpcy5oZWlnaHQ9dCx0aGlzLm51bWJlckxheWVyPXIsdGhpcy5taW5GaWx0ZXI9XCJsaW5lYXJcIix0aGlzLm1hZ0ZpbHRlcj1cImxpbmVhclwiLHRoaXMubWlwbWFwRmlsdGVyPVwibGluZWFyXCIsdGhpcy5hZGRyZXNzTW9kZVU9QnQucmVwZWF0LHRoaXMuYWRkcmVzc01vZGVWPUJ0LnJlcGVhdH1pbml0KCl7bGV0IGU9dGhpcztyZXR1cm4gZS5pbnRlcm5hbENyZWF0ZUJpbmRpbmdMYXlvdXREZXNjJiZlLmludGVybmFsQ3JlYXRlQmluZGluZ0xheW91dERlc2MoKSxlLmludGVybmFsQ3JlYXRlVGV4dHVyZSYmZS5pbnRlcm5hbENyZWF0ZVRleHR1cmUoKSxlLmludGVybmFsQ3JlYXRlVmlldyYmZS5pbnRlcm5hbENyZWF0ZVZpZXcoKSxlLmludGVybmFsQ3JlYXRlU2FtcGxlciYmZS5pbnRlcm5hbENyZWF0ZVNhbXBsZXIoKSx0aGlzfWNyZWF0ZVRleHR1cmVEZXNjcmlwdG9yKGUsdCxyLHMsYT1HUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HfEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVHxHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkN8R1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UfEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkcsbj0xLGw9MCl7dGhpcy53aWR0aD1lLHRoaXMuaGVpZ2h0PXQsdGhpcy5mb3JtYXQ9cyx0aGlzLnVzYWdlPWEsdGhpcy50ZXh0dXJlRGVzY3JpcHRvcj17c2l6ZTpbZSx0LG5dLG1pcExldmVsQ291bnQ6cixmb3JtYXQ6cyx1c2FnZTphLGxhYmVsOmAke3RoaXMubmFtZSt0aGlzLndpZHRoK3RoaXMuaGVpZ2h0K3RoaXMuZm9ybWF0fWB9LGw+MCYmKHRoaXMudGV4dHVyZURlc2NyaXB0b3Iuc2FtcGxlQ291bnQ9bCksbj4xP3RoaXMudmlld0Rlc2NyaXB0b3I9e2RpbWVuc2lvbjpcIjJkLWFycmF5XCJ9OnRoaXMudmlld0Rlc2NyaXB0b3I9e2RpbWVuc2lvbjp0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnZpZXdEaW1lbnNpb259fWdlbmVyYXRlKGUpe2xldCB0PTMyLHI9MzI7XCJ3aWR0aFwiaW4gZSYmKHQ9ZS53aWR0aCxyPWUuaGVpZ2h0KSwodDwzMnx8cjwzMikmJmNvbnNvbGUubG9nKGUubmFtZStcIlNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMzIhXCIpLHRoaXMud2lkdGg9dCx0aGlzLmhlaWdodD1yLHRoaXMuY3JlYXRlVGV4dHVyZShlKX1jcmVhdGVUZXh0dXJlKGUpe3RoaXMuX3NvdXJjZUltYWdlRGF0YT1lLHRoaXMudXBkYXRlVGV4dHVyZURlc2NyaXB0aW9uKCksdGhpcy51cGRhdGVHUFVUZXh0dXJlKCk7bGV0IHQ9Uy5kZXZpY2U7dGhpcy5ncHVUZXh0dXJlIGluc3RhbmNlb2YgR1BVVGV4dHVyZSYmdC5xdWV1ZS5jb3B5RXh0ZXJuYWxJbWFnZVRvVGV4dHVyZSh7c291cmNlOnRoaXMuX3NvdXJjZUltYWdlRGF0YX0se3RleHR1cmU6dGhpcy5ncHVUZXh0dXJlfSxbdGhpcy53aWR0aCx0aGlzLmhlaWdodF0pLHRoaXMudXNlTWlwbWFwJiZIdC53ZWJHUFVHZW5lcmF0ZU1pcG1hcCh0aGlzKX1nZXQgdXNlTWlwbWFwKCl7cmV0dXJuIHRoaXMuX3VzZU1pcG1hcH1zZXQgdXNlTWlwbWFwKGUpe2lmKGUpe2lmKHRoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cImZpbHRlcmluZ1wiLHRoaXMuX3VzZU1pcG1hcD09ITEmJnRoaXMuX3NvdXJjZUltYWdlRGF0YSl7dGhpcy5fdXNlTWlwbWFwPSEwLHRoaXMudXBkYXRlVGV4dHVyZURlc2NyaXB0aW9uKCksdGhpcy51cGRhdGVHUFVUZXh0dXJlKCk7bGV0IHQ9Uy5kZXZpY2U7dGhpcy5ncHVUZXh0dXJlIGluc3RhbmNlb2YgR1BVVGV4dHVyZSYmdC5xdWV1ZS5jb3B5RXh0ZXJuYWxJbWFnZVRvVGV4dHVyZSh7c291cmNlOnRoaXMuX3NvdXJjZUltYWdlRGF0YX0se3RleHR1cmU6dGhpcy5ncHVUZXh0dXJlfSxbdGhpcy53aWR0aCx0aGlzLmhlaWdodF0pLEh0LndlYkdQVUdlbmVyYXRlTWlwbWFwKHRoaXMpfX1lbHNlIGlmKHRoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cIm5vbi1maWx0ZXJpbmdcIix0aGlzLl91c2VNaXBtYXA9PSEwJiZ0aGlzLl9zb3VyY2VJbWFnZURhdGEpe3RoaXMuX3VzZU1pcG1hcD0hMSx0aGlzLnVwZGF0ZVRleHR1cmVEZXNjcmlwdGlvbigpLHRoaXMudXBkYXRlR1BVVGV4dHVyZSgpO2xldCB0PVMuZGV2aWNlO3RoaXMuZ3B1VGV4dHVyZSBpbnN0YW5jZW9mIEdQVVRleHR1cmUmJnQucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoe3NvdXJjZTp0aGlzLl9zb3VyY2VJbWFnZURhdGF9LHt0ZXh0dXJlOnRoaXMuZ3B1VGV4dHVyZX0sW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdKX10aGlzLl90ZXh0dXJlQ2hhbmdlPSEwLHRoaXMuX3VzZU1pcG1hcD1lLHRoaXMubm90aWNlQ2hhbmdlKCl9Z2V0IHNvdXJjZUltYWdlRGF0YSgpe3JldHVybiB0aGlzLl9zb3VyY2VJbWFnZURhdGF9dXBkYXRlVGV4dHVyZURlc2NyaXB0aW9uKCl7dGhpcy5taXBtYXBDb3VudD1NYXRoLmZsb29yKHRoaXMudXNlTWlwbWFwP01hdGgubG9nMihNYXRoLm1pbih0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSk6MSksdGhpcy5jcmVhdGVUZXh0dXJlRGVzY3JpcHRvcih0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHRoaXMubWlwbWFwQ291bnQsdGhpcy5mb3JtYXQpfXVwZGF0ZUdQVVRleHR1cmUoKXt0aGlzLmdwdVRleHR1cmUmJnRoaXMuZ3B1VGV4dHVyZSBpbnN0YW5jZW9mIEdQVVRleHR1cmUmJnRoaXMuZ3B1VGV4dHVyZS5kZXN0cm95KCksdGhpcy5ncHVUZXh0dXJlPW51bGwsdGhpcy52aWV3PW51bGwsdGhpcy5ncHVUZXh0dXJlPXRoaXMuZ2V0R1BVVGV4dHVyZSgpfWdldEdQVVRleHR1cmUoKXtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlfHwodGhpcy5ncHVUZXh0dXJlPVMuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGhpcy50ZXh0dXJlRGVzY3JpcHRvcikpLHRoaXMuZ3B1VGV4dHVyZX1nZXRHUFVWaWV3KGU9MCl7cmV0dXJuIHRoaXMudmlld3x8KHRoaXMuZ3B1VGV4dHVyZT10aGlzLmdldEdQVVRleHR1cmUoKSx0aGlzLmdwdVRleHR1cmUgaW5zdGFuY2VvZiBHUFVUZXh0dXJlJiYodGhpcy52aWV3PXRoaXMuZ3B1VGV4dHVyZS5jcmVhdGVWaWV3KHRoaXMudmlld0Rlc2NyaXB0b3IpLHRoaXMudmlldy5sYWJlbD10aGlzLm5hbWUpKSx0aGlzLnZpZXd9YmluZFN0YXRlQ2hhbmdlKGUsdCl7dGhpcy5fc3RhdGVDaGFuZ2VSZWYuc2V0KHQsZSl9dW5CaW5kU3RhdGVDaGFuZ2UoZSl7dGhpcy5fc3RhdGVDaGFuZ2VSZWYuZGVsZXRlKGUpfW5vdGljZUNoYW5nZSgpe3RoaXMuZ3B1U2FtcGxlcj1TLmRldmljZS5jcmVhdGVTYW1wbGVyKHRoaXMpLHRoaXMuX3N0YXRlQ2hhbmdlUmVmLmZvckVhY2goKGUsdCk9PntlKCl9KX1kZXN0cm95KGUpe2UmJnRoaXMuZ3B1VGV4dHVyZSBpbnN0YW5jZW9mIEdQVVRleHR1cmUmJih0aGlzLmdwdVNhbXBsZXI9bnVsbCx0aGlzLmdwdVNhbXBsZXJfY29tcGFyaXNvbj1udWxsLHRoaXMudGV4dHVyZUJpbmRpbmdMYXlvdXQ9bnVsbCx0aGlzLnRleHR1cmVEZXNjcmlwdG9yPW51bGwsdGhpcy5ncHVUZXh0dXJlLmRlc3Ryb3koKSx0aGlzLmdwdVRleHR1cmU9bnVsbCksdGhpcy5fc3RhdGVDaGFuZ2VSZWYuY2xlYXIoKX1nZXQgYWRkcmVzc01vZGVVKCl7cmV0dXJuIHRoaXMuX2FkZHJlc3NNb2RlVX1zZXQgYWRkcmVzc01vZGVVKGUpe3RoaXMuX2FkZHJlc3NNb2RlVSE9ZSYmKHRoaXMuX2FkZHJlc3NNb2RlVT1lLHRoaXMubm90aWNlQ2hhbmdlKCkpfWdldCBhZGRyZXNzTW9kZVYoKXtyZXR1cm4gdGhpcy5fYWRkcmVzc01vZGVWfXNldCBhZGRyZXNzTW9kZVYoZSl7dGhpcy5fYWRkcmVzc01vZGVWIT1lJiYodGhpcy5fYWRkcmVzc01vZGVWPWUsdGhpcy5ub3RpY2VDaGFuZ2UoKSl9Z2V0IGFkZHJlc3NNb2RlVygpe3JldHVybiB0aGlzLl9hZGRyZXNzTW9kZVd9c2V0IGFkZHJlc3NNb2RlVyhlKXt0aGlzLl9hZGRyZXNzTW9kZVchPWUmJih0aGlzLl9hZGRyZXNzTW9kZVc9ZSx0aGlzLm5vdGljZUNoYW5nZSgpKX1nZXQgbWFnRmlsdGVyKCl7cmV0dXJuIHRoaXMuX21hZ0ZpbHRlcn1zZXQgbWFnRmlsdGVyKGUpe3RoaXMuX21hZ0ZpbHRlciE9ZSYmKHRoaXMuX21hZ0ZpbHRlcj1lLHRoaXMubm90aWNlQ2hhbmdlKCkpfWdldCBtaW5GaWx0ZXIoKXtyZXR1cm4gdGhpcy5fbWluRmlsdGVyfXNldCBtaW5GaWx0ZXIoZSl7dGhpcy5fbWluRmlsdGVyIT1lJiYodGhpcy5fbWluRmlsdGVyPWUsdGhpcy5ub3RpY2VDaGFuZ2UoKSl9Z2V0IG1pcG1hcEZpbHRlcigpe3JldHVybiB0aGlzLl9taXBtYXBGaWx0ZXJ9c2V0IG1pcG1hcEZpbHRlcihlKXt0aGlzLl9taXBtYXBGaWx0ZXIhPWUmJih0aGlzLl9taXBtYXBGaWx0ZXI9ZSx0aGlzLm5vdGljZUNoYW5nZSgpKX1nZXQgbG9kTWluQ2xhbXAoKXtyZXR1cm4gdGhpcy5fbG9kTWluQ2xhbXB9c2V0IGxvZE1pbkNsYW1wKGUpe3RoaXMuX2xvZE1pbkNsYW1wIT1lJiYodGhpcy5fbG9kTWluQ2xhbXA9ZSx0aGlzLm5vdGljZUNoYW5nZSgpKX1nZXQgbG9kTWF4Q2xhbXAoKXtyZXR1cm4gdGhpcy5fbG9kTWF4Q2xhbXB9c2V0IGxvZE1heENsYW1wKGUpe3RoaXMuX2xvZE1heENsYW1wIT1lJiYodGhpcy5fbG9kTWF4Q2xhbXA9ZSx0aGlzLm5vdGljZUNoYW5nZSgpKX1nZXQgY29tcGFyZSgpe3JldHVybiB0aGlzLl9jb21wYXJlfXNldCBjb21wYXJlKGUpe3RoaXMuX2NvbXBhcmUhPWUmJih0aGlzLl9jb21wYXJlPWUsdGhpcy5ub3RpY2VDaGFuZ2UoKSl9Z2V0IG1heEFuaXNvdHJvcHkoKXtyZXR1cm4gdGhpcy5fbWF4QW5pc290cm9weX1zZXQgbWF4QW5pc290cm9weShlKXt0aGlzLl9tYXhBbmlzb3Ryb3B5IT1lJiYodGhpcy5fbWF4QW5pc290cm9weT1lLHRoaXMubm90aWNlQ2hhbmdlKCkpfX1jbGFzcyBUbCBleHRlbmRzIGF0e2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcihlLHQsciksbyh0aGlzLFwiX2JpdG1hcFRleHR1cmVzXCIpLHRoaXMuZm9ybWF0PUcucmdiYTh1bm9ybSx0aGlzLm1pcG1hcENvdW50PTEsdGhpcy5fYml0bWFwVGV4dHVyZXM9W10sdGhpcy5pbml0KCl9c2V0VGV4dHVyZXMoZSl7dGhpcy5fYml0bWFwVGV4dHVyZXMubGVuZ3RoPTA7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9ZVt0XTt0aGlzLmFkZFRleHR1cmUocil9fWFkZFRleHR1cmUoZSl7KGUud2lkdGghPXRoaXMud2lkdGh8fGUuaGVpZ2h0IT10aGlzLmhlaWdodCkmJmNvbnNvbGUuZXJyb3IoXCJiaXRtYXAgdGV4dHVyZSBtdXNlIG1hdGNoIGJpdG1hcFRleHR1cmVBcnJheSBzaXplIVwiKSx0aGlzLl9iaXRtYXBUZXh0dXJlcy5pbmRleE9mKGUpPT0tMSYmKGUucGlkPXRoaXMuX2JpdG1hcFRleHR1cmVzLmxlbmd0aCx0aGlzLl9iaXRtYXBUZXh0dXJlcy5wdXNoKGUpLHRoaXMudXBkYXRlVGV4dHVyZSgpKX1yZW1vdmVUZXh0dXJlKGUpe2xldCB0PXRoaXMuX2JpdG1hcFRleHR1cmVzLmluZGV4T2YoZSk7aWYodCE9LTEpe3RoaXMuX2JpdG1hcFRleHR1cmVzLnNwbGljZSh0LDEpO2ZvcihsZXQgcj0wO3I8dGhpcy5fYml0bWFwVGV4dHVyZXMubGVuZ3RoO3IrKyl7Y29uc3Qgcz10aGlzLl9iaXRtYXBUZXh0dXJlc1tyXTtzLnBpZD1yfX19dXBkYXRlVGV4dHVyZSgpe2xldCBlPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fYml0bWFwVGV4dHVyZXMubGVuZ3RoO3QrKyl7bGV0IHI9dGhpcy5fYml0bWFwVGV4dHVyZXNbdF07ZS5jb3B5VGV4dHVyZVRvVGV4dHVyZSh7dGV4dHVyZTpyLmdldEdQVVRleHR1cmUoKSxtaXBMZXZlbDowLG9yaWdpbjp7eDowLHk6MCx6OjB9fSx7dGV4dHVyZTp0aGlzLmdldEdQVVRleHR1cmUoKSxtaXBMZXZlbDowLG9yaWdpbjp7eDowLHk6MCx6OnR9fSx7d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHQsZGVwdGhPckFycmF5TGF5ZXJzOjF9KX13LmVuZENvbW1hbmRFbmNvZGVyKGUpfWludGVybmFsQ3JlYXRlQmluZGluZ0xheW91dERlc2MoKXt0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnZpZXdEaW1lbnNpb249XCIyZC1hcnJheVwiLHRoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cImZpbHRlcmluZ1wiLHRoaXMubWluRmlsdGVyPU5yLmxpbmVhcix0aGlzLm1hZ0ZpbHRlcj1Oci5saW5lYXJ9aW50ZXJuYWxDcmVhdGVUZXh0dXJlKCl7dGhpcy50ZXh0dXJlRGVzY3JpcHRvcj17Zm9ybWF0OnRoaXMuZm9ybWF0LHNpemU6e3dpZHRoOnRoaXMud2lkdGgsaGVpZ2h0OnRoaXMuaGVpZ2h0LGRlcHRoT3JBcnJheUxheWVyczp0aGlzLm51bWJlckxheWVyfSxkaW1lbnNpb246XCIyZFwiLHVzYWdlOkdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVHxHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HfSx0aGlzLmdwdVRleHR1cmU9Uy5kZXZpY2UuY3JlYXRlVGV4dHVyZSh0aGlzLnRleHR1cmVEZXNjcmlwdG9yKX1pbnRlcm5hbENyZWF0ZVZpZXcoKXt0aGlzLnZpZXdEZXNjcmlwdG9yPXtkaW1lbnNpb246XCIyZC1hcnJheVwifSx0aGlzLnZpZXc9dGhpcy5ncHVUZXh0dXJlLmNyZWF0ZVZpZXcodGhpcy52aWV3RGVzY3JpcHRvcil9aW50ZXJuYWxDcmVhdGVTYW1wbGVyKCl7dGhpcy5ncHVTYW1wbGVyPVMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIodGhpcyl9fWNvbnN0IEVpPWNsYXNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX2llc1RleHR1cmVcIiksbyh0aGlzLFwiaW5kZXhcIiwwKX1nZW5lcmF0ZUlFUyhpKXt9c2V0IElFU1RleHR1cmUoaSl7dGhpcy5faWVzVGV4dHVyZT1pLGkuYWRkcmVzc01vZGVVPUJ0LnJlcGVhdCxpLmFkZHJlc3NNb2RlVj1CdC5yZXBlYXQsaS5hZGRyZXNzTW9kZVc9QnQucmVwZWF0LEVpLmllc19saXN0LmluZGV4T2YodGhpcyk9PS0xJiYodGhpcy5pbmRleD1FaS5pZXNfbGlzdC5sZW5ndGgsRWkuaWVzX2xpc3QucHVzaCh0aGlzKSxFaS5pZXNUZXh0dXJlfHxFaS5jcmVhdGUoaS53aWR0aCxpLmhlaWdodCksRWkuaWVzVGV4dHVyZS5hZGRUZXh0dXJlKGkpKX1nZXQgSUVTVGV4dHVyZSgpe3JldHVybiB0aGlzLl9pZXNUZXh0dXJlfXN0YXRpYyBjcmVhdGUoaSxlKXtsZXQgdD00ODt0aGlzLmllc1RleHR1cmU9bmV3IFRsKGksZSx0KX19O2xldCBCaT1FaTtvKEJpLFwidXNlXCIsITEpLG8oQmksXCJpZXNUZXh0dXJlXCIpLG8oQmksXCJpZXNfbGlzdFwiLFtdKTtjbGFzcyBNbHtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJyZW5kZXJlclwiKSxvKHRoaXMsXCJvd25lclwiKSxvKHRoaXMsXCJ1dWlkXCIpLHRoaXMucmVuZGVyZXI9ZSx0aGlzLnV1aWQ9ZS5vYmplY3QzRC5pbnN0YW5jZUlEfWxlYXZlTm9kZSgpe3RoaXMub3duZXImJih0aGlzLm93bmVyLmVudGl0aWVzLmRlbGV0ZSh0aGlzLnV1aWQpLHRoaXMub3duZXI9bnVsbCl9ZW50ZXJOb2RlKGUpe3RoaXMub3duZXImJnRoaXMubGVhdmVOb2RlKCksdGhpcy5vd25lcj1lLGUuZW50aXRpZXMuc2V0KHRoaXMudXVpZCx0aGlzKX11cGRhdGUoZSl7dmFyIHQ7cmV0dXJuKCh0PXRoaXMub3duZXIpPT1udWxsP3ZvaWQgMDp0LnRyeUluc2VydEVudGl0eSh0aGlzKSl8fCh0aGlzLmxlYXZlTm9kZSgpLGUudHJ5SW5zZXJ0RW50aXR5KHRoaXMpKSx0aGlzLm93bmVyfX12YXIgSGQ9T2JqZWN0LmRlZmluZVByb3BlcnR5LFlkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsV3I9KGksZSx0LHIpPT57Zm9yKHZhciBzPXI+MT92b2lkIDA6cj9ZZChlLHQpOmUsYT1pLmxlbmd0aC0xLG47YT49MDthLS0pKG49aVthXSkmJihzPShyP24oZSx0LHMpOm4ocykpfHxzKTtyZXR1cm4gciYmcyYmSGQoZSx0LHMpLHN9O2NsYXNzICR0IGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcImluc3RhbmNlQ291bnRcIiwwKSxvKHRoaXMsXCJsb2RMZXZlbFwiLDApLG8odGhpcyxcImFsd2F5c1JlbmRlclwiLCExKSxvKHRoaXMsXCJpbnN0YW5jZUlEXCIpLG8odGhpcyxcImRyYXdUeXBlXCIsMCksbyh0aGlzLFwiX2dlb21ldHJ5XCIpLG8odGhpcyxcIl9tYXRlcmlhbHNcIixbXSksbyh0aGlzLFwiX2Nhc3RTaGFkb3dcIiwhMCksbyh0aGlzLFwiX2Nhc3RSZWZsZWN0aW9uXCIsITEpLG8odGhpcyxcIl9jYXN0R0lcIiwhMSksbyh0aGlzLFwiX3JlbmRlcmVyTWFza1wiLFVlLkRlZmF1bHQpLG8odGhpcyxcIl9pblJlbmRlcmVyXCIsITEpLG8odGhpcyxcIl9yZWFkeVBpcGVsaW5lXCIsITEpLG8odGhpcyxcIl9jb21iaW5lU2hhZGVyUmVmZWN0aW9uXCIpLG8odGhpcyxcIl9pZ25vcmVFbnZNYXBcIiksbyh0aGlzLFwiX2lnbm9yZVByZWZpbHRlck1hcFwiKSxvKHRoaXMsXCJfX3JlbmRlck9yZGVyXCIsMCksbyh0aGlzLFwiX3JlbmRlck9yZGVyXCIsMCksbyh0aGlzLFwiaXNSZW5kZXJPcmRlckNoYW5nZVwiKSxvKHRoaXMsXCJuZWVkU29ydE9uQ2FtZXJhWlwiKSxvKHRoaXMsXCJfb2N0cmVlQmluZGVyXCIpLG8odGhpcyxcInByZUluaXRcIiwhMSksbyh0aGlzLFwiX3JlbmRlckxheWVyXCIsWXIuTm9uZSl9aW5pdCgpe3RoaXMucmVuZGVyT3JkZXI9MCx0aGlzLnJlbmRlcmVyTWFzaz1VZS5EZWZhdWx0LHRoaXMuaW5zdGFuY2VJRD1xYSgpLnRvU3RyaW5nKCl9YXR0YWNoU2NlbmVPY3RyZWUoZSl7dGhpcy5fb2N0cmVlQmluZGVyPXtvY3RyZWU6ZSxlbnRpdHk6bmV3IE1sKHRoaXMpfSx0aGlzLnRyYW5zZm9ybS5ldmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcihPZS5MT0NBTF9PTkNIQU5HRSx0aGlzLnVwZGF0ZU9jdHJlZUVudGl0eSx0aGlzKX1kZXRhY2hTY2VuZU9jdHJlZSgpe3ZhciBlO3RoaXMuX29jdHJlZUJpbmRlciYmKChlPXRoaXMuX29jdHJlZUJpbmRlci5lbnRpdHkpPT1udWxsfHxlLmxlYXZlTm9kZSgpLHRoaXMudHJhbnNmb3JtLmV2ZW50RGlzcGF0Y2hlci5yZW1vdmVFdmVudExpc3RlbmVyKE9lLkxPQ0FMX09OQ0hBTkdFLHRoaXMudXBkYXRlT2N0cmVlRW50aXR5LHRoaXMpLHRoaXMuX29jdHJlZUJpbmRlcj1udWxsKX11cGRhdGVPY3RyZWVFbnRpdHkoZSl7dmFyIHQscjsocj0odD10aGlzLl9vY3RyZWVCaW5kZXIpPT1udWxsP3ZvaWQgMDp0LmVudGl0eSk9PW51bGx8fHIudXBkYXRlKHRoaXMuX29jdHJlZUJpbmRlci5vY3RyZWUpfWNvcHlDb21wb25lbnQoZSl7cmV0dXJuIHN1cGVyLmNvcHlDb21wb25lbnQoZSksdGhpcy5nZW9tZXRyeT1lLl9nZW9tZXRyeSx0aGlzLm1hdGVyaWFscz1lLl9tYXRlcmlhbHMuc2xpY2UoKSx0aGlzLmRyYXdUeXBlPWUuZHJhd1R5cGUsdGhpcy5hbHdheXNSZW5kZXI9ZS5hbHdheXNSZW5kZXIsdGhpcy5uZWVkU29ydE9uQ2FtZXJhWj1lLm5lZWRTb3J0T25DYW1lcmFaLHRoaXMuaXNSZW5kZXJPcmRlckNoYW5nZT1lLmlzUmVuZGVyT3JkZXJDaGFuZ2UsdGhpcy5jYXN0U2hhZG93PWUuY2FzdFNoYWRvdyx0aGlzLmNhc3RHST1lLmNhc3RHSSx0aGlzLnJlbmRlcmVyTWFzaz1lLnJlbmRlcmVyTWFzayx0aGlzfWdldCByZW5kZXJMYXllcigpe3JldHVybiB0aGlzLl9yZW5kZXJMYXllcn1zZXQgcmVuZGVyTGF5ZXIoZSl7dGhpcy5fcmVuZGVyTGF5ZXI9ZX1nZXQgZ2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cnl9c2V0IGdlb21ldHJ5KGUpe3RoaXMuX2dlb21ldHJ5IT1lJiYodGhpcy5fZ2VvbWV0cnkmJnNlLmdldEluc3RhbmNlKCkuZGV0YWNoZWQodGhpcy5fZ2VvbWV0cnksdGhpcyksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZChlLHRoaXMpKSx0aGlzLl9nZW9tZXRyeT1lfWFkZE1hc2soZSl7dGhpcy5fcmVuZGVyZXJNYXNrPVR0LmFkZE1hc2sodGhpcy5yZW5kZXJlck1hc2ssZSl9cmVtb3ZlTWFzayhlKXt0aGlzLl9yZW5kZXJlck1hc2s9VHQucmVtb3ZlTWFzayh0aGlzLnJlbmRlcmVyTWFzayxlKX1oYXNNYXNrKGUpe3JldHVybiBUdC5oYXNNYXNrKHRoaXMucmVuZGVyZXJNYXNrLGUpfWdldCByZW5kZXJlck1hc2soKXtyZXR1cm4gdGhpcy5fcmVuZGVyZXJNYXNrfXNldCByZW5kZXJlck1hc2soZSl7dGhpcy5fcmVuZGVyZXJNYXNrPWV9Z2V0IHJlbmRlck9yZGVyKCl7cmV0dXJuIHRoaXMuX3JlbmRlck9yZGVyfXNldCByZW5kZXJPcmRlcihlKXtlIT10aGlzLl9yZW5kZXJPcmRlciYmKHRoaXMuaXNSZW5kZXJPcmRlckNoYW5nZT0hMCx0aGlzLl9fcmVuZGVyT3JkZXI9ZSksdGhpcy5fcmVuZGVyT3JkZXI9ZX1nZXQgbWF0ZXJpYWxzKCl7cmV0dXJuIHRoaXMuX21hdGVyaWFsc31zZXQgbWF0ZXJpYWxzKGUpe3RoaXMuX3JlYWR5UGlwZWxpbmU9ITE7Zm9yKGxldCByPTA7cjx0aGlzLl9tYXRlcmlhbHMubGVuZ3RoO3IrKyl7bGV0IHM9dGhpcy5fbWF0ZXJpYWxzW3JdO3NlLmdldEluc3RhbmNlKCkuZGV0YWNoZWQocyx0aGlzKX1mb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IHM9ZVtyXTtzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKHMsdGhpcyl9dGhpcy5fbWF0ZXJpYWxzPWU7bGV0IHQ9MDtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3Qgbj1lW3JdLmdldFBhc3MocmUuQ09MT1IpWzBdO24uc2hhZGVyU3RhdGUudHJhbnNwYXJlbnQmJih0PXQ+bi5yZW5kZXJPcmRlcj90Om4ucmVuZGVyT3JkZXIpfXRoaXMucmVuZGVyT3JkZXI9dCx0aGlzLl9yZWFkeVBpcGVsaW5lfHx0aGlzLmluaXRQaXBlbGluZSgpfWFkZFJlbmRlcmVyTWFzayhlKXt0aGlzLl9yZW5kZXJlck1hc2s9VHQuYWRkTWFzayh0aGlzLl9yZW5kZXJlck1hc2ssZSl9cmVtb3ZlUmVuZGVyZXJNYXNrKGUpe3RoaXMuX3JlbmRlcmVyTWFzaz1UdC5yZW1vdmVNYXNrKHRoaXMuX3JlbmRlcmVyTWFzayxlKX1vbkVuYWJsZSgpe3RoaXMuX3JlYWR5UGlwZWxpbmV8fHRoaXMuaW5pdFBpcGVsaW5lKCksUS5pbnN0YW5jZS5hZGRSZW5kZXJOb2RlKHRoaXMudHJhbnNmb3JtLnNjZW5lM0QsdGhpcyksdGhpcy51cGRhdGVPY3RyZWVFbnRpdHkoKX1vbkRpc2FibGUoKXtRLmluc3RhbmNlLnJlbW92ZVJlbmRlck5vZGUodGhpcy50cmFuc2Zvcm0uc2NlbmUzRCx0aGlzKX1zZWxmQ2xvbmVNYXRlcmlhbHMoZSl7bGV0IHQ9W107Zm9yKGxldCByPTAscz10aGlzLm1hdGVyaWFscy5sZW5ndGg7cjxzO3IrKyl7Y29uc3QgYT10aGlzLm1hdGVyaWFsc1tyXS5jbG9uZSgpO3QucHVzaChhKX1yZXR1cm4gdGhpcy5tYXRlcmlhbHM9dCx0aGlzLl9yZWFkeVBpcGVsaW5lPSExLHRoaXMuaW5pdFBpcGVsaW5lKCksdGhpc31pbml0UGlwZWxpbmUoKXtpZih0aGlzLl9nZW9tZXRyeSYmdGhpcy5fbWF0ZXJpYWxzLmxlbmd0aD4wKXtmb3IobGV0IHQ9MDt0PHRoaXMuX21hdGVyaWFscy5sZW5ndGg7dCsrKXtsZXQgcz10aGlzLl9tYXRlcmlhbHNbdF0uZ2V0UGFzcyhyZS5DT0xPUik7Zm9yKGxldCBhPTA7YTxzLmxlbmd0aDthKyspe2NvbnN0IG49c1thXTtuLnNoYWRlclJlZmxlY3Rpb258fG4ucHJlQ29tcGlsZSh0aGlzLl9nZW9tZXRyeSksdGhpcy5fZ2VvbWV0cnkuZ2VuZXJhdGUobi5zaGFkZXJSZWZsZWN0aW9uKX10aGlzLm9iamVjdDNELmJvdW5kPXRoaXMuX2dlb21ldHJ5LmJvdW5kcy5jbG9uZSgpfXRoaXMuX3JlYWR5UGlwZWxpbmU9ITA7bGV0IGU9MDtmb3IobGV0IHQ9MDt0PHRoaXMubWF0ZXJpYWxzLmxlbmd0aDt0Kyspe2NvbnN0IGE9dGhpcy5tYXRlcmlhbHNbdF0uZ2V0UGFzcyhyZS5DT0xPUilbMF07YS5yZW5kZXJPcmRlcj49M2UzP2U9ZT5hLnJlbmRlck9yZGVyP2U6YS5yZW5kZXJPcmRlcjplPU1hdGgubWF4KGUtM2UzLDApLHRoaXMuY2FzdE5lZWRQYXNzKCl9dGhpcy5yZW5kZXJPcmRlcj1lLHRoaXMuZW5hYmxlJiZ0aGlzLnRyYW5zZm9ybSYmdGhpcy50cmFuc2Zvcm0uc2NlbmUzRCYmUS5pbnN0YW5jZS5hZGRSZW5kZXJOb2RlKHRoaXMudHJhbnNmb3JtLnNjZW5lM0QsdGhpcyl9fWNhc3ROZWVkUGFzcygpe2lmKHRoaXMuY2FzdEdJKWZvcihsZXQgdD0wO3Q8dGhpcy5tYXRlcmlhbHMubGVuZ3RoO3QrKyl7Y29uc3Qgcj10aGlzLm1hdGVyaWFsc1t0XTtYci5jcmVhdGVHSVBhc3ModGhpcyxyKX1mb3IobGV0IHQ9MDt0PHRoaXMubWF0ZXJpYWxzLmxlbmd0aDt0Kyspe2NvbnN0IHI9dGhpcy5tYXRlcmlhbHNbdF07ci5jYXN0U2hhZG93JiZYci5jcmVhdGVTaGFkb3dQYXNzKHRoaXMscil9aWYodGhpcy5jYXN0UmVmbGVjdGlvbilmb3IobGV0IHQ9MDt0PHRoaXMubWF0ZXJpYWxzLmxlbmd0aDt0Kyspe2NvbnN0IHI9dGhpcy5tYXRlcmlhbHNbdF07ci5jYXN0U2hhZG93JiZYci5jcmVhdGVTaGFkb3dQYXNzKHRoaXMscil9aWYoIVR0Lmhhc01hc2sodGhpcy5yZW5kZXJlck1hc2ssVWUuSWdub3JlRGVwdGhQYXNzKSYmQS5zZXR0aW5nLnJlbmRlci56UHJlUGFzcylmb3IobGV0IHQ9MDt0PHRoaXMubWF0ZXJpYWxzLmxlbmd0aDt0Kyspe2NvbnN0IHI9dGhpcy5tYXRlcmlhbHNbdF07WHIuY3JlYXRlRGVwdGhQYXNzKHRoaXMscil9ZWxzZSBmb3IobGV0IHQ9MDt0PHRoaXMubWF0ZXJpYWxzLmxlbmd0aDt0KyspdGhpcy5tYXRlcmlhbHNbdF0ucmVtb3ZlUGFzcyhyZS5ERVBUSCwwKX1nZXQgY2FzdFNoYWRvdygpe3JldHVybiB0aGlzLl9jYXN0U2hhZG93fXNldCBjYXN0U2hhZG93KGUpe3RoaXMuX2Nhc3RTaGFkb3c9ZX1nZXQgY2FzdEdJKCl7cmV0dXJuIHRoaXMuX2Nhc3RHSX1zZXQgY2FzdEdJKGUpe3RoaXMuX2Nhc3RHST1lfWdldCBjYXN0UmVmbGVjdGlvbigpe3JldHVybiB0aGlzLl9jYXN0UmVmbGVjdGlvbn1zZXQgY2FzdFJlZmxlY3Rpb24oZSl7dGhpcy5fY2FzdFJlZmxlY3Rpb249ZX1yZW5kZXJQYXNzKGUsdCxyKXtsZXQgcz10aGlzLGE9cy50cmFuc2Zvcm0uX3dvcmxkTWF0cml4O2ZvcihsZXQgbj0wO248cy5tYXRlcmlhbHMubGVuZ3RoO24rKyl7Y29uc3QgbD1zLm1hdGVyaWFsc1tuXTtpZighbHx8IWwuZW5hYmxlKWNvbnRpbnVlO2xldCBoPWwuZ2V0UGFzcyh0KTtpZighKCFofHxoLmxlbmd0aD09MCkpe3cuYmluZEdlb21ldHJ5QnVmZmVyKHIuZW5jb2RlcixzLl9nZW9tZXRyeSk7Zm9yKGxldCB1PTA7dTxoLmxlbmd0aDt1Kyspe2lmKCFofHxoLmxlbmd0aD09MCljb250aW51ZTtjb25zdCBmPWhbdV07aWYoZi5waXBlbGluZSl7Zi5zaGFkZXJTdGF0ZS5zcGxpdFRleHR1cmUmJihyLmVuZFJlbmRlclBhc3MoKSxGZS5Xcml0ZVNwbGl0Q29sb3JUZXh0dXJlKHMuaW5zdGFuY2VJRCksci5iZWdpblJlbmRlclBhc3MoKSx3LmJpbmRDYW1lcmEoci5lbmNvZGVyLGUuY2FtZXJhKSx3LmJpbmRHZW9tZXRyeUJ1ZmZlcihyLmVuY29kZXIscy5fZ2VvbWV0cnkpKSx3LmJpbmRQaXBlbGluZShyLmVuY29kZXIsZik7bGV0IF89cy5fZ2VvbWV0cnkuc3ViR2VvbWV0cmllc1tuXS5sb2RMZXZlbHNbcy5sb2RMZXZlbF07cy5pbnN0YW5jZUNvdW50PjA/dy5kcmF3SW5kZXhlZChyLmVuY29kZXIsXy5pbmRleENvdW50LHMuaW5zdGFuY2VDb3VudCxfLmluZGV4U3RhcnQsMCwwKTp3LmRyYXdJbmRleGVkKHIuZW5jb2RlcixfLmluZGV4Q291bnQsMSxfLmluZGV4U3RhcnQsMCxhLmluZGV4KX19fX19cmVuZGVyUGFzczIoZSx0LHIscyxhLG49ITEpe2lmKCF0aGlzLmVuYWJsZSlyZXR1cm47bGV0IGw9dGhpcyxoPWwub2JqZWN0M0QudHJhbnNmb3JtLl93b3JsZE1hdHJpeDtmb3IobGV0IHU9MDt1PHRoaXMubWF0ZXJpYWxzLmxlbmd0aDt1Kyspe2xldCBmPXRoaXMubWF0ZXJpYWxzW3VdLmdldFBhc3ModCk7aWYoIWZ8fGYubGVuZ3RoPT0wKXJldHVybjtpZih0aGlzLmRyYXdUeXBlPT0yKWZvcihsZXQgZCBvZiBmKWQucGlwZWxpbmUmJih3LmJpbmRQaXBlbGluZShhLGQpLHcuZHJhdyhhLDYsMSwwLGguaW5kZXgpKTtlbHNle3cuYmluZEdlb21ldHJ5QnVmZmVyKGEsbC5fZ2VvbWV0cnkpO2ZvcihsZXQgZCBvZiBmKWlmKGQucGlwZWxpbmUpe3cuYmluZFBpcGVsaW5lKGEsZCk7bGV0IHY9bC5fZ2VvbWV0cnkuc3ViR2VvbWV0cmllc1t1XS5sb2RMZXZlbHNbbC5sb2RMZXZlbF07dy5kcmF3SW5kZXhlZChhLHYuaW5kZXhDb3VudCwxLHYuaW5kZXhTdGFydCwwLGguaW5kZXgpfX19fXJlY29yZFJlbmRlclBhc3MyKGUsdCxyLHMsYSxuPSExKXtpZighdGhpcy5lbmFibGUpcmV0dXJuO2xldCBsPXRoaXM7Zm9yKGxldCBoPTA7aDx0aGlzLm1hdGVyaWFscy5sZW5ndGg7aCsrKXtsZXQgYz10aGlzLm1hdGVyaWFsc1toXS5nZXRQYXNzKHQpO2lmKCFjfHxjLmxlbmd0aD09MClyZXR1cm47bGV0IGY9bC5vYmplY3QzRC50cmFuc2Zvcm0uX3dvcmxkTWF0cml4O2ZvcihsZXQgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXtjb25zdCBwPWNbZF07dy5iaW5kUGlwZWxpbmUoYSxwKTtsZXQgeT1sLl9nZW9tZXRyeS5zdWJHZW9tZXRyaWVzW2hdLmxvZExldmVsc1tsLmxvZExldmVsXTt3LmRyYXdJbmRleGVkKGEseS5pbmRleENvdW50LDEseS5pbmRleFN0YXJ0LDAsZi5pbmRleCl9fX1ub3RpY2VTaGFkZXJDaGFuZ2UoKXt0aGlzLmVuYWJsZSYmKHRoaXMub25FbmFibGUoKSx0aGlzLnByZUluaXQ9ITEpfW5vZGVVcGRhdGUoZSx0LHIscyl7dGhpcy5wcmVJbml0PSEwO2xldCBhPXRoaXMsbj1lLnNjZW5lLmVudk1hcDtmb3IobGV0IGw9MDtsPGEubWF0ZXJpYWxzLmxlbmd0aDtsKyspe2xldCB1PWEubWF0ZXJpYWxzW2xdLmdldFBhc3ModCk7aWYodSlmb3IobGV0IGM9MDtjPHUubGVuZ3RoO2MrKyl7Y29uc3QgZD11W2NdO2lmKGQuc2hhZGVyU3RhdGUuc3BsaXRUZXh0dXJlKXtsZXQgQz1GZS5DcmVhdGVTcGxpdFRleHR1cmUoYS5pbnN0YW5jZUlEKTtkLnNldFRleHR1cmUoXCJzcGxpdFRleHR1cmVfTWFwXCIsQyl9aWYoIWEuX2lnbm9yZUVudk1hcCYmZC5lbnZNYXAhPW4mJmQuc2V0VGV4dHVyZShcImVudk1hcFwiLG4pLGQuc2V0VGV4dHVyZShcInByZWZpbHRlck1hcFwiLG4pLGQucGlwZWxpbmUpe2QuYXBwbHkoYS5fZ2VvbWV0cnksciwoKT0+YS5ub3RpY2VTaGFkZXJDaGFuZ2UoKSk7Y29udGludWV9bGV0IHA9QS5yZXMuZ2V0VGV4dHVyZShcIkJSREZMVVRcIik7ZC5zZXRUZXh0dXJlKFwiYnJkZmx1dE1hcFwiLHApO2xldCBtPUEuZ2V0UmVuZGVySm9iKGUpLnNoYWRvd01hcFBhc3NSZW5kZXJlcjttJiZtLmRlcHRoMkRBcnJheVRleHR1cmUmJihkLnNldFRleHR1cmUoXCJzaGFkb3dNYXBcIixBLmdldFJlbmRlckpvYihlKS5zaGFkb3dNYXBQYXNzUmVuZGVyZXIuZGVwdGgyREFycmF5VGV4dHVyZSksZC5zZXRTdG9yYWdlQnVmZmVyKFwic2hhZG93QnVmZmVyXCIsVmUuc2hhZG93QnVmZmVyLmdldChlLnNjZW5lKSkpO2xldCBfPUEuZ2V0UmVuZGVySm9iKGUpLnBvaW50TGlnaHRTaGFkb3dSZW5kZXJlcjtfJiZfLmN1YmVBcnJheVRleHR1cmUmJmQuc2V0VGV4dHVyZShcInBvaW50U2hhZG93TWFwXCIsXy5jdWJlQXJyYXlUZXh0dXJlKTtsZXQgdj1CaS5pZXNUZXh0dXJlO3YmJmQuc2V0VGV4dHVyZShcImllc1RleHR1cmVBcnJheU1hcFwiLHYpLHIuaXJyYWRpYW5jZUJ1ZmZlciYmci5pcnJhZGlhbmNlQnVmZmVyLmxlbmd0aD4wJiYoZC5zZXRUZXh0dXJlKFwiaXJyYWRpYW5jZU1hcFwiLHIuaXJyYWRpYW5jZUJ1ZmZlclswXSksZC5zZXRUZXh0dXJlKFwiaXJyYWRpYW5jZURlcHRoTWFwXCIsci5pcnJhZGlhbmNlQnVmZmVyWzFdKSk7bGV0IHk9cGUuZ2V0TGlnaHRFbnRyaWVzKGUuc2NlbmUpO3kmJihkLnNldFN0b3JhZ2VCdWZmZXIoXCJsaWdodEJ1ZmZlclwiLHkuc3RvcmFnZUdQVUJ1ZmZlcikseS5pcnJhZGlhbmNlVm9sdW1lJiZkLnNldFN0cnVjdFN0b3JhZ2VCdWZmZXIoXCJpcnJhZGlhbmNlRGF0YVwiLHkuaXJyYWRpYW5jZVZvbHVtZS5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyKSkscyYmKGQuc2V0U3RvcmFnZUJ1ZmZlcihcImNsdXN0ZXJzVW5pZm9ybVwiLHMuY2x1c3RlcnNVbmlmb3JtQnVmZmVyKSxkLnNldFN0b3JhZ2VCdWZmZXIoXCJsaWdodEFzc2lnbkJ1ZmZlclwiLHMubGlnaHRBc3NpZ25CdWZmZXIpLGQuc2V0U3RvcmFnZUJ1ZmZlcihcImFzc2lnblRhYmxlXCIscy5hc3NpZ25UYWJsZUJ1ZmZlciksZC5zZXRTdG9yYWdlQnVmZmVyKFwiY2x1c3RlckJ1ZmZlclwiLHMuY2x1c3RlckJ1ZmZlcikpLGQuYXBwbHkoYS5fZ2VvbWV0cnkscil9fX1iZWZvcmVEZXN0cm95KGUpe3NlLmdldEluc3RhbmNlKCkuZGV0YWNoZWQodGhpcy5fZ2VvbWV0cnksdGhpcyksc2UuZ2V0SW5zdGFuY2UoKS5oYXNSZWZlcmVuY2UodGhpcy5fZ2VvbWV0cnkpfHx0aGlzLl9nZW9tZXRyeS5kZXN0cm95KGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fbWF0ZXJpYWxzLmxlbmd0aDt0Kyspe2NvbnN0IHI9dGhpcy5fbWF0ZXJpYWxzW3RdO3NlLmdldEluc3RhbmNlKCkuZGV0YWNoZWQocix0aGlzKSxzZS5nZXRJbnN0YW5jZSgpLmhhc1JlZmVyZW5jZShyKXx8ci5kZXN0cm95KGUpfXN1cGVyLmJlZm9yZURlc3Ryb3koZSl9ZGVzdHJveShlKXtzdXBlci5kZXN0cm95KGUpLHRoaXMuX2dlb21ldHJ5PW51bGwsdGhpcy5fbWF0ZXJpYWxzPW51bGwsdGhpcy5fY29tYmluZVNoYWRlclJlZmVjdGlvbj1udWxsfX1XcihbVnRdLCR0LnByb3RvdHlwZSxcIm1hdGVyaWFsc1wiLDEpLFdyKFtWdF0sJHQucHJvdG90eXBlLFwiY2FzdFNoYWRvd1wiLDEpLFdyKFtWdF0sJHQucHJvdG90eXBlLFwiY2FzdFNoYWRvd1wiLDEpLFdyKFtWdF0sJHQucHJvdG90eXBlLFwiY2FzdEdJXCIsMSksV3IoW1Z0XSwkdC5wcm90b3R5cGUsXCJjYXN0R0lcIiwxKTt2YXIgeGU9KGk9PihpW2kuTk9ORT0wXT1cIk5PTkVcIixpW2kuQUJPVkU9MV09XCJBQk9WRVwiLGlbaS5BTFBIQT0yXT1cIkFMUEhBXCIsaVtpLk5PUk1BTD0zXT1cIk5PUk1BTFwiLGlbaS5BREQ9NF09XCJBRERcIixpW2kuQkVMT1c9NV09XCJCRUxPV1wiLGlbaS5FUkFTRT02XT1cIkVSQVNFXCIsaVtpLk1VTD03XT1cIk1VTFwiLGlbaS5TQ1JFRU49OF09XCJTQ1JFRU5cIixpW2kuRElWRD05XT1cIkRJVkRcIixpW2kuU09GVF9BREQ9MTBdPVwiU09GVF9BRERcIixpKSkoeGV8fHt9KSxEbD0oaT0+KGlbaS5zcmNfYT0wXT1cInNyY19hXCIsaVtpLmRlc3RfYT0xXT1cImRlc3RfYVwiLGkpKShEbHx8e30pO2NsYXNzIG5ve3N0YXRpYyBnZXRCbGVuZChlKXtsZXQgdD17Y29sb3I6e3NyY0ZhY3RvcjpcInNyYy1hbHBoYVwiLGRzdEZhY3RvcjpcIm9uZVwifSxhbHBoYTp7c3JjRmFjdG9yOlwib25lXCIsZHN0RmFjdG9yOlwib25lXCJ9fTtzd2l0Y2goZSl7Y2FzZSAwOnQuY29sb3Iuc3JjRmFjdG9yPVwib25lXCIsdC5jb2xvci5kc3RGYWN0b3I9XCJ6ZXJvXCIsdC5jb2xvci5vcGVyYXRpb249XCJhZGRcIjticmVhaztjYXNlIDE6dC5jb2xvci5zcmNGYWN0b3I9XCJvbmUtbWludXMtc3JjLWFscGhhXCIsdC5jb2xvci5kc3RGYWN0b3I9XCJkc3QtYWxwaGFcIix0LmNvbG9yLm9wZXJhdGlvbj1cImFkZFwiO2JyZWFrO2Nhc2UgNDp0LmNvbG9yLnNyY0ZhY3Rvcj1cIm9uZVwiLHQuY29sb3IuZHN0RmFjdG9yPVwib25lXCIsdC5jb2xvci5vcGVyYXRpb249XCJhZGRcIix0LmFscGhhLnNyY0ZhY3Rvcj1cIm9uZVwiLHQuYWxwaGEuZHN0RmFjdG9yPVwib25lXCIsdC5hbHBoYS5vcGVyYXRpb249XCJhZGRcIjticmVhaztjYXNlIDI6dC5jb2xvci5zcmNGYWN0b3I9XCJzcmMtYWxwaGFcIix0LmNvbG9yLmRzdEZhY3Rvcj1cIm9uZS1taW51cy1zcmMtYWxwaGFcIjticmVhaztjYXNlIDU6dC5jb2xvci5zcmNGYWN0b3I9XCJvbmUtbWludXMtc3JjLWFscGhhXCIsdC5jb2xvci5kc3RGYWN0b3I9XCJvbmVcIix0LmNvbG9yLm9wZXJhdGlvbj1cImFkZFwiO2JyZWFrO2Nhc2UgNjp0LmNvbG9yLnNyY0ZhY3Rvcj1cInplcm9cIix0LmNvbG9yLmRzdEZhY3Rvcj1cIm9uZS1taW51cy1zcmMtYWxwaGFcIix0LmNvbG9yLm9wZXJhdGlvbj1cImFkZFwiO2JyZWFrO2Nhc2UgNzp0LmNvbG9yLnNyY0ZhY3Rvcj1cImRzdFwiLHQuY29sb3IuZHN0RmFjdG9yPVwib25lLW1pbnVzLXNyYy1hbHBoYVwiLHQuY29sb3Iub3BlcmF0aW9uPVwiYWRkXCI7YnJlYWs7Y2FzZSAzOnQuY29sb3Iuc3JjRmFjdG9yPVwib25lXCIsdC5jb2xvci5kc3RGYWN0b3I9XCJvbmUtbWludXMtc3JjLWFscGhhXCIsdC5jb2xvci5vcGVyYXRpb249XCJhZGRcIjticmVhaztjYXNlIDEwOnQuY29sb3Iuc3JjRmFjdG9yPVwib25lXCIsdC5jb2xvci5kc3RGYWN0b3I9XCJvbmVcIix0LmNvbG9yLm9wZXJhdGlvbj1cIm1heFwiLHQuYWxwaGEuc3JjRmFjdG9yPVwib25lXCIsdC5hbHBoYS5kc3RGYWN0b3I9XCJvbmVcIix0LmFscGhhLm9wZXJhdGlvbj1cImFkZFwiO2JyZWFrO2Nhc2UgODp0LmNvbG9yLnNyY0ZhY3Rvcj1cIm9uZVwiLHQuY29sb3IuZHN0RmFjdG9yPVwib25lLW1pbnVzLXNyY1wiLHQuY29sb3Iub3BlcmF0aW9uPVwiYWRkXCI7YnJlYWt9cmV0dXJuIHR9fWxldCBQbD1gXG4gICAgI2luY2x1ZGUgXCJXb3JsZE1hdHJpeFVuaWZvcm1cIlxuICAgICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG5cbiAgICBzdHJ1Y3QgVmVydGV4QXR0cmlidXRlcyB7XG4gICAgICAgIEBsb2NhdGlvbigwKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxuICAgICAgICBAbG9jYXRpb24oMSkgY29sb3I6IHZlYzQ8ZjMyPixcbiAgICB9XG5cbiAgICBzdHJ1Y3QgVmVydGV4T3V0cHV0IHtcbiAgICAgICAgQGxvY2F0aW9uKDApIHZhcnlpbmdfV1BvczogdmVjNDxmMzI+LFxuICAgICAgICBAbG9jYXRpb24oMSkgdmFyeWluZ19Db2xvcjogdmVjNDxmMzI+LFxuICAgICAgICBAYnVpbHRpbihwb3NpdGlvbikgbWVtYmVyOiB2ZWM0PGYzMj5cbiAgICB9O1xuXG4gICAgQHZlcnRleFxuICAgIGZuIG1haW4oIHZlcnRleDpWZXJ0ZXhBdHRyaWJ1dGVzICkgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgdmFyIHdvcmxkTWF0cml4ID0gbW9kZWxzLm1hdHJpeFt1MzIodmVydGV4LnBvc2l0aW9uLncpXTtcbiAgICAgICAgdmFyIHdvcmxkUG9zID0gKHdvcmxkTWF0cml4ICogdmVjNDxmMzI+KHZlcnRleC5wb3NpdGlvbi54eXosIDEuMCkpO1xuICAgICAgICB2YXIgdmlld1Bvc2l0aW9uID0gKChnbG9iYWxVbmlmb3JtLnZpZXdNYXQpICogd29ybGRQb3MpO1xuICAgICAgICB2YXIgY2xpcFBvc2l0aW9uID0gZ2xvYmFsVW5pZm9ybS5wcm9qTWF0ICogdmlld1Bvc2l0aW9uO1xuXG4gICAgICAgIHZhciBPUklfVmVydGV4T3V0OiBWZXJ0ZXhPdXRwdXQ7IFxuICAgICAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfV1BvcyA9IHdvcmxkUG9zO1xuICAgICAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfQ29sb3IgPSB2ZXJ0ZXguY29sb3I7XG4gICAgICAgIE9SSV9WZXJ0ZXhPdXQubWVtYmVyID0gY2xpcFBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gT1JJX1ZlcnRleE91dDtcbiAgICB9XG5gLFJsPWBcbiAgICBzdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICBAbG9jYXRpb24oMCkgY29sb3I6IHZlYzQ8ZjMyPixcbiAgICAgICAgLy8gI2lmIFVTRV9XT1JMRFBPU1xuICAgICAgICAgICAgQGxvY2F0aW9uKDEpIHdvcmxkUG9zOiB2ZWM0PGYzMj4sXG4gICAgICAgIC8vICNlbmRpZlxuICAgICAgICAvLyAjaWYgVVNFR0JVRkZFUlxuICAgICAgICAgICAgQGxvY2F0aW9uKDIpIHdvcmxkTm9ybWFsOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICBAbG9jYXRpb24oMykgbWF0ZXJpYWw6IHZlYzQ8ZjMyPixcbiAgICAgICAgLy8gI2VuZGlmXG4gICAgICAgIEBidWlsdGluKGZyYWdfZGVwdGgpIG91dF9kZXB0aDogZjMyXG4gICAgfTtcblxuICAgIEBmcmFnbWVudFxuICAgIGZuIG1haW4oICBcbiAgICAgICAgQGxvY2F0aW9uKDApIHZXb3JsZFBvczogdmVjNDxmMzI+LFxuICAgICAgICBAbG9jYXRpb24oMSkgdmFyeWluZ19Db2xvcjogdmVjNDxmMzI+LFxuICAgICkgLT4gRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICB2YXIgcmVzdWx0OiBGcmFnbWVudE91dHB1dDtcblxuICAgICAgICAvLyAjaWYgVVNFX1dPUkxEUE9TXG4gICAgICAgICAgICByZXN1bHQud29ybGRQb3MgPSB2V29ybGRQb3M7XG4gICAgICAgIC8vICNlbmRpZlxuXG4gICAgICAgIC8vICNpZiBVU0VHQlVGRkVSXG4gICAgICAgICAgICAvLyByZXN1bHQud29ybGROb3JtYWwgPSB2ZWM0PGYzMj4oMC4wLCAwLjAsIDAuMCwgMS4wKTsgXG4gICAgICAgICAgICByZXN1bHQubWF0ZXJpYWwgPSB2ZWM0PGYzMj4oMC4wLCAxLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgLy8gI2VuZGlmXG5cbiAgICAgICAgcmVzdWx0LmNvbG9yID0gdmFyeWluZ19Db2xvcjtcblxuICAgICAgICAvLyBsZXQgbiA9IGdsb2JhbFVuaWZvcm0ubmVhciA7XG4gICAgICAgIC8vIGxldCBmID0gZ2xvYmFsVW5pZm9ybS5mYXIgO1xuICAgICAgICAvLyBsZXQgeiA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZC56IDtcbiAgICAgICAgLy8gbGV0IHB0ID0gcG93KChmIC8gbikseik7XG4gICAgICAgIC8vIGxldCByYXRpbyA9IG4gKiBwdCAvIChmIC8gbik7XG4gICAgICAgIC8vIHJlc3VsdC5vdXRfZGVwdGggPSAgcmF0aW8gO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbmA7Y2xhc3MgTGx7Y29uc3RydWN0b3IoZSx0KXtvKHRoaXMsXCJtQ291bnRcIiksbyh0aGlzLFwibUJhdGNoU2l6ZVwiKSxvKHRoaXMsXCJtQmF0Y2hDb3VudFwiKSxvKHRoaXMsXCJtTWluSW5kZXhDb3VudFwiKSxvKHRoaXMsXCJtT2Zmc2V0XCIpLG8odGhpcyxcIm1JbmRleEJ1ZmZlclwiKSxvKHRoaXMsXCJtRGF0YUJ1ZmZlclwiKSxvKHRoaXMsXCJtQmF0Y2hCdWZmZXJzXCIpLG8odGhpcyxcIm1WZXJ0ZXhTaGFkZXJcIiksbyh0aGlzLFwibUZyYWdtZW50U2hhZGVyXCIpLG8odGhpcyxcIm1SZW5kZXJQaXBlbGluZVwiKSxvKHRoaXMsXCJtUmVuZGVyUGlwZWxpbmVMYXlvdXRcIiksbyh0aGlzLFwibVZlcnRleEJ1ZmZlckxheW91dFwiKSxvKHRoaXMsXCJtR1BVUHJpbWl0aXZlVG9wb2xvZ3lcIiksdGhpcy5tTWluSW5kZXhDb3VudD1lLHRoaXMubUdQVVByaW1pdGl2ZVRvcG9sb2d5PXQsdGhpcy5tQmF0Y2hTaXplPU1hdGgudHJ1bmMoNjU1MzYvdGhpcy5tTWluSW5kZXhDb3VudCksdGhpcy5pbml0KCl9cmVzZXQoKXt0aGlzLm1Db3VudD0wLHRoaXMubU9mZnNldD0wLHRoaXMubUJhdGNoQ291bnQ9MH1hZGRTaGFwZURhdGEoZSl7bGV0IHQ9ZS5zaGFwZURhdGE7Zm9yKDt0Lmxlbmd0aD4wOyl7aWYodGhpcy5tT2Zmc2V0Pj10aGlzLm1EYXRhQnVmZmVyLmxlbmd0aCYmdGhpcy5mbHVzaCgpLHRoaXMubU9mZnNldCt0Lmxlbmd0aDw9dGhpcy5tRGF0YUJ1ZmZlci5sZW5ndGgpe3RoaXMubURhdGFCdWZmZXIuc2V0KHQsdGhpcy5tT2Zmc2V0KSx0aGlzLm1PZmZzZXQrPXQubGVuZ3RoO2JyZWFrfWxldCByPXRoaXMubURhdGFCdWZmZXIubGVuZ3RoLXRoaXMubU9mZnNldDt0aGlzLm1EYXRhQnVmZmVyLnNldCh0LnNsaWNlKDAsciksdGhpcy5tT2Zmc2V0KSx0aGlzLm1PZmZzZXQrPXIsdD10LnNsaWNlKHIpfX1mbHVzaCgpe2lmKHRoaXMubU9mZnNldD4wKXtsZXQgZTt0aGlzLm1CYXRjaENvdW50PHRoaXMubUJhdGNoQnVmZmVycy5sZW5ndGg/ZT10aGlzLm1CYXRjaEJ1ZmZlcnNbdGhpcy5tQmF0Y2hDb3VudF06KGU9Uy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMubURhdGFCdWZmZXIuYnl0ZUxlbmd0aCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5WRVJURVh8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSx0aGlzLm1CYXRjaEJ1ZmZlcnMucHVzaChlKSksUy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoZSwwLHRoaXMubURhdGFCdWZmZXIsMCx0aGlzLm1PZmZzZXQpLHRoaXMubUNvdW50Kz10aGlzLm1PZmZzZXQvOCx0aGlzLm1CYXRjaENvdW50KyssdGhpcy5tT2Zmc2V0PTB9fXJlbmRlcihlLHQpe2NvbnN0IHI9Uy5kZXZpY2U7aWYoIXRoaXMubVJlbmRlclBpcGVsaW5lKXtsZXQgcz1lLm91dEF0dGFjaG1lbnRzO2lmKGUub3V0Q29sb3IhPS0xKXtsZXQgbj1zW2Uub3V0Q29sb3JdO24uYmxlbmQ9bm8uZ2V0QmxlbmQoeGUuTk9ORSl9dGhpcy5tUmVuZGVyUGlwZWxpbmVMYXlvdXQ9ci5jcmVhdGVQaXBlbGluZUxheW91dCh7YmluZEdyb3VwTGF5b3V0czpbSHIuZ2V0R2xvYmFsRGF0YUJpbmRHcm91cExheW91dCgpXX0pO2xldCBhPXtsYWJlbDpcIkdyYXBoaWMzREZpeGVkUmVuZGVyUGlwZWxpbmVcIixsYXlvdXQ6dGhpcy5tUmVuZGVyUGlwZWxpbmVMYXlvdXQsdmVydGV4Onttb2R1bGU6dGhpcy5tVmVydGV4U2hhZGVyLGVudHJ5UG9pbnQ6XCJtYWluXCIsYnVmZmVyczpbdGhpcy5tVmVydGV4QnVmZmVyTGF5b3V0XX0sZnJhZ21lbnQ6e21vZHVsZTp0aGlzLm1GcmFnbWVudFNoYWRlcixlbnRyeVBvaW50OlwibWFpblwiLHRhcmdldHM6c30scHJpbWl0aXZlOnt0b3BvbG9neTp0aGlzLm1HUFVQcmltaXRpdmVUb3BvbG9neSxjdWxsTW9kZTp1aS5iYWNrLGZyb250RmFjZTpcImNjd1wifX07ZS5kZXB0aFRleHR1cmUmJihhLmRlcHRoU3RlbmNpbD17ZGVwdGhXcml0ZUVuYWJsZWQ6ITAsZGVwdGhDb21wYXJlOnZ0Lmxlc3NfZXF1YWwsZm9ybWF0OmUuZGVwdGhUZXh0dXJlLmZvcm1hdH0pLHRoaXMubVJlbmRlclBpcGVsaW5lPXcuY3JlYXRlUGlwZWxpbmUoYSl9aWYodGhpcy5mbHVzaCgpLHRoaXMubUJhdGNoQ291bnQ+MCl7dC5zZXRQaXBlbGluZSh0aGlzLm1SZW5kZXJQaXBlbGluZSksdC5zZXRJbmRleEJ1ZmZlcih0aGlzLm1JbmRleEJ1ZmZlcixcInVpbnQxNlwiKTtsZXQgcz10aGlzLm1Db3VudC90aGlzLm1NaW5JbmRleENvdW50O2ZvcihsZXQgYT1NYXRoLnRydW5jKHMvdGhpcy5tQmF0Y2hTaXplKS0xO2E+PTA7YS0tKXQuc2V0VmVydGV4QnVmZmVyKDAsdGhpcy5tQmF0Y2hCdWZmZXJzW2FdKSx0LmRyYXdJbmRleGVkKHRoaXMubU1pbkluZGV4Q291bnQqdGhpcy5tQmF0Y2hTaXplLDEsMCwwLDApO3M9cyV0aGlzLm1CYXRjaFNpemUscyE9MCYmKHQuc2V0VmVydGV4QnVmZmVyKDAsdGhpcy5tQmF0Y2hCdWZmZXJzW3RoaXMubUJhdGNoQ291bnQtMV0pLHQuZHJhd0luZGV4ZWQodGhpcy5tTWluSW5kZXhDb3VudCpzLDEsMCwwLDApKX19aW5pdCgpe2NvbnN0IGU9Uy5kZXZpY2U7bGV0IHQ9bmV3IFVpbnQxNkFycmF5KChNYXRoLnRydW5jKHRoaXMubU1pbkluZGV4Q291bnQqdGhpcy5tQmF0Y2hTaXplLzQpKzEpKjQpO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXRbcl09cjt0aGlzLm1JbmRleEJ1ZmZlcj1lLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0LmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuSU5ERVh8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSxlLnF1ZXVlLndyaXRlQnVmZmVyKHRoaXMubUluZGV4QnVmZmVyLDAsdCksdGhpcy5tVmVydGV4QnVmZmVyTGF5b3V0PXthcnJheVN0cmlkZTooNCs0KSo0LHN0ZXBNb2RlOlwidmVydGV4XCIsYXR0cmlidXRlczpbe3NoYWRlckxvY2F0aW9uOjAsb2Zmc2V0OjAsZm9ybWF0OlwiZmxvYXQzMng0XCJ9LHtzaGFkZXJMb2NhdGlvbjoxLG9mZnNldDoxNixmb3JtYXQ6XCJmbG9hdDMyeDRcIn1dfSx0aGlzLm1CYXRjaEJ1ZmZlcnM9W10sdGhpcy5tRGF0YUJ1ZmZlcj1uZXcgRmxvYXQzMkFycmF5KCg0KzQpKnQubGVuZ3RoKSx0aGlzLm1CYXRjaEJ1ZmZlcnMucHVzaChlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLm1EYXRhQnVmZmVyLmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuVkVSVEVYfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfSkpLHRoaXMubVZlcnRleFNoYWRlcj10aGlzLmNyZWF0ZVNoYWRlck1vZHVsZShcIkdyYXBoaWMzREZpeGVkUmVuZGVyUGlwZWxpbmUudnNcIix1dC5wYXJzZShQbCx7fSkpLHRoaXMubUZyYWdtZW50U2hhZGVyPXRoaXMuY3JlYXRlU2hhZGVyTW9kdWxlKFwiR3JhcGhpYzNERml4ZWRSZW5kZXJQaXBlbGluZS5mc1wiLHV0LnBhcnNlKFJsLHt9KSksdGhpcy5yZXNldCgpfWNyZWF0ZVNoYWRlck1vZHVsZShlLHQpe2xldCByPVMuZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7bGFiZWw6ZSxjb2RlOnR9KTtyZXR1cm4gci5nZXRDb21waWxhdGlvbkluZm8oKS50aGVuKHM9PntzLm1lc3NhZ2VzLmxlbmd0aD4wJiYoY29uc29sZS5sb2codCksY29uc29sZS5sb2cocykpfSkscn19Y2xhc3MgZWl7fW8oZWksXCJTaGFwZVZlcnRleFNpemVcIiw4KTtjbGFzcyBsb3tjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJ1dWlkXCIpLG8odGhpcyxcInR5cGVcIiksbyh0aGlzLFwiY29sb3JcIiksbyh0aGlzLFwiY291bnRcIiwwKSxvKHRoaXMsXCJzaGFwZURhdGFcIiksbyh0aGlzLFwiZGlydHlEYXRhXCIsITEpLG8odGhpcyxcIm1lbW9yeURhdGFJbmRleFwiLC0xKSxvKHRoaXMsXCJ0cmFuc2Zvcm1JbmRleFwiKSx0aGlzLnRyYW5zZm9ybUluZGV4PWV9YnVpbGRBeGlzKGU9bmV3IGcoMCwwLDApLHQ9MTApe3RoaXMuYnVpbGRMaW5lcyhbZSxuZXcgZyhlLngrdCxlLnksZS56KV0sei5oZXhSR0JDb2xvcih6LlJFRCkpLHRoaXMuYnVpbGRMaW5lcyhbZSxuZXcgZyhlLngsZS55K3QsZS56KV0sei5oZXhSR0JDb2xvcih6LkdSRUVOKSksdGhpcy5idWlsZExpbmVzKFtlLG5ldyBnKGUueCxlLnksZS56K3QpXSx6LmhleFJHQkNvbG9yKHouQkxVRSkpfWJ1aWxkTGluZXMoZSx0PXouQ09MT1JfV0hJVEUpe2lmKCEoZS5sZW5ndGg8Mikpe2lmKGUubGVuZ3RoPT0yKXt0aGlzLmZpbGxTaGFwZURhdGEoZSx0KTtyZXR1cm59dmFyIHI9bmV3IEFycmF5KGUubGVuZ3RoK2UubGVuZ3RoLTIpO2ZvcihsZXQgcz0xLGE9MDtzPGUubGVuZ3RoOysrcylyW2ErK109ZVtzLTFdLHJbYSsrXT1lW3NdO3RoaXMuZmlsbFNoYXBlRGF0YShyLHQpfX1idWlsZEFyY0xpbmUoZSx0LHIscyxhPTE2LG49Zy5ZX0FYSVMsbD16LkNPTE9SX1dISVRFKXtjb25zdCBoPShzLXIpKl9lO3IqPV9lO3ZhciB1PVtdO2ZvcihsZXQgcD0wO3A8PWE7KytwKXtwPjEmJnUucHVzaCh1W3UubGVuZ3RoLTFdKTt2YXIgYz1oKihwL2EpK3IsZj10Kk1hdGguY29zKGMpLGQ9dCpNYXRoLnNpbihjKTtzd2l0Y2gobil7Y2FzZSBnLlhfQVhJUzp1LnB1c2goZS5hZGQobmV3IGcoMCxmLGQpKSk7YnJlYWs7Y2FzZSBnLllfQVhJUzp1LnB1c2goZS5hZGQobmV3IGcoZiwwLGQpKSk7YnJlYWs7Y2FzZSBnLlpfQVhJUzp1LnB1c2goZS5hZGQobmV3IGcoZixkLDApKSk7YnJlYWs7ZGVmYXVsdDp1LnB1c2goZS5hZGQobmV3IGcoZixkLDApKSk7YnJlYWt9fXRoaXMuZmlsbFNoYXBlRGF0YSh1LGwpfWJ1aWxkQ2lyY2xlKGUsdCxyPTMyLHM9Zy5ZX0FYSVMsYT16LkNPTE9SX1dISVRFKXt2YXIgbj1bXTtmb3IobGV0IGM9MDtjPD1yOysrYyl7dmFyIGw9MipNYXRoLlBJKmMvcixoPXQqTWF0aC5jb3MobCksdT10Kk1hdGguc2luKGwpO3N3aXRjaChzKXtjYXNlIGcuWF9BWElTOm4ucHVzaChlLmFkZChuZXcgZygwLGgsdSkpKTticmVhaztjYXNlIGcuWV9BWElTOm4ucHVzaChlLmFkZChuZXcgZyhoLDAsdSkpKTticmVhaztjYXNlIGcuWl9BWElTOm4ucHVzaChlLmFkZChuZXcgZyhoLHUsMCkpKTticmVhaztkZWZhdWx0Om4ucHVzaChlLmFkZChuZXcgZyhoLHUsMCkpKTticmVha31jPjAmJm4ucHVzaChuW24ubGVuZ3RoLTFdKX1uLnB1c2goblswXSksdGhpcy5maWxsU2hhcGVEYXRhKG4sYSl9ZmlsbFNoYXBlRGF0YShlLHQpe2lmKCF0aGlzLnNoYXBlRGF0YSl0aGlzLnNoYXBlRGF0YT1uZXcgRmxvYXQzMkFycmF5KGVpLlNoYXBlVmVydGV4U2l6ZSplLmxlbmd0aCk7ZWxzZSBpZih0aGlzLmNvdW50K2VpLlNoYXBlVmVydGV4U2l6ZSplLmxlbmd0aD49dGhpcy5zaGFwZURhdGEubGVuZ3RoKXtsZXQgcz1uZXcgRmxvYXQzMkFycmF5KHRoaXMuc2hhcGVEYXRhLmxlbmd0aCtlaS5TaGFwZVZlcnRleFNpemUqZS5sZW5ndGgpO3Muc2V0KHRoaXMuc2hhcGVEYXRhKSx0aGlzLnNoYXBlRGF0YT1zfWNvbnN0IHI9dGhpcy5zaGFwZURhdGE7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDsrK3Mpe2NvbnN0IGE9ZVtzXTtpZihyW3RoaXMuY291bnQrK109YS54LHJbdGhpcy5jb3VudCsrXT1hLnksclt0aGlzLmNvdW50KytdPWEueixyW3RoaXMuY291bnQrK109dGhpcy50cmFuc2Zvcm1JbmRleCx0IGluc3RhbmNlb2YgeilyW3RoaXMuY291bnQrK109dC5yLHJbdGhpcy5jb3VudCsrXT10Lmcsclt0aGlzLmNvdW50KytdPXQuYixyW3RoaXMuY291bnQrK109dC5hO2Vsc2V7Y29uc3Qgbj10W3NdO3JbdGhpcy5jb3VudCsrXT1uLnIsclt0aGlzLmNvdW50KytdPW4uZyxyW3RoaXMuY291bnQrK109bi5iLHJbdGhpcy5jb3VudCsrXT1uLmF9fXRoaXMuZGlydHlEYXRhPSEwfXJlc2V0KCl7dGhpcy5jb3VudD0wfX1jbGFzcyBVcyBleHRlbmRzICR0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSxvKHRoaXMsXCJzaGFwZXNcIiksbyh0aGlzLFwibURpcnR5RGF0YVwiLCExKSxvKHRoaXMsXCJtTWluSW5kZXhDb3VudFwiKSxvKHRoaXMsXCJtR1BVUHJpbWl0aXZlVG9wb2xvZ3lcIiksbyh0aGlzLFwibVJlbmRlclBpcGVsaW5lXCIpLHRoaXMuYWx3YXlzUmVuZGVyPSEwLHRoaXMubU1pbkluZGV4Q291bnQ9ZSx0aGlzLm1HUFVQcmltaXRpdmVUb3BvbG9neT10LHRoaXMuc2hhcGVzPW5ldyBNYXAsdGhpcy5hZGRSZW5kZXJlck1hc2soVWUuUGFydGljbGUpfWZpbGxTaGFwZURhdGEoZSx0LHIscyl7dGhpcy5tRGlydHlEYXRhPSEwO3ZhciBhO3RoaXMuc2hhcGVzLmhhcyhlKT8oYT10aGlzLnNoYXBlcy5nZXQoZSksYS5zaGFwZURhdGEubGVuZ3RoPGVpLlNoYXBlVmVydGV4U2l6ZSpzLmxlbmd0aCYmKGEuc2hhcGVEYXRhPW5ldyBGbG9hdDMyQXJyYXkoZWkuU2hhcGVWZXJ0ZXhTaXplKnMubGVuZ3RoKSkpOihhPW5ldyBsbyh0aGlzLnRyYW5zZm9ybS5fd29ybGRNYXRyaXguaW5kZXgpLGEudHlwZT10LGEuY29sb3I9cixhLnNoYXBlRGF0YT1uZXcgRmxvYXQzMkFycmF5KGVpLlNoYXBlVmVydGV4U2l6ZSpzLmxlbmd0aCkpO2NvbnN0IG49YS5zaGFwZURhdGEsbD10aGlzLnRyYW5zZm9ybS5fd29ybGRNYXRyaXguaW5kZXg7Zm9yKGxldCBoPTAsdT0wO2g8cy5sZW5ndGg7KytoKXtjb25zdCBjPXNbaF07blt1KytdPWMueCxuW3UrK109Yy55LG5bdSsrXT1jLnosblt1KytdPWwsblt1KytdPXIucixuW3UrK109ci5nLG5bdSsrXT1yLmIsblt1KytdPXIuYX10aGlzLnNoYXBlcy5zZXQoZSxhKX1pbml0KCl7c3VwZXIuaW5pdCgpLHRoaXMuY2FzdEdJPSExLHRoaXMuY2FzdFNoYWRvdz0hMSx0aGlzLm1SZW5kZXJQaXBlbGluZT1uZXcgTGwodGhpcy5tTWluSW5kZXhDb3VudCx0aGlzLm1HUFVQcmltaXRpdmVUb3BvbG9neSl9cmVtb3ZlU2hhcGUoZSl7dGhpcy5zaGFwZXMuaGFzKGUpJiYodGhpcy5tRGlydHlEYXRhPSEwLHRoaXMuc2hhcGVzLmRlbGV0ZShlKSl9aW5pdFBpcGVsaW5lKCl7dGhpcy5vYmplY3QzRC5ib3VuZD1uZXcgQmUoZy5aRVJPLGcuTUFYKSx0aGlzLl9yZWFkeVBpcGVsaW5lPSEwfW5vZGVVcGRhdGUoZSx0LHIscyl7dGhpcy5tRGlydHlEYXRhJiYodGhpcy5tUmVuZGVyUGlwZWxpbmUucmVzZXQoKSx0aGlzLnNoYXBlcy5mb3JFYWNoKChhLG4pPT57dGhpcy5tUmVuZGVyUGlwZWxpbmUuYWRkU2hhcGVEYXRhKGEpfSksdGhpcy5tRGlydHlEYXRhPSExKX1yZW5kZXJQYXNzMihlLHQscixzLGEsbj0hMSl7dGhpcy5tUmVuZGVyUGlwZWxpbmUucmVuZGVyKHIsYSl9YWxsb2NHcmFwaGljczNEU2hhcGUoZSx0KXtsZXQgcjtyZXR1cm4gdGhpcy5zaGFwZXMuaGFzKGUpPyhyPXRoaXMuc2hhcGVzLmdldChlKSxyLnJlc2V0KCkpOihyPW5ldyBsbyh0KSxyLnV1aWQ9ZSxyLnR5cGU9XCJsaW5lXCIsci5jb2xvcj16LkNPTE9SX1dISVRFLHRoaXMuc2hhcGVzLnNldChyLnV1aWQscikpLHRoaXMubURpcnR5RGF0YT0hMCxyfX1jbGFzcyBVbHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcIm9wYXF1ZUxpc3RcIixbXSksbyh0aGlzLFwidHJhbnNwYXJlbnRMaXN0XCIsW10pLG8odGhpcyxcInNreVwiKX1jbGVhbigpe3RoaXMub3BhcXVlTGlzdC5sZW5ndGg9MCx0aGlzLnRyYW5zcGFyZW50TGlzdC5sZW5ndGg9MH19Y2xhc3MgT2x7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJyZW5kZXJHcm91cFwiKSx0aGlzLnJlbmRlckdyb3VwPW5ldyBNYXB9Y29sbGVjdF9hZGQoZSl7bGV0IHQ9XCJcIixyPVwiXCI7dCs9ZS5nZW9tZXRyeS5pbnN0YW5jZUlEO2ZvcihsZXQgYT0wO2E8ZS5tYXRlcmlhbHMubGVuZ3RoO2ErKyl7Y29uc3Qgbj1lLm1hdGVyaWFsc1thXTtyKz1uLmRlZmF1bHRQYXNzLnNoYWRlclZhcmlhbnR9bGV0IHM9dCtyO3RoaXMucmVuZGVyR3JvdXAuaGFzKHMpfHx0aGlzLnJlbmRlckdyb3VwLnNldChzLHtidW5kbGVNYXA6bmV3IE1hcCxrZXk6cyxyZW5kZXJOb2RlczpbXX0pLHRoaXMucmVuZGVyR3JvdXAuZ2V0KHMpLnJlbmRlck5vZGVzLmluZGV4T2YoZSk9PS0xJiZ0aGlzLnJlbmRlckdyb3VwLmdldChzKS5yZW5kZXJOb2Rlcy5wdXNoKGUpfX1jbGFzcyBObHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcInJlbmRlclNoYWRlclVwZGF0ZUxpc3RcIixuZXcgTWFwKSxvKHRoaXMsXCJyZW5kZXJOb2RlTGlzdFwiLG5ldyBNYXApfWNvbGxlY3RfYWRkKGUpe2xldCB0PWUudHJhbnNmb3JtLnZpZXczRDt0JiZlLm1hdGVyaWFscyYmZS5tYXRlcmlhbHMuZm9yRWFjaChyPT57bGV0IHM9dGhpcy5yZW5kZXJTaGFkZXJVcGRhdGVMaXN0LmdldCh0KTtzfHwocz1uZXcgTWFwLHRoaXMucmVuZGVyU2hhZGVyVXBkYXRlTGlzdC5zZXQodCxzKSk7bGV0IGE9dGhpcy5yZW5kZXJOb2RlTGlzdC5nZXQodCk7YXx8KGE9bmV3IE1hcCx0aGlzLnJlbmRlck5vZGVMaXN0LnNldCh0LGEpKSxhLnNldChlLmluc3RhbmNlSUQsZSk7bGV0IG49ci5nZXRBbGxQYXNzKCk7Zm9yKGxldCBsPTA7bDxuLmxlbmd0aDtsKyspe2NvbnN0IGg9bltsXTtsZXQgdT1gJHtlLmdlb21ldHJ5Lmluc3RhbmNlSUQraC5pbnN0YW5jZUlEfWAsYz1zLmdldCh1KTtjfHwoYz1uZXcgTWFwLHMuc2V0KHUsYykpLGMuc2V0KGUuaW5zdGFuY2VJRCxlKX19KX1jb2xsZWN0X3JlbW92ZShlKXtsZXQgdD1lLnRyYW5zZm9ybS52aWV3M0Q7aWYodCYmZS5tYXRlcmlhbHMpe2xldCByPXRoaXMucmVuZGVyU2hhZGVyVXBkYXRlTGlzdC5nZXQodCk7ciYmZS5tYXRlcmlhbHMuZm9yRWFjaChzPT57bGV0IGE9cy5nZXRBbGxQYXNzKCk7Zm9yKGxldCBuPTA7bjxhLmxlbmd0aDtuKyspe2NvbnN0IGw9YVtuXTtsZXQgaD1gJHtlLmdlb21ldHJ5Lmluc3RhbmNlSUQrbC5pbnN0YW5jZUlEfWA7ci5kZWxldGUoaCl9fSl9fX1jb25zdCBGbD1jbGFzc3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcIl9zY2VuZUxpZ2h0c1wiKSxvKHRoaXMsXCJfc2NlbmVHSVByb2Jlc1wiKSxvKHRoaXMsXCJfb3BfUmVuZGVyTm9kZXNcIiksbyh0aGlzLFwiX3RyX1JlbmRlck5vZGVzXCIpLG8odGhpcyxcIl9vY3RyZWVSZW5kZXJOb2Rlc1wiKSxvKHRoaXMsXCJfZ3JhcGhpY3NcIiksbyh0aGlzLFwiX29wX3JlbmRlckdyb3VwXCIpLG8odGhpcyxcIl90cl9yZW5kZXJHcm91cFwiKSxvKHRoaXMsXCJfcmVuZGVyU2hhZGVyQ29sbGVjdFwiKSxvKHRoaXMsXCJzdGF0ZVwiLHtnaUxpZ2h0aW5nQ2hhbmdlOiEwfSksbyh0aGlzLFwic2t5XCIpLG8odGhpcyxcIl9jb2xsZWN0SW5mb1wiKSxvKHRoaXMsXCJyZW5kZXJlck9jdHJlZVwiKSx0aGlzLl9zY2VuZUxpZ2h0cz1uZXcgTWFwLHRoaXMuX3NjZW5lR0lQcm9iZXM9bmV3IE1hcCx0aGlzLl9vcF9SZW5kZXJOb2Rlcz1uZXcgTWFwLHRoaXMuX3RyX1JlbmRlck5vZGVzPW5ldyBNYXAsdGhpcy5fZ3JhcGhpY3M9W10sdGhpcy5fb3BfcmVuZGVyR3JvdXA9bmV3IE1hcCx0aGlzLl90cl9yZW5kZXJHcm91cD1uZXcgTWFwLHRoaXMuX2NvbGxlY3RJbmZvPW5ldyBVbCx0aGlzLl9yZW5kZXJTaGFkZXJDb2xsZWN0PW5ldyBObCx0aGlzLl9vY3RyZWVSZW5kZXJOb2Rlcz1uZXcgTWFwfXN0YXRpYyBnZXQgaW5zdGFuY2UoKXtyZXR1cm4gdGhpcy5faW5zdGFuY2V8fCh0aGlzLl9pbnN0YW5jZT1uZXcgRmwpLHRoaXMuX2luc3RhbmNlfWdldFBhc2hMaXN0KGksZSl7aWYoZS5yZW5kZXJPcmRlcjwzZTMpcmV0dXJuIHRoaXMuX29wX1JlbmRlck5vZGVzLmdldChpKTtpZihlLnJlbmRlck9yZGVyPj0zZTMpcmV0dXJuIHRoaXMuX3RyX1JlbmRlck5vZGVzLmdldChpKX1zb3J0UmVuZGVyTm9kZShpLGUpe2ZvcihsZXQgdD1pLmxlbmd0aC0xO3Q+MDt0LS0paWYoaVt0XS5yZW5kZXJPcmRlcjxlLnJlbmRlck9yZGVyKXtpLnB1c2goZSk7cmV0dXJufWkucHVzaChlKX1hZGRSZW5kZXJOb2RlKGksZSl7aWYoIWkpcmV0dXJuO2xldCB0PWUucmVuZGVyT3JkZXI+PTNlMztpZihlLmhhc01hc2soVWUuU2t5KSl0aGlzLnNreT1lO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFVzKXRoaXMuX2dyYXBoaWNzLmluZGV4T2YoZSk9PS0xJiZ0aGlzLl9ncmFwaGljcy5wdXNoKGUpO2Vsc2UgaWYob28uaGFzTWFzayhlLnJlbmRlckxheWVyLFlyLk5vbmUpKXt0aGlzLnJlbW92ZVJlbmRlck5vZGUoaSxlKTtsZXQgcj10P3RoaXMuX3RyX1JlbmRlck5vZGVzOnRoaXMuX29wX1JlbmRlck5vZGVzO3IuaGFzKGkpfHxyLnNldChpLFtdKSxyLmdldChpKS5wdXNoKGUpLEEuc2V0dGluZy5vY2NsdXNpb25RdWVyeS5vY3RyZWUmJmUuYXR0YWNoU2NlbmVPY3RyZWUodGhpcy5nZXRPY3RyZWUoaSkpO2xldCBzPXRoaXMuZ2V0UGFzaExpc3QoaSxlKTtzLmluZGV4T2YoZSk9PS0xJiZ0aGlzLnNvcnRSZW5kZXJOb2RlKHMsZSl9ZWxzZXt0aGlzLnJlbW92ZVJlbmRlck5vZGUoaSxlKTtsZXQgcj10P3RoaXMuX3RyX3JlbmRlckdyb3VwOnRoaXMuX29wX3JlbmRlckdyb3VwO3IuaGFzKGkpfHxyLnNldChpLG5ldyBPbCksci5nZXQoaSkuY29sbGVjdF9hZGQoZSl9ZS5vYmplY3QzRC5yZW5kZXJOb2RlPWUsdGhpcy5fcmVuZGVyU2hhZGVyQ29sbGVjdC5jb2xsZWN0X2FkZChlKX1nZXRPY3RyZWUoaSl7bGV0IGUsdD1BLnNldHRpbmcub2NjbHVzaW9uUXVlcnkub2N0cmVlO2lmKHQmJihlPXRoaXMuX29jdHJlZVJlbmRlck5vZGVzLmdldChpKSwhZSkpe2xldCByPW5ldyBnKHQueCx0LnksdC56KSxzPW5ldyBnKHQud2lkdGgsdC5oZWlnaHQsdC5kZXB0aCksYT1uZXcgQmUocixzKTtlPW5ldyBlcihhKSx0aGlzLl9vY3RyZWVSZW5kZXJOb2Rlcy5zZXQoaSxlKX1yZXR1cm4gZX1yZW1vdmVSZW5kZXJOb2RlKGksZSl7aWYoZS5kZXRhY2hTY2VuZU9jdHJlZSgpLGUuaGFzTWFzayhVZS5Ta3kpKXRoaXMuc2t5PW51bGw7ZWxzZSBpZihvby5oYXNNYXNrKGUucmVuZGVyTGF5ZXIsWXIuTm9uZSkpe2xldCB0PXRoaXMuZ2V0UGFzaExpc3QoaSxlKTtpZih0KXtsZXQgcj10LmluZGV4T2YoZSk7ciE9LTEmJnQuc3BsaWNlKHIsMSl9fXRoaXMuX3JlbmRlclNoYWRlckNvbGxlY3QuY29sbGVjdF9yZW1vdmUoZSl9YWRkTGlnaHQoaSxlKXtpZighdGhpcy5fc2NlbmVMaWdodHMuaGFzKGkpKXRoaXMuX3NjZW5lTGlnaHRzLnNldChpLFtlXSk7ZWxzZXtsZXQgdD10aGlzLl9zY2VuZUxpZ2h0cy5nZXQoaSk7aWYodC5sZW5ndGg+PUEuc2V0dGluZy5saWdodC5tYXhMaWdodCl7Y29uc29sZS53YXJuKFwiQWxyZWF5IG1lZXQgbWF4bWl1bSBsaWdodCBudW1iZXI6XCIsQS5zZXR0aW5nLmxpZ2h0Lm1heExpZ2h0KTtyZXR1cm59dC5pbmRleE9mKGUpIT0tMXx8dC5wdXNoKGUpfX1yZW1vdmVMaWdodChpLGUpe2lmKHRoaXMuX3NjZW5lTGlnaHRzLmhhcyhpKSl7bGV0IHQ9dGhpcy5fc2NlbmVMaWdodHMuZ2V0KGkpLHI9dC5pbmRleE9mKGUpO3IhPS0xJiZ0LnNwbGljZShyLDEpfX1nZXRMaWdodHMoaSl7bGV0IGU9dGhpcy5fc2NlbmVMaWdodHMuZ2V0KGkpO3JldHVybiBlfHxbXX1hZGRHSVByb2JlKGksZSl7dGhpcy5fc2NlbmVHSVByb2Jlcy5oYXMoaSk/dGhpcy5fc2NlbmVHSVByb2Jlcy5nZXQoaSkucHVzaChlKTp0aGlzLl9zY2VuZUdJUHJvYmVzLnNldChpLFtlXSl9cmVtb3ZlR0lQcm9iZShpLGUpe2lmKHRoaXMuX3NjZW5lR0lQcm9iZXMuaGFzKGkpKXtsZXQgdD10aGlzLl9zY2VuZUdJUHJvYmVzLmdldChpKSxyPXQuaW5kZXhPZihlKTtyIT0tMSYmdC5zcGxpY2UociwxKX19Z2V0UHJvYmVzKGkpe2xldCBlPXRoaXMuX3NjZW5lR0lQcm9iZXMuZ2V0KGkpO3JldHVybiBlfHxbXX1hdXRvU29ydFJlbmRlck5vZGVzKGkpe2xldCBlPXRoaXMuX3RyX1JlbmRlck5vZGVzLmdldChpKTtpZighZSlyZXR1cm47bGV0IHQ9ITE7Zm9yKGNvbnN0IHIgb2YgZSlpZihyLmlzUmVuZGVyT3JkZXJDaGFuZ2V8fHIubmVlZFNvcnRPbkNhbWVyYVope3Q9ITA7YnJlYWt9aWYodCl7Zm9yKGNvbnN0IHIgb2YgZSl7bGV0IHM9ci5yZW5kZXJPcmRlcjtpZihyLm5lZWRTb3J0T25DYW1lcmFaKXtsZXQgYT1FbC53b3JsZFRvQ2FtZXJhRGVwdGgoci5vYmplY3QzRCk7YT0xLU1hdGgubWF4KDAsTWF0aC5taW4oMSxhKSkscys9YX1yLl9fcmVuZGVyT3JkZXI9cyxyLmlzUmVuZGVyT3JkZXJDaGFuZ2U9ITF9ZS5zb3J0KChyLHMpPT5yLl9fcmVuZGVyT3JkZXI+cy5fX3JlbmRlck9yZGVyPzE6LTEpfXJldHVybiB0aGlzfWdldFJlbmRlck5vZGVzKGksZSl7aWYodGhpcy5fY29sbGVjdEluZm8uY2xlYW4oKSx0aGlzLl9jb2xsZWN0SW5mby5za3k9dGhpcy5za3ksQS5zZXR0aW5nLm9jY2x1c2lvblF1ZXJ5Lm9jdHJlZSl0aGlzLnJlbmRlcmVyT2N0cmVlPXRoaXMuZ2V0T2N0cmVlKGkpLHRoaXMucmVuZGVyZXJPY3RyZWUuZ2V0UmVuZGVyTm9kZShlLmZydXN0dW0sdGhpcy5fY29sbGVjdEluZm8pO2Vsc2V7bGV0IHQ9dGhpcy5fb3BfUmVuZGVyTm9kZXMuZ2V0KGkpO3QmJih0aGlzLl9jb2xsZWN0SW5mby5vcGFxdWVMaXN0PXQuY29uY2F0KCkpO2xldCByPXRoaXMuX3RyX1JlbmRlck5vZGVzLmdldChpKTtyJiYodGhpcy5fY29sbGVjdEluZm8udHJhbnNwYXJlbnRMaXN0PXIuY29uY2F0KCkpfXJldHVybiB0aGlzLl9jb2xsZWN0SW5mb31nZXRPcFJlbmRlckdyb3VwKGkpe3JldHVybiB0aGlzLl9vcF9yZW5kZXJHcm91cC5nZXQoaSl9Z2V0VHJSZW5kZXJHcm91cChpKXtyZXR1cm4gdGhpcy5fdHJfcmVuZGVyR3JvdXAuZ2V0KGkpfWdldEdyYXBoaWNMaXN0KCl7cmV0dXJuIHRoaXMuX2dyYXBoaWNzfWdldFJlbmRlclNoYWRlckNvbGxlY3QoaSl7cmV0dXJuIHRoaXMuX3JlbmRlclNoYWRlckNvbGxlY3QucmVuZGVyU2hhZGVyVXBkYXRlTGlzdC5nZXQoaSl8fFtdfX07bGV0IFE9Rmw7byhRLFwiX2luc3RhbmNlXCIpO2NsYXNzIGtse2NvbnN0cnVjdG9yKCl7byh0aGlzLFwic2V0dGluZ1wiKSxvKHRoaXMsXCJwcm9iZXNCdWZmZXJEYXRhXCIpLG8odGhpcyxcInByb2Jlc0J1ZmZlclwiKSxvKHRoaXMsXCJpc1ZvbHVtZUZyYW1lQ2hhbmdlXCIsITApLG8odGhpcyxcInJhbmRvbU9yaWVudGF0aW9uXCIpLG8odGhpcyxcInN0YXJ0UG9zaXRpb25cIixuZXcgZyksbyh0aGlzLFwiaXNWb2x1bWVDaGFuZ2VcIiwhMCksbyh0aGlzLFwiaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlclwiKSxvKHRoaXMsXCJkaXJlY3Rpb25EaXN0YW5jZVwiLDIwKSxvKHRoaXMsXCJyYW5kb21TZWVkQ291bnRcIiwzKSxvKHRoaXMsXCJ1c2VSYW5kb21JbmRleFwiLDApLG8odGhpcyxcImNlbnRlckRpcmVjdGlvblwiLG5ldyBnKDAsMCx0aGlzLmRpcmVjdGlvbkRpc3RhbmNlKS5ub3JtYWxpemUoMSkpLG8odGhpcyxcImFycm91bmRQb3NpdGlvbnNcIixbXSksbyh0aGlzLFwiZGVidWdYXCIsMCksbyh0aGlzLFwiZGVidWdZXCIsMCksbyh0aGlzLFwiZGVidWdaXCIsMCl9dXBkYXRlT3JpZW50YXRpb24oKXtyZXR1cm4gdGhpcy51c2VSYW5kb21JbmRleCsrLHRoaXMudXNlUmFuZG9tSW5kZXg+PXRoaXMuYXJyb3VuZFBvc2l0aW9ucy5sZW5ndGgmJih0aGlzLnVzZVJhbmRvbUluZGV4PTApLFYuZnJvbVRvUm90YXRpb24odGhpcy5jZW50ZXJEaXJlY3Rpb24sdGhpcy5hcnJvdW5kUG9zaXRpb25zW3RoaXMudXNlUmFuZG9tSW5kZXhdLHRoaXMucmFuZG9tT3JpZW50YXRpb24pLHRoaXMucmFuZG9tT3JpZW50YXRpb259aW5pdChlKXt0aGlzLnNldHRpbmc9ZSx0aGlzLnJhbmRvbU9yaWVudGF0aW9uPW5ldyBWKCExKSx0aGlzLnJhbmRvbU9yaWVudGF0aW9uLmlkZW50aXR5KCksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyPW5ldyBnZSg4MCksdGhpcy5jcmVhdGVGcmFtZXNCdWZmZXIoKSx0aGlzLmFycm91bmRQb3NpdGlvbnMucHVzaCh0aGlzLmNlbnRlckRpcmVjdGlvbi5jbG9uZSgpKTtmb3IobGV0IHQ9MDt0PHRoaXMucmFuZG9tU2VlZENvdW50O3QrKyl7bGV0IHI9TWF0aC5QSSoyKnQvdGhpcy5yYW5kb21TZWVkQ291bnQscz1uZXcgZyhNYXRoLnNpbihyKSxNYXRoLmNvcyhyKSx0aGlzLmRpcmVjdGlvbkRpc3RhbmNlKS5ub3JtYWxpemUoMSk7dGhpcy5hcnJvdW5kUG9zaXRpb25zLnB1c2gocyl9fXNldFZvbHVtZURhdGFDaGFuZ2UoKXt0aGlzLmlzVm9sdW1lQ2hhbmdlPSEwfXVwZGF0ZVByb2JlcyhlKXtsZXQgdD10aGlzLnByb2Jlc0J1ZmZlckRhdGE7Zm9yKGxldCByIG9mIGUpe2xldCBzPXIuaW5kZXgqNDt0W3MrM109ci5kcmF3Q2FsbEZyYW1lfX1jcmVhdGVGcmFtZXNCdWZmZXIoKXtpZighdGhpcy5wcm9iZXNCdWZmZXJEYXRhKXtsZXQgZT10aGlzLnNldHRpbmcucHJvYmVYQ291bnQqdGhpcy5zZXR0aW5nLnByb2JlWUNvdW50KnRoaXMuc2V0dGluZy5wcm9iZVpDb3VudDt0aGlzLnByb2Jlc0J1ZmZlckRhdGE9bmV3IEZsb2F0MzJBcnJheShlKjQpLHRoaXMucHJvYmVzQnVmZmVyRGF0YS5maWxsKC0xKSx0aGlzLnByb2Jlc0J1ZmZlcj1uZXcgZ2UoZSo0LEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpfX11cGxvYWRCdWZmZXIoKXt0aGlzLmlzVm9sdW1lQ2hhbmdlJiYodGhpcy5maWxsSXJyYWRpYW5jZURhdGEoKSx0aGlzLmlzVm9sdW1lQ2hhbmdlPSExLHRoaXMuaXNWb2x1bWVGcmFtZUNoYW5nZT0hMCksdGhpcy5wcm9iZXNCdWZmZXIuc2V0RmxvYXQzMkFycmF5KFwidW5pZm9ybUZyYW1lc0J1ZmZlclwiLHRoaXMucHJvYmVzQnVmZmVyRGF0YSl9Y2FsY1Bvc2l0aW9uKGUsdCxyLHMpe2xldCBhPXRoaXMuc2V0dGluZyxuPXRoaXMuc2V0dGluZy5wcm9iZVNwYWNlO3JldHVybiBzPXN8fG5ldyBnLHMueD1lKm4tbiooYS5wcm9iZVhDb3VudC0xKSouNSthLm9mZnNldFgscy55PXQqbi1uKihhLnByb2JlWUNvdW50LTEpKi41K2Eub2Zmc2V0WSxzLno9cipuLW4qKGEucHJvYmVaQ291bnQtMSkqLjUrYS5vZmZzZXRaLHN9ZmlsbElycmFkaWFuY2VEYXRhKCl7bGV0IGU9dGhpcy5zZXR0aW5nLHQ9dGhpcy5jYWxjUG9zaXRpb24oMCwwLDAsdGhpcy5zdGFydFBvc2l0aW9uKTt0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJvcmllbnRhdGlvbkluZGV4XCIsdGhpcy5yYW5kb21PcmllbnRhdGlvbi5pbmRleCksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyLnNldEZsb2F0KFwiaHlzdGVyZXNpc1wiLGUuaHlzdGVyZXNpcyksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyLnNldEZsb2F0KFwiT2N0UlRTaWRlU2l6ZVwiLGUub2N0UlRTaWRlU2l6ZSksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyLnNldEZsb2F0KFwiT2N0UlRNYXhTaXplXCIsZS5vY3RSVE1heFNpemUpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcInN0YXJ0WFwiLHQueCksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyLnNldEZsb2F0KFwic3RhcnRZXCIsdC55KSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJzdGFydFpcIix0LnopLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcIlByb2JlU3BhY2VcIixlLnByb2JlU3BhY2UpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcInByb2JlWENvdW50XCIsZS5wcm9iZVhDb3VudCksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyLnNldEZsb2F0KFwicHJvYmVZQ291bnRcIixlLnByb2JlWUNvdW50KSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJwcm9iZVpDb3VudFwiLGUucHJvYmVaQ291bnQpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcIm1heERpc3RhbmNlXCIsZS5wcm9iZVNwYWNlKjEuNzMyKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJkZXB0aFNoYXJwbmVzc1wiLGUuZGVwdGhTaGFycG5lc3MpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcIlByb2JlU291cmNlVGV4dHVyZVNpemVcIixlLnByb2JlU291cmNlVGV4dHVyZVNpemUpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcIlByb2JlU2l6ZVwiLGUucHJvYmVTaXplKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJib3VuY2VJbnRlbnNpdHlcIixlLmJvdW5jZUludGVuc2l0eSksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyLnNldEZsb2F0KFwicHJvYmVSb3VnaG5lc3NcIixlLnByb2JlUm91Z2huZXNzKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJub3JtYWxCaWFzXCIsZS5ub3JtYWxCaWFzKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJpcnJhZGlhbmNlQ2hlYnlzaGV2Qmlhc1wiLGUuaXJyYWRpYW5jZUNoZWJ5c2hldkJpYXMpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcInJheU51bWJlclwiLGUucmF5TnVtYmVyKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJpcnJhZGlhbmNlRGlzdGFuY2VCaWFzXCIsZS5pcnJhZGlhbmNlRGlzdGFuY2VCaWFzKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJpbmRpcmVjdEludGVuc2l0eVwiLGUuaW5kaXJlY3RJbnRlbnNpdHkpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcImRkZ2lHYW1tYVwiLGUuZGRnaUdhbW1hKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJsZXJwSHlzdGVyZXNpc1wiLGUubGVycEh5c3RlcmVzaXMpLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5zZXRGbG9hdChcImRlYnVnWFwiLHRoaXMuZGVidWdYKSx0aGlzLmlycmFkaWFuY2VWb2x1bWVCdWZmZXIuc2V0RmxvYXQoXCJkZWJ1Z1lcIix0aGlzLmRlYnVnWSksdGhpcy5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyLnNldEZsb2F0KFwiZGVidWdaXCIsdGhpcy5kZWJ1Z1opLHRoaXMuaXJyYWRpYW5jZVZvbHVtZUJ1ZmZlci5hcHBseSgpfX1jbGFzcyB6bHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcInN0b3JhZ2VHUFVCdWZmZXJcIiksbyh0aGlzLFwiaXJyYWRpYW5jZVZvbHVtZVwiKSxvKHRoaXMsXCJfbGlnaHRMaXN0XCIsW10pLHRoaXMuc3RvcmFnZUdQVUJ1ZmZlcj1uZXcgZ2UoR3IubGlnaHRTaXplKkEuc2V0dGluZy5saWdodC5tYXhMaWdodCxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyksdGhpcy5pcnJhZGlhbmNlVm9sdW1lPW5ldyBrbCx0aGlzLmlycmFkaWFuY2VWb2x1bWUuaW5pdChBLnNldHRpbmcuZ2kpO2ZvcihsZXQgZT0wO2U8QS5zZXR0aW5nLmxpZ2h0Lm1heExpZ2h0O2UrKyl7bGV0IHQ9dGhpcy5zdG9yYWdlR1BVQnVmZmVyLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUoR3IubGlnaHRTaXplKjQpO3RoaXMuX2xpZ2h0TGlzdC5wdXNoKHQpfXRoaXMuc3RvcmFnZUdQVUJ1ZmZlci52aXNpYmlsaXR5PUdQVVNoYWRlclN0YWdlLlZFUlRFWHxHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVHxHUFVTaGFkZXJTdGFnZS5DT01QVVRFfXVwZGF0ZShlKXt0aGlzLnN0b3JhZ2VHUFVCdWZmZXIuY2xlYW4oKTtsZXQgdD1RLmluc3RhbmNlLmdldExpZ2h0cyhlLnNjZW5lKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3Qgcz10W3JdLmxpZ2h0RGF0YTtzLmluZGV4PXIsdGhpcy53cml0ZUxpZ2h0Qnl0ZXMocyx0aGlzLl9saWdodExpc3Rbcl0pfXRoaXMuc3RvcmFnZUdQVUJ1ZmZlci5hcHBseSgpfXdyaXRlTGlnaHRCeXRlcyhlLHQpe3Qub2Zmc2V0PTAsdC53cml0ZUZsb2F0KGUuaW5kZXgpLHQud3JpdGVJbnQzMihlLmxpZ2h0VHlwZSksdC53cml0ZUZsb2F0KGUucmFkaXVzKSx0LndyaXRlRmxvYXQoZS5saW5lYXIpLHQud3JpdGVWZWN0b3IzKGUubGlnaHRQb3NpdGlvbiksdC53cml0ZUZsb2F0KGUubGlnaHRNYXRyaXhJbmRleCksdC53cml0ZVZlY3RvcjMoZS5kaXJlY3Rpb24pLHQud3JpdGVGbG9hdChlLnF1YWRyYXRpYyksdC53cml0ZVJHQkNvbG9yKGUubGlnaHRDb2xvciksdC53cml0ZUZsb2F0KGUuaW50ZW5zaXR5KSx0LndyaXRlRmxvYXQoZS5pbm5lckFuZ2xlKSx0LndyaXRlRmxvYXQoZS5vdXRlckFuZ2xlKSx0LndyaXRlRmxvYXQoZS5yYW5nZSksdC53cml0ZUludDMyKGUuY2FzdFNoYWRvd0luZGV4KSx0LndyaXRlVmVjdG9yMyhlLmxpZ2h0VGFuZ2VudCksdC53cml0ZUZsb2F0KGUuaWVzSW5kZXgpfX1jbGFzcyBHbHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcImdwdUJ1ZmZlclwiKSxvKHRoaXMsXCJwcm9iZXNcIiksbyh0aGlzLFwibWVtb3J5RG9cIiksbyh0aGlzLFwiX3Byb2JlSW5mb0xpc3RcIil9aW5pdERhdGFVbmlmb3JtKGUpe3RoaXMubWVtb3J5RG89bmV3IHpyLHRoaXMucHJvYmVzPWUsdGhpcy5fcHJvYmVJbmZvTGlzdD1bXSx0aGlzLm1lbW9yeURvLmRlc3Ryb3koKSx0aGlzLm1lbW9yeURvLmFsbG9jYXRpb24oZS5sZW5ndGgqMTcqNCk7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciB0PTE3O2xldCBzPXRoaXMubWVtb3J5RG8uYWxsb2NhdGlvbl9ub2RlKHQqNCk7dGhpcy5fcHJvYmVJbmZvTGlzdC5wdXNoKHMpO2xldCBhPWVbcl0udHJhbnNmb3JtLndvcmxkUG9zaXRpb247cy5zZXRBcnJheSgwLFthLngsYS55LGEuel0pfXRoaXMuZ3B1QnVmZmVyPVMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLm1lbW9yeURvLnNoYXJlRGF0YUJ1ZmZlci5ieXRlTGVuZ3RoLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UsbGFiZWw6XCJQcm9iZUJ1ZmZlclwiLG1hcHBlZEF0Q3JlYXRpb246ITF9KX11cGRhdGVHUFVCdWZmZXIoKXtjb25zdCBlPXRoaXMubWVtb3J5RG8uc2hhcmVEYXRhQnVmZmVyO2xldCB0PXRoaXMubWVtb3J5RG8uc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgscj0wO2NvbnN0IHM9NWUzKjY0O2Zvcig7cjx0OylTLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcih0aGlzLmdwdUJ1ZmZlcixyLGUscixNYXRoLmZsb29yKE1hdGgubWluKHMsdC1yKSkpLHIrPXN9fWNsYXNzIFFsIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSx0PTAscil7c3VwZXIoKSxvKHRoaXMsXCJzaXplXCIpLHRoaXMuYnVmZmVyVHlwZT1NdC5TdG9yYWdlR1BVQnVmZmVyLHRoaXMuc2l6ZT1lLHRoaXMuY3JlYXRlQnVmZmVyKEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8dCxlLHIpfXdyaXRlQnVmZmVyQnlIZWFwKGUsdCl7bGV0IHI9Uy5kZXZpY2U7aWYoZS5sZW5ndGg+MCl7bGV0IHM9bnVsbDtmb3IoO3RoaXMubWFwQXN5bmNSZWFkeS5sZW5ndGgmJihzPXRoaXMubWFwQXN5bmNSZWFkeS5zaGlmdCgpLHMudXNlZFNpemUhPWUuYnl0ZUxlbmd0aCk7KXMuZGVzdHJveSgpLHRoaXMubWFwQXN5bmNCdWZmZXJzT3V0c3RhbmRpbmctLSxzPW51bGw7c3x8KHM9ci5jcmVhdGVCdWZmZXIoe3NpemU6ZS5ieXRlTGVuZ3RoLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURSxtYXBwZWRBdENyZWF0aW9uOiEwfSkscy51c2VkU2l6ZT1lLmJ5dGVMZW5ndGgsdGhpcy5tYXBBc3luY0J1ZmZlcnNPdXRzdGFuZGluZysrLHRoaXMubWFwQXN5bmNCdWZmZXJzT3V0c3RhbmRpbmc+MTAmJmNvbnNvbGUud2FybihgIFdhcm5pbmc6IG1hcEFzeW5jIHJlcXVlc3RzIGZyb20gJHt0aGlzLm1hcEFzeW5jQnVmZmVyc091dHN0YW5kaW5nfSBmcmFtZXMgYWdvIGhhdmUgbm90IHJlc29sdmVkIHlldC4gIE1CIG9mIHN0YWdpbmcgYnVmZmVycyBhbGxvY2F0ZWQuYCkpO2xldCBhPW5ldyBGbG9hdDMyQXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LHQpO25ldyBGbG9hdDMyQXJyYXkocy5nZXRNYXBwZWRSYW5nZSgwLHQqNCkpLnNldChhKSxzLnVubWFwKCk7Y29uc3QgbD1yLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7bC5jb3B5QnVmZmVyVG9CdWZmZXIocywwLHRoaXMuYnVmZmVyLDAsdCo0KSxyLnF1ZXVlLnN1Ym1pdChbbC5maW5pc2goKV0pLHMubWFwQXN5bmMoR1BVTWFwTW9kZS5XUklURSkudGhlbigoKT0+dGhpcy5tYXBBc3luY1JlYWR5LnB1c2gocykpfX19Y2xhc3MgVmx7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJ1dWlkXCIpLG8odGhpcyxcImluZGV4XCIpLG8odGhpcyxcInVzYWdlXCIpLG8odGhpcyxcImdyb3VwQnVmZmVyU2l6ZVwiKSxvKHRoaXMsXCJtYXRyaXhCdWZmZXJEc3RcIiksdGhpcy51dWlkPVB0KCksdGhpcy5ncm91cEJ1ZmZlclNpemU9MCx0aGlzLnVzYWdlPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsdGhpcy5jYWNoZVdvcmxkTWF0cml4KCl9Y2FjaGVXb3JsZE1hdHJpeCgpe3RoaXMuZ3JvdXBCdWZmZXJTaXplPVYubWF4Q291bnQqVi5ibG9ja0J5dGVzLHRoaXMubWF0cml4QnVmZmVyRHN0PW5ldyBRbCh0aGlzLmdyb3VwQnVmZmVyU2l6ZS80KSx0aGlzLm1hdHJpeEJ1ZmZlckRzdC52aXNpYmlsaXR5PUdQVVNoYWRlclN0YWdlLlZFUlRFWHxHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVHxHUFVTaGFkZXJTdGFnZS5DT01QVVRFLHRoaXMubWF0cml4QnVmZmVyRHN0LmJ1ZmZlci5sYWJlbD10aGlzLmdyb3VwQnVmZmVyU2l6ZS50b1N0cmluZygpfXdyaXRlQnVmZmVyKGUpe2NvbnN0IHQ9Vi5keW5hbWljTWF0cml4Qnl0ZXM7dGhpcy5tYXRyaXhCdWZmZXJEc3QubWFwQXN5bmNXcml0ZSh0LGUpfX1jbGFzcyBwZXtzdGF0aWMgaW5pdCgpe3RoaXMubW9kZWxNYXRyaXhCaW5kR3JvdXA9bmV3IFZsLHRoaXMuX2NhbWVyYUJpbmRHcm91cHM9bmV3IE1hcCx0aGlzLl9saWdodEVudHJpZXNNYXA9bmV3IE1hcH1zdGF0aWMgZ2V0Q2FtZXJhR3JvdXAoZSl7bGV0IHQ9dGhpcy5fY2FtZXJhQmluZEdyb3Vwcy5nZXQoZSk7cmV0dXJuIHR8fCh0PW5ldyBTbCh0aGlzLm1vZGVsTWF0cml4QmluZEdyb3VwKSx0aGlzLl9jYW1lcmFCaW5kR3JvdXBzLnNldChlLHQpKSxlLmlzU2hhZG93Q2FtZXJhP3Quc2V0U2hhZG93Q2FtZXJhKGUpOnQuc2V0Q2FtZXJhKGUpLHR9c3RhdGljIGdldExpZ2h0RW50cmllcyhlKXtlfHxjb25zb2xlLmxvZyhcImdldExpZ2h0RW50cmllcyBzY2VuZSBpcyBudWxsXCIpO2xldCB0PXRoaXMuX2xpZ2h0RW50cmllc01hcC5nZXQoZSk7cmV0dXJuIHR8fCh0PW5ldyB6bCx0aGlzLl9saWdodEVudHJpZXNNYXAuc2V0KGUsdCkpLHRoaXMuX2xpZ2h0RW50cmllc01hcC5nZXQoZSl9c3RhdGljIHVwZGF0ZVByb2JlcyhlKXt0aGlzLl9wcm9iZUVudHJpZXN8fCh0aGlzLl9wcm9iZUVudHJpZXM9bmV3IEdsLHRoaXMuX3Byb2JlRW50cmllcy5pbml0RGF0YVVuaWZvcm0oZSkpfX1vKHBlLFwiX2NhbWVyYUJpbmRHcm91cHNcIiksbyhwZSxcIl9saWdodEVudHJpZXNNYXBcIiksbyhwZSxcIl9wcm9iZUVudHJpZXNcIiksbyhwZSxcIm1vZGVsTWF0cml4QmluZEdyb3VwXCIpO2NvbnN0IGpyPWNsYXNze3N0YXRpYyBiaW5kUGlwZWxpbmUoaSxlKXtpZihqci5sYXN0U2hhZGVyIT1lKWpyLmxhc3RTaGFkZXI9ZTtlbHNlIHJldHVybjtqci5sYXN0UGlwZWxpbmUhPWUucGlwZWxpbmUmJihqci5sYXN0UGlwZWxpbmU9ZS5waXBlbGluZSxpLnNldFBpcGVsaW5lKGUucGlwZWxpbmUpKTtmb3IobGV0IHQ9MTt0PGUuYmluZEdyb3Vwcy5sZW5ndGg7dCsrKXtjb25zdCByPWUuYmluZEdyb3Vwc1t0XTtyJiZpLnNldEJpbmRHcm91cCh0LHIpfX1zdGF0aWMgYmluZENhbWVyYShpLGUpe2xldCB0PXBlLmdldENhbWVyYUdyb3VwKGUpO2kuc2V0QmluZEdyb3VwKDAsdC5nbG9iYWxCaW5kR3JvdXApfXN0YXRpYyBiaW5kR2VvbWV0cnlCdWZmZXIoaSxlKXtpZih0aGlzLmxhc3RHZW9tZXRyeSE9ZSl7dGhpcy5sYXN0R2VvbWV0cnk9ZSxlLmluZGljZXNCdWZmZXImJmkuc2V0SW5kZXhCdWZmZXIoZS5pbmRpY2VzQnVmZmVyLmluZGljZXNHUFVCdWZmZXIuYnVmZmVyLGUuaW5kaWNlc0J1ZmZlci5pbmRpY2VzRm9ybWF0KTtsZXQgdD1lLnZlcnRleEJ1ZmZlci52ZXJ0ZXhHUFVCdWZmZXIscj1lLnZlcnRleEJ1ZmZlci52ZXJ0ZXhCdWZmZXJMYXlvdXRzO2ZvcihsZXQgcz0wO3M8ci5sZW5ndGg7cysrKXtjb25zdCBhPXJbc107aS5zZXRWZXJ0ZXhCdWZmZXIocyx0LmJ1ZmZlcixhLm9mZnNldCxhLnNpemUpfX19c3RhdGljIGNsZWFuQ2FjaGUoKXt0aGlzLmxhc3RHZW9tZXRyeT1udWxsLHRoaXMubGFzdFBpcGVsaW5lPW51bGwsdGhpcy5sYXN0U2hhZGVyPW51bGx9c3RhdGljIGNyZWF0ZVBpcGVsaW5lKGkpe3JldHVybiBmdC5jb3VudFN0YXJ0KFwiR1BVQ29udGV4dFwiLFwicGlwZWxpbmVcIiksUy5kZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoaSl9c3RhdGljIGJlZ2luQ29tbWFuZEVuY29kZXIoKXtyZXR1cm4gZnQuY291bnRTdGFydChcIkdQVUNvbnRleHRcIixcImJlZ2luQ29tbWFuZEVuY29kZXJcIiksdGhpcy5MYXN0Q29tbWFuZCYmUy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLkxhc3RDb21tYW5kLmZpbmlzaCgpXSksdGhpcy5MYXN0Q29tbWFuZD1TLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpLHRoaXMuTGFzdENvbW1hbmR9c3RhdGljIGVuZENvbW1hbmRFbmNvZGVyKGkpe3RoaXMuTGFzdENvbW1hbmQ9PWkmJihTLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuTGFzdENvbW1hbmQuZmluaXNoKCldKSx0aGlzLkxhc3RDb21tYW5kPW51bGwsZnQuY291bnRTdGFydChcIkdQVUNvbnRleHRcIixcImVuZENvbW1hbmRFbmNvZGVyXCIpKX1zdGF0aWMgcmVjb3JkQnVuZGxlRW5jb2RlcihpKXtyZXR1cm4gUy5kZXZpY2UuY3JlYXRlUmVuZGVyQnVuZGxlRW5jb2RlcihpKX1zdGF0aWMgYmVnaW5SZW5kZXJQYXNzKGksZSl7aWYodGhpcy5jbGVhbkNhY2hlKCksdGhpcy5yZW5kZXJQYXNzQ291bnQrKyx0aGlzLmxhc3RSZW5kZXJQYXNzU3RhdGU9ZSxlLnJlbmRlclRhcmdldHMmJmUucmVuZGVyVGFyZ2V0cy5sZW5ndGg+MCl7Zm9yKGxldCB0PTA7dDxlLnJlbmRlclRhcmdldHMubGVuZ3RoOysrdCl7Y29uc3Qgcj1lLnJlbmRlclRhcmdldHNbdF07bGV0IHM9ZS5yZW5kZXJQYXNzRGVzY3JpcHRvci5jb2xvckF0dGFjaG1lbnRzW3RdO2UubXVsdGlzYW1wbGU+MCYmZS5yZW5kZXJUYXJnZXRzLmxlbmd0aD09MT8ocy52aWV3PWUubXVsdGlUZXh0dXJlLmNyZWF0ZVZpZXcoKSxzLnJlc29sdmVUYXJnZXQ9ci5nZXRHUFVWaWV3KCkpOnMudmlldz1yLmdldEdQVVRleHR1cmUoKS5jcmVhdGVWaWV3KCl9cmV0dXJuIGkuYmVnaW5SZW5kZXJQYXNzKGUucmVuZGVyUGFzc0Rlc2NyaXB0b3IpfWVsc2V7bGV0IHQ9ZS5yZW5kZXJQYXNzRGVzY3JpcHRvci5jb2xvckF0dGFjaG1lbnRzWzBdO3JldHVybiB0JiYoZS5tdWx0aXNhbXBsZT4wPyh0LnZpZXc9ZS5tdWx0aVRleHR1cmUuY3JlYXRlVmlldygpLHQucmVzb2x2ZVRhcmdldD1TLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKS5jcmVhdGVWaWV3KCkpOnQudmlldz1TLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKS5jcmVhdGVWaWV3KCkpLGkuYmVnaW5SZW5kZXJQYXNzKGUucmVuZGVyUGFzc0Rlc2NyaXB0b3IpfX1zdGF0aWMgZHJhd0luZGV4ZWQoaSxlLHQscixzLGEpe2kuZHJhd0luZGV4ZWQoZSx0LHIscyxhKSx0aGlzLmRyYXdDb3VudCsrfXN0YXRpYyBkcmF3KGksZSx0LHIscyl7aS5kcmF3KGUsdCxyLHMpLHRoaXMuZHJhd0NvdW50Kyt9c3RhdGljIGVuZFBhc3MoaSl7aS5pbnNlcnREZWJ1Z01hcmtlcihcImVuZFwiKSxpLmVuZCgpfXN0YXRpYyBjb21wdXRlQ29tbWFuZChpLGUpe2xldCB0PWkuYmVnaW5Db21wdXRlUGFzcygpO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKWVbcl0uY29tcHV0ZSh0KTt0LmVuZCgpfX07bGV0IHc9anI7byh3LFwibGFzdEdlb21ldHJ5XCIpLG8odyxcImxhc3RQaXBlbGluZVwiKSxvKHcsXCJsYXN0U2hhZGVyXCIpLG8odyxcImRyYXdDb3VudFwiLDApLG8odyxcInJlbmRlclBhc3NDb3VudFwiLDApLG8odyxcImdlb21ldHJ5Q291bnRcIiwwKSxvKHcsXCJwaXBlbGluZUNvdW50XCIsMCksbyh3LFwibWF0cml4Q291bnRcIiwwKSxvKHcsXCJsYXN0UmVuZGVyUGFzc1N0YXRlXCIpLG8odyxcIkxhc3RDb21tYW5kXCIpO2NsYXNzIEhse2NvbnN0cnVjdG9yKCl7byh0aGlzLFwic291cmNlXCIpLG8odGhpcyxcImlucHV0XCIpLG8odGhpcyxcIm91dHB1dFwiKX1yZXNldChlKXt0aGlzLmlucHV0JiZ0aGlzLmlucHV0LmRlc3Ryb3koKSx0aGlzLm91dHB1dCYmdGhpcy5vdXRwdXQuZGVzdHJveSgpLHRoaXMuaW5wdXQ9dGhpcy5vdXRwdXQ9bnVsbCx0aGlzLnNvdXJjZT1lfWFwcGx5KGUpe2lmKHRoaXMuc291cmNlKXtpZighdGhpcy5pbnB1dCl7bGV0IHQ9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVDt0aGlzLmlucHV0PW5ldyBnZSh0aGlzLnNvdXJjZS5sZW5ndGgsdCx0aGlzLnNvdXJjZSksdGhpcy5pbnB1dC5hcHBseSgpfWlmKCF0aGlzLm91dHB1dCl7bGV0IHQ9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQzt0aGlzLm91dHB1dD1uZXcgZ2UoZSozLHQpLHRoaXMub3V0cHV0LmFwcGx5KCl9fX19Y2xhc3MgWWx7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJlbmFibGVcIiksbyh0aGlzLFwibW9ycGhUYXJnZXRzUmVsYXRpdmVcIiksbyh0aGlzLFwiTWF4TW9ycGhUYXJnZXRDb3VudFwiLDY0KSxvKHRoaXMsXCJfY29tcHV0ZUNvbmZpZ0FycmF5XCIpLG8odGhpcyxcIl9jb21wdXRlQ29uZmlnQnVmZmVyXCIpLG8odGhpcyxcIl9tb3JwaEluZmx1ZW5jZUFycmF5XCIpLG8odGhpcyxcIl9tb3JwaEluZmx1ZW5jZUJ1ZmZlclwiKSxvKHRoaXMsXCJfcG9zaXRpb25BdHRyRGF0YUdyb3VwXCIpLG8odGhpcyxcIl9ub3JtYWxBdHRyRGF0YUdyb3VwXCIpLG8odGhpcyxcIl9pc0luZmx1ZW5jZURpcnR5XCIpLG8odGhpcyxcIl9tb3JwaFRhcmdldENvdW50XCIpLG8odGhpcyxcIl90b3RhbFZlcnRleENvdW50XCIpLG8odGhpcyxcIl9jb21wdXRlU2hhZGVyXCIpLG8odGhpcyxcIl9jb21wdXRlU2hhZGVyc1wiKSxvKHRoaXMsXCJfY29tcHV0ZVdvcmtHcm91cFhZXCIsMSksbyh0aGlzLFwiX2NvbGxlY3RNb3JwaFRhcmdldERhdGFcIiksdGhpcy5faXNJbmZsdWVuY2VEaXJ0eT0hMCx0aGlzLmdlbmVyYXRlR1BVQnVmZmVyKCksdGhpcy5fcG9zaXRpb25BdHRyRGF0YUdyb3VwPW5ldyBIbCx0aGlzLl9ub3JtYWxBdHRyRGF0YUdyb3VwPW5ldyBIbH1pbml0TW9ycGhUYXJnZXQoZSl7dGhpcy5fY29sbGVjdE1vcnBoVGFyZ2V0RGF0YT10aGlzLmNvbGxlY3RNb3JwaFRhcmdldExpc3QoZSksdGhpcy5fY29tcHV0ZVNoYWRlciYmdGhpcy5fY29tcHV0ZVNoYWRlci5kZXN0cm95KCk7bGV0IHQ9TGUuQ3NNYWluO3RoaXMuX2NvbXB1dGVTaGFkZXI9bmV3IGJlKHQpLHRoaXMuX2NvbGxlY3RNb3JwaFRhcmdldERhdGEubWVyZ2VkTm9ybWFsP3RoaXMuX2NvbXB1dGVTaGFkZXIuc2V0RGVmaW5lKFwiVVNFX01PUlBITk9STUFMU1wiLCEwKTp0aGlzLl9jb21wdXRlU2hhZGVyLmRlbGV0ZURlZmluZShcIlVTRV9NT1JQSE5PUk1BTFNcIiksdGhpcy5fY29tcHV0ZVNoYWRlcnM9W3RoaXMuX2NvbXB1dGVTaGFkZXJdLHRoaXMuX2lzSW5mbHVlbmNlRGlydHk9ITAsdGhpcy5fbW9ycGhUYXJnZXRDb3VudD10aGlzLl9jb2xsZWN0TW9ycGhUYXJnZXREYXRhLm10Q291bnQsdGhpcy5fdG90YWxWZXJ0ZXhDb3VudD10aGlzLl9jb2xsZWN0TW9ycGhUYXJnZXREYXRhLnZDb3VudCx0aGlzLl9tb3JwaEluZmx1ZW5jZUFycmF5LmZpbGwoMCksdGhpcy5fY29tcHV0ZVdvcmtHcm91cFhZPXRoaXMuY2FsY1dvcmtHcm91cCh0aGlzLl90b3RhbFZlcnRleENvdW50KSx0aGlzLl9wb3NpdGlvbkF0dHJEYXRhR3JvdXAucmVzZXQodGhpcy5fY29sbGVjdE1vcnBoVGFyZ2V0RGF0YS5tZXJnZWRQb3MpLHRoaXMuX25vcm1hbEF0dHJEYXRhR3JvdXAucmVzZXQodGhpcy5fY29sbGVjdE1vcnBoVGFyZ2V0RGF0YS5tZXJnZWROb3JtYWwpfWFwcGx5UmVuZGVyU2hhZGVyKGUpe3RoaXMudXBsb2FkTW9ycGhUYXJnZXRCdWZmZXIoKSx0aGlzLnVwbG9hZENvbmZpZ0dCdWZmZXIoKSxlLnNldFVuaWZvcm1CdWZmZXIoXCJtb3JwaFRhcmdldENvbmZpZ1wiLHRoaXMuX2NvbXB1dGVDb25maWdCdWZmZXIpLGUuc2V0U3RvcmFnZUJ1ZmZlcihcIm1vcnBoVGFyZ2V0T3BQb3NpdGlvbnNcIix0aGlzLl9wb3NpdGlvbkF0dHJEYXRhR3JvdXAub3V0cHV0KSx0aGlzLl9jb2xsZWN0TW9ycGhUYXJnZXREYXRhLm1lcmdlZE5vcm1hbCYmZS5zZXRTdG9yYWdlQnVmZmVyKFwibW9ycGhUYXJnZXRPcE5vcm1hbHNcIix0aGlzLl9ub3JtYWxBdHRyRGF0YUdyb3VwLm91dHB1dCl9Y29tcHV0ZU1vcnBoVGFyZ2V0KGUpe3RoaXMudXBsb2FkQ29uZmlnR0J1ZmZlcigpLHRoaXMudXBsb2FkTW9ycGhUYXJnZXRCdWZmZXIoKSx0aGlzLl9jb21wdXRlU2hhZGVyLnNldFVuaWZvcm1CdWZmZXIoXCJtb3JwaFRhcmdldENvbmZpZ1wiLHRoaXMuX2NvbXB1dGVDb25maWdCdWZmZXIpLHRoaXMuX2NvbXB1dGVTaGFkZXIuc2V0U3RvcmFnZUJ1ZmZlcihcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlXCIsdGhpcy5fbW9ycGhJbmZsdWVuY2VCdWZmZXIpLHRoaXMuX2NvbXB1dGVTaGFkZXIuc2V0U3RvcmFnZUJ1ZmZlcihcIm1vcnBoVGFyZ2V0UG9zaXRpb25zXCIsdGhpcy5fcG9zaXRpb25BdHRyRGF0YUdyb3VwLmlucHV0KSx0aGlzLl9jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VCdWZmZXIoXCJtb3JwaFRhcmdldE9wUG9zaXRpb25zXCIsdGhpcy5fcG9zaXRpb25BdHRyRGF0YUdyb3VwLm91dHB1dCksdGhpcy5fY29sbGVjdE1vcnBoVGFyZ2V0RGF0YS5tZXJnZWROb3JtYWwmJih0aGlzLl9jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VCdWZmZXIoXCJtb3JwaFRhcmdldE5vcm1hbHNcIix0aGlzLl9ub3JtYWxBdHRyRGF0YUdyb3VwLmlucHV0KSx0aGlzLl9jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VCdWZmZXIoXCJtb3JwaFRhcmdldE9wTm9ybWFsc1wiLHRoaXMuX25vcm1hbEF0dHJEYXRhR3JvdXAub3V0cHV0KSksdGhpcy5fY29tcHV0ZVNoYWRlci53b3JrZXJTaXplWD10aGlzLl9jb21wdXRlV29ya0dyb3VwWFksdGhpcy5fY29tcHV0ZVNoYWRlci53b3JrZXJTaXplWT10aGlzLl9jb21wdXRlV29ya0dyb3VwWFksdGhpcy5fY29tcHV0ZVNoYWRlci53b3JrZXJTaXplWj0xLHcuY29tcHV0ZUNvbW1hbmQoZSx0aGlzLl9jb21wdXRlU2hhZGVycyl9dXBkYXRlSW5mbHVlbmNlKGUsdCl7dGhpcy5faXNJbmZsdWVuY2VEaXJ0eT0hMCx0aGlzLl9tb3JwaEluZmx1ZW5jZUFycmF5W2VdPXR9Y29sbGVjdE1vcnBoVGFyZ2V0TGlzdChlKXtsZXQgdD10aGlzLmNvbGxlY3RBdHRyaWJ1dGUoXCJhX21vcnBoUG9zaXRpb25zX1wiLGUpLHI9dC5sZW5ndGgscz10WzBdLmRhdGEubGVuZ3RoLzMsYT1uZXcgRmxvYXQzMkFycmF5KHMqciozKTt7bGV0IGg9MDtmb3IobGV0IHU9MDt1PHI7dSsrKXtsZXQgYz10W3VdO2Euc2V0KGMuZGF0YSxoKSxoKz1jLmRhdGEubGVuZ3RofX1sZXQgbj10aGlzLmNvbGxlY3RBdHRyaWJ1dGUoXCJhX21vcnBoTm9ybWFsc19cIixlKSxsO2lmKG4mJm4ubGVuZ3RoPjApe2xldCBoPTA7bD1uZXcgRmxvYXQzMkFycmF5KHMqciozKTtmb3IobGV0IHU9MDt1PHI7dSsrKXtsZXQgYz1uW3VdO2wuc2V0KGMuZGF0YSxoKSxoKz1jLmRhdGEubGVuZ3RofX1yZXR1cm57bXRDb3VudDpyLHZDb3VudDpzLG1lcmdlZFBvczphLG1lcmdlZE5vcm1hbDpsfX1jb2xsZWN0QXR0cmlidXRlKGUsdCl7bGV0IHI9W107Zm9yKGxldCBzPTA7czx0aGlzLk1heE1vcnBoVGFyZ2V0Q291bnQ7cysrKXtsZXQgYT1lK3Msbj10LmdldEF0dHJpYnV0ZShhKTtpZihuKXJbc109bjtlbHNlIGJyZWFrfXJldHVybiByfXVwbG9hZENvbmZpZ0dCdWZmZXIoKXtpZih0aGlzLl9pc0luZmx1ZW5jZURpcnR5KXtsZXQgZT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fbW9ycGhUYXJnZXRDb3VudDt0KyspZSs9dGhpcy5fbW9ycGhJbmZsdWVuY2VBcnJheVt0XTt0aGlzLl9tb3JwaEluZmx1ZW5jZUJ1ZmZlci5zZXRGbG9hdDMyQXJyYXkoXCJkYXRhXCIsdGhpcy5fbW9ycGhJbmZsdWVuY2VBcnJheSksdGhpcy5fbW9ycGhJbmZsdWVuY2VCdWZmZXIuYXBwbHkoKSx0aGlzLl9jb21wdXRlQ29uZmlnQXJyYXlbMF09dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZT8xOjEtZSx0aGlzLl9jb21wdXRlQ29uZmlnQXJyYXlbMV09dGhpcy5fbW9ycGhUYXJnZXRDb3VudCx0aGlzLl9jb21wdXRlQ29uZmlnQXJyYXlbMl09dGhpcy5fdG90YWxWZXJ0ZXhDb3VudCx0aGlzLl9jb21wdXRlQ29uZmlnQXJyYXlbM109dGhpcy5fY29tcHV0ZVdvcmtHcm91cFhZLHRoaXMuX2NvbXB1dGVDb25maWdCdWZmZXIuc2V0RmxvYXQzMkFycmF5KFwiZGF0YVwiLHRoaXMuX2NvbXB1dGVDb25maWdBcnJheSksdGhpcy5fY29tcHV0ZUNvbmZpZ0J1ZmZlci5hcHBseSgpLHRoaXMuX2lzSW5mbHVlbmNlRGlydHk9ITF9fWNhbGNXb3JrR3JvdXAoZSl7bGV0IHQ9TWF0aC5jZWlsKE1hdGguc3FydChlKSkscj1NYXRoLmNlaWwoTWF0aC5sb2cyKHQpKTtyZXR1cm4gdD1NYXRoLnBvdygyLHIpLHR9dXBsb2FkTW9ycGhUYXJnZXRCdWZmZXIoKXt0aGlzLl9wb3NpdGlvbkF0dHJEYXRhR3JvdXAub3V0cHV0fHx0aGlzLl9wb3NpdGlvbkF0dHJEYXRhR3JvdXAuYXBwbHkodGhpcy5fdG90YWxWZXJ0ZXhDb3VudCksdGhpcy5fbm9ybWFsQXR0ckRhdGFHcm91cC5vdXRwdXR8fHRoaXMuX25vcm1hbEF0dHJEYXRhR3JvdXAuYXBwbHkodGhpcy5fdG90YWxWZXJ0ZXhDb3VudCl9Z2VuZXJhdGVHUFVCdWZmZXIoKXt0aGlzLl9jb21wdXRlQ29uZmlnQXJyYXk9bmV3IEZsb2F0MzJBcnJheSg0KSx0aGlzLl9jb21wdXRlQ29uZmlnQnVmZmVyPW5ldyBEdCg0KSx0aGlzLl9tb3JwaEluZmx1ZW5jZUFycmF5PW5ldyBGbG9hdDMyQXJyYXkodGhpcy5NYXhNb3JwaFRhcmdldENvdW50KTtsZXQgZT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUO3RoaXMuX21vcnBoSW5mbHVlbmNlQnVmZmVyPW5ldyBnZSh0aGlzLk1heE1vcnBoVGFyZ2V0Q291bnQsZSl9fXZhciBYZD1PYmplY3QuZGVmaW5lUHJvcGVydHksV2Q9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixPcz0oaSxlLHQscik9Pntmb3IodmFyIHM9cj4xP3ZvaWQgMDpyP1dkKGUsdCk6ZSxhPWkubGVuZ3RoLTEsbjthPj0wO2EtLSkobj1pW2FdKSYmKHM9KHI/bihlLHQscyk6bihzKSl8fHMpO3JldHVybiByJiZzJiZYZChlLHQscyksc307Y29uc3QgWGw9Y2xhc3MgZXh0ZW5kcyAkdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwicmVjZWl2ZVNoYWRvd1wiKSxvKHRoaXMsXCJtb3JwaERhdGFcIil9b25FbmFibGUoKXtzdXBlci5vbkVuYWJsZSgpfW9uRGlzYWJsZSgpe3N1cGVyLm9uRGlzYWJsZSgpfWNsb25lVG8oaSl7aS5hZGRDb21wb25lbnQoWGwpLmNvcHlDb21wb25lbnQodGhpcyl9Y29weUNvbXBvbmVudChpKXtyZXR1cm4gc3VwZXIuY29weUNvbXBvbmVudChpKSx0aGlzLnJlY2VpdmVTaGFkb3c9aS5yZWNlaXZlU2hhZG93LHRoaXN9Z2V0IGdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuX2dlb21ldHJ5fXNldCBnZW9tZXRyeShpKXtzdXBlci5nZW9tZXRyeT1pO2xldCBlPWkubW9ycGhUYXJnZXREaWN0aW9uYXJ5IT1udWxsO2UmJih0aGlzLm1vcnBoRGF0YXx8KHRoaXMubW9ycGhEYXRhPW5ldyBZbCksdGhpcy5tb3JwaERhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU9aS5tb3JwaFRhcmdldHNSZWxhdGl2ZSx0aGlzLm1vcnBoRGF0YS5pbml0TW9ycGhUYXJnZXQoaSkpLHRoaXMubW9ycGhEYXRhJiYodGhpcy5tb3JwaERhdGEuZW5hYmxlPWUpLHRoaXMubW9ycGhEYXRhJiZ0aGlzLm1vcnBoRGF0YS5lbmFibGU/dGhpcy5hZGRSZW5kZXJlck1hc2soVWUuTW9ycGhUYXJnZXQpOnRoaXMucmVtb3ZlUmVuZGVyZXJNYXNrKFVlLk1vcnBoVGFyZ2V0KSx0aGlzLm9iamVjdDNELmJvdW5kPXRoaXMuX2dlb21ldHJ5LmJvdW5kcy5jbG9uZSgpLHRoaXMuX3JlYWR5UGlwZWxpbmUmJnRoaXMuaW5pdFBpcGVsaW5lKCl9Z2V0IG1hdGVyaWFsKCl7cmV0dXJuIHRoaXMuX21hdGVyaWFsc1swXX1zZXQgbWF0ZXJpYWwoaSl7dGhpcy5tYXRlcmlhbHM9W2ldfXNldE1vcnBoSW5mbHVlbmNlKGksZSl7aWYodGhpcy5tb3JwaERhdGEmJnRoaXMubW9ycGhEYXRhLmVuYWJsZSl7bGV0IHQ9dGhpcy5fZ2VvbWV0cnkubW9ycGhUYXJnZXREaWN0aW9uYXJ5W2ldO3Q+PTAmJnRoaXMubW9ycGhEYXRhLnVwZGF0ZUluZmx1ZW5jZSh0LGUpfX1zZXRNb3JwaEluZmx1ZW5jZUluZGV4KGksZSl7dGhpcy5tb3JwaERhdGEmJnRoaXMubW9ycGhEYXRhLmVuYWJsZSYmaT49MCYmdGhpcy5tb3JwaERhdGEudXBkYXRlSW5mbHVlbmNlKGksZSl9b25Db21wdXRlKGksZSl7dGhpcy5tb3JwaERhdGEmJnRoaXMubW9ycGhEYXRhLmVuYWJsZSYmdGhpcy5tb3JwaERhdGEuY29tcHV0ZU1vcnBoVGFyZ2V0KGUpfW5vZGVVcGRhdGUoaSxlLHQscil7aWYodGhpcy5tb3JwaERhdGEmJnRoaXMubW9ycGhEYXRhLmVuYWJsZSlmb3IobGV0IHM9MDtzPHRoaXMubWF0ZXJpYWxzLmxlbmd0aDtzKyspe2xldCBuPXRoaXMubWF0ZXJpYWxzW3NdLmdldFBhc3MoZSk7aWYobilmb3IobGV0IGw9MDtsPG4ubGVuZ3RoO2wrKyl0aGlzLm1vcnBoRGF0YS5hcHBseVJlbmRlclNoYWRlcihuW2xdKX1zdXBlci5ub2RlVXBkYXRlKGksZSx0LHIpfWRlc3Ryb3koaSl7c3VwZXIuZGVzdHJveShpKX19O2xldCBjZT1YbDtPcyhbVnRdLGNlLnByb3RvdHlwZSxcImdlb21ldHJ5XCIsMSksT3MoW1Z0XSxjZS5wcm90b3R5cGUsXCJnZW9tZXRyeVwiLDEpLE9zKFtWdF0sY2UucHJvdG90eXBlLFwibWF0ZXJpYWxcIiwxKSxPcyhbVnRdLGNlLnByb3RvdHlwZSxcIm1hdGVyaWFsXCIsMSk7Y2xhc3MgV2x7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJsYWJlbFwiLFwiXCIpLG8odGhpcyxcImN1c3RvbVNpemVcIiwhMSksbyh0aGlzLFwielByZVRleHR1cmVcIixudWxsKSxvKHRoaXMsXCJkZXB0aFRleHR1cmVcIixudWxsKSxvKHRoaXMsXCJvdXRBdHRhY2htZW50c1wiKSxvKHRoaXMsXCJvdXRDb2xvclwiLC0xKSxvKHRoaXMsXCJyZW5kZXJUYXJnZXRzXCIpLG8odGhpcyxcInJ0VGV4dHVyZURlc2NyaXB0c1wiKSxvKHRoaXMsXCJpcnJhZGlhbmNlQnVmZmVyXCIpLG8odGhpcyxcIm11bHRpc2FtcGxlXCIsMCksbyh0aGlzLFwibXVsdGlUZXh0dXJlXCIpLG8odGhpcyxcImRlcHRoVmlld0luZGV4XCIsMCksbyh0aGlzLFwiZGVwdGhDbGVhblZhbHVlXCIsMCksbyh0aGlzLFwiaXNPdXRUYXJnZXRcIiwhMCksbyh0aGlzLFwiY2FtZXJhM0RcIiksbyh0aGlzLFwicnRGcmFtZVwiKSxvKHRoaXMsXCJyZW5kZXJQYXNzRGVzY3JpcHRvclwiKSxvKHRoaXMsXCJyZW5kZXJCdW5kbGVFbmNvZGVyRGVzY3JpcHRvclwiKSxvKHRoaXMsXCJkZXB0aExvYWRPcFwiKX1nZXRMYXN0UmVuZGVyVGV4dHVyZSgpe3JldHVybiB0aGlzLnJlbmRlclRhcmdldHMmJnRoaXMucmVuZGVyVGFyZ2V0cy5sZW5ndGg+MD90aGlzLnJlbmRlclRhcmdldHNbMF06QS5yZXMucmVkVGV4dHVyZX19Y29uc3QgcXI9Y2xhc3N7c3RhdGljIGNyZWF0ZVJlbmRlcmVyUGFzc1N0YXRlKGksZT1udWxsKXtsZXQgdD1uZXcgV2w7aWYodC5sYWJlbD1pLmxhYmVsLHQuY3VzdG9tU2l6ZT1pLmN1c3RvbVNpemUsdC5ydEZyYW1lPWksdC56UHJlVGV4dHVyZT1pLnpQcmVUZXh0dXJlLHQuZGVwdGhUZXh0dXJlPWkuZGVwdGhUZXh0dXJlLHQuZGVwdGhWaWV3SW5kZXg9aS5kZXB0aFZpZXdJbmRleCx0LmlzT3V0VGFyZ2V0PWkuaXNPdXRUYXJnZXQsdC5kZXB0aENsZWFuVmFsdWU9aS5kZXB0aENsZWFuVmFsdWUsdC5kZXB0aExvYWRPcD1pLmRlcHRoTG9hZE9wLGkmJmkuYXR0YWNobWVudHMubGVuZ3RoPjApe3QucmVuZGVyVGFyZ2V0cz1pLmF0dGFjaG1lbnRzLHQucnRUZXh0dXJlRGVzY3JpcHRzPWkucnREZXNjcmlwdG9ycyx0LnJlbmRlclBhc3NEZXNjcmlwdG9yPXFyLmdldFJlbmRlclBhc3NEZXNjcmlwdG9yKHQpLHQucmVuZGVyQnVuZGxlRW5jb2RlckRlc2NyaXB0b3I9cXIuZ2V0UmVuZGVyQnVuZGxlRGVzY3JpcHRvcih0KSx0Lm91dEF0dGFjaG1lbnRzPVtdO2ZvcihsZXQgcj0wO3I8aS5hdHRhY2htZW50cy5sZW5ndGg7cisrKXtjb25zdCBzPWkuYXR0YWNobWVudHNbcl07dC5vdXRBdHRhY2htZW50c1tyXT17Zm9ybWF0OnMuZm9ybWF0fSxzLm5hbWUuaW5kZXhPZihBZS5jb2xvckJ1ZmZlclRleF9OQU1FKSE9LTEmJih0Lm91dENvbG9yPXIpfX1lbHNlIHQucmVuZGVyUGFzc0Rlc2NyaXB0b3I9cXIuZ2V0UmVuZGVyUGFzc0Rlc2NyaXB0b3IodCxlKSx0LnJlbmRlckJ1bmRsZUVuY29kZXJEZXNjcmlwdG9yPXFyLmdldFJlbmRlckJ1bmRsZURlc2NyaXB0b3IodCksdC5vdXRBdHRhY2htZW50cz1be2Zvcm1hdDpTLnByZXNlbnRhdGlvbkZvcm1hdH1dLHQub3V0Q29sb3I9MDtyZXR1cm4gdH1zdGF0aWMgZ2V0UmVuZGVyUGFzc0Rlc2NyaXB0b3IoaSxlPW51bGwpe1MuZGV2aWNlLFMucHJlc2VudGF0aW9uU2l6ZTtsZXQgdD1bXTtpZihpLnJlbmRlclRhcmdldHMmJmkucmVuZGVyVGFyZ2V0cy5sZW5ndGg+MCl7aS5yZW5kZXJUYXJnZXRzWzBdLndpZHRoLGkucmVuZGVyVGFyZ2V0c1swXS5oZWlnaHQ7Zm9yKGxldCBzPTA7czxpLnJlbmRlclRhcmdldHMubGVuZ3RoO3MrKyl7Y29uc3QgYT1pLnJlbmRlclRhcmdldHNbc10sbj1pLnJ0VGV4dHVyZURlc2NyaXB0c1tzXTt0LnB1c2goe3ZpZXc6YS5nZXRHUFVWaWV3KCkscmVzb2x2ZVRhcmdldDp2b2lkIDAsbG9hZE9wOm4ubG9hZE9wLGNsZWFyVmFsdWU6bi5jbGVhclZhbHVlLHN0b3JlT3A6bi5zdG9yZU9wfSl9fWVsc2UgaWYoIWkuY3VzdG9tU2l6ZSl7bGV0IHM9Uy5jYW52YXNDb25maWcmJlMuY2FudmFzQ29uZmlnLmFscGhhP1sxLDEsMSwwXTpbMCwwLDAsMV07aS5pc091dFRhcmdldD09ITAmJnQucHVzaCh7dmlldzp2b2lkIDAscmVzb2x2ZVRhcmdldDp2b2lkIDAsbG9hZE9wOlMuY2FudmFzQ29uZmlnJiZTLmNhbnZhc0NvbmZpZy5hbHBoYXx8ZSE9bnVsbD9cImxvYWRcIjpcImNsZWFyXCIsY2xlYXJWYWx1ZTpzLHN0b3JlT3A6XCJzdG9yZVwifSl9bGV0IHI9bnVsbDtyZXR1cm4gaS5kZXB0aFRleHR1cmV8fGkuelByZVRleHR1cmU/KGkuelByZVRleHR1cmUmJihpLmRlcHRoVGV4dHVyZT1pLnpQcmVUZXh0dXJlKSxyPXtsYWJlbDpgJHtpLmxhYmVsfSByZW5kZXJQYXNzRGVzY3JpcHRvciB6UHJlVGV4dHVyZSR7aS56UHJlVGV4dHVyZT9cImxvYWRcIjpcImNsZWFyXCJ9YCxjb2xvckF0dGFjaG1lbnRzOnQsZGVwdGhTdGVuY2lsQXR0YWNobWVudDp7dmlldzppLmRlcHRoVGV4dHVyZS5nZXRHUFVWaWV3KCksZGVwdGhMb2FkT3A6aS56UHJlVGV4dHVyZT9cImxvYWRcIjppLmRlcHRoTG9hZE9wLGRlcHRoQ2xlYXJWYWx1ZTppLnpQcmVUZXh0dXJlPzE6aS5kZXB0aENsZWFuVmFsdWUsZGVwdGhTdG9yZU9wOlwic3RvcmVcIn19KTpyPXtjb2xvckF0dGFjaG1lbnRzOnQsbGFiZWw6XCJyZW5kZXJQYXNzRGVzY3JpcHRvciBub3Qgd3JpdGVEZXB0aFwifSx0aGlzLnJlbmRlclBhc3NEZXNjcmlwdG9yQ291bnQrKyxyfXN0YXRpYyBnZXRSZW5kZXJCdW5kbGVEZXNjcmlwdG9yKGkpe1MucHJlc2VudGF0aW9uU2l6ZTtsZXQgZT1bXTtpZihpLnJlbmRlclRhcmdldHMmJmkucmVuZGVyVGFyZ2V0cy5sZW5ndGg+MCl7aS5yZW5kZXJUYXJnZXRzWzBdLndpZHRoLGkucmVuZGVyVGFyZ2V0c1swXS5oZWlnaHQ7Zm9yKGxldCByPTA7cjxpLnJlbmRlclRhcmdldHMubGVuZ3RoO3IrKyl7Y29uc3Qgcz1pLnJlbmRlclRhcmdldHNbcl07ZS5wdXNoKHMuZm9ybWF0KX19bGV0IHQ9bnVsbDtyZXR1cm4gaS5kZXB0aFRleHR1cmU/dD17Y29sb3JGb3JtYXRzOmUsZGVwdGhTdGVuY2lsRm9ybWF0OmkuZGVwdGhUZXh0dXJlLmZvcm1hdH06dD17Y29sb3JGb3JtYXRzOmV9LHRoaXMucmVuZGVyUGFzc0Rlc2NyaXB0b3JDb3VudCsrLHR9fTtsZXQgSGU9cXI7byhIZSxcImJpbmRHcm91cERlc2NyaXB0b3JDb3VudFwiLDApLG8oSGUsXCJiaW5kVGV4dHVyZURlc2NyaXB0b3JDb3VudFwiLDApLG8oSGUsXCJyZW5kZXJQYXNzRGVzY3JpcHRvckNvdW50XCIsMCksbyhIZSxcInBpcGVsaW5lRGVzY3JpcHRvckNvdW50XCIsMCk7dmFyIFk9KGk9PihpLnBvc2l0aW9uPVwicG9zaXRpb25cIixpLm5vcm1hbD1cIm5vcm1hbFwiLGkudXY9XCJ1dlwiLGkuVEFOR0VOVD1cIlRBTkdFTlRcIixpLlRFWENPT1JEXzE9XCJURVhDT09SRF8xXCIsaS5URVhDT09SRF8yPVwiVEVYQ09PUkRfMlwiLGkuY29sb3I9XCJjb2xvclwiLGkuam9pbnRzMD1cImpvaW50czBcIixpLmpvaW50czE9XCJqb2ludHMxXCIsaS53ZWlnaHRzMD1cIndlaWdodHMwXCIsaS53ZWlnaHRzMT1cIndlaWdodHMxXCIsaS53ZWlnaHQ9XCJ3ZWlnaHRcIixpLmluZGljZXM9XCJpbmRpY2VzXCIsaS52SW5kZXg9XCJ2SW5kZXhcIixpLmFfbW9ycGhQb3NpdGlvbnNfMD1cImFfbW9ycGhQb3NpdGlvbnNfMFwiLGkpKShZfHx7fSk7Y2xhc3MgaG8gZXh0ZW5kcyBKdHtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcIm5vZGVcIiksdGhpcy5idWZmZXJUeXBlPU10LlZlcnRleEdQVUJ1ZmZlcix0aGlzLmNyZWF0ZVZlcnRleEJ1ZmZlcihHUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCxlKX1jcmVhdGVWZXJ0ZXhCdWZmZXIoZSx0KXtsZXQgcj1TLmRldmljZTt0aGlzLmJ5dGVTaXplPXQqRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULHRoaXMudXNhZ2U9ZSx0aGlzLmJ1ZmZlciYmdGhpcy5kZXN0cm95KCksdGhpcy5idWZmZXI9ci5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5ieXRlU2l6ZSx1c2FnZTplLG1hcHBlZEF0Q3JlYXRpb246ITF9KSx0aGlzLm1lbW9yeS5hbGxvY2F0aW9uKHRoaXMuYnl0ZVNpemUpLHRoaXMubm9kZT10aGlzLm1lbW9yeS5hbGxvY2F0aW9uX25vZGUodGhpcy5ieXRlU2l6ZSl9fXZhciB0aT0oaT0+KGlbaS5zcGxpdD0wXT1cInNwbGl0XCIsaVtpLmNvbXBvc2U9MV09XCJjb21wb3NlXCIsaSkpKHRpfHx7fSk7Y2xhc3Mgamx7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJ2ZXJ0ZXhDb3VudFwiLDApLG8odGhpcyxcInZlcnRleEdQVUJ1ZmZlclwiKSxvKHRoaXMsXCJnZW9tZXRyeVR5cGVcIix0aS5jb21wb3NlKSxvKHRoaXMsXCJfdmVydGV4QnVmZmVyTGF5b3V0c1wiKSxvKHRoaXMsXCJfYXR0cmlidXRlU2xvdExheW91dHNcIiksbyh0aGlzLFwiX2F0dHJpYnV0ZUxvY2F0aW9uXCIpLHRoaXMuX3ZlcnRleEJ1ZmZlckxheW91dHM9W10sdGhpcy5fYXR0cmlidXRlTG9jYXRpb249e30sdGhpcy5fYXR0cmlidXRlU2xvdExheW91dHM9W119Z2V0IHZlcnRleEJ1ZmZlckxheW91dHMoKXtyZXR1cm4gdGhpcy5fdmVydGV4QnVmZmVyTGF5b3V0c31jcmVhdGVWZXJ0ZXhCdWZmZXIoZSx0KXtzd2l0Y2godGhpcy5nZW9tZXRyeVR5cGUpe2Nhc2UgdGkuc3BsaXQ6dGhpcy5jcmVhdGVTcGxpdFZlcnRleEJ1ZmZlcihlLHQpO2JyZWFrO2Nhc2UgdGkuY29tcG9zZTp0aGlzLmNyZWF0ZUNvbXBvc2VWZXJ0ZXhCdWZmZXIoZSx0KTticmVha319Y3JlYXRlU3BsaXRWZXJ0ZXhCdWZmZXIoZSx0KXtsZXQgcj0wO2ZvcihsZXQgcz0wO3M8dC5hdHRyaWJ1dGVzLmxlbmd0aDtzKyspe2NvbnN0IGE9dC5hdHRyaWJ1dGVzW3NdO2lmKGEubmFtZT09XCJpbmRleFwiKWNvbnRpbnVlO3RoaXMuX2F0dHJpYnV0ZUxvY2F0aW9uW2EubmFtZV09YS5sb2NhdGlvbjtsZXQgbj17bmFtZTphLm5hbWUsZm9ybWF0OmEuZm9ybWF0LG9mZnNldDowLHNoYWRlckxvY2F0aW9uOmEubG9jYXRpb24sc3RyaWRlOmJpW2EuZm9ybWF0XX07dGhpcy5fYXR0cmlidXRlU2xvdExheW91dHNbYS5sb2NhdGlvbl09W25dO2xldCBsPWUuZ2V0KGEubmFtZSk7bHx8KGw9e2F0dHJpYnV0ZTphLm5hbWUsZGF0YTpuZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSp0aGlzLnZlcnRleENvdW50KX0sZS5zZXQoYS5uYW1lLGwpKTtsZXQgaD1sLmRhdGEubGVuZ3RoL24uc3RyaWRlO3RoaXMudmVydGV4Q291bnQhPTAmJnRoaXMudmVydGV4Q291bnQhPWgmJmNvbnNvbGUuZXJyb3IoXCIgdmVydGV4IGNvdW50IG5vdCBtYXRjaCBhdHRyaWJ1dGUgY291bnRcIiksdGhpcy52ZXJ0ZXhDb3VudD1oLHRoaXMuX3ZlcnRleEJ1ZmZlckxheW91dHNbYS5sb2NhdGlvbl09e25hbWU6YS5uYW1lLGFycmF5U3RyaWRlOmEuc2l6ZSo0LHN0ZXBNb2RlOlwidmVydGV4XCIsYXR0cmlidXRlczp0aGlzLl9hdHRyaWJ1dGVTbG90TGF5b3V0c1thLmxvY2F0aW9uXSxvZmZzZXQ6cio0LHNpemU6dGhpcy52ZXJ0ZXhDb3VudCphLnNpemUqNH0scis9dGhpcy52ZXJ0ZXhDb3VudCphLnNpemV9dGhpcy52ZXJ0ZXhHUFVCdWZmZXI9bmV3IGhvKHIpfWNyZWF0ZUNvbXBvc2VWZXJ0ZXhCdWZmZXIoZSx0KXt0aGlzLl9hdHRyaWJ1dGVTbG90TGF5b3V0c1swXT1bXTtsZXQgcj0wO2ZvcihsZXQgcz0wO3M8dC5hdHRyaWJ1dGVzLmxlbmd0aDtzKyspe2NvbnN0IGE9dC5hdHRyaWJ1dGVzW3NdO2lmKGEubmFtZT09XCJpbmRleFwifHxhLnR5cGU9PVwiYnVpbHRpblwiKWNvbnRpbnVlO3RoaXMuX2F0dHJpYnV0ZUxvY2F0aW9uW2EubmFtZV09YS5sb2NhdGlvbjtsZXQgbj17bmFtZTphLm5hbWUsZm9ybWF0OmEuZm9ybWF0LG9mZnNldDpyKjQsc2hhZGVyTG9jYXRpb246YS5sb2NhdGlvbixzdHJpZGU6YmlbYS5mb3JtYXRdfTt0aGlzLl9hdHRyaWJ1dGVTbG90TGF5b3V0c1swXVthLmxvY2F0aW9uXT1uO2xldCBsPWUuZ2V0KGEubmFtZSk7bHx8KGw9e2F0dHJpYnV0ZTphLm5hbWUsZGF0YTpuZXcgRmxvYXQzMkFycmF5KGEuc2l6ZSp0aGlzLnZlcnRleENvdW50KX0sZS5zZXQoYS5uYW1lLGwpKTtsZXQgaD1sLmRhdGEubGVuZ3RoL24uc3RyaWRlO3RoaXMudmVydGV4Q291bnQhPTAmJnRoaXMudmVydGV4Q291bnQhPWgmJmNvbnNvbGUuZXJyb3IoXCIgdmVydGV4IGNvdW50IG5vdCBtYXRjaCBhdHRyaWJ1dGUgY291bnRcIiksdGhpcy52ZXJ0ZXhDb3VudD1oLHIrPWEuc2l6ZX10aGlzLl92ZXJ0ZXhCdWZmZXJMYXlvdXRzWzBdPXtuYW1lOlwiY29tcG9zZVN0cnVjdFwiLGFycmF5U3RyaWRlOnIqNCxzdGVwTW9kZTpcInZlcnRleFwiLGF0dHJpYnV0ZXM6dGhpcy5fYXR0cmlidXRlU2xvdExheW91dHNbMF0sb2Zmc2V0OjAsc2l6ZTp0aGlzLnZlcnRleENvdW50KnIqNH0sdGhpcy52ZXJ0ZXhHUFVCdWZmZXI9bmV3IGhvKHRoaXMudmVydGV4Q291bnQqcil9dXBsb2FkKGUsdCl7dmFyIHI7aWYodGhpcy52ZXJ0ZXhHUFVCdWZmZXIpe3N3aXRjaCh0aGlzLmdlb21ldHJ5VHlwZSl7Y2FzZSB0aS5zcGxpdDp7bGV0IHM9dGhpcy5fYXR0cmlidXRlTG9jYXRpb25bZV0sYT10aGlzLl92ZXJ0ZXhCdWZmZXJMYXlvdXRzW3NdO3RoaXMudmVydGV4R1BVQnVmZmVyLm5vZGUuc2V0RmxvYXQzMkFycmF5KGEub2Zmc2V0LzQsdC5kYXRhKX1icmVhaztjYXNlIHRpLmNvbXBvc2U6Zm9yKGxldCBzPTA7czx0aGlzLnZlcnRleENvdW50O3MrKyl7Y29uc3QgYT10aGlzLl9hdHRyaWJ1dGVTbG90TGF5b3V0c1swXVt0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbltlXV07Zm9yKGxldCBuPTA7bjxhLnN0cmlkZTtuKyspe2xldCBsPXQuZGF0YVtzKmEuc3RyaWRlK25dLGg9cyoodGhpcy5fdmVydGV4QnVmZmVyTGF5b3V0c1swXS5hcnJheVN0cmlkZS80KSthLm9mZnNldC80K247dGhpcy52ZXJ0ZXhHUFVCdWZmZXIubm9kZS5zZXRGbG9hdChsLGgpfX1icmVha30ocj10aGlzLnZlcnRleEdQVUJ1ZmZlcik9PW51bGx8fHIuYXBwbHkoKX19dXBkYXRlQXR0cmlidXRlcyhlKXtzd2l0Y2godGhpcy5nZW9tZXRyeVR5cGUpe2Nhc2UgdGkuc3BsaXQ6Zm9yKGxldCB0PTA7dDx0aGlzLl92ZXJ0ZXhCdWZmZXJMYXlvdXRzLmxlbmd0aDt0Kyspe2NvbnN0IHI9dGhpcy5fdmVydGV4QnVmZmVyTGF5b3V0c1t0XTtsZXQgcz1lLmdldChyLm5hbWUpO3RoaXMudmVydGV4R1BVQnVmZmVyLm5vZGUuc2V0RmxvYXQzMkFycmF5KHIub2Zmc2V0LzQscy5kYXRhKX1icmVhaztjYXNlIHRpLmNvbXBvc2U6Zm9yKGxldCB0PTA7dDx0aGlzLnZlcnRleENvdW50O3QrKyl0aGlzLl9hdHRyaWJ1dGVTbG90TGF5b3V0cy5mb3JFYWNoKHI9Pntmb3IobGV0IHM9MDtzPHIubGVuZ3RoO3MrKyl7Y29uc3QgYT1yW3NdO2xldCBuPWUuZ2V0KGEubmFtZSk7Zm9yKGxldCBsPTA7bDxhLnN0cmlkZTtsKyspe2xldCBoPW4uZGF0YVt0KmEuc3RyaWRlK2xdLHU9dCoodGhpcy5fdmVydGV4QnVmZmVyTGF5b3V0c1swXS5hcnJheVN0cmlkZS80KSthLm9mZnNldC80K2w7dGhpcy52ZXJ0ZXhHUFVCdWZmZXIubm9kZS5zZXRGbG9hdChoLHUpfX19KTticmVha310aGlzLnZlcnRleEdQVUJ1ZmZlci5hcHBseSgpfWNvbXB1dGUoKXt9ZGVzdHJveShlKXt0aGlzLnZlcnRleENvdW50PW51bGwsdGhpcy5nZW9tZXRyeVR5cGU9bnVsbCx0aGlzLl92ZXJ0ZXhCdWZmZXJMYXlvdXRzPW51bGwsdGhpcy5fYXR0cmlidXRlU2xvdExheW91dHM9bnVsbCx0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbj1udWxsLHRoaXMudmVydGV4R1BVQnVmZmVyJiZ0aGlzLnZlcnRleEdQVUJ1ZmZlci5kZXN0cm95KGUpLHRoaXMudmVydGV4R1BVQnVmZmVyPW51bGx9fWNsYXNzIHFsIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSxvKHRoaXMsXCJpbmRpY2VzTm9kZVwiKSx0aGlzLmJ1ZmZlclR5cGU9TXQuSW5kaWNlc0dQVUJ1ZmZlcix0aGlzLmNyZWF0ZUluZGljZXNCdWZmZXIoR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5JTkRFWHxHUFVCdWZmZXJVc2FnZS5JTkRJUkVDVCxlKX1jcmVhdGVJbmRpY2VzQnVmZmVyKGUsdCl7bGV0IHI9Uy5kZXZpY2U7dGhpcy5ieXRlU2l6ZT10Lmxlbmd0aCo0LHRoaXMudXNhZ2U9ZSx0aGlzLmJ1ZmZlciYmdGhpcy5kZXN0cm95KCksdGhpcy5idWZmZXI9ci5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5ieXRlU2l6ZSx1c2FnZTplLG1hcHBlZEF0Q3JlYXRpb246ITF9KSx0aGlzLm1lbW9yeS5hbGxvY2F0aW9uKHRoaXMuYnl0ZVNpemUpLHQmJih0aGlzLmluZGljZXNOb2RlPXRoaXMubWVtb3J5LmFsbG9jYXRpb25fbm9kZSh0Lmxlbmd0aCo0KSx0aGlzLmluZGljZXNOb2RlLnNldEFycmF5QnVmZmVyKDAsdCksdGhpcy5hcHBseSgpKX19Y2xhc3MgS2x7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJ1dWlkXCIsXCJcIiksbyh0aGlzLFwibmFtZVwiKSxvKHRoaXMsXCJpbmRpY2VzR1BVQnVmZmVyXCIpLG8odGhpcyxcImluZGljZXNGb3JtYXRcIixcInVpbnQxNlwiKSxvKHRoaXMsXCJpbmRpY2VzQ291bnRcIiwwKX1jcmVhdGVJbmRpY2VzQnVmZmVyKGUpe2UuZGF0YSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5P3RoaXMuaW5kaWNlc0Zvcm1hdD1cInVpbnQxNlwiOmUuZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5JiYodGhpcy5pbmRpY2VzRm9ybWF0PVwidWludDMyXCIpLHRoaXMuaW5kaWNlc0NvdW50PWUuZGF0YS5sZW5ndGgsdGhpcy5pbmRpY2VzR1BVQnVmZmVyPW5ldyBxbChlLmRhdGEpfXVwbG9hZChlKXt0aGlzLmluZGljZXNHUFVCdWZmZXIuaW5kaWNlc05vZGUuc2V0QXJyYXlCdWZmZXIoMCxlKSx0aGlzLmluZGljZXNHUFVCdWZmZXIuYXBwbHkoKX1jb21wdXRlKCl7fWRlc3Ryb3koKXt0aGlzLnV1aWQ9bnVsbCx0aGlzLm5hbWU9bnVsbCx0aGlzLmluZGljZXNGb3JtYXQ9bnVsbCx0aGlzLmluZGljZXNDb3VudD1udWxsLHRoaXMuaW5kaWNlc0dQVUJ1ZmZlci5kZXN0cm95KCksdGhpcy5pbmRpY2VzR1BVQnVmZmVyPW51bGx9fWNsYXNzIEpse2NvbnN0cnVjdG9yKCl7byh0aGlzLFwibG9kTGV2ZWxzXCIpfX1jb25zdCBUaT1jbGFzc3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcImluc3RhbmNlSURcIiksbyh0aGlzLFwibmFtZVwiKSxvKHRoaXMsXCJzdWJHZW9tZXRyaWVzXCIsW10pLG8odGhpcyxcIm1vcnBoVGFyZ2V0c1JlbGF0aXZlXCIpLG8odGhpcyxcIm1vcnBoVGFyZ2V0RGljdGlvbmFyeVwiKSxvKHRoaXMsXCJfYm91bmRzXCIpLG8odGhpcyxcIl9hdHRyaWJ1dGVNYXBcIiksbyh0aGlzLFwiX2F0dHJpYnV0ZXNcIiksbyh0aGlzLFwiX2luZGljZXNCdWZmZXJcIiksbyh0aGlzLFwiX3ZlcnRleEJ1ZmZlclwiKSxvKHRoaXMsXCJfb25DaGFuZ2VcIiwhMCksdGhpcy5pbnN0YW5jZUlEPVB0KCksdGhpcy5fYXR0cmlidXRlTWFwPW5ldyBNYXAsdGhpcy5fYXR0cmlidXRlcz1bXSx0aGlzLl92ZXJ0ZXhCdWZmZXI9bmV3IGpsfWdldCBpbmRpY2VzQnVmZmVyKCl7cmV0dXJuIHRoaXMuX2luZGljZXNCdWZmZXJ9Z2V0IHZlcnRleEJ1ZmZlcigpe3JldHVybiB0aGlzLl92ZXJ0ZXhCdWZmZXJ9Z2V0IHZlcnRleEF0dHJpYnV0ZXMoKXtyZXR1cm4gdGhpcy5fYXR0cmlidXRlc31nZXQgdmVydGV4QXR0cmlidXRlTWFwKCl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZU1hcH1nZXQgZ2VvbWV0cnlUeXBlKCl7cmV0dXJuIHRoaXMuX3ZlcnRleEJ1ZmZlci5nZW9tZXRyeVR5cGV9c2V0IGdlb21ldHJ5VHlwZShpKXt0aGlzLl92ZXJ0ZXhCdWZmZXIuZ2VvbWV0cnlUeXBlPWl9Z2V0IGJvdW5kcygpe2lmKCF0aGlzLl9ib3VuZHMpe3RoaXMuX2JvdW5kcz1uZXcgQmUobmV3IGcsbmV3IGcoMSwxLDEpKSx0aGlzLl9ib3VuZHMubWluLng9TnVtYmVyLk1BWF9WQUxVRSx0aGlzLl9ib3VuZHMubWluLnk9TnVtYmVyLk1BWF9WQUxVRSx0aGlzLl9ib3VuZHMubWluLno9TnVtYmVyLk1BWF9WQUxVRSx0aGlzLl9ib3VuZHMubWF4Lng9LU51bWJlci5NQVhfVkFMVUUsdGhpcy5fYm91bmRzLm1heC55PS1OdW1iZXIuTUFYX1ZBTFVFLHRoaXMuX2JvdW5kcy5tYXguej0tTnVtYmVyLk1BWF9WQUxVRTtsZXQgaT10aGlzLmdldEF0dHJpYnV0ZShZLnBvc2l0aW9uKTtpZihpKWZvcihsZXQgZT0wO2U8aS5kYXRhLmxlbmd0aC8zO2UrKyl7Y29uc3QgdD1pLmRhdGFbZSozKzBdLHI9aS5kYXRhW2UqMysxXSxzPWkuZGF0YVtlKjMrMl07dGhpcy5fYm91bmRzLm1pbi54PnQmJih0aGlzLl9ib3VuZHMubWluLng9dCksdGhpcy5fYm91bmRzLm1pbi55PnImJih0aGlzLl9ib3VuZHMubWluLnk9ciksdGhpcy5fYm91bmRzLm1pbi56PnMmJih0aGlzLl9ib3VuZHMubWluLno9cyksdGhpcy5fYm91bmRzLm1heC54PHQmJih0aGlzLl9ib3VuZHMubWF4Lng9dCksdGhpcy5fYm91bmRzLm1heC55PHImJih0aGlzLl9ib3VuZHMubWF4Lnk9ciksdGhpcy5fYm91bmRzLm1heC56PHMmJih0aGlzLl9ib3VuZHMubWF4Lno9cyl9dGhpcy5fYm91bmRzLnNldEZyb21NaW5NYXgodGhpcy5fYm91bmRzLm1pbix0aGlzLl9ib3VuZHMubWF4KX1yZXR1cm4gdGhpcy5fYm91bmRzfXNldCBib3VuZHMoaSl7dGhpcy5fYm91bmRzPWl9YWRkU3ViR2VvbWV0cnkoLi4uaSl7bGV0IGU9bmV3IEpsO2UubG9kTGV2ZWxzPWksdGhpcy5zdWJHZW9tZXRyaWVzLnB1c2goZSl9Z2VuZXJhdGUoaSl7dGhpcy5fb25DaGFuZ2UmJih0aGlzLl9vbkNoYW5nZT0hMSx0aGlzLl9pbmRpY2VzQnVmZmVyLnVwbG9hZCh0aGlzLmdldEF0dHJpYnV0ZShZLmluZGljZXMpLmRhdGEpLHRoaXMuX3ZlcnRleEJ1ZmZlci5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5fYXR0cmlidXRlTWFwLGkpLHRoaXMuX3ZlcnRleEJ1ZmZlci51cGRhdGVBdHRyaWJ1dGVzKHRoaXMuX2F0dHJpYnV0ZU1hcCkpfXNldEluZGljZXMoaSl7aWYoIXRoaXMuX2F0dHJpYnV0ZU1hcC5oYXMoWS5pbmRpY2VzKSl7bGV0IGU9e2F0dHJpYnV0ZTpZLmluZGljZXMsZGF0YTppfTt0aGlzLl9hdHRyaWJ1dGVNYXAuc2V0KFkuaW5kaWNlcyxlKSx0aGlzLl9pbmRpY2VzQnVmZmVyPW5ldyBLbCx0aGlzLl9pbmRpY2VzQnVmZmVyLmNyZWF0ZUluZGljZXNCdWZmZXIoZSl9fXNldEF0dHJpYnV0ZShpLGUpe2lmKGk9PVkuaW5kaWNlcyl0aGlzLnNldEluZGljZXMoZSk7ZWxzZXtsZXQgdD17YXR0cmlidXRlOmksZGF0YTplfTt0aGlzLl9hdHRyaWJ1dGVNYXAuc2V0KGksdCksdGhpcy5fYXR0cmlidXRlcy5wdXNoKGkpfX1nZXRBdHRyaWJ1dGUoaSl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZU1hcC5nZXQoaSl9aGFzQXR0cmlidXRlKGkpe3JldHVybiB0aGlzLl9hdHRyaWJ1dGVNYXAuaGFzKGkpfWdlbldpcmVmcmFtZSgpe2xldCBpPXRoaXMuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiksZT10aGlzLmdldEF0dHJpYnV0ZShcImluZGljZXNcIik7aWYoZSYmaSYmZS5kYXRhLmxlbmd0aD4wKXtsZXQgdD1pLmRhdGEscj1bXTtmb3IobGV0IHM9MDtzPGUuZGF0YS5sZW5ndGgvMztzKyspe2NvbnN0IGE9ZS5kYXRhW3MqMyswXSxuPWUuZGF0YVtzKjMrMV0sbD1lLmRhdGFbcyozKzJdO2xldCBoPW5ldyBnKHRbYSozKzBdLHRbYSozKzFdLHRbYSozKzJdKSx1PW5ldyBnKHRbbiozKzBdLHRbbiozKzFdLHRbbiozKzJdKSxjPW5ldyBnKHRbbCozKzBdLHRbbCozKzFdLHRbbCozKzJdKTtyLnB1c2goaCx1KSxyLnB1c2godSxjKSxyLnB1c2goYyxoKX1yZXR1cm4gcn1yZXR1cm4gbnVsbH1jb21wdXRlKCl7dGhpcy5faW5kaWNlc0J1ZmZlciYmdGhpcy5faW5kaWNlc0J1ZmZlci5jb21wdXRlKCksdGhpcy5fdmVydGV4QnVmZmVyJiZ0aGlzLl92ZXJ0ZXhCdWZmZXIuY29tcHV0ZSgpfWNvbXB1dGVOb3JtYWxzKCl7bGV0IGk9dGhpcy5nZXRBdHRyaWJ1dGUoWS5wb3NpdGlvbiksZT10aGlzLmdldEF0dHJpYnV0ZShZLm5vcm1hbCksdD10aGlzLmdldEF0dHJpYnV0ZShZLmluZGljZXMpO2lmKCFpfHwhZXx8IXQpcmV0dXJuIHRoaXM7bGV0IHI9dC5kYXRhLmxlbmd0aC8zLHM9VGkucG9pbnQxLGE9VGkucG9pbnQyLG49VGkucG9pbnQzLGw9VGkuY3Jvc3NBLGg9VGkuY3Jvc3NCLHU9VGkuY3Jvc3NSZXQ7Zm9yKGxldCBjPTA7YzxyO2MrKyl7bGV0IGY9dC5kYXRhW2MqM10sZD10LmRhdGFbYyozKzFdLHA9dC5kYXRhW2MqMysyXTtzLnNldChpLmRhdGFbZiozXSxpLmRhdGFbZiozKzFdLGkuZGF0YVtmKjMrMl0pLGEuc2V0KGkuZGF0YVtkKjNdLGkuZGF0YVtkKjMrMV0saS5kYXRhW2QqMysyXSksbi5zZXQoaS5kYXRhW3AqM10saS5kYXRhW3AqMysxXSxpLmRhdGFbcCozKzJdKSxnLnN1YihzLGEsbCkubm9ybWFsaXplKCksZy5zdWIocyxuLGgpLm5vcm1hbGl6ZSgpO2xldCBtPWwuY3Jvc3NQcm9kdWN0KGgsdSkubm9ybWFsaXplKCk7ZS5kYXRhW2YqM109ZS5kYXRhW2QqM109ZS5kYXRhW3AqM109bS54LGUuZGF0YVtmKjMrMV09ZS5kYXRhW2QqMysxXT1lLmRhdGFbcCozKzFdPW0ueSxlLmRhdGFbZiozKzJdPWUuZGF0YVtkKjMrMl09ZS5kYXRhW3AqMysyXT1tLnp9cmV0dXJuIHRoaXMuX3ZlcnRleEJ1ZmZlci51cGxvYWQoWS5ub3JtYWwsZSksdGhpc31pc1ByaW1pdGl2ZSgpe3JldHVybiExfWRlc3Ryb3koaSl7dGhpcy5pbnN0YW5jZUlEPW51bGwsdGhpcy5uYW1lPW51bGwsdGhpcy5zdWJHZW9tZXRyaWVzPW51bGwsdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnk9bnVsbCx0aGlzLl9ib3VuZHMuZGVzdHJveSgpLHRoaXMuX2JvdW5kcz1udWxsLHRoaXMuX2F0dHJpYnV0ZU1hcD1udWxsLHRoaXMuX2F0dHJpYnV0ZXM9bnVsbCx0aGlzLl9pbmRpY2VzQnVmZmVyLmRlc3Ryb3koKSx0aGlzLl92ZXJ0ZXhCdWZmZXIuZGVzdHJveSgpLHRoaXMuX2luZGljZXNCdWZmZXI9bnVsbCx0aGlzLl92ZXJ0ZXhCdWZmZXI9bnVsbH19O2xldCB0dD1UaTtvKHR0LFwiY3Jvc3NBXCIsZy5VUC5jbG9uZSgpKSxvKHR0LFwiY3Jvc3NCXCIsZy5VUC5jbG9uZSgpKSxvKHR0LFwiY3Jvc3NSZXRcIixnLlVQLmNsb25lKCkpLG8odHQsXCJwb2ludDFcIixnLlVQLmNsb25lKCkpLG8odHQsXCJwb2ludDJcIixnLlVQLmNsb25lKCkpLG8odHQsXCJwb2ludDNcIixnLlVQLmNsb25lKCkpO2NsYXNzIFpsIGV4dGVuZHMgdHR7Y29uc3RydWN0b3IoZSx0LHI9MSxzPTEsYT1nLllfQVhJUyl7c3VwZXIoKSxvKHRoaXMsXCJ3aWR0aFwiKSxvKHRoaXMsXCJoZWlnaHRcIiksbyh0aGlzLFwic2VnbWVudFdcIiksbyh0aGlzLFwic2VnbWVudEhcIiksbyh0aGlzLFwidXBcIiksdGhpcy53aWR0aD1lLHRoaXMuaGVpZ2h0PXQsdGhpcy5zZWdtZW50Vz1yLHRoaXMuc2VnbWVudEg9cyx0aGlzLnVwPWEsdGhpcy5idWlsZEdlb21ldHJ5KHRoaXMudXApfWJ1aWxkR2VvbWV0cnkoZSl7dmFyIHQscixzLGEsbj10aGlzLnNlZ21lbnRXKzE7KHRoaXMuc2VnbWVudEgrMSkqbix0aGlzLmJvdW5kcz1uZXcgQmUoZy5aRVJPLmNsb25lKCksbmV3IGcodGhpcy53aWR0aCwxLHRoaXMuaGVpZ2h0KSkscz10aGlzLnNlZ21lbnRIKnRoaXMuc2VnbWVudFcqNjtsZXQgbD0odGhpcy5zZWdtZW50VysxKSoodGhpcy5zZWdtZW50SCsxKSxoPW5ldyBGbG9hdDMyQXJyYXkobCozKSx1PW5ldyBGbG9hdDMyQXJyYXkobCozKSxjPW5ldyBGbG9hdDMyQXJyYXkobCoyKSxmO3RoaXMuc2VnbWVudFcqdGhpcy5zZWdtZW50SCoyKjM+PVVpbnQxNkFycmF5Lmxlbmd0aD9mPW5ldyBVaW50MzJBcnJheSh0aGlzLnNlZ21lbnRXKnRoaXMuc2VnbWVudEgqMiozKTpmPW5ldyBVaW50MTZBcnJheSh0aGlzLnNlZ21lbnRXKnRoaXMuc2VnbWVudEgqMiozKSxzPTA7Zm9yKHZhciBwPTAsbT0wLF89MCx2PTA7djw9dGhpcy5zZWdtZW50SDsrK3YpZm9yKHZhciB5PTA7eTw9dGhpcy5zZWdtZW50VzsrK3kpe3N3aXRjaCh0PSh5L3RoaXMuc2VnbWVudFctLjUpKnRoaXMud2lkdGgscj0odi90aGlzLnNlZ21lbnRILS41KSp0aGlzLmhlaWdodCxlKXtjYXNlIGcuWV9BWElTOmhbcCsrXT10LGhbcCsrXT0wLGhbcCsrXT1yLHVbbSsrXT0wLHVbbSsrXT0xLHVbbSsrXT0wO2JyZWFrO2Nhc2UgZy5aX0FYSVM6aFtwKytdPXQsaFtwKytdPS1yLGhbcCsrXT0wLHVbbSsrXT0wLHVbbSsrXT0wLHVbbSsrXT0xO2JyZWFrO2Nhc2UgZy5YX0FYSVM6aFtwKytdPTAsaFtwKytdPXQsaFtwKytdPXIsdVttKytdPTEsdVttKytdPTAsdVttKytdPTA7YnJlYWs7ZGVmYXVsdDpoW3ArK109dCxoW3ArK109MCxoW3ArK109cix1W20rK109MCx1W20rK109MSx1W20rK109MDticmVha31jW18rK109eS90aGlzLnNlZ21lbnRXLGNbXysrXT12L3RoaXMuc2VnbWVudEgseSE9dGhpcy5zZWdtZW50VyYmdiE9dGhpcy5zZWdtZW50SCYmKGE9eSt2Km4sZltzKytdPWErMSxmW3MrK109YSxmW3MrK109YStuLGZbcysrXT1hKzEsZltzKytdPWErbixmW3MrK109YStuKzEpfXRoaXMuc2V0SW5kaWNlcyhmKSx0aGlzLnNldEF0dHJpYnV0ZShZLnBvc2l0aW9uLGgpLHRoaXMuc2V0QXR0cmlidXRlKFkubm9ybWFsLHUpLHRoaXMuc2V0QXR0cmlidXRlKFkudXYsYyksdGhpcy5zZXRBdHRyaWJ1dGUoWS5URVhDT09SRF8xLGMpLHRoaXMuYWRkU3ViR2VvbWV0cnkoe2luZGV4U3RhcnQ6MCxpbmRleENvdW50OmYubGVuZ3RoLHZlcnRleFN0YXJ0OjAsaW5kZXg6MH0pfX1jbGFzcyBOcyBleHRlbmRzIHRle2NvbnN0cnVjdG9yKGU9XCJRdWFkR2xzbF92c1wiLHQ9XCJRdWFkR2xzbF9mc1wiLHIscyxhPTAsbj0hMSl7c3VwZXIoKSxvKHRoaXMsXCJ3aWR0aFwiLDEyOCksbyh0aGlzLFwiaGVpZ2h0XCIsMTI4KSxvKHRoaXMsXCJxdWFkUmVuZGVyZXJcIiksbyh0aGlzLFwibWF0ZXJpYWxcIiksbyh0aGlzLFwidW5pZm9ybXNcIiksbyh0aGlzLFwicmVuZGVyZXJQYXNzU3RhdGVcIiksbyh0aGlzLFwicGFzc1wiKTtsZXQgbD1yP3IuYXR0YWNobWVudHM6W107dGhpcy5tYXRlcmlhbD1uZXcgX2ksdGhpcy5wYXNzPW5ldyBXZShlLHQpLHRoaXMubWF0ZXJpYWwuYWRkUGFzcyhyZS5DT0xPUix0aGlzLnBhc3MpLHRoaXMucGFzcy5ibGVuZE1vZGU9eGUuTk9ORTtsZXQgaD10aGlzLnBhc3Muc2hhZGVyU3RhdGU7aC5mcm9udEZhY2U9XCJjd1wiLGguZGVwdGhXcml0ZUVuYWJsZWQ9ITEsaC5kZXB0aENvbXBhcmU9dnQuYWx3YXlzLGgubXVsdGlzYW1wbGU9YSx0aGlzLnVuaWZvcm1zPXRoaXMucGFzcy51bmlmb3Jtcz1zfHx7Y29sb3I6bmV3ICQobmV3IHopfSx0aGlzLnF1YWRSZW5kZXJlcj10aGlzLmFkZENvbXBvbmVudChjZSksdGhpcy5xdWFkUmVuZGVyZXIubWF0ZXJpYWw9dGhpcy5tYXRlcmlhbCx0aGlzLnF1YWRSZW5kZXJlci5jYXN0R0k9ITEsdGhpcy5xdWFkUmVuZGVyZXIuY2FzdFNoYWRvdz0hMSx0aGlzLnF1YWRSZW5kZXJlci5kcmF3VHlwZT1uPzI6MCx0aGlzLnF1YWRSZW5kZXJlci5nZW9tZXRyeT1uZXcgWmwoMTAwLDEwMCwxLDEpLHRoaXMuY29sb3JUZXh0dXJlPUEucmVzLmJsYWNrVGV4dHVyZSx0aGlzLnBhc3Muc2V0VW5pZm9ybUZsb2F0KFwieFwiLDApLHRoaXMucGFzcy5zZXRVbmlmb3JtRmxvYXQoXCJ5XCIsMCksdGhpcy5wYXNzLnNldFVuaWZvcm1GbG9hdChcIndpZHRoXCIsMTAwKSx0aGlzLnBhc3Muc2V0VW5pZm9ybUZsb2F0KFwiaGVpZ2h0XCIsMTAwKSx0aGlzLnF1YWRSZW5kZXJlci5tYXRlcmlhbD10aGlzLm1hdGVyaWFsLHRoaXMucXVhZFJlbmRlcmVyLl9fc3RhcnQoKSx0aGlzLnF1YWRSZW5kZXJlci5fZW5hYmxlPSEwLHRoaXMucXVhZFJlbmRlcmVyLm9uRW5hYmxlKCksdGhpcy5yZW5kZXJlclBhc3NTdGF0ZT1IZS5jcmVhdGVSZW5kZXJlclBhc3NTdGF0ZShyLFwibG9hZFwiKSxoLm11bHRpc2FtcGxlPjAmJih0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLm11bHRpc2FtcGxlPWgubXVsdGlzYW1wbGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZS5tdWx0aVRleHR1cmU9Uy5kZXZpY2UuY3JlYXRlVGV4dHVyZSh7c2l6ZTp7d2lkdGg6Uy5wcmVzZW50YXRpb25TaXplWzBdLGhlaWdodDpTLnByZXNlbnRhdGlvblNpemVbMV19LHNhbXBsZUNvdW50OmgubXVsdGlzYW1wbGUsZm9ybWF0OmwubGVuZ3RoPjA/bFswXS5mb3JtYXQ6Uy5wcmVzZW50YXRpb25Gb3JtYXQsdXNhZ2U6R1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UfSkpfXNldCBjb2xvclRleHR1cmUoZSl7dGhpcy5tYXRlcmlhbC5nZXRQYXNzKHJlLkNPTE9SKVswXS5zZXRUZXh0dXJlKFwiYmFzZU1hcFwiLGUpfXJlbmRlclRhcmdldChlLHQscil7bGV0IHM9ZS5jYW1lcmEsYT13LmJlZ2luUmVuZGVyUGFzcyhyLHQucmVuZGVyZXJQYXNzU3RhdGUpO3cuYmluZENhbWVyYShhLHMpLHQucXVhZFJlbmRlcmVyLm5vZGVVcGRhdGUoZSxyZS5DT0xPUix0LnJlbmRlcmVyUGFzc1N0YXRlLG51bGwpLHQucXVhZFJlbmRlcmVyLnJlbmRlclBhc3MyKGUscmUuQ09MT1IsdC5yZW5kZXJlclBhc3NTdGF0ZSxudWxsLGEpLHcuZW5kUGFzcyhhKX1yZW5kZXJUb1ZpZXdRdWFkKGUsdCxyLHMpe2xldCBhPWUuY2FtZXJhO3QuY29sb3JUZXh0dXJlPXM7bGV0IG49dy5iZWdpblJlbmRlclBhc3Mocix0LnJlbmRlcmVyUGFzc1N0YXRlKTt3LmJpbmRDYW1lcmEobixhKSx0LnF1YWRSZW5kZXJlci5ub2RlVXBkYXRlKGUscmUuQ09MT1IsdC5yZW5kZXJlclBhc3NTdGF0ZSxudWxsKSx0LnF1YWRSZW5kZXJlci5yZW5kZXJQYXNzMihlLHJlLkNPTE9SLHQucmVuZGVyZXJQYXNzU3RhdGUsbnVsbCxuKSx3LmVuZFBhc3Mobil9fWNsYXNzIG9lIGV4dGVuZHMgYXR7Y29uc3RydWN0b3IoZSx0LHI9Ry5yZ2JhOHVub3JtLHM9ITEsYSxuPTEsbD0wLGg9ITApe3N1cGVyKGUsdCxuKSxvKHRoaXMsXCJyZXNvbHZlVGFyZ2V0XCIpO2xldCB1PVMuZGV2aWNlO3RoaXMubmFtZT1QdCgpLGEhPW51bGw/dGhpcy51c2FnZT1hOnRoaXMudXNhZ2U9R1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UfEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDfEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCx0aGlzLmNyZWF0ZVRleHR1cmVEZXNjcmlwdG9yKGUsdCwxLHIsdGhpcy51c2FnZSxuLGwpLHRoaXMudXNlTWlwbWFwPSExLHRoaXMudmlzaWJpbGl0eT1HUFVTaGFkZXJTdGFnZS5DT01QVVRFfEdQVVNoYWRlclN0YWdlLlZFUlRFWHxHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxyPT1HLnJnYmEzMmZsb2F0Pyh0aGlzLnNhbXBsZXJCaW5kaW5nTGF5b3V0LnR5cGU9XCJub24tZmlsdGVyaW5nXCIsdGhpcy50ZXh0dXJlQmluZGluZ0xheW91dC5zYW1wbGVUeXBlPVwidW5maWx0ZXJhYmxlLWZsb2F0XCIsdGhpcy5ncHVTYW1wbGVyPXUuY3JlYXRlU2FtcGxlcih7fSkpOnI9PUcuZGVwdGgzMmZsb2F0Pyh0aGlzLnNhbXBsZXJCaW5kaW5nTGF5b3V0LnR5cGU9XCJmaWx0ZXJpbmdcIix0aGlzLnNhbXBsZXJfY29tcGFyaXNvbkJpbmRpbmdMYXlvdXQudHlwZT1cImNvbXBhcmlzb25cIix0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnNhbXBsZVR5cGU9XCJkZXB0aFwiLHRoaXMuZ3B1U2FtcGxlcj1TLmRldmljZS5jcmVhdGVTYW1wbGVyKHt9KSx0aGlzLmdwdVNhbXBsZXJfY29tcGFyaXNvbj1TLmRldmljZS5jcmVhdGVTYW1wbGVyKHtjb21wYXJlOlwibGVzc1wiLGxhYmVsOlwic2FtcGxlcl9jb21wYXJpc29uXCJ9KSk6cj09Ry5kZXB0aDI0cGx1cz8odGhpcy5zYW1wbGVyQmluZGluZ0xheW91dD17dHlwZTpcImZpbHRlcmluZ1wifSx0aGlzLnNhbXBsZXJfY29tcGFyaXNvbkJpbmRpbmdMYXlvdXQ9e3R5cGU6XCJjb21wYXJpc29uXCJ9LHRoaXMudGV4dHVyZUJpbmRpbmdMYXlvdXQuc2FtcGxlVHlwZT1cImRlcHRoXCIsdGhpcy5ncHVTYW1wbGVyPVMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe30pLHRoaXMuZ3B1U2FtcGxlcl9jb21wYXJpc29uPVMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe2NvbXBhcmU6XCJsZXNzXCIsbGFiZWw6XCJzYW1wbGVyX2NvbXBhcmlzb25cIn0pKToodGhpcy5zYW1wbGVyQmluZGluZ0xheW91dC50eXBlPVwiZmlsdGVyaW5nXCIsdGhpcy50ZXh0dXJlQmluZGluZ0xheW91dC5zYW1wbGVUeXBlPVwiZmxvYXRcIixsPjAmJih0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0Lm11bHRpc2FtcGxlZD0hMCksdGhpcy5taW5GaWx0ZXI9XCJsaW5lYXJcIix0aGlzLm1hZ0ZpbHRlcj1cImxpbmVhclwiLHRoaXMubWlwbWFwRmlsdGVyPVwibGluZWFyXCIsdGhpcy5tYXhBbmlzb3Ryb3B5PTE2LHRoaXMuYWRkcmVzc01vZGVVPUJ0LmNsYW1wX3RvX2VkZ2UsdGhpcy5hZGRyZXNzTW9kZVY9QnQuY2xhbXBfdG9fZWRnZSx0aGlzLmdwdVNhbXBsZXI9dS5jcmVhdGVTYW1wbGVyKHRoaXMpKX1jcmVhdGUoZSx0LHI9ITApe2xldCBzPVMuZGV2aWNlO2NvbnN0IGE9ZSo0O2xldCBuPW5ldyBGbG9hdDMyQXJyYXkoZSp0KjQpO2NvbnN0IGw9cy5jcmVhdGVCdWZmZXIoe3NpemU6bi5ieXRlTGVuZ3RoLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSk7cy5xdWV1ZS53cml0ZUJ1ZmZlcihsLDAsbik7Y29uc3QgaD13LmJlZ2luQ29tbWFuZEVuY29kZXIoKTtoLmNvcHlCdWZmZXJUb1RleHR1cmUoe2J1ZmZlcjpsLGJ5dGVzUGVyUm93OmF9LHt0ZXh0dXJlOnRoaXMuZ2V0R1BVVGV4dHVyZSgpfSx7d2lkdGg6ZSxoZWlnaHQ6dCxkZXB0aE9yQXJyYXlMYXllcnM6MX0pLHcuZW5kQ29tbWFuZEVuY29kZXIoaCl9cmVhZFRleHR1cmVUb0ltYWdlKCl7bGV0IGU9Uy5kZXZpY2UsdD1TLndpbmRvd1dpZHRoLHI9Uy53aW5kb3dIZWlnaHQscz1uZXcgRmxvYXQzMkFycmF5KHQqcio0KTtjb25zdCBhPWUuY3JlYXRlQnVmZmVyKHtzaXplOnMuYnl0ZUxlbmd0aCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pO3JldHVybiB3LmJlZ2luQ29tbWFuZEVuY29kZXIoKS5jb3B5VGV4dHVyZVRvQnVmZmVyKHt0ZXh0dXJlOnRoaXMuZ2V0R1BVVGV4dHVyZSgpfSx7YnVmZmVyOmF9LFt0LHJdKSxhLmdldE1hcHBlZFJhbmdlKDAscy5ieXRlTGVuZ3RoKX19Y2xhc3MgQ2V7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJzdG9yZU9wXCIsXCJzdG9yZVwiKSxvKHRoaXMsXCJsb2FkT3BcIixcImNsZWFyXCIpLG8odGhpcyxcImNsZWFyVmFsdWVcIixbMCwwLDAsMF0pfX1jbGFzcyBaZXtjb25zdHJ1Y3RvcihlLHQscixzLGE9ITApe28odGhpcyxcImxhYmVsXCIpLG8odGhpcyxcImN1c3RvbVNpemVcIiwhMSksbyh0aGlzLFwiYXR0YWNobWVudHNcIiksbyh0aGlzLFwicnREZXNjcmlwdG9yc1wiKSxvKHRoaXMsXCJ6UHJlVGV4dHVyZVwiKSxvKHRoaXMsXCJkZXB0aFRleHR1cmVcIiksbyh0aGlzLFwiZGVwdGhWaWV3SW5kZXhcIiwwKSxvKHRoaXMsXCJkZXB0aENsZWFuVmFsdWVcIiwxKSxvKHRoaXMsXCJkZXB0aExvYWRPcFwiLFwiY2xlYXJcIiksbyh0aGlzLFwiaXNPdXRUYXJnZXRcIiwhMCksdGhpcy5hdHRhY2htZW50cz1lLHRoaXMucnREZXNjcmlwdG9ycz10LHRoaXMuZGVwdGhUZXh0dXJlPXIsdGhpcy56UHJlVGV4dHVyZT1zLHRoaXMuaXNPdXRUYXJnZXQ9YX1jbG9uZTJGcmFtZShlKXtlLmF0dGFjaG1lbnRzLnB1c2goLi4udGhpcy5hdHRhY2htZW50cy5jb25jYXQoKSk7Zm9yKGxldCB0PTA7dDx0aGlzLnJ0RGVzY3JpcHRvcnMubGVuZ3RoO3QrKyl7Y29uc3Qgcj10aGlzLnJ0RGVzY3JpcHRvcnNbdF07bGV0IHM9bmV3IENlO3MubG9hZE9wPXIubG9hZE9wLHMuc3RvcmVPcD1yLnN0b3JlT3Ascy5jbGVhclZhbHVlPXIuY2xlYXJWYWx1ZSxlLnJ0RGVzY3JpcHRvcnMucHVzaChzKX1lLmRlcHRoVGV4dHVyZT10aGlzLmRlcHRoVGV4dHVyZSxlLnpQcmVUZXh0dXJlPXRoaXMuelByZVRleHR1cmUsZS5jdXN0b21TaXplPXRoaXMuY3VzdG9tU2l6ZX1jbG9uZSgpe2xldCBlPW5ldyBaZShbXSxbXSk7cmV0dXJuIHRoaXMuY2xvbmUyRnJhbWUoZSksZX19Y29uc3QgRnM9Y2xhc3N7c3RhdGljIGluaXQoKXt0aGlzLnJ0VGV4dHVyZU1hcD1uZXcgTWFwLHRoaXMucnRWaWV3UXVhZD1uZXcgTWFwfXN0YXRpYyBjcmVhdGVSVFRleHR1cmUoaSxlLHQscixzPSExLGE9MCl7bGV0IG49dGhpcy5ydFRleHR1cmVNYXAuZ2V0KGkpO3JldHVybiBufHwoaT09QWUuY29sb3JCdWZmZXJUZXhfTkFNRT9uPW5ldyBvZShlLHQscixzLHZvaWQgMCwxLGEsITEpOm49bmV3IG9lKGUsdCxyLHMsdm9pZCAwLDEsYSwhMCksbi5uYW1lPWksRnMucnRUZXh0dXJlTWFwLnNldChpLG4pKSxufXN0YXRpYyBjcmVhdGVSVFRleHR1cmVBcnJheShpLGUsdCxyLHM9MSxhPSExLG49MCl7bGV0IGw9dGhpcy5ydFRleHR1cmVNYXAuZ2V0KGkpO3JldHVybiBsfHwobD1uZXcgb2UoZSx0LHIsYSx2b2lkIDAscyxuKSxsLm5hbWU9aSxGcy5ydFRleHR1cmVNYXAuc2V0KGksbCkpLGx9c3RhdGljIGNyZWF0ZVZpZXdRdWFkKGksZSx0LHIscyxhPTApe2xldCBuPW5ldyBaZShbcl0sW25ldyBDZV0pLGw9bmV3IE5zKGUsdCxuLHMsYSk7cmV0dXJuIEZzLnJ0Vmlld1F1YWQuc2V0KGksbCksbH1zdGF0aWMgZ2V0VGV4dHVyZShpKXtyZXR1cm4gdGhpcy5ydFRleHR1cmVNYXAuZ2V0KGkpfXN0YXRpYyBDcmVhdGVTcGxpdFRleHR1cmUoaSl7bGV0IGU9dGhpcy5nZXRUZXh0dXJlKEFlLmNvbG9yQnVmZmVyVGV4X05BTUUpLHQ9dGhpcy5nZXRUZXh0dXJlKGkrXCJfc3BsaXRcIik7cmV0dXJuIHR8fCh0PXRoaXMuY3JlYXRlUlRUZXh0dXJlKGkrXCJfc3BsaXRcIixlLndpZHRoLGUuaGVpZ2h0LGUuZm9ybWF0LCExKSksdH1zdGF0aWMgV3JpdGVTcGxpdENvbG9yVGV4dHVyZShpKXtsZXQgZT10aGlzLmdldFRleHR1cmUoQWUuY29sb3JCdWZmZXJUZXhfTkFNRSksdD10aGlzLmdldFRleHR1cmUoaStcIl9zcGxpdFwiKTtjb25zdCByPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO3IuY29weVRleHR1cmVUb1RleHR1cmUoe3RleHR1cmU6ZS5nZXRHUFVUZXh0dXJlKCksbWlwTGV2ZWw6MCxvcmlnaW46e3g6MCx5OjAsejowfX0se3RleHR1cmU6dC5nZXRHUFVUZXh0dXJlKCksbWlwTGV2ZWw6MCxvcmlnaW46e3g6MCx5OjAsejowfX0se3dpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0LGRlcHRoT3JBcnJheUxheWVyczoxfSksdy5lbmRDb21tYW5kRW5jb2RlcihyKX19O2xldCBGZT1GcztvKEZlLFwicnRUZXh0dXJlTWFwXCIpLG8oRmUsXCJydFZpZXdRdWFkXCIpO2NsYXNzIEN0e2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiZW5hYmxlXCIsITApLG8odGhpcyxcInBvc3RSZW5kZXJlclwiKSxvKHRoaXMsXCJydFZpZXdRdWFkXCIpLG8odGhpcyxcInZpcnR1YWxUZXh0dXJlXCIpLHRoaXMucnRWaWV3UXVhZD1uZXcgTWFwLHRoaXMudmlydHVhbFRleHR1cmU9bmV3IE1hcH1jcmVhdGVSVFRleHR1cmUoZSx0LHIscyxhPSExLG49MCl7bGV0IGw9RmUuY3JlYXRlUlRUZXh0dXJlKGUsdCxyLHMsYSxuKTtyZXR1cm4gbC5uYW1lPWUsdGhpcy52aXJ0dWFsVGV4dHVyZS5zZXQoZSxsKSxzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKGwsdGhpcyksbH1jcmVhdGVWaWV3UXVhZChlLHQscixzLGE9MCl7bGV0IG49RmUuY3JlYXRlVmlld1F1YWQoZSxcIlF1YWRfdmVydF93Z3NsXCIsdCxyLHMsYSk7cmV0dXJuIHRoaXMucnRWaWV3UXVhZC5zZXQoZSxuKSxufWdldE91dFRleHR1cmUoKXtsZXQgZSx0PXcubGFzdFJlbmRlclBhc3NTdGF0ZS5yZW5kZXJUYXJnZXRzO3JldHVybiB0Lmxlbmd0aD4wP2U9dFswXTplPUZlLmdldFRleHR1cmUoQWUuY29sb3JCdWZmZXJUZXhfTkFNRSksZX1hdXRvU2V0Q29sb3JUZXh0dXJlKGUsdCl7bGV0IHI9dGhpcy5nZXRPdXRUZXh0dXJlKCk7dC5zZXRTYW1wbGVyVGV4dHVyZShlLHIpfWNvbXB1dGUoZSl7fW9uQXR0YWNoKGUpe31vbkRldGFjaChlKXt9cmVuZGVyKGUsdCl7dGhpcy5jb21wdXRlKGUpLHRoaXMucnRWaWV3UXVhZC5mb3JFYWNoKChyLHMpPT57bGV0IGE9dy5sYXN0UmVuZGVyUGFzc1N0YXRlLmdldExhc3RSZW5kZXJUZXh0dXJlKCk7ci5yZW5kZXJUb1ZpZXdRdWFkKGUscix0LGEpfSl9ZGVzdHJveShlKXt0aGlzLnBvc3RSZW5kZXJlcj1udWxsO2ZvcihsZXQgdD0wO3Q8dGhpcy5ydFZpZXdRdWFkLnNpemU7dCsrKXRoaXMucnRWaWV3UXVhZC52YWx1ZXNbdF0uZGVzdHJveShlKTt0aGlzLnJ0Vmlld1F1YWQuY2xlYXIoKSx0aGlzLnJ0Vmlld1F1YWQ9bnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMudmlydHVhbFRleHR1cmUuc2l6ZTt0Kyspe2NvbnN0IHI9dGhpcy52aXJ0dWFsVGV4dHVyZS52YWx1ZXNbdF07c2UuZ2V0SW5zdGFuY2UoKS5kZXRhY2hlZChyLHRoaXMpLHIuZGVzdHJveShlKX19fWNsYXNzIHVvIGV4dGVuZHMgQ3R7Y29uc3RydWN0b3IoKXtzdXBlcigpO2xldCBlPVMucHJlc2VudGF0aW9uU2l6ZTtGZS5jcmVhdGVSVFRleHR1cmUoQWUuY29sb3JCdWZmZXJUZXhfTkFNRSxlWzBdLGVbMV0sRy5yZ2JhMTZmbG9hdCwhMSksTi5yZWdpc3RlcihcIkZYQUFfU2hhZGVyXCIsSWMpO2xldCB0PXt1X3RleGVsOm5ldyAkKG5ldyBaKDEvZVswXSwxL2VbMV0pKSx1X3N0cmVuZ3RoOm5ldyAkKDQpfSxyPXRoaXMuY3JlYXRlUlRUZXh0dXJlKFwiRlhBQVBvc3RcIixlWzBdLGVbMV0sRy5yZ2JhMTZmbG9hdCk7dGhpcy5jcmVhdGVWaWV3UXVhZChcImZ4YWFcIixcIkZYQUFfU2hhZGVyXCIscix0KX1vbkF0dGFjaChlKXtBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmZ4YWEuZW5hYmxlPSEwfW9uRGV0YWNoKGUpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZnhhYS5lbmFibGU9ITF9fWNsYXNzICRse2NvbnN0cnVjdG9yKGUpe28odGhpcyxcImNvbW1hbmRcIiksbyh0aGlzLFwiZW5jb2RlclwiKSxvKHRoaXMsXCJyZW5kZXJlclBhc3NTdGF0ZXNcIiksbyh0aGlzLFwicnRGcmFtZVwiKSx0aGlzLnJ0RnJhbWU9ZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlcz1bXX1jbGVhbigpe3RoaXMucmVuZGVyZXJQYXNzU3RhdGVzLmxlbmd0aD0wLHcuY2xlYW5DYWNoZSgpfWJlZ2luQ29udGludWVSZW5kZXJlclBhc3NTdGF0ZSgpe2lmKHRoaXMucmVuZGVyZXJQYXNzU3RhdGVzLmxlbmd0aD4wKXtsZXQgZT10aGlzLnJ0RnJhbWUuY2xvbmUoKTtmb3IoY29uc3QgciBvZiBlLnJ0RGVzY3JpcHRvcnMpci5sb2FkT3A9XCJsb2FkXCI7ZS5kZXB0aExvYWRPcD1cImxvYWRcIjtsZXQgdD1IZS5jcmVhdGVSZW5kZXJlclBhc3NTdGF0ZShlKTtyZXR1cm4gdGhpcy5yZW5kZXJlclBhc3NTdGF0ZXMucHVzaCh0KSx0fWVsc2V7bGV0IGU9SGUuY3JlYXRlUmVuZGVyZXJQYXNzU3RhdGUodGhpcy5ydEZyYW1lKTtyZXR1cm4gdGhpcy5yZW5kZXJlclBhc3NTdGF0ZXMucHVzaChlKSxlfX1nZXQgcmVuZGVyZXJQYXNzU3RhdGUoKXtyZXR1cm4gdGhpcy5yZW5kZXJlclBhc3NTdGF0ZXNbdGhpcy5yZW5kZXJlclBhc3NTdGF0ZXMubGVuZ3RoLTFdfWJlZ2luUmVuZGVyUGFzcygpe3RoaXMuYmVnaW5Db250aW51ZVJlbmRlcmVyUGFzc1N0YXRlKCksdGhpcy5iZWdpbmVOZXdDb21tYW5kKCksdGhpcy5iZWdpbk5ld0VuY29kZXIoKX1lbmRSZW5kZXJQYXNzKCl7dGhpcy5lbmRFbmNvZGVyKCksdGhpcy5lbmRDb21tYW5kKCl9YmVnaW5lTmV3Q29tbWFuZCgpe3JldHVybiB0aGlzLmNvbW1hbmQ9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCksdGhpcy5jb21tYW5kfWVuZENvbW1hbmQoKXt3LmVuZENvbW1hbmRFbmNvZGVyKHRoaXMuY29tbWFuZCksdGhpcy5jb21tYW5kPW51bGx9YmVnaW5OZXdFbmNvZGVyKCl7cmV0dXJuIHRoaXMuZW5jb2Rlcj13LmJlZ2luUmVuZGVyUGFzcyh0aGlzLmNvbW1hbmQsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSksdGhpcy5lbmNvZGVyfWVuZEVuY29kZXIoKXt3LmVuZFBhc3ModGhpcy5lbmNvZGVyKSx0aGlzLmVuY29kZXI9bnVsbH19Y2xhc3MgZGkgZXh0ZW5kcyBoaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwicmVuZGVyZXJQYXNzU3RhdGVcIiksbyh0aGlzLFwic3BsaXRSZW5kZXJlclBhc3NTdGF0ZVwiKSxvKHRoaXMsXCJ1c2VSZW5kZXJCdW5kbGVcIiwhMSksbyh0aGlzLFwiZGVidWdWaWV3UXVhZHNcIiksbyh0aGlzLFwiZGVidWdUZXh0dXJlc1wiKSxvKHRoaXMsXCJyZW5kZXJDb250ZXh0XCIpLG8odGhpcyxcIl9yZW5kZXJlclR5cGVcIiksbyh0aGlzLFwiX3J0RnJhbWVcIiksdGhpcy5kZWJ1Z1RleHR1cmVzPVtdLHRoaXMuZGVidWdWaWV3UXVhZHM9W119Z2V0IHBhc3NUeXBlKCl7cmV0dXJuIHRoaXMuX3JlbmRlcmVyVHlwZX1zZXQgcGFzc1R5cGUoZSl7dGhpcy5fcmVuZGVyZXJUeXBlPWV9c2V0UmVuZGVyU3RhdGVzKGUpe2lmKHRoaXMuX3J0RnJhbWU9ZSxlKXt0aGlzLnJlbmRlcmVyUGFzc1N0YXRlPUhlLmNyZWF0ZVJlbmRlcmVyUGFzc1N0YXRlKGUpO2xldCB0PWUuY2xvbmUoKTt0LmRlcHRoTG9hZE9wPVwibG9hZFwiO2Zvcihjb25zdCByIG9mIHQucnREZXNjcmlwdG9ycylyLmxvYWRPcD1cImxvYWRcIjt0aGlzLnNwbGl0UmVuZGVyZXJQYXNzU3RhdGU9SGUuY3JlYXRlUmVuZGVyZXJQYXNzU3RhdGUodCl9dGhpcy5yZW5kZXJDb250ZXh0PW5ldyAkbChlKX1zZXRJcnJhZGlhbmNlKGUsdCl7dGhpcy5yZW5kZXJlclBhc3NTdGF0ZS5pcnJhZGlhbmNlQnVmZmVyPVtlLHRdfWNvbXB1dGUoZSx0KXt9cmVuZGVyKGUsdCxyLHM9ITEpe3cuY2xlYW5DYWNoZSgpO2xldCBhPWUuY2FtZXJhLG49ZS5zY2VuZTt0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLmNhbWVyYTNEPWE7bGV0IGw9US5pbnN0YW5jZS5nZXRSZW5kZXJOb2RlcyhuLGEpLGg9dGhpcy5yZW5kZXJCdW5kbGVPcChlLGwsdCxyKSx1PXM/W106dGhpcy5yZW5kZXJCdW5kbGVUcihlLGwsdCxyKTt7bGV0IGM9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCksZj13LmJlZ2luUmVuZGVyUGFzcyhjLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUpO2gubGVuZ3RoPjAmJmYuZXhlY3V0ZUJ1bmRsZXMoaCksIXMmJlEuaW5zdGFuY2Uuc2t5JiYody5iaW5kQ2FtZXJhKGYsYSksUS5pbnN0YW5jZS5za3kucmVuZGVyUGFzczIoZSx0aGlzLl9yZW5kZXJlclR5cGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSxyLGYpKSx0aGlzLmRyYXdSZW5kZXJOb2RlcyhlLGYsYyxsLm9wYXF1ZUxpc3QsdCksdy5lbmRQYXNzKGYpLHcuZW5kQ29tbWFuZEVuY29kZXIoYyl9e2xldCBjPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLGY9dy5iZWdpblJlbmRlclBhc3MoYyx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlKTt1Lmxlbmd0aD4wJiZmLmV4ZWN1dGVCdW5kbGVzKHUpLHN8fCh3LmJpbmRDYW1lcmEoZixhKSx0aGlzLmRyYXdSZW5kZXJOb2RlcyhlLGYsYyxsLnRyYW5zcGFyZW50TGlzdCx0KSksdy5lbmRQYXNzKGYpLHcuZW5kQ29tbWFuZEVuY29kZXIoYyl9fW5vZGVVcGxvYWQoZSx0LHIpe31vY2NsdXNpb25SZW5kZXJOb2RlVGVzdChlLHQscil7cmV0dXJuIHI/ci5vY2NsdXNpb25SZW5kZXJOb2RlVGVzdChlKT4wOiEwfXJlbmRlck9wKGUsdCxyLHMsYSl7fXJlbmRlclRyKGUsdCxyLHMsYSl7fXJlbmRlckJ1bmRsZU9wKGUsdCxyLHMpe2xldCBhPVEuaW5zdGFuY2UuZ2V0T3BSZW5kZXJHcm91cChlLnNjZW5lKTtpZihhKXtsZXQgbj1bXTtyZXR1cm4gYS5yZW5kZXJHcm91cC5mb3JFYWNoKGw9PntpZihsLmJ1bmRsZU1hcC5oYXModGhpcy5fcmVuZGVyZXJUeXBlKSluLnB1c2gobC5idW5kbGVNYXAuZ2V0KHRoaXMuX3JlbmRlcmVyVHlwZSkpO2Vsc2V7bGV0IGg9dy5yZWNvcmRCdW5kbGVFbmNvZGVyKHRoaXMucmVuZGVyZXJQYXNzU3RhdGUucmVuZGVyQnVuZGxlRW5jb2RlckRlc2NyaXB0b3IpO3RoaXMucmVjb3JkUmVuZGVyQnVuZGxlTm9kZShlLGgsbC5yZW5kZXJOb2RlcyxzKTtsZXQgdT1oLmZpbmlzaCgpO2wuYnVuZGxlTWFwLnNldCh0aGlzLl9yZW5kZXJlclR5cGUsdSksbi5wdXNoKHUpfX0pLG59cmV0dXJuW119cmVuZGVyQnVuZGxlVHIoZSx0LHIscyl7bGV0IGE9US5pbnN0YW5jZS5nZXRUclJlbmRlckdyb3VwKGUuc2NlbmUpO2lmKGEpe2xldCBuPVtdO3JldHVybiBhLnJlbmRlckdyb3VwLmZvckVhY2gobD0+e2lmKGwuYnVuZGxlTWFwLmhhcyh0aGlzLl9yZW5kZXJlclR5cGUpKW4ucHVzaChsLmJ1bmRsZU1hcC5nZXQodGhpcy5fcmVuZGVyZXJUeXBlKSk7ZWxzZXtsZXQgaD13LnJlY29yZEJ1bmRsZUVuY29kZXIodGhpcy5yZW5kZXJlclBhc3NTdGF0ZS5yZW5kZXJCdW5kbGVFbmNvZGVyRGVzY3JpcHRvcik7dGhpcy5yZWNvcmRSZW5kZXJCdW5kbGVOb2RlKGUsaCxsLnJlbmRlck5vZGVzLHMpO2xldCB1PWguZmluaXNoKCk7bC5idW5kbGVNYXAuc2V0KHRoaXMuX3JlbmRlcmVyVHlwZSx1KSxuLnB1c2godSl9fSksbn1yZXR1cm5bXX1yZWNvcmRSZW5kZXJCdW5kbGVOb2RlKGUsdCxyLHMpe3cuYmluZENhbWVyYSh0LGUuY2FtZXJhKSx3LmJpbmRHZW9tZXRyeUJ1ZmZlcih0LHJbMF0uZ2VvbWV0cnkpO2ZvcihsZXQgYT0wO2E8ci5sZW5ndGg7KythKXtsZXQgbj1yW2FdO24udHJhbnNmb3JtLndvcmxkTWF0cml4LmluZGV4LG4udHJhbnNmb3JtLmVuYWJsZSYmbi5yZWNvcmRSZW5kZXJQYXNzMihlLHRoaXMuX3JlbmRlcmVyVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLHMsdCl9fWRyYXdSZW5kZXJOb2RlcyhlLHQscixzLGEsbil7dy5iaW5kQ2FtZXJhKHQsZS5jYW1lcmEpO2ZvcihsZXQgbD1BLnNldHRpbmcucmVuZGVyLmRyYXdPcE1pbjtsPE1hdGgubWluKHMubGVuZ3RoLEEuc2V0dGluZy5yZW5kZXIuZHJhd09wTWF4KTsrK2wpe2xldCBoPXNbbF07aC50cmFuc2Zvcm0uZW5hYmxlJiZoLmVuYWJsZSYmaC5yZW5kZXJQYXNzMihlLHRoaXMuX3JlbmRlcmVyVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLG4sdCl9fXNldERlYnVnVGV4dHVyZShlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7bGV0IHI9ZVt0XSxzPVwiUXVhZF92ZXJ0X3dnc2xcIixhPVwiUXVhZF9mcmFnX3dnc2xcIjtzd2l0Y2goci5mb3JtYXQpe2Nhc2UgRy5yZ2JhOHNpbnQ6Y2FzZSBHLnJnYmE4dWludDpjYXNlIEcucmdiYTh1bm9ybTpjYXNlIEcucmdiYTE2ZmxvYXQ6Y2FzZSBHLnJnYmEzMmZsb2F0OmE9XCJRdWFkX2ZyYWdfd2dzbFwiO2JyZWFrO2Nhc2UgRy5kZXB0aDI0cGx1czpjYXNlIEcuZGVwdGgzMmZsb2F0OmE9XCJRdWFkX2RlcHRoMmRfZnJhZ193Z3NsXCIsci50ZXh0dXJlQmluZGluZ0xheW91dC52aWV3RGltZW5zaW9uPT1cImN1YmVcIiYmKGE9XCJRdWFkX2RlcHRoQ3ViZV9mcmFnX3dnc2xcIik7YnJlYWt9bGV0IG49bmV3IE5zKHMsYSxuZXcgWmUoW10sW10pKTt0aGlzLmRlYnVnVGV4dHVyZXMucHVzaChlW3RdKSx0aGlzLmRlYnVnVmlld1F1YWRzLnB1c2gobil9fX1jbGFzcyBlaCBleHRlbmRzIGRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBhc3NUeXBlPXJlLkNPTE9SfXJlbmRlcihlLHQscixzPSExKXt0aGlzLnJlbmRlckNvbnRleHQuY2xlYW4oKTtsZXQgYT1lLnNjZW5lLG49ZS5jYW1lcmE7dGhpcy5yZW5kZXJlclBhc3NTdGF0ZS5jYW1lcmEzRD1uO2xldCBsPVEuaW5zdGFuY2UuZ2V0UmVuZGVyTm9kZXMoYSxuKSxoPXRoaXMucmVuZGVyQnVuZGxlT3AoZSxsLHQsciksdT1zP1tdOnRoaXMucmVuZGVyQnVuZGxlVHIoZSxsLHQscik7ZnQuc3RhcnQoXCJjb2xvclBhc3MgUmVuZGVyZXJcIik7e2Z0LnN0YXJ0KFwiQ29sb3JQYXNzIERyYXcgT3BhcXVlXCIpLHRoaXMucmVuZGVyQ29udGV4dC5iZWdpblJlbmRlclBhc3MoKSx0aGlzLnJlbmRlckNvbnRleHQuY29tbWFuZDtsZXQgYz10aGlzLnJlbmRlckNvbnRleHQuZW5jb2Rlcjt3LmJpbmRDYW1lcmEoYyxuKSxoLmxlbmd0aD4wJiYoUS5pbnN0YW5jZS5nZXRPcFJlbmRlckdyb3VwKGEpLGMuZXhlY3V0ZUJ1bmRsZXMoaCkpLCFzJiZRLmluc3RhbmNlLnNreSYmKHcuYmluZENhbWVyYShjLG4pLFEuaW5zdGFuY2Uuc2t5LnByZUluaXR8fFEuaW5zdGFuY2Uuc2t5Lm5vZGVVcGRhdGUoZSx0aGlzLl9yZW5kZXJlclR5cGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSxyKSxRLmluc3RhbmNlLnNreS5yZW5kZXJQYXNzMihlLHRoaXMuX3JlbmRlcmVyVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLHIsYykpLGwub3BhcXVlTGlzdCYmKHcuYmluZENhbWVyYShjLG4pLHRoaXMuZHJhd05vZGVzKGUsdGhpcy5yZW5kZXJDb250ZXh0LGwub3BhcXVlTGlzdCx0LHIpLHRoaXMucmVuZGVyQ29udGV4dC5lbmRSZW5kZXJQYXNzKCksZnQuZW5kKFwiQ29sb3JQYXNzIERyYXcgT3BhcXVlXCIpKX17ZnQuc3RhcnQoXCJDb2xvclBhc3MgRHJhdyBUcmFuc3BhcmVudFwiKSx0aGlzLnJlbmRlckNvbnRleHQuYmVnaW5SZW5kZXJQYXNzKCksdGhpcy5yZW5kZXJDb250ZXh0LmNvbW1hbmQ7bGV0IGM9dGhpcy5yZW5kZXJDb250ZXh0LmVuY29kZXI7dS5sZW5ndGg+MCYmYy5leGVjdXRlQnVuZGxlcyh1KSwhcyYmbC50cmFuc3BhcmVudExpc3QmJih3LmJpbmRDYW1lcmEoYyxuKSx0aGlzLmRyYXdOb2RlcyhlLHRoaXMucmVuZGVyQ29udGV4dCxsLnRyYW5zcGFyZW50TGlzdCx0LHIpKTtsZXQgZj1RLmluc3RhbmNlLmdldEdyYXBoaWNMaXN0KCk7Zm9yKGxldCBkPTA7ZDxmLmxlbmd0aDtkKyspe2NvbnN0IHA9ZltkXTtwLnRyYW5zZm9ybS53b3JsZE1hdHJpeC5pbmRleCxwLm5vZGVVcGRhdGUoZSx0aGlzLl9yZW5kZXJlclR5cGUsdGhpcy5zcGxpdFJlbmRlcmVyUGFzc1N0YXRlLHIpLHAucmVuZGVyUGFzczIoZSx0aGlzLl9yZW5kZXJlclR5cGUsdGhpcy5zcGxpdFJlbmRlcmVyUGFzc1N0YXRlLHIsYyl9dGhpcy5yZW5kZXJDb250ZXh0LmVuZFJlbmRlclBhc3MoKSxmdC5lbmQoXCJDb2xvclBhc3MgRHJhdyBUcmFuc3BhcmVudFwiKX1mdC5lbmQoXCJjb2xvclBhc3MgUmVuZGVyZXJcIil9ZHJhd05vZGVzKGUsdCxyLHMsYSl7e2xldCBuPVEuaW5zdGFuY2UuZ2V0UmVuZGVyU2hhZGVyQ29sbGVjdChlKTtmb3IoY29uc3QgbCBvZiBuKXtsZXQgaD1sWzFdO2Zvcihjb25zdCB1IG9mIGgpe2xldCBjPXVbMV07aWYoYy5wcmVJbml0KXtjLm5vZGVVcGRhdGUoZSx0aGlzLl9yZW5kZXJlclR5cGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSxhKTticmVha319fWZvcihsZXQgbD1BLnNldHRpbmcucmVuZGVyLmRyYXdPcE1pbjtsPE1hdGgubWluKHIubGVuZ3RoLEEuc2V0dGluZy5yZW5kZXIuZHJhd09wTWF4KTsrK2wpe2xldCBoPXJbbF07aC50cmFuc2Zvcm0uZW5hYmxlJiZoLmVuYWJsZSYmKGgucHJlSW5pdHx8aC5ub2RlVXBkYXRlKGUsdGhpcy5fcmVuZGVyZXJUeXBlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUsYSksaC5yZW5kZXJQYXNzKGUsdGhpcy5wYXNzVHlwZSx0aGlzLnJlbmRlckNvbnRleHQpKX19fW9jY2x1c2lvblJlbmRlck5vZGVUZXN0KGUsdCxyKXtyZXR1cm4gci56RGVwdGhSZW5kZXJOb2RlVGVzdCh0KT4wfX1jb25zdCB0cj1jbGFzcyBleHRlbmRzIFple2NvbnN0cnVjdG9yKCl7c3VwZXIoW10sW10pfWNyYXRlR0J1ZmZlcihpLGUsdCl7bGV0IHI9dGhpcy5hdHRhY2htZW50cyxzPXRoaXMucnREZXNjcmlwdG9ycyxhPUZlLmNyZWF0ZVJUVGV4dHVyZShpK0FlLmNvbG9yQnVmZmVyVGV4X05BTUUsZSx0LEcucmdiYTE2ZmxvYXQsITEpLG49RmUuY3JlYXRlUlRUZXh0dXJlKGkrQWUucG9zaXRpb25CdWZmZXJUZXhfTkFNRSxlLHQsRy5yZ2JhMTZmbG9hdCwhMSksbD1GZS5jcmVhdGVSVFRleHR1cmUoaStBZS5ub3JtYWxCdWZmZXJUZXhfTkFNRSxlLHQsRy5yZ2JhOHVub3JtLCExKSxoPUZlLmNyZWF0ZVJUVGV4dHVyZShpK0FlLm1hdGVyaWFsQnVmZmVyVGV4X05BTUUsZSx0LEcucmdiYTh1bm9ybSwhMSk7ci5wdXNoKGEpLHIucHVzaChuKSxyLnB1c2gobCksci5wdXNoKGgpO2xldCB1PW5ldyBDZTt1LmxvYWRPcD1cImNsZWFyXCI7bGV0IGM9bmV3IG9lKGUsdCxHLmRlcHRoMzJmbG9hdCwhMSk7Yy5uYW1lPVwiZGVwdGhUZXh0dXJlXCI7bGV0IGY9bmV3IENlO2YubG9hZE9wPVwibG9hZFwiLHRoaXMuZGVwdGhUZXh0dXJlPWMscy5wdXNoKHUpLHMucHVzaChuZXcgQ2UpLHMucHVzaChuZXcgQ2UpLHMucHVzaChuZXcgQ2UpfWdldENvbG9yTWFwKCl7cmV0dXJuIHRoaXMuYXR0YWNobWVudHNbMF19Z2V0UG9zaXRpb25NYXAoKXtyZXR1cm4gdGhpcy5hdHRhY2htZW50c1sxXX1nZXROb3JtYWxNYXAoKXtyZXR1cm4gdGhpcy5hdHRhY2htZW50c1syXX1nZXRNYXRlcmlhbE1hcCgpe3JldHVybiB0aGlzLmF0dGFjaG1lbnRzWzNdfXN0YXRpYyBnZXRHQnVmZmVyRnJhbWUoaSl7bGV0IGU7aWYodHIuZ0J1ZmZlck1hcC5oYXMoaSkpZT10ci5nQnVmZmVyTWFwLmdldChpKTtlbHNle2U9bmV3IHRyO2xldCB0PVMucHJlc2VudGF0aW9uU2l6ZTtlLmNyYXRlR0J1ZmZlcihpLHRbMF0sdFsxXSksdHIuZ0J1ZmZlck1hcC5zZXQoaSxlKX1yZXR1cm4gZX1jbG9uZSgpe2xldCBpPW5ldyB0cjtyZXR1cm4gdGhpcy5jbG9uZTJGcmFtZShpKSxpfX07bGV0IHd0PXRyO28od3QsXCJnQnVmZmVyTWFwXCIsbmV3IE1hcCk7Y2xhc3Mga3N7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJmcnVzdHVtQ3VsbGluZ0xpc3RcIiksbyh0aGlzLFwielZpc2libGVMaXN0XCIpLG8odGhpcyxcIl9yZW5kZXJMaXN0XCIpLHRoaXMuX3JlbmRlckxpc3Q9bmV3IE1hcH1vY2NsdXNpb25SZW5kZXJOb2RlVGVzdChlKXtyZXR1cm4gQS5zZXR0aW5nLm9jY2x1c2lvblF1ZXJ5LmVuYWJsZT90aGlzLmZydXN0dW1DdWxsaW5nTGlzdD90aGlzLmZydXN0dW1DdWxsaW5nTGlzdFtlXTowOjF9ekRlcHRoUmVuZGVyTm9kZVRlc3QoZSl7cmV0dXJuIHRoaXMuelZpc2libGVMaXN0P3RoaXMuelZpc2libGVMaXN0W2VdOjB9dXBkYXRlKGUsdCl7fWNvbGxlY3QoZSx0KXt9cmVuZGVyQ29tbWl0VGVzdGluZyhlLHQpe3JldHVybiEwfX1vKGtzLFwiZW5hYmxlXCIsITApO2NsYXNzIGlyIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMuYnVmZmVyVHlwZT1NdC5Db21wdXRlR1BVQnVmZmVyLHRoaXMuY3JlYXRlQnVmZmVyKEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsZSx0KX19Y2xhc3MgdGh7Y29uc3RydWN0b3IoZSx0KXtvKHRoaXMsXCJjbHVzdGVyQnVmZmVyXCIpLG8odGhpcyxcImxpZ2h0QXNzaWduQnVmZmVyXCIpLG8odGhpcyxcImFzc2lnblRhYmxlQnVmZmVyXCIpLG8odGhpcyxcImNsdXN0ZXJzVW5pZm9ybUJ1ZmZlclwiKSx0aGlzLmNsdXN0ZXJCdWZmZXI9bmV3IGlyKGUqMio0KSx0aGlzLmNsdXN0ZXJzVW5pZm9ybUJ1ZmZlcj1uZXcgRHQoMTApLHRoaXMuY2x1c3RlcnNVbmlmb3JtQnVmZmVyLnZpc2liaWxpdHk9R1BVU2hhZGVyU3RhZ2UuRlJBR01FTlR8R1BVU2hhZGVyU3RhZ2UuQ09NUFVURSx0aGlzLmxpZ2h0QXNzaWduQnVmZmVyPW5ldyBpcihlKnQpLHRoaXMubGlnaHRBc3NpZ25CdWZmZXIudmlzaWJpbGl0eT1HUFVTaGFkZXJTdGFnZS5GUkFHTUVOVHxHUFVTaGFkZXJTdGFnZS5DT01QVVRFLHRoaXMuYXNzaWduVGFibGVCdWZmZXI9bmV3IGlyKGUqNCksdGhpcy5hc3NpZ25UYWJsZUJ1ZmZlci52aXNpYmlsaXR5PUdQVVNoYWRlclN0YWdlLkZSQUdNRU5UfEdQVVNoYWRlclN0YWdlLkNPTVBVVEV9dXBkYXRlKGUsdCxyLHMsYSxuLGwsaCx1LGMpe3RoaXMuY2x1c3RlcnNVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwiY2x1c3RlclRpbGVYXCIscyksdGhpcy5jbHVzdGVyc1VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJjbHVzdGVyVGlsZVlcIixhKSx0aGlzLmNsdXN0ZXJzVW5pZm9ybUJ1ZmZlci5zZXRGbG9hdChcImNsdXN0ZXJUaWxlWlwiLG4pLHRoaXMuY2x1c3RlcnNVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwibnVtTGlnaHRzXCIsbCksdGhpcy5jbHVzdGVyc1VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJtYXhOdW1MaWdodHNQZXJDbHVzdGVyXCIsaCksdGhpcy5jbHVzdGVyc1VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJuZWFyXCIsdSksdGhpcy5jbHVzdGVyc1VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJmYXJcIixjKSx0aGlzLmNsdXN0ZXJzVW5pZm9ybUJ1ZmZlci5zZXRGbG9hdChcInNjcmVlbldpZHRoXCIsZSksdGhpcy5jbHVzdGVyc1VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJzY3JlZW5IZWlnaHRcIix0KSx0aGlzLmNsdXN0ZXJzVW5pZm9ybUJ1ZmZlci5zZXRGbG9hdChcImNsdXN0ZXJQaXhcIixyKSx0aGlzLmNsdXN0ZXJzVW5pZm9ybUJ1ZmZlci5hcHBseSgpfX1jbGFzcyBrZXt9byhrZSxcImNsdXN0ZXJUaWxlWFwiLDE2KSxvKGtlLFwiY2x1c3RlclRpbGVZXCIsMTYpLG8oa2UsXCJjbHVzdGVyVGlsZVpcIiwzMik7bGV0IGloPWBcbiAgI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcblxuICAgICAgICBzdHJ1Y3QgQ2x1c3RlckJveHtcbiAgICAgICAgICAgIG1pblBvaW50OnZlYzQ8ZjMyPixcbiAgICAgICAgICAgIG1heFBvaW50OnZlYzQ8ZjMyPlxuICAgICAgICB9XG5cbiAgICAgICAgc3RydWN0IENsdXN0ZXJzVW5pZm9ybXtcbiAgICAgICAgICAgIGNsdXN0ZXJUaWxlWDpmMzIsXG4gICAgICAgICAgICBjbHVzdGVyVGlsZVk6ZjMyLFxuICAgICAgICAgICAgY2x1c3RlclRpbGVaOmYzMixcbiAgICAgICAgICAgIG51bUxpZ2h0czpmMzIsXG4gICAgICAgICAgICBtYXhOdW1MaWdodHNQZXJDbHVzdGVyOmYzMixcbiAgICAgICAgICAgIG5lYXI6ZjMyLFxuICAgICAgICAgICAgZmFyOmYzMixcbiAgICAgICAgICAgIHNjcmVlbldpZHRoOmYzMixcbiAgICAgICAgICAgIHNjcmVlbkhlaWdodDpmMzIsXG4gICAgICAgICAgICBjbHVzdGVyUGl4OmYzMlxuICAgICAgICB9XG4gICAgIFxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHVuaWZvcm0+IGNsdXN0ZXJzVW5pZm9ybSA6IENsdXN0ZXJzVW5pZm9ybTtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLHJlYWRfd3JpdGU+IGNsdXN0ZXJCdWZmZXIgOiBhcnJheTxDbHVzdGVyQm94PjtcblxuXG4gICAgICAgIHZhcjxwcml2YXRlPiBjbHVzdGVyVGlsZVg6ZjMyIDtcbiAgICAgICAgdmFyPHByaXZhdGU+IGNsdXN0ZXJUaWxlWTpmMzIgO1xuICAgICAgICB2YXI8cHJpdmF0ZT4gY2x1c3RlclRpbGVaOmYzMiA7XG4gICAgICAgIGZuIGNvbnZlcnRORENUb1ZpZXcoIHY0OnZlYzQ8ZjMyPiApIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICAgICAgICB2YXIgdiA9IGdsb2JhbFVuaWZvcm0ucHZNYXRyaXhJbnYgKiB2NCA7XG4gICAgICAgICAgICB2ID0gdiAvIHYudyA7XG4gICAgICAgICAgICByZXR1cm4gdiA7XG4gICAgICAgIH1cblxuICAgICAgICBmbiBncmlkVG9JbmRleChpOnZlYzM8dTMyPikgLT4gdTMye1xuICAgICAgICAgICAgcmV0dXJuIGkueiAqIHUzMihjbHVzdGVyVGlsZVgpICogdTMyKGNsdXN0ZXJUaWxlWSkgKyBpLnkgKiB1MzIoY2x1c3RlclRpbGVYKSArIGkueCA7XG4gICAgICAgIH1cblxuICAgICAgICBmbiBTY3JlZW5Ub1ZpZXcoc2NyZWVuIDogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj4ge1xuICAgICAgICAgICAgbGV0IHRleENvb3JkID0gc2NyZWVuLnh5IC8gdmVjMjxmMzI+KGNsdXN0ZXJzVW5pZm9ybS5zY3JlZW5XaWR0aCwgY2x1c3RlcnNVbmlmb3JtLnNjcmVlbkhlaWdodCk7XG4gICAgICAgICAgICBsZXQgY2xpcCA9IHZlYzQ8ZjMyPih2ZWMyPGYzMj4odGV4Q29vcmQueCwgMS4wIC0gdGV4Q29vcmQueSkgKiAyLjAgLSB2ZWMyPGYzMj4oMS4wLCAxLjApLCBzY3JlZW4ueiwgc2NyZWVuLncpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRORENUb1ZpZXcoY2xpcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGZuIExpbmVJbnRlcnNlY3Rpb25Ub1pQbGFuZSggZXllOnZlYzM8ZjMyPiAsIG5kY1BvaW50IDp2ZWMzPGYzMj4gLCB6OmYzMikgLT4gdmVjMzxmMzI+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB2ZWMzPGYzMj4oMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB2YXIgZGlyID0gbmRjUG9pbnQgLSBleWU7XG4gICAgICAgICAgICB2YXIgdCA9ICh6IC0gZG90KG5vcm1hbCwgZXllKSkgLyBkb3Qobm9ybWFsLCBkaXIpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGV5ZSArIHQgKiBkaXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7a2UuY2x1c3RlclRpbGVYfSwke2tlLmNsdXN0ZXJUaWxlWX0sMSlcbiAgICAgICAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2ludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4gKXtcblxuICAgICAgICAgICAgbGV0IGkgPSBsb2NhbF9pbnZvY2F0aW9uX2lkLnggO1xuICAgICAgICAgICAgbGV0IGogPSBsb2NhbF9pbnZvY2F0aW9uX2lkLnkgO1xuICAgICAgICAgICAgbGV0IGsgPSB3b3JrZ3JvdXBfaWQueCA7XG5cbiAgICAgICAgICAgIGNsdXN0ZXJUaWxlWCA9IGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVg7XG4gICAgICAgICAgICBjbHVzdGVyVGlsZVkgPSBjbHVzdGVyc1VuaWZvcm0uY2x1c3RlclRpbGVZO1xuICAgICAgICAgICAgY2x1c3RlclRpbGVaID0gY2x1c3RlcnNVbmlmb3JtLmNsdXN0ZXJUaWxlWjtcblxuICAgICAgICAgICAgbGV0IGNsdXN0ZXJHcmlkID0gdmVjMzx1MzI+KGksaixrKTtcbiAgICAgICAgICAgIGxldCB0aWxlSW5kZXggPSBncmlkVG9JbmRleChjbHVzdGVyR3JpZCk7XG4gICAgICAgICAgICBsZXQgZXllUG9zID0gdmVjMzxmMzI+KDAuMCwgMC4wLCAwLjApO1xuXG4gICAgICAgICAgICBsZXQgdHggPSBjbHVzdGVyVGlsZVg7XG4gICAgICAgICAgICBsZXQgdHkgPSBjbHVzdGVyVGlsZVk7XG4gICAgICAgICAgICBsZXQgdHogPSBjbHVzdGVyVGlsZVogO1xuICAgICAgICAgICAgbGV0IG5lYXIgPSBjbHVzdGVyc1VuaWZvcm0ubmVhciA7XG4gICAgICAgICAgICBsZXQgZmFyID0gY2x1c3RlcnNVbmlmb3JtLmZhciA7XG5cbiAgICAgICAgICAgIGxldCB0aXRsZVNpemUgPSB2ZWMyPGYzMj4oIGdsb2JhbFVuaWZvcm0ud2luZG93V2lkdGggLyB0eCAsIGdsb2JhbFVuaWZvcm0ud2luZG93SGVpZ2h0IC8gdHkgKSA7XG5cbiAgICAgICAgICAgIHZhciBtYXhQb2ludFNzID0gdmVjNDxmMzI+KHZlYzI8ZjMyPihmMzIoaSkgKyAxLjAsIGYzMihqKSArIDEuMCkgKiB0aXRsZVNpemUsIDAuMCwgMS4wKTtcblx0ICAgICAgICB2YXIgbWluUG9pbnRTcyA9IHZlYzQ8ZjMyPih2ZWMyPGYzMj4oZjMyKGkpICwgZjMyKGopKSAqIHRpdGxlU2l6ZSwgMC4wLCAxLjApO1xuXG4gICAgICAgICAgICB2YXIgbWF4UG9pbnRWcyA9IFNjcmVlblRvVmlldyhtYXhQb2ludFNzKS54eXo7XG5cdCAgICAgICAgdmFyIG1pblBvaW50VnMgPSBTY3JlZW5Ub1ZpZXcobWluUG9pbnRTcykueHl6O1xuIFxuICAgICAgICAgICAgdmFyIHRpbGVOZWFyID0gY2x1c3RlcnNVbmlmb3JtLm5lYXIgKiBwb3coY2x1c3RlcnNVbmlmb3JtLmZhciAvIGNsdXN0ZXJzVW5pZm9ybS5uZWFyLCBmMzIoaykgLyBjbHVzdGVyc1VuaWZvcm0uY2x1c3RlclRpbGVaKTtcblx0ICAgICAgICB2YXIgdGlsZUZhciA9IGNsdXN0ZXJzVW5pZm9ybS5uZWFyICogcG93KGNsdXN0ZXJzVW5pZm9ybS5mYXIgLyBjbHVzdGVyc1VuaWZvcm0ubmVhciwgKGYzMihrKSArIDEuMCkgLyBjbHVzdGVyc1VuaWZvcm0uY2x1c3RlclRpbGVaKTtcblxuICAgICAgICAgICAgdmFyIG1pblBvaW50TmVhciA9IExpbmVJbnRlcnNlY3Rpb25Ub1pQbGFuZShleWVQb3MsIG1pblBvaW50VnMsIHRpbGVOZWFyKTtcbiAgICAgICAgICAgIHZhciBtaW5Qb2ludEZhciA9IExpbmVJbnRlcnNlY3Rpb25Ub1pQbGFuZShleWVQb3MsIG1pblBvaW50VnMsIHRpbGVGYXIpO1xuICAgICAgICAgICAgdmFyIG1heFBvaW50TmVhciA9IExpbmVJbnRlcnNlY3Rpb25Ub1pQbGFuZShleWVQb3MsIG1heFBvaW50VnMsIHRpbGVOZWFyKTtcbiAgICAgICAgICAgIHZhciBtYXhQb2ludEZhciA9IExpbmVJbnRlcnNlY3Rpb25Ub1pQbGFuZShleWVQb3MsIG1heFBvaW50VnMsIHRpbGVGYXIpO1xuXG4gICAgICAgICAgICB2YXIgbWluUG9pbnRBQUJCID0gbWluKG1pbihtaW5Qb2ludE5lYXIsIG1pblBvaW50RmFyKSwgbWluKG1heFBvaW50TmVhciwgbWF4UG9pbnRGYXIpKTtcbiAgICAgICAgICAgIHZhciBtYXhQb2ludEFBQkIgPSBtYXgobWF4KG1pblBvaW50TmVhciwgbWluUG9pbnRGYXIpLCBtYXgobWF4UG9pbnROZWFyLCBtYXhQb2ludEZhcikpO1xuXG4gICAgICAgICAgICB2YXIgY2x1c3RlckJveCA6IENsdXN0ZXJCb3ggO1xuICAgICAgICAgICAgY2x1c3RlckJveC5taW5Qb2ludCA9IHZlYzQ8ZjMyPihtaW5Qb2ludEFBQkIsZjMyKHRpbGVJbmRleCkpIDtcbiAgICAgICAgICAgIGNsdXN0ZXJCb3gubWF4UG9pbnQgPSB2ZWM0PGYzMj4obWF4UG9pbnRBQUJCLGYzMih0aWxlSW5kZXgpKSA7XG4gICAgICAgICAgICBjbHVzdGVyQnVmZmVyW3RpbGVJbmRleF0gPSBjbHVzdGVyQm94O1xuICAgICAgICB9XG5gLHJoPWBcbiNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG5cbnN0cnVjdCBDbHVzdGVyQm94e1xuICAgIG1pbjp2ZWM0PGYzMj4sXG4gICAgbWF4OnZlYzQ8ZjMyPlxufVxuXG5zdHJ1Y3QgTGlnaHQge1xuICAgIGluZGV4OmYzMixcbiAgICBsaWdodFR5cGU6aTMyLFxuICAgIHJhZGl1czpmMzIsXG4gICAgbGluZWFyOmYzMixcblxuICAgIHBvc2l0aW9uOnZlYzM8ZjMyPixcbiAgICBsaWdodE1hdHJpeEluZGV4OmYzMixcblxuICAgIGRpcmVjdGlvbjp2ZWMzPGYzMj4sXG4gICAgcXVhZHJhdGljOmYzMixcblxuICAgIGxpZ2h0Q29sb3I6dmVjMzxmMzI+LFxuICAgIGludGVuc2l0eTpmMzIsXG5cbiAgICBpbm5lckN1dE9mZiA6ZjMyLFxuICAgIG91dGVyQ3V0T2ZmOmYzMixcbiAgICByYW5nZSA6ZjMyLFxuICAgIGNhc3RTaGFkb3c6ZjMyLFxuXG4gICAgbGlnaHRUYW5nZW50OnZlYzM8ZjMyPixcbiAgICBpZXM6ZjMyLFxufTtcblxuc3RydWN0IExpZ2h0SW5kZXhcbntcbiAgICBjb3VudDpmMzIsXG4gICAgc3RhcnQ6ZjMyLFxuICAgIGVtcHR5MDpmMzIsXG4gICAgZW1wdHkxOmYzMixcbn07XG5cbnN0cnVjdCBDbHVzdGVyc1VuaWZvcm17XG4gICAgY2x1c3RlclRpbGVYOmYzMixcbiAgICBjbHVzdGVyVGlsZVk6ZjMyLFxuICAgIGNsdXN0ZXJUaWxlWjpmMzIsXG4gICAgbnVtTGlnaHRzOmYzMixcbiAgICBtYXhOdW1MaWdodHNQZXJDbHVzdGVyOmYzMixcbiAgICBuZWFyOmYzMixcbiAgICBmYXI6ZjMyLFxuICAgIHNjcmVlbldpZHRoOmYzMixcbiAgICBzY3JlZW5IZWlnaHQ6ZjMyLFxuICAgIGNsdXN0ZXJQaXg6ZjMyLCBcbn1cblxudmFyPHByaXZhdGU+IGNsdXN0ZXJUaWxlWDpmMzIgO1xudmFyPHByaXZhdGU+IGNsdXN0ZXJUaWxlWTpmMzIgO1xudmFyPHByaXZhdGU+IGNsdXN0ZXJUaWxlWjpmMzIgO1xuXG4vLyBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IG1vZGVscyA6IFVuaWZvcm1zO1xuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjx1bmlmb3JtPiBjbHVzdGVyc1VuaWZvcm0gOiBDbHVzdGVyc1VuaWZvcm07XG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UscmVhZD4gY2x1c3RlckJ1ZmZlciA6IGFycmF5PENsdXN0ZXJCb3g+O1xuQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLHJlYWQ+IGxpZ2h0QnVmZmVyIDogYXJyYXk8TGlnaHQ+OyBcbkBncm91cCgwKSBAYmluZGluZyg0KSB2YXI8c3RvcmFnZSxyZWFkX3dyaXRlPiBsaWdodEFzc2lnbkJ1ZmZlciA6IGFycmF5PGYzMj47XG5AZ3JvdXAoMCkgQGJpbmRpbmcoNSkgdmFyPHN0b3JhZ2UscmVhZF93cml0ZT4gYXNzaWduVGFibGUgOiBhcnJheTxMaWdodEluZGV4PjtcblxuZm4gZ3JpZFRvSW5kZXgoaTp2ZWMzPHUzMj4pIC0+IHUzMntcbiAgICByZXR1cm4gaS56ICogdTMyKGNsdXN0ZXJUaWxlWCkgKiB1MzIoY2x1c3RlclRpbGVZKSArIGkueSAqIHUzMihjbHVzdGVyVGlsZVgpICsgaS54IDtcbn1cblxuZm4gR2V0U3FkaXNQb2ludEFBQkIoIHBvczp2ZWMzPGYzMj4sICBjbHVzdGVyOkNsdXN0ZXJCb3ggICkgLT4gZjMyXG57XG4gICAgdmFyIHNxRGlzdGFuY2UgPSAwLjA7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgM3U7IGkrPTF1KVxuICAgIHtcbiAgICAgICAgdmFyIHYgPSBwb3NbaV07XG4gICAgICAgIGlmICh2IDwgY2x1c3Rlci5taW5baV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBkaWZmID0gY2x1c3Rlci5taW5baV0gLSB2O1xuICAgICAgICAgICAgc3FEaXN0YW5jZSArPSBkaWZmICogZGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ID4gY2x1c3Rlci5tYXhbaV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBkaWZmID0gIHYgLSBjbHVzdGVyLm1heFtpXTtcbiAgICAgICAgICAgIHNxRGlzdGFuY2UgKz0gZGlmZiAqIGRpZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNxRGlzdGFuY2U7XG59XG5cbmZuIFRlc3RTcGhlcmVBQUJCKCBib3g6Q2x1c3RlckJveCAsbGlnaHQ6TGlnaHQgKSAtPiBib29sXG57XG4gICAgbGV0IGxpZ2h0UG9zID0gbGlnaHQucG9zaXRpb24ueHl6O1xuICAgIHZhciByYWRpdXMgPSBsaWdodC5yYW5nZSAqIDIuMCA7XG4gICAgdmFyIHNwaGVyZVBvcyA9IGdsb2JhbFVuaWZvcm0udmlld01hdCAqIHZlYzQ8ZjMyPihsaWdodFBvcy54eXosIDEuMCkgO1xuICAgIHNwaGVyZVBvcyA9IHNwaGVyZVBvcyAvIHNwaGVyZVBvcy53IDtcbiAgICBsZXQgc3FEaXN0YW5jZSA9IEdldFNxZGlzUG9pbnRBQUJCKHNwaGVyZVBvcy54eXogLCBib3gpO1xuICAgIHJldHVybiBzcURpc3RhbmNlIDw9IChyYWRpdXMqcmFkaXVzKTtcbn1cblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7a2UuY2x1c3RlclRpbGVYfSwke2tlLmNsdXN0ZXJUaWxlWX0sMSlcbmZuIENzTWFpbiggQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4gLCBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+ICl7XG4gICAgLy8gY2x1c3RlciBJRCBcbiAgICBsZXQgaSA9IGxvY2FsX2ludm9jYXRpb25faWQueCA7XG4gICAgbGV0IGogPSBsb2NhbF9pbnZvY2F0aW9uX2lkLnkgO1xuICAgIGxldCBrID0gd29ya2dyb3VwX2lkLnggO1xuXG4gICAgY2x1c3RlclRpbGVYID0gY2x1c3RlcnNVbmlmb3JtLmNsdXN0ZXJUaWxlWDtcbiAgICBjbHVzdGVyVGlsZVkgPSBjbHVzdGVyc1VuaWZvcm0uY2x1c3RlclRpbGVZO1xuICAgIGNsdXN0ZXJUaWxlWiA9IGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVo7XG5cbiAgICB2YXIgY2x1c3RlcklkXzNEID0gdmVjMzx1MzI+KGksaixrKTtcbiAgICB2YXIgY2x1c3RlcklkXzFEID0gZ3JpZFRvSW5kZXgoY2x1c3RlcklkXzNEKTtcblxuICAgIHZhciBib3g6Q2x1c3RlckJveCA9IGNsdXN0ZXJCdWZmZXJbY2x1c3RlcklkXzFEXTtcblxuICAgIHZhciBzdGFydEluZGV4ID0gaTMyKGNsdXN0ZXJJZF8xRCkgKiBpMzIoY2x1c3RlcnNVbmlmb3JtLm1heE51bUxpZ2h0c1BlckNsdXN0ZXIpIDtcbiAgICB2YXIgZW5kSW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgZm9yKHZhciBsaWdodElEID0gMCA7IGxpZ2h0SUQgPCBpMzIoY2x1c3RlcnNVbmlmb3JtLm51bUxpZ2h0cykgOyBsaWdodElEKz0xKVxuICAgIHtcbiAgICAgICAgbGV0IGxpOkxpZ2h0ID0gbGlnaHRCdWZmZXJbbGlnaHRJRF07XG4gICAgICAgIGlmKCFUZXN0U3BoZXJlQUFCQihib3gsIGxpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGlnaHRBc3NpZ25CdWZmZXJbZW5kSW5kZXhdID0gZjMyKGxpZ2h0SUQpO1xuICAgICAgICBlbmRJbmRleCsrO1xuICAgIH1cblxuICAgIHZhciBpZHg6IExpZ2h0SW5kZXg7XG4gICAgaWR4LmNvdW50ID0gZjMyKGVuZEluZGV4LXN0YXJ0SW5kZXgpO1xuICAgIGlkeC5zdGFydCA9IGYzMihzdGFydEluZGV4KTtcbiAgICBpZHguZW1wdHkwID0gZjMyKGNsdXN0ZXJJZF8xRCk7XG4gICAgaWR4LmVtcHR5MSA9IGYzMihjbHVzdGVyc1VuaWZvcm0ubWF4TnVtTGlnaHRzUGVyQ2x1c3Rlcik7XG4gICAgYXNzaWduVGFibGVbY2x1c3RlcklkXzFEXSA9IGlkeDtcbn1cbmA7ZnVuY3Rpb24gamQoaSl7aWYoaSYmISh0eXBlb2Ygd2luZG93PlwidVwiKSl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO3JldHVybiBlLnNldEF0dHJpYnV0ZShcInR5cGVcIixcInRleHQvY3NzXCIpLGUuaW5uZXJIVE1MPWksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKSxpfX1mdW5jdGlvbiBycihpLGUpe3ZhciB0PWkuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpLHI9TWF0aC5yb3VuZChpLnIpLHM9TWF0aC5yb3VuZChpLmcpLGE9TWF0aC5yb3VuZChpLmIpLG49aS5hLGw9TWF0aC5yb3VuZChpLmgpLGg9aS5zLnRvRml4ZWQoMSksdT1pLnYudG9GaXhlZCgxKTtpZihlfHx0PT09XCJUSFJFRV9DSEFSX0hFWFwifHx0PT09XCJTSVhfQ0hBUl9IRVhcIil7Zm9yKHZhciBjPWkuaGV4LnRvU3RyaW5nKDE2KTtjLmxlbmd0aDw2OyljPVwiMFwiK2M7cmV0dXJuXCIjXCIrY31lbHNle2lmKHQ9PT1cIkNTU19SR0JcIilyZXR1cm5cInJnYihcIityK1wiLFwiK3MrXCIsXCIrYStcIilcIjtpZih0PT09XCJDU1NfUkdCQVwiKXJldHVyblwicmdiYShcIityK1wiLFwiK3MrXCIsXCIrYStcIixcIituK1wiKVwiO2lmKHQ9PT1cIkhFWFwiKXJldHVyblwiMHhcIitpLmhleC50b1N0cmluZygxNik7aWYodD09PVwiUkdCX0FSUkFZXCIpcmV0dXJuXCJbXCIrcitcIixcIitzK1wiLFwiK2ErXCJdXCI7aWYodD09PVwiUkdCQV9BUlJBWVwiKXJldHVyblwiW1wiK3IrXCIsXCIrcytcIixcIithK1wiLFwiK24rXCJdXCI7aWYodD09PVwiUkdCX09CSlwiKXJldHVyblwie3I6XCIrcitcIixnOlwiK3MrXCIsYjpcIithK1wifVwiO2lmKHQ9PT1cIlJHQkFfT0JKXCIpcmV0dXJuXCJ7cjpcIityK1wiLGc6XCIrcytcIixiOlwiK2ErXCIsYTpcIituK1wifVwiO2lmKHQ9PT1cIkhTVl9PQkpcIilyZXR1cm5cIntoOlwiK2wrXCIsczpcIitoK1wiLHY6XCIrdStcIn1cIjtpZih0PT09XCJIU1ZBX09CSlwiKXJldHVyblwie2g6XCIrbCtcIixzOlwiK2grXCIsdjpcIit1K1wiLGE6XCIrbitcIn1cIn1yZXR1cm5cInVua25vd24gZm9ybWF0XCJ9dmFyIHNoPUFycmF5LnByb3RvdHlwZS5mb3JFYWNoLEtyPUFycmF5LnByb3RvdHlwZS5zbGljZSxVPXtCUkVBSzp7fSxleHRlbmQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChLci5jYWxsKGFyZ3VtZW50cywxKSxmdW5jdGlvbih0KXt2YXIgcj10aGlzLmlzT2JqZWN0KHQpP09iamVjdC5rZXlzKHQpOltdO3IuZm9yRWFjaChmdW5jdGlvbihzKXt0aGlzLmlzVW5kZWZpbmVkKHRbc10pfHwoZVtzXT10W3NdKX0uYmluZCh0aGlzKSl9LHRoaXMpLGV9LGRlZmF1bHRzOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goS3IuY2FsbChhcmd1bWVudHMsMSksZnVuY3Rpb24odCl7dmFyIHI9dGhpcy5pc09iamVjdCh0KT9PYmplY3Qua2V5cyh0KTpbXTtyLmZvckVhY2goZnVuY3Rpb24ocyl7dGhpcy5pc1VuZGVmaW5lZChlW3NdKSYmKGVbc109dFtzXSl9LmJpbmQodGhpcykpfSx0aGlzKSxlfSxjb21wb3NlOmZ1bmN0aW9uKCl7dmFyIGU9S3IuY2FsbChhcmd1bWVudHMpO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1Lci5jYWxsKGFyZ3VtZW50cykscj1lLmxlbmd0aC0xO3I+PTA7ci0tKXQ9W2Vbcl0uYXBwbHkodGhpcyx0KV07cmV0dXJuIHRbMF19fSxlYWNoOmZ1bmN0aW9uKGUsdCxyKXtpZihlKXtpZihzaCYmZS5mb3JFYWNoJiZlLmZvckVhY2g9PT1zaCllLmZvckVhY2godCxyKTtlbHNlIGlmKGUubGVuZ3RoPT09ZS5sZW5ndGgrMCl7dmFyIHM9dm9pZCAwLGE9dm9pZCAwO2ZvcihzPTAsYT1lLmxlbmd0aDtzPGE7cysrKWlmKHMgaW4gZSYmdC5jYWxsKHIsZVtzXSxzKT09PXRoaXMuQlJFQUspcmV0dXJufWVsc2UgZm9yKHZhciBuIGluIGUpaWYodC5jYWxsKHIsZVtuXSxuKT09PXRoaXMuQlJFQUspcmV0dXJufX0sZGVmZXI6ZnVuY3Rpb24oZSl7c2V0VGltZW91dChlLDApfSxkZWJvdW5jZTpmdW5jdGlvbihlLHQscil7dmFyIHM9dm9pZCAwO3JldHVybiBmdW5jdGlvbigpe3ZhciBhPXRoaXMsbj1hcmd1bWVudHM7ZnVuY3Rpb24gbCgpe3M9bnVsbCxyfHxlLmFwcGx5KGEsbil9dmFyIGg9cnx8IXM7Y2xlYXJUaW1lb3V0KHMpLHM9c2V0VGltZW91dChsLHQpLGgmJmUuYXBwbHkoYSxuKX19LHRvQXJyYXk6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9BcnJheT9lLnRvQXJyYXkoKTpLci5jYWxsKGUpfSxpc1VuZGVmaW5lZDpmdW5jdGlvbihlKXtyZXR1cm4gZT09PXZvaWQgMH0saXNOdWxsOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09bnVsbH0saXNOYU46ZnVuY3Rpb24oaSl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gaS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gaS50b1N0cmluZygpfSxlfShmdW5jdGlvbihpKXtyZXR1cm4gaXNOYU4oaSl9KSxpc0FycmF5OkFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGkpe3JldHVybiBpLmNvbnN0cnVjdG9yPT09QXJyYXl9LGlzT2JqZWN0OmZ1bmN0aW9uKGUpe3JldHVybiBlPT09T2JqZWN0KGUpfSxpc051bWJlcjpmdW5jdGlvbihlKXtyZXR1cm4gZT09PWUrMH0saXNTdHJpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1lK1wiXCJ9LGlzQm9vbGVhbjpmdW5jdGlvbihlKXtyZXR1cm4gZT09PSExfHxlPT09ITB9LGlzRnVuY3Rpb246ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBGdW5jdGlvbn19LHFkPVt7bGl0bXVzOlUuaXNTdHJpbmcsY29udmVyc2lvbnM6e1RIUkVFX0NIQVJfSEVYOntyZWFkOmZ1bmN0aW9uKGUpe3ZhciB0PWUubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtyZXR1cm4gdD09PW51bGw/ITE6e3NwYWNlOlwiSEVYXCIsaGV4OnBhcnNlSW50KFwiMHhcIit0WzFdLnRvU3RyaW5nKCkrdFsxXS50b1N0cmluZygpK3RbMl0udG9TdHJpbmcoKSt0WzJdLnRvU3RyaW5nKCkrdFszXS50b1N0cmluZygpK3RbM10udG9TdHJpbmcoKSwwKX19LHdyaXRlOnJyfSxTSVhfQ0hBUl9IRVg6e3JlYWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtyZXR1cm4gdD09PW51bGw/ITE6e3NwYWNlOlwiSEVYXCIsaGV4OnBhcnNlSW50KFwiMHhcIit0WzFdLnRvU3RyaW5nKCksMCl9fSx3cml0ZTpycn0sQ1NTX1JHQjp7cmVhZDpmdW5jdGlvbihlKXt2YXIgdD1lLm1hdGNoKC9ecmdiXFwoXFxzKihcXFMrKVxccyosXFxzKihcXFMrKVxccyosXFxzKihcXFMrKVxccypcXCkvKTtyZXR1cm4gdD09PW51bGw/ITE6e3NwYWNlOlwiUkdCXCIscjpwYXJzZUZsb2F0KHRbMV0pLGc6cGFyc2VGbG9hdCh0WzJdKSxiOnBhcnNlRmxvYXQodFszXSl9fSx3cml0ZTpycn0sQ1NTX1JHQkE6e3JlYWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5tYXRjaCgvXnJnYmFcXChcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKlxcKS8pO3JldHVybiB0PT09bnVsbD8hMTp7c3BhY2U6XCJSR0JcIixyOnBhcnNlRmxvYXQodFsxXSksZzpwYXJzZUZsb2F0KHRbMl0pLGI6cGFyc2VGbG9hdCh0WzNdKSxhOnBhcnNlRmxvYXQodFs0XSl9fSx3cml0ZTpycn19fSx7bGl0bXVzOlUuaXNOdW1iZXIsY29udmVyc2lvbnM6e0hFWDp7cmVhZDpmdW5jdGlvbihlKXtyZXR1cm57c3BhY2U6XCJIRVhcIixoZXg6ZSxjb252ZXJzaW9uTmFtZTpcIkhFWFwifX0sd3JpdGU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGV4fX19fSx7bGl0bXVzOlUuaXNBcnJheSxjb252ZXJzaW9uczp7UkdCX0FSUkFZOntyZWFkOmZ1bmN0aW9uKGUpe3JldHVybiBlLmxlbmd0aCE9PTM/ITE6e3NwYWNlOlwiUkdCXCIscjplWzBdLGc6ZVsxXSxiOmVbMl19fSx3cml0ZTpmdW5jdGlvbihlKXtyZXR1cm5bZS5yLGUuZyxlLmJdfX0sUkdCQV9BUlJBWTp7cmVhZDpmdW5jdGlvbihlKXtyZXR1cm4gZS5sZW5ndGghPT00PyExOntzcGFjZTpcIlJHQlwiLHI6ZVswXSxnOmVbMV0sYjplWzJdLGE6ZVszXX19LHdyaXRlOmZ1bmN0aW9uKGUpe3JldHVybltlLnIsZS5nLGUuYixlLmFdfX19fSx7bGl0bXVzOlUuaXNPYmplY3QsY29udmVyc2lvbnM6e1JHQkFfT0JKOntyZWFkOmZ1bmN0aW9uKGUpe3JldHVybiBVLmlzTnVtYmVyKGUucikmJlUuaXNOdW1iZXIoZS5nKSYmVS5pc051bWJlcihlLmIpJiZVLmlzTnVtYmVyKGUuYSk/e3NwYWNlOlwiUkdCXCIscjplLnIsZzplLmcsYjplLmIsYTplLmF9OiExfSx3cml0ZTpmdW5jdGlvbihlKXtyZXR1cm57cjplLnIsZzplLmcsYjplLmIsYTplLmF9fX0sUkdCX09CSjp7cmVhZDpmdW5jdGlvbihlKXtyZXR1cm4gVS5pc051bWJlcihlLnIpJiZVLmlzTnVtYmVyKGUuZykmJlUuaXNOdW1iZXIoZS5iKT97c3BhY2U6XCJSR0JcIixyOmUucixnOmUuZyxiOmUuYn06ITF9LHdyaXRlOmZ1bmN0aW9uKGUpe3JldHVybntyOmUucixnOmUuZyxiOmUuYn19fSxIU1ZBX09CSjp7cmVhZDpmdW5jdGlvbihlKXtyZXR1cm4gVS5pc051bWJlcihlLmgpJiZVLmlzTnVtYmVyKGUucykmJlUuaXNOdW1iZXIoZS52KSYmVS5pc051bWJlcihlLmEpP3tzcGFjZTpcIkhTVlwiLGg6ZS5oLHM6ZS5zLHY6ZS52LGE6ZS5hfTohMX0sd3JpdGU6ZnVuY3Rpb24oZSl7cmV0dXJue2g6ZS5oLHM6ZS5zLHY6ZS52LGE6ZS5hfX19LEhTVl9PQko6e3JlYWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIFUuaXNOdW1iZXIoZS5oKSYmVS5pc051bWJlcihlLnMpJiZVLmlzTnVtYmVyKGUudik/e3NwYWNlOlwiSFNWXCIsaDplLmgsczplLnMsdjplLnZ9OiExfSx3cml0ZTpmdW5jdGlvbihlKXtyZXR1cm57aDplLmgsczplLnMsdjplLnZ9fX19fV0sSnI9dm9pZCAwLHpzPXZvaWQgMCxjbz1mdW5jdGlvbigpe3pzPSExO3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MT9VLnRvQXJyYXkoYXJndW1lbnRzKTphcmd1bWVudHNbMF07cmV0dXJuIFUuZWFjaChxZCxmdW5jdGlvbih0KXtpZih0LmxpdG11cyhlKSlyZXR1cm4gVS5lYWNoKHQuY29udmVyc2lvbnMsZnVuY3Rpb24ocixzKXtpZihKcj1yLnJlYWQoZSksenM9PT0hMSYmSnIhPT0hMSlyZXR1cm4genM9SnIsSnIuY29udmVyc2lvbk5hbWU9cyxKci5jb252ZXJzaW9uPXIsVS5CUkVBS30pLFUuQlJFQUt9KSx6c30sYWg9dm9pZCAwLEdzPXtoc3ZfdG9fcmdiOmZ1bmN0aW9uKGUsdCxyKXt2YXIgcz1NYXRoLmZsb29yKGUvNjApJTYsYT1lLzYwLU1hdGguZmxvb3IoZS82MCksbj1yKigxLXQpLGw9ciooMS1hKnQpLGg9ciooMS0oMS1hKSp0KSx1PVtbcixoLG5dLFtsLHIsbl0sW24scixoXSxbbixsLHJdLFtoLG4scl0sW3IsbixsXV1bc107cmV0dXJue3I6dVswXSoyNTUsZzp1WzFdKjI1NSxiOnVbMl0qMjU1fX0scmdiX3RvX2hzdjpmdW5jdGlvbihlLHQscil7dmFyIHM9TWF0aC5taW4oZSx0LHIpLGE9TWF0aC5tYXgoZSx0LHIpLG49YS1zLGw9dm9pZCAwLGg9dm9pZCAwO2lmKGEhPT0wKWg9bi9hO2Vsc2UgcmV0dXJue2g6TmFOLHM6MCx2OjB9O3JldHVybiBlPT09YT9sPSh0LXIpL246dD09PWE/bD0yKyhyLWUpL246bD00KyhlLXQpL24sbC89NixsPDAmJihsKz0xKSx7aDpsKjM2MCxzOmgsdjphLzI1NX19LHJnYl90b19oZXg6ZnVuY3Rpb24oZSx0LHIpe3ZhciBzPXRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsMixlKTtyZXR1cm4gcz10aGlzLmhleF93aXRoX2NvbXBvbmVudChzLDEsdCkscz10aGlzLmhleF93aXRoX2NvbXBvbmVudChzLDAsciksc30sY29tcG9uZW50X2Zyb21faGV4OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+PnQqOCYyNTV9LGhleF93aXRoX2NvbXBvbmVudDpmdW5jdGlvbihlLHQscil7cmV0dXJuIHI8PChhaD10KjgpfGUmfigyNTU8PGFoKX19LEtkPXR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09XCJzeW1ib2xcIj9mdW5jdGlvbihpKXtyZXR1cm4gdHlwZW9mIGl9OmZ1bmN0aW9uKGkpe3JldHVybiBpJiZ0eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJmkuY29uc3RydWN0b3I9PT1TeW1ib2wmJmkhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGl9LFJ0PWZ1bmN0aW9uKGksZSl7aWYoIShpIGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0sTHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBzPXRbcl07cy5lbnVtZXJhYmxlPXMuZW51bWVyYWJsZXx8ITEscy5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gcyYmKHMud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHMua2V5LHMpfX1yZXR1cm4gZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0JiZpKGUucHJvdG90eXBlLHQpLHImJmkoZSxyKSxlfX0oKSxnaT1mdW5jdGlvbiBpKGUsdCxyKXtlPT09bnVsbCYmKGU9RnVuY3Rpb24ucHJvdG90eXBlKTt2YXIgcz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCk7aWYocz09PXZvaWQgMCl7dmFyIGE9T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO3JldHVybiBhPT09bnVsbD92b2lkIDA6aShhLHQscil9ZWxzZXtpZihcInZhbHVlXCJpbiBzKXJldHVybiBzLnZhbHVlO3ZhciBuPXMuZ2V0O3JldHVybiBuPT09dm9pZCAwP3ZvaWQgMDpuLmNhbGwocil9fSxwaT1mdW5jdGlvbihpLGUpe2lmKHR5cGVvZiBlIT1cImZ1bmN0aW9uXCImJmUhPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTtpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6aSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihpLGUpOmkuX19wcm90b19fPWUpfSxtaT1mdW5jdGlvbihpLGUpe2lmKCFpKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gZSYmKHR5cGVvZiBlPT1cIm9iamVjdFwifHx0eXBlb2YgZT09XCJmdW5jdGlvblwiKT9lOml9LFllPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaSgpe2lmKFJ0KHRoaXMsaSksdGhpcy5fX3N0YXRlPWNvLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLl9fc3RhdGU9PT0hMSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50c1wiKTt0aGlzLl9fc3RhdGUuYT10aGlzLl9fc3RhdGUuYXx8MX1yZXR1cm4gTHQoaSxbe2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gcnIodGhpcyl9fSx7a2V5OlwidG9IZXhTdHJpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBycih0aGlzLCEwKX19LHtrZXk6XCJ0b09yaWdpbmFsXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyl9fV0pLGl9KCk7ZnVuY3Rpb24gZm8oaSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShpLGUse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fc3RhdGUuc3BhY2U9PT1cIlJHQlwiP3RoaXMuX19zdGF0ZVtlXTooWWUucmVjYWxjdWxhdGVSR0IodGhpcyxlLHQpLHRoaXMuX19zdGF0ZVtlXSl9LHNldDpmdW5jdGlvbihzKXt0aGlzLl9fc3RhdGUuc3BhY2UhPT1cIlJHQlwiJiYoWWUucmVjYWxjdWxhdGVSR0IodGhpcyxlLHQpLHRoaXMuX19zdGF0ZS5zcGFjZT1cIlJHQlwiKSx0aGlzLl9fc3RhdGVbZV09c319KX1mdW5jdGlvbiBnbyhpLGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShpLGUse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fc3RhdGUuc3BhY2U9PT1cIkhTVlwiP3RoaXMuX19zdGF0ZVtlXTooWWUucmVjYWxjdWxhdGVIU1YodGhpcyksdGhpcy5fX3N0YXRlW2VdKX0sc2V0OmZ1bmN0aW9uKHIpe3RoaXMuX19zdGF0ZS5zcGFjZSE9PVwiSFNWXCImJihZZS5yZWNhbGN1bGF0ZUhTVih0aGlzKSx0aGlzLl9fc3RhdGUuc3BhY2U9XCJIU1ZcIiksdGhpcy5fX3N0YXRlW2VdPXJ9fSl9WWUucmVjYWxjdWxhdGVSR0I9ZnVuY3Rpb24oaSxlLHQpe2lmKGkuX19zdGF0ZS5zcGFjZT09PVwiSEVYXCIpaS5fX3N0YXRlW2VdPUdzLmNvbXBvbmVudF9mcm9tX2hleChpLl9fc3RhdGUuaGV4LHQpO2Vsc2UgaWYoaS5fX3N0YXRlLnNwYWNlPT09XCJIU1ZcIilVLmV4dGVuZChpLl9fc3RhdGUsR3MuaHN2X3RvX3JnYihpLl9fc3RhdGUuaCxpLl9fc3RhdGUucyxpLl9fc3RhdGUudikpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIGNvbG9yIHN0YXRlXCIpfSxZZS5yZWNhbGN1bGF0ZUhTVj1mdW5jdGlvbihpKXt2YXIgZT1Hcy5yZ2JfdG9faHN2KGkucixpLmcsaS5iKTtVLmV4dGVuZChpLl9fc3RhdGUse3M6ZS5zLHY6ZS52fSksVS5pc05hTihlLmgpP1UuaXNVbmRlZmluZWQoaS5fX3N0YXRlLmgpJiYoaS5fX3N0YXRlLmg9MCk6aS5fX3N0YXRlLmg9ZS5ofSxZZS5DT01QT05FTlRTPVtcInJcIixcImdcIixcImJcIixcImhcIixcInNcIixcInZcIixcImhleFwiLFwiYVwiXSxmbyhZZS5wcm90b3R5cGUsXCJyXCIsMiksZm8oWWUucHJvdG90eXBlLFwiZ1wiLDEpLGZvKFllLnByb3RvdHlwZSxcImJcIiwwKSxnbyhZZS5wcm90b3R5cGUsXCJoXCIpLGdvKFllLnByb3RvdHlwZSxcInNcIiksZ28oWWUucHJvdG90eXBlLFwidlwiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoWWUucHJvdG90eXBlLFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX3N0YXRlLmF9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9fc3RhdGUuYT1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShZZS5wcm90b3R5cGUsXCJoZXhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19zdGF0ZS5zcGFjZSE9PVwiSEVYXCImJih0aGlzLl9fc3RhdGUuaGV4PUdzLnJnYl90b19oZXgodGhpcy5yLHRoaXMuZyx0aGlzLmIpLHRoaXMuX19zdGF0ZS5zcGFjZT1cIkhFWFwiKSx0aGlzLl9fc3RhdGUuaGV4fSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fX3N0YXRlLnNwYWNlPVwiSEVYXCIsdGhpcy5fX3N0YXRlLmhleD1lfX0pO3ZhciBNaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGkoZSx0KXtSdCh0aGlzLGkpLHRoaXMuaW5pdGlhbFZhbHVlPWVbdF0sdGhpcy5kb21FbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5vYmplY3Q9ZSx0aGlzLnByb3BlcnR5PXQsdGhpcy5fX29uQ2hhbmdlPXZvaWQgMCx0aGlzLl9fb25GaW5pc2hDaGFuZ2U9dm9pZCAwfXJldHVybiBMdChpLFt7a2V5Olwib25DaGFuZ2VcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fX29uQ2hhbmdlPXQsdGhpc319LHtrZXk6XCJvbkZpbmlzaENoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9fb25GaW5pc2hDaGFuZ2U9dCx0aGlzfX0se2tleTpcInNldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldPXQsdGhpcy5fX29uQ2hhbmdlJiZ0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzLHQpLHRoaXMudXBkYXRlRGlzcGxheSgpLHRoaXN9fSx7a2V5OlwiZ2V0VmFsdWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XX19LHtrZXk6XCJ1cGRhdGVEaXNwbGF5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319LHtrZXk6XCJpc01vZGlmaWVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbml0aWFsVmFsdWUhPT10aGlzLmdldFZhbHVlKCl9fV0pLGl9KCksSmQ9e0hUTUxFdmVudHM6W1wiY2hhbmdlXCJdLE1vdXNlRXZlbnRzOltcImNsaWNrXCIsXCJtb3VzZW1vdmVcIixcIm1vdXNlZG93blwiLFwibW91c2V1cFwiLFwibW91c2VvdmVyXCJdLEtleWJvYXJkRXZlbnRzOltcImtleWRvd25cIl19LG9oPXt9O1UuZWFjaChKZCxmdW5jdGlvbihpLGUpe1UuZWFjaChpLGZ1bmN0aW9uKHQpe29oW3RdPWV9KX0pO3ZhciBaZD0vKFxcZCsoXFwuXFxkKyk/KXB4LztmdW5jdGlvbiBZdChpKXtpZihpPT09XCIwXCJ8fFUuaXNVbmRlZmluZWQoaSkpcmV0dXJuIDA7dmFyIGU9aS5tYXRjaChaZCk7cmV0dXJuIFUuaXNOdWxsKGUpPzA6cGFyc2VGbG9hdChlWzFdKX12YXIgRT17bWFrZVNlbGVjdGFibGU6ZnVuY3Rpb24oZSx0KXtlPT09dm9pZCAwfHxlLnN0eWxlPT09dm9pZCAwfHwoZS5vbnNlbGVjdHN0YXJ0PXQ/ZnVuY3Rpb24oKXtyZXR1cm4hMX06ZnVuY3Rpb24oKXt9LGUuc3R5bGUuTW96VXNlclNlbGVjdD10P1wiYXV0b1wiOlwibm9uZVwiLGUuc3R5bGUuS2h0bWxVc2VyU2VsZWN0PXQ/XCJhdXRvXCI6XCJub25lXCIsZS51bnNlbGVjdGFibGU9dD9cIm9uXCI6XCJvZmZcIil9LG1ha2VGdWxsc2NyZWVuOmZ1bmN0aW9uKGUsdCxyKXt2YXIgcz1yLGE9dDtVLmlzVW5kZWZpbmVkKGEpJiYoYT0hMCksVS5pc1VuZGVmaW5lZChzKSYmKHM9ITApLGUuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGEmJihlLnN0eWxlLmxlZnQ9MCxlLnN0eWxlLnJpZ2h0PTApLHMmJihlLnN0eWxlLnRvcD0wLGUuc3R5bGUuYm90dG9tPTApfSxmYWtlRXZlbnQ6ZnVuY3Rpb24oZSx0LHIscyl7dmFyIGE9cnx8e30sbj1vaFt0XTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCB0eXBlIFwiK3QrXCIgbm90IHN1cHBvcnRlZC5cIik7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRXZlbnQobik7c3dpdGNoKG4pe2Nhc2VcIk1vdXNlRXZlbnRzXCI6e3ZhciBoPWEueHx8YS5jbGllbnRYfHwwLHU9YS55fHxhLmNsaWVudFl8fDA7bC5pbml0TW91c2VFdmVudCh0LGEuYnViYmxlc3x8ITEsYS5jYW5jZWxhYmxlfHwhMCx3aW5kb3csYS5jbGlja0NvdW50fHwxLDAsMCxoLHUsITEsITEsITEsITEsMCxudWxsKTticmVha31jYXNlXCJLZXlib2FyZEV2ZW50c1wiOnt2YXIgYz1sLmluaXRLZXlib2FyZEV2ZW50fHxsLmluaXRLZXlFdmVudDtVLmRlZmF1bHRzKGEse2NhbmNlbGFibGU6ITAsY3RybEtleTohMSxhbHRLZXk6ITEsc2hpZnRLZXk6ITEsbWV0YUtleTohMSxrZXlDb2RlOnZvaWQgMCxjaGFyQ29kZTp2b2lkIDB9KSxjKHQsYS5idWJibGVzfHwhMSxhLmNhbmNlbGFibGUsd2luZG93LGEuY3RybEtleSxhLmFsdEtleSxhLnNoaWZ0S2V5LGEubWV0YUtleSxhLmtleUNvZGUsYS5jaGFyQ29kZSk7YnJlYWt9ZGVmYXVsdDp7bC5pbml0RXZlbnQodCxhLmJ1YmJsZXN8fCExLGEuY2FuY2VsYWJsZXx8ITApO2JyZWFrfX1VLmRlZmF1bHRzKGwscyksZS5kaXNwYXRjaEV2ZW50KGwpfSxiaW5kOmZ1bmN0aW9uKGUsdCxyLHMpe3ZhciBhPXN8fCExO3JldHVybiBlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKHQscixhKTplLmF0dGFjaEV2ZW50JiZlLmF0dGFjaEV2ZW50KFwib25cIit0LHIpLEV9LHVuYmluZDpmdW5jdGlvbihlLHQscixzKXt2YXIgYT1zfHwhMTtyZXR1cm4gZS5yZW1vdmVFdmVudExpc3RlbmVyP2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LHIsYSk6ZS5kZXRhY2hFdmVudCYmZS5kZXRhY2hFdmVudChcIm9uXCIrdCxyKSxFfSxhZGRDbGFzczpmdW5jdGlvbihlLHQpe2lmKGUuY2xhc3NOYW1lPT09dm9pZCAwKWUuY2xhc3NOYW1lPXQ7ZWxzZSBpZihlLmNsYXNzTmFtZSE9PXQpe3ZhciByPWUuY2xhc3NOYW1lLnNwbGl0KC8gKy8pO3IuaW5kZXhPZih0KT09PS0xJiYoci5wdXNoKHQpLGUuY2xhc3NOYW1lPXIuam9pbihcIiBcIikucmVwbGFjZSgvXlxccysvLFwiXCIpLnJlcGxhY2UoL1xccyskLyxcIlwiKSl9cmV0dXJuIEV9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGUsdCl7aWYodClpZihlLmNsYXNzTmFtZT09PXQpZS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtlbHNle3ZhciByPWUuY2xhc3NOYW1lLnNwbGl0KC8gKy8pLHM9ci5pbmRleE9mKHQpO3MhPT0tMSYmKHIuc3BsaWNlKHMsMSksZS5jbGFzc05hbWU9ci5qb2luKFwiIFwiKSl9ZWxzZSBlLmNsYXNzTmFtZT12b2lkIDA7cmV0dXJuIEV9LGhhc0NsYXNzOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKylcIit0K1wiKD86XFxcXHMrfCQpXCIpLnRlc3QoZS5jbGFzc05hbWUpfHwhMX0sZ2V0V2lkdGg6ZnVuY3Rpb24oZSl7dmFyIHQ9Z2V0Q29tcHV0ZWRTdHlsZShlKTtyZXR1cm4gWXQodFtcImJvcmRlci1sZWZ0LXdpZHRoXCJdKStZdCh0W1wiYm9yZGVyLXJpZ2h0LXdpZHRoXCJdKStZdCh0W1wicGFkZGluZy1sZWZ0XCJdKStZdCh0W1wicGFkZGluZy1yaWdodFwiXSkrWXQodC53aWR0aCl9LGdldEhlaWdodDpmdW5jdGlvbihlKXt2YXIgdD1nZXRDb21wdXRlZFN0eWxlKGUpO3JldHVybiBZdCh0W1wiYm9yZGVyLXRvcC13aWR0aFwiXSkrWXQodFtcImJvcmRlci1ib3R0b20td2lkdGhcIl0pK1l0KHRbXCJwYWRkaW5nLXRvcFwiXSkrWXQodFtcInBhZGRpbmctYm90dG9tXCJdKStZdCh0LmhlaWdodCl9LGdldE9mZnNldDpmdW5jdGlvbihlKXt2YXIgdD1lLHI9e2xlZnQ6MCx0b3A6MH07aWYodC5vZmZzZXRQYXJlbnQpZG8gci5sZWZ0Kz10Lm9mZnNldExlZnQsci50b3ArPXQub2Zmc2V0VG9wLHQ9dC5vZmZzZXRQYXJlbnQ7d2hpbGUodCk7cmV0dXJuIHJ9LGlzQWN0aXZlOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCYmKGUudHlwZXx8ZS5ocmVmKX19LG5oPWZ1bmN0aW9uKGkpe3BpKGUsaSk7ZnVuY3Rpb24gZSh0LHIpe1J0KHRoaXMsZSk7dmFyIHM9bWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQscikpLGE9cztzLl9fcHJldj1zLmdldFZhbHVlKCkscy5fX2NoZWNrYm94PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiY2hlY2tib3hcIik7ZnVuY3Rpb24gbigpe2Euc2V0VmFsdWUoIWEuX19wcmV2KX1yZXR1cm4gRS5iaW5kKHMuX19jaGVja2JveCxcImNoYW5nZVwiLG4sITEpLHMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChzLl9fY2hlY2tib3gpLHMudXBkYXRlRGlzcGxheSgpLHN9cmV0dXJuIEx0KGUsW3trZXk6XCJzZXRWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKHIpe3ZhciBzPWdpKGUucHJvdG90eXBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcInNldFZhbHVlXCIsdGhpcykuY2FsbCh0aGlzLHIpO3JldHVybiB0aGlzLl9fb25GaW5pc2hDaGFuZ2UmJnRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsdGhpcy5nZXRWYWx1ZSgpKSx0aGlzLl9fcHJldj10aGlzLmdldFZhbHVlKCksc319LHtrZXk6XCJ1cGRhdGVEaXNwbGF5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRWYWx1ZSgpPT09ITA/KHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsXCJjaGVja2VkXCIpLHRoaXMuX19jaGVja2JveC5jaGVja2VkPSEwLHRoaXMuX19wcmV2PSEwKToodGhpcy5fX2NoZWNrYm94LmNoZWNrZWQ9ITEsdGhpcy5fX3ByZXY9ITEpLGdpKGUucHJvdG90eXBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcInVwZGF0ZURpc3BsYXlcIix0aGlzKS5jYWxsKHRoaXMpfX1dKSxlfShNaSksJGQ9ZnVuY3Rpb24oaSl7cGkoZSxpKTtmdW5jdGlvbiBlKHQscixzKXtSdCh0aGlzLGUpO3ZhciBhPW1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0LHIpKSxuPXMsbD1hO2lmKGEuX19zZWxlY3Q9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKSxVLmlzQXJyYXkobikpe3ZhciBoPXt9O1UuZWFjaChuLGZ1bmN0aW9uKHUpe2hbdV09dX0pLG49aH1yZXR1cm4gVS5lYWNoKG4sZnVuY3Rpb24odSxjKXt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO2YuaW5uZXJIVE1MPWMsZi5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLHUpLGwuX19zZWxlY3QuYXBwZW5kQ2hpbGQoZil9KSxhLnVwZGF0ZURpc3BsYXkoKSxFLmJpbmQoYS5fX3NlbGVjdCxcImNoYW5nZVwiLGZ1bmN0aW9uKCl7dmFyIHU9dGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWU7bC5zZXRWYWx1ZSh1KX0pLGEuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChhLl9fc2VsZWN0KSxhfXJldHVybiBMdChlLFt7a2V5Olwic2V0VmFsdWVcIix2YWx1ZTpmdW5jdGlvbihyKXt2YXIgcz1naShlLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJzZXRWYWx1ZVwiLHRoaXMpLmNhbGwodGhpcyxyKTtyZXR1cm4gdGhpcy5fX29uRmluaXNoQ2hhbmdlJiZ0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLHRoaXMuZ2V0VmFsdWUoKSksc319LHtrZXk6XCJ1cGRhdGVEaXNwbGF5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gRS5pc0FjdGl2ZSh0aGlzLl9fc2VsZWN0KT90aGlzOih0aGlzLl9fc2VsZWN0LnZhbHVlPXRoaXMuZ2V0VmFsdWUoKSxnaShlLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJ1cGRhdGVEaXNwbGF5XCIsdGhpcykuY2FsbCh0aGlzKSl9fV0pLGV9KE1pKSxlZz1mdW5jdGlvbihpKXtwaShlLGkpO2Z1bmN0aW9uIGUodCxyKXtSdCh0aGlzLGUpO3ZhciBzPW1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0LHIpKSxhPXM7ZnVuY3Rpb24gbigpe2Euc2V0VmFsdWUoYS5fX2lucHV0LnZhbHVlKX1mdW5jdGlvbiBsKCl7YS5fX29uRmluaXNoQ2hhbmdlJiZhLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChhLGEuZ2V0VmFsdWUoKSl9cmV0dXJuIHMuX19pbnB1dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikscy5fX2lucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIixcInRleHRcIiksRS5iaW5kKHMuX19pbnB1dCxcImtleXVwXCIsbiksRS5iaW5kKHMuX19pbnB1dCxcImNoYW5nZVwiLG4pLEUuYmluZChzLl9faW5wdXQsXCJibHVyXCIsbCksRS5iaW5kKHMuX19pbnB1dCxcImtleWRvd25cIixmdW5jdGlvbihoKXtoLmtleUNvZGU9PT0xMyYmdGhpcy5ibHVyKCl9KSxzLnVwZGF0ZURpc3BsYXkoKSxzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQocy5fX2lucHV0KSxzfXJldHVybiBMdChlLFt7a2V5OlwidXBkYXRlRGlzcGxheVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIEUuaXNBY3RpdmUodGhpcy5fX2lucHV0KXx8KHRoaXMuX19pbnB1dC52YWx1ZT10aGlzLmdldFZhbHVlKCkpLGdpKGUucHJvdG90eXBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUucHJvdG90eXBlKSxcInVwZGF0ZURpc3BsYXlcIix0aGlzKS5jYWxsKHRoaXMpfX1dKSxlfShNaSk7ZnVuY3Rpb24gbGgoaSl7dmFyIGU9aS50b1N0cmluZygpO3JldHVybiBlLmluZGV4T2YoXCIuXCIpPi0xP2UubGVuZ3RoLWUuaW5kZXhPZihcIi5cIiktMTowfXZhciBoaD1mdW5jdGlvbihpKXtwaShlLGkpO2Z1bmN0aW9uIGUodCxyLHMpe1J0KHRoaXMsZSk7dmFyIGE9bWkodGhpcywoZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuY2FsbCh0aGlzLHQscikpLG49c3x8e307cmV0dXJuIGEuX19taW49bi5taW4sYS5fX21heD1uLm1heCxhLl9fc3RlcD1uLnN0ZXAsVS5pc1VuZGVmaW5lZChhLl9fc3RlcCk/YS5pbml0aWFsVmFsdWU9PT0wP2EuX19pbXBsaWVkU3RlcD0xOmEuX19pbXBsaWVkU3RlcD1NYXRoLnBvdygxMCxNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKGEuaW5pdGlhbFZhbHVlKSkvTWF0aC5MTjEwKSkvMTA6YS5fX2ltcGxpZWRTdGVwPWEuX19zdGVwLGEuX19wcmVjaXNpb249bGgoYS5fX2ltcGxpZWRTdGVwKSxhfXJldHVybiBMdChlLFt7a2V5Olwic2V0VmFsdWVcIix2YWx1ZTpmdW5jdGlvbihyKXt2YXIgcz1yO3JldHVybiB0aGlzLl9fbWluIT09dm9pZCAwJiZzPHRoaXMuX19taW4/cz10aGlzLl9fbWluOnRoaXMuX19tYXghPT12b2lkIDAmJnM+dGhpcy5fX21heCYmKHM9dGhpcy5fX21heCksdGhpcy5fX3N0ZXAhPT12b2lkIDAmJnMldGhpcy5fX3N0ZXAhPT0wJiYocz1NYXRoLnJvdW5kKHMvdGhpcy5fX3N0ZXApKnRoaXMuX19zdGVwKSxnaShlLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJzZXRWYWx1ZVwiLHRoaXMpLmNhbGwodGhpcyxzKX19LHtrZXk6XCJtaW5cIix2YWx1ZTpmdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5fX21pbj1yLHRoaXN9fSx7a2V5OlwibWF4XCIsdmFsdWU6ZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuX19tYXg9cix0aGlzfX0se2tleTpcInN0ZXBcIix2YWx1ZTpmdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5fX3N0ZXA9cix0aGlzLl9faW1wbGllZFN0ZXA9cix0aGlzLl9fcHJlY2lzaW9uPWxoKHIpLHRoaXN9fV0pLGV9KE1pKTtmdW5jdGlvbiB0ZyhpLGUpe3ZhciB0PU1hdGgucG93KDEwLGUpO3JldHVybiBNYXRoLnJvdW5kKGkqdCkvdH12YXIgUXM9ZnVuY3Rpb24oaSl7cGkoZSxpKTtmdW5jdGlvbiBlKHQscixzKXtSdCh0aGlzLGUpO3ZhciBhPW1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0LHIscykpO2EuX190cnVuY2F0aW9uU3VzcGVuZGVkPSExO3ZhciBuPWEsbD12b2lkIDA7ZnVuY3Rpb24gaCgpe3ZhciBtPXBhcnNlRmxvYXQobi5fX2lucHV0LnZhbHVlKTtVLmlzTmFOKG0pfHxuLnNldFZhbHVlKG0pfWZ1bmN0aW9uIHUoKXtuLl9fb25GaW5pc2hDaGFuZ2UmJm4uX19vbkZpbmlzaENoYW5nZS5jYWxsKG4sbi5nZXRWYWx1ZSgpKX1mdW5jdGlvbiBjKCl7dSgpfWZ1bmN0aW9uIGYobSl7dmFyIF89bC1tLmNsaWVudFk7bi5zZXRWYWx1ZShuLmdldFZhbHVlKCkrXypuLl9faW1wbGllZFN0ZXApLGw9bS5jbGllbnRZfWZ1bmN0aW9uIGQoKXtFLnVuYmluZCh3aW5kb3csXCJtb3VzZW1vdmVcIixmKSxFLnVuYmluZCh3aW5kb3csXCJtb3VzZXVwXCIsZCksdSgpfWZ1bmN0aW9uIHAobSl7RS5iaW5kKHdpbmRvdyxcIm1vdXNlbW92ZVwiLGYpLEUuYmluZCh3aW5kb3csXCJtb3VzZXVwXCIsZCksbD1tLmNsaWVudFl9cmV0dXJuIGEuX19pbnB1dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS5fX2lucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIixcInRleHRcIiksRS5iaW5kKGEuX19pbnB1dCxcImNoYW5nZVwiLGgpLEUuYmluZChhLl9faW5wdXQsXCJibHVyXCIsYyksRS5iaW5kKGEuX19pbnB1dCxcIm1vdXNlZG93blwiLHApLEUuYmluZChhLl9faW5wdXQsXCJrZXlkb3duXCIsZnVuY3Rpb24obSl7bS5rZXlDb2RlPT09MTMmJihuLl9fdHJ1bmNhdGlvblN1c3BlbmRlZD0hMCx0aGlzLmJsdXIoKSxuLl9fdHJ1bmNhdGlvblN1c3BlbmRlZD0hMSx1KCkpfSksYS51cGRhdGVEaXNwbGF5KCksYS5kb21FbGVtZW50LmFwcGVuZENoaWxkKGEuX19pbnB1dCksYX1yZXR1cm4gTHQoZSxbe2tleTpcInVwZGF0ZURpc3BsYXlcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9faW5wdXQudmFsdWU9dGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQ/dGhpcy5nZXRWYWx1ZSgpOnRnKHRoaXMuZ2V0VmFsdWUoKSx0aGlzLl9fcHJlY2lzaW9uKSxnaShlLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJ1cGRhdGVEaXNwbGF5XCIsdGhpcykuY2FsbCh0aGlzKX19XSksZX0oaGgpO2Z1bmN0aW9uIHVoKGksZSx0LHIscyl7cmV0dXJuIHIrKHMtcikqKChpLWUpLyh0LWUpKX12YXIgcG89ZnVuY3Rpb24oaSl7cGkoZSxpKTtmdW5jdGlvbiBlKHQscixzLGEsbil7UnQodGhpcyxlKTt2YXIgbD1taSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCxyLHttaW46cyxtYXg6YSxzdGVwOm59KSksaD1sO2wuX19iYWNrZ3JvdW5kPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbC5fX2ZvcmVncm91bmQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxFLmJpbmQobC5fX2JhY2tncm91bmQsXCJtb3VzZWRvd25cIix1KSxFLmJpbmQobC5fX2JhY2tncm91bmQsXCJ0b3VjaHN0YXJ0XCIsZCksRS5hZGRDbGFzcyhsLl9fYmFja2dyb3VuZCxcInNsaWRlclwiKSxFLmFkZENsYXNzKGwuX19mb3JlZ3JvdW5kLFwic2xpZGVyLWZnXCIpO2Z1bmN0aW9uIHUoXyl7ZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCksRS5iaW5kKHdpbmRvdyxcIm1vdXNlbW92ZVwiLGMpLEUuYmluZCh3aW5kb3csXCJtb3VzZXVwXCIsZiksYyhfKX1mdW5jdGlvbiBjKF8pe18ucHJldmVudERlZmF1bHQoKTt2YXIgdj1oLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gaC5zZXRWYWx1ZSh1aChfLmNsaWVudFgsdi5sZWZ0LHYucmlnaHQsaC5fX21pbixoLl9fbWF4KSksITF9ZnVuY3Rpb24gZigpe0UudW5iaW5kKHdpbmRvdyxcIm1vdXNlbW92ZVwiLGMpLEUudW5iaW5kKHdpbmRvdyxcIm1vdXNldXBcIixmKSxoLl9fb25GaW5pc2hDaGFuZ2UmJmguX19vbkZpbmlzaENoYW5nZS5jYWxsKGgsaC5nZXRWYWx1ZSgpKX1mdW5jdGlvbiBkKF8pe18udG91Y2hlcy5sZW5ndGg9PT0xJiYoRS5iaW5kKHdpbmRvdyxcInRvdWNobW92ZVwiLHApLEUuYmluZCh3aW5kb3csXCJ0b3VjaGVuZFwiLG0pLHAoXykpfWZ1bmN0aW9uIHAoXyl7dmFyIHY9Xy50b3VjaGVzWzBdLmNsaWVudFgseT1oLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtoLnNldFZhbHVlKHVoKHYseS5sZWZ0LHkucmlnaHQsaC5fX21pbixoLl9fbWF4KSl9ZnVuY3Rpb24gbSgpe0UudW5iaW5kKHdpbmRvdyxcInRvdWNobW92ZVwiLHApLEUudW5iaW5kKHdpbmRvdyxcInRvdWNoZW5kXCIsbSksaC5fX29uRmluaXNoQ2hhbmdlJiZoLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChoLGguZ2V0VmFsdWUoKSl9cmV0dXJuIGwudXBkYXRlRGlzcGxheSgpLGwuX19iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGwuX19mb3JlZ3JvdW5kKSxsLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQobC5fX2JhY2tncm91bmQpLGx9cmV0dXJuIEx0KGUsW3trZXk6XCJ1cGRhdGVEaXNwbGF5XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgcj0odGhpcy5nZXRWYWx1ZSgpLXRoaXMuX19taW4pLyh0aGlzLl9fbWF4LXRoaXMuX19taW4pO3JldHVybiB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aD1yKjEwMCtcIiVcIixnaShlLnByb3RvdHlwZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlLnByb3RvdHlwZSksXCJ1cGRhdGVEaXNwbGF5XCIsdGhpcykuY2FsbCh0aGlzKX19XSksZX0oaGgpLGNoPWZ1bmN0aW9uKGkpe3BpKGUsaSk7ZnVuY3Rpb24gZSh0LHIscyl7UnQodGhpcyxlKTt2YXIgYT1taSh0aGlzLChlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpKS5jYWxsKHRoaXMsdCxyKSksbj1hO3JldHVybiBhLl9fYnV0dG9uPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYS5fX2J1dHRvbi5pbm5lckhUTUw9cz09PXZvaWQgMD9cIkZpcmVcIjpzLEUuYmluZChhLl9fYnV0dG9uLFwiY2xpY2tcIixmdW5jdGlvbihsKXtyZXR1cm4gbC5wcmV2ZW50RGVmYXVsdCgpLG4uZmlyZSgpLCExfSksRS5hZGRDbGFzcyhhLl9fYnV0dG9uLFwiYnV0dG9uXCIpLGEuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChhLl9fYnV0dG9uKSxhfXJldHVybiBMdChlLFt7a2V5OlwiZmlyZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fX29uQ2hhbmdlJiZ0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzKSx0aGlzLmdldFZhbHVlKCkuY2FsbCh0aGlzLm9iamVjdCksdGhpcy5fX29uRmluaXNoQ2hhbmdlJiZ0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLHRoaXMuZ2V0VmFsdWUoKSl9fV0pLGV9KE1pKSxtbz1mdW5jdGlvbihpKXtwaShlLGkpO2Z1bmN0aW9uIGUodCxyKXtSdCh0aGlzLGUpO3ZhciBzPW1pKHRoaXMsKGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpLmNhbGwodGhpcyx0LHIpKTtzLl9fY29sb3I9bmV3IFllKHMuZ2V0VmFsdWUoKSkscy5fX3RlbXA9bmV3IFllKDApO3ZhciBhPXM7cy5kb21FbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksRS5tYWtlU2VsZWN0YWJsZShzLmRvbUVsZW1lbnQsITEpLHMuX19zZWxlY3Rvcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHMuX19zZWxlY3Rvci5jbGFzc05hbWU9XCJzZWxlY3RvclwiLHMuX19zYXR1cmF0aW9uX2ZpZWxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikscy5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lPVwic2F0dXJhdGlvbi1maWVsZFwiLHMuX19maWVsZF9rbm9iPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikscy5fX2ZpZWxkX2tub2IuY2xhc3NOYW1lPVwiZmllbGQta25vYlwiLHMuX19maWVsZF9rbm9iX2JvcmRlcj1cIjJweCBzb2xpZCBcIixzLl9faHVlX2tub2I9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxzLl9faHVlX2tub2IuY2xhc3NOYW1lPVwiaHVlLWtub2JcIixzLl9faHVlX2ZpZWxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikscy5fX2h1ZV9maWVsZC5jbGFzc05hbWU9XCJodWUtZmllbGRcIixzLl9faW5wdXQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLHMuX19pbnB1dC50eXBlPVwidGV4dFwiLHMuX19pbnB1dF90ZXh0U2hhZG93PVwiMCAxcHggMXB4IFwiLEUuYmluZChzLl9faW5wdXQsXCJrZXlkb3duXCIsZnVuY3Rpb24oXyl7Xy5rZXlDb2RlPT09MTMmJmYuY2FsbCh0aGlzKX0pLEUuYmluZChzLl9faW5wdXQsXCJibHVyXCIsZiksRS5iaW5kKHMuX19zZWxlY3RvcixcIm1vdXNlZG93blwiLGZ1bmN0aW9uKCl7RS5hZGRDbGFzcyh0aGlzLFwiZHJhZ1wiKS5iaW5kKHdpbmRvdyxcIm1vdXNldXBcIixmdW5jdGlvbigpe0UucmVtb3ZlQ2xhc3MoYS5fX3NlbGVjdG9yLFwiZHJhZ1wiKX0pfSksRS5iaW5kKHMuX19zZWxlY3RvcixcInRvdWNoc3RhcnRcIixmdW5jdGlvbigpe0UuYWRkQ2xhc3ModGhpcyxcImRyYWdcIikuYmluZCh3aW5kb3csXCJ0b3VjaGVuZFwiLGZ1bmN0aW9uKCl7RS5yZW1vdmVDbGFzcyhhLl9fc2VsZWN0b3IsXCJkcmFnXCIpfSl9KTt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1UuZXh0ZW5kKHMuX19zZWxlY3Rvci5zdHlsZSx7d2lkdGg6XCIxMjJweFwiLGhlaWdodDpcIjEwMnB4XCIscGFkZGluZzpcIjNweFwiLGJhY2tncm91bmRDb2xvcjpcIiMyMjJcIixib3hTaGFkb3c6XCIwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuMylcIn0pLFUuZXh0ZW5kKHMuX19maWVsZF9rbm9iLnN0eWxlLHtwb3NpdGlvbjpcImFic29sdXRlXCIsd2lkdGg6XCIxMnB4XCIsaGVpZ2h0OlwiMTJweFwiLGJvcmRlcjpzLl9fZmllbGRfa25vYl9ib3JkZXIrKHMuX19jb2xvci52PC41P1wiI2ZmZlwiOlwiIzAwMFwiKSxib3hTaGFkb3c6XCIwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuNSlcIixib3JkZXJSYWRpdXM6XCIxMnB4XCIsekluZGV4OjF9KSxVLmV4dGVuZChzLl9faHVlX2tub2Iuc3R5bGUse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix3aWR0aDpcIjE1cHhcIixoZWlnaHQ6XCIycHhcIixib3JkZXJSaWdodDpcIjRweCBzb2xpZCAjZmZmXCIsekluZGV4OjF9KSxVLmV4dGVuZChzLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSx7d2lkdGg6XCIxMDBweFwiLGhlaWdodDpcIjEwMHB4XCIsYm9yZGVyOlwiMXB4IHNvbGlkICM1NTVcIixtYXJnaW5SaWdodDpcIjNweFwiLGRpc3BsYXk6XCJpbmxpbmUtYmxvY2tcIixjdXJzb3I6XCJwb2ludGVyXCJ9KSxVLmV4dGVuZChuLnN0eWxlLHt3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCIsYmFja2dyb3VuZDpcIm5vbmVcIn0pLGZoKG4sXCJ0b3BcIixcInJnYmEoMCwwLDAsMClcIixcIiMwMDBcIiksVS5leHRlbmQocy5fX2h1ZV9maWVsZC5zdHlsZSx7d2lkdGg6XCIxNXB4XCIsaGVpZ2h0OlwiMTAwcHhcIixib3JkZXI6XCIxcHggc29saWQgIzU1NVwiLGN1cnNvcjpcIm5zLXJlc2l6ZVwiLHBvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCIzcHhcIixyaWdodDpcIjNweFwifSkscmcocy5fX2h1ZV9maWVsZCksVS5leHRlbmQocy5fX2lucHV0LnN0eWxlLHtvdXRsaW5lOlwibm9uZVwiLHRleHRBbGlnbjpcImNlbnRlclwiLGNvbG9yOlwiI2ZmZlwiLGJvcmRlcjowLGZvbnRXZWlnaHQ6XCJib2xkXCIsdGV4dFNoYWRvdzpzLl9faW5wdXRfdGV4dFNoYWRvdytcInJnYmEoMCwwLDAsMC43KVwifSksRS5iaW5kKHMuX19zYXR1cmF0aW9uX2ZpZWxkLFwibW91c2Vkb3duXCIsbCksRS5iaW5kKHMuX19zYXR1cmF0aW9uX2ZpZWxkLFwidG91Y2hzdGFydFwiLGwpLEUuYmluZChzLl9fZmllbGRfa25vYixcIm1vdXNlZG93blwiLGwpLEUuYmluZChzLl9fZmllbGRfa25vYixcInRvdWNoc3RhcnRcIixsKSxFLmJpbmQocy5fX2h1ZV9maWVsZCxcIm1vdXNlZG93blwiLGgpLEUuYmluZChzLl9faHVlX2ZpZWxkLFwidG91Y2hzdGFydFwiLGgpO2Z1bmN0aW9uIGwoXyl7cChfKSxFLmJpbmQod2luZG93LFwibW91c2Vtb3ZlXCIscCksRS5iaW5kKHdpbmRvdyxcInRvdWNobW92ZVwiLHApLEUuYmluZCh3aW5kb3csXCJtb3VzZXVwXCIsdSksRS5iaW5kKHdpbmRvdyxcInRvdWNoZW5kXCIsdSl9ZnVuY3Rpb24gaChfKXttKF8pLEUuYmluZCh3aW5kb3csXCJtb3VzZW1vdmVcIixtKSxFLmJpbmQod2luZG93LFwidG91Y2htb3ZlXCIsbSksRS5iaW5kKHdpbmRvdyxcIm1vdXNldXBcIixjKSxFLmJpbmQod2luZG93LFwidG91Y2hlbmRcIixjKX1mdW5jdGlvbiB1KCl7RS51bmJpbmQod2luZG93LFwibW91c2Vtb3ZlXCIscCksRS51bmJpbmQod2luZG93LFwidG91Y2htb3ZlXCIscCksRS51bmJpbmQod2luZG93LFwibW91c2V1cFwiLHUpLEUudW5iaW5kKHdpbmRvdyxcInRvdWNoZW5kXCIsdSksZCgpfWZ1bmN0aW9uIGMoKXtFLnVuYmluZCh3aW5kb3csXCJtb3VzZW1vdmVcIixtKSxFLnVuYmluZCh3aW5kb3csXCJ0b3VjaG1vdmVcIixtKSxFLnVuYmluZCh3aW5kb3csXCJtb3VzZXVwXCIsYyksRS51bmJpbmQod2luZG93LFwidG91Y2hlbmRcIixjKSxkKCl9ZnVuY3Rpb24gZigpe3ZhciBfPWNvKHRoaXMudmFsdWUpO18hPT0hMT8oYS5fX2NvbG9yLl9fc3RhdGU9XyxhLnNldFZhbHVlKGEuX19jb2xvci50b09yaWdpbmFsKCkpKTp0aGlzLnZhbHVlPWEuX19jb2xvci50b1N0cmluZygpfWZ1bmN0aW9uIGQoKXthLl9fb25GaW5pc2hDaGFuZ2UmJmEuX19vbkZpbmlzaENoYW5nZS5jYWxsKGEsYS5fX2NvbG9yLnRvT3JpZ2luYWwoKSl9cy5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQobikscy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHMuX19maWVsZF9rbm9iKSxzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQocy5fX3NhdHVyYXRpb25fZmllbGQpLHMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChzLl9faHVlX2ZpZWxkKSxzLl9faHVlX2ZpZWxkLmFwcGVuZENoaWxkKHMuX19odWVfa25vYikscy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHMuX19pbnB1dCkscy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHMuX19zZWxlY3Rvcikscy51cGRhdGVEaXNwbGF5KCk7ZnVuY3Rpb24gcChfKXtfLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpPT09LTEmJl8ucHJldmVudERlZmF1bHQoKTt2YXIgdj1hLl9fc2F0dXJhdGlvbl9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx5PV8udG91Y2hlcyYmXy50b3VjaGVzWzBdfHxfLEM9eS5jbGllbnRYLEI9eS5jbGllbnRZLFQ9KEMtdi5sZWZ0KS8odi5yaWdodC12LmxlZnQpLE09MS0oQi12LnRvcCkvKHYuYm90dG9tLXYudG9wKTtyZXR1cm4gTT4xP009MTpNPDAmJihNPTApLFQ+MT9UPTE6VDwwJiYoVD0wKSxhLl9fY29sb3Iudj1NLGEuX19jb2xvci5zPVQsYS5zZXRWYWx1ZShhLl9fY29sb3IudG9PcmlnaW5hbCgpKSwhMX1mdW5jdGlvbiBtKF8pe18udHlwZS5pbmRleE9mKFwidG91Y2hcIik9PT0tMSYmXy5wcmV2ZW50RGVmYXVsdCgpO3ZhciB2PWEuX19odWVfZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkseT1fLnRvdWNoZXMmJl8udG91Y2hlc1swXXx8XyxDPXkuY2xpZW50WSxCPTEtKEMtdi50b3ApLyh2LmJvdHRvbS12LnRvcCk7cmV0dXJuIEI+MT9CPTE6QjwwJiYoQj0wKSxhLl9fY29sb3IuaD1CKjM2MCxhLnNldFZhbHVlKGEuX19jb2xvci50b09yaWdpbmFsKCkpLCExfXJldHVybiBzfXJldHVybiBMdChlLFt7a2V5OlwidXBkYXRlRGlzcGxheVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHI9Y28odGhpcy5nZXRWYWx1ZSgpKTtpZihyIT09ITEpe3ZhciBzPSExO1UuZWFjaChZZS5DT01QT05FTlRTLGZ1bmN0aW9uKGwpe2lmKCFVLmlzVW5kZWZpbmVkKHJbbF0pJiYhVS5pc1VuZGVmaW5lZCh0aGlzLl9fY29sb3IuX19zdGF0ZVtsXSkmJnJbbF0hPT10aGlzLl9fY29sb3IuX19zdGF0ZVtsXSlyZXR1cm4gcz0hMCx7fX0sdGhpcykscyYmVS5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUscil9VS5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSx0aGlzLl9fY29sb3IuX19zdGF0ZSksdGhpcy5fX3RlbXAuYT0xO3ZhciBhPXRoaXMuX19jb2xvci52PC41fHx0aGlzLl9fY29sb3Iucz4uNT8yNTU6MCxuPTI1NS1hO1UuZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLHttYXJnaW5MZWZ0OjEwMCp0aGlzLl9fY29sb3Iucy03K1wicHhcIixtYXJnaW5Ub3A6MTAwKigxLXRoaXMuX19jb2xvci52KS03K1wicHhcIixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxib3JkZXI6dGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyK1wicmdiKFwiK2ErXCIsXCIrYStcIixcIithK1wiKVwifSksdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcD0oMS10aGlzLl9fY29sb3IuaC8zNjApKjEwMCtcInB4XCIsdGhpcy5fX3RlbXAucz0xLHRoaXMuX190ZW1wLnY9MSxmaCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCxcImxlZnRcIixcIiNmZmZcIix0aGlzLl9fdGVtcC50b0hleFN0cmluZygpKSx0aGlzLl9faW5wdXQudmFsdWU9dGhpcy5fX2NvbG9yLnRvU3RyaW5nKCksVS5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLHtiYWNrZ3JvdW5kQ29sb3I6dGhpcy5fX2NvbG9yLnRvSGV4U3RyaW5nKCksY29sb3I6XCJyZ2IoXCIrYStcIixcIithK1wiLFwiK2ErXCIpXCIsdGV4dFNoYWRvdzp0aGlzLl9faW5wdXRfdGV4dFNoYWRvdytcInJnYmEoXCIrbitcIixcIituK1wiLFwiK24rXCIsLjcpXCJ9KX19XSksZX0oTWkpLGlnPVtcIi1tb3otXCIsXCItby1cIixcIi13ZWJraXQtXCIsXCItbXMtXCIsXCJcIl07ZnVuY3Rpb24gZmgoaSxlLHQscil7aS5zdHlsZS5iYWNrZ3JvdW5kPVwiXCIsVS5lYWNoKGlnLGZ1bmN0aW9uKHMpe2kuc3R5bGUuY3NzVGV4dCs9XCJiYWNrZ3JvdW5kOiBcIitzK1wibGluZWFyLWdyYWRpZW50KFwiK2UrXCIsIFwiK3QrXCIgMCUsIFwiK3IrXCIgMTAwJSk7IFwifSl9ZnVuY3Rpb24gcmcoaSl7aS5zdHlsZS5iYWNrZ3JvdW5kPVwiXCIsaS5zdHlsZS5jc3NUZXh0Kz1cImJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTtcIixpLnN0eWxlLmNzc1RleHQrPVwiYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpO1wiLGkuc3R5bGUuY3NzVGV4dCs9XCJiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpO1wiLGkuc3R5bGUuY3NzVGV4dCs9XCJiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTtcIixpLnN0eWxlLmNzc1RleHQrPVwiYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTtcIn12YXIgc2c9e2xvYWQ6ZnVuY3Rpb24oZSx0KXt2YXIgcj10fHxkb2N1bWVudCxzPXIuY3JlYXRlRWxlbWVudChcImxpbmtcIik7cy50eXBlPVwidGV4dC9jc3NcIixzLnJlbD1cInN0eWxlc2hlZXRcIixzLmhyZWY9ZSxyLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzKX0saW5qZWN0OmZ1bmN0aW9uKGUsdCl7dmFyIHI9dHx8ZG9jdW1lbnQscz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7cy50eXBlPVwidGV4dC9jc3NcIixzLmlubmVySFRNTD1lO3ZhciBhPXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO3RyeXthLmFwcGVuZENoaWxkKHMpfWNhdGNoe319fSxhZz1gPGRpdiBpZD1cImRnLXNhdmVcIiBjbGFzcz1cImRnIGRpYWxvZ3VlXCI+XG5cbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxuXG4gIDx0ZXh0YXJlYSBpZD1cImRnLW5ldy1jb25zdHJ1Y3RvclwiPjwvdGV4dGFyZWE+XG5cbiAgPGRpdiBpZD1cImRnLXNhdmUtbG9jYWxseVwiPlxuXG4gICAgPGlucHV0IGlkPVwiZGctbG9jYWwtc3RvcmFnZVwiIHR5cGU9XCJjaGVja2JveFwiLz4gQXV0b21hdGljYWxseSBzYXZlXG4gICAgdmFsdWVzIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gb24gZXhpdC5cblxuICAgIDxkaXYgaWQ9XCJkZy1sb2NhbC1leHBsYWluXCI+VGhlIHZhbHVlcyBzYXZlZCB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IHdpbGxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XG4gICAgICBlYXNpZXIgdG8gd29yayBpbmNyZW1lbnRhbGx5LCBidXQgPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpcyBmcmFnaWxlLFxuICAgICAgYW5kIHlvdXIgZnJpZW5kcyBtYXkgbm90IHNlZSB0aGUgc2FtZSB2YWx1ZXMgeW91IGRvLlxuXG4gICAgPC9kaXY+XG5cbiAgPC9kaXY+XG5cbjwvZGl2PmAsb2c9ZnVuY3Rpb24oZSx0KXt2YXIgcj1lW3RdO3JldHVybiBVLmlzQXJyYXkoYXJndW1lbnRzWzJdKXx8VS5pc09iamVjdChhcmd1bWVudHNbMl0pP25ldyAkZChlLHQsYXJndW1lbnRzWzJdKTpVLmlzTnVtYmVyKHIpP1UuaXNOdW1iZXIoYXJndW1lbnRzWzJdKSYmVS5pc051bWJlcihhcmd1bWVudHNbM10pP1UuaXNOdW1iZXIoYXJndW1lbnRzWzRdKT9uZXcgcG8oZSx0LGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdKTpuZXcgcG8oZSx0LGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10pOlUuaXNOdW1iZXIoYXJndW1lbnRzWzRdKT9uZXcgUXMoZSx0LHttaW46YXJndW1lbnRzWzJdLG1heDphcmd1bWVudHNbM10sc3RlcDphcmd1bWVudHNbNF19KTpuZXcgUXMoZSx0LHttaW46YXJndW1lbnRzWzJdLG1heDphcmd1bWVudHNbM119KTpVLmlzU3RyaW5nKHIpP25ldyBlZyhlLHQpOlUuaXNGdW5jdGlvbihyKT9uZXcgY2goZSx0LFwiXCIpOlUuaXNCb29sZWFuKHIpP25ldyBuaChlLHQpOm51bGx9O2Z1bmN0aW9uIG5nKGkpe3NldFRpbWVvdXQoaSwxZTMvNjApfXZhciBsZz13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxuZyxoZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGkoKXtSdCh0aGlzLGkpLHRoaXMuYmFja2dyb3VuZEVsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxVLmV4dGVuZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLHtiYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDAsMCwwLDAuOClcIix0b3A6MCxsZWZ0OjAsZGlzcGxheTpcIm5vbmVcIix6SW5kZXg6XCIxMDAwXCIsb3BhY2l0eTowLFdlYmtpdFRyYW5zaXRpb246XCJvcGFjaXR5IDAuMnMgbGluZWFyXCIsdHJhbnNpdGlvbjpcIm9wYWNpdHkgMC4ycyBsaW5lYXJcIn0pLEUubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCksdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbj1cImZpeGVkXCIsdGhpcy5kb21FbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksVS5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLHtwb3NpdGlvbjpcImZpeGVkXCIsZGlzcGxheTpcIm5vbmVcIix6SW5kZXg6XCIxMDAxXCIsb3BhY2l0eTowLFdlYmtpdFRyYW5zaXRpb246XCItd2Via2l0LXRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyXCIsdHJhbnNpdGlvbjpcInRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyXCJ9KSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTt2YXIgZT10aGlzO0UuYmluZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LFwiY2xpY2tcIixmdW5jdGlvbigpe2UuaGlkZSgpfSl9cmV0dXJuIEx0KGksW3trZXk6XCJzaG93XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5PTAsdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybT1cInNjYWxlKDEuMSlcIix0aGlzLmxheW91dCgpLFUuZGVmZXIoZnVuY3Rpb24oKXt0LmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHk9MSx0LmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eT0xLHQuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm09XCJzY2FsZSgxKVwifSl9fSx7a2V5OlwiaGlkZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxyPWZ1bmN0aW9uIHMoKXt0LmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0LmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsRS51bmJpbmQodC5kb21FbGVtZW50LFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLHMpLEUudW5iaW5kKHQuZG9tRWxlbWVudCxcInRyYW5zaXRpb25lbmRcIixzKSxFLnVuYmluZCh0LmRvbUVsZW1lbnQsXCJvVHJhbnNpdGlvbkVuZFwiLHMpfTtFLmJpbmQodGhpcy5kb21FbGVtZW50LFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLHIpLEUuYmluZCh0aGlzLmRvbUVsZW1lbnQsXCJ0cmFuc2l0aW9uZW5kXCIsciksRS5iaW5kKHRoaXMuZG9tRWxlbWVudCxcIm9UcmFuc2l0aW9uRW5kXCIsciksdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5PTAsdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHk9MCx0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtPVwic2NhbGUoMS4xKVwifX0se2tleTpcImxheW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kb21FbGVtZW50LnN0eWxlLmxlZnQ9d2luZG93LmlubmVyV2lkdGgvMi1FLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkvMitcInB4XCIsdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcD13aW5kb3cuaW5uZXJIZWlnaHQvMi1FLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpLzIrXCJweFwifX1dKSxpfSgpLHVnPWpkKGAuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWV7d2lkdGg6MTAwJX0uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCU7cG9zaXRpb246cmVsYXRpdmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjdweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuY3IuY29sb3J7b3ZlcmZsb3c6dmlzaWJsZX0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmNvbG9ye2JvcmRlci1sZWZ0OjNweCBzb2xpZH0uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMkZBMUQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJGQTFENn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJGQTFENjttYXgtd2lkdGg6MTAwJX0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XG5gKTtzZy5pbmplY3QodWcpO3ZhciBkaD1cImRnXCIsZ2g9NzIscGg9MjAsWnI9XCJEZWZhdWx0XCIsJHI9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuISF3aW5kb3cubG9jYWxTdG9yYWdlfWNhdGNoe3JldHVybiExfX0oKSxlcz12b2lkIDAsbWg9ITAsc3I9dm9pZCAwLEFvPSExLEFoPVtdLHZlPWZ1bmN0aW9uIGkoZSl7dmFyIHQ9dGhpcyxyPWV8fHt9O3RoaXMuZG9tRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuX191bD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIiksdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCksRS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsZGgpLHRoaXMuX19mb2xkZXJzPXt9LHRoaXMuX19jb250cm9sbGVycz1bXSx0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHM9W10sdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVycz1bXSx0aGlzLl9fbGlzdGVuaW5nPVtdLHI9VS5kZWZhdWx0cyhyLHtjbG9zZU9uVG9wOiExLGF1dG9QbGFjZTohMCx3aWR0aDppLkRFRkFVTFRfV0lEVEh9KSxyPVUuZGVmYXVsdHMocix7cmVzaXphYmxlOnIuYXV0b1BsYWNlLGhpZGVhYmxlOnIuYXV0b1BsYWNlfSksVS5pc1VuZGVmaW5lZChyLmxvYWQpP3IubG9hZD17cHJlc2V0OlpyfTpyLnByZXNldCYmKHIubG9hZC5wcmVzZXQ9ci5wcmVzZXQpLFUuaXNVbmRlZmluZWQoci5wYXJlbnQpJiZyLmhpZGVhYmxlJiZBaC5wdXNoKHRoaXMpLHIucmVzaXphYmxlPVUuaXNVbmRlZmluZWQoci5wYXJlbnQpJiZyLnJlc2l6YWJsZSxyLmF1dG9QbGFjZSYmVS5pc1VuZGVmaW5lZChyLnNjcm9sbGFibGUpJiYoci5zY3JvbGxhYmxlPSEwKTt2YXIgcz0kciYmbG9jYWxTdG9yYWdlLmdldEl0ZW0oYXIodGhpcyxcImlzTG9jYWxcIikpPT09XCJ0cnVlXCIsYT12b2lkIDAsbj12b2lkIDA7aWYoT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyx7cGFyZW50OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5wYXJlbnR9fSxzY3JvbGxhYmxlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5zY3JvbGxhYmxlfX0sYXV0b1BsYWNlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5hdXRvUGxhY2V9fSxjbG9zZU9uVG9wOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5jbG9zZU9uVG9wfX0scHJlc2V0OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5wYXJlbnQ/dC5nZXRSb290KCkucHJlc2V0OnIubG9hZC5wcmVzZXR9LHNldDpmdW5jdGlvbihkKXt0LnBhcmVudD90LmdldFJvb3QoKS5wcmVzZXQ9ZDpyLmxvYWQucHJlc2V0PWQsZ2codGhpcyksdC5yZXZlcnQoKX19LHdpZHRoOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci53aWR0aH0sc2V0OmZ1bmN0aW9uKGQpe3Iud2lkdGg9ZCx5byh0LGQpfX0sbmFtZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHIubmFtZX0sc2V0OmZ1bmN0aW9uKGQpe3IubmFtZT1kLG4mJihuLmlubmVySFRNTD1yLm5hbWUpfX0sY2xvc2VkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5jbG9zZWR9LHNldDpmdW5jdGlvbihkKXtyLmNsb3NlZD1kLHIuY2xvc2VkP0UuYWRkQ2xhc3ModC5fX3VsLGkuQ0xBU1NfQ0xPU0VEKTpFLnJlbW92ZUNsYXNzKHQuX191bCxpLkNMQVNTX0NMT1NFRCksdGhpcy5vblJlc2l6ZSgpLHQuX19jbG9zZUJ1dHRvbiYmKHQuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUw9ZD9pLlRFWFRfT1BFTjppLlRFWFRfQ0xPU0VEKX19LGxvYWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiByLmxvYWR9fSx1c2VMb2NhbFN0b3JhZ2U6e2dldDpmdW5jdGlvbigpe3JldHVybiBzfSxzZXQ6ZnVuY3Rpb24oZCl7JHImJihzPWQsZD9FLmJpbmQod2luZG93LFwidW5sb2FkXCIsYSk6RS51bmJpbmQod2luZG93LFwidW5sb2FkXCIsYSksbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXIodCxcImlzTG9jYWxcIiksZCkpfX19KSxVLmlzVW5kZWZpbmVkKHIucGFyZW50KSl7aWYodGhpcy5jbG9zZWQ9ci5jbG9zZWR8fCExLEUuYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LGkuQ0xBU1NfTUFJTiksRS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsITEpLCRyJiZzKXt0LnVzZUxvY2FsU3RvcmFnZT0hMDt2YXIgbD1sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhcih0aGlzLFwiZ3VpXCIpKTtsJiYoci5sb2FkPUpTT04ucGFyc2UobCkpfXRoaXMuX19jbG9zZUJ1dHRvbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUw9aS5URVhUX0NMT1NFRCxFLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbixpLkNMQVNTX0NMT1NFX0JVVFRPTiksci5jbG9zZU9uVG9wPyhFLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbixpLkNMQVNTX0NMT1NFX1RPUCksdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9fY2xvc2VCdXR0b24sdGhpcy5kb21FbGVtZW50LmNoaWxkTm9kZXNbMF0pKTooRS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24saS5DTEFTU19DTE9TRV9CT1RUT00pLHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2xvc2VCdXR0b24pKSxFLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLFwiY2xpY2tcIixmdW5jdGlvbigpe3QuY2xvc2VkPSF0LmNsb3NlZH0pfWVsc2V7ci5jbG9zZWQ9PT12b2lkIDAmJihyLmNsb3NlZD0hMCk7dmFyIGg9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoci5uYW1lKTtFLmFkZENsYXNzKGgsXCJjb250cm9sbGVyLW5hbWVcIiksbj1fbyh0LGgpO3ZhciB1PWZ1bmN0aW9uKGQpe3JldHVybiBkLnByZXZlbnREZWZhdWx0KCksdC5jbG9zZWQ9IXQuY2xvc2VkLCExfTtFLmFkZENsYXNzKHRoaXMuX191bCxpLkNMQVNTX0NMT1NFRCksRS5hZGRDbGFzcyhuLFwidGl0bGVcIiksRS5iaW5kKG4sXCJjbGlja1wiLHUpLHIuY2xvc2VkfHwodGhpcy5jbG9zZWQ9ITEpfXIuYXV0b1BsYWNlJiYoVS5pc1VuZGVmaW5lZChyLnBhcmVudCkmJihtaCYmKHNyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksRS5hZGRDbGFzcyhzcixkaCksRS5hZGRDbGFzcyhzcixpLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNyKSxtaD0hMSksc3IuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KSxFLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCxpLkNMQVNTX0FVVE9fUExBQ0UpKSx0aGlzLnBhcmVudHx8eW8odCxyLndpZHRoKSksdGhpcy5fX3Jlc2l6ZUhhbmRsZXI9ZnVuY3Rpb24oKXt0Lm9uUmVzaXplRGVib3VuY2VkKCl9LEUuYmluZCh3aW5kb3csXCJyZXNpemVcIix0aGlzLl9fcmVzaXplSGFuZGxlciksRS5iaW5kKHRoaXMuX191bCxcIndlYmtpdFRyYW5zaXRpb25FbmRcIix0aGlzLl9fcmVzaXplSGFuZGxlciksRS5iaW5kKHRoaXMuX191bCxcInRyYW5zaXRpb25lbmRcIix0aGlzLl9fcmVzaXplSGFuZGxlciksRS5iaW5kKHRoaXMuX191bCxcIm9UcmFuc2l0aW9uRW5kXCIsdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpLHRoaXMub25SZXNpemUoKSxyLnJlc2l6YWJsZSYmZGcodGhpcyksYT1mdW5jdGlvbigpeyRyJiZsb2NhbFN0b3JhZ2UuZ2V0SXRlbShhcih0LFwiaXNMb2NhbFwiKSk9PT1cInRydWVcIiYmbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXIodCxcImd1aVwiKSxKU09OLnN0cmluZ2lmeSh0LmdldFNhdmVPYmplY3QoKSkpfSx0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGU9YTtmdW5jdGlvbiBjKCl7dmFyIGY9dC5nZXRSb290KCk7Zi53aWR0aCs9MSxVLmRlZmVyKGZ1bmN0aW9uKCl7Zi53aWR0aC09MX0pfXIucGFyZW50fHxjKCl9O3ZlLnRvZ2dsZUhpZGU9ZnVuY3Rpb24oKXtBbz0hQW8sVS5lYWNoKEFoLGZ1bmN0aW9uKGkpe2kuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5PUFvP1wibm9uZVwiOlwiXCJ9KX0sdmUuQ0xBU1NfQVVUT19QTEFDRT1cImFcIix2ZS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUj1cImFjXCIsdmUuQ0xBU1NfTUFJTj1cIm1haW5cIix2ZS5DTEFTU19DT05UUk9MTEVSX1JPVz1cImNyXCIsdmUuQ0xBU1NfVE9PX1RBTEw9XCJ0YWxsZXItdGhhbi13aW5kb3dcIix2ZS5DTEFTU19DTE9TRUQ9XCJjbG9zZWRcIix2ZS5DTEFTU19DTE9TRV9CVVRUT049XCJjbG9zZS1idXR0b25cIix2ZS5DTEFTU19DTE9TRV9UT1A9XCJjbG9zZS10b3BcIix2ZS5DTEFTU19DTE9TRV9CT1RUT009XCJjbG9zZS1ib3R0b21cIix2ZS5DTEFTU19EUkFHPVwiZHJhZ1wiLHZlLkRFRkFVTFRfV0lEVEg9MjQ1LHZlLlRFWFRfQ0xPU0VEPVwiQ2xvc2UgQ29udHJvbHNcIix2ZS5URVhUX09QRU49XCJPcGVuIENvbnRyb2xzXCIsdmUuX2tleWRvd25IYW5kbGVyPWZ1bmN0aW9uKGkpe2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSE9PVwidGV4dFwiJiYoaS53aGljaD09PWdofHxpLmtleUNvZGU9PT1naCkmJnZlLnRvZ2dsZUhpZGUoKX0sRS5iaW5kKHdpbmRvdyxcImtleWRvd25cIix2ZS5fa2V5ZG93bkhhbmRsZXIsITEpLFUuZXh0ZW5kKHZlLnByb3RvdHlwZSx7YWRkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRzKHRoaXMsZSx0LHtmYWN0b3J5QXJnczpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMil9KX0sYWRkQ29sb3I6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHModGhpcyxlLHQse2NvbG9yOiEwfSl9LHJlbW92ZTpmdW5jdGlvbihlKXt0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoZS5fX2xpKSx0aGlzLl9fY29udHJvbGxlcnMuc3BsaWNlKHRoaXMuX19jb250cm9sbGVycy5pbmRleE9mKGUpLDEpO3ZhciB0PXRoaXM7VS5kZWZlcihmdW5jdGlvbigpe3Qub25SZXNpemUoKX0pfSxkZXN0cm95OmZ1bmN0aW9uKCl7aWYodGhpcy5wYXJlbnQpdGhyb3cgbmV3IEVycm9yKFwiT25seSB0aGUgcm9vdCBHVUkgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCAuZGVzdHJveSgpLiBGb3Igc3ViZm9sZGVycywgdXNlIGd1aS5yZW1vdmVGb2xkZXIoZm9sZGVyKSBpbnN0ZWFkLlwiKTt0aGlzLmF1dG9QbGFjZSYmc3IucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50KTt2YXIgZT10aGlzO1UuZWFjaCh0aGlzLl9fZm9sZGVycyxmdW5jdGlvbih0KXtlLnJlbW92ZUZvbGRlcih0KX0pLEUudW5iaW5kKHdpbmRvdyxcImtleWRvd25cIix2ZS5fa2V5ZG93bkhhbmRsZXIsITEpLF9oKHRoaXMpfSxhZGRGb2xkZXI6ZnVuY3Rpb24oZSl7aWYodGhpcy5fX2ZvbGRlcnNbZV0hPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZSBuYW1lIFwiJytlKydcIicpO3ZhciB0PXtuYW1lOmUscGFyZW50OnRoaXN9O3QuYXV0b1BsYWNlPXRoaXMuYXV0b1BsYWNlLHRoaXMubG9hZCYmdGhpcy5sb2FkLmZvbGRlcnMmJnRoaXMubG9hZC5mb2xkZXJzW2VdJiYodC5jbG9zZWQ9dGhpcy5sb2FkLmZvbGRlcnNbZV0uY2xvc2VkLHQubG9hZD10aGlzLmxvYWQuZm9sZGVyc1tlXSk7dmFyIHI9bmV3IHZlKHQpO3RoaXMuX19mb2xkZXJzW2VdPXI7dmFyIHM9X28odGhpcyxyLmRvbUVsZW1lbnQpO3JldHVybiBFLmFkZENsYXNzKHMsXCJmb2xkZXJcIikscn0scmVtb3ZlRm9sZGVyOmZ1bmN0aW9uKGUpe3RoaXMuX191bC5yZW1vdmVDaGlsZChlLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCksZGVsZXRlIHRoaXMuX19mb2xkZXJzW2UubmFtZV0sdGhpcy5sb2FkJiZ0aGlzLmxvYWQuZm9sZGVycyYmdGhpcy5sb2FkLmZvbGRlcnNbZS5uYW1lXSYmZGVsZXRlIHRoaXMubG9hZC5mb2xkZXJzW2UubmFtZV0sX2goZSk7dmFyIHQ9dGhpcztVLmVhY2goZS5fX2ZvbGRlcnMsZnVuY3Rpb24ocil7ZS5yZW1vdmVGb2xkZXIocil9KSxVLmRlZmVyKGZ1bmN0aW9uKCl7dC5vblJlc2l6ZSgpfSl9LG9wZW46ZnVuY3Rpb24oKXt0aGlzLmNsb3NlZD0hMX0sY2xvc2U6ZnVuY3Rpb24oKXt0aGlzLmNsb3NlZD0hMH0saGlkZTpmdW5jdGlvbigpe3RoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5PVwibm9uZVwifSxzaG93OmZ1bmN0aW9uKCl7dGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJcIn0sb25SZXNpemU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldFJvb3QoKTtpZihlLnNjcm9sbGFibGUpe3ZhciB0PUUuZ2V0T2Zmc2V0KGUuX191bCkudG9wLHI9MDtVLmVhY2goZS5fX3VsLmNoaWxkTm9kZXMsZnVuY3Rpb24ocyl7ZS5hdXRvUGxhY2UmJnM9PT1lLl9fc2F2ZV9yb3d8fChyKz1FLmdldEhlaWdodChzKSl9KSx3aW5kb3cuaW5uZXJIZWlnaHQtdC1waDxyPyhFLmFkZENsYXNzKGUuZG9tRWxlbWVudCx2ZS5DTEFTU19UT09fVEFMTCksZS5fX3VsLnN0eWxlLmhlaWdodD13aW5kb3cuaW5uZXJIZWlnaHQtdC1waCtcInB4XCIpOihFLnJlbW92ZUNsYXNzKGUuZG9tRWxlbWVudCx2ZS5DTEFTU19UT09fVEFMTCksZS5fX3VsLnN0eWxlLmhlaWdodD1cImF1dG9cIil9ZS5fX3Jlc2l6ZV9oYW5kbGUmJlUuZGVmZXIoZnVuY3Rpb24oKXtlLl9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQ9ZS5fX3VsLm9mZnNldEhlaWdodCtcInB4XCJ9KSxlLl9fY2xvc2VCdXR0b24mJihlLl9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGg9ZS53aWR0aCtcInB4XCIpfSxvblJlc2l6ZURlYm91bmNlZDpVLmRlYm91bmNlKGZ1bmN0aW9uKCl7dGhpcy5vblJlc2l6ZSgpfSw1MCkscmVtZW1iZXI6ZnVuY3Rpb24oKXtpZihVLmlzVW5kZWZpbmVkKGVzKSYmKGVzPW5ldyBoZyxlcy5kb21FbGVtZW50LmlubmVySFRNTD1hZyksdGhpcy5wYXJlbnQpdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLlwiKTt2YXIgZT10aGlzO1UuZWFjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGZ1bmN0aW9uKHQpe2UuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGg9PT0wJiZmZyhlKSxlLl9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZih0KT09PS0xJiZlLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaCh0KX0pLHRoaXMuYXV0b1BsYWNlJiZ5byh0aGlzLHRoaXMud2lkdGgpfSxnZXRSb290OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXM7ZS5wYXJlbnQ7KWU9ZS5wYXJlbnQ7cmV0dXJuIGV9LGdldFNhdmVPYmplY3Q6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxvYWQ7cmV0dXJuIGUuY2xvc2VkPXRoaXMuY2xvc2VkLHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGg+MCYmKGUucHJlc2V0PXRoaXMucHJlc2V0LGUucmVtZW1iZXJlZHx8KGUucmVtZW1iZXJlZD17fSksZS5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XT1Wcyh0aGlzKSksZS5mb2xkZXJzPXt9LFUuZWFjaCh0aGlzLl9fZm9sZGVycyxmdW5jdGlvbih0LHIpe2UuZm9sZGVyc1tyXT10LmdldFNhdmVPYmplY3QoKX0pLGV9LHNhdmU6ZnVuY3Rpb24oKXt0aGlzLmxvYWQucmVtZW1iZXJlZHx8KHRoaXMubG9hZC5yZW1lbWJlcmVkPXt9KSx0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF09VnModGhpcykseG8odGhpcywhMSksdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCl9LHNhdmVBczpmdW5jdGlvbihlKXt0aGlzLmxvYWQucmVtZW1iZXJlZHx8KHRoaXMubG9hZC5yZW1lbWJlcmVkPXt9LHRoaXMubG9hZC5yZW1lbWJlcmVkW1pyXT1Wcyh0aGlzLCEwKSksdGhpcy5sb2FkLnJlbWVtYmVyZWRbZV09VnModGhpcyksdGhpcy5wcmVzZXQ9ZSx2byh0aGlzLGUsITApLHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpfSxyZXZlcnQ6ZnVuY3Rpb24oZSl7VS5lYWNoKHRoaXMuX19jb250cm9sbGVycyxmdW5jdGlvbih0KXt0aGlzLmdldFJvb3QoKS5sb2FkLnJlbWVtYmVyZWQ/eGgoZXx8dGhpcy5nZXRSb290KCksdCk6dC5zZXRWYWx1ZSh0LmluaXRpYWxWYWx1ZSksdC5fX29uRmluaXNoQ2hhbmdlJiZ0Ll9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0LHQuZ2V0VmFsdWUoKSl9LHRoaXMpLFUuZWFjaCh0aGlzLl9fZm9sZGVycyxmdW5jdGlvbih0KXt0LnJldmVydCh0KX0pLGV8fHhvKHRoaXMuZ2V0Um9vdCgpLCExKX0sbGlzdGVuOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX19saXN0ZW5pbmcubGVuZ3RoPT09MDt0aGlzLl9fbGlzdGVuaW5nLnB1c2goZSksdCYmeWgodGhpcy5fX2xpc3RlbmluZyl9LHVwZGF0ZURpc3BsYXk6ZnVuY3Rpb24oKXtVLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLGZ1bmN0aW9uKGUpe2UudXBkYXRlRGlzcGxheSgpfSksVS5lYWNoKHRoaXMuX19mb2xkZXJzLGZ1bmN0aW9uKGUpe2UudXBkYXRlRGlzcGxheSgpfSl9fSk7ZnVuY3Rpb24gX28oaSxlLHQpe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtyZXR1cm4gZSYmci5hcHBlbmRDaGlsZChlKSx0P2kuX191bC5pbnNlcnRCZWZvcmUocix0KTppLl9fdWwuYXBwZW5kQ2hpbGQociksaS5vblJlc2l6ZSgpLHJ9ZnVuY3Rpb24gX2goaSl7RS51bmJpbmQod2luZG93LFwicmVzaXplXCIsaS5fX3Jlc2l6ZUhhbmRsZXIpLGkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSYmRS51bmJpbmQod2luZG93LFwidW5sb2FkXCIsaS5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKX1mdW5jdGlvbiB4byhpLGUpe3ZhciB0PWkuX19wcmVzZXRfc2VsZWN0W2kuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO2U/dC5pbm5lckhUTUw9dC52YWx1ZStcIipcIjp0LmlubmVySFRNTD10LnZhbHVlfWZ1bmN0aW9uIGNnKGksZSx0KXtpZih0Ll9fbGk9ZSx0Ll9fZ3VpPWksVS5leHRlbmQodCx7b3B0aW9uczpmdW5jdGlvbihuKXtpZihhcmd1bWVudHMubGVuZ3RoPjEpe3ZhciBsPXQuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7cmV0dXJuIHQucmVtb3ZlKCksdHMoaSx0Lm9iamVjdCx0LnByb3BlcnR5LHtiZWZvcmU6bCxmYWN0b3J5QXJnczpbVS50b0FycmF5KGFyZ3VtZW50cyldfSl9aWYoVS5pc0FycmF5KG4pfHxVLmlzT2JqZWN0KG4pKXt2YXIgaD10Ll9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO3JldHVybiB0LnJlbW92ZSgpLHRzKGksdC5vYmplY3QsdC5wcm9wZXJ0eSx7YmVmb3JlOmgsZmFjdG9yeUFyZ3M6W25dfSl9fSxuYW1lOmZ1bmN0aW9uKG4pe3JldHVybiB0Ll9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MPW4sdH0sbGlzdGVuOmZ1bmN0aW9uKCl7cmV0dXJuIHQuX19ndWkubGlzdGVuKHQpLHR9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiB0Ll9fZ3VpLnJlbW92ZSh0KSx0fX0pLHQgaW5zdGFuY2VvZiBwbyl7dmFyIHI9bmV3IFFzKHQub2JqZWN0LHQucHJvcGVydHkse21pbjp0Ll9fbWluLG1heDp0Ll9fbWF4LHN0ZXA6dC5fX3N0ZXB9KTtVLmVhY2goW1widXBkYXRlRGlzcGxheVwiLFwib25DaGFuZ2VcIixcIm9uRmluaXNoQ2hhbmdlXCIsXCJzdGVwXCIsXCJtaW5cIixcIm1heFwiXSxmdW5jdGlvbihhKXt2YXIgbj10W2FdLGw9clthXTt0W2FdPXJbYV09ZnVuY3Rpb24oKXt2YXIgaD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3JldHVybiBsLmFwcGx5KHIsaCksbi5hcHBseSh0LGgpfX0pLEUuYWRkQ2xhc3MoZSxcImhhcy1zbGlkZXJcIiksdC5kb21FbGVtZW50Lmluc2VydEJlZm9yZShyLmRvbUVsZW1lbnQsdC5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBRcyl7dmFyIHM9ZnVuY3Rpb24obil7aWYoVS5pc051bWJlcih0Ll9fbWluKSYmVS5pc051bWJlcih0Ll9fbWF4KSl7dmFyIGw9dC5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTCxoPXQuX19ndWkuX19saXN0ZW5pbmcuaW5kZXhPZih0KT4tMTt0LnJlbW92ZSgpO3ZhciB1PXRzKGksdC5vYmplY3QsdC5wcm9wZXJ0eSx7YmVmb3JlOnQuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsZmFjdG9yeUFyZ3M6W3QuX19taW4sdC5fX21heCx0Ll9fc3RlcF19KTtyZXR1cm4gdS5uYW1lKGwpLGgmJnUubGlzdGVuKCksdX1yZXR1cm4gbn07dC5taW49VS5jb21wb3NlKHMsdC5taW4pLHQubWF4PVUuY29tcG9zZShzLHQubWF4KX1lbHNlIHQgaW5zdGFuY2VvZiBuaD8oRS5iaW5kKGUsXCJjbGlja1wiLGZ1bmN0aW9uKCl7RS5mYWtlRXZlbnQodC5fX2NoZWNrYm94LFwiY2xpY2tcIil9KSxFLmJpbmQodC5fX2NoZWNrYm94LFwiY2xpY2tcIixmdW5jdGlvbihhKXthLnN0b3BQcm9wYWdhdGlvbigpfSkpOnQgaW5zdGFuY2VvZiBjaD8oRS5iaW5kKGUsXCJjbGlja1wiLGZ1bmN0aW9uKCl7RS5mYWtlRXZlbnQodC5fX2J1dHRvbixcImNsaWNrXCIpfSksRS5iaW5kKGUsXCJtb3VzZW92ZXJcIixmdW5jdGlvbigpe0UuYWRkQ2xhc3ModC5fX2J1dHRvbixcImhvdmVyXCIpfSksRS5iaW5kKGUsXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7RS5yZW1vdmVDbGFzcyh0Ll9fYnV0dG9uLFwiaG92ZXJcIil9KSk6dCBpbnN0YW5jZW9mIG1vJiYoRS5hZGRDbGFzcyhlLFwiY29sb3JcIiksdC51cGRhdGVEaXNwbGF5PVUuY29tcG9zZShmdW5jdGlvbihhKXtyZXR1cm4gZS5zdHlsZS5ib3JkZXJMZWZ0Q29sb3I9dC5fX2NvbG9yLnRvU3RyaW5nKCksYX0sdC51cGRhdGVEaXNwbGF5KSx0LnVwZGF0ZURpc3BsYXkoKSk7dC5zZXRWYWx1ZT1VLmNvbXBvc2UoZnVuY3Rpb24oYSl7cmV0dXJuIGkuZ2V0Um9vdCgpLl9fcHJlc2V0X3NlbGVjdCYmdC5pc01vZGlmaWVkKCkmJnhvKGkuZ2V0Um9vdCgpLCEwKSxhfSx0LnNldFZhbHVlKX1mdW5jdGlvbiB4aChpLGUpe3ZhciB0PWkuZ2V0Um9vdCgpLHI9dC5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2YoZS5vYmplY3QpO2lmKHIhPT0tMSl7dmFyIHM9dC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tyXTtpZihzPT09dm9pZCAwJiYocz17fSx0Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW3JdPXMpLHNbZS5wcm9wZXJ0eV09ZSx0LmxvYWQmJnQubG9hZC5yZW1lbWJlcmVkKXt2YXIgYT10LmxvYWQucmVtZW1iZXJlZCxuPXZvaWQgMDtpZihhW2kucHJlc2V0XSluPWFbaS5wcmVzZXRdO2Vsc2UgaWYoYVtacl0pbj1hW1pyXTtlbHNlIHJldHVybjtpZihuW3JdJiZuW3JdW2UucHJvcGVydHldIT09dm9pZCAwKXt2YXIgbD1uW3JdW2UucHJvcGVydHldO2UuaW5pdGlhbFZhbHVlPWwsZS5zZXRWYWx1ZShsKX19fX1mdW5jdGlvbiB0cyhpLGUsdCxyKXtpZihlW3RdPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJytlKydcIiBoYXMgbm8gcHJvcGVydHkgXCInK3QrJ1wiJyk7dmFyIHM9dm9pZCAwO2lmKHIuY29sb3Ipcz1uZXcgbW8oZSx0KTtlbHNle3ZhciBhPVtlLHRdLmNvbmNhdChyLmZhY3RvcnlBcmdzKTtzPW9nLmFwcGx5KGksYSl9ci5iZWZvcmUgaW5zdGFuY2VvZiBNaSYmKHIuYmVmb3JlPXIuYmVmb3JlLl9fbGkpLHhoKGkscyksRS5hZGRDbGFzcyhzLmRvbUVsZW1lbnQsXCJjXCIpO3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO0UuYWRkQ2xhc3MobixcInByb3BlcnR5LW5hbWVcIiksbi5pbm5lckhUTUw9cy5wcm9wZXJ0eTt2YXIgbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2wuYXBwZW5kQ2hpbGQobiksbC5hcHBlbmRDaGlsZChzLmRvbUVsZW1lbnQpO3ZhciBoPV9vKGksbCxyLmJlZm9yZSk7cmV0dXJuIEUuYWRkQ2xhc3MoaCx2ZS5DTEFTU19DT05UUk9MTEVSX1JPVykscyBpbnN0YW5jZW9mIG1vP0UuYWRkQ2xhc3MoaCxcImNvbG9yXCIpOkUuYWRkQ2xhc3MoaCxLZChzLmdldFZhbHVlKCkpKSxjZyhpLGgscyksaS5fX2NvbnRyb2xsZXJzLnB1c2gocyksc31mdW5jdGlvbiBhcihpLGUpe3JldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmK1wiLlwiK2V9ZnVuY3Rpb24gdm8oaSxlLHQpe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7ci5pbm5lckhUTUw9ZSxyLnZhbHVlPWUsaS5fX3ByZXNldF9zZWxlY3QuYXBwZW5kQ2hpbGQociksdCYmKGkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXg9aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoLTEpfWZ1bmN0aW9uIHZoKGksZSl7ZS5zdHlsZS5kaXNwbGF5PWkudXNlTG9jYWxTdG9yYWdlP1wiYmxvY2tcIjpcIm5vbmVcIn1mdW5jdGlvbiBmZyhpKXt2YXIgZT1pLl9fc2F2ZV9yb3c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO0UuYWRkQ2xhc3MoaS5kb21FbGVtZW50LFwiaGFzLXNhdmVcIiksaS5fX3VsLmluc2VydEJlZm9yZShlLGkuX191bC5maXJzdENoaWxkKSxFLmFkZENsYXNzKGUsXCJzYXZlLXJvd1wiKTt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTt0LmlubmVySFRNTD1cIiZuYnNwO1wiLEUuYWRkQ2xhc3ModCxcImJ1dHRvbiBnZWFyc1wiKTt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtyLmlubmVySFRNTD1cIlNhdmVcIixFLmFkZENsYXNzKHIsXCJidXR0b25cIiksRS5hZGRDbGFzcyhyLFwic2F2ZVwiKTt2YXIgcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtzLmlubmVySFRNTD1cIk5ld1wiLEUuYWRkQ2xhc3MocyxcImJ1dHRvblwiKSxFLmFkZENsYXNzKHMsXCJzYXZlLWFzXCIpO3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2EuaW5uZXJIVE1MPVwiUmV2ZXJ0XCIsRS5hZGRDbGFzcyhhLFwiYnV0dG9uXCIpLEUuYWRkQ2xhc3MoYSxcInJldmVydFwiKTt2YXIgbj1pLl9fcHJlc2V0X3NlbGVjdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO2lmKGkubG9hZCYmaS5sb2FkLnJlbWVtYmVyZWQ/VS5lYWNoKGkubG9hZC5yZW1lbWJlcmVkLGZ1bmN0aW9uKGYsZCl7dm8oaSxkLGQ9PT1pLnByZXNldCl9KTp2byhpLFpyLCExKSxFLmJpbmQobixcImNoYW5nZVwiLGZ1bmN0aW9uKCl7Zm9yKHZhciBmPTA7ZjxpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7ZisrKWkuX19wcmVzZXRfc2VsZWN0W2ZdLmlubmVySFRNTD1pLl9fcHJlc2V0X3NlbGVjdFtmXS52YWx1ZTtpLnByZXNldD10aGlzLnZhbHVlfSksZS5hcHBlbmRDaGlsZChuKSxlLmFwcGVuZENoaWxkKHQpLGUuYXBwZW5kQ2hpbGQociksZS5hcHBlbmRDaGlsZChzKSxlLmFwcGVuZENoaWxkKGEpLCRyKXt2YXIgbD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRnLWxvY2FsLWV4cGxhaW5cIiksaD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRnLWxvY2FsLXN0b3JhZ2VcIiksdT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRnLXNhdmUtbG9jYWxseVwiKTt1LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLGxvY2FsU3RvcmFnZS5nZXRJdGVtKGFyKGksXCJpc0xvY2FsXCIpKT09PVwidHJ1ZVwiJiZoLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcImNoZWNrZWRcIiksdmgoaSxsKSxFLmJpbmQoaCxcImNoYW5nZVwiLGZ1bmN0aW9uKCl7aS51c2VMb2NhbFN0b3JhZ2U9IWkudXNlTG9jYWxTdG9yYWdlLHZoKGksbCl9KX12YXIgYz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRnLW5ldy1jb25zdHJ1Y3RvclwiKTtFLmJpbmQoYyxcImtleWRvd25cIixmdW5jdGlvbihmKXtmLm1ldGFLZXkmJihmLndoaWNoPT09Njd8fGYua2V5Q29kZT09PTY3KSYmZXMuaGlkZSgpfSksRS5iaW5kKHQsXCJjbGlja1wiLGZ1bmN0aW9uKCl7Yy5pbm5lckhUTUw9SlNPTi5zdHJpbmdpZnkoaS5nZXRTYXZlT2JqZWN0KCksdm9pZCAwLDIpLGVzLnNob3coKSxjLmZvY3VzKCksYy5zZWxlY3QoKX0pLEUuYmluZChyLFwiY2xpY2tcIixmdW5jdGlvbigpe2kuc2F2ZSgpfSksRS5iaW5kKHMsXCJjbGlja1wiLGZ1bmN0aW9uKCl7dmFyIGY9cHJvbXB0KFwiRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuXCIpO2YmJmkuc2F2ZUFzKGYpfSksRS5iaW5kKGEsXCJjbGlja1wiLGZ1bmN0aW9uKCl7aS5yZXZlcnQoKX0pfWZ1bmN0aW9uIGRnKGkpe3ZhciBlPXZvaWQgMDtpLl9fcmVzaXplX2hhbmRsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFUuZXh0ZW5kKGkuX19yZXNpemVfaGFuZGxlLnN0eWxlLHt3aWR0aDpcIjZweFwiLG1hcmdpbkxlZnQ6XCItM3B4XCIsaGVpZ2h0OlwiMjAwcHhcIixjdXJzb3I6XCJldy1yZXNpemVcIixwb3NpdGlvbjpcImFic29sdXRlXCJ9KTtmdW5jdGlvbiB0KGEpe3JldHVybiBhLnByZXZlbnREZWZhdWx0KCksaS53aWR0aCs9ZS1hLmNsaWVudFgsaS5vblJlc2l6ZSgpLGU9YS5jbGllbnRYLCExfWZ1bmN0aW9uIHIoKXtFLnJlbW92ZUNsYXNzKGkuX19jbG9zZUJ1dHRvbix2ZS5DTEFTU19EUkFHKSxFLnVuYmluZCh3aW5kb3csXCJtb3VzZW1vdmVcIix0KSxFLnVuYmluZCh3aW5kb3csXCJtb3VzZXVwXCIscil9ZnVuY3Rpb24gcyhhKXtyZXR1cm4gYS5wcmV2ZW50RGVmYXVsdCgpLGU9YS5jbGllbnRYLEUuYWRkQ2xhc3MoaS5fX2Nsb3NlQnV0dG9uLHZlLkNMQVNTX0RSQUcpLEUuYmluZCh3aW5kb3csXCJtb3VzZW1vdmVcIix0KSxFLmJpbmQod2luZG93LFwibW91c2V1cFwiLHIpLCExfUUuYmluZChpLl9fcmVzaXplX2hhbmRsZSxcIm1vdXNlZG93blwiLHMpLEUuYmluZChpLl9fY2xvc2VCdXR0b24sXCJtb3VzZWRvd25cIixzKSxpLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGkuX19yZXNpemVfaGFuZGxlLGkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCl9ZnVuY3Rpb24geW8oaSxlKXtpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGg9ZStcInB4XCIsaS5fX3NhdmVfcm93JiZpLmF1dG9QbGFjZSYmKGkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aD1lK1wicHhcIiksaS5fX2Nsb3NlQnV0dG9uJiYoaS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoPWUrXCJweFwiKX1mdW5jdGlvbiBWcyhpLGUpe3ZhciB0PXt9O3JldHVybiBVLmVhY2goaS5fX3JlbWVtYmVyZWRPYmplY3RzLGZ1bmN0aW9uKHIscyl7dmFyIGE9e30sbj1pLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW3NdO1UuZWFjaChuLGZ1bmN0aW9uKGwsaCl7YVtoXT1lP2wuaW5pdGlhbFZhbHVlOmwuZ2V0VmFsdWUoKX0pLHRbc109YX0pLHR9ZnVuY3Rpb24gZ2coaSl7Zm9yKHZhciBlPTA7ZTxpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7ZSsrKWkuX19wcmVzZXRfc2VsZWN0W2VdLnZhbHVlPT09aS5wcmVzZXQmJihpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4PWUpfWZ1bmN0aW9uIHloKGkpe2kubGVuZ3RoIT09MCYmbGcuY2FsbCh3aW5kb3csZnVuY3Rpb24oKXt5aChpKX0pLFUuZWFjaChpLGZ1bmN0aW9uKGUpe2UudXBkYXRlRGlzcGxheSgpfSl9dmFyIENoPXZlO2NsYXNzIHBne2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiZGVidWdcIiwhMSksbyh0aGlzLFwiZGF0YVwiKSxvKHRoaXMsXCJndWlcIiksbyh0aGlzLFwiYmluZFwiKSxvKHRoaXMsXCJfY3VycmVudFwiKSxvKHRoaXMsXCJfbnVsbEJpbmRcIix7fSksbyh0aGlzLFwiZm9sZGVyc1wiLHt9KSx0aGlzLmRhdGE9e30sdGhpcy5iaW5kPXt9LHRoaXMuX251bGxCaW5kPXt9LHRoaXMuX251bGxCaW5kLm9uQ2hhbmdlPSgpPT57fX1pbml0KGU9MTApe3RoaXMuZGVidWc9ITAsdGhpcy5ndWk9bmV3IENoLHRoaXMuZ3VpLmRvbUVsZW1lbnQuc3R5bGUuekluZGV4PWAke2V9YCx0aGlzLmd1aS5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQuc3R5bGUuekluZGV4PWAke2V9YCx0aGlzLmFkZEZvbGRlcihcIk9yaWxsdXNpb25cIil9YWRkQ3VzdG9tKGUsdCxyLHMsYSxuKXtpZighdGhpcy5kZWJ1ZylyZXR1cm4gdGhpcy5fbnVsbEJpbmQ7bGV0IGw9dGhpcy5fY3VycmVudD90aGlzLl9jdXJyZW50OnRoaXMuZ3VpLGg9e1tlXTp0W3JdfTtsLmFkZChoLGUscyxhLG4pLm9uQ2hhbmdlKHU9Pnt0W3JdPXV9KX1hZGQoZSx0LHIscyxhKXtyZXR1cm4gdGhpcy5kZWJ1Zz8odGhpcy5fY3VycmVudD90aGlzLl9jdXJyZW50OnRoaXMuZ3VpKS5hZGQoZSx0LHIscyxhKTp0aGlzLl9udWxsQmluZH1hZGRMYWJlbChlKXtpZighdGhpcy5kZWJ1ZylyZXR1cm4gdGhpcy5fbnVsbEJpbmQ7YnQuYWRkKHtsYWJlbDplfSxcImxhYmVsXCIpfWFkZEluZm8oZSx0KXtpZighdGhpcy5kZWJ1ZylyZXR1cm4gdGhpcy5fbnVsbEJpbmQ7bGV0IHI9e307cltlXT10LnRvU3RyaW5nKCksYnQuYWRkKHIsZSl9YWRkQ29sb3IoZSx0KXtpZighdGhpcy5kZWJ1ZylyZXR1cm4gdGhpcy5fbnVsbEJpbmQ7bGV0IHM9KHRoaXMuX2N1cnJlbnQ/dGhpcy5fY3VycmVudDp0aGlzLmd1aSkuYWRkQ29sb3IoZVt0XSxcInJnYmFcIikubmFtZSh0KTtyZXR1cm4gcy5vbkNoYW5nZShhPT57Y29uc29sZS5sb2coYSk7bGV0IG49ZVt0XTtuLnJnYmE9YSxlW3RdPW59KSxzfWFkZEJ1dHRvbihlLHQpe2lmKCF0aGlzLmRlYnVnKXJldHVybiB0aGlzLl9udWxsQmluZDt2YXIgcj1uZXcgZnVuY3Rpb24oKXt0aGlzW2VdPXR9Oyh0aGlzLl9jdXJyZW50P3RoaXMuX2N1cnJlbnQ6dGhpcy5ndWkpLmFkZChyLGUpfW9wZW4oKXtpZighdGhpcy5kZWJ1ZylyZXR1cm4gdGhpcy5fbnVsbEJpbmQ7KHRoaXMuX2N1cnJlbnQ/dGhpcy5fY3VycmVudDp0aGlzLmd1aSkub3BlbigpfWNsb3NlKCl7aWYoIXRoaXMuZGVidWcpcmV0dXJuIHRoaXMuX251bGxCaW5kOyh0aGlzLl9jdXJyZW50P3RoaXMuX2N1cnJlbnQ6dGhpcy5ndWkpLmNsb3NlKCl9YWRkRm9sZGVyKGUpe3JldHVybiB0aGlzLmRlYnVnPyh0aGlzLmZvbGRlcnNbZV0/dGhpcy5fY3VycmVudD10aGlzLmZvbGRlcnNbZV06KHRoaXMuX2N1cnJlbnQ9dGhpcy5ndWkuYWRkRm9sZGVyKGUpLHRoaXMuZm9sZGVyc1tlXT10aGlzLl9jdXJyZW50KSx0aGlzLl9jdXJyZW50KTp0aGlzLl9udWxsQmluZH1yZW1vdmVGb2xkZXIoZSl7aWYoIXRoaXMuZGVidWcpcmV0dXJuIHRoaXMuX251bGxCaW5kO2xldCB0PXRoaXMuZm9sZGVyc1tlXTt0JiYodGhpcy5ndWkucmVtb3ZlRm9sZGVyKHQpLHRoaXMuX2N1cnJlbnQ9bnVsbCxkZWxldGUgdGhpcy5mb2xkZXJzW2VdKX1lbmRGb2xkZXIoKXtpZighdGhpcy5kZWJ1ZylyZXR1cm4gdGhpcy5fbnVsbEJpbmQ7dGhpcy5fY3VycmVudD1udWxsfV9jcmVhdFBhbmVsKCl7bGV0IGU9bmV3IENoO3JldHVybiBlLmRvbUVsZW1lbnQuc3R5bGUuekluZGV4PVwiMTBcIixlLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudC5zdHlsZS56SW5kZXg9XCIxMFwiLGV9X2FkZChlLHQscixzLGEsbil7cmV0dXJuIGUuYWRkKHQscixzLGEsbil9X2FkZExhYmVsKGUsdCl7YnQuX2FkZChlLHtsYWJlbDp0fSxcImxhYmVsXCIpfV9hZGRCdXR0b24oZSx0LHIpe3ZhciBzPW5ldyBmdW5jdGlvbigpe3RoaXNbdF09cn07ZS5hZGQocyx0KX1fYWRkQ29sb3IoZSx0LHIpe3JldHVybiBlLmFkZENvbG9yKHRbcl0sXCJyZ2JcIikubmFtZShyKX1fYWRkRm9sZGVyKGUsdCl7ZS5Gb2xkZXI9PW51bGwmJihlLkZvbGRlcj17fSk7bGV0IHI9ZS5hZGRGb2xkZXIodCk7cmV0dXJuIGUuRm9sZGVyW3RdPXIscn1fcmVtb3ZlRm9sZGVyKGUsdCl7ZS5Gb2xkZXImJmUuRm9sZGVyW3RdJiZlLnJlbW92ZUZvbGRlcihlLkZvbGRlclt0XSl9fWxldCBidD1uZXcgcGc7Y2xhc3Mgd2ggZXh0ZW5kcyBkaXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcIm1heE51bUxpZ2h0c1BlckNsdXN0ZXJcIiw2NCksbyh0aGlzLFwiY2x1c3RlclBpeFwiLDEpLG8odGhpcyxcImNsdXN0ZXJMaWdodGluZ0J1ZmZlclwiKSxvKHRoaXMsXCJfY3VycmVudExpZ2h0Q291bnRcIiwwKSxvKHRoaXMsXCJfY2x1c3RlckdlbmVyYXRlQ29tcHV0ZVwiKSxvKHRoaXMsXCJfY2x1c3RlckxpZ2h0aW5nQ29tcHV0ZVwiKSxvKHRoaXMsXCJfdXNlQ2FtZXJhXCIpLG8odGhpcyxcInJlc2l6ZVwiLCExKSx0aGlzLnBhc3NUeXBlPXJlLkNsdXN0ZXIsdGhpcy5pbml0Q29tcHV0ZShlKX1pbml0Q29tcHV0ZShlKXt0aGlzLl9jbHVzdGVyR2VuZXJhdGVDb21wdXRlPW5ldyBiZShpaCksdGhpcy5fY2x1c3RlckxpZ2h0aW5nQ29tcHV0ZT1uZXcgYmUocmgpO2xldCB0PVMucHJlc2VudGF0aW9uU2l6ZSxyPWtlLmNsdXN0ZXJUaWxlWCprZS5jbHVzdGVyVGlsZVkqa2UuY2x1c3RlclRpbGVaLHM9ZS5jYW1lcmEsYT1zLm5lYXIsbj1zLmZhcjt0aGlzLmNsdXN0ZXJMaWdodGluZ0J1ZmZlcj1uZXcgdGgocix0aGlzLm1heE51bUxpZ2h0c1BlckNsdXN0ZXIpLHRoaXMuY2x1c3RlckxpZ2h0aW5nQnVmZmVyLnVwZGF0ZSh0WzBdLHRbMV0sdGhpcy5jbHVzdGVyUGl4LGtlLmNsdXN0ZXJUaWxlWCxrZS5jbHVzdGVyVGlsZVksa2UuY2x1c3RlclRpbGVaLDAsdGhpcy5tYXhOdW1MaWdodHNQZXJDbHVzdGVyLGEsbiksdGhpcy5fY2x1c3RlckdlbmVyYXRlQ29tcHV0ZS5zZXRVbmlmb3JtQnVmZmVyKFwiY2x1c3RlcnNVbmlmb3JtXCIsdGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIuY2x1c3RlcnNVbmlmb3JtQnVmZmVyKSx0aGlzLl9jbHVzdGVyR2VuZXJhdGVDb21wdXRlLnNldFN0b3JhZ2VCdWZmZXIoXCJjbHVzdGVyQnVmZmVyXCIsdGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIuY2x1c3RlckJ1ZmZlcik7bGV0IGw9cGUuZ2V0TGlnaHRFbnRyaWVzKGUuc2NlbmUpO3RoaXMuX2NsdXN0ZXJMaWdodGluZ0NvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcIm1vZGVsc1wiLHBlLm1vZGVsTWF0cml4QmluZEdyb3VwLm1hdHJpeEJ1ZmZlckRzdCksdGhpcy5fY2x1c3RlckxpZ2h0aW5nQ29tcHV0ZS5zZXRVbmlmb3JtQnVmZmVyKFwiY2x1c3RlcnNVbmlmb3JtXCIsdGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIuY2x1c3RlcnNVbmlmb3JtQnVmZmVyKSx0aGlzLl9jbHVzdGVyTGlnaHRpbmdDb21wdXRlLnNldFN0b3JhZ2VCdWZmZXIoXCJjbHVzdGVyQnVmZmVyXCIsdGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIuY2x1c3RlckJ1ZmZlciksdGhpcy5fY2x1c3RlckxpZ2h0aW5nQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwibGlnaHRCdWZmZXJcIixsLnN0b3JhZ2VHUFVCdWZmZXIpLHRoaXMuX2NsdXN0ZXJMaWdodGluZ0NvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcImxpZ2h0QXNzaWduQnVmZmVyXCIsdGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIubGlnaHRBc3NpZ25CdWZmZXIpLHRoaXMuX2NsdXN0ZXJMaWdodGluZ0NvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcImFzc2lnblRhYmxlXCIsdGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIuYXNzaWduVGFibGVCdWZmZXIpLHRoaXMucmVzaXplPSEwLGJ0LmFkZEJ1dHRvbihcImNsdXN0ZXJCdWZmZXJcIiwoKT0+e2xldCBoPXRoaXMuY2x1c3RlckxpZ2h0aW5nQnVmZmVyLmNsdXN0ZXJCdWZmZXIucmVhZEJ1ZmZlcigpO2NvbnNvbGUubG9nKGgpO2xldCB1PTIqNDtmb3IobGV0IGM9MDtjPHI7YysrKXtjb25zdCBmPW5ldyBGbG9hdDMyQXJyYXkoaC5idWZmZXIsYyp1KjQsdSk7bGV0IGQ9bmV3IGcoZlswXSxmWzFdLGZbMl0sZlszXSkscD1uZXcgZyhmWzRdLGZbNV0sZls2XSxmWzddKTtlLmdyYXBoaWMzRC5kcmF3Qm94KGMrXCItYm94XCIsZCxwLHoucmFuZG9tKCkpfX0pLGJ0LmFkZEJ1dHRvbihcImFzc2lnblRhYmxlXCIsKCk9PntsZXQgaD10aGlzLmNsdXN0ZXJMaWdodGluZ0J1ZmZlci5hc3NpZ25UYWJsZUJ1ZmZlci5yZWFkQnVmZmVyKCk7Zm9yKGxldCB1PTA7dTxoLmxlbmd0aC80O3UrKyl7Y29uc3QgYz1oW3UqNCswXSxmPWhbdSo0KzFdLGQ9aFt1KjQrMl0scD1oW3UqNCszXTtjPj0xJiZjb25zb2xlLmxvZyhjKSxmK2M+ZisxJiZjb25zb2xlLmxvZyhjLGYsZCxwKX1jb25zb2xlLmxvZyhoKX0pLGJ0LmFkZEJ1dHRvbihcImNsdXN0ZXJzVW5pZm9ybUJ1ZmZlclwiLCgpPT57bGV0IGg9dGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIuY2x1c3RlcnNVbmlmb3JtQnVmZmVyLnJlYWRCdWZmZXIoKTtjb25zb2xlLmxvZyhoKX0pfXJlbmRlcihlLHQpe2xldCByPWUuc2NlbmUscz1RLmluc3RhbmNlLmdldExpZ2h0cyhyKTtpZih0aGlzLl91c2VDYW1lcmEhPWUuY2FtZXJhKXt0aGlzLl91c2VDYW1lcmE9ZS5jYW1lcmE7bGV0IGw9cGUuZ2V0Q2FtZXJhR3JvdXAodGhpcy5fdXNlQ2FtZXJhKTt0aGlzLl9jbHVzdGVyR2VuZXJhdGVDb21wdXRlLnNldFVuaWZvcm1CdWZmZXIoXCJnbG9iYWxVbmlmb3JtXCIsbC51bmlmb3JtR1BVQnVmZmVyKSx0aGlzLl9jbHVzdGVyTGlnaHRpbmdDb21wdXRlLnNldFVuaWZvcm1CdWZmZXIoXCJnbG9iYWxVbmlmb3JtXCIsbC51bmlmb3JtR1BVQnVmZmVyKX10aGlzLl9jdXJyZW50TGlnaHRDb3VudCE9cy5sZW5ndGgmJih0aGlzLl9jdXJyZW50TGlnaHRDb3VudD1zLmxlbmd0aCx0aGlzLmNsdXN0ZXJMaWdodGluZ0J1ZmZlci5jbHVzdGVyc1VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJudW1MaWdodHNcIixzLmxlbmd0aCksdGhpcy5jbHVzdGVyTGlnaHRpbmdCdWZmZXIuY2x1c3RlcnNVbmlmb3JtQnVmZmVyLmFwcGx5KCksdGhpcy5fY2x1c3RlckdlbmVyYXRlQ29tcHV0ZS53b3JrZXJTaXplWD1rZS5jbHVzdGVyVGlsZVosdGhpcy5fY2x1c3RlckxpZ2h0aW5nQ29tcHV0ZS53b3JrZXJTaXplWD1rZS5jbHVzdGVyVGlsZVopO2xldCBhPVMucHJlc2VudGF0aW9uU2l6ZTt0aGlzLmNsdXN0ZXJMaWdodGluZ0J1ZmZlci51cGRhdGUoYVswXSxhWzFdLHRoaXMuY2x1c3RlclBpeCxrZS5jbHVzdGVyVGlsZVgsa2UuY2x1c3RlclRpbGVZLGtlLmNsdXN0ZXJUaWxlWixzLmxlbmd0aCx0aGlzLm1heE51bUxpZ2h0c1BlckNsdXN0ZXIsZS5jYW1lcmEubmVhcixlLmNhbWVyYS5mYXIpLHRoaXMucmVzaXplPSExO2xldCBuPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO3cuY29tcHV0ZUNvbW1hbmQobixbdGhpcy5fY2x1c3RlckdlbmVyYXRlQ29tcHV0ZSx0aGlzLl9jbHVzdGVyTGlnaHRpbmdDb21wdXRlXSksdy5lbmRDb21tYW5kRW5jb2RlcihuKX19Y2xhc3MgYmggZXh0ZW5kcyB0ZXtjb25zdHJ1Y3RvcihlPS4wMDEsdD0xZTQscj05MCxzPSExKXtzdXBlcigpLG8odGhpcyxcInVwX2NhbWVyYVwiKSxvKHRoaXMsXCJkb3duX2NhbWVyYVwiKSxvKHRoaXMsXCJsZWZ0X2NhbWVyYVwiKSxvKHRoaXMsXCJyaWdodF9jYW1lcmFcIiksbyh0aGlzLFwiZnJvbnRfY2FtZXJhXCIpLG8odGhpcyxcImJhY2tfY2FtZXJhXCIpLHRoaXMuaW5pdEN1YmVDYW1lcmEoZSx0LHIscyl9c2V0IGxhYmVsKGUpe3RoaXMudXBfY2FtZXJhLm5hbWU9ZStcInVwXCIsdGhpcy5kb3duX2NhbWVyYS5uYW1lPWUrXCJkb3duXCIsdGhpcy5sZWZ0X2NhbWVyYS5uYW1lPWUrXCJsZWZ0XCIsdGhpcy5yaWdodF9jYW1lcmEubmFtZT1lK1wicmlnaHRcIix0aGlzLmZyb250X2NhbWVyYS5uYW1lPWUrXCJmcm9udFwiLHRoaXMuYmFja19jYW1lcmEubmFtZT1lK1wiYmFja1wifWluaXRDdWJlQ2FtZXJhKGUsdCxyPTkwLHM9ITEpe3RoaXMudXBfY2FtZXJhPU5lLmNyZWF0ZUNhbWVyYTNET2JqZWN0KHRoaXMsXCJ1cFwiKSx0aGlzLmRvd25fY2FtZXJhPU5lLmNyZWF0ZUNhbWVyYTNET2JqZWN0KHRoaXMsXCJkb3duXCIpLHRoaXMubGVmdF9jYW1lcmE9TmUuY3JlYXRlQ2FtZXJhM0RPYmplY3QodGhpcyxcImxlZnRcIiksdGhpcy5yaWdodF9jYW1lcmE9TmUuY3JlYXRlQ2FtZXJhM0RPYmplY3QodGhpcyxcInJpZ2h0XCIpLHRoaXMuZnJvbnRfY2FtZXJhPU5lLmNyZWF0ZUNhbWVyYTNET2JqZWN0KHRoaXMsXCJmcm9udFwiKSx0aGlzLmJhY2tfY2FtZXJhPU5lLmNyZWF0ZUNhbWVyYTNET2JqZWN0KHRoaXMsXCJiYWNrXCIpLHRoaXMudXBfY2FtZXJhLmlzU2hhZG93Q2FtZXJhPXMsdGhpcy5kb3duX2NhbWVyYS5pc1NoYWRvd0NhbWVyYT1zLHRoaXMubGVmdF9jYW1lcmEuaXNTaGFkb3dDYW1lcmE9cyx0aGlzLnJpZ2h0X2NhbWVyYS5pc1NoYWRvd0NhbWVyYT1zLHRoaXMuZnJvbnRfY2FtZXJhLmlzU2hhZG93Q2FtZXJhPXMsdGhpcy5iYWNrX2NhbWVyYS5pc1NoYWRvd0NhbWVyYT1zO2xldCBhPTE7dGhpcy51cF9jYW1lcmEucGVyc3BlY3RpdmUocixhLGUsdCksdGhpcy51cF9jYW1lcmEubG9va0F0KGcuWkVSTyxnLlVQLGcuRE9XTiksdGhpcy51cF9jYW1lcmEub2JqZWN0M0Quc2NhbGVYPS0xLHRoaXMudXBfY2FtZXJhLm9iamVjdDNELnJvdGF0aW9uWT0xODAsdGhpcy5kb3duX2NhbWVyYS5wZXJzcGVjdGl2ZShyLGEsZSx0KSx0aGlzLmRvd25fY2FtZXJhLmxvb2tBdChnLlpFUk8sZy5ET1dOLGcuRE9XTiksdGhpcy5kb3duX2NhbWVyYS5vYmplY3QzRC5zY2FsZVg9LTEsdGhpcy5kb3duX2NhbWVyYS5vYmplY3QzRC5yb3RhdGlvblk9MTgwLHRoaXMubGVmdF9jYW1lcmEucGVyc3BlY3RpdmUocixhLGUsdCksdGhpcy5sZWZ0X2NhbWVyYS5sb29rQXQoZy5aRVJPLGcuTEVGVCksdGhpcy5sZWZ0X2NhbWVyYS5vYmplY3QzRC5zY2FsZVg9LTEsdGhpcy5yaWdodF9jYW1lcmEucGVyc3BlY3RpdmUocixhLGUsdCksdGhpcy5yaWdodF9jYW1lcmEubG9va0F0KGcuWkVSTyxnLlJJR0hUKSx0aGlzLnJpZ2h0X2NhbWVyYS5vYmplY3QzRC5zY2FsZVg9LTEsdGhpcy5mcm9udF9jYW1lcmEucGVyc3BlY3RpdmUocixhLGUsdCksdGhpcy5mcm9udF9jYW1lcmEubG9va0F0KGcuWkVSTyxnLkZPUldBUkQpLHRoaXMuZnJvbnRfY2FtZXJhLm9iamVjdDNELnNjYWxlWD0tMSx0aGlzLmJhY2tfY2FtZXJhLnBlcnNwZWN0aXZlKHIsYSxlLHQpLHRoaXMuYmFja19jYW1lcmEubG9va0F0KGcuWkVSTyxnLkJBQ0spLHRoaXMuYmFja19jYW1lcmEub2JqZWN0M0Quc2NhbGVYPS0xLHRoaXMudXBfY2FtZXJhLnR5cGU9SWUuc2hhZG93LHRoaXMuZG93bl9jYW1lcmEudHlwZT1JZS5zaGFkb3csdGhpcy5sZWZ0X2NhbWVyYS50eXBlPUllLnNoYWRvdyx0aGlzLnJpZ2h0X2NhbWVyYS50eXBlPUllLnNoYWRvdyx0aGlzLmZyb250X2NhbWVyYS50eXBlPUllLnNoYWRvdyx0aGlzLmJhY2tfY2FtZXJhLnR5cGU9SWUuc2hhZG93fX1jbGFzcyBTaCBleHRlbmRzIGF0e2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcihlLHQsciksdGhpcy5mb3JtYXQ9Ry5kZXB0aDMyZmxvYXQsdGhpcy5taXBtYXBDb3VudD0xLHRoaXMuaW5pdCgpfWludGVybmFsQ3JlYXRlQmluZGluZ0xheW91dERlc2MoKXt0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnNhbXBsZVR5cGU9XCJkZXB0aFwiLHRoaXMudGV4dHVyZUJpbmRpbmdMYXlvdXQudmlld0RpbWVuc2lvbj1cImN1YmUtYXJyYXlcIix0aGlzLnNhbXBsZXJCaW5kaW5nTGF5b3V0LnR5cGU9XCJmaWx0ZXJpbmdcIix0aGlzLnNhbXBsZXJfY29tcGFyaXNvbkJpbmRpbmdMYXlvdXQudHlwZT1cImNvbXBhcmlzb25cIn1pbnRlcm5hbENyZWF0ZVRleHR1cmUoKXt0aGlzLnRleHR1cmVEZXNjcmlwdG9yPXtmb3JtYXQ6dGhpcy5mb3JtYXQsc2l6ZTp7d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHQsZGVwdGhPckFycmF5TGF5ZXJzOjYqdGhpcy5udW1iZXJMYXllcn0sZGltZW5zaW9uOlwiMmRcIix1c2FnZTpHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElOR30sdGhpcy5ncHVUZXh0dXJlPVMuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGhpcy50ZXh0dXJlRGVzY3JpcHRvcil9aW50ZXJuYWxDcmVhdGVWaWV3KCl7dGhpcy52aWV3RGVzY3JpcHRvcj17ZGltZW5zaW9uOlwiY3ViZS1hcnJheVwifSx0aGlzLnZpZXc9dGhpcy5ncHVUZXh0dXJlLmNyZWF0ZVZpZXcodGhpcy52aWV3RGVzY3JpcHRvcil9aW50ZXJuYWxDcmVhdGVTYW1wbGVyKCl7dGhpcy5ncHVTYW1wbGVyPVMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe21pbkZpbHRlcjpOci5saW5lYXIsbWFnRmlsdGVyOk5yLmxpbmVhcn0pLHRoaXMuZ3B1U2FtcGxlcl9jb21wYXJpc29uPVMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe2NvbXBhcmU6XCJsZXNzXCIsbGFiZWw6XCJzYW1wbGVyX2NvbXBhcmlzb25cIn0pfX1jbGFzcyBJaCBleHRlbmRzIGRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJzaGFkb3dQYXNzQ291bnRcIiksbyh0aGlzLFwiX2ZvcmNlVXBkYXRlXCIsITEpLG8odGhpcyxcIl9zaGFkb3dDYW1lcmFEaWNcIiksbyh0aGlzLFwic2hhZG93Q2FtZXJhXCIpLG8odGhpcyxcImN1YmVBcnJheVRleHR1cmVcIiksbyh0aGlzLFwiY29sb3JUZXh0dXJlXCIpLG8odGhpcyxcInNoYWRvd1NpemVcIiwxMDI0KSx0aGlzLnBhc3NUeXBlPXJlLlBPSU5UX1NIQURPVyx0aGlzLl9zaGFkb3dDYW1lcmFEaWM9bmV3IE1hcCx0aGlzLmN1YmVBcnJheVRleHR1cmU9bmV3IFNoKHRoaXMuc2hhZG93U2l6ZSx0aGlzLnNoYWRvd1NpemUsOCksdGhpcy5jb2xvclRleHR1cmU9bmV3IG9lKHRoaXMuc2hhZG93U2l6ZSx0aGlzLnNoYWRvd1NpemUsRy5iZ3JhOHVub3JtLCExKSxzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKHRoaXMuY3ViZUFycmF5VGV4dHVyZSx0aGlzKX1nZXRTaGFkb3dDYW1lcmEoZSx0KXtsZXQgcjtpZih0aGlzLl9zaGFkb3dDYW1lcmFEaWMuaGFzKHQpKXI9dGhpcy5fc2hhZG93Q2FtZXJhRGljLmdldCh0KTtlbHNle2xldCBzPW5ldyBiaChlLmNhbWVyYS5uZWFyLGUuY2FtZXJhLmZhciw5MCwhMCk7cy5sYWJlbD10Lm5hbWU7bGV0IGE9W10sbj1bXTtmb3IobGV0IGw9MDtsPDY7bCsrKXtsZXQgaD1uZXcgb2UodGhpcy5zaGFkb3dTaXplLHRoaXMuc2hhZG93U2l6ZSx0aGlzLmN1YmVBcnJheVRleHR1cmUuZm9ybWF0LCExKSx1PW5ldyBaZShbdGhpcy5jb2xvclRleHR1cmVdLFtuZXcgQ2VdKTtoLm5hbWU9XCJzaGFkb3dEZXB0aFRleHR1cmVfXCIrdC5uYW1lK2wrXCJfZmFjZVwiLHUuZGVwdGhUZXh0dXJlPWgsdS5sYWJlbD1cInNoYWRvd1JlbmRlclwiLHUuY3VzdG9tU2l6ZT0hMDtsZXQgYz1IZS5jcmVhdGVSZW5kZXJlclBhc3NTdGF0ZSh1KTtuW2xdPWMsYVtsXT1oLEEuZ2V0UmVuZGVySm9iKGUpLnBvc3RSZW5kZXJlci5zZXREZWJ1Z1RleHR1cmUoW2hdKSxBLmdldFJlbmRlckpvYihlKS5kZWJ1ZygpfXI9e2N1YmVDYW1lcmE6cyxkZXB0aFRleHR1cmU6YSxyZW5kZXJlclBhc3NTdGF0ZTpufSx0aGlzLl9zaGFkb3dDYW1lcmFEaWMuc2V0KHQscil9cmV0dXJuIHJ9cmVuZGVyKGUsdCl7aWYoIUEuc2V0dGluZy5zaGFkb3cuZW5hYmxlKXJldHVybjt0aGlzLnNoYWRvd1Bhc3NDb3VudD0wLGUuY2FtZXJhO2xldCByPWUuc2NlbmUscz1WZS5nZXRQb2ludFNoYWRvd0xpZ2h0V2hpY2hTY2VuZShyKSxhPXMubGVuZ3RoO2ZvcihsZXQgbj0wO248YTtuKyspe2xldCBsPXNbbl07aWYobC5saWdodERhdGEubGlnaHRUeXBlIT1RZS5EaXJlY3Rpb25MaWdodCYmbC5saWdodERhdGEuY2FzdFNoYWRvd0luZGV4Pi0xJiYobC5uZWVkVXBkYXRlU2hhZG93fHx0aGlzLl9mb3JjZVVwZGF0ZXx8aGUuZnJhbWU8NXx8bC5yZWFsVGltZVNoYWRvdykpe2wubmVlZFVwZGF0ZVNoYWRvdz0hMTtsZXQgaD10aGlzLmdldFNoYWRvd0NhbWVyYShlLGwpLHU9bC50cmFuc2Zvcm0ud29ybGRQb3NpdGlvbjtoLmN1YmVDYW1lcmEueD11LngsaC5jdWJlQ2FtZXJhLnk9dS55LGguY3ViZUNhbWVyYS56PXUuejtsZXQgYztoLmN1YmVDYW1lcmEudHJhbnNmb3JtLnVwZGF0ZVdvcmxkTWF0cml4KCEwKSx0LnVwZGF0ZShoLmN1YmVDYW1lcmEucmlnaHRfY2FtZXJhLHIpLGM9US5pbnN0YW5jZS5nZXRSZW5kZXJOb2RlcyhyLGguY3ViZUNhbWVyYS5yaWdodF9jYW1lcmEpLHRoaXMucmVuZGVyU2NlbmVPbmNlKDAsaCxlLGguY3ViZUNhbWVyYS5yaWdodF9jYW1lcmEsYyx0KSx0LnVwZGF0ZShoLmN1YmVDYW1lcmEubGVmdF9jYW1lcmEsciksYz1RLmluc3RhbmNlLmdldFJlbmRlck5vZGVzKHIsaC5jdWJlQ2FtZXJhLmxlZnRfY2FtZXJhKSx0aGlzLnJlbmRlclNjZW5lT25jZSgxLGgsZSxoLmN1YmVDYW1lcmEubGVmdF9jYW1lcmEsYyx0KSx0LnVwZGF0ZShoLmN1YmVDYW1lcmEudXBfY2FtZXJhLHIpLGM9US5pbnN0YW5jZS5nZXRSZW5kZXJOb2RlcyhyLGguY3ViZUNhbWVyYS51cF9jYW1lcmEpLHRoaXMucmVuZGVyU2NlbmVPbmNlKDIsaCxlLGguY3ViZUNhbWVyYS51cF9jYW1lcmEsYyx0KSx0LnVwZGF0ZShoLmN1YmVDYW1lcmEuZG93bl9jYW1lcmEsciksYz1RLmluc3RhbmNlLmdldFJlbmRlck5vZGVzKHIsaC5jdWJlQ2FtZXJhLmRvd25fY2FtZXJhKSx0aGlzLnJlbmRlclNjZW5lT25jZSgzLGgsZSxoLmN1YmVDYW1lcmEuZG93bl9jYW1lcmEsYyx0KSx0LnVwZGF0ZShoLmN1YmVDYW1lcmEuZnJvbnRfY2FtZXJhLHIpLGM9US5pbnN0YW5jZS5nZXRSZW5kZXJOb2RlcyhyLGguY3ViZUNhbWVyYS5mcm9udF9jYW1lcmEpLHRoaXMucmVuZGVyU2NlbmVPbmNlKDQsaCxlLGguY3ViZUNhbWVyYS5mcm9udF9jYW1lcmEsYyx0KSx0LnVwZGF0ZShoLmN1YmVDYW1lcmEuYmFja19jYW1lcmEsciksYz1RLmluc3RhbmNlLmdldFJlbmRlck5vZGVzKHIsaC5jdWJlQ2FtZXJhLmJhY2tfY2FtZXJhKSx0aGlzLnJlbmRlclNjZW5lT25jZSg1LGgsZSxoLmN1YmVDYW1lcmEuYmFja19jYW1lcmEsYyx0KTtsZXQgZj13LmJlZ2luQ29tbWFuZEVuY29kZXIoKTtmb3IobGV0IGQ9MDtkPDY7ZCsrKWYuY29weVRleHR1cmVUb1RleHR1cmUoe3RleHR1cmU6aC5kZXB0aFRleHR1cmVbZF0uZ2V0R1BVVGV4dHVyZSgpLG1pcExldmVsOjAsb3JpZ2luOnt4OjAseTowLHo6MH19LHt0ZXh0dXJlOnRoaXMuY3ViZUFycmF5VGV4dHVyZS5nZXRHUFVUZXh0dXJlKCksbWlwTGV2ZWw6MCxvcmlnaW46e3g6MCx5OjAsejpsLnNoYWRvd0luZGV4KjYrZH19LHt3aWR0aDp0aGlzLnNoYWRvd1NpemUsaGVpZ2h0OnRoaXMuc2hhZG93U2l6ZSxkZXB0aE9yQXJyYXlMYXllcnM6MX0pO3cuZW5kQ29tbWFuZEVuY29kZXIoZil9fXRoaXMuX2ZvcmNlVXBkYXRlPSExfXJlbmRlclNjZW5lT25jZShlLHQscixzLGEsbil7dGhpcy5yZW5kZXJlclBhc3NTdGF0ZT10LnJlbmRlcmVyUGFzc1N0YXRlW2VdO2xldCBsPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLGg9dy5iZWdpblJlbmRlclBhc3MobCx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlKTtoLnNldFZpZXdwb3J0KDAsMCx0aGlzLnNoYWRvd1NpemUsdGhpcy5zaGFkb3dTaXplLDAsMSksaC5zZXRTY2lzc29yUmVjdCgwLDAsdGhpcy5zaGFkb3dTaXplLHRoaXMuc2hhZG93U2l6ZSkscy5vblVwZGF0ZSgpLHMudHJhbnNmb3JtLnVwZGF0ZVdvcmxkTWF0cml4KCEwKTtsZXQgdT1RLmluc3RhbmNlLmdldFJlbmRlclNoYWRlckNvbGxlY3Qocik7Zm9yKGNvbnN0IGMgb2YgdSl7bGV0IGY9Y1sxXTtmb3IoY29uc3QgZCBvZiBmKXtsZXQgcD1kWzFdO2lmKHAucHJlSW5pdCl7cC5ub2RlVXBkYXRlKHIsdGhpcy5fcmVuZGVyZXJUeXBlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUsbnVsbCk7YnJlYWt9fX10aGlzLmRyYXdTaGFkb3dSZW5kZXJOb2RlcyhyLHMsaCxhLm9wYXF1ZUxpc3QsbiksdGhpcy5kcmF3U2hhZG93UmVuZGVyTm9kZXMocixzLGgsYS50cmFuc3BhcmVudExpc3Qsbiksdy5lbmRQYXNzKGgpLHcuZW5kQ29tbWFuZEVuY29kZXIobCl9ZHJhd1NoYWRvd1JlbmRlck5vZGVzKGUsdCxyLHMsYSl7aWYody5iaW5kQ2FtZXJhKHIsdCkscylmb3IobGV0IG49QS5zZXR0aW5nLnJlbmRlci5kcmF3T3BNaW47bjxNYXRoLm1pbihzLmxlbmd0aCxBLnNldHRpbmcucmVuZGVyLmRyYXdPcE1heCk7KytuKXtsZXQgbD1zW25dO2lmKGwudHJhbnNmb3JtLndvcmxkTWF0cml4LmluZGV4LCEhbC50cmFuc2Zvcm0uZW5hYmxlJiZsLmVuYWJsZSl7bC5wcmVJbml0fHxsLm5vZGVVcGRhdGUoZSx0aGlzLl9yZW5kZXJlclR5cGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSk7Zm9yKGxldCBoIG9mIGwubWF0ZXJpYWxzKXtsZXQgdT1oLmdldFBhc3ModGhpcy5fcmVuZGVyZXJUeXBlKTtpZighdXx8dS5sZW5ndGg9PTApY29udGludWU7dy5iaW5kR2VvbWV0cnlCdWZmZXIocixsLmdlb21ldHJ5KTtsZXQgYz1sLm9iamVjdDNELnRyYW5zZm9ybS5fd29ybGRNYXRyaXg7Zm9yKGxldCBmIG9mIHUpe2NvbnN0IGQ9ZjtpZihkLnBpcGVsaW5lKXtkLnNldFVuaWZvcm1GbG9hdChcImNhbWVyYUZhclwiLHQuZmFyKSxkLnNldFVuaWZvcm1WZWN0b3IzKFwibGlnaHRXb3JsZFBvc1wiLHQudHJhbnNmb3JtLndvcmxkUG9zaXRpb24pLGQubWF0ZXJpYWxEYXRhVW5pZm9ybUJ1ZmZlci5hcHBseSgpLHcuYmluZFBpcGVsaW5lKHIsZCk7bGV0IHA9bC5nZW9tZXRyeS5zdWJHZW9tZXRyaWVzO2Zvcihjb25zdCBtIG9mIHApe2xldCB2PW0ubG9kTGV2ZWxzW2wubG9kTGV2ZWxdO3cuZHJhd0luZGV4ZWQocix2LmluZGV4Q291bnQsMSx2LmluZGV4U3RhcnQsMCxjLmluZGV4KX19fX19fX19Y2xhc3MgRWggZXh0ZW5kcyBhdHtjb25zdHJ1Y3RvcihlLHQscj1HLmRlcHRoMzJmbG9hdCxzPTQpe3N1cGVyKGUsdCxzKSx0aGlzLmZvcm1hdD1yLHRoaXMubWlwbWFwQ291bnQ9MSx0aGlzLmluaXQoKX1pbnRlcm5hbENyZWF0ZUJpbmRpbmdMYXlvdXREZXNjKCl7dGhpcy50ZXh0dXJlQmluZGluZ0xheW91dC5zYW1wbGVUeXBlPVwiZGVwdGhcIix0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnZpZXdEaW1lbnNpb249XCIyZC1hcnJheVwiLHRoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cImZpbHRlcmluZ1wiLHRoaXMuc2FtcGxlcl9jb21wYXJpc29uQmluZGluZ0xheW91dC50eXBlPVwiY29tcGFyaXNvblwifWludGVybmFsQ3JlYXRlVGV4dHVyZSgpe3RoaXMudGV4dHVyZURlc2NyaXB0b3I9e2Zvcm1hdDp0aGlzLmZvcm1hdCxzaXplOnt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodCxkZXB0aE9yQXJyYXlMYXllcnM6dGhpcy5udW1iZXJMYXllcn0sZGltZW5zaW9uOlwiMmRcIix1c2FnZTpHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElOR30sdGhpcy5ncHVUZXh0dXJlPVMuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGhpcy50ZXh0dXJlRGVzY3JpcHRvcil9aW50ZXJuYWxDcmVhdGVWaWV3KCl7dGhpcy52aWV3RGVzY3JpcHRvcj17ZGltZW5zaW9uOlwiMmQtYXJyYXlcIn0sdGhpcy52aWV3PXRoaXMuZ3B1VGV4dHVyZS5jcmVhdGVWaWV3KHRoaXMudmlld0Rlc2NyaXB0b3IpfWludGVybmFsQ3JlYXRlU2FtcGxlcigpe3RoaXMuZ3B1U2FtcGxlcj1TLmRldmljZS5jcmVhdGVTYW1wbGVyKHt9KSx0aGlzLmdwdVNhbXBsZXJfY29tcGFyaXNvbj1TLmRldmljZS5jcmVhdGVTYW1wbGVyKHtjb21wYXJlOlwibGVzc1wiLGxhYmVsOlwic2FtcGxlcl9jb21wYXJpc29uXCJ9KX19Y2xhc3MgQmggZXh0ZW5kcyBkaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwic2hhZG93UGFzc0NvdW50XCIpLG8odGhpcyxcImRlcHRoMkRBcnJheVRleHR1cmVcIiksbyh0aGlzLFwicmVuZGVyZXJQYXNzU3RhdGVzXCIpLG8odGhpcyxcIl9mb3JjZVVwZGF0ZVwiLCExKSxvKHRoaXMsXCJfc2hhZG93UG9zXCIsbmV3IGcpLG8odGhpcyxcIl9zaGFkb3dDYW1lcmFUYXJnZXRcIixuZXcgZyksdGhpcy5zZXRTaGFkb3dNYXAoQS5zZXR0aW5nLnNoYWRvdy5zaGFkb3dTaXplLGx0LkNhc2NhZGVzKSx0aGlzLnBhc3NUeXBlPXJlLlNIQURPV31zZXRTaGFkb3dNYXAoZSx0KXt0aGlzLnJlbmRlcmVyUGFzc1N0YXRlcz1bXSx0aGlzLmRlcHRoMkRBcnJheVRleHR1cmU9bmV3IEVoKGUsZSxHLmRlcHRoMzJmbG9hdCw4KSxzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKHRoaXMuZGVwdGgyREFycmF5VGV4dHVyZSx0aGlzKTtmb3IobGV0IHI9MDtyPDg7cisrKXtsZXQgcz1uZXcgWmUoW10sW10pO2NvbnN0IGE9bmV3IG9lKGUsZSxHLmRlcHRoMzJmbG9hdCwhMSk7YS5uYW1lPWBzaGFkb3dEZXB0aFRleHR1cmVfJHtyfWAscy5kZXB0aFRleHR1cmU9YSxzLmxhYmVsPVwic2hhZG93UmVuZGVyXCIscy5jdXN0b21TaXplPSEwLHMuZGVwdGhDbGVhblZhbHVlPTE7bGV0IG49SGUuY3JlYXRlUmVuZGVyZXJQYXNzU3RhdGUocyk7dGhpcy5yZW5kZXJlclBhc3NTdGF0ZXNbcl09bn19cmVuZGVyKGUsdCl7bGV0IHI9QS5zZXR0aW5nLnNoYWRvdztpZighci5lbmFibGUpcmV0dXJuO2xldCBzPWUuY2FtZXJhLGE9ZS5zY2VuZTtpZih0aGlzLnNoYWRvd1Bhc3NDb3VudD0wLCFyLm5lZWRVcGRhdGV8fGhlLmZyYW1lJXIudXBkYXRlRnJhbWVSYXRlIT0wKXJldHVybjtsZXQgbj1WZS5nZXREaXJlY3RTaGFkb3dMaWdodFdoaWNoU2NlbmUoYSksbD1yLnNoYWRvd1NpemU7Y29uc3QgaD1sdC5DYXNjYWRlcztmb3IobGV0IHUgb2Ygbil7Y29uc3QgYz11O2xldCBmPWMuc2hhZG93SW5kZXg7dGhpcy5yZW5kZXJlclBhc3NTdGF0ZT10aGlzLnJlbmRlcmVyUGFzc1N0YXRlc1tmXTtsZXQgZD1RLmluc3RhbmNlLmdldFJlbmRlclNoYWRlckNvbGxlY3QoZSk7Zm9yKGNvbnN0IHAgb2YgZCl7bGV0IG09cFsxXTtmb3IoY29uc3QgXyBvZiBtKXtsZXQgdj1fWzFdO2lmKHYucHJlSW5pdCl7di5ub2RlVXBkYXRlKGUsdGhpcy5fcmVuZGVyZXJUeXBlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUsbnVsbCk7YnJlYWt9fX1pZihjLmNhc3RTaGFkb3cmJmMubmVlZFVwZGF0ZVNoYWRvd3x8dGhpcy5fZm9yY2VVcGRhdGV8fGMuY2FzdFNoYWRvdyYmci5hdXRvVXBkYXRlKWlmKGMubmVlZFVwZGF0ZVNoYWRvdz0hMSxzLmVuYWJsZUNTTSYmZj09MClmb3IobGV0IHA9MDtwPGg7cCsrKXt0aGlzLnJlbmRlcmVyUGFzc1N0YXRlPXRoaXMucmVuZGVyZXJQYXNzU3RhdGVzW3BdO2xldCBtPXMuY3NtLmNoaWxkcmVuW3BdLF89cy5nZXRDU01TaGFkb3dXb3JsZEV4dGVudHMocCk7dGhpcy5wb3NlU2hhZG93Q2FtZXJhKHMsYy5kaXJlY3Rpb24sbS5zaGFkb3dDYW1lcmEsXyxtLmJvdW5kLmNlbnRlciksdGhpcy5yZW5kZXJTaGFkb3coZSxtLnNoYWRvd0NhbWVyYSx0LHRoaXMucmVuZGVyZXJQYXNzU3RhdGUpLHRoaXMuY29weURlcHRoVGV4dHVyZSh0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLmRlcHRoVGV4dHVyZSx0aGlzLmRlcHRoMkRBcnJheVRleHR1cmUscCxsKX1lbHNle3MuZW5hYmxlQ1NNJiYoZis9aC0xKTtsZXQgcD1zLmdldFNoYWRvd1dvcmxkRXh0ZW50cygpO3RoaXMucmVuZGVyZXJQYXNzU3RhdGU9dGhpcy5yZW5kZXJlclBhc3NTdGF0ZXNbZl0sdGhpcy5wb3NlU2hhZG93Q2FtZXJhKHMsYy5kaXJlY3Rpb24sYy5zaGFkb3dDYW1lcmEscCxzLmxvb2tUYXJnZXQpLHRoaXMucmVuZGVyU2hhZG93KGUsYy5zaGFkb3dDYW1lcmEsdCx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlKSx0aGlzLmNvcHlEZXB0aFRleHR1cmUodGhpcy5yZW5kZXJlclBhc3NTdGF0ZS5kZXB0aFRleHR1cmUsdGhpcy5kZXB0aDJEQXJyYXlUZXh0dXJlLGYsbCl9fXRoaXMuX2ZvcmNlVXBkYXRlPSExfWNvcHlEZXB0aFRleHR1cmUoZSx0LHIscyl7bGV0IGE9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCk7YS5jb3B5VGV4dHVyZVRvVGV4dHVyZSh7dGV4dHVyZTplLmdldEdQVVRleHR1cmUoKSxtaXBMZXZlbDowLG9yaWdpbjp7eDowLHk6MCx6OjB9fSx7dGV4dHVyZTp0LmdldEdQVVRleHR1cmUoKSxtaXBMZXZlbDowLG9yaWdpbjp7eDowLHk6MCx6OnJ9fSx7d2lkdGg6cyxoZWlnaHQ6cyxkZXB0aE9yQXJyYXlMYXllcnM6MX0pLHcuZW5kQ29tbWFuZEVuY29kZXIoYSl9cG9zZVNoYWRvd0NhbWVyYShlLHQscixzLGEpe3RoaXMuX3NoYWRvd1Bvcy5jb3B5KHQpLm5vcm1hbGl6ZShlLmZhciksYS5hZGQodGhpcy5fc2hhZG93UG9zLHRoaXMuX3NoYWRvd0NhbWVyYVRhcmdldCksYS5zdWJ0cmFjdCh0aGlzLl9zaGFkb3dQb3MsdGhpcy5fc2hhZG93UG9zKSxyLnRyYW5zZm9ybS5sb29rQXQodGhpcy5fc2hhZG93UG9zLHRoaXMuX3NoYWRvd0NhbWVyYVRhcmdldCksci5vcnRob09mZkNlbnRlcigtcyxzLC1zLHMsZS5uZWFyLGUuZmFyKjIpfWNvbXB1dGUoKXt9cmVuZGVyU2hhZG93KGUsdCxyLHMpe2xldCBhPVEuaW5zdGFuY2UuZ2V0UmVuZGVyTm9kZXMoZS5zY2VuZSx0KSxuPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLGw9dy5iZWdpblJlbmRlclBhc3MobixzKTt0LnRyYW5zZm9ybS51cGRhdGVXb3JsZE1hdHJpeCgpLGtzLmVuYWJsZSYmKHIudXBkYXRlKHQsZS5zY2VuZSksci5jb2xsZWN0KGEsdCkpLHcuYmluZENhbWVyYShsLHQpO2xldCBoPXRoaXMucmVuZGVyU2hhZG93QnVuZGxlT3AoZSx0LHMpLHU9dGhpcy5yZW5kZXJTaGFkb3dCdW5kbGVUcihlLHQscyk7aC5sZW5ndGg+MCYmbC5leGVjdXRlQnVuZGxlcyhoKSx0aGlzLmRyYXdTaGFkb3dSZW5kZXJOb2RlcyhlLHQsbCxhLm9wYXF1ZUxpc3QpLHUubGVuZ3RoPjAmJmwuZXhlY3V0ZUJ1bmRsZXModSksdGhpcy5kcmF3U2hhZG93UmVuZGVyTm9kZXMoZSx0LGwsYS50cmFuc3BhcmVudExpc3QpLHcuZW5kUGFzcyhsKSx3LmVuZENvbW1hbmRFbmNvZGVyKG4pfXJlbmRlclNoYWRvd0J1bmRsZU9wKGUsdCxyKXtsZXQgcz1RLmluc3RhbmNlLmdldE9wUmVuZGVyR3JvdXAoZS5zY2VuZSk7aWYocyl7bGV0IGE9W107cmV0dXJuIHMucmVuZGVyR3JvdXAuZm9yRWFjaChuPT57aWYobi5idW5kbGVNYXAuaGFzKHRoaXMuX3JlbmRlcmVyVHlwZSkpYS5wdXNoKG4uYnVuZGxlTWFwLmdldCh0aGlzLl9yZW5kZXJlclR5cGUpKTtlbHNle2xldCBsPXcucmVjb3JkQnVuZGxlRW5jb2RlcihyLnJlbmRlckJ1bmRsZUVuY29kZXJEZXNjcmlwdG9yKTt0aGlzLnJlY29yZFNoYWRvd1JlbmRlckJ1bmRsZU5vZGUoZSx0LGwsbi5yZW5kZXJOb2Rlcyk7bGV0IGg9bC5maW5pc2goKTtuLmJ1bmRsZU1hcC5zZXQodGhpcy5fcmVuZGVyZXJUeXBlLGgpLGEucHVzaChoKX19KSxhfXJldHVybltdfXJlbmRlclNoYWRvd0J1bmRsZVRyKGUsdCxyKXtsZXQgcz1RLmluc3RhbmNlLmdldFRyUmVuZGVyR3JvdXAoZS5zY2VuZSk7aWYocyl7bGV0IGE9W107cmV0dXJuIHMucmVuZGVyR3JvdXAuZm9yRWFjaChuPT57aWYobi5idW5kbGVNYXAuaGFzKHRoaXMuX3JlbmRlcmVyVHlwZSkpYS5wdXNoKG4uYnVuZGxlTWFwLmdldCh0aGlzLl9yZW5kZXJlclR5cGUpKTtlbHNle2xldCBsPXcucmVjb3JkQnVuZGxlRW5jb2RlcihyLnJlbmRlckJ1bmRsZUVuY29kZXJEZXNjcmlwdG9yKTt0aGlzLnJlY29yZFNoYWRvd1JlbmRlckJ1bmRsZU5vZGUoZSx0LGwsbi5yZW5kZXJOb2Rlcyk7bGV0IGg9bC5maW5pc2goKTtuLmJ1bmRsZU1hcC5zZXQodGhpcy5fcmVuZGVyZXJUeXBlLGgpLGEucHVzaChoKX19KSxhfXJldHVybltdfXJlY29yZFNoYWRvd1JlbmRlckJ1bmRsZU5vZGUoZSx0LHIscyxhKXtpZih3LmJpbmRDYW1lcmEocix0KSxzKXt3LmJpbmRHZW9tZXRyeUJ1ZmZlcihyLHNbMF0uZ2VvbWV0cnkpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7KytuKXtsZXQgbD1zW25dO2wudHJhbnNmb3JtLmVuYWJsZSYmbC5yZWNvcmRSZW5kZXJQYXNzMihlLHRoaXMuX3JlbmRlcmVyVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLGEscil9fX1kcmF3U2hhZG93UmVuZGVyTm9kZXMoZSx0LHIscyxhKXtpZih3LmJpbmRDYW1lcmEocix0KSxzKWZvcihsZXQgbj1BLnNldHRpbmcucmVuZGVyLmRyYXdPcE1pbjtuPE1hdGgubWluKHMubGVuZ3RoLEEuc2V0dGluZy5yZW5kZXIuZHJhd09wTWF4KTsrK24pe2xldCBsPXNbbl07bC50cmFuc2Zvcm0uZW5hYmxlJiZsLmVuYWJsZSYmbC5yZW5kZXJQYXNzMihlLHRoaXMuX3JlbmRlcmVyVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLGEscil9fX1jbGFzcyBUaCBleHRlbmRzIGRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJ6QnVmZmVyVGV4dHVyZVwiKSxvKHRoaXMsXCJ1c2VSZW5kZXJCdW5kbGVcIiwhMSksbyh0aGlzLFwic2hhZG93UGFzc0NvdW50XCIpLG8odGhpcyxcInpDdWxsaW5nQ29tcHV0ZVwiKSx0aGlzLnBhc3NUeXBlPXJlLkRFUFRIO2xldCBlPVMucHJlc2VudGF0aW9uU2l6ZSx0PTE7dGhpcy56QnVmZmVyVGV4dHVyZT1GZS5jcmVhdGVSVFRleHR1cmUoQWUuekJ1ZmZlclRleHR1cmVfTkFNRSxNYXRoLmZsb29yKGVbMF0qdCksTWF0aC5mbG9vcihlWzFdKnQpLEcucmdiYTE2ZmxvYXQsITEpO2xldCByPW5ldyBDZTtyLmNsZWFyVmFsdWU9WzAsMCwwLDBdLHIubG9hZE9wPVwiY2xlYXJcIjtsZXQgcz1uZXcgWmUoW10sW10sRmUuY3JlYXRlUlRUZXh0dXJlKEFlLnpQcmVEZXB0aFRleHR1cmVfTkFNRSxNYXRoLmZsb29yKGVbMF0pLE1hdGguZmxvb3IoZVsxXSksRy5kZXB0aDMyZmxvYXQsITEpLG51bGwsITEpO3RoaXMuc2V0UmVuZGVyU3RhdGVzKHMpfXJlbmRlcihlLHQpe2xldCByPWUuY2FtZXJhLHM9ZS5zY2VuZTt3LmNsZWFuQ2FjaGUoKSxmdC5zdGFydChcIkRlcHRoUGFzcyBSZW5kZXJlclwiKTtsZXQgYT1zO3RoaXMucmVuZGVyZXJQYXNzU3RhdGUuY2FtZXJhM0Q9cjtsZXQgbj1RLmluc3RhbmNlLmdldFJlbmRlck5vZGVzKGEscik7dGhpcy5jb21wdXRlKGUsdCk7bGV0IGw9dGhpcy5yZW5kZXJCdW5kbGVPcChlLG4sdCksaD1bXSx1PXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLGM9dy5iZWdpblJlbmRlclBhc3ModSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlKTtsLmxlbmd0aD4wJiZjLmV4ZWN1dGVCdW5kbGVzKGwpO2xldCBmPVEuaW5zdGFuY2UuZ2V0UmVuZGVyU2hhZGVyQ29sbGVjdChlKTtmb3IoY29uc3QgZCBvZiBmKXtsZXQgcD1kWzFdO2Zvcihjb25zdCBtIG9mIHApe2xldCBfPW1bMV07aWYoXy5wcmVJbml0KXtfLm5vZGVVcGRhdGUoZSx0aGlzLl9yZW5kZXJlclR5cGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSxudWxsKTticmVha319fXRoaXMuZHJhd1JlbmRlck5vZGVzKGUsYyx1LG4ub3BhcXVlTGlzdCx0KSxoLmxlbmd0aD4wJiZjLmV4ZWN1dGVCdW5kbGVzKGgpLHcuZW5kUGFzcyhjKSx3LmVuZENvbW1hbmRFbmNvZGVyKHUpLGZ0LmVuZChcIkRlcHRoUGFzcyBSZW5kZXJlclwiKX1kcmF3UmVuZGVyTm9kZXMoZSx0LHIscyxhLG4pe3cuYmluZENhbWVyYSh0LGUuY2FtZXJhKTtmb3IobGV0IGw9QS5zZXR0aW5nLnJlbmRlci5kcmF3T3BNaW47bDxNYXRoLm1pbihzLmxlbmd0aCxBLnNldHRpbmcucmVuZGVyLmRyYXdPcE1heCk7KytsKXtsZXQgaD1zW2xdO2gudHJhbnNmb3JtLmVuYWJsZSYmaC5lbmFibGUmJihoLnByZUluaXR8fGgubm9kZVVwZGF0ZShlLHRoaXMuX3JlbmRlcmVyVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlKSxoLnJlbmRlclBhc3MyKGUsdGhpcy5fcmVuZGVyZXJUeXBlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUsbix0KSl9fX1jbGFzcyBNaHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcIm1hcFwiKSxvKHRoaXMsXCJwYXNzUmVuZGVyZXJMaXN0XCIpLHRoaXMubWFwPW5ldyBNYXAsdGhpcy5wYXNzUmVuZGVyZXJMaXN0PVtdfWFkZFJlbmRlcmVyKGUpe3RoaXMubWFwLmhhcyhlLnBhc3NUeXBlKT9jb25zb2xlLmVycm9yKFwic2FtZSByZW5kZXJlciBwYXNzIHJlcGVhdCFcIik6KHRoaXMubWFwLnNldChlLnBhc3NUeXBlLGUpLGUucGFzc1R5cGU8PTgmJnRoaXMuYWRkUGFzc1JlbmRlcmVyKGUpKX1nZXRSZW5kZXJlcihlKXtyZXR1cm4gdGhpcy5tYXAuZ2V0KGUpfWFkZFBhc3NSZW5kZXJlcihlKXt0aGlzLnBhc3NSZW5kZXJlckxpc3QucHVzaChlKX1nZXRBbGxSZW5kZXJlcigpe3JldHVybiB0aGlzLm1hcH1nZXRBbGxQYXNzUmVuZGVyZXIoKXtyZXR1cm4gdGhpcy5wYXNzUmVuZGVyZXJMaXN0fX1jbGFzcyBEaCBleHRlbmRzIGRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJmaW5hbFF1YWRWaWV3XCIpLG8odGhpcyxcInBvc3RMaXN0XCIpLHRoaXMuX3JlbmRlcmVyVHlwZT1yZS5QT1NULHRoaXMucG9zdExpc3Q9W10sdGhpcy5pbml0UmVuZGVyZXIoKX1pbml0UmVuZGVyZXIoKXtOLnJlZ2lzdGVyKFwiRnVsbFF1YWRfdmVydF93Z3NsXCIsZWwpLHRoaXMuZmluYWxRdWFkVmlldz1uZXcgTnMoXCJRdWFkX3ZlcnRfd2dzbFwiLFwiUXVhZF9mcmFnX3dnc2xcIixuZXcgWmUoW10sW10pLG51bGwsbnVsbCwhMSl9YXR0YWNoUG9zdChlLHQpe3QucG9zdFJlbmRlcmVyPXRoaXMsdGhpcy5wb3N0TGlzdC5pbmRleE9mKHQpIT0tMXx8KHRoaXMucG9zdExpc3QucHVzaCh0KSx0Lm9uQXR0YWNoKGUpKX1kZXRhY2hQb3N0KGUsdCl7bGV0IHI9dGhpcy5wb3N0TGlzdC5pbmRleE9mKHQpO3JldHVybiByPj0wJiYodGhpcy5wb3N0TGlzdC5zcGxpY2UociwxKSx0Lm9uRGV0YWNoKGUpLHQucG9zdFJlbmRlcmVyPW51bGwpLHI+PTB9cmVuZGVyKGUpe2xldCB0PXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO2ZvcihsZXQgcz0wO3M8dGhpcy5wb3N0TGlzdC5sZW5ndGg7cysrKXtjb25zdCBhPXRoaXMucG9zdExpc3Rbc107YS5lbmFibGUmJmEucmVuZGVyKGUsdCl9bGV0IHI9dy5sYXN0UmVuZGVyUGFzc1N0YXRlLmdldExhc3RSZW5kZXJUZXh0dXJlKCk7aWYodGhpcy5maW5hbFF1YWRWaWV3LnJlbmRlclRvVmlld1F1YWQoZSx0aGlzLmZpbmFsUXVhZFZpZXcsdCxyKSx0aGlzLmRlYnVnVmlld1F1YWRzLmxlbmd0aCl7bGV0IHM9QS5zZXR0aW5nLnJlbmRlci5kZWJ1Z1F1YWQ7cz49MCYmdGhpcy5kZWJ1Z1ZpZXdRdWFkc1tzXS5yZW5kZXJUb1ZpZXdRdWFkKGUsdGhpcy5kZWJ1Z1ZpZXdRdWFkc1tzXSx0LHRoaXMuZGVidWdUZXh0dXJlc1tzXSl9dy5lbmRDb21tYW5kRW5jb2Rlcih0KX19Y2xhc3MgUGh7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwicmVuZGVyZXJNYXBcIiksbyh0aGlzLFwic2hhZG93TWFwUGFzc1JlbmRlcmVyXCIpLG8odGhpcyxcInBvaW50TGlnaHRTaGFkb3dSZW5kZXJlclwiKSxvKHRoaXMsXCJkZGdpUHJvYmVSZW5kZXJlclwiKSxvKHRoaXMsXCJwb3N0UmVuZGVyZXJcIiksbyh0aGlzLFwiY2x1c3RlckxpZ2h0aW5nUmVuZGVyXCIpLG8odGhpcyxcIm9jY2x1c2lvblN5c3RlbVwiKSxvKHRoaXMsXCJkZXB0aFBhc3NSZW5kZXJlclwiKSxvKHRoaXMsXCJjb2xvclBhc3NSZW5kZXJlclwiKSxvKHRoaXMsXCJwYXVzZVJlbmRlclwiLCExKSxvKHRoaXMsXCJwaWNrRmlyZVwiKSxvKHRoaXMsXCJfdmlld1wiKSx0aGlzLl92aWV3PWUsdGhpcy5yZW5kZXJlck1hcD1uZXcgTWgsdGhpcy5vY2NsdXNpb25TeXN0ZW09bmV3IGtzLHRoaXMuY2x1c3RlckxpZ2h0aW5nUmVuZGVyPXRoaXMuYWRkUmVuZGVyZXIod2gsZSksQS5zZXR0aW5nLnJlbmRlci56UHJlUGFzcyYmKHRoaXMuZGVwdGhQYXNzUmVuZGVyZXI9dGhpcy5hZGRSZW5kZXJlcihUaCkpLHRoaXMuc2hhZG93TWFwUGFzc1JlbmRlcmVyPW5ldyBCaCx0aGlzLnBvaW50TGlnaHRTaGFkb3dSZW5kZXJlcj1uZXcgSWh9YWRkUmVuZGVyZXIoZSx0KXtsZXQgcjtyZXR1cm4gdD9yPW5ldyBlKHQpOnI9bmV3IGUsdGhpcy5yZW5kZXJlck1hcC5hZGRSZW5kZXJlcihyKSxyfWdldCB2aWV3KCl7cmV0dXJuIHRoaXMuX3ZpZXd9c2V0IHZpZXcoZSl7dGhpcy5fdmlldz1lfXN0YXJ0KCl7fXN0b3AoKXt9cGF1c2UoKXt0aGlzLnBhdXNlUmVuZGVyPSEwfXJlc3VtZSgpe3RoaXMucGF1c2VSZW5kZXI9ITF9ZW5hYmxlUG9zdChlKXt0aGlzLnBvc3RSZW5kZXJlcj10aGlzLmFkZFJlbmRlcmVyKERoKSx0aGlzLnBvc3RSZW5kZXJlci5zZXRSZW5kZXJTdGF0ZXMoZSl9YWRkUG9zdChlKXtyZXR1cm4gdGhpcy5wb3N0UmVuZGVyZXJ8fHRoaXMuZW5hYmxlUG9zdCh3dC5nZXRHQnVmZmVyRnJhbWUoXCJDb2xvclBhc3NHQnVmZmVyXCIpKSxlIGluc3RhbmNlb2YgQ3QmJnRoaXMucG9zdFJlbmRlcmVyLmF0dGFjaFBvc3QodGhpcy52aWV3LGUpLGV9cmVtb3ZlUG9zdChlKXtpZihlIGluc3RhbmNlb2YgQ3QpdGhpcy5wb3N0UmVuZGVyZXIuZGV0YWNoUG9zdCh0aGlzLnZpZXcsZSk7ZWxzZSBmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl0aGlzLnBvc3RSZW5kZXJlci5kZXRhY2hQb3N0KHRoaXMudmlldyxlW3RdKX1yZW5kZXJGcmFtZSgpe2xldCBlPXRoaXMuX3ZpZXc7cGUuZ2V0TGlnaHRFbnRyaWVzKGUuc2NlbmUpLnVwZGF0ZShlKSx0aGlzLm9jY2x1c2lvblN5c3RlbS51cGRhdGUoZS5jYW1lcmEsZS5zY2VuZSksdGhpcy5jbHVzdGVyTGlnaHRpbmdSZW5kZXIucmVuZGVyKGUsdGhpcy5vY2NsdXNpb25TeXN0ZW0pLHRoaXMuc2hhZG93TWFwUGFzc1JlbmRlcmVyJiYoVmUudXBkYXRlKGUuc2NlbmUpLHRoaXMuc2hhZG93TWFwUGFzc1JlbmRlcmVyLnJlbmRlcihlLHRoaXMub2NjbHVzaW9uU3lzdGVtKSksdGhpcy5wb2ludExpZ2h0U2hhZG93UmVuZGVyZXImJnRoaXMucG9pbnRMaWdodFNoYWRvd1JlbmRlcmVyLnJlbmRlcihlLHRoaXMub2NjbHVzaW9uU3lzdGVtKSx0aGlzLmRlcHRoUGFzc1JlbmRlcmVyJiYodGhpcy5kZXB0aFBhc3NSZW5kZXJlci5jb21wdXRlKGUsdGhpcy5vY2NsdXNpb25TeXN0ZW0pLHRoaXMuZGVwdGhQYXNzUmVuZGVyZXIucmVuZGVyKGUsdGhpcy5vY2NsdXNpb25TeXN0ZW0pKSxBLnNldHRpbmcuZ2kuZW5hYmxlJiZ0aGlzLmRkZ2lQcm9iZVJlbmRlcmVyJiYodGhpcy5kZGdpUHJvYmVSZW5kZXJlci5jb21wdXRlKGUsdGhpcy5vY2NsdXNpb25TeXN0ZW0pLHRoaXMuZGRnaVByb2JlUmVuZGVyZXIucmVuZGVyKGUsdGhpcy5vY2NsdXNpb25TeXN0ZW0pKTtsZXQgdD10aGlzLnJlbmRlcmVyTWFwLmdldEFsbFBhc3NSZW5kZXJlcigpO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBzPXRbcl07cy5jb21wdXRlKGUsdGhpcy5vY2NsdXNpb25TeXN0ZW0pLHMucmVuZGVyKGUsdGhpcy5vY2NsdXNpb25TeXN0ZW0sdGhpcy5jbHVzdGVyTGlnaHRpbmdSZW5kZXIuY2x1c3RlckxpZ2h0aW5nQnVmZmVyKX10aGlzLnBvc3RSZW5kZXJlciYmdGhpcy5wb3N0UmVuZGVyZXIucG9zdExpc3QubGVuZ3RoPjAmJnRoaXMucG9zdFJlbmRlcmVyLnJlbmRlcihlKX1kZWJ1Zygpe319Y2xhc3MgUmggZXh0ZW5kcyB0ZXtjb25zdHJ1Y3RvcihlPS4wMDEsdD0xZTQscj05MCxzPSExKXtzdXBlcigpLG8odGhpcyxcInVwX2NhbWVyYVwiKSxvKHRoaXMsXCJkb3duX2NhbWVyYVwiKSxvKHRoaXMsXCJsZWZ0X2NhbWVyYVwiKSxvKHRoaXMsXCJyaWdodF9jYW1lcmFcIiksbyh0aGlzLFwiZnJvbnRfY2FtZXJhXCIpLG8odGhpcyxcImJhY2tfY2FtZXJhXCIpLHRoaXMuaW5pdEN1YmVDYW1lcmEoZSx0LHIscyl9aW5pdEN1YmVDYW1lcmEoZSx0LHI9OTAscz0hMSl7dGhpcy51cF9jYW1lcmE9TmUuY3JlYXRlQ2FtZXJhM0RPYmplY3QodGhpcyxcInVwXCIpLHRoaXMuZG93bl9jYW1lcmE9TmUuY3JlYXRlQ2FtZXJhM0RPYmplY3QodGhpcyxcImRvd25cIiksdGhpcy5sZWZ0X2NhbWVyYT1OZS5jcmVhdGVDYW1lcmEzRE9iamVjdCh0aGlzLFwibGVmdFwiKSx0aGlzLnJpZ2h0X2NhbWVyYT1OZS5jcmVhdGVDYW1lcmEzRE9iamVjdCh0aGlzLFwicmlnaHRcIiksdGhpcy5mcm9udF9jYW1lcmE9TmUuY3JlYXRlQ2FtZXJhM0RPYmplY3QodGhpcyxcImZyb250XCIpLHRoaXMuYmFja19jYW1lcmE9TmUuY3JlYXRlQ2FtZXJhM0RPYmplY3QodGhpcyxcImJhY2tcIiksdGhpcy51cF9jYW1lcmEuaXNTaGFkb3dDYW1lcmE9cyx0aGlzLmRvd25fY2FtZXJhLmlzU2hhZG93Q2FtZXJhPXMsdGhpcy5sZWZ0X2NhbWVyYS5pc1NoYWRvd0NhbWVyYT1zLHRoaXMucmlnaHRfY2FtZXJhLmlzU2hhZG93Q2FtZXJhPXMsdGhpcy5mcm9udF9jYW1lcmEuaXNTaGFkb3dDYW1lcmE9cyx0aGlzLmJhY2tfY2FtZXJhLmlzU2hhZG93Q2FtZXJhPXM7bGV0IGE9MTt0aGlzLnVwX2NhbWVyYS5wZXJzcGVjdGl2ZShyLGEsZSx0KSx0aGlzLnVwX2NhbWVyYS5sb29rQXQoZy5aRVJPLGcuVVAsZy5ET1dOKSx0aGlzLmRvd25fY2FtZXJhLnBlcnNwZWN0aXZlKHIsYSxlLHQpLHRoaXMuZG93bl9jYW1lcmEubG9va0F0KGcuWkVSTyxnLkRPV04sZy5ET1dOKSx0aGlzLmxlZnRfY2FtZXJhLnBlcnNwZWN0aXZlKHIsYSxlLHQpLHRoaXMubGVmdF9jYW1lcmEubG9va0F0KGcuWkVSTyxnLkxFRlQpLHRoaXMucmlnaHRfY2FtZXJhLnBlcnNwZWN0aXZlKHIsYSxlLHQpLHRoaXMucmlnaHRfY2FtZXJhLmxvb2tBdChnLlpFUk8sZy5SSUdIVCksdGhpcy5mcm9udF9jYW1lcmEucGVyc3BlY3RpdmUocixhLGUsdCksdGhpcy5mcm9udF9jYW1lcmEubG9va0F0KGcuWkVSTyxnLkZPUldBUkQpLHRoaXMuYmFja19jYW1lcmEucGVyc3BlY3RpdmUocixhLGUsdCksdGhpcy5iYWNrX2NhbWVyYS5sb29rQXQoZy5aRVJPLGcuQkFDSyksdGhpcy51cF9jYW1lcmEudHlwZT1JZS5zaGFkb3csdGhpcy5kb3duX2NhbWVyYS50eXBlPUllLnNoYWRvdyx0aGlzLmxlZnRfY2FtZXJhLnR5cGU9SWUuc2hhZG93LHRoaXMucmlnaHRfY2FtZXJhLnR5cGU9SWUuc2hhZG93LHRoaXMuZnJvbnRfY2FtZXJhLnR5cGU9SWUuc2hhZG93LHRoaXMuYmFja19jYW1lcmEudHlwZT1JZS5zaGFkb3d9fWNsYXNzIExoIGV4dGVuZHMgWmV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihbXSxbXSksdGhpcy5jcmF0ZUdCdWZmZXIoZSx0KX1jcmF0ZUdCdWZmZXIoZSx0KXtsZXQgcj10aGlzLmF0dGFjaG1lbnRzLHM9dGhpcy5ydERlc2NyaXB0b3JzLGE9bmV3IG9lKGUsdCxHLnJnYmExNmZsb2F0LCExKTthLm5hbWU9XCJwb3NpdGlvbk1hcFwiO2xldCBuPW5ldyBDZTtuLmxvYWRPcD1cImxvYWRcIjtsZXQgbD1uZXcgb2UoZSx0LEcucmdiYTE2ZmxvYXQsITEpO2wubmFtZT1cIm5vcm1hbE1hcFwiO2xldCBoPW5ldyBDZTtoLmxvYWRPcD1cImxvYWRcIjtsZXQgdT1uZXcgb2UoZSx0LEcucmdiYTE2ZmxvYXQsITEpO3UubmFtZT1cImNvbG9yTWFwXCI7bGV0IGM9bmV3IENlO2MubG9hZE9wPVwibG9hZFwiO2xldCBmPW5ldyBvZShlLHQsRy5kZXB0aDI0cGx1cywhMSk7Zi5uYW1lPVwiZGVwdGhUZXh0dXJlXCI7bGV0IGQ9bmV3IENlO2QubG9hZE9wPVwibG9hZFwiLHIucHVzaChhKSxyLnB1c2gobCksci5wdXNoKHUpLHMucHVzaChuKSxzLnB1c2goaCkscy5wdXNoKGMpLHRoaXMuZGVwdGhUZXh0dXJlPWZ9fWxldCBVaD1gXG4jaW5jbHVkZSBcIkdlbmVyYXlSYW5kb21EaXJcIlxuI2luY2x1ZGUgXCJNYXRoU2hhZGVyXCJcbiNpbmNsdWRlIFwiSXJyYWRpYW5jZVZvbHVtZURhdGFfZnJhZ1wiXG5cbnN0cnVjdCBQcm9iZURhdGF7XG4gIG9mZnNldFg6ZjMyLFxuICBvZmZzZXRZOmYzMixcbiAgb2Zmc2V0WjpmMzIsXG4gIGZyYW1lOmYzMixcbn1cblxuIHN0cnVjdCBVbmlmb3JtcyB7XG4gICAgIG1hdHJpeCA6IGFycmF5PG1hdDR4NDxmMzI+PlxuIH07XG5cbnN0cnVjdCBSYXlQcm9iZUJ1ZmZlcntcbiAgV1Bvc2l0aW9uOiB2ZWMzPGYzMj4sXG4gIFdOb3JtYWw6dmVjMzxmMzI+LFxuICBXUmFkaWFuY2U6dmVjNDxmMzI+LFxufVxuXG5zdHJ1Y3QgQ2FjaGVIaXREYXRhe1xuICBjb2xvcjp2ZWM0PGYzMj4sXG4gIGRlcHRoOnZlYzQ8ZjMyPixcbn1cblxuLy8gIHN0cnVjdCBSYXlJbmZve1xuLy8gICByYXlzOmFycmF5PHZlYzQ8ZjMyPiw0MDk2PlxuLy8gIH1cblxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBwcm9iZXMgOiBhcnJheTxQcm9iZURhdGE+O1xuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBpcnJhZGlhbmNlQnVmZmVyIDogYXJyYXk8dmVjNDxmMzI+PjtcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gZGVwdGhCdWZmZXIgOiBhcnJheTx2ZWM0PGYzMj4+O1xuQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLCByZWFkPiB1bmlmb3JtRGF0YSA6IElycmFkaWFuY2VWb2x1bWVEYXRhIDtcbkBncm91cCgwKSBAYmluZGluZyg0KSB2YXIgcHJvYmVJcnJhZGlhbmNlTWFwIDogdGV4dHVyZV9zdG9yYWdlXzJkPHJnYmExNmZsb2F0LCB3cml0ZT47XG5AZ3JvdXAoMCkgQGJpbmRpbmcoNSkgdmFyIHByb2JlRGVwdGhNYXAgOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTE2ZmxvYXQsIHdyaXRlPjtcbkBncm91cCgwKSBAYmluZGluZyg2KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gZGVwdGhSYXlzQnVmZmVyIDogYXJyYXk8dmVjNDxmMzI+PjtcblxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhciBwb3NpdGlvbk1hcCA6IHRleHR1cmVfMmQ8ZjMyPjtcbkBncm91cCgxKSBAYmluZGluZygxKSB2YXIgbm9ybWFsTWFwIDogdGV4dHVyZV8yZDxmMzI+O1xuQGdyb3VwKDEpIEBiaW5kaW5nKDIpIHZhciBjb2xvck1hcCA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuQGdyb3VwKDIpIEBiaW5kaW5nKDApXG52YXI8c3RvcmFnZSwgcmVhZD4gbW9kZWxzIDogVW5pZm9ybXM7XG5cbnZhcjxwcml2YXRlPiBwcm9iZUlEOiB1MzIgO1xudmFyPHByaXZhdGU+IHdvcmtncm91cF9pZHg6IHUzMiA7XG52YXI8cHJpdmF0ZT4gd29ya2dyb3VwX2lkeTogdTMyIDtcbnZhcjxwcml2YXRlPiBoeXN0ZXJlc2lzOiBmMzIgPSAwLjk4IDtcbnZhcjxwcml2YXRlPiBlcHNpbG9uOiBmMzIgPSAxZS02IDtcbnZhcjxwcml2YXRlPiBwcm9iZUxvY2F0aW9uOnZlYzM8ZjMyPiA9IHZlYzM8ZjMyPigwLjApO1xudmFyPHByaXZhdGU+IGVuZXJneUNvbnNlcnZhdGlvbjogZjMyID0gMC44NSA7XG52YXI8cHJpdmF0ZT4gcmVzdWx0SXJyYWRpYW5jZTogdmVjNDxmMzI+IDtcbnZhcjxwcml2YXRlPiByZXN1bHREZXB0aDogdmVjNDxmMzI+IDtcbnZhcjxwcml2YXRlPiBSQVlTX1BFUl9QUk9CRTogZjMyID0gMTQ0LjAgO1xudmFyPHByaXZhdGU+IE9DVF9SVF9TSVpFOiB1MzI7XG52YXI8cHJpdmF0ZT4gUFJPQkVfT0NUX1JUX1NJWkU6IHUzMjtcbnZhcjxwcml2YXRlPiBPQ1RfU0lERV9TSVpFX3UzMjogdTMyO1xudmFyPHByaXZhdGU+IE9DVF9TSURFX1NJWkVfZjMyOiBmMzI7XG52YXI8cHJpdmF0ZT4gT0NUX1JUX1NJWkVfZjMyOiBmMzI7XG52YXI8cHJpdmF0ZT4gUFJPQkVfU09VUkNFU0laRTogZjMyO1xudmFyPHByaXZhdGU+IFBST0JFTUFQX1NPVVJDRVNJWkU6IGYzMjtcbnZhcjxwcml2YXRlPiBxdWF0ZXJuaW9uOnZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPigwLjAsIC0wLjcwNzEwNjc4MTE4NjU0NzUsIDAuNzA3MTA2NzgxMTg2NTQ3NSwgMC4wKTtcbnZhcjxwcml2YXRlPiByYW5kb21NYXRyaXg6bWF0NHg0PGYzMj47XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSggOCAsIDggLCAxIClcbmZuIENzTWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSW52b2NhdGlvbl9pZCA6IHZlYzM8dTMyPilcbntcbiAgIFJBWVNfUEVSX1BST0JFID0gZjMyKGkzMih1bmlmb3JtRGF0YS5yYXlOdW1iZXIpKTtcbiAgIE9DVF9SVF9TSVpFID0gdTMyKHVuaWZvcm1EYXRhLk9jdFJUTWF4U2l6ZSk7XG4gICBPQ1RfUlRfU0laRV9mMzIgPSBmMzIodW5pZm9ybURhdGEuT2N0UlRNYXhTaXplKTtcbiAgIE9DVF9TSURFX1NJWkVfdTMyID0gdTMyKHVuaWZvcm1EYXRhLk9jdFJUU2lkZVNpemUpO1xuICAgT0NUX1NJREVfU0laRV9mMzIgPSBmMzIodW5pZm9ybURhdGEuT2N0UlRTaWRlU2l6ZSk7XG4gICBQUk9CRV9TT1VSQ0VTSVpFID0gZjMyKHVuaWZvcm1EYXRhLlByb2JlU2l6ZSk7XG4gICBQUk9CRU1BUF9TT1VSQ0VTSVpFID0gZjMyKHVuaWZvcm1EYXRhLlByb2JlU291cmNlVGV4dHVyZVNpemUpO1xuICAgaHlzdGVyZXNpcyA9IHVuaWZvcm1EYXRhLmh5c3RlcmVzaXM7XG4gICAgLy8gcHJvYmUgaW5kZXhcbiAgICBwcm9iZUlEID0gZ2xvYmFsSW52b2NhdGlvbl9pZC56IDtcbiAgICAvLyBwaXhlbCBjb29yZFxuICAgIHdvcmtncm91cF9pZHggPSBnbG9iYWxJbnZvY2F0aW9uX2lkLnggO1xuICAgIHdvcmtncm91cF9pZHkgPSBnbG9iYWxJbnZvY2F0aW9uX2lkLnk7XG5cbiAgICBwcm9iZUxvY2F0aW9uID0gY2FsY1Byb2JlUG9zaXRpb24ocHJvYmVJRCk7XG5cbiAgICByZXN1bHRJcnJhZGlhbmNlID0gdmVjNDxmMzI+KDAuMCk7XG4gICAgcmVzdWx0RGVwdGggPSB2ZWM0PGYzMj4oMC4wLDAuMCwwLjAsMC4wKTtcblxuICAgIHZhciB0ZHIgPSBub3JtYWxpemUoZ2V0Q3VycmVudERpcigpKTtcbiAgICBsZXQgb3JpZW50YXRpb25JbmRleCA9IHUzMih1bmlmb3JtRGF0YS5vcmllbnRhdGlvbkluZGV4KTtcbiAgICByYW5kb21NYXRyaXggPSBtb2RlbHMubWF0cml4W29yaWVudGF0aW9uSW5kZXhdO1xuXG4gICAgdmFyIGRpc3RhbmNlUHByb2JlVVYgPSBnZXRTYW1wbGVQcm9iZVVWKHRkci54eXopO1xuICAgIHZhciByYXlVdjp2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oZGlzdGFuY2VQcHJvYmVVVi54eSAqIGYzMihQUk9CRU1BUF9TT1VSQ0VTSVpFIC0gMS4wKSk7XG4gICAgbGV0IHJheUhpdFBvc2l0aW9uID0gdGV4dHVyZUxvYWQocG9zaXRpb25NYXAsIHJheVV2LCAwKS54eXogO1xuICAgIFxuICAgIGZvcih2YXIgaTpmMzIgPSAwLjA7IGkgPCBSQVlTX1BFUl9QUk9CRSA7IGkgPSBpICsgMS4wICl7XG4gICAgICByYWRpYW5jZVByb2JlT25jZShpLCB0ZHIpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRJcnJhZGlhbmNlLncgPiBlcHNpbG9uKSB7XG4gICAgICB2YXIgY29sb3IgPSB2ZWMzPGYzMj4ocmVzdWx0SXJyYWRpYW5jZS54eXovKDIuMCpyZXN1bHRJcnJhZGlhbmNlLncpKSA7XG4gICAgICBjb2xvciA9IHBvdyhjb2xvci5yZ2IsIHZlYzM8ZjMyPigxLjAgLyB1bmlmb3JtRGF0YS5kZGdpR2FtbWEpKTtcbiAgICAgIHJlc3VsdElycmFkaWFuY2UgPSB2ZWM0PGYzMj4oY29sb3IsMS4wLWh5c3RlcmVzaXMpO1xuICAgIH1cblxuICAgIC8vIGlmIG5vbnplcm9cbiAgICBpZiAocmVzdWx0RGVwdGgudyA+IGVwc2lsb24pIHtcbiAgICAgIHJlc3VsdERlcHRoID0gdmVjNDxmMzI+KHJlc3VsdERlcHRoLnh5ei8oMi4wKnJlc3VsdERlcHRoLncpLDEuMC1oeXN0ZXJlc2lzKSA7XG4gICAgfVxuXG4gICBsZXQgcGl4ZWxDb29yZCA9IGdldFdyaXRlT2N0VVZCeUlEKCk7XG5cbiAgIHZhciBsZXJwRGF0YVJlc3VsdDpDYWNoZUhpdERhdGE7XG5cbiAgIGxlcnBEYXRhUmVzdWx0LmNvbG9yID0gcmVzdWx0SXJyYWRpYW5jZTtcblxuICAgbGVycERhdGFSZXN1bHQuZGVwdGggPSByZXN1bHREZXB0aDtcblxuICAgbGVycERhdGFSZXN1bHQgPSBsZXJwSGl0RGF0YShsZXJwRGF0YVJlc3VsdCwgcGl4ZWxDb29yZCk7XG5cbiAgIHdyaXRlUmF5SGl0RGF0YShwaXhlbENvb3JkLCBsZXJwRGF0YVJlc3VsdCk7XG5cbiAgIHN0b3JlUGl4ZWxBdENvb3JkKHByb2JlSXJyYWRpYW5jZU1hcCwgcGl4ZWxDb29yZCAsIHZlYzQ8ZjMyPihsZXJwRGF0YVJlc3VsdC5jb2xvci54eXosIDEuMCksIHRydWUpO1xuXG4gICBzdG9yZVBpeGVsQXRDb29yZChwcm9iZURlcHRoTWFwLCBwaXhlbENvb3JkICwgdmVjNDxmMzI+KHJlc3VsdERlcHRoLnh5LCAwLjAsIDEuMCksIGZhbHNlKTtcbn1cblxuZm4gbGVycEhpdERhdGEoZGF0YTpDYWNoZUhpdERhdGEsIGNvb3JkOnZlYzI8aTMyPikgLT4gQ2FjaGVIaXREYXRhe1xuICAgbGV0IGZyYW1lSW5kZXggPSBwcm9iZXNbcHJvYmVJRF0uZnJhbWU7XG4gICB2YXIgbmV3RGF0YTpDYWNoZUhpdERhdGEgPSBkYXRhO1xuXG4gICAvL2lmKGZyYW1lSW5kZXggPiAxLjApe1xuICAgICAgdmFyIG9sZERhdGEgPSByZWFkUmF5SGl0RGF0YShjb29yZCk7XG4gICAgICBuZXdEYXRhLmNvbG9yID0gbWl4KG9sZERhdGEuY29sb3IsIG5ld0RhdGEuY29sb3IsIHVuaWZvcm1EYXRhLmxlcnBIeXN0ZXJlc2lzKTtcbiAgICAgIG5ld0RhdGEuZGVwdGggPSBtaXgob2xkRGF0YS5kZXB0aCwgbmV3RGF0YS5kZXB0aCwgdW5pZm9ybURhdGEubGVycEh5c3RlcmVzaXMpO1xuICAgLy99XG4gICByZXR1cm4gbmV3RGF0YTtcbn1cblxuZm4gc3F1YXJlKHY6dmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj57XG4gICB2YXIgdjMgPSB2O1xuICAgdjMueCA9IHYzLnggKiB2My54O1xuICAgdjMueSA9IHYzLnkgKiB2My55O1xuICAgdjMueiA9IHYzLnogKiB2My56O1xuICAgcmV0dXJuIHYzO1xufVxuXG4gZm4gdGVzdFNhbXBsZSgpIC0+dmVjNDxmMzI+e1xuICAgdmFyIHV4ID0gZjMyKHdvcmtncm91cF9pZHgpIC8gT0NUX1NJREVfU0laRV9mMzI7XG4gICB2YXIgdXkgPSBmMzIod29ya2dyb3VwX2lkeSkgLyBPQ1RfU0lERV9TSVpFX2YzMjtcbiAgIHZhciB1diA9IHZlYzI8ZjMyPih1eCx1eSkgKiAyLjAgLSAxLjAgO1xuICAgdmFyIGRpciA9IG9jdERlY29kZSh1dik7XG4gICB2YXIgcHJvYmVVViA9IGdldFNhbXBsZVByb2JlVVYoZGlyLnh5eik7XG4gICB2YXIgcmF5UHJvYmVCdWZmZXIgPSBnZXRDdXJyZW50UmF5SGl0QnVmZmVyKHByb2JlVVYpO1xuICAgcmV0dXJuIHJheVByb2JlQnVmZmVyLldSYWRpYW5jZTtcbiB9XG5cbiBmbiBncmlkQ29vcmRUb1Byb2JlSW5kZXgoZ3JpZDp2ZWMzPGkzMj4pIC0+IGkzMlxuIHtcbiAgICAgcmV0dXJuIGdyaWQueCArIGdyaWQueiAqIGkzMih1bmlmb3JtRGF0YS5ncmlkWENvdW50KSArIGdyaWQueSAqIGkzMih1bmlmb3JtRGF0YS5ncmlkWENvdW50ICogdW5pZm9ybURhdGEuZ3JpZFpDb3VudCk7XG4gfVxuXG5mbiBzdG9yZVBpeGVsQXRDb29yZCh0ZXh0dXJlOnRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+LCBjb29yZDp2ZWMyPGkzMj4sIGNvbG9yOnZlYzQ8ZjMyPiwgaXNDb2xvcjpib29sKXtcbiAgIGxldCBzaWRlQ250ID0gaTMyKE9DVF9TSURFX1NJWkVfdTMyKTtcbiAgIGxldCBzaWRlQm9yZGVyQ250ID0gc2lkZUNudCArIDI7XG4gICBsZXQgaW5kZXhYWSA9IGNvb3JkIC8gc2lkZUNudDtcbiAgIGxldCBtb2RlWFkgPSBjb29yZCAlIHNpZGVDbnQ7XG5cbiAgIHZhciBuZXdDb29yZCA9IGluZGV4WFkgKiBzaWRlQm9yZGVyQ250ICsgbW9kZVhZO1xuICAgdGV4dHVyZVN0b3JlKHRleHR1cmUsIG5ld0Nvb3JkICsgMSwgY29sb3IpO1xuXG4gICB2YXIgYm9yZGVyQ29vcmQgPSB2ZWMyPGkzMj4oLTEpO1xuICAgLy9cXHU1REU2XFx1NTNGM1xuICAgaWYobW9kZVhZLnggJSAoc2lkZUNudCAtIDEpID09IDApe1xuICAgICBib3JkZXJDb29yZCA9IG1vZGVYWTtcbiAgICAgYm9yZGVyQ29vcmQueSA9IHNpZGVDbnQgLSBib3JkZXJDb29yZC55O1xuICAgICBpZihtb2RlWFkueCA9PSBzaWRlQ250IC0gMSl7XG4gICAgICAgYm9yZGVyQ29vcmQueCA9IHNpZGVCb3JkZXJDbnQgLSAxO1xuICAgICB9XG4gICAgIGJvcmRlckNvb3JkID0gaW5kZXhYWSAqIHNpZGVCb3JkZXJDbnQgKyBib3JkZXJDb29yZDtcbiAgICAgdGV4dHVyZVN0b3JlKHRleHR1cmUsIGJvcmRlckNvb3JkLCBjb2xvcik7XG4gICB9XG4gICAvL1xcdTRFMEFcXHU0RTBCXG4gICBpZihtb2RlWFkueSAlIChzaWRlQ250IC0gMSkgPT0gMCl7XG4gICAgIGJvcmRlckNvb3JkID0gbW9kZVhZO1xuICAgICBib3JkZXJDb29yZC54ID0gc2lkZUNudCAtIGJvcmRlckNvb3JkLng7XG4gICAgIGlmKG1vZGVYWS55ID09IHNpZGVDbnQgLSAxKXtcbiAgICAgICAgIGJvcmRlckNvb3JkLnkgPSBzaWRlQm9yZGVyQ250IC0gMTtcbiAgICAgfVxuICAgICBib3JkZXJDb29yZCA9IGluZGV4WFkgKiBzaWRlQm9yZGVyQ250ICsgYm9yZGVyQ29vcmQ7XG4gICAgIHRleHR1cmVTdG9yZSh0ZXh0dXJlLCBib3JkZXJDb29yZCwgY29sb3IpO1xuICAgfVxuICAgLy9cXHU4ODY1XFx1ODlEMlxuICAgaWYobW9kZVhZLnggJSAoc2lkZUNudCAtIDEpID09IDAgJiYgbW9kZVhZLnkgJSAoc2lkZUNudCAtIDEpID09IDApe1xuICAgICAgdmFyIGNvcm5lckNvb3JkID0gbW9kZVhZO1xuICAgICAgaWYobW9kZVhZLnggPT0gMCl7XG4gICAgICAgICBjb3JuZXJDb29yZC54ID0gc2lkZUJvcmRlckNudCAtIDE7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgIGNvcm5lckNvb3JkLnggPSAwO1xuICAgICAgfVxuICAgICAgIGlmKG1vZGVYWS55ID09IDApe1xuICAgICAgICAgY29ybmVyQ29vcmQueSA9IHNpZGVCb3JkZXJDbnQgLSAxO1xuICAgICAgfWVsc2V7XG4gICAgICAgICBjb3JuZXJDb29yZC55ID0gMDtcbiAgICAgIH1cbiAgICAgIGNvcm5lckNvb3JkID0gaW5kZXhYWSAqIHNpZGVCb3JkZXJDbnQgKyBjb3JuZXJDb29yZDtcbiAgICAgIHRleHR1cmVTdG9yZSh0ZXh0dXJlLCBjb3JuZXJDb29yZCwgY29sb3IpO1xuICAgfVxufVxuXG5mbiBjYWxjUHJvYmVQb3NpdGlvbihpZDp1MzIpIC0+IHZlYzM8ZjMyPntcbiAgIHZhciBwcm9iZUxvY2F0aW9uID0gdmVjMzxmMzI+KDAuMCk7XG4gICB2YXIgYmxvY2tDb3VudCA9IHUzMih1bmlmb3JtRGF0YS5ncmlkWENvdW50ICogdW5pZm9ybURhdGEuZ3JpZFpDb3VudCkgO1xuICAgdmFyIGdyaWQgPSB2ZWMzPHUzMj4oMHUpO1xuICAgZ3JpZC54ID0gKGlkICUgYmxvY2tDb3VudCkgJSB1MzIodW5pZm9ybURhdGEuZ3JpZFhDb3VudCk7XG4gICBncmlkLnkgPSBpZCAvIGJsb2NrQ291bnQ7XG4gICBncmlkLnogPSAoaWQgJSBibG9ja0NvdW50KSAvIHUzMih1bmlmb3JtRGF0YS5ncmlkWENvdW50KTtcbiAgIHByb2JlTG9jYXRpb24ueCA9IGYzMihncmlkLngpICogdW5pZm9ybURhdGEuUHJvYmVTcGFjZSArIHVuaWZvcm1EYXRhLnN0YXJ0WDtcbiAgIHByb2JlTG9jYXRpb24ueSA9IGYzMihncmlkLnkpICogdW5pZm9ybURhdGEuUHJvYmVTcGFjZSArIHVuaWZvcm1EYXRhLnN0YXJ0WTtcbiAgIHByb2JlTG9jYXRpb24ueiA9IGYzMihncmlkLnopICogdW5pZm9ybURhdGEuUHJvYmVTcGFjZSArIHVuaWZvcm1EYXRhLnN0YXJ0WjtcbiAgIHJldHVybiBwcm9iZUxvY2F0aW9uO1xufVxuXG5mbiBnZXRXcml0ZU9jdFVWQnlJRCgpIC0+IHZlYzI8aTMyPlxue1xuICAgdmFyIGJsb2NrQ291bnQgPSB1MzIodW5pZm9ybURhdGEuZ3JpZFhDb3VudCAqIHVuaWZvcm1EYXRhLmdyaWRaQ291bnQpIDtcbiAgIHZhciBvZmZzZXRYID0gKHByb2JlSUQgJSBibG9ja0NvdW50KSAlIHUzMih1bmlmb3JtRGF0YS5ncmlkWENvdW50KSA7XG4gICB2YXIgb2Zmc2V0WSA9IHUzMih1bmlmb3JtRGF0YS5ncmlkWkNvdW50IC0gMS4wKSAtIChwcm9iZUlEICUgYmxvY2tDb3VudCkgLyB1MzIodW5pZm9ybURhdGEuZ3JpZFhDb3VudCkgO1xuICAgdmFyIG9mZnNldFogPSBwcm9iZUlEIC8gYmxvY2tDb3VudCA7XG4gICB2YXIgcGl4ZWxDb29yZCA9IHZlYzI8aTMyPihpMzIod29ya2dyb3VwX2lkeCksIGkzMih3b3JrZ3JvdXBfaWR5KSk7XG4gICBwaXhlbENvb3JkLnggPSBwaXhlbENvb3JkLnggKyBpMzIob2Zmc2V0WCAqIE9DVF9TSURFX1NJWkVfdTMyKTtcbiAgIHBpeGVsQ29vcmQueSA9IHBpeGVsQ29vcmQueSArIGkzMihvZmZzZXRZICogT0NUX1NJREVfU0laRV91MzIgKyBvZmZzZXRaICogdTMyKHVuaWZvcm1EYXRhLmdyaWRaQ291bnQpICogT0NUX1NJREVfU0laRV91MzIpO1xuXG4gICBwaXhlbENvb3JkID0gb2Zmc2V0QnlDb2wocGl4ZWxDb29yZCwgT0NUX1NJREVfU0laRV9mMzIsIE9DVF9SVF9TSVpFLCB2ZWMzPGYzMj4odW5pZm9ybURhdGEuZ3JpZFhDb3VudCwgdW5pZm9ybURhdGEuZ3JpZFlDb3VudCwgdW5pZm9ybURhdGEuZ3JpZFpDb3VudCkpO1xuICAgcmV0dXJuIHBpeGVsQ29vcmQ7XG59XG5cbmZuIG9mZnNldEJ5Q29sKHBpeGVsQ29vcmQwOnZlYzI8aTMyPiwgb2N0U2lkZVNpemU6ZjMyLCBtYXBIZWlnaHQ6dTMyLCBjb3VudHM6dmVjMzxmMzI+KSAtPiB2ZWMyPGkzMj5cbntcbiB2YXIgcGl4ZWxDb29yZCA9IHBpeGVsQ29vcmQwO1xuIGxldCBibG9ja1NpemU6dmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy54KSwgIGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy56KSk7XG4gbGV0IGJsb2NrU2l6ZVlCb3JkZXI6aTMyID0gaTMyKChvY3RTaWRlU2l6ZSArIDIuMCkgKiBjb3VudHMueik7XG4gbGV0IGJsb2NrTWF4Um93Qm9yZGVyOmkzMiA9IGkzMihtYXBIZWlnaHQpIC8gYmxvY2tTaXplWUJvcmRlcjtcbiBsZXQgcGl4ZWxDb3VudFlNYXg6aTMyID0gYmxvY2tNYXhSb3dCb3JkZXIgKiBpMzIob2N0U2lkZVNpemUgKiBjb3VudHMueik7XG4gbGV0IGNvbDppMzIgPSBwaXhlbENvb3JkLnkgLyBwaXhlbENvdW50WU1heDtcblxuIHBpeGVsQ29vcmQueCA9IGNvbCAqIGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy54KSArIHBpeGVsQ29vcmQueDtcbiBwaXhlbENvb3JkLnkgPSBwaXhlbENvb3JkLnkgJSBwaXhlbENvdW50WU1heDtcblxuIHJldHVybiBwaXhlbENvb3JkO1xufVxuXG5mbiByYWRpYW5jZVByb2JlT25jZShyYXlJRDpmMzIsIHRkcjp2ZWMzPGYzMj4pe1xuICAgdmFyIHRleGVsRGlyZWN0aW9uID0gc3BoZXJpY2FsRmlib25hY2NpKHJheUlELCBSQVlTX1BFUl9QUk9CRSApIDtcbiAgIHZhciByYXlEaXJlY3Rpb24gPSBub3JtYWxpemUoIHZlYzM8ZjMyPigocmFuZG9tTWF0cml4ICogdmVjNDxmMzI+KHRleGVsRGlyZWN0aW9uLCAxLjApKS54eXopKTtcbiAgIHZhciBwcm9iZVVWID0gZ2V0U2FtcGxlUHJvYmVVVihyYXlEaXJlY3Rpb24ueHl6KTtcbiAgIHZhciByYXlXcml0ZVVWID0gZ2V0V3JpdGVSYXlJbmZvVVYoKTtcblxuICAgdmFyIHJheVByb2JlQnVmZmVyID0gZ2V0Q3VycmVudFJheUhpdEJ1ZmZlcihwcm9iZVVWKTtcbiAgIHZhciByYXlIaXRMb2NhdGlvbiA9IHJheVByb2JlQnVmZmVyLldQb3NpdGlvbiArIG5vcm1hbGl6ZShyYXlQcm9iZUJ1ZmZlci5XTm9ybWFsKSAqIDAuMDE7XG5cbiAgIHZhciByYXlQcm9iZURpc3RhbmNlID0gbGVuZ3RoKHByb2JlTG9jYXRpb24gLSByYXlIaXRMb2NhdGlvbikgO1xuICAgLy8gcmF5UHJvYmVEaXN0YW5jZSA9IG1pbih1bmlmb3JtRGF0YS5Qcm9iZVNwYWNlICogNC4wLCByYXlQcm9iZURpc3RhbmNlKSA7XG5cbiAgIC8vIGlmIChkb3QocmF5UHJvYmVCdWZmZXIuV05vcm1hbCwgcmF5UHJvYmVCdWZmZXIuV05vcm1hbCkgPCBlcHNpbG9uKSB7XG4gICAvLyAgIHJheVByb2JlRGlzdGFuY2UgPSBlcHNpbG9uIDtcbiAgIC8vIH1cblxuICAgbGV0IHJpZCA9IGkzMihwcm9iZUlEKSAqIGkzMihSQVlTX1BFUl9QUk9CRSkgKyBpMzIocmF5SUQpIDtcbiAgIGRlcHRoUmF5c0J1ZmZlcltyaWRdID0gdmVjNDxmMzI+KHJheURpcmVjdGlvbi54eXoscmF5UHJvYmVEaXN0YW5jZSkgO1xuXG4gICAvLyBEZXRlY3QgbWlzc2VzIGFuZCBmb3JjZSBkZXB0aFxuICAgdmFyIGlfd2VpZ2h0ID0gbWF4KDAuMCwgZG90KHRkcixyYXlEaXJlY3Rpb24pICk7XG4gICB2YXIgZF93ZWlnaHQgPSBwb3coaV93ZWlnaHQsIHVuaWZvcm1EYXRhLmRlcHRoU2hhcnBuZXNzKTtcbiAgIFxuICAgaWYgKGlfd2VpZ2h0ID49IGVwc2lsb24pIHtcbiAgICAgLy8gIHZhciB3ZWlnaHRDb2xvciA9IHBvdyh3ZWlnaHQsICgyLjAgLSB1bmlmb3JtRGF0YS5wcm9iZVJvdWdobmVzcykgKiAyLjApO1xuICAgICAgcmVzdWx0SXJyYWRpYW5jZSArPSB2ZWM0KHJheVByb2JlQnVmZmVyLldSYWRpYW5jZS5yZ2IsIGlfd2VpZ2h0ICk7XG4gICAgIFxuICAgfVxuICAgaWYoZF93ZWlnaHQ+PSBlcHNpbG9uKXtcbiAgICAgICByZXN1bHREZXB0aCArPSB2ZWM0KHJheVByb2JlRGlzdGFuY2UgKiBkX3dlaWdodCwgcmF5UHJvYmVEaXN0YW5jZSAqIHJheVByb2JlRGlzdGFuY2UgKiBkX3dlaWdodCwgMC4wICwgaV93ZWlnaHQpO1xuICAgfVxufVxuXG5mbiBnZXRDdXJyZW50UmF5SGl0QnVmZmVyKHByb2JlVVY6dmVjMjxmMzI+KSAtPiBSYXlQcm9iZUJ1ZmZlciB7XG4gIHZhciByYXlQcm9iZUJ1ZmZlciA6IFJheVByb2JlQnVmZmVyIDtcbiAgdmFyIHV2OnZlYzI8aTMyPiA9IHZlYzI8aTMyPihwcm9iZVVWLnh5ICogZjMyKFBST0JFTUFQX1NPVVJDRVNJWkUgLSAxLjApKTtcbiAgcmF5UHJvYmVCdWZmZXIuV1Bvc2l0aW9uID0gdGV4dHVyZUxvYWQocG9zaXRpb25NYXAsIHV2LCAwKS54eXogO1xuICByYXlQcm9iZUJ1ZmZlci5XTm9ybWFsID0gbm9ybWFsaXplKHRleHR1cmVMb2FkKG5vcm1hbE1hcCwgdXYsIDApLnh5eiAqIDIuMCAtIDEuMCk7XG4gIHJheVByb2JlQnVmZmVyLldSYWRpYW5jZSA9IHRleHR1cmVMb2FkKGNvbG9yTWFwLCB1diwgMCkueHl6dyAqIGVuZXJneUNvbnNlcnZhdGlvbjtcbiAgcmV0dXJuIHJheVByb2JlQnVmZmVyIDtcbn1cblxuZm4gZ2V0U2FtcGxlUHJvYmVVVihkaXIwOnZlYzM8ZjMyPikgLT4gdmVjMjxmMzI+IHtcbiAgIHZhciBkaXIgPSBhcHBseVF1YXRlcm5pb24oZGlyMCwgcXVhdGVybmlvbik7XG4gICBsZXQgZmFjZUlkID0gZGlyX3RvX2ZhY2VJZChkaXIpO1xuICAgdmFyIHRhcmdldFVWOnZlYzI8ZjMyPiA9IGNvbnZlcnRfeHl6X3RvX2N1YmVfdXYoZGlyLngsIGRpci55LCBkaXIueik7XG4gICB0YXJnZXRVVi54ID0gMS4wIC0gdGFyZ2V0VVYueDtcbiAgIGxldCB0aHJlc2hvdWxkID0gMC41IC8gUFJPQkVfU09VUkNFU0laRTtcbiAgIHRhcmdldFVWID0gY2xhbXAodGFyZ2V0VVYsIHZlYzI8ZjMyPih0aHJlc2hvdWxkKSwgdmVjMjxmMzI+KDEuMCAtIHRocmVzaG91bGQpKTtcblxuICAgdGFyZ2V0VVYueCA9IGYzMihmYWNlSWQpICsgdGFyZ2V0VVYueDtcblxuICAgbGV0IGFzcGVjdDpmMzIgPSBQUk9CRV9TT1VSQ0VTSVpFIC8gUFJPQkVNQVBfU09VUkNFU0laRTtcbiAgIHRhcmdldFVWID0gdGFyZ2V0VVYgKiBhc3BlY3QgO1xuXG4gICB2YXIgZnVsbENvbCA9IHUzMihQUk9CRU1BUF9TT1VSQ0VTSVpFKSAvIHUzMihQUk9CRV9TT1VSQ0VTSVpFKTtcbiAgIHZhciBvZmZzZXRTYW1wbGVVdiA9IHZlYzI8ZjMyPiggZjMyKHByb2JlSUQgLyBmdWxsQ29sKSAqIDYuMCAsIGYzMihwcm9iZUlEICUgZnVsbENvbCkpICogYXNwZWN0O1xuICAgcmV0dXJuIHRhcmdldFVWICsgb2Zmc2V0U2FtcGxlVXY7XG59XG5cbmZuIGdldFdyaXRlUmF5SW5mb1VWKCkgLT4gdmVjMjxpMzI+IHtcbiAgdmFyIHdyaXRlVVYgPSB2ZWMyPGkzMj4oaTMyKHdvcmtncm91cF9pZHkpLGkzMihwcm9iZUlEKSkgO1xuICByZXR1cm4gd3JpdGVVViA7XG59XG5cbmZuIHdyaXRlUmF5SGl0RGF0YSggdXY6dmVjMjxpMzI+ICwgZGF0YTpDYWNoZUhpdERhdGEpe1xuICBsZXQgaW5kZXggPSB1di55ICogaTMyKE9DVF9SVF9TSVpFKSArIHV2LnggO1xuICBpcnJhZGlhbmNlQnVmZmVyW2luZGV4XSA9IGRhdGEuY29sb3IgO1xuICBkZXB0aEJ1ZmZlcltpbmRleF0gPSBkYXRhLmRlcHRoIDtcbn1cblxuZm4gcmVhZFJheUhpdERhdGEoIHV2OnZlYzI8aTMyPiApIC0+IENhY2hlSGl0RGF0YXtcbiAgdmFyIGRhdGE6Q2FjaGVIaXREYXRhO1xuICBsZXQgaW5kZXggPSB1di55ICogaTMyKE9DVF9SVF9TSVpFKSArIHV2LnggO1xuICBkYXRhLmNvbG9yID0gaXJyYWRpYW5jZUJ1ZmZlcltpbmRleF0gO1xuICBkYXRhLmRlcHRoID0gZGVwdGhCdWZmZXJbaW5kZXhdIDtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZuIGdldEN1cnJlbnREaXIoKSAtPiB2ZWMzPGYzMj4ge1xuICB2YXIgdXggPSBmMzIod29ya2dyb3VwX2lkeCkgLyBPQ1RfU0lERV9TSVpFX2YzMjtcbiAgdmFyIHV5ID0gZjMyKHdvcmtncm91cF9pZHkpIC8gT0NUX1NJREVfU0laRV9mMzI7XG4gIHZhciB1diA9IHZlYzI8ZjMyPih1eCx1eSkgKiAyLjAgLSAxLjAgO1xuICB2YXIgZGlyID0gb2N0RGVjb2RlKHV2KSA7XG4gIHJldHVybiBub3JtYWxpemUoZGlyKSA7XG59XG5cblxuYDtjbGFzcyBPaHtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJpcnJhZGlhbmNlQnVmZmVyXCIpLG8odGhpcyxcImRlcHRoQnVmZmVyXCIpLG8odGhpcyxcInByb2JlSXJyYWRpYW5jZU1hcFwiKSxvKHRoaXMsXCJwcm9iZURlcHRoTWFwXCIpLG8odGhpcyxcInZvbHVtZVwiKSxvKHRoaXMsXCJjb21wdXRlU2hhZGVyXCIpLG8odGhpcyxcImRlcHRoUmF5c0J1ZmZlclwiKSx0aGlzLnZvbHVtZT1lLHRoaXMuaW5pdFBpcGVsaW5lKCl9aW5pdFBpcGVsaW5lKCl7dGhpcy5jb21wdXRlU2hhZGVyPW5ldyBiZShVaCk7bGV0IGU9QS5zZXR0aW5nLmdpLHQ9ZS5vY3RSVE1heFNpemUqZS5vY3RSVE1heFNpemU7dGhpcy5pcnJhZGlhbmNlQnVmZmVyPW5ldyBnZSh0KjQsR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCksdGhpcy5jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VCdWZmZXIoXCJpcnJhZGlhbmNlQnVmZmVyXCIsdGhpcy5pcnJhZGlhbmNlQnVmZmVyKSx0aGlzLmRlcHRoQnVmZmVyPW5ldyBnZSh0KjQsR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCksdGhpcy5jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VCdWZmZXIoXCJkZXB0aEJ1ZmZlclwiLHRoaXMuZGVwdGhCdWZmZXIpLHRoaXMuZGVwdGhSYXlzQnVmZmVyPW5ldyBnZSg0MDk2KjQqMioyKjIsR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyksdGhpcy5jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VCdWZmZXIoXCJkZXB0aFJheXNCdWZmZXJcIix0aGlzLmRlcHRoUmF5c0J1ZmZlciksdGhpcy5jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VCdWZmZXIoXCJwcm9iZXNcIix0aGlzLnZvbHVtZS5wcm9iZXNCdWZmZXIpLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTdG9yYWdlQnVmZmVyKFwidW5pZm9ybURhdGFcIix0aGlzLnZvbHVtZS5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyKSx0aGlzLmNvbXB1dGVTaGFkZXIuc2V0U3RvcmFnZUJ1ZmZlcihcIm1vZGVsc1wiLHBlLm1vZGVsTWF0cml4QmluZEdyb3VwLm1hdHJpeEJ1ZmZlckRzdCl9c2V0VGV4dHVyZXMoZSx0LHIpe3RoaXMucHJvYmVJcnJhZGlhbmNlTWFwPXQsdGhpcy5wcm9iZURlcHRoTWFwPXI7bGV0IHM9ZVswXSxhPWVbMV0sbj1lWzJdO3RoaXMuY29tcHV0ZVNoYWRlci5zZXRTdG9yYWdlVGV4dHVyZShcInByb2JlSXJyYWRpYW5jZU1hcFwiLHRoaXMucHJvYmVJcnJhZGlhbmNlTWFwKSx0aGlzLmNvbXB1dGVTaGFkZXIuc2V0U3RvcmFnZVRleHR1cmUoXCJwcm9iZURlcHRoTWFwXCIsdGhpcy5wcm9iZURlcHRoTWFwKSx0aGlzLmNvbXB1dGVTaGFkZXIuc2V0U2FtcGxlclRleHR1cmUoXCJwb3NpdGlvbk1hcFwiLHMpLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcIm5vcm1hbE1hcFwiLGEpLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcImNvbG9yTWFwXCIsbil9cmVhZEJ1ZmZlcigpe3JldHVybiB0aGlzLmRlcHRoUmF5c0J1ZmZlci5yZWFkQnVmZmVyKCl9Y29tcHV0ZShlLHQpe2xldCByPXRoaXMudm9sdW1lLnNldHRpbmcscz13LmJlZ2luQ29tbWFuZEVuY29kZXIoKSxhPVEuaW5zdGFuY2UuZ2V0UHJvYmVzKGUuc2NlbmUpO3RoaXMuY29tcHV0ZVNoYWRlci53b3JrZXJTaXplWD1yLm9jdFJUU2lkZVNpemUvOCx0aGlzLmNvbXB1dGVTaGFkZXIud29ya2VyU2l6ZVk9ci5vY3RSVFNpZGVTaXplLzgsdGhpcy5jb21wdXRlU2hhZGVyLndvcmtlclNpemVaPWEubGVuZ3RoLHcuY29tcHV0ZUNvbW1hbmQocyxbdGhpcy5jb21wdXRlU2hhZGVyXSl9fWxldCBOaD1gXG4gICNpbmNsdWRlIFwiTWF0aFNoYWRlclwiXG4gICNpbmNsdWRlIFwiSXJyYWRpYW5jZVZvbHVtZURhdGFfZnJhZ1wiXG5cbiAgc3RydWN0IElycmFkaWFuY2VGaWVsZCB7XG4gICAgICBwcm9iZVN0YXJ0UG9zaXRpb246IHZlYzQ8ZjMyPixcbiAgICAgIHByb2JlQ291bnRzOnZlYzQ8ZjMyPixcbiAgICAgIHByb2JlU3RlcDpmMzIsXG4gICAgICBpcnJhZGlhbmNlVGV4dHVyZVdpZHRoOmYzMixcbiAgICAgIGlycmFkaWFuY2VUZXh0dXJlSGVpZ2h0OmYzMixcbiAgICAgIGlycmFkaWFuY2VQcm9iZVNpZGVMZW5ndGg6ZjMyLFxuICB9O1xuXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXIgb3V0cHV0QnVmZmVyIDogdGV4dHVyZV9zdG9yYWdlXzJkPHJnYmExNmZsb2F0LCB3cml0ZT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSxyZWFkPiB1bmlmb3JtRGF0YSA6IElycmFkaWFuY2VWb2x1bWVEYXRhIDtcblxuICBAZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyIG5vcm1hbE1hcFNhbXBsZXIgOiBzYW1wbGVyO1xuICBAZ3JvdXAoMSkgQGJpbmRpbmcoMSkgdmFyIG5vcm1hbE1hcCA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICBAZ3JvdXAoMSkgQGJpbmRpbmcoMikgdmFyIGNvbG9yTWFwU2FtcGxlciA6IHNhbXBsZXI7XG4gIEBncm91cCgxKSBAYmluZGluZygzKSB2YXIgY29sb3JNYXAgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgQGdyb3VwKDEpIEBiaW5kaW5nKDQpIHZhciBsaXRNYXBTYW1wbGVyIDogc2FtcGxlcjtcbiAgQGdyb3VwKDEpIEBiaW5kaW5nKDUpIHZhciBsaXRNYXAgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgQGdyb3VwKDEpIEBiaW5kaW5nKDYpIHZhciBpcnJhZGlhbmNlTWFwU2FtcGxlciA6IHNhbXBsZXI7XG4gIEBncm91cCgxKSBAYmluZGluZyg3KSB2YXIgaXJyYWRpYW5jZU1hcCA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICB2YXI8cHJpdmF0ZT4gd3NuOnZlYzM8ZjMyPjtcbiAgdmFyPHByaXZhdGU+IHVsaXRDb2xvcjp2ZWM0PGYzMj47XG4gIHZhcjxwcml2YXRlPiBsaXRDb2xvcjp2ZWM0PGYzMj47XG4gIHZhcjxwcml2YXRlPiBpcnJhZGlhbmNlRmllbGRTdXJmYWNlIDogSXJyYWRpYW5jZUZpZWxkIDtcbiAgdmFyPHByaXZhdGU+IHByb2JlSUQ6dTMyO1xuXG4gIHZhcjxwcml2YXRlPiBxdWF0ZXJuaW9uOnZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPigwLjAsIC0wLjcwNzEwNjc4MTE4NjU0NzUsIDAuNzA3MTA2NzgxMTg2NTQ3NSwgMC4wKTtcblxuICBmbiBnZXRJcnJhZGlhbmNlRmllbGRTdXJmYWNlKCkgLT4gSXJyYWRpYW5jZUZpZWxke1xuICAgIGxldCBkYXRhID0gdW5pZm9ybURhdGE7XG4gICAgaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZVN0YXJ0UG9zaXRpb24gPSB2ZWM0PGYzMj4oZGF0YS5zdGFydFgsIGRhdGEuc3RhcnRZLCBkYXRhLnN0YXJ0WiwgMC4wKTtcbiAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLnByb2JlQ291bnRzID0gdmVjNDxmMzI+KGRhdGEuZ3JpZFhDb3VudCwgZGF0YS5ncmlkWUNvdW50LCBkYXRhLmdyaWRaQ291bnQsIDAuMCk7XG4gICAgaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZVN0ZXAgPSBkYXRhLlByb2JlU3BhY2U7XG4gICAgaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5pcnJhZGlhbmNlVGV4dHVyZVdpZHRoID0gZGF0YS5PY3RSVE1heFNpemU7XG4gICAgaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5pcnJhZGlhbmNlVGV4dHVyZUhlaWdodCA9IGRhdGEuT2N0UlRNYXhTaXplO1xuICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVByb2JlU2lkZUxlbmd0aCA9IGRhdGEuT2N0UlRTaWRlU2l6ZTtcbiAgICByZXR1cm4gaXJyYWRpYW5jZUZpZWxkU3VyZmFjZTtcbiAgfVxuXG4gIGZuIHJvdGF0ZURpcihuOnZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+e1xuICAgICByZXR1cm4gbm9ybWFsaXplKGFwcGx5UXVhdGVybmlvbigtbiwgcXVhdGVybmlvbikpO1xuICB9XG5cbiAgZm4gc2FtcGxlTGl0Q29sb3IodXY6dmVjMjxpMzI+KSAtPiB2ZWM0PGYzMj5cbiAge1xuICAgICAgdmFyIG9jMTp2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlTGV2ZWwobGl0TWFwLCBsaXRNYXBTYW1wbGVyLCB2ZWMyPGYzMj4oMC4wKSwgMC4wKTtcbiAgICAgIHZhciBvYzp2ZWM0PGYzMj4gPSB0ZXh0dXJlTG9hZChsaXRNYXAsIHV2LCAwKTtcbiAgICAgIHJldHVybiBvYztcbiAgfVxuXG4gIGZuIHNhbXBsZU5vcm1hbCh1djp2ZWMyPGkzMj4pIC0+IHZlYzQ8ZjMyPlxuICB7XG4gICAgICB2YXIgb2MxOnZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGVMZXZlbChub3JtYWxNYXAsIG5vcm1hbE1hcFNhbXBsZXIsIHZlYzI8ZjMyPigwLjApLCAwLjApO1xuICAgICAgdmFyIG9jOnZlYzQ8ZjMyPiA9IHRleHR1cmVMb2FkKG5vcm1hbE1hcCwgdXYsIDApO1xuICAgICAgcmV0dXJuIG9jO1xuICB9XG5cbiAgZm4gc2FtcGxlQ29sb3IodXY6dmVjMjxpMzI+KSAtPiB2ZWM0PGYzMj5cbiAge1xuICAgICAgdmFyIG9jMTp2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlTGV2ZWwoY29sb3JNYXAsIGNvbG9yTWFwU2FtcGxlciwgdmVjMjxmMzI+KDAuMCksIDAuMCk7XG4gICAgICB2YXIgb2M6dmVjNDxmMzI+ID0gdGV4dHVyZUxvYWQoY29sb3JNYXAsIHV2LCAwKTtcbiAgICAgIHJldHVybiBvYztcbiAgfVxuXG4gIGZuIHNhbXBsZVByb2JlKGZyYWdDb29yZDp2ZWMyPHUzMj4pe1xuICAgIHZhciB1diA9IHZlYzI8aTMyPihpMzIoZnJhZ0Nvb3JkLngpLCBpMzIoZnJhZ0Nvb3JkLnkpKSA7XG5cbiAgICBsaXRDb2xvciA9IHNhbXBsZUxpdENvbG9yKHV2KTtcblxuICAgIHZhciBub3JtYWxNYXAgPSBzYW1wbGVOb3JtYWwodXYpO1xuICAgIHdzbiA9IG5vcm1hbE1hcC54eXogKiAyLjAgLSAxLjA7XG5cbiAgICB1bGl0Q29sb3IgPSBzYW1wbGVDb2xvcih1dik7XG4gIH1cblxuICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoIDggLCA4ICwgMSApXG4gIGZuIENzTWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSW52b2NhdGlvbl9pZCA6IHZlYzM8dTMyPilcbiAge1xuICAgIGdldElycmFkaWFuY2VGaWVsZFN1cmZhY2UoKTtcbiAgICB2YXIgZnJhZ0Nvb3JkID0gdmVjMjx1MzI+KCBnbG9iYWxJbnZvY2F0aW9uX2lkLngsIGdsb2JhbEludm9jYXRpb25faWQueSk7XG4gICAgcHJvYmVJRCA9IGdsb2JhbEludm9jYXRpb25faWQuejtcbiAgICBmcmFnQ29vcmQgPSBmcmFnQ29vcmQgKyBnZXRDb29yZE9mZnNldChwcm9iZUlEKTtcblxuICAgIHNhbXBsZVByb2JlKGZyYWdDb29yZCk7XG5cbiAgICBsZXQgaXJyYWRpYW5jZSA9IGdldElycmFkaWFuY2VDb2xvcigpO1xuICAgIGxldCByZXN1bHQgPSBibGVuZElycmFkaWFuY2VDb2xvcihpcnJhZGlhbmNlKTtcbiAgICB0ZXh0dXJlU3RvcmUob3V0cHV0QnVmZmVyLCB2ZWMyPGkzMj4oZnJhZ0Nvb3JkKSwgcmVzdWx0KTtcbiAgfVxuXG4gIGZuIGJsZW5kSXJyYWRpYW5jZUNvbG9yKGlycmFkaWFuY2U6dmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj57XG4gICAgIHZhciBib3VuY2VDb2xvciA9IGlycmFkaWFuY2UgKiB1bGl0Q29sb3I7XG4gICAgIGxldCBib3VuY2VJbnRlbnNpdHkgPSBnZXRCb3VuY2VJbnRlbnNpdHkodW5pZm9ybURhdGEuYm91bmNlSW50ZW5zaXR5KTtcbiAgICAgbGV0IGNvbnNlcnZhdGlvbjEgPSAxLjAgLyBzcXJ0KCgxLjAgKyBib3VuY2VJbnRlbnNpdHkgKiAwLjU1KSk7XG4gICAgIGxldCBjb25zZXJ2YXRpb24yID0gMS4wIC8gc3FydCgoMS4wICsgYm91bmNlSW50ZW5zaXR5KSk7XG4gICAgIHZhciByZXN1bHQgPSBsaXRDb2xvciAqIGNvbnNlcnZhdGlvbjIgKyBib3VuY2VDb2xvciAqIHNxcnQoYm91bmNlSW50ZW5zaXR5KSAqIGNvbnNlcnZhdGlvbjE7XG4gICAgIHJldHVybiB2ZWM0PGYzMj4ocmVzdWx0Lnh5eiwgbGl0Q29sb3Iudyk7XG4gIH1cblxuICBmbiBnZXRCb3VuY2VJbnRlbnNpdHkoaW50ZW5zaXR5OmYzMikgLT4gZjMyIHtcbiAgICB2YXIgdmFsdWUgPSBjbGFtcChpbnRlbnNpdHksIDAuMCwgMS4wKSAqIDEwLjA7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZm4gZ2V0Q29vcmRPZmZzZXQoaWQ6dTMyKSAtPiB2ZWMyPHUzMj57XG4gICAgICB2YXIgZnVsbENvbCA9IHUzMih1bmlmb3JtRGF0YS5Qcm9iZVNvdXJjZVRleHR1cmVTaXplIC8gdW5pZm9ybURhdGEuUHJvYmVTaXplKTtcbiAgICAgIHZhciBvZmZzZXRTYW1wbGVVdiA9IHZlYzI8dTMyPiggKGlkIC8gZnVsbENvbCkgKiA2dSAsIGlkICUgZnVsbENvbCkgKiB1MzIodW5pZm9ybURhdGEuUHJvYmVTaXplKTtcbiAgICAgIHJldHVybiBvZmZzZXRTYW1wbGVVdjtcbiAgfVxuXG4gIGZuIGdldElycmFkaWFuY2VDb2xvcigpIC0+IHZlYzQ8ZjMyPntcbiAgICAgdmFyIHByb2JlSXJyYWRpYW5jZTogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KDAuMCk7XG4gICAgIGlmKGxlbmd0aCh3c24pID4gMC4wMSl7XG4gICAgICAgcHJvYmVJcnJhZGlhbmNlID0gZ2V0SXJyZGlhY2VJbmRleChpMzIocHJvYmVJRCksIHdzbik7XG4gICAgIH1cbiAgICAgcmV0dXJuIHByb2JlSXJyYWRpYW5jZTtcbiAgfVxuXG4gIGZuIGdldElycmRpYWNlSW5kZXgoaW5kZXg6aTMyLCB3c246dmVjMzxmMzI+KSAtPiB2ZWM0PGYzMj57XG4gICAgdmFyIHdzTiA9IHJvdGF0ZURpcih3c24ueHl6KTtcbiAgICB2YXIgdGV4Q29vcmQ6dmVjMjxmMzI+ID0gdGV4dHVyZUNvb3JkRnJvbURpcmVjdGlvbih3c04sXG4gICAgICBpbmRleCxcbiAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVRleHR1cmVXaWR0aCxcbiAgICAgIGlycmFkaWFuY2VGaWVsZFN1cmZhY2UuaXJyYWRpYW5jZVRleHR1cmVIZWlnaHQsXG4gICAgICBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VQcm9iZVNpZGVMZW5ndGgpO1xuXG4gICAgdmFyIHByb2JlSXJyYWRpYW5jZTogdmVjMzxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKGlycmFkaWFuY2VNYXAsIGlycmFkaWFuY2VNYXBTYW1wbGVyLCB0ZXhDb29yZCwgMC4wKS54eXo7XG4gICAgcmV0dXJuIHZlYzQ8ZjMyPihwcm9iZUlycmFkaWFuY2UsIDEuMCk7XG4gIH1cblxuICBmbiB0ZXh0dXJlQ29vcmRGcm9tRGlyZWN0aW9uKGRpcjp2ZWMzPGYzMj4sIHByb2JlSW5kZXg6aTMyLCB3aWR0aDpmMzIsIGhlaWdodDpmMzIsIHNpZGVMZW5ndGg6ZjMyKSAtPiB2ZWMyPGYzMj5cbiAge1xuICAgICAgdmFyIHV2ID0gZ2V0V3JpdGVPY3RVVkJ5SUQoZGlyLCB1MzIocHJvYmVJbmRleCksIHNpZGVMZW5ndGgpIDtcbiAgICAgIHV2LnggPSB1di54IC8gaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5pcnJhZGlhbmNlVGV4dHVyZVdpZHRoO1xuICAgICAgdXYueSA9IHV2LnkgLyBpcnJhZGlhbmNlRmllbGRTdXJmYWNlLmlycmFkaWFuY2VUZXh0dXJlSGVpZ2h0O1xuICAgICAgcmV0dXJuIHV2IDtcbiAgfVxuXG4gIGZuIGdldFdyaXRlT2N0VVZCeUlEKGRpcjp2ZWMzPGYzMj4gLCBwcm9iZUlEOnUzMiwgc2l6ZTogZjMyKSAtPiB2ZWMyPGYzMj5cbiAge1xuICAgICAgdmFyIGJsb2NrQ291bnQgPSB1MzIoaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZUNvdW50cy54ICogaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZUNvdW50cy56KSA7XG4gICAgICB2YXIgb2Zmc2V0WCA9IChwcm9iZUlEICUgYmxvY2tDb3VudCkgJSB1MzIoaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZUNvdW50cy54KSA7XG4gICAgICB2YXIgb2Zmc2V0WSA9IHUzMihpcnJhZGlhbmNlRmllbGRTdXJmYWNlLnByb2JlQ291bnRzLnogLSAxLjApIC0gKHByb2JlSUQgJSBibG9ja0NvdW50KSAvIHUzMihpcnJhZGlhbmNlRmllbGRTdXJmYWNlLnByb2JlQ291bnRzLngpIDtcbiAgICAgIHZhciBvZmZzZXRaID0gcHJvYmVJRCAvIGJsb2NrQ291bnQgO1xuXG4gICAgICB2YXIgcGl4ZWxDb29yZCA9ICgoIG9jdEVuY29kZShkaXIpICsgMS4wICkgKiAwLjUpICogdmVjMjxmMzI+KHNpemUsc2l6ZSkgO1xuXG4gICAgICB2YXIgYmxvY2tPZmZzZXQgPSB2ZWMyPGYzMj4oMC4wKTtcbiAgICAgIGJsb2NrT2Zmc2V0LnggPSBmMzIob2Zmc2V0WCkgKiBzaXplO1xuICAgICAgYmxvY2tPZmZzZXQueSA9IGYzMihvZmZzZXRZKSAqIHNpemUgKyBmMzIob2Zmc2V0WikgKiBmMzIoaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5wcm9iZUNvdW50cy56KSAqIHNpemU7XG5cbiAgICAgIGxldCBtYXBIZWlnaHQgPSB1MzIoaXJyYWRpYW5jZUZpZWxkU3VyZmFjZS5pcnJhZGlhbmNlVGV4dHVyZUhlaWdodCk7XG4gICAgICB2YXIgcHJvYmVDb3VudHM6dmVjMzxmMzI+ID0gdmVjMzxmMzI+KGlycmFkaWFuY2VGaWVsZFN1cmZhY2UucHJvYmVDb3VudHMueHl6KTtcblxuICAgICAgdmFyIGdyaWRPZmZzZXRGcm9tID0gdmVjMjxpMzI+KGJsb2NrT2Zmc2V0KSArIDE7XG4gICAgICB2YXIgZ3JpZE9mZnNldFRvID0gb2Zmc2V0QnlDb2woZ3JpZE9mZnNldEZyb20sIHNpemUsIG1hcEhlaWdodCwgcHJvYmVDb3VudHMpO1xuXG4gICAgICBwaXhlbENvb3JkID0gcGl4ZWxDb29yZCArIHZlYzI8ZjMyPihncmlkT2Zmc2V0VG8gLSAxKSArIHZlYzI8ZjMyPih2ZWMyPGkzMj4odmVjMjxmMzI+KGdyaWRPZmZzZXRUbykgLyBzaXplKSAqIDIpO1xuXG4gICAgICByZXR1cm4gcGl4ZWxDb29yZCArIDEuMCA7XG4gIH1cblxuICBmbiBvZmZzZXRCeUNvbChwaXhlbENvb3JkMDp2ZWMyPGkzMj4sIG9jdFNpZGVTaXplOmYzMiwgbWFwSGVpZ2h0OnUzMiwgY291bnRzOnZlYzM8ZjMyPikgLT4gdmVjMjxpMzI+XG4gIHtcbiAgICB2YXIgcGl4ZWxDb29yZCA9IHBpeGVsQ29vcmQwO1xuICAgIGxldCBibG9ja1NpemU6dmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy54KSwgIGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy56KSk7XG4gICAgbGV0IGJsb2NrU2l6ZVlCb3JkZXI6aTMyID0gaTMyKChvY3RTaWRlU2l6ZSArIDIuMCkgKiBjb3VudHMueik7XG4gICAgbGV0IGJsb2NrTWF4Um93Qm9yZGVyOmkzMiA9IGkzMihtYXBIZWlnaHQpIC8gYmxvY2tTaXplWUJvcmRlcjtcbiAgICBsZXQgcGl4ZWxDb3VudFlNYXg6aTMyID0gYmxvY2tNYXhSb3dCb3JkZXIgKiBpMzIob2N0U2lkZVNpemUgKiBjb3VudHMueik7XG4gICAgbGV0IGNvbDppMzIgPSBwaXhlbENvb3JkLnkgLyBwaXhlbENvdW50WU1heDtcblxuICAgIHBpeGVsQ29vcmQueCA9IGNvbCAqIGkzMihvY3RTaWRlU2l6ZSAqIGNvdW50cy54KSArIHBpeGVsQ29vcmQueDtcbiAgICBwaXhlbENvb3JkLnkgPSBwaXhlbENvb3JkLnkgJSBwaXhlbENvdW50WU1heDtcblxuICAgIHJldHVybiBwaXhlbENvb3JkO1xuICB9XG5gO2NsYXNzIEZoe2NvbnN0cnVjdG9yKGUpe28odGhpcyxcImJsZW5kVGV4dHVyZVwiKSxvKHRoaXMsXCJ2b2x1bWVcIiksbyh0aGlzLFwiY29tcHV0ZXJTaGFkZXJcIiksdGhpcy52b2x1bWU9ZSx0aGlzLmluaXRQaXBlbGluZSgpfWluaXRQaXBlbGluZSgpe2xldCBlPUEuc2V0dGluZy5naTt0aGlzLmJsZW5kVGV4dHVyZT1uZXcgb2UoZS5wcm9iZVNvdXJjZVRleHR1cmVTaXplLGUucHJvYmVTb3VyY2VUZXh0dXJlU2l6ZSxHLnJnYmExNmZsb2F0LCExLEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElORyksdGhpcy5jb21wdXRlclNoYWRlcj1uZXcgYmUoTmgpLHRoaXMuY29tcHV0ZXJTaGFkZXIuc2V0U3RvcmFnZVRleHR1cmUoXCJvdXRwdXRCdWZmZXJcIix0aGlzLmJsZW5kVGV4dHVyZSksdGhpcy5jb21wdXRlclNoYWRlci5zZXRTdG9yYWdlQnVmZmVyKFwidW5pZm9ybURhdGFcIix0aGlzLnZvbHVtZS5pcnJhZGlhbmNlVm9sdW1lQnVmZmVyKX1zZXRJbnB1dHMoZSl7bGV0IHQ9ZVswXSxyPWVbMV0scz1lWzJdLGE9ZVszXTt0aGlzLmNvbXB1dGVyU2hhZGVyLnNldFNhbXBsZXJUZXh0dXJlKFwibm9ybWFsTWFwXCIsdCksdGhpcy5jb21wdXRlclNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcImNvbG9yTWFwXCIsciksdGhpcy5jb21wdXRlclNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcImxpdE1hcFwiLHMpLHRoaXMuY29tcHV0ZXJTaGFkZXIuc2V0U2FtcGxlclRleHR1cmUoXCJpcnJhZGlhbmNlTWFwXCIsYSl9Y29tcHV0ZShlLHQpe2xldCByPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLHM9dGhpcy52b2x1bWUuc2V0dGluZyxhPXMucHJvYmVYQ291bnQqcy5wcm9iZVlDb3VudCpzLnByb2JlWkNvdW50LG49cy5wcm9iZVNpemU7dGhpcy5jb21wdXRlclNoYWRlci53b3JrZXJTaXplWD1uKjYvOCx0aGlzLmNvbXB1dGVyU2hhZGVyLndvcmtlclNpemVZPW4vOCx0aGlzLmNvbXB1dGVyU2hhZGVyLndvcmtlclNpemVaPWEsdy5jb21wdXRlQ29tbWFuZChyLFt0aGlzLmNvbXB1dGVyU2hhZGVyXSl9fWxldCBraD1gXG5cbiNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG4jaW5jbHVkZSBcIk1hdGhTaGFkZXJcIlxuI2luY2x1ZGUgXCJGYXN0TWF0aFNoYWRlclwiXG4jaW5jbHVkZSBcIkNvbG9yVXRpbFwiXG5cbnN0cnVjdCBDb25zdFVuaWZvcm17XG4gICBzY3JlZW5XaWR0aDpmMzIsXG4gICBzY3JlZW5IZWlnaHQ6ZjMyXG59XG5cbnN0cnVjdCBMaWdodERhdGEge1xuICAgICBpbmRleDpmMzIsXG4gICAgIGxpZ2h0VHlwZTppMzIsXG4gICAgIHJhZGl1czpmMzIsXG4gICAgIGxpbmVhcjpmMzIsXG4gICAgIFxuICAgICBwb3NpdGlvbjp2ZWMzPGYzMj4sXG4gICAgIGxpZ2h0TWF0cml4SW5kZXg6ZjMyLFxuXG4gICAgIGRpcmVjdGlvbjp2ZWMzPGYzMj4sXG4gICAgIHF1YWRyYXRpYzpmMzIsXG5cbiAgICAgbGlnaHRDb2xvcjp2ZWMzPGYzMj4sXG4gICAgIGludGVuc2l0eTpmMzIsXG5cbiAgICAgaW5uZXJDdXRPZmYgOmYzMixcbiAgICAgb3V0ZXJDdXRPZmY6ZjMyLFxuICAgICByYW5nZSA6ZjMyLFxuICAgICBjYXN0U2hhZG93OmkzMixcblxuICAgICBsaWdodFRhbmdlbnQ6dmVjMzxmMzI+LFxuICAgICBpZXM6ZjMyLFxufTtcblxuc3RydWN0IFVuaWZvcm1zIHtcbiAgICAgbWF0cml4IDogYXJyYXk8bWF0NHg0PGYzMj4+XG4gfTtcblxuY29uc3QgUG9pbnRMaWdodFR5cGUgPSAxO1xuY29uc3QgRGlyZWN0TGlnaHRUeXBlID0gMjtcbmNvbnN0IFNwb3RMaWdodFR5cGUgPSAzO1xuXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIG91dHB1dEJ1ZmZlciA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciBwcmVmaWx0ZXJNYXBTYW1wbGVyOiBzYW1wbGVyO1xuQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhciBwcmVmaWx0ZXJNYXA6IHRleHR1cmVfY3ViZTxmMzI+O1xuXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyIHBvc2l0aW9uTWFwU2FtcGxlciA6IHNhbXBsZXI7XG5AZ3JvdXAoMSkgQGJpbmRpbmcoMSkgdmFyIHBvc2l0aW9uTWFwIDogdGV4dHVyZV8yZDxmMzI+O1xuXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMikgdmFyIG5vcm1hbE1hcFNhbXBsZXIgOiBzYW1wbGVyO1xuQGdyb3VwKDEpIEBiaW5kaW5nKDMpIHZhciBub3JtYWxNYXAgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbkBncm91cCgxKSBAYmluZGluZyg0KSB2YXIgY29sb3JNYXBTYW1wbGVyIDogc2FtcGxlcjtcbkBncm91cCgxKSBAYmluZGluZyg1KSB2YXIgY29sb3JNYXAgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbkBncm91cCgxKSBAYmluZGluZyg2KSB2YXIgc2hhZG93TWFwU2FtcGxlciA6IHNhbXBsZXJfY29tcGFyaXNvbjtcbkBncm91cCgxKSBAYmluZGluZyg3KSB2YXIgc2hhZG93TWFwIDogdGV4dHVyZV9kZXB0aF8yZF9hcnJheTtcblxuQGdyb3VwKDEpIEBiaW5kaW5nKDgpIHZhciBwb2ludFNoYWRvd01hcFNhbXBsZXI6IHNhbXBsZXI7XG5AZ3JvdXAoMSkgQGJpbmRpbmcoOSkgdmFyIHBvaW50U2hhZG93TWFwOiB0ZXh0dXJlX2RlcHRoX2N1YmVfYXJyYXkgO1xuXG5AZ3JvdXAoMikgQGJpbmRpbmcoMClcbnZhcjxzdG9yYWdlLHJlYWQ+IGxpZ2h0QnVmZmVyOiBhcnJheTxMaWdodERhdGE+O1xuXG5AZ3JvdXAoMikgQGJpbmRpbmcoMSlcbnZhcjxzdG9yYWdlLCByZWFkPiBtb2RlbHMgOiBVbmlmb3Jtcztcblxuc3RydWN0IFNoYWRvd1N0cnVjdHtcbiBkaXJlY3RTaGFkb3dWaXNpYmlsaXR5OmYzMixcbiBwb2ludFNoYWRvd3M6YXJyYXk8ZjMyLDg+LFxufVxuXG52YXI8cHJpdmF0ZT4gc2hhZG93U3RydXQ6IFNoYWRvd1N0cnVjdCA7XG52YXI8cHJpdmF0ZT4gdWxpdENvbG9yOnZlYzM8ZjMyPjtcbnZhcjxwcml2YXRlPiB3UG9zaXRpb246dmVjMzxmMzI+O1xudmFyPHByaXZhdGU+IHdOb3JtYWw6dmVjMzxmMzI+O1xuXG5jb25zdCBMVU1FTiA9IDEwLjc2NDtcblxuZm4gc2FtcGxlUG9zaXRpb24odXY6dmVjMjxpMzI+KSAtPiB2ZWM0PGYzMj5cbntcbiAgIHZhciBvYzE6dmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKHBvc2l0aW9uTWFwLCBwb3NpdGlvbk1hcFNhbXBsZXIsIHZlYzI8ZjMyPigwLjApLCAwLjApO1xuICAgdmFyIG9jOnZlYzQ8ZjMyPiA9IHRleHR1cmVMb2FkKHBvc2l0aW9uTWFwLCB1diwgMCkgO1xuICAgcmV0dXJuIG9jO1xufVxuXG5mbiBzYW1wbGVOb3JtYWwodXY6dmVjMjxpMzI+KSAtPiB2ZWM0PGYzMj5cbntcbiAgIHZhciBvYzE6dmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKG5vcm1hbE1hcCwgbm9ybWFsTWFwU2FtcGxlciwgdmVjMjxmMzI+KDAuMCksIDAuMCk7XG4gICB2YXIgb2M6dmVjNDxmMzI+ID0gdGV4dHVyZUxvYWQobm9ybWFsTWFwLCB1diwgMCk7XG4gICByZXR1cm4gb2M7XG59XG5cbmZuIHNhbXBsZUNvbG9yKHV2OnZlYzI8aTMyPikgLT4gdmVjNDxmMzI+XG57XG4gICB2YXIgb2MxOnZlYzQ8ZjMyPiA9IHRleHR1cmVTYW1wbGVMZXZlbChjb2xvck1hcCwgY29sb3JNYXBTYW1wbGVyLCB2ZWMyPGYzMj4oMC4wKSwgMC4wKTtcbiAgIHZhciBvYzp2ZWM0PGYzMj4gPSB0ZXh0dXJlTG9hZChjb2xvck1hcCwgdXYsIDApO1xuICAgdWxpdENvbG9yID0gdmVjMyhvYy54eXopO1xuICAgcmV0dXJuIG9jO1xufVxuXG5jb25zdCBjc21Db3VudDppMzIgPSAke2x0LkNhc2NhZGVzfSA7XG5mbiBkaXJlY3RTaGFkb3dNYXBpbmcoUDp2ZWMzPGYzMj4sIE46dmVjMzxmMzI+LCBzaGFkb3dCaWFzOiBmMzIpICB7XG4gIGxldCBlbmFibGVDU006Ym9vbCA9IGdsb2JhbFVuaWZvcm0uZW5hYmxlQ1NNID4gMC41O1xuICB2YXIgbGlnaHQgPSBsaWdodEJ1ZmZlclswXTtcbiAgdmFyIHZpc2liaWxpdHkgPSAxLjA7XG4gIHZhciBzaGFkb3dJbmRleCA9IGkzMihsaWdodC5jYXN0U2hhZG93KTtcbiAgaWYgKHNoYWRvd0luZGV4ID49IDAgKSB7XG4gICAgdmFyIHNoYWRvd01hdHJpeDptYXQ0eDQ8ZjMyPjtcbiAgICBpZihlbmFibGVDU00gJiYgY3NtQ291bnQgPiAxKXtcbiAgICAgIGZvcih2YXIgY3NtOmkzMiA9IDA7IGNzbSA8IGNzbUNvdW50OyBjc20gKyspe1xuICAgICAgICB2YXIgY3NtU2hhZG93QmlhcyA9IGdsb2JhbFVuaWZvcm0uY3NtU2hhZG93Qmlhc1tjc21dO1xuICAgICAgICBzaGFkb3dNYXRyaXggPSBnbG9iYWxVbmlmb3JtLmNzbU1hdHJpeFtjc21dO1xuICAgICAgICBsZXQgY3NtU2hhZG93UmVzdWx0ID0gZGlyZWN0U2hhZG93TWFwaW5nSW5kZXgobGlnaHQsIHNoYWRvd01hdHJpeCwgUCwgTiwgY3NtLCBjc21TaGFkb3dCaWFzKTtcbiAgICAgICAgaWYoY3NtU2hhZG93UmVzdWx0LnkgPCAwLjUpe1xuICAgICAgICAgIHZpc2liaWxpdHkgPSBjc21TaGFkb3dSZXN1bHQueDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgc2hhZG93TWF0cml4ID0gZ2xvYmFsVW5pZm9ybS5zaGFkb3dNYXRyaXhbc2hhZG93SW5kZXhdO1xuICAgICAgdmlzaWJpbGl0eSA9IGRpcmVjdFNoYWRvd01hcGluZ0luZGV4KGxpZ2h0LCBzaGFkb3dNYXRyaXgsIFAsIE4sIHNoYWRvd0luZGV4LCBzaGFkb3dCaWFzKS54O1xuICAgIH1cbiAgfVxuICBzaGFkb3dTdHJ1dC5kaXJlY3RTaGFkb3dWaXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbn1cblxuZm4gZGlyZWN0U2hhZG93TWFwaW5nSW5kZXgobGlnaHQ6TGlnaHREYXRhLCBtYXRyaXg6bWF0NHg0PGYzMj4sIFA6dmVjMzxmMzI+LCBOOnZlYzM8ZjMyPiwgZGVwdGhUZXhJbmRleDppMzIsIHNoYWRvd0JpYXM6ZjMyKSAtPiB2ZWMyPGYzMj5cbntcbiAgdmFyIHZpc2liaWxpdHkgPSAxLjA7XG4gIHZhciBpc091dFNpZGVBcmVhOmYzMiA9IDEuMDtcbiAgdmFyIHNoYWRvd1Bvc1RtcCA9IG1hdHJpeCAqIHZlYzQ8ZjMyPihQLnh5eiwgMS4wKTtcbiAgdmFyIHNoYWRvd1BvcyA9IHNoYWRvd1Bvc1RtcC54eXogLyBzaGFkb3dQb3NUbXAudztcbiAgdmFyIHZhcnlpbmdfc2hhZG93VVYgPSBzaGFkb3dQb3MueHkgKiB2ZWMyPGYzMj4oMC41LCAtMC41KSArIHZlYzI8ZjMyPigwLjUsIDAuNSk7XG4gIGlmICh2YXJ5aW5nX3NoYWRvd1VWLnggPD0gMS4wXG4gICAgJiYgdmFyeWluZ19zaGFkb3dVVi54ID49IDAuMFxuICAgICYmIHZhcnlpbmdfc2hhZG93VVYueSA8PSAxLjBcbiAgICAmJiB2YXJ5aW5nX3NoYWRvd1VWLnkgPj0gMC4wXG4gICAgJiYgc2hhZG93UG9zVG1wLnogPD0gMS4wXG4gICAgJiYgc2hhZG93UG9zVG1wLnogPj0gMC4wKVxuICB7XG4gICAgaXNPdXRTaWRlQXJlYSA9IDAuMDtcbiAgICB2YXIgdXZPbmVQaXhlbCA9IDEuMCAvIHZlYzI8ZjMyPihnbG9iYWxVbmlmb3JtLnNoYWRvd01hcFNpemUpO1xuICAgIHZhciBOb0wgPSBhYnMoZG90KE4sIG5vcm1hbGl6ZShsaWdodC5kaXJlY3Rpb24pKSk7XG4gICAgdmFyIGJpYXMgPSBzaGFkb3dCaWFzIC8gbWF4KE5vTCwgMC4wMDAwMDEpO1xuICAgIHZpc2liaWxpdHkgPSB0ZXh0dXJlU2FtcGxlQ29tcGFyZUxldmVsKHNoYWRvd01hcCwgc2hhZG93TWFwU2FtcGxlciwgdmFyeWluZ19zaGFkb3dVViwgZGVwdGhUZXhJbmRleCwgc2hhZG93UG9zLnogLSBiaWFzKTtcbiAgICB2aXNpYmlsaXR5ICs9IDAuMDAxO1xuICB9XG4gIHJldHVybiB2ZWMyPGYzMj4odmlzaWJpbGl0eSwgaXNPdXRTaWRlQXJlYSk7XG59XG5cbmZuIHBvaW50U2hhZG93TWFwQ29tcGFyZShzaGFkb3dCaWFzOmYzMil7XG4gICBmb3IodmFyIGk6aTMyID0gaTMyKDApIDsgaSA8IGkzMig4KTsgaSA9IGkgKyAxIClcbiAgIHsgXG4gICAgICAgdmFyIHYgPSAxLjAgO1xuICAgICAgIGxldCBsaWdodCA9IGxpZ2h0QnVmZmVyW2ldIDtcbiAgICAgICBpZihsaWdodC5jYXN0U2hhZG93IDwgMCApe1xuICAgICAgICAgc2hhZG93U3RydXQucG9pbnRTaGFkb3dzW2ldID0gdiA7XG4gICAgICAgICBjb250aW51ZSA7XG4gICAgICAgfVxuXG4gICAgICAgbGV0IGZyZ1RvTGlnaHQgPSB3UG9zaXRpb24gLSBsaWdodC5wb3NpdGlvbi54eXo7XG4gICAgICAgdmFyIGRpcjp2ZWMzPGYzMj4gPSBub3JtYWxpemUoZnJnVG9MaWdodCkgIDtcblxuICAgICAgIHZhciBsZW4gPSBsZW5ndGgoZnJnVG9MaWdodCkgO1xuICAgICAgIHZhciBkZXB0aCA9IHRleHR1cmVTYW1wbGVMZXZlbChwb2ludFNoYWRvd01hcCxwb2ludFNoYWRvd01hcFNhbXBsZXIsZGlyLnh5eixpLDApOyBcbiAgICAgICBkZXB0aCAqPSBnbG9iYWxVbmlmb3JtLmZhciA7XG4gICAgICAgaWYoKGxlbiAtIHNoYWRvd0JpYXMpID4gZGVwdGgpe1xuICAgICAgICAgIHYgPSAwLjAgOyBcbiAgICAgICB9XG4gICAgICAgc2hhZG93U3RydXQucG9pbnRTaGFkb3dzW2ldID0gdiA7XG4gICB9XG59IFxuXG5mbiBkaXJlY3RMaWdodGluZyggYWxiZWRvOnZlYzM8ZjMyPiAsIFdQIDp2ZWMzPGYzMj4sIE46dmVjMzxmMzI+ICwgVjp2ZWMzPGYzMj4gLCBsaWdodDpMaWdodERhdGEgLCBzaGFkb3dCaWFzOmYzMiAgKSAtPiB2ZWMzPGYzMj4ge1xuIHZhciBMID0gLW5vcm1hbGl6ZShsaWdodC5kaXJlY3Rpb24ueHl6KSA7XG4gdmFyIE5vTCA9IG1heChkb3QoTixMKSwwLjApO1xuIGxldCBsaWdodENDID0gcG93KCBsaWdodC5saWdodENvbG9yLnJnYix2ZWMzPGYzMj4oMi4yKSk7XG4gdmFyIGxpZ2h0Q29sb3IgPSBnZXRIRFJDb2xvciggbGlnaHRDQyAsIGxpZ2h0LmxpbmVhciApIDtcbiB2YXIgYXR0ID0gbGlnaHQuaW50ZW5zaXR5IC8gTFVNRU4gO1xuIGlmKGxpZ2h0LmNhc3RTaGFkb3c+PTApe1xuICAgICBsaWdodENvbG9yICo9IHNoYWRvd1N0cnV0LmRpcmVjdFNoYWRvd1Zpc2liaWxpdHkgO1xuIH1cbiBsZXQgZmluYWxMaWdodCA9IChhbGJlZG8gLyBQSSkgKiBsaWdodENvbG9yICogTm9MICogYXR0ICogMi4wIDtcbiByZXR1cm4gZmluYWxMaWdodCA7XG59XG5cbmZuIHBvaW50TGlnaHRpbmcoIGFsYmVkbzp2ZWMzPGYzMj4sV1A6dmVjMzxmMzI+LCBOOnZlYzM8ZjMyPiwgVjp2ZWMzPGYzMj4sIGxpZ2h0OkxpZ2h0RGF0YSApIC0+IHZlYzM8ZjMyPiB7XG4gbGV0IGxpZ2h0UG9zID0gbW9kZWxzLm1hdHJpeFt1MzIobGlnaHQubGlnaHRNYXRyaXhJbmRleCldWzNdLnh5ejtcbiB2YXIgZGlyID0gbGlnaHRQb3MueHl6IC0gV1AgO1xuIGxldCBkaXN0ID0gbGVuZ3RoKGRpcik7XG4gdmFyIGNvbG9yID0gdmVjMzxmMzI+KDAuMCkgO1xuXG4gaWYoZGlzdCAhPSAwLjApe1xuICAgZGlyICo9IDEuMCAvIGRpc3QgO1xuIH1cblxuIGlmKCBhYnMoZGlzdCkgPCBsaWdodC5yYW5nZSApe1xuICAgICB2YXIgTCA9IGRpciA7XG4gICAgIHZhciBhdHRlbiA9IDEuMCA7XG4gICAgIGF0dGVuID0gMS4wIC0gc21vb3Roc3RlcCgwLjAsbGlnaHQucmFuZ2UsZGlzdCkgO1xuICAgICBhdHRlbiAqPSAxLjAgLyBtYXgobGlnaHQucmFkaXVzLDAuMDAwMSkgO1xuXG4gICAgIHZhciBsaWdodENvbG9yID0gbGlnaHQubGlnaHRDb2xvci5yZ2IgIDtcbiAgICAgbGlnaHRDb2xvciA9IGdldEhEUkNvbG9yKGxpZ2h0Q29sb3IgLCBsaWdodC5saW5lYXIgKSAqIGxpZ2h0LmludGVuc2l0eSAvIExVTUVOICogMi4wO1xuICAgICBjb2xvciA9IChhbGJlZG8gLyBQSSkgKiBsaWdodENvbG9yLnJnYiAqIGF0dGVuIDtcbiB9XG5cbiByZXR1cm4gIGNvbG9yICowLjA7XG59XG5cbmZuIHNwb3RMaWdodCggYWxiZWRvOnZlYzM8ZjMyPixXUDp2ZWMzPGYzMj4sIE46dmVjMzxmMzI+LCBWOnZlYzM8ZjMyPiwgbGlnaHQ6TGlnaHREYXRhICkgLT4gdmVjMzxmMzI+IHtcbiBsZXQgbGlnaHRQb3MgPSBtb2RlbHMubWF0cml4W3UzMihsaWdodC5saWdodE1hdHJpeEluZGV4KV1bM10ueHl6O1xuIHZhciBkaXIgPSBsaWdodFBvcy54eXogLSBXUCA7XG4gbGV0IGRpc3QgPSBsZW5ndGgoZGlyKSA7XG5cbiBpZihkaXN0ICE9IDAuMCl7XG4gICBkaXIgKj0gMS4wIC8gZGlzdCA7XG4gfVxuXG4gdmFyIGNvbG9yID0gdmVjMzxmMzI+KDAuMCkgO1xuIGlmKCBhYnMoZGlzdCkgPCBsaWdodC5yYW5nZSAqIDIuMCApe1xuICAgICB2YXIgTCA9IGRpciA7XG4gICAgIGxldCB0aGV0YSA9IGRvdCgtTCwgbm9ybWFsaXplKGxpZ2h0LmRpcmVjdGlvbikpO1xuICAgICBsZXQgYW5nbGUgPSBhY29zKHRoZXRhKSA7XG4gICAgIHZhciBhdHRlbiA9IDEuMCA7XG4gICAgIGF0dGVuID0gMS4wIC0gc21vb3Roc3RlcCgwLjAsbGlnaHQucmFuZ2UsZGlzdCkgO1xuICAgICBhdHRlbiAqPSAxLjAgLyBtYXgobGlnaHQucmFkaXVzLDAuMSkgO1xuICAgICBpZihhbmdsZSA8IGxpZ2h0Lm91dGVyQ3V0T2ZmKXtcbiAgICAgICBpZihhbmdsZSA+IGxpZ2h0LmlubmVyQ3V0T2ZmKXtcbiAgICAgICAgIGF0dGVuICo9IDEuMCAtIHNtb290aHN0ZXAobGlnaHQuaW5uZXJDdXRPZmYsIGxpZ2h0Lm91dGVyQ3V0T2ZmLCBhbmdsZSkgO1xuICAgICAgIH1cbiAgICAgfWVsc2V7XG4gICAgICAgYXR0ZW4gPSAwLjAgO1xuICAgICB9XG4gICAgIHZhciBsaWdodENvbG9yID0gbGlnaHQubGlnaHRDb2xvci5yZ2IgIDtcbiAgICAgbGlnaHRDb2xvciA9IGdldEhEUkNvbG9yKGxpZ2h0Q29sb3IgLCBsaWdodC5saW5lYXIgKSAqIGxpZ2h0LmludGVuc2l0eSAvIExVTUVOICogMi4wO1xuICAgICBjb2xvciA9IChhbGJlZG8gLyBQSSkgKiBsaWdodENvbG9yLnJnYiAqIGF0dGVuIDtcbiAgIH1cbiByZXR1cm4gIGNvbG9yIDtcbn1cblxuZm4gY29vcmRGdW4oZnJhZ0Nvb3JkOnZlYzI8dTMyPiktPiB2ZWM0PGYzMj57XG4gdmFyIHV2ID0gdmVjMjxpMzI+KGkzMihmcmFnQ29vcmQueCksIGkzMihmcmFnQ29vcmQueSkpIDtcbiB2YXIgcG9zID0gc2FtcGxlUG9zaXRpb24odXYpO1xuXG4gdmFyIG5vcm1hbE1hcCA9IHNhbXBsZU5vcm1hbCh1dik7XG4gdmFyIG5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWFwLnh5eiAqIDIuMCAtIDEuMCApO1xuXG4gdmFyIGNvbG9yID0gc2FtcGxlQ29sb3IodXYpO1xuIHZhciBlbWlzc2l2ZSA9IHZlYzQ8ZjMyPihwb3MuYSxub3JtYWxNYXAuYSxjb2xvci5hLDAuMCkgKiAxLjAgO1xuIGlmKHBvcy53ICsgMS4wID4gMTAwMDAuMCl7XG4gICByZXR1cm4gdmVjNDxmMzI+KGNvbG9yKTtcbiB9XG4gdmFyIFYgPSBub3JtYWxpemUocG9zLnh5eiAtIGdsb2JhbFVuaWZvcm0uY2FtZXJhV29ybGRNYXRyaXhbM10ueHl6KTtcbiB2YXIgTiA9IG5vcm1hbC54eXogO1xuXG4gd1Bvc2l0aW9uID0gcG9zLnh5ejtcbiB3Tm9ybWFsID0gTjtcblxuIGRpcmVjdFNoYWRvd01hcGluZyh3UG9zaXRpb24sIHdOb3JtYWwsIGdsb2JhbFVuaWZvcm0uc2hhZG93Qmlhcyk7XG4gcG9pbnRTaGFkb3dNYXBDb21wYXJlKGdsb2JhbFVuaWZvcm0uc2hhZG93Qmlhcyk7XG5cbiB2YXIgbGlnaHRpbmcgPSB2ZWMzPGYzMj4oMC4wKTtcbiBsZXQgbGlnaHRDb3VudCA9IDMyIDtcbiBmb3IodmFyIGk6aTMyID0gMCA7IGkgPCBsaWdodENvdW50IDsgaSA9IGkgKyAxIClcbiB7XG4gICAgIGxldCBsaWdodCA9IGxpZ2h0QnVmZmVyW2ldO1xuICAgICBzd2l0Y2ggKGxpZ2h0LmxpZ2h0VHlwZSkge1xuICAgICAgICAgY2FzZSBQb2ludExpZ2h0VHlwZToge1xuICAgICAgICAgICAgIGxpZ2h0aW5nICs9IHBvaW50TGlnaHRpbmcoY29sb3IucmdiLHBvcy54eXosTixWLGxpZ2h0KTtcbiAgICAgICAgIH1cbiAgICAgICAgIGNhc2UgRGlyZWN0TGlnaHRUeXBlOiB7XG4gICAgICAgICAgICAgbGlnaHRpbmcgKz0gZGlyZWN0TGlnaHRpbmcoY29sb3IucmdiLHBvcy54eXosTixWLGxpZ2h0LGdsb2JhbFVuaWZvcm0uc2hhZG93Qmlhcyk7XG4gICAgICAgICB9XG4gICAgICAgICBjYXNlIFNwb3RMaWdodFR5cGU6IHtcbiAgICAgICAgICAgICBsaWdodGluZyArPSBzcG90TGlnaHQoY29sb3IucmdiLHBvcy54eXosTixWLGxpZ2h0KTtcbiAgICAgICAgIH1cbiAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgIH1cbiAgICAgfVxuIH1cblxuIC8vIGxpZ2h0aW5nID0gdmVjMzxmMzI+KDEuMCkgLyAodmVjMzxmMzI+KDEuMCkgKyBsaWdodGluZy5yZ2IpICogbGlnaHRpbmcucmdiO1xuXG4gdmFyIHNreUxpZ2h0OiB2ZWMzPGYzMj4gPSBnbG9iYWxVbmlmb3JtLnNreUV4cG9zdXJlICogKHRleHR1cmVTYW1wbGVMZXZlbChwcmVmaWx0ZXJNYXAsIHByZWZpbHRlck1hcFNhbXBsZXIsIE4ueHl6LCA4LjAgKS5yZ2IpO1xuIC8vIHNreUxpZ2h0ID0gTGluZWFyVG9HYW1tYVNwYWNlKHNreUxpZ2h0KTtcbiAvLyBza3lMaWdodCA9IChjb2xvci5yZ2IgLyAzLjE0MTU5MjYgKSAqIHNreUxpZ2h0O1xuIC8vIHNreUxpZ2h0ID0gdmVjMzxmMzI+KDEuMCkgLyAodmVjMzxmMzI+KDEuMCkgKyBza3lMaWdodC5yZ2IpICogc2t5TGlnaHQucmdiO1xuXG4gbGlnaHRpbmcgPSBsaWdodGluZy5yZ2IgOy8vKyBza3lMaWdodC5yZ2IgO1xuXG4gcmV0dXJuIHZlYzQ8ZjMyPihsaWdodGluZy5yZ2IsY29sb3IudykrZW1pc3NpdmU7XG59XG5cbi8vIGZuIHZlcnRleFRvQ29vcmQodmVydGV4UG9zaXRpb246dmVjMzxmMzI+KSAtPiB2ZWM0PGYzMj57XG4vLyAgIHZhciB3b3JsZFBvcyA9IHZlYzQ8ZjMyPih2ZXJ0ZXhQb3NpdGlvbi54eXosIDEuMCk7XG4vLyAgIHZhciBmcmFnUG9zaXRpb24gPSBnbG9iYWxVbmlmb3JtLnZpZXdNYXQgKiB3b3JsZFBvcyA7XG4vLyAgIC8vIHZhciBwb3NpdGlvbiA9IGdsb2JhbFVuaWZvcm0ucHJvak1hdCAqIGZyYWdQb3NpdGlvbiA7XG4vLyAgIHJldHVybiBmcmFnUG9zaXRpb247XG4vLyB9XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSggOCAsIDggLCAxIClcbmZuIENzTWFpbiggQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4gLCBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSW52b2NhdGlvbl9pZCA6IHZlYzM8dTMyPilcbntcbiAgIHZhciBmcmFnQ29vcmQgPSB2ZWMyPHUzMj4oIGdsb2JhbEludm9jYXRpb25faWQueCwgZ2xvYmFsSW52b2NhdGlvbl9pZC55KTtcbiAgIHZhciBjb2xvciA9IGNvb3JkRnVuKGZyYWdDb29yZCk7XG4gICBcbiAgIC8vIGNvbG9yID0gdmVjNChwb3coY29sb3IucmdiLHZlYzM8ZjMyPigxLjAvMi40KSksMS4wKTtcbiAgIHRleHR1cmVTdG9yZShvdXRwdXRCdWZmZXIsIHZlYzI8aTMyPihmcmFnQ29vcmQpLGNvbG9yKTtcbn1cblxuYDtjbGFzcyB6aHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcImNvbXB1dGVTaGFkZXJcIiksbyh0aGlzLFwid29ybGRQb3NNYXBcIiksbyh0aGlzLFwid29ybGROb3JtYWxNYXBcIiksbyh0aGlzLFwiY29sb3JNYXBcIiksbyh0aGlzLFwic2hhZG93TWFwXCIpLG8odGhpcyxcInBvaW50U2hhZG93TWFwXCIpLG8odGhpcyxcImxpZ2h0aW5nVGV4dHVyZVwiKTtsZXQgZT1BLnNldHRpbmcuZ2k7dGhpcy5saWdodGluZ1RleHR1cmU9bmV3IG9lKGUucHJvYmVTb3VyY2VUZXh0dXJlU2l6ZSxlLnByb2JlU291cmNlVGV4dHVyZVNpemUsRy5yZ2JhMTZmbG9hdCwhMSxHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HfEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkcpfWNyZWF0ZShlKXtsZXQgdD1wZS5nZXRMaWdodEVudHJpZXMoZS5zY2VuZSk7dGhpcy5jb21wdXRlU2hhZGVyPW5ldyBiZShraCk7bGV0IHI9cGUuZ2V0Q2FtZXJhR3JvdXAoZS5jYW1lcmEpO3RoaXMuY29tcHV0ZVNoYWRlci5zZXRVbmlmb3JtQnVmZmVyKFwiZ2xvYmFsVW5pZm9ybVwiLHIudW5pZm9ybUdQVUJ1ZmZlciksdGhpcy5jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VUZXh0dXJlKFwib3V0cHV0QnVmZmVyXCIsdGhpcy5saWdodGluZ1RleHR1cmUpLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTdG9yYWdlQnVmZmVyKFwibGlnaHRCdWZmZXJcIix0LnN0b3JhZ2VHUFVCdWZmZXIpLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTdG9yYWdlQnVmZmVyKFwibW9kZWxzXCIscGUubW9kZWxNYXRyaXhCaW5kR3JvdXAubWF0cml4QnVmZmVyRHN0KSx0aGlzLmNvbXB1dGVTaGFkZXIuc2V0U2FtcGxlclRleHR1cmUoXCJwb3NpdGlvbk1hcFwiLHRoaXMud29ybGRQb3NNYXApLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcIm5vcm1hbE1hcFwiLHRoaXMud29ybGROb3JtYWxNYXApLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcImNvbG9yTWFwXCIsdGhpcy5jb2xvck1hcCksdGhpcy5jb21wdXRlU2hhZGVyLnNldFNhbXBsZXJUZXh0dXJlKFwic2hhZG93TWFwXCIsdGhpcy5zaGFkb3dNYXApLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcInBvaW50U2hhZG93TWFwXCIsdGhpcy5wb2ludFNoYWRvd01hcCksdGhpcy5jb21wdXRlU2hhZGVyLnNldFNhbXBsZXJUZXh0dXJlKFwicHJlZmlsdGVyTWFwXCIsQS5yZXMuZGVmYXVsdFNreSl9c2V0SW5wdXRzKGUpe3RoaXMud29ybGRQb3NNYXA9ZVswXSx0aGlzLndvcmxkTm9ybWFsTWFwPWVbMV0sdGhpcy5jb2xvck1hcD1lWzJdLHRoaXMuc2hhZG93TWFwPWVbM10sdGhpcy5wb2ludFNoYWRvd01hcD1lWzRdfWNvbXB1dGUoZSx0KXt0aGlzLmNvbXB1dGVTaGFkZXJ8fHRoaXMuY3JlYXRlKGUpO2xldCByPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLHM9QS5zZXR0aW5nLmdpO3RoaXMuY29tcHV0ZVNoYWRlci53b3JrZXJTaXplWD1zLnByb2JlU291cmNlVGV4dHVyZVNpemUvOCx0aGlzLmNvbXB1dGVTaGFkZXIud29ya2VyU2l6ZVk9cy5wcm9iZVNvdXJjZVRleHR1cmVTaXplLzgsdGhpcy5jb21wdXRlU2hhZGVyLndvcmtlclNpemVaPTEsdy5jb21wdXRlQ29tbWFuZChyLFt0aGlzLmNvbXB1dGVTaGFkZXJdKX19bGV0IEhzPW5ldyBqZShcIkdJUmVuZGVyU3RhcnRFdmVudFwiKSxDbz1uZXcgamUoXCJHSVJlbmRlckNvbXBsZXRlRXZlbnRcIik7Y2xhc3MgbWd7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJjb3VudFwiKSxvKHRoaXMsXCJjb21wbGV0ZVwiKX19Y2xhc3MgR2ggZXh0ZW5kcyBkaXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcImN1YmVDYW1lcmFcIiksbyh0aGlzLFwidm9sdW1lXCIpLG8odGhpcyxcInByb2JlQ291bnRQZXJGcmFtZVwiLDEpLG8odGhpcyxcIm5leHRQcm9iZUluZGV4XCIsLTEpLG8odGhpcyxcInRlbXBQcm9iZUxpc3RcIixbXSksbyh0aGlzLFwiaXNSZW5kZXJDbG91ZEdJXCIpLG8odGhpcyxcInByb2JlUmVuZGVyUmVzdWx0XCIpLG8odGhpcyxcInJlbmRlclN0YXR1c1wiLFwibm9uZVwiKSxvKHRoaXMsXCJwb3NpdGlvbk1hcFwiKSxvKHRoaXMsXCJub3JtYWxNYXBcIiksbyh0aGlzLFwiY29sb3JNYXBcIiksbyh0aGlzLFwicHJvYmVOZXh0XCIsMTI4KSxvKHRoaXMsXCJzaXplV1wiKSxvKHRoaXMsXCJzaXplSFwiKSxvKHRoaXMsXCJsaWdodGluZ1Bhc3NcIiksbyh0aGlzLFwiYm91bmNlUGFzc1wiKSxvKHRoaXMsXCJpcnJhZGlhbmNlQ29tcHV0ZVBhc3NcIiksbyh0aGlzLFwiaXJyYWRpYW5jZURlcHRoTWFwXCIpLG8odGhpcyxcImlycmFkaWFuY2VDb2xvck1hcFwiKSx0aGlzLnBhc3NUeXBlPXJlLkdJLHRoaXMudm9sdW1lPWU7bGV0IHQ9ZS5zZXR0aW5nO3RoaXMuY3ViZUNhbWVyYT1uZXcgUmgoLjAxLDVlMyksdGhpcy5zaXplVz10LnByb2JlU291cmNlVGV4dHVyZVNpemUsdGhpcy5zaXplSD10LnByb2JlU291cmNlVGV4dHVyZVNpemUsdGhpcy5wcm9iZU5leHQ9dC5wcm9iZVNvdXJjZVRleHR1cmVTaXplL3QucHJvYmVTaXplLHRoaXMuaW5pdElycmFkaWFuY2VNYXAoZSksdGhpcy5wcm9iZVJlbmRlclJlc3VsdD1uZXcgbWc7bGV0IHI9bmV3IExoKHRoaXMuc2l6ZVcsdGhpcy5zaXplSCk7dGhpcy5wb3NpdGlvbk1hcD1yLmF0dGFjaG1lbnRzWzBdLHRoaXMubm9ybWFsTWFwPXIuYXR0YWNobWVudHNbMV0sdGhpcy5jb2xvck1hcD1yLmF0dGFjaG1lbnRzWzJdLHRoaXMuc2V0UmVuZGVyU3RhdGVzKHIpfXNldElucHV0VGV4dHVyZShlKXt0aGlzLmxpZ2h0aW5nUGFzcz1uZXcgemgsdGhpcy5ib3VuY2VQYXNzPW5ldyBGaCh0aGlzLnZvbHVtZSksdGhpcy5pcnJhZGlhbmNlQ29tcHV0ZVBhc3M9bmV3IE9oKHRoaXMudm9sdW1lKSx0aGlzLmxpZ2h0aW5nUGFzcy5zZXRJbnB1dHMoW3RoaXMucG9zaXRpb25NYXAsdGhpcy5ub3JtYWxNYXAsdGhpcy5jb2xvck1hcCxlWzBdLGVbMV1dKSx0aGlzLmJvdW5jZVBhc3Muc2V0SW5wdXRzKFt0aGlzLm5vcm1hbE1hcCx0aGlzLmNvbG9yTWFwLHRoaXMubGlnaHRpbmdQYXNzLmxpZ2h0aW5nVGV4dHVyZSx0aGlzLmlycmFkaWFuY2VDb2xvck1hcF0pLHRoaXMuaXJyYWRpYW5jZUNvbXB1dGVQYXNzLnNldFRleHR1cmVzKFt0aGlzLnBvc2l0aW9uTWFwLHRoaXMubm9ybWFsTWFwLHRoaXMuYm91bmNlUGFzcy5ibGVuZFRleHR1cmVdLHRoaXMuaXJyYWRpYW5jZUNvbG9yTWFwLHRoaXMuaXJyYWRpYW5jZURlcHRoTWFwKX1zZXRJcnJhZGlhbmNlRGF0YShlLHQscixzKXtpZihyIT10aGlzLmlycmFkaWFuY2VDb2xvck1hcC53aWR0aHx8cyE9dGhpcy5pcnJhZGlhbmNlQ29sb3JNYXAuaGVpZ2h0KXtjb25zb2xlLmVycm9yKFwiaXJyYWRpYW5jZSBpbWFnZSBzaXplIG5vdCBtYXRjaCAhXCIpO3JldHVybn10aGlzLndyaXRlVG9UZXh0dXJlKHRoaXMuaXJyYWRpYW5jZUNvbG9yTWFwLGUscixzKSx0aGlzLndyaXRlVG9UZXh0dXJlKHRoaXMuaXJyYWRpYW5jZURlcHRoTWFwLHQscixzKX11cGRhdGVQcm9iZShlLHQscil7bGV0IHM9US5pbnN0YW5jZS5nZXRMaWdodHMoZS5zY2VuZSksYT10aGlzLnZvbHVtZS5zZXR0aW5nLnByb2JlU2l6ZTt0LmRyYXdDYWxsRnJhbWUrPTEsdGhpcy5jdWJlQ2FtZXJhLng9dC54LHRoaXMuY3ViZUNhbWVyYS55PXQueSx0aGlzLmN1YmVDYW1lcmEuej10LnosdGhpcy52b2x1bWUuc2V0dGluZy5kZWJ1Z0NhbWVyYT8odGhpcy5jdWJlQ2FtZXJhLng9ZS5jYW1lcmEudHJhbnNmb3JtLngsdGhpcy5jdWJlQ2FtZXJhLnk9ZS5jYW1lcmEudHJhbnNmb3JtLnksdGhpcy5jdWJlQ2FtZXJhLno9ZS5jYW1lcmEudHJhbnNmb3JtLnosdGhpcy5jdWJlQ2FtZXJhLnJvdGF0aW9uWD1lLmNhbWVyYS50cmFuc2Zvcm0ucm90YXRpb25YLHRoaXMuY3ViZUNhbWVyYS5yb3RhdGlvblk9ZS5jYW1lcmEudHJhbnNmb3JtLnJvdGF0aW9uWSx0aGlzLmN1YmVDYW1lcmEucm90YXRpb25aPWUuY2FtZXJhLnRyYW5zZm9ybS5yb3RhdGlvblopOih0aGlzLmN1YmVDYW1lcmEucm90YXRpb25YPXQucm90YXRpb25YLHRoaXMuY3ViZUNhbWVyYS5yb3RhdGlvblk9dC5yb3RhdGlvblksdGhpcy5jdWJlQ2FtZXJhLnJvdGF0aW9uWj10LnJvdGF0aW9uWik7bGV0IG49dGhpcy5jdWJlQ2FtZXJhLGw9TWF0aC5mbG9vcih0LmluZGV4L3RoaXMucHJvYmVOZXh0KSooYSo2KSxoPU1hdGguZmxvb3IodC5pbmRleCV0aGlzLnByb2JlTmV4dCkqYTtyLnNldFZpZXdwb3J0KDArbCxoLGEsYSwwLDEpLHRoaXMucmVuZGVyU2NlbmVPbmNlKGUsbi5yaWdodF9jYW1lcmEscixzKSxyLnNldFZpZXdwb3J0KGErbCxoLGEsYSwwLDEpLHRoaXMucmVuZGVyU2NlbmVPbmNlKGUsbi5sZWZ0X2NhbWVyYSxyLHMpLHIuc2V0Vmlld3BvcnQoYSoyK2wsaCxhLGEsMCwxKSx0aGlzLnJlbmRlclNjZW5lT25jZShlLG4udXBfY2FtZXJhLHIscyksci5zZXRWaWV3cG9ydChhKjMrbCxoLGEsYSwwLDEpLHRoaXMucmVuZGVyU2NlbmVPbmNlKGUsbi5kb3duX2NhbWVyYSxyLHMpLHIuc2V0Vmlld3BvcnQoYSo0K2wsaCxhLGEsMCwxKSx0aGlzLnJlbmRlclNjZW5lT25jZShlLG4uZnJvbnRfY2FtZXJhLHIscyksci5zZXRWaWV3cG9ydChhKjUrbCxoLGEsYSwwLDEpLHRoaXMucmVuZGVyU2NlbmVPbmNlKGUsbi5iYWNrX2NhbWVyYSxyLHMpfXJlbmRlclNjZW5lT25jZShlLHQscixzKXt0aGlzLnZvbHVtZS51cGxvYWRCdWZmZXIoKTtsZXQgYT1RLmluc3RhbmNlLmdldFJlbmRlck5vZGVzKGUuc2NlbmUsdCk7dy5iaW5kQ2FtZXJhKHIsdCk7bGV0IG49TWF0aC5tYXgoMCxBLnNldHRpbmcucmVuZGVyLmRyYXdPcE1pbiksbD1NYXRoLm1pbihBLnNldHRpbmcucmVuZGVyLmRyYXdPcE1heCxhLm9wYXF1ZUxpc3QubGVuZ3RoKSxoPVEuaW5zdGFuY2UuZ2V0UmVuZGVyU2hhZGVyQ29sbGVjdChlKTtmb3IoY29uc3QgdSBvZiBoKXtsZXQgYz11WzFdO2Zvcihjb25zdCBmIG9mIGMpe2xldCBkPWZbMV07aWYoZC5wcmVJbml0KXtkLm5vZGVVcGRhdGUoZSx0aGlzLnBhc3NUeXBlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUsbnVsbCk7YnJlYWt9fX1mb3IobGV0IHU9bjt1PGw7Kyt1KXtsZXQgYz1hLm9wYXF1ZUxpc3RbdV07Yy5lbmFibGUmJmMudHJhbnNmb3JtLmVuYWJsZSYmKGMucHJlSW5pdHx8Yy5ub2RlVXBkYXRlKGUsdGhpcy5wYXNzVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLG51bGwpLGMucmVuZGVyUGFzczIoZSx0aGlzLnBhc3NUeXBlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUsbnVsbCxyKSl9US5pbnN0YW5jZS5za3kmJihRLmluc3RhbmNlLnNreS5wcmVJbml0fHxRLmluc3RhbmNlLnNreS5ub2RlVXBkYXRlKGUsdGhpcy5wYXNzVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLG51bGwpLFEuaW5zdGFuY2Uuc2t5LnJlbmRlclBhc3MyKGUsdGhpcy5wYXNzVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLG51bGwscikpLG49TWF0aC5tYXgoMCxBLnNldHRpbmcucmVuZGVyLmRyYXdUck1pbiksbD1NYXRoLm1pbihBLnNldHRpbmcucmVuZGVyLmRyYXdUck1heCxhLnRyYW5zcGFyZW50TGlzdC5sZW5ndGgpO2ZvcihsZXQgdT1uO3U8bDsrK3Upe2xldCBjPWEudHJhbnNwYXJlbnRMaXN0W3VdO2MuZW5hYmxlJiZjLnRyYW5zZm9ybS5lbmFibGUmJihjLnByZUluaXR8fGMubm9kZVVwZGF0ZShlLHRoaXMucGFzc1R5cGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSxudWxsKSxjLnJlbmRlclBhc3MyKGUsdGhpcy5wYXNzVHlwZSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLG51bGwscikpfX1yZW5kZXIoZSx0KXtpZighQS5zZXR0aW5nLmdpLmVuYWJsZSlyZXR1cm47dGhpcy52b2x1bWUudXBkYXRlT3JpZW50YXRpb24oKSx0aGlzLnZvbHVtZS5pc1ZvbHVtZUZyYW1lQ2hhbmdlPSExLHRoaXMudm9sdW1lLnVwbG9hZEJ1ZmZlcigpLHRoaXMucmVuZFByb2JlKGUpO2xldCByPXRoaXMucHJvYmVSZW5kZXJSZXN1bHQuY291bnQ+MDsoUS5pbnN0YW5jZS5zdGF0ZS5naUxpZ2h0aW5nQ2hhbmdlfHxyfHxBLnNldHRpbmcuZ2kucmVhbFRpbWVHSSkmJihRLmluc3RhbmNlLnN0YXRlLmdpTGlnaHRpbmdDaGFuZ2U9ITEsdGhpcy5saWdodGluZ1Bhc3MuY29tcHV0ZShlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUpLHRoaXMuYm91bmNlUGFzcy5jb21wdXRlKGUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZSksdGhpcy5pcnJhZGlhbmNlQ29tcHV0ZVBhc3MuY29tcHV0ZShlLHRoaXMucmVuZGVyZXJQYXNzU3RhdGUpKSx0aGlzLnByb2JlUmVuZGVyUmVzdWx0LmNvbXBsZXRlJiZ0aGlzLmRpc3BhdGNoRXZlbnQoQ28pfXN0YXJ0UmVuZGVyR0koZT0wKXt0aGlzLm5leHRQcm9iZUluZGV4PT0tMSYmZT09MCYmdGhpcy5kaXNwYXRjaEV2ZW50KEhzKSx0aGlzLm5leHRQcm9iZUluZGV4PWUsdGhpcy5yZW5kZXJTdGF0dXM9XCJyZW5kZXJpbmdcIn1zdGFydFJlbmRlckNsb3VkR0koKXt0aGlzLmRpc3BhdGNoRXZlbnQoSHMpLHRoaXMubmV4dFByb2JlSW5kZXg9MCx0aGlzLnJlbmRlclN0YXR1cz1cInJlbmRlcmluZ1wiLHRoaXMuaXNSZW5kZXJDbG91ZEdJPSEwfXJlbmRQcm9iZShlKXtsZXQgdD1BLnNldHRpbmcuZ2kuYXV0b1JlbmRlclByb2JlLHI9ITE7aWYodD8odGhpcy5uZXh0UHJvYmVJbmRleD09LTEmJnRoaXMuc3RhcnRSZW5kZXJHSSgpLHI9ITApOnI9dGhpcy5yZW5kZXJTdGF0dXM9PVwicmVuZGVyaW5nXCIsdGhpcy5wcm9iZVJlbmRlclJlc3VsdC5jb3VudD0wLHRoaXMucHJvYmVSZW5kZXJSZXN1bHQuY29tcGxldGU9ITEscil7bGV0IHM9US5pbnN0YW5jZS5nZXRQcm9iZXMoZS5zY2VuZSk7dGhpcy5yZW5kZXJDb250ZXh0LmNsZWFuKCksdGhpcy5yZW5kZXJDb250ZXh0LmJlZ2luUmVuZGVyUGFzcygpLHRoaXMudGVtcFByb2JlTGlzdC5sZW5ndGg9MDtsZXQgYT1NYXRoLm1pbih0aGlzLnByb2JlQ291bnRQZXJGcmFtZSxzLmxlbmd0aCk7Zm9yKHRoaXMucHJvYmVSZW5kZXJSZXN1bHQuY291bnQ9YTthPjA7KXtjb25zdCBsPXNbdGhpcy5uZXh0UHJvYmVJbmRleF07dGhpcy51cGRhdGVQcm9iZShlLGwsdGhpcy5yZW5kZXJDb250ZXh0LmVuY29kZXIpLGEtLSx0aGlzLm5leHRQcm9iZUluZGV4KyssbC5kcmF3Q2FsbEZyYW1lPDMmJnRoaXMudGVtcFByb2JlTGlzdC5wdXNoKGwpfXRoaXMudGVtcFByb2JlTGlzdC5sZW5ndGg+MCYmdGhpcy52b2x1bWUudXBkYXRlUHJvYmVzKHRoaXMudGVtcFByb2JlTGlzdCk7bGV0IG49dGhpcy5uZXh0UHJvYmVJbmRleD49cy5sZW5ndGg7dGhpcy5uZXh0UHJvYmVJbmRleD49cy5sZW5ndGgmJnRoaXMuaXNSZW5kZXJDbG91ZEdJJiZ0aGlzLnVwZGF0ZVByb2JlKGUsc1swXSx0aGlzLnJlbmRlckNvbnRleHQuZW5jb2RlciksdGhpcy5yZW5kZXJDb250ZXh0LmVuZFJlbmRlclBhc3MoKSxuJiYodGhpcy5uZXh0UHJvYmVJbmRleD0tMSx0aGlzLnJlbmRlclN0YXR1cz1cImNvbXBsZXRlXCIsdGhpcy5wcm9iZVJlbmRlclJlc3VsdC5jb21wbGV0ZT0hMCl9fWluaXRJcnJhZGlhbmNlTWFwKGUpe2xldCB0PWUuc2V0dGluZyxyPUdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkN8R1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUO3RoaXMuaXJyYWRpYW5jZURlcHRoTWFwPW5ldyBvZSh0Lm9jdFJUTWF4U2l6ZSx0Lm9jdFJUTWF4U2l6ZSxHLnJnYmExNmZsb2F0LCExLHIpLHRoaXMuaXJyYWRpYW5jZURlcHRoTWFwLm5hbWU9XCJpcnJhZGlhbmNlRGVwdGhNYXBcIix0aGlzLmlycmFkaWFuY2VDb2xvck1hcD1uZXcgb2UodC5vY3RSVE1heFNpemUsdC5vY3RSVE1heFNpemUsRy5yZ2JhMTZmbG9hdCwhMSxyKSx0aGlzLmlycmFkaWFuY2VDb2xvck1hcC5uYW1lPVwiaXJyYWRpYW5jZUNvbG9yTWFwXCJ9d3JpdGVUb1RleHR1cmUoZSx0LHIscyl7Y29uc29sZS5sb2coZS5uYW1lKTtjb25zdCBhPVMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0LmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KTtTLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihhLDAsdCk7Y29uc3Qgbj13LmJlZ2luQ29tbWFuZEVuY29kZXIoKTtuLmNvcHlCdWZmZXJUb1RleHR1cmUoe2J1ZmZlcjphLGJ5dGVzUGVyUm93OnIqMTZ9LHt0ZXh0dXJlOmUuZ2V0R1BVVGV4dHVyZSgpfSx7d2lkdGg6cixoZWlnaHQ6cyxkZXB0aE9yQXJyYXlMYXllcnM6MX0pLHcuZW5kQ29tbWFuZEVuY29kZXIobil9fWNsYXNzIHdvIGV4dGVuZHMgUGh7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9c3RhcnQoKXtzdXBlci5zdGFydCgpO2xldCBlPXd0LmdldEdCdWZmZXJGcmFtZShcIkNvbG9yUGFzc0dCdWZmZXJcIik7e2xldCB0PVtdLHI9bmV3IGVoO2lmKEEuc2V0dGluZy5yZW5kZXIuelByZVBhc3MmJihlLnpQcmVUZXh0dXJlPXRoaXMuZGVwdGhQYXNzUmVuZGVyZXIucmVuZGVyZXJQYXNzU3RhdGUuZGVwdGhUZXh0dXJlKSxyLnNldFJlbmRlclN0YXRlcyhlKSxBLnNldHRpbmcuZ2kuZW5hYmxlKXtsZXQgcz1wZS5nZXRMaWdodEVudHJpZXModGhpcy52aWV3LnNjZW5lKTt0aGlzLmRkZ2lQcm9iZVJlbmRlcmVyPW5ldyBHaChzLmlycmFkaWFuY2VWb2x1bWUpLHRoaXMuZGRnaVByb2JlUmVuZGVyZXIuc2V0SW5wdXRUZXh0dXJlKFt0aGlzLnNoYWRvd01hcFBhc3NSZW5kZXJlci5kZXB0aDJEQXJyYXlUZXh0dXJlLHRoaXMucG9pbnRMaWdodFNoYWRvd1JlbmRlcmVyLmN1YmVBcnJheVRleHR1cmVdKSxyLnNldElycmFkaWFuY2UodGhpcy5kZGdpUHJvYmVSZW5kZXJlci5pcnJhZGlhbmNlQ29sb3JNYXAsdGhpcy5kZGdpUHJvYmVSZW5kZXJlci5pcnJhZGlhbmNlRGVwdGhNYXApLHRoaXMucmVuZGVyZXJNYXAuYWRkUmVuZGVyZXIodGhpcy5kZGdpUHJvYmVSZW5kZXJlciksdC5wdXNoKHRoaXMuZGRnaVByb2JlUmVuZGVyZXIucG9zaXRpb25NYXAsdGhpcy5kZGdpUHJvYmVSZW5kZXJlci5ub3JtYWxNYXAsdGhpcy5kZGdpUHJvYmVSZW5kZXJlci5jb2xvck1hcCx0aGlzLmRkZ2lQcm9iZVJlbmRlcmVyLmxpZ2h0aW5nUGFzcy5saWdodGluZ1RleHR1cmUsdGhpcy5kZGdpUHJvYmVSZW5kZXJlci5pcnJhZGlhbmNlQ29sb3JNYXAsdGhpcy5kZGdpUHJvYmVSZW5kZXJlci5pcnJhZGlhbmNlRGVwdGhNYXApfXRoaXMucG9zdFJlbmRlcmVyJiZ0aGlzLnBvc3RSZW5kZXJlci5zZXREZWJ1Z1RleHR1cmUodCksdGhpcy5yZW5kZXJlck1hcC5hZGRSZW5kZXJlcihyKX1BLnNldHRpbmcucmVuZGVyLmRlYnVnJiZ0aGlzLmRlYnVnKCl9ZGVidWcoKXt9fWNsYXNzIFFoe2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX2ZhY3RvclwiKSxvKHRoaXMsXCJfZG91YmxlRmFjdG9yXCIpLHRoaXMuX2ZhY3Rvcj0xLHRoaXMuX2RvdWJsZUZhY3Rvcj0yfWdldCBhY2NlbGVyYXRlSW50ZXJwb2xhdG9yKCl7cmV0dXJuIHRoaXMuX2ZhY3Rvcn1zZXQgYWNjZWxlcmF0ZUludGVycG9sYXRvcihlKXt0aGlzLl9mYWN0b3I9ZSx0aGlzLl9kb3VibGVGYWN0b3I9Mip0aGlzLl9mYWN0b3J9Z2V0SW50ZXJwb2xhdGlvbihlKXtyZXR1cm4gdGhpcy5fZmFjdG9yPT0xP2UqZTpNYXRoLnBvdyhlLHRoaXMuX2RvdWJsZUZhY3Rvcil9fWNsYXNzIFZoe2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX2ZhY3RvclwiLDEpfWdldCBkZWNlbGVyYXRlSW50ZXJwb2xhdG9yKCl7cmV0dXJuIHRoaXMuX2ZhY3Rvcn1zZXQgZGVjZWxlcmF0ZUludGVycG9sYXRvcihlKXt0aGlzLl9mYWN0b3I9ZX1nZXRJbnRlcnBvbGF0aW9uKGUpe2xldCB0O3JldHVybiB0aGlzLl9mYWN0b3I9PTE/dD0xLSgxLWUpKigxLWUpOnQ9MS1NYXRoLnBvdygxLWUsMip0aGlzLl9mYWN0b3IpLHR9fWNsYXNzIEhoe2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX2ZhY3RvclwiLDEpfWdldEludGVycG9sYXRpb24oZSl7cmV0dXJuIE1hdGguY29zKChlKzEpKk1hdGguUEkpLzIrLjV9fWNsYXNzIFloe2dldEludGVycG9sYXRpb24oZSl7cmV0dXJuIGV9fWNsYXNzIFhoe2dldEludGVycG9sYXRpb24oZSl7cmV0dXJuIDQuOSplKzQuOSplfX1jbGFzcyBBdHtjb25zdHJ1Y3Rvcigpe31zdGF0aWMgYm91bmNlKGUpe3JldHVybiBlKmUqOS44fWdldEludGVycG9sYXRpb24oZSl7cmV0dXJuIGUqPTEuMTIyNixlPC4zNTM1P0F0LmJvdW5jZShlKTplPC43NDA4P0F0LmJvdW5jZShlLS41NDcxOSkrLjc6ZTwuOTY0ND9BdC5ib3VuY2UoZS0uODUyNikrLjk6QXQuYm91bmNlKGUtMS4wNDM1KSsuOTV9Z2V0Qm91bmNlSW50ZXJwb2xhdGlvbihlKXtyZXR1cm4gZTwuNT9BdC5ib3VuY2UoZSk6QXQuYm91bmNlKGUtMSl9Z2VKdW1wVXAoZSx0KXtyZXR1cm4gdDwuNT8odD10Ly41LGUqdC1BdC5ib3VuY2UodCkpOnQ8Ljg/KHQ9KHQtLjUpLyguOC0uNSksKGUqdC1BdC5ib3VuY2UodCkpKi4zKTp0PDE/KHQ9KHQtLjgpLygxLS44KSwoZSp0LUF0LmJvdW5jZSh0KSkqLjE1KTplKnQtQXQuYm91bmNlKHQpfX1jbGFzcyBXaHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcIl90ZW5zaW9uXCIpLHRoaXMuX3RlbnNpb249Mn1nZXQgYW50aWNpcGF0ZUludGVycG9sYXRvcigpe3JldHVybiB0aGlzLl90ZW5zaW9ufXNldCBhbnRpY2lwYXRlSW50ZXJwb2xhdG9yKGUpe3RoaXMuX3RlbnNpb249ZX1nZXRJbnRlcnBvbGF0aW9uKGUpe3JldHVybiBlKmUqKCh0aGlzLl90ZW5zaW9uKzEpKmUtdGhpcy5fdGVuc2lvbil9fWNsYXNzIFNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX3RlbnNpb25cIiksdGhpcy5fdGVuc2lvbj0xKjEuNX1hbnRpY2lwYXRlT3ZlcnNob290SW50ZXJwb2xhdG9yKGUpe3RoaXMuX3RlbnNpb249ZSoxLjV9YW50aWNpcGF0ZU92ZXJzaG9vdEludGVycG9sYXRvcjIoZSx0KXt0aGlzLl90ZW5zaW9uPWUqdH1nZXRJbnRlcnBvbGF0aW9uKGUpe3JldHVybiBlPC41Py41KlNzLmEoZSoyLHRoaXMuX3RlbnNpb24pOi41KihTcy5vKGUqMi0yLHRoaXMuX3RlbnNpb24pKzIpfXN0YXRpYyBhKGUsdCl7cmV0dXJuIGUqZSooKHQrMSkqZS10KX1zdGF0aWMgbyhlLHQpe3JldHVybiBlKmUqKCh0KzEpKmUrdCl9fWNsYXNzIGpoe2NvbnN0cnVjdG9yKGUpe28odGhpcyxcIl9jeWNsZXNcIiksdGhpcy5fY3ljbGVzPWV9Z2V0SW50ZXJwb2xhdGlvbihlKXtyZXR1cm4gTWF0aC5zaW4oMip0aGlzLl9jeWNsZXMqTWF0aC5QSSplKX19Y2xhc3MgcWh7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJfdGVuc2lvblwiKSx0aGlzLl90ZW5zaW9uPTJ9Z2V0SW50ZXJwb2xhdGlvbihlKXtyZXR1cm4gZS09MSxlKmUqKCh0aGlzLl90ZW5zaW9uKzEpKmUrdGhpcy5fdGVuc2lvbikrMX19dmFyIGJvPShpPT4oaVtpLkFjY2VsZXJhdGVJbnRlcnBvbGF0b3I9MF09XCJBY2NlbGVyYXRlSW50ZXJwb2xhdG9yXCIsaVtpLkRlY2VsZXJhdGVJbnRlcnBvbGF0b3I9MV09XCJEZWNlbGVyYXRlSW50ZXJwb2xhdG9yXCIsaVtpLkFjY2VsZXJhdGVEZWNlbGVyYXRlSW50ZXJwb2xhdG9yPTJdPVwiQWNjZWxlcmF0ZURlY2VsZXJhdGVJbnRlcnBvbGF0b3JcIixpW2kuTGluZWFySW50ZXJwb2xhdG9yPTNdPVwiTGluZWFySW50ZXJwb2xhdG9yXCIsaVtpLkJvdW5jZUludGVycG9sYXRvcj00XT1cIkJvdW5jZUludGVycG9sYXRvclwiLGlbaS5BbnRpY2lwYXRlSW50ZXJwb2xhdG9yPTVdPVwiQW50aWNpcGF0ZUludGVycG9sYXRvclwiLGlbaS5BbnRpY2lwYXRlT3ZlcnNob290SW50ZXJwb2xhdG9yPTZdPVwiQW50aWNpcGF0ZU92ZXJzaG9vdEludGVycG9sYXRvclwiLGlbaS5DeWNsZUludGVycG9sYXRvcj03XT1cIkN5Y2xlSW50ZXJwb2xhdG9yXCIsaVtpLk92ZXJzaG9vdEludGVycG9sYXRvcj04XT1cIk92ZXJzaG9vdEludGVycG9sYXRvclwiLGlbaS5KdW1wZXJJbnRlcnBvbGF0b3I9OV09XCJKdW1wZXJJbnRlcnBvbGF0b3JcIixpKSkoYm98fHt9KTtjb25zdCBvcj1jbGFzc3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcImNvbXBsZXRlXCIsITEpLG8odGhpcyxcIm9uQ29tcGxldGVcIiksbyh0aGlzLFwib25Qcm9ncmVzc1wiKSxvKHRoaXMsXCJ0YXJnZXRcIiksbyh0aGlzLFwicHJvcGVydHlcIiksbyh0aGlzLFwidGFyZ2V0UHJvcGVydHlcIiksbyh0aGlzLFwiZHVydGlvblwiKSxvKHRoaXMsXCJpbnRlcnBvbGF0b3JFbnVtXCIpLG8odGhpcyxcImRlbGF5VGltZVwiLDApLG8odGhpcyxcIl9pbnRlcnBvbGF0b3JcIiksbyh0aGlzLFwiX2N0XCIsMCksbyh0aGlzLFwiX3BcIiwwKX1zdGF0aWMgdG8oaSxlLHQscj0wKXt2YXIgcz1uZXcgb3I7cmV0dXJuIHMudGFyZ2V0PWkscy5wcm9wZXJ0eT1lLHMuZHVydGlvbj10LHMuaW50ZXJwb2xhdG9yRW51bT1yLHMuc3RhcnQoKSxzLmRlbGF5VGltZT1lLmRlbGF5VGltZT9lLmRlbGF5VGltZTowLGUub25Db21wbGV0ZSYmKHMub25Db21wbGV0ZT1lLm9uQ29tcGxldGUpLGUub25Qcm9ncmVzcyYmKHMub25Qcm9ncmVzcz1lLm9uUHJvZ3Jlc3MpLHRoaXMuaW50ZXJwb2xhdG9ycy5wdXNoKHMpLHN9c3RhdGljIHRpY2soaSl7bGV0IGU9b3IuaW50ZXJwb2xhdG9ycztmb3IobGV0IHQgb2YgZSl0LmNvbXBsZXRlP29yLnJlbW92ZSh0LCEwKTp0LnRpY2soaSl9c3RhdGljIHJlbW92ZShpLGUpe2xldCB0PW9yLmludGVycG9sYXRvcnMscj10LmluZGV4T2YoaSk7ciE9LTEmJnQuc3BsaWNlKHIsMSksZSYmaS5kaXNwb3NlKCl9c3RhdGljIHJlbW92ZUxpc3QoaSxlKXtpLmZvckVhY2godD0+e3RoaXMucmVtb3ZlKHQsZSl9KX1zdGFydCgpe3dpbmRvdy5BY2NlbGVyYXRlSW50ZXJwb2xhdG9yPVFoLHdpbmRvdy5EZWNlbGVyYXRlSW50ZXJwb2xhdG9yPVZoLHdpbmRvdy5BY2NlbGVyYXRlRGVjZWxlcmF0ZUludGVycG9sYXRvcj1IaCx3aW5kb3cuTGluZWFySW50ZXJwb2xhdG9yPVloLHdpbmRvdy5Cb3VuY2VJbnRlcnBvbGF0b3I9QXQsd2luZG93LkFudGljaXBhdGVJbnRlcnBvbGF0b3I9V2gsd2luZG93LkFudGljaXBhdGVPdmVyc2hvb3RJbnRlcnBvbGF0b3I9U3Msd2luZG93LkN5Y2xlSW50ZXJwb2xhdG9yPWpoLHdpbmRvdy5PdmVyc2hvb3RJbnRlcnBvbGF0b3I9cWgsd2luZG93Lkp1bXBlckludGVycG9sYXRvcj1YaCx0aGlzLl9pbnRlcnBvbGF0b3I9bmV3IHdpbmRvd1tib1t0aGlzLmludGVycG9sYXRvckVudW1dXSx0aGlzLnRhcmdldFByb3BlcnR5PXt9O2ZvcihsZXQgaSBpbiB0aGlzLnByb3BlcnR5KXRoaXMudGFyZ2V0UHJvcGVydHlbaV09dGhpcy50YXJnZXRbaV19dGljayhpKXtpZih0aGlzLmRlbGF5VGltZTw9MCl7dGhpcy5fcD1NYXRoLm1pbih0aGlzLl9jdC90aGlzLmR1cnRpb24sMSk7bGV0IGU9dGhpcy5faW50ZXJwb2xhdG9yLmdldEludGVycG9sYXRpb24odGhpcy5fcCksdD10aGlzLnByb3BlcnR5LHI9dGhpcy50YXJnZXQscz10aGlzLnRhcmdldFByb3BlcnR5LGEsbjtmb3IobGV0IGwgaW4gdCluPXRbbF0sYT1zW2xdLHJbbF09YSsobi1hKSplO3RoaXMub25Qcm9ncmVzcyE9bnVsbCYmdGhpcy5vblByb2dyZXNzKHRoaXMuX3ApLHRoaXMuX2N0Pj10aGlzLmR1cnRpb24mJih0aGlzLmNvbXBsZXRlPSEwLHRoaXMub25Db21wbGV0ZSE9bnVsbCYmdGhpcy5vbkNvbXBsZXRlKHRoaXMudGFyZ2V0KSksdGhpcy5fY3QrPWl9ZWxzZSB0aGlzLmRlbGF5VGltZS09aX1kaXNwb3NlKCl7dGhpcy5vbkNvbXBsZXRlPW51bGwsdGhpcy5vblByb2dyZXNzPW51bGwsdGhpcy50YXJnZXQ9bnVsbCx0aGlzLnByb3BlcnR5PW51bGwsdGhpcy50YXJnZXRQcm9wZXJ0eT1udWxsLHRoaXMuaW50ZXJwb2xhdG9yRW51bT1udWxsLHRoaXMuX2ludGVycG9sYXRvcj1udWxsLG9yLnJlbW92ZSh0aGlzKX19O2xldCBTbz1vcjtvKFNvLFwiaW50ZXJwb2xhdG9yc1wiLFtdKTtjbGFzcyBpdHtzdGF0aWMgaGFzU3RyaW5nKGUsdCl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpaWYoZVtyXT09dClyZXR1cm4gcjtyZXR1cm4tMX1zdGF0aWMgZ2V0RWxsaXBzaXMoZSx0PTQpe2xldCByPWU7cmV0dXJuIHIubGVuZ3RoPnQmJihyPXIuc2xpY2UoMCx0KStcIi4uLlwiKSxyfXN0YXRpYyBnZXRVUkxOYW1lKGUpe3ZhciB0O3Q9ZS5zcGxpdChcIi9cIik7bGV0IHI9dFt0Lmxlbmd0aC0xXTtyZXR1cm4gcj1yLnNwbGl0KFwiLlwiKVswXSxyfXN0YXRpYyBnZXRGaWxlRm9ybWF0KGUpe3ZhciB0PWUubGFzdEluZGV4T2YoXCIuXCIpO3QrKzt2YXIgcj1lLmxlbmd0aDtlLmluZGV4T2YoXCI/XCIsdCkhPT0tMSYmKHI9ZS5pbmRleE9mKFwiP1wiLHQpKTt2YXIgcz1lLnN1YnN0cih0LHItdCk7cmV0dXJuIHM9cy50b0xvd2VyQ2FzZSgpLHN9c3RhdGljIHJlYWRMaW5lUHJvcGVydHkoZSx0KXtlLnRyaW0oKS5zcGxpdChcIiBcIikuZm9yRWFjaCgocixzKT0+e2xldCBhPXIuc3BsaXQoXCI9XCIpO2lmKGEubGVuZ3RoPjEpe2xldCBuPWFbMF0sbD1hWzFdO09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYobC5pbmRleE9mKCdcIicpPT0tMT90W25dPXBhcnNlRmxvYXQoYVsxXSk6dFtuXT1sLnJlcGxhY2UoJ1wiJyxcIlwiKS5yZXBsYWNlKCdcIicsXCJcIikpfX0pfXN0YXRpYyBnZXRQYXRoKGUpe3ZhciB0PWUubGFzdEluZGV4T2YoXCIvXCIpO3JldHVybiB0KyssZS5zdWJzdHJpbmcoMCx0KX1zdGF0aWMgbm9ybWFsaXplUGF0aChlKXt2YXIgdD1lLnJlcGxhY2VBbGwoXCIvL1wiLFwiL1wiKTtyZXR1cm4gdD10LnJlcGxhY2VBbGwoXCJcXFxcXCIsXCIvXCIpLHR9c3RhdGljIGdldFN0cmluZ0xpc3QoZSx0PVwiO1wiKXtyZXR1cm4gZS5zcGxpdCh0KX1zdGF0aWMgZm9ybWF0VGltZShlKXtsZXQgcj1lLzFlMy82MCxzPU1hdGguZmxvb3IociksYT1NYXRoLmZsb29yKHItcyk7cmV0dXJuW3MudG9TdHJpbmcoKSxhLnRvU3RyaW5nKCldfXN0YXRpYyB0cmltKGUpe3JldHVybiBlLnJlcGxhY2UoL15cXHMrL2csXCJcIikucmVwbGFjZSgvXFxzKyQvZyxcIlwiKX1zdGF0aWMgaXNFbXB0eShlKXtyZXR1cm4hZXx8dHlwZW9mIGU+XCJ1XCJ8fGU9PW51bGx8fHR5cGVvZiBlPT1cInN0cmluZ1wiJiZ0aGlzLnRyaW0oZSk9PT1cIlwifHxlPT09XCJudWxsXCJ9c3RhdGljIHN0ckN1dChlLHQpe2lmKGUubGVuZ3RoKjI8PXQpcmV0dXJuIGU7Zm9yKHZhciByPTAscz1cIlwiLGE9MDthPGUubGVuZ3RoO2ErKylpZihzPXMrZS5jaGFyQXQoYSksZS5jaGFyQ29kZUF0KGEpPjEyOCl7aWYocj1yKzIscj49dClyZXR1cm4gcy5zdWJzdHJpbmcoMCxzLmxlbmd0aC0xKStcIi4uLlwifWVsc2UgaWYocj1yKzEscj49dClyZXR1cm4gcy5zdWJzdHJpbmcoMCxzLmxlbmd0aC0yKStcIi4uLlwiO3JldHVybiBzfXN0YXRpYyB0b1F1ZXJ5UGFpcihlLHQscj0hMSl7cmV0dXJuIGUrXCI9XCIrKHI/ZW5jb2RlVVJJQ29tcG9uZW50KHQpOnQpfXN0YXRpYyBzdHJpbmdGb3JtYXQoZSwuLi50KXtpZihhcmd1bWVudHMubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJwbGVhc2UgZ2l2ZSBhcmcgYXQgbGVhc3Qgb25lICFcIik7aWYoYXJndW1lbnRzLmxlbmd0aD09PTImJnR5cGVvZiBhcmd1bWVudHNbMV09PVwib2JqZWN0XCIpZm9yKGxldCByIGluIGFyZ3VtZW50c1sxXSl7bGV0IHM9bmV3IFJlZ0V4cChcIih7XCIrcitcIn0pXCIsXCJnXCIpO2U9ZS5yZXBsYWNlKHMsYXJndW1lbnRzWzFdW3JdKX1lbHNlIGZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtpZih0W3JdPT1udWxsKXJldHVybiBlO3tsZXQgcz1uZXcgUmVnRXhwKFwiKHtbXCIrcitcIl19KVwiLFwiZ1wiKTtlPWUucmVwbGFjZShzLHRbcl0pfX1yZXR1cm4gZX1zdGF0aWMgcGFyc2VKc29uMlN0cmluZyhlLHQpe2xldCByPW51bGwscz1cIlwiLGE9MCxuPVwiICAgIFwiO3JldHVybiB0PXR8fHt9LHQubmV3bGluZUFmdGVyQ29sb25JZkJlZm9yZUJyYWNlT3JCcmFja2V0PXQubmV3bGluZUFmdGVyQ29sb25JZkJlZm9yZUJyYWNlT3JCcmFja2V0PT09ITAsdC5zcGFjZUFmdGVyQ29sb249dC5zcGFjZUFmdGVyQ29sb24hPT0hMSx0eXBlb2YgZSE9XCJzdHJpbmdcInx8KGU9SlNPTi5wYXJzZShlKSksZT1KU09OLnN0cmluZ2lmeShlKSxyPS8oW1xce1xcfV0pL2csZT1lLnJlcGxhY2UocixgXFxyXG4kMVxcclxuYCkscj0vKFtcXFtcXF1dKS9nLGU9ZS5yZXBsYWNlKHIsYFxcclxuJDFcXHJcbmApLHI9LyhcXCwpL2csZT1lLnJlcGxhY2UocixgJDFcXHJcbmApLHI9LyhcXHJcXG5cXHJcXG4pL2csZT1lLnJlcGxhY2UocixgXFxyXG5gKSxyPS9cXHJcXG5cXCwvZyxlPWUucmVwbGFjZShyLFwiLFwiKSx0Lm5ld2xpbmVBZnRlckNvbG9uSWZCZWZvcmVCcmFjZU9yQnJhY2tldHx8KHI9L1xcOlxcclxcblxcey9nLGU9ZS5yZXBsYWNlKHIsXCI6e1wiKSxyPS9cXDpcXHJcXG5cXFsvZyxlPWUucmVwbGFjZShyLFwiOltcIikpLHQuc3BhY2VBZnRlckNvbG9uJiYocj0vXFw6L2csZT1lLnJlcGxhY2UocixcIjpcIikpLGUuc3BsaXQoYFxcclxuYCkuZm9yRWFjaChmdW5jdGlvbihsLGgpe2xldCB1PTAsYz0wLGY9XCJcIjtmb3IobC5tYXRjaCgvXFx7JC8pfHxsLm1hdGNoKC9cXFskLyk/Yz0xOmwubWF0Y2goL1xcfS8pfHxsLm1hdGNoKC9cXF0vKT9hIT09MCYmKGEtPTEpOmM9MCx1PTA7dTxhO3UrKylmKz1uO3MrPWYrbCtgXFxyXG5gLGErPWN9KSxzfXN0YXRpYyBjb21wYXJlVmVyc2lvbihlLHQpe2U9ZS5zcGxpdChcIi5cIiksdD10LnNwbGl0KFwiLlwiKTtsZXQgcj1NYXRoLm1heChlLmxlbmd0aCx0Lmxlbmd0aCk7Zm9yKDtlLmxlbmd0aDxyOyllLnB1c2goXCIwXCIpO2Zvcig7dC5sZW5ndGg8cjspdC5wdXNoKFwiMFwiKTtmb3IobGV0IHM9MDtzPHI7cysrKXtsZXQgYT1wYXJzZUludChlW3NdKSxuPXBhcnNlSW50KHRbc10pO2lmKGE+bilyZXR1cm4gMTtpZihhPG4pcmV0dXJuLTF9cmV0dXJuIDB9c3RhdGljIGJ1aWxkUmFuZG9tQ29kZSgpe2xldCBlPVwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODlcIix0PWUubGVuZ3RoLHI9XCJcIjtmb3IobGV0IGE9MDthPDI2O2ErKyl7bGV0IG49TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnQpO3IrPWUuY2hhckF0KG4pfXJldHVybmAke25ldyBEYXRlKCkuZ2V0VGltZSgpfS0ke3J9YH1zdGF0aWMgVVVJRCgpe3JldHVyblwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLGZ1bmN0aW9uKGUpe3ZhciB0PU1hdGgucmFuZG9tKCkqMTZ8MCxyPWU9PVwieFwiP3Q6dCYzfDg7cmV0dXJuIHIudG9TdHJpbmcoMTYpfSl9c3RhdGljIHN0cmluZ1RvSGFzaChlKXtsZXQgdD0wO2lmKGUubGVuZ3RoPT0wKXJldHVybiB0O2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtjb25zdCBzPWUuY2hhckNvZGVBdChyKTt0PSh0PDw1KS10K3MsdD10JnR9cmV0dXJuIHR9c3RhdGljIHBhcnNlVXJsKGUsdCl7cmV0dXJuIHQubWF0Y2goL14oYmxvYnxodHRwfGh0dHBzKTovKT90OmUrdH19byhpdCxcIl9maWx0ZXJDaGFyXCIsW1wiIFwiLFwiICBcIixcIjtcIixgXG5gLFwiXFxyXCIsXCJcdFwiLGBcbmAsXCJcXHJcIixcIlx0XCJdKTtjbGFzcyBpaSBleHRlbmRzIGF0e2NvbnN0cnVjdG9yKGU9ITApe3N1cGVyKCksbyh0aGlzLFwiX3NvdXJjZVwiKSxvKHRoaXMsXCJpbWFnZURhdGFcIiksdGhpcy51c2VNaXBtYXA9ZX1nZXQgc291cmNlKCl7cmV0dXJuIHRoaXMuX3NvdXJjZX1zZXQgc291cmNlKGUpe3RoaXMuX3NvdXJjZT1lLHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ/dGhpcy5fc291cmNlLmRlY29kZSgpLnRoZW4oYXN5bmMoKT0+e2lmKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpe2NvbnN0IHQ9YXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5fc291cmNlLHtpbWFnZU9yaWVudGF0aW9uOnRoaXMuZmxpcFk/XCJmbGlwWVwiOlwiZnJvbS1pbWFnZVwifSk7dGhpcy5nZW5lcmF0ZSh0KX19KToodGhpcy5fc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSYmdGhpcy5nZW5lcmF0ZSh0aGlzLl9zb3VyY2UpfWFzeW5jIGxvYWQoZSx0KXtpZihlLmluZGV4T2YoXCI7YmFzZTY0XCIpIT0tMSl7Y29uc3Qgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO2xldCBzPWUuaW5kZXhPZihcImRhdGE6aW1hZ2VcIiksYT1lLnN1YnN0cmluZyhzLGUubGVuZ3RoKTtyLnNyYz1hLGF3YWl0IHIuZGVjb2RlKCksci53aWR0aD1NYXRoLm1heChyLndpZHRoLDMyKSxyLmhlaWdodD1NYXRoLm1heChyLmhlaWdodCwzMik7Y29uc3Qgbj1hd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChyLHtyZXNpemVXaWR0aDpyLndpZHRoLHJlc2l6ZUhlaWdodDpyLmhlaWdodCxpbWFnZU9yaWVudGF0aW9uOnRoaXMuZmxpcFk/XCJmbGlwWVwiOlwiZnJvbS1pbWFnZVwifSk7dGhpcy5mb3JtYXQ9Ry5yZ2JhOHVub3JtLHRoaXMuZ2VuZXJhdGUobil9ZWxzZXtjb25zdCByPWF3YWl0IGZldGNoKGUse2hlYWRlcnM6T2JqZWN0LmFzc2lnbih7QWNjZXB0OlwiaW1hZ2UvYXZpZixpbWFnZS93ZWJwLCovKlwifSx0Py5oZWFkZXJzKX0pO2xldCBzPWF3YWl0IGppLnJlYWQoZSxyLHQpLGE9bmV3IEJsb2IoW3NdLHt0eXBlOlwiaW1hZ2UvanBlZ1wifSk7cz1udWxsLGF3YWl0IHRoaXMubG9hZEZyb21CbG9iKGEpfXJldHVybiB0aGlzLm5hbWU9aXQuZ2V0VVJMTmFtZShlKSwhMH1hc3luYyBsb2FkRnJvbUJsb2IoZSl7dGhpcy5pbWFnZURhdGE9ZTtsZXQgdD1hd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChlLHtpbWFnZU9yaWVudGF0aW9uOnRoaXMuZmxpcFk/XCJmbGlwWVwiOlwiZnJvbS1pbWFnZVwifSk7aWYodC53aWR0aDwzMnx8dC5oZWlnaHQ8MzIpe2xldCByPU1hdGgubWF4KHQud2lkdGgsMzIpLHM9TWF0aC5tYXgodC5oZWlnaHQsMzIpO3Q9YXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAodCx7cmVzaXplV2lkdGg6cixyZXNpemVIZWlnaHQ6cyxpbWFnZU9yaWVudGF0aW9uOnRoaXMuZmxpcFk/XCJmbGlwWVwiOlwiZnJvbS1pbWFnZVwifSl9cmV0dXJuIHRoaXMuZm9ybWF0PUcucmdiYTh1bm9ybSx0aGlzLmdlbmVyYXRlKHQpLCEwfX1jbGFzcyBqaXtjb25zdHJ1Y3Rvcigpe28odGhpcyxcImJhc2VVcmxcIixcIlwiKSxvKHRoaXMsXCJpbml0VXJsXCIpLG8odGhpcyxcIl9wcm9ncmVzc1wiLDApfWFzeW5jIGxvYWRCaW5EYXRhKGUsdCl7cmV0dXJuIHRoaXMuYmFzZVVybD1pdC5nZXRQYXRoKGUpLHRoaXMuaW5pdFVybD1lLG5ldyBQcm9taXNlKGFzeW5jKHIscyk9PntmZXRjaChlLHtoZWFkZXJzOnQ/LmhlYWRlcnN9KS50aGVuKGFzeW5jIGE9PntpZihhLm9rKXtsZXQgbj1hd2FpdCBqaS5yZWFkKGUsYSx0KSxsPW4uYnVmZmVyO249bnVsbCxyKGwpfWVsc2UgdGhyb3cgRXJyb3IoXCJyZXF1ZXN0IHJlamVjdGVkIHdpdGggc3RhdHVzIFwiK2Euc3RhdHVzKX0pLmNhdGNoKGE9Pnt0Lm9uRXJyb3ImJnQub25FcnJvcihhKSxzKGEpfSl9KX1hc3luYyBsb2FkQXN5bmNCaXRtYXBUZXh0dXJlKGUsdCl7dGhpcy5iYXNlVXJsPWl0LmdldFBhdGgoZSksdGhpcy5pbml0VXJsPWU7bGV0IHI9bmV3IGlpO3JldHVybiByLnVybD1lLHIubmFtZT1pdC5nZXRVUkxOYW1lKGUpLGF3YWl0IHIubG9hZChlLHQpLEEucmVzLmFkZFRleHR1cmUoZSxyKSxyfWFzeW5jIGxvYWRKc29uKGUsdCl7cmV0dXJuIHRoaXMuYmFzZVVybD1pdC5nZXRQYXRoKGUpLHRoaXMuaW5pdFVybD1lLG5ldyBQcm9taXNlKGFzeW5jKHIscyk9PntmZXRjaChlLHtoZWFkZXJzOnQ/LmhlYWRlcnN9KS50aGVuKGFzeW5jIGE9PntpZihhLm9rKXtsZXQgbj1hd2FpdCBqaS5yZWFkKGUsYSx0KTtjb25zdCBoPW5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZShuKTtuPW51bGwscihKU09OLnBhcnNlKGgpKX1lbHNlIHRocm93IEVycm9yKFwicmVxdWVzdCByZWplY3RlZCB3aXRoIHN0YXR1c1wiK2Euc3RhdHVzKX0pLmNhdGNoKGE9Pnt0Lm9uRXJyb3ImJnQub25FcnJvcihhKSxzKGEpfSl9KX1hc3luYyBsb2FkVHh0KGUsdCl7cmV0dXJuIHRoaXMuYmFzZVVybD1pdC5nZXRQYXRoKGUpLG5ldyBQcm9taXNlKGFzeW5jKHIscyk9PntmZXRjaChlKS50aGVuKGFzeW5jIGE9PntpZihhLm9rKXtsZXQgbj1hd2FpdCBqaS5yZWFkKGUsYSx0KTtjb25zdCBoPW5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZShuKTtuPW51bGwscih7ZGF0YTpofSl9ZWxzZSB0aHJvdyBFcnJvcihcInJlcXVlc3QgcmVqZWN0ZWQgd2l0aCBzdGF0dXNcIithLnN0YXR1cyl9KS5jYXRjaChhPT57dC5vbkVycm9yJiZ0Lm9uRXJyb3IoYSkscyhhKX0pfSl9c3RhdGljIGFzeW5jIHJlYWQoZSx0LHIpe2NvbnN0IHM9dC5ib2R5LmdldFJlYWRlcigpLGE9K3QuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKTtsZXQgbj0wLGw9W10saD1bXTtmb3IoOzspe2NvbnN0e2RvbmU6Zix2YWx1ZTpkfT1hd2FpdCBzLnJlYWQoKTtpZihmKXthPjAmJnImJnIub25Db21wbGV0ZSYmci5vbkNvbXBsZXRlLmNhbGwodGhpcyxlKTticmVha31sLnB1c2goZCksbis9ZC5sZW5ndGgsYT4wP3ImJnIub25Qcm9ncmVzcyYmci5vblByb2dyZXNzLmNhbGwodGhpcyxuLGEsZSk6aC5wdXNoKGQubGVuZ3RoKX1pZihoLmxlbmd0aD4wKWZvcihsZXQgZj0wO2Y8bC5sZW5ndGg7ZisrKWNvbnNvbGUubG9nKGhbZl0pLHImJnIub25Qcm9ncmVzcyYmci5vblByb2dyZXNzLmNhbGwodGhpcyxoW2ZdLG4sZSksaFtmXT09biYmciYmci5vbkNvbXBsZXRlJiZyLm9uQ29tcGxldGUuY2FsbCh0aGlzLGUpO2xldCB1PW5ldyBVaW50OEFycmF5KG4pLGM9MDtmb3IobGV0IGYgb2YgbCl1LnNldChmLGMpLGMrPWYubGVuZ3RoO3JldHVybiB1fX1jbGFzcyBodCBleHRlbmRzIGppe2FzeW5jIGxvYWQoZSx0LHIscyl7c3dpdGNoKHQuZm9ybWF0KXtjYXNlXCJiaW5cIjpyZXR1cm4gbmV3IFByb21pc2UoYXN5bmMoYSxuKT0+e3RoaXMubG9hZEJpbkRhdGEoZSxyKS50aGVuKGFzeW5jIGw9PntsZXQgaD1uZXcgdDtpZihoLnVzZXJEYXRhPXMsaC5iYXNlVXJsPXRoaXMuYmFzZVVybCxoLmluaXRVcmw9ZSxhd2FpdCBoLnBhcnNlQnVmZmVyKGwpLGgudmVyaWZpY2F0aW9uKCkpYShoKTtlbHNlIHRocm93IG5ldyBFcnJvcihcInBhcnNlciBlcnJvclwiKX0pLmNhdGNoKGw9PntuKGwpfSl9KTtjYXNlXCJqc29uXCI6cmV0dXJuIG5ldyBQcm9taXNlKChhLG4pPT57dGhpcy5sb2FkSnNvbihlLHIpLnRoZW4oYXN5bmMgbD0+e2xldCBoPW5ldyB0O2gudXNlckRhdGE9cyxoLmJhc2VVcmw9dGhpcy5iYXNlVXJsLGguaW5pdFVybD1lLGgubG9hZGVyRnVuY3Rpb25zPXIsYXdhaXQgaC5wYXJzZUpzb24obCksYShoKX0pLmNhdGNoKGw9PntuKGwpfSl9KTtjYXNlXCJ0ZXh0XCI6cmV0dXJuIG5ldyBQcm9taXNlKChhLG4pPT57dGhpcy5sb2FkVHh0KGUscikudGhlbihhc3luYyBsPT57bGV0IGg9bmV3IHQ7aC51c2VyRGF0YT1zLGguYmFzZVVybD10aGlzLmJhc2VVcmwsaC5pbml0VXJsPWUsaC5sb2FkZXJGdW5jdGlvbnM9cixsLmRhdGE/KGF3YWl0IGgucGFyc2VTdHJpbmcobC5kYXRhKSxhKGgpKTpuKFwidGV4dCBsb2FkIGlzIGVtcHR5IVwiKX0pLmNhdGNoKGw9PntuKGwpfSl9KX19fWNsYXNzIFh0e2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiYmFzZVVybFwiKSxvKHRoaXMsXCJpbml0VXJsXCIpLG8odGhpcyxcImxvYWRlckZ1bmN0aW9uc1wiKSxvKHRoaXMsXCJ1c2VyRGF0YVwiKSxvKHRoaXMsXCJkYXRhXCIpfXBhcnNlU3RyaW5nKGUpe31wYXJzZUpzb24oZSl7fXBhcnNlQnVmZmVyKGUpe31wYXJzZVRleHR1cmUoZSl7dGhyb3cgdGhpcy5wYXJzZXJFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIsLTEpfXBhcnNlKGUpe312ZXJpZmljYXRpb24oZSl7dGhyb3cgdGhpcy5wYXJzZXJFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIsLTEpfXBhcnNlckVycm9yKGUsdCl7Y29uc29sZS5lcnJvcihgZXJyb3IgaWQ6JHt0fSAke2V9YCl9fW8oWHQsXCJmb3JtYXRcIixcImJpblwiKTtjbGFzcyBZc3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcImFzc2V0XCIpLG8odGhpcyxcImFjY2Vzc29yc1wiKSxvKHRoaXMsXCJidWZmZXJzXCIpLG8odGhpcyxcImJ1ZmZlclZpZXdzXCIpLG8odGhpcyxcIm1hdGVyaWFsc1wiKSxvKHRoaXMsXCJtZXNoZXNcIiksbyh0aGlzLFwibm9kZXNcIiksbyh0aGlzLFwic2NlbmVcIiwwKSxvKHRoaXMsXCJzY2VuZXNcIiksbyh0aGlzLFwidGV4dHVyZXNcIiksbyh0aGlzLFwiY2FtZXJhc1wiKSxvKHRoaXMsXCJza2luc1wiKSxvKHRoaXMsXCJyZXNvdXJjZXNcIiksbyh0aGlzLFwiaW1hZ2VzXCIpLG8odGhpcyxcInNhbXBsZXJzXCIpLG8odGhpcyxcImFuaW1hdGlvbnNcIiksbyh0aGlzLFwiZXh0ZW5zaW9uc1wiKX19Y2xhc3MgQWd7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJub2Rlc1wiKX19Y2xhc3MgX2d7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJuYW1lXCIpLG8odGhpcyxcInR5cGVcIiksbyh0aGlzLFwiY29sb3JcIiksbyh0aGlzLFwiaW50ZW5zaXR5XCIpLG8odGhpcyxcInJhbmdlXCIpLG8odGhpcyxcInNwb3RcIiksbyh0aGlzLFwiaXNQYXJzZWRcIil9fWNsYXNzIHhne2NvbnN0cnVjdG9yKCl7byh0aGlzLFwibmFtZVwiKSxvKHRoaXMsXCJyb3RhdGlvblwiKSxvKHRoaXMsXCJzY2FsZVwiKSxvKHRoaXMsXCJ0cmFuc2xhdGlvblwiKSxvKHRoaXMsXCJjaGlsZHJlblwiKSxvKHRoaXMsXCJtYXRyaXhcIiksbyh0aGlzLFwibWVzaFwiLC0xKSxvKHRoaXMsXCJpc1BhcnNlZFwiKSxvKHRoaXMsXCJkbm9kZVwiKSxvKHRoaXMsXCJjYW1lcmFcIiksbyh0aGlzLFwic2tpblwiKSxvKHRoaXMsXCJub2RlSWRcIiksbyh0aGlzLFwicHJpbWl0aXZlc1wiKSxvKHRoaXMsXCJleHRlbnNpb25zXCIpLG8odGhpcyxcImxpZ2h0XCIpfX1jbGFzcyB2Z3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcImF0dHJpYnV0ZXNcIiksbyh0aGlzLFwiaW5kaWNlc1wiKSxvKHRoaXMsXCJtYXRlcmlhbFwiKSxvKHRoaXMsXCJtb2RlXCIpLG8odGhpcyxcIm5hbWVcIiksbyh0aGlzLFwidGFyZ2V0c1wiKSxvKHRoaXMsXCJleHRlbnNpb25zXCIpLG8odGhpcyxcIm1vcnBoVGFyZ2V0c1JlbGF0aXZlXCIpfX1jbGFzcyB5Z3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcIm5hbWVcIiksbyh0aGlzLFwicHJpbWl0aXZlc1wiKSxvKHRoaXMsXCJpc1BhcnNlZFwiKSxvKHRoaXMsXCJkcHJpbWl0aXZlc1wiKSxvKHRoaXMsXCJ3ZWlnaHRzXCIpLG8odGhpcyxcImV4dHJhc1wiKX19Y2xhc3MgQ2d7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJidWZmZXJWaWV3XCIpLG8odGhpcyxcImNvbXBvbmVudFR5cGVcIiksbyh0aGlzLFwiY291bnRcIiksbyh0aGlzLFwidHlwZVwiKSxvKHRoaXMsXCJtYXhcIiksbyh0aGlzLFwibWluXCIpLG8odGhpcyxcImlzUGFyc2VkXCIpLG8odGhpcyxcImRhY2Nlc3NvclwiKSxvKHRoaXMsXCJub3JtYWxpemVkXCIpLG8odGhpcyxcInNwYXJzZVwiKSxvKHRoaXMsXCJieXRlT2Zmc2V0XCIpLG8odGhpcyxcImNvbXB1dGVSZXN1bHRcIil9fWNvbnN0IHdnPXdpbmRvdy5TaGFyZWRBcnJheUJ1ZmZlcj9mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5idWZmZXImJihlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxlLmJ1ZmZlciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFyZWRBcnJheUJ1ZmZlcil9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLmJ1ZmZlciYmZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcn0sSW89NTEyMCxpcz01MTIxLEVvPTUxMjIsQm89NTEyMyxUbz01MTI0LE1vPTUxMjUsRG89NTEyNixiZz0zMjgxOSxTZz0zMjgyMCxJZz0zMzYzNSxFZz01MTMxLEJnPTMzNjQwLFRnPTM1ODk5LE1nPTM1OTAyLERnPTM2MjY5LFBnPTM0MDQyLEtoPXt9O3tjb25zdCBpPUtoO2lbSW9dPUludDhBcnJheSxpW2lzXT1VaW50OEFycmF5LGlbRW9dPUludDE2QXJyYXksaVtCb109VWludDE2QXJyYXksaVtUb109SW50MzJBcnJheSxpW01vXT1VaW50MzJBcnJheSxpW0RvXT1GbG9hdDMyQXJyYXksaVtiZ109VWludDE2QXJyYXksaVtTZ109VWludDE2QXJyYXksaVtJZ109VWludDE2QXJyYXksaVtFZ109VWludDE2QXJyYXksaVtCZ109VWludDMyQXJyYXksaVtUZ109VWludDMyQXJyYXksaVtNZ109VWludDMyQXJyYXksaVtEZ109VWludDMyQXJyYXksaVtQZ109VWludDMyQXJyYXl9ZnVuY3Rpb24gUmcoaSl7c3dpdGNoKGkpe2Nhc2UgSW50OEFycmF5OnJldHVybiBJbztjYXNlIFVpbnQ4QXJyYXk6cmV0dXJuIGlzO2Nhc2UgVWludDhDbGFtcGVkQXJyYXk6cmV0dXJuIGlzO2Nhc2UgSW50MTZBcnJheTpyZXR1cm4gRW87Y2FzZSBVaW50MTZBcnJheTpyZXR1cm4gQm87Y2FzZSBJbnQzMkFycmF5OnJldHVybiBUbztjYXNlIFVpbnQzMkFycmF5OnJldHVybiBNbztjYXNlIEZsb2F0MzJBcnJheTpyZXR1cm4gRG87ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB0eXBlZCBhcnJheSB0eXBlXCIpfX1mdW5jdGlvbiBMZyhpKXtpZihpIGluc3RhbmNlb2YgSW50OEFycmF5KXJldHVybiBJbztpZihpIGluc3RhbmNlb2YgVWludDhBcnJheXx8aSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KXJldHVybiBpcztpZihpIGluc3RhbmNlb2YgSW50MTZBcnJheSlyZXR1cm4gRW87aWYoaSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KXJldHVybiBCbztpZihpIGluc3RhbmNlb2YgSW50MzJBcnJheSlyZXR1cm4gVG87aWYoaSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KXJldHVybiBNbztpZihpIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXJldHVybiBEbzt0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB0eXBlZCBhcnJheSB0eXBlXCIpfWZ1bmN0aW9uIFBvKGkpe2NvbnN0IGU9S2hbaV07aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwidW5rb253IGdsIHR5cGVcIik7cmV0dXJuIGV9ZnVuY3Rpb24gVWcoaSxlPUZsb2F0MzJBcnJheSl7cmV0dXJuIHdnKGkpP2k6bmV3IGUoaSl9Y2xhc3MgcnN7c3RhdGljIGFzeW5jIGFwcGx5KGUsdCl7aWYoIXQuZXh0ZW5zaW9ucylyZXR1cm47Y29uc3Qgcj10LmV4dGVuc2lvbnMuS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb247aWYoIXIpcmV0dXJuO2xldCBzPXRoaXMuX3dvcmtlcnMuZ2V0KGUuZ2x0Zik7c3x8KHM9bmV3IFdvcmtlcihhd2FpdCB0aGlzLmluaXREZWNvZGVyKCkpLHRoaXMuX3dvcmtlcnMuc2V0KGUuZ2x0ZixzKSkscy5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXRcIixkZWNvZGVyQ29uZmlnOnt9fSk7bGV0IGE9ZS5wYXJzZUJ1ZmZlclZpZXcoci5idWZmZXJWaWV3KTtpZighYS5yZXN1bHQpe2xldCBuPWF3YWl0IG5ldyBQcm9taXNlKChsLGgpPT57cy5vbm1lc3NhZ2U9dT0+e2NvbnN0IGM9dS5kYXRhO2MudHlwZT09XCJkZWNvZGVcIj9sKGMucmVzdWx0KTpjLnR5cGU9PVwiZXJyb3JcIiYmaChjLmVycm9yKX0scy5wb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZXJcIixidWZmZXI6YSxhdHRyaWJ1dGVzOnIuYXR0cmlidXRlc30sW2FdKX0pO2EucmVzdWx0PW59cmV0dXJuIGEucmVzdWx0fXN0YXRpYyB1bmxvYWQoZSl7bGV0IHQ9dGhpcy5fd29ya2Vycy5nZXQoZSk7dCYmKHQudGVybWluYXRlKCksdGhpcy5fd29ya2Vycy5kZWxldGUoZSkpfXN0YXRpYyBhc3luYyBpbml0RGVjb2Rlcigpe2lmKCF0aGlzLl93b3JrZXJDb2RlKXtsZXQgZT1hd2FpdCBuZXcgaHQoKS5sb2FkVHh0KFwiaHR0cHM6Ly9jZG4ub3JpbGx1c2lvbi5jb20vZHJhY29fZGVjb2Rlcl9nbHRmLmpzXCIpO2NvbnN0IHQ9bmV3IEJsb2IoW2UuZGF0YSxcIlwiLGAoJHtPZ30pKClgXSx7dHlwZTpcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIn0pO3RoaXMuX3dvcmtlckNvZGU9VVJMLmNyZWF0ZU9iamVjdFVSTCh0KX1yZXR1cm4gdGhpcy5fd29ya2VyQ29kZX19byhycyxcIl93b3JrZXJDb2RlXCIpLG8ocnMsXCJfd29ya2Vyc1wiLG5ldyBNYXApO2Z1bmN0aW9uIE9nKCl7bGV0IGksZTtvbm1lc3NhZ2U9dD0+e2NvbnN0IHI9dC5kYXRhO3N3aXRjaChyLnR5cGUpe2Nhc2VcImluaXRcIjppPXIuZGVjb2RlckNvbmZpZyxlPW5ldyBQcm9taXNlKChuLGwpPT57aS5vbk1vZHVsZUxvYWRlZD1oPT57bih7ZHJhY286aH0pfSxEcmFjb0RlY29kZXJNb2R1bGUoaSl9KTticmVhaztjYXNlXCJkZWNvZGVyXCI6Y29uc3Qgcz1yLmJ1ZmZlcixhPXIuYXR0cmlidXRlcztlLnRoZW4obj0+e2NvbnN0IGw9bi5kcmFjbztsZXQgaD1uZXcgbC5EZWNvZGVyLHU9bmV3IGwuRGVjb2RlckJ1ZmZlcjt1LkluaXQobmV3IEludDhBcnJheShzKSxzLmJ5dGVMZW5ndGgpO2xldCBjLGY7dHJ5e2NvbnN0IGQ9aC5HZXRFbmNvZGVkR2VvbWV0cnlUeXBlKHUpO2Q9PWwuVFJJQU5HVUxBUl9NRVNIPyhmPW5ldyBsLk1lc2gsYz1oLkRlY29kZUJ1ZmZlclRvTWVzaCh1LGYpKTpzZWxmLnBvc3RNZXNzYWdlKG5ldyBFcnJvcihcIklOVkFMSURfR0VPTUVUUllfVFlQRTpcIitkKSksYy5vaygpfHxzZWxmLnBvc3RNZXNzYWdlKG5ldyBFcnJvcihcIkRyYWNvRGVjb2RlOlwiK2MuZXJyb3JfbXNnKCkpKTtsZXQgcD17fTtmb3IoY29uc3QgbSBpbiBhKXtsZXQgXz1oLkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQoZixhW21dKTtjb25zdCB2PV8ubnVtX2NvbXBvbmVudHMoKSxDPWYubnVtX3BvaW50cygpKnYsQj1DKkZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxUPWwuRFRfRkxPQVQzMixNPWwuX21hbGxvYyhCKTtoLkdldEF0dHJpYnV0ZURhdGFBcnJheUZvckFsbFBvaW50cyhmLF8sVCxCLE0pO2NvbnN0IEQ9bmV3IEZsb2F0MzJBcnJheShsLkhFQVBGMzIuYnVmZmVyLE0sQykuc2xpY2UoKTtsLl9mcmVlKE0pLHBbbV09e2RhdGE6RCxudW1Db21wb25lbnRzOnYsbm9ybWFsaXplOiExfX17Y29uc3QgXz1mLm51bV9mYWNlcygpKjMsdj1fKjQseT1sLl9tYWxsb2Modik7aC5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShmLHYseSk7Y29uc3QgQz1uZXcgVWludDMyQXJyYXkobC5IRUFQRjMyLmJ1ZmZlcix5LF8pLnNsaWNlKCk7bC5fZnJlZSh5KSxwLmluZGljZXM9e2RhdGE6QyxudW1Db21wb25lbnRzOjEsbm9ybWFsaXplOiExfX1zZWxmLnBvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlXCIscmVzdWx0OnB9KX1jYXRjaChkKXtzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOlwiZXJyb3JcIixlcnJvcjpkLm1lc3NhZ2V9KX1maW5hbGx5e2wuZGVzdHJveShmKSxsLmRlc3Ryb3koaCksbC5kZXN0cm95KHUpfX0pO2JyZWFrfX19Y2xhc3MgSmh7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwiZ2x0ZlwiKSx0aGlzLmdsdGY9ZX1wYXJzZShlKXtjb25zdCB0PXRoaXMuZ2x0Zi5jYW1lcmFzW2VdO2lmKCF0KXJldHVybiB0aGlzLmVycm9yTWlzcyhcImNhbWVyYVwiLGUpO2lmKHQuaXNQYXJzZWQpcmV0dXJuIHQuZGNhbWVyYTt0LmlzUGFyc2VkPSEwLHQuZGNhbWVyYT0hMTtjb25zdHtuYW1lOnIsdHlwZTpzLHBlcnNwZWN0aXZlOmEsb3J0aG9ncmFwaGljOm59PXQ7aWYocz09PVwicGVyc3BlY3RpdmVcIiYmYSl7Y29uc3R7YXNwZWN0UmF0aW86bCx5Zm92OmgsemZhcjp1LHpuZWFyOmN9PWE7dC5kY2FtZXJhPU9iamVjdC5hc3NpZ24oe30se25hbWU6cix0eXBlOnMseWZvdjpoLHpuZWFyOmMsYXNwZWN0UmF0aW86bCx6ZmFyOnV9KX1lbHNlIGlmKHM9PT1cIm9ydGhvZ3JhcGhpY1wiJiZuKXtjb25zdHt4bWFnOmwseW1hZzpoLHpmYXI6dSx6bmVhcjpjfT1uO3QuZGNhbWVyYT1PYmplY3QuYXNzaWduKHt9LHtuYW1lOnIsdHlwZTpzLHhtYWc6bCx5bWFnOmgsemZhcjp1LHpuZWFyOmN9KX1yZXR1cm4gdC5kY2FtZXJhfWVycm9yTWlzcyhlLHQpe3Rocm93IG5ldyBFcnJvcihlK3QpfX1jb25zdCBaaD1jbGFzcyBleHRlbmRzIFh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxvKHRoaXMsXCJfZ2x0ZlwiKX1hc3luYyBwYXJzZUpzb24oaSl7dGhpcy5fZ2x0Zj1uZXcgWXMsdGhpcy5fZ2x0Zj17Li4udGhpcy5fZ2x0ZiwuLi5pfSx0aGlzLl9nbHRmLnJlc291cmNlcz17fSxhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5sb2FkX2dsdGZfYmluKCksdGhpcy5sb2FkX2dsdGZfdGV4dHVyZXMoKV0pO2xldCBlPW5ldyBqcyx0PWF3YWl0IGUucGFyc2UodGhpcy5pbml0VXJsLHRoaXMuX2dsdGYsdGhpcy5fZ2x0Zi5zY2VuZSk7cmV0dXJuIGUuZGVzdG9yeSgpLGU9bnVsbCx0Pyh0aGlzLmRhdGE9dC5yb290Tm9kZSx0LnJvb3ROb2RlKToodGhpcy5fZ2x0Zj1udWxsLG51bGwpfXZlcmlmaWNhdGlvbigpe2lmKHRoaXMuZGF0YSlyZXR1cm4hMDt0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKX1zdGF0aWMgZ2V0TWVzaE5hbWVDb3VudGVyKCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuYEdMVEZfTk9fTkFNRV9QUklNSVRJVkVfJHtaaC5fY291bnRlcisrfWB9fXN0YXRpYyBnZXRNb2RlbE5hbWVDb3VudGVyKCl7bGV0IGk9MDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm5gR0xURl9OT19OQU1FX01FU0hfJHtpKyt9YH19c3RhdGljIGdldFRleENvb3JkRGVmaW5lKGkpe3JldHVybmBVVl9OVU0gJHtpfWB9c3RhdGljIGdldFZlcnRleENvbG9yRGVmaW5lKGkpe3JldHVybmBIQVNfVkVSVEVYQ09MT1IgJHtpfWB9c3RhdGljIGdldEJhc2VDb2xvclRleHR1cmVEZWZpbmUoKXtyZXR1cm5cIkhBU19CQVNFQ09MT1JNQVBcIn1zdGF0aWMgZ2V0TWV0YWxSb3VnaG5lc3NEZWZpbmUoKXtyZXR1cm5cIkhBU19NRVRBTFJPVUdITkVTU01BUFwifXN0YXRpYyBnZXROb3JtYWxNYXBEZWZpbmUoKXtyZXR1cm5cIkhBU19OT1JNQUxNQVBcIn1zdGF0aWMgZ2V0RW1pc3NpdmVNYXBEZWZpbmUoKXtyZXR1cm5cIkhBU19FTUlTU0lWRU1BUFwifXN0YXRpYyBnZXRPY2NsdXNpb25NYXBEZWZpbmUoKXtyZXR1cm5cIkhBU19PQ0NMVVNJT05NQVBcIn1zdGF0aWMgZ2V0TW9ycGhUYXJnZXRzRGVmaW5lKGkpe3JldHVybmBNT1JQSF9UQVJHRVRfTlVNICR7aX1gfXN0YXRpYyBnZXRNb3JwaHRhcmdldFBvc2l0aW9uRGVmaW5lKCl7cmV0dXJuXCJIQVNfTU9SUEhfUE9TSVRJT05cIn1zdGF0aWMgZ2V0TW9ycGh0YXJnZXROb3JtYWxEZWZpbmUoKXtyZXR1cm5cIkhBU19NT1JQSF9OT1JNQUxcIn1zdGF0aWMgZ2V0TW9ycGh0YXJnZXRUYW5nZW50RGVmaW5lKCl7cmV0dXJuXCJIQVNfTU9SUEhfVEFOR0VOVFwifXN0YXRpYyBnZXRKb2ludHNOdW1EZWZpbmUoaSl7cmV0dXJuYEpPSU5UU19OVU0gJHtpfWB9c3RhdGljIGdldEpvaW50VmVjOERlZmluZSgpe3JldHVyblwiSk9JTlRfVkVDOFwifXN0YXRpYyBnZXRIYXNOb3JtYWxEZWZpbmUoKXtyZXR1cm5cIkhBU19OT1JNQUxcIn1zdGF0aWMgZ2V0SGFzVGFuZ2VudERlZmluZSgpe3JldHVyblwiSEFTX1RBTkdFTlRcIn1zdGF0aWMgZ2V0SGFzTm9ybWFsTWFwRGVmaW5lKCl7cmV0dXJuXCJIQVNfTk9STUFMX01BUFwifXN0YXRpYyBnZXRBbHBoYU1hc2tEZWZpbmUoKXtyZXR1cm5cIkFMUEhBX01BU0tcIn1zdGF0aWMgZ2V0QWxwaGFCbGVuZERlZmluZSgpe3JldHVyblwiQUxQSEFfQkxFTkRcIn1hc3luYyBsb2FkX2dsdGZfYmluKCl7dmFyIGk7aWYodGhpcy5fZ2x0Zi5idWZmZXJzJiZ0aGlzLl9nbHRmLmJ1ZmZlcnMubGVuZ3RoPjApe2xldCBlPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZ2x0Zi5idWZmZXJzLmxlbmd0aDt0Kyspe2NvbnN0IHI9dGhpcy5fZ2x0Zi5idWZmZXJzW3RdO2lmKHIudXJpLnN1YnN0cmluZygwLDUpIT09XCJkYXRhOlwiKXtsZXQgcz1pdC5wYXJzZVVybCh0aGlzLmJhc2VVcmwsci51cmkpOyhpPXRoaXMubG9hZGVyRnVuY3Rpb25zKSE9bnVsbCYmaS5vblVybCYmKHM9YXdhaXQgdGhpcy5sb2FkZXJGdW5jdGlvbnMub25VcmwocykpO2xldCBhPW5ldyBodCgpLmxvYWRCaW5EYXRhKHMsdGhpcy5sb2FkZXJGdW5jdGlvbnMpLnRoZW4obj0+e3RoaXMuX2dsdGYucmVzb3VyY2VzW3IudXJpXT1ufSk7ZS5wdXNoKGEpfX1hd2FpdCBQcm9taXNlLmFsbChlKX19YXN5bmMgbG9hZF9nbHRmX3RleHR1cmVzKCl7dmFyIGk7aWYodGhpcy5fZ2x0Zix0aGlzLl9nbHRmLmltYWdlcyl7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLl9nbHRmLmltYWdlcy5sZW5ndGg7dCsrKXtjb25zdCByPXRoaXMuX2dsdGYuaW1hZ2VzW3RdO2lmKHIudXJpKXtsZXQgcz1pdC5wYXJzZVVybCh0aGlzLmJhc2VVcmwsci51cmkpOyhpPXRoaXMubG9hZGVyRnVuY3Rpb25zKSE9bnVsbCYmaS5vblVybCYmKHM9YXdhaXQgdGhpcy5sb2FkZXJGdW5jdGlvbnMub25VcmwocykpO2xldCBhPW5ldyBodCgpLmxvYWRBc3luY0JpdG1hcFRleHR1cmUocyx0aGlzLmxvYWRlckZ1bmN0aW9ucykudGhlbihuPT57bi5uYW1lPWl0LmdldFVSTE5hbWUoci51cmkpLHRoaXMuX2dsdGYucmVzb3VyY2VzW24ubmFtZV09bn0pO2UucHVzaChhKX19YXdhaXQgUHJvbWlzZS5hbGwoZSl9fX07bGV0IEtlPVpoO28oS2UsXCJmb3JtYXRcIixcImpzb25cIiksbyhLZSxcIl9jb3VudGVyXCIsMCksbyhLZSxcImRlZmF1bHRNYXRlcmlhbFwiLHtuYW1lOlwiR0xURl9ERUZBVUxUX01BVEVSSUFMXCIsYWxwaGFDdXRvZmY6LjMzLGFscGhhTW9kZTpcIk1BU0tcIixwYnJNZXRhbGxpY1JvdWdobmVzczp7bmFtZTpcIkdMVEZfREVGQVVMVF9NQVRFUklBTFwiLGRlZmluZXM6W10sZG91YmxlU2lkZWQ6ITEsYmFzZUNvbG9yRmFjdG9yOlsxLDEsMSwxXSxtZXRhbGxpY0ZhY3RvcjoxLHJvdWdobmVzc0ZhY3RvcjoxLGVtaXNzaXZlRmFjdG9yOlswLDAsMF19fSk7Y2xhc3MgJGh7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwiZ2x0ZlwiKSxvKHRoaXMsXCJzdWJQYXJzZXJcIiksdGhpcy5nbHRmPWUuZ2x0Zix0aGlzLnN1YlBhcnNlcj1lfWFzeW5jIHBhcnNlKGUpe2NvbnN0IHQ9dGhpcy5nbHRmLm1lc2hlc1tlXTtpZighdClyZXR1cm4gdGhpcy5lcnJvck1pc3MoXCJtZXNoXCIsZSk7aWYodC5pc1BhcnNlZClyZXR1cm4gdC5kcHJpbWl0aXZlcztjb25zdCByPXQucHJpbWl0aXZlcyxzPXQuZXh0cmFzLGE9W107Zm9yKGxldCBuPTA7bjxyLmxlbmd0aDtuKyspe2NvbnN0IGw9cltuXSx7YXR0cmlidXRlczpoLGluZGljZXM6dSxtYXRlcmlhbDpjLG1vZGU6ZixuYW1lOmQsdGFyZ2V0czpwLG1vcnBoVGFyZ2V0c1JlbGF0aXZlOm0sZXh0ZW5zaW9uczpffT1sO2xldCB2PXQubmFtZTtmb3IobGV0IFAgaW4gaCl2Kz1QO3YrPWBpbmRpY2VzOiR7dX1gLHYrPWBtYXRlcmlhbDoke2N9YDtjb25zdCB5PXthdHRyaWJBcnJheXM6e2luZGljZXM6W119LHdlaWdodHM6W10sZGVmaW5lczpbXSxtYXRlcmlhbDpudWxsLGRyYXdNb2RlOm51bGwsbWVzaE5hbWU6bnVsbCxtb2RlbE5hbWU6bnVsbCxtb3JwaFRhcmdldHNSZWxhdGl2ZTohMSx0YXJnZXROYW1lczpzP3MudGFyZ2V0TmFtZXM6bnVsbH07bGV0IEM9ITEsQj0wLFQ9ITEsTTtfJiZfLktIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uJiYoTT1hd2FpdCBycy5hcHBseSh0aGlzLnN1YlBhcnNlcixsKSk7Zm9yKGNvbnN0IFAgaW4gaCl7Y29uc3QgTD1NP01bUF06dGhpcy5wYXJzZUFjY2Vzc29yKGhbUF0pO2lmKEwpe2xldCBJO3N3aXRjaChQKXtjYXNlXCJQT1NJVElPTlwiOkk9WS5wb3NpdGlvbjticmVhaztjYXNlXCJOT1JNQUxcIjpJPVkubm9ybWFsLEM9ITA7YnJlYWs7Y2FzZVwiVEVYQ09PUkRfMFwiOkk9WS51dixCKys7YnJlYWs7Y2FzZVwiSk9JTlRTXzBcIjpJPVkuam9pbnRzMDticmVhaztjYXNlXCJKT0lOVFNfMVwiOkk9WS5qb2ludHMxLFQ9ITA7YnJlYWs7Y2FzZVwiV0VJR0hUU18wXCI6ST1ZLndlaWdodHMwO2JyZWFrO2Nhc2VcIldFSUdIVFNfMVwiOkk9WS53ZWlnaHRzMTticmVhaztkZWZhdWx0Okk9UH15LmF0dHJpYkFycmF5c1tJXT1MfX1pZihDJiZ5LmRlZmluZXMucHVzaChLZS5nZXRIYXNOb3JtYWxEZWZpbmUoKSksQiYmeS5kZWZpbmVzLnB1c2goS2UuZ2V0VGV4Q29vcmREZWZpbmUoQikpLFQmJnkuZGVmaW5lcy5wdXNoKEtlLmdldEpvaW50VmVjOERlZmluZSgpKSx1IT09dm9pZCAwKXtjb25zdCBQPU0/TS5pbmRpY2VzOnRoaXMucGFyc2VBY2Nlc3Nvcih1KTtQJiYoeS5hdHRyaWJBcnJheXMuaW5kaWNlcz1QKX1jb25zdCBEPWF3YWl0IHRoaXMucGFyc2VNYXRlcmlhbChjKTtpZihEJiYoeS5tYXRlcmlhbD1ELHkuZGVmaW5lcz15LmRlZmluZXMuY29uY2F0KEQuZGVmaW5lcykpLHkuZHJhd01vZGU9Zj09PXZvaWQgMD80OmYseS5tZXNoTmFtZT0oKT0+dix5Lm1vZGVsTmFtZT10Lm5hbWV8fEtlLmdldE1vZGVsTmFtZUNvdW50ZXIoKSxwKXt5LmRlZmluZXMucHVzaChLZS5nZXRNb3JwaFRhcmdldHNEZWZpbmUocC5sZW5ndGgpKSx5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlPSEwO2xldCBQPSExLEw9ITEsST0hMTtmb3IobGV0IE89MDtPPHAubGVuZ3RoO08rKyl7Y29uc3Qgaz1wW09dO09iamVjdC5rZXlzKGspLmZvckVhY2goSD0+e2NvbnN0IFc9dGhpcy5wYXJzZUFjY2Vzc29yKGtbSF0pO2lmKFcpe2xldCBuZTtzd2l0Y2goSCl7Y2FzZVwiUE9TSVRJT05cIjpuZT1sZS5NT1JQSF9QT1NJVElPTl9QUkVGSVgrTyxQPSEwO2JyZWFrO2Nhc2VcIk5PUk1BTFwiOm5lPWxlLk1PUlBIX05PUk1BTF9QUkVGSVgrTyxMPSEwO2JyZWFrO2Nhc2VcIlRBTkdFTlRcIjpuZT1sZS5NT1JQSF9UQU5HRU5UX1BSRUZJWCtPLEk9ITA7YnJlYWs7ZGVmYXVsdDpuZT0hMX1uZT95LmF0dHJpYkFycmF5c1tuZV09Vzpjb25zb2xlLmVycm9yKGBnbFRGIGhhcyB1bnN1cHBvcnRlZCBtb3JwaCB0YXJnZXQgYXR0cmlidXRlICR7SH1gKX19KX1QJiZ5LmRlZmluZXMucHVzaChLZS5nZXRNb3JwaHRhcmdldFBvc2l0aW9uRGVmaW5lKCkpLEwmJnkuZGVmaW5lcy5wdXNoKEtlLmdldE1vcnBodGFyZ2V0Tm9ybWFsRGVmaW5lKCkpLEkmJnkuZGVmaW5lcy5wdXNoKEtlLmdldE1vcnBodGFyZ2V0VGFuZ2VudERlZmluZSgpKSx5LndlaWdodHM9dC53ZWlnaHRzfHxuZXcgQXJyYXkocC5sZW5ndGgpLmZpbGwoMCl9YS5wdXNoKHkpfXJldHVybiB0LmRwcmltaXRpdmVzPWEsdC5pc1BhcnNlZD0hMCx0LmRwcmltaXRpdmVzfXBhcnNlQWNjZXNzb3IoZSl7cmV0dXJuIHRoaXMuc3ViUGFyc2VyLnBhcnNlQWNjZXNzb3IoZSl9cGFyc2VNYXRlcmlhbChlKXtyZXR1cm4gdGhpcy5zdWJQYXJzZXIucGFyc2VNYXRlcmlhbChlKX1lcnJvck1pc3MoZSx0KXt0aHJvdyBuZXcgRXJyb3IoZSt0KX19Y2xhc3MgZXV7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwiZ2x0ZlwiKSxvKHRoaXMsXCJzdWJQYXJzZXJcIiksdGhpcy5nbHRmPWUuZ2x0Zix0aGlzLnN1YlBhcnNlcj1lfWFzeW5jIHBhcnNlKGUpe2xldCB0O2lmKGU9PW51bGw/dD1LZS5kZWZhdWx0TWF0ZXJpYWw6dD10aGlzLmdsdGYubWF0ZXJpYWxzW2VdLCF0KXJldHVybiB0aGlzLmVycm9yTWlzcyhcIm1hdGVyaWFsXCIsZSk7aWYodC5pc1BhcnNlZClyZXR1cm4gdC5kbWF0ZXJpYWw7bGV0e25hbWU6cixwYnJNZXRhbGxpY1JvdWdobmVzczpzLG5vcm1hbFRleHR1cmU6YSxvY2NsdXNpb25UZXh0dXJlOm4sZW1pc3NpdmVUZXh0dXJlOmwsZW1pc3NpdmVGYWN0b3I6aCxhbHBoYU1vZGU6dSxhbHBoYUN1dG9mZjpjLGRvdWJsZVNpZGVkOmYsZXh0ZW5zaW9uczpkfT10O2NvbnN0IHA9e25hbWU6cixkZWZpbmVzOltdLGRvdWJsZVNpZGVkOiEhZixiYXNlQ29sb3JGYWN0b3I6WzEsMSwxLDFdLGVtaXNzaXZlRmFjdG9yOm51bGwsYWxwaGFDdXRvZmY6MCxlbmFibGVCbGVuZDohMSxiYXNlQ29sb3JUZXh0dXJlOm51bGwsbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOm51bGwsbm9ybWFsVGV4dHVyZTpudWxsLG9jY2x1c2lvblRleHR1cmU6bnVsbCxlbWlzc2l2ZVRleHR1cmU6bnVsbCx0cmFuc2Zvcm1VVjE6bnVsbCx0cmFuc2Zvcm1VVjI6bnVsbCxleHRlbnNpb25zOm51bGx9O2lmKHMpe2NvbnN0e2Jhc2VDb2xvckZhY3RvcjptLG1ldGFsbGljRmFjdG9yOl8scm91Z2huZXNzRmFjdG9yOnYsYmFzZUNvbG9yVGV4dHVyZTp5LG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZTpDfT1zO2lmKE9iamVjdC5hc3NpZ24ocCx7YmFzZUNvbG9yRmFjdG9yOm18fFsxLDEsMSwxXSxtZXRhbGxpY0ZhY3RvcjpfPT09dm9pZCAwPzE6Xyxyb3VnaG5lc3NGYWN0b3I6dj09PXZvaWQgMD8uNTp2fSkseSl7bGV0IEI9eS5leHRlbnNpb25zO2lmKEIpe2xldCBNPUIuS0hSX3RleHR1cmVfdHJhbnNmb3JtO00mJihwLnRyYW5zZm9ybVVWMT1uZXcgaihNLm9mZnNldD9NLm9mZnNldFswXTowLE0ub2Zmc2V0P00ub2Zmc2V0WzFdOjAsTS5zY2FsZT9NLnNjYWxlWzBdOjEsTS5zY2FsZT9NLnNjYWxlWzFdOjEpKX1jb25zdCBUPWF3YWl0IHRoaXMucGFyc2VUZXh0dXJlKHkuaW5kZXgpO1Q/cC5iYXNlQ29sb3JUZXh0dXJlPVQ6cC5iYXNlQ29sb3JUZXh0dXJlPUEucmVzLnJlZFRleHR1cmV9aWYoQyl7Y29uc3QgQj1hd2FpdCB0aGlzLnBhcnNlVGV4dHVyZShDLmluZGV4KTtCP3AubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlPUI6cC5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmU9QS5yZXMuYmxhY2tUZXh0dXJlfX1lbHNlIE9iamVjdC5hc3NpZ24ocCx7YmFzZUNvbG9yRmFjdG9yOlsxLDEsMSwxXSxtZXRhbGxpY0ZhY3RvcjowLHJvdWdobmVzc0ZhY3RvcjouNX0pO2lmKHAuYmFzZUNvbG9yRmFjdG9yJiZwLmJhc2VDb2xvckZhY3RvclszXTwxJiYodT11PT09XCJNQVNLXCI/XCJNQVNLXCI6XCJCTEVORFwiKSx1JiZ1IT09XCJPUEFRVUVcIiYmKHU9PT1cIk1BU0tcIiYmKHAuZGVmaW5lcy5wdXNoKEtlLmdldEFscGhhTWFza0RlZmluZSgpKSxwLmFscGhhQ3V0b2ZmPWM9PT12b2lkIDA/LjU6YyksdT09PVwiQkxFTkRcIiYmKHAuZGVmaW5lcy5wdXNoKEtlLmdldEFscGhhQmxlbmREZWZpbmUoKSkscC5lbmFibGVCbGVuZD0hMCkpLGEpe2NvbnN0IG09YXdhaXQgdGhpcy5wYXJzZVRleHR1cmUoYS5pbmRleCk7bT9wLm5vcm1hbFRleHR1cmU9bTpwLm5vcm1hbFRleHR1cmU9QS5yZXMubm9ybWFsVGV4dHVyZX1pZihuKXtjb25zdCBtPWF3YWl0IHRoaXMucGFyc2VUZXh0dXJlKG4uaW5kZXgpO20mJihwLm9jY2x1c2lvblRleHR1cmU9bSl9aWYoaCYmKHAuZW1pc3NpdmVGYWN0b3I9aCksbCl7Y29uc3QgbT1hd2FpdCB0aGlzLnBhcnNlVGV4dHVyZShsLmluZGV4KTttP3AuZW1pc3NpdmVUZXh0dXJlPW06cC5lbWlzc2l2ZVRleHR1cmU9QS5yZXMuYmxhY2tUZXh0dXJlfXJldHVybiBkJiYocC5leHRlbnNpb25zPWQpLHQuaXNQYXJzZWQ9ITAsdC5kbWF0ZXJpYWw9cCxwfWFzeW5jIHBhcnNlVGV4dHVyZShlKXtyZXR1cm4gdGhpcy5zdWJQYXJzZXIucGFyc2VUZXh0dXJlKGUpfWVycm9yTWlzcyhlLHQpe3Rocm93IG5ldyBFcnJvcihlK3QpfX1jbGFzcyB0dXtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJnbHRmXCIpLG8odGhpcyxcInN1YlBhcnNlclwiKSx0aGlzLmdsdGY9ZS5nbHRmLHRoaXMuc3ViUGFyc2VyPWV9cGFyc2UoZSl7Y29uc3QgdD10aGlzLmdsdGYuc2tpbnNbZV07aWYoIXQpcmV0dXJuIHRoaXMuZXJyb3JNaXNzKFwic2tpblwiLGUpO2lmKHQuaXNQYXJzZWQpcmV0dXJuIHQuZHNraW47Y29uc3R7bmFtZTpyLGpvaW50czpzLGludmVyc2VCaW5kTWF0cmljZXM6YSxza2VsZXRvbjpufT10O2lmKCFzKXJldHVybiB0aGlzLmVycm9yTWlzcyhcInNraW4uam9pbnRzXCIsZSk7dC5pc1BhcnNlZD0hMCx0LmRza2luPSExO2xldCBsPXtuYW1lOnIsc2tlbGV0b246bnVsbCxpbnZlcnNlQmluZE1hdHJpY2VzOm51bGwsam9pbnRzOnMsZGVmaW5lczpbS2UuZ2V0Sm9pbnRzTnVtRGVmaW5lKHMubGVuZ3RoKV19O2lmKG4pbC5za2VsZXRvbj1uO2Vsc2V7dmFyIGg9LTE7Zm9yKGxldCB1PTA7dTx0aGlzLmdsdGYubm9kZXMubGVuZ3RoO3UrKylpZih0aGlzLmdsdGYubm9kZXNbdV0ubmFtZT09XCJyb290XCIpe2g9dTticmVha31pZihoPT0tMSl7bGV0IHU9dGhpcy5nbHRmLnNjZW5lc1t0aGlzLmdsdGYuc2NlbmVdO2g9dS5ub2Rlc1t1Lm5vZGVzLmxlbmd0aC0xXX1sLnNrZWxldG9uPWh9aWYobC5pbnZlcnNlQmluZE1hdHJpY2VzPWxlLklERU5USVRZX0lOVkVSU0VfQklORF9NQVRSSUNFUyxhIT09dm9pZCAwKXtjb25zdCB1PXRoaXMucGFyc2VBY2Nlc3NvcihhKTtpZih1KXtjb25zdCBjPXUuZGF0YSxmPVtdO2ZvcihsZXQgZD0wO2Q8Yy5sZW5ndGg7ZCs9MTYpZi5wdXNoKGMuc2xpY2UoZCxkKzE2KSk7bC5pbnZlcnNlQmluZE1hdHJpY2VzPWZ9ZWxzZSBsPW51bGx9cmV0dXJuIHQuZHNraW49bCx0LmRza2lufXBhcnNlQWNjZXNzb3IoZSl7cmV0dXJuIHRoaXMuc3ViUGFyc2VyLnBhcnNlQWNjZXNzb3IoZSl9ZXJyb3JNaXNzKGUsdCl7dGhyb3cgbmV3IEVycm9yKGUrdCl9fWNsYXNzIGl1e2NvbnN0cnVjdG9yKGU9XCJcIil7byh0aGlzLFwibmFtZVwiLFwiXCIpLG8odGhpcyxcImluZGV4XCIsMCksbyh0aGlzLFwicGFyZW50XCIsbnVsbCksbyh0aGlzLFwiY2hpbGRyZW5cIixbXSksbyh0aGlzLFwic2NhbGVcIixuZXcgZyksbyh0aGlzLFwicm90YXRpb25cIixuZXcgcSksbyh0aGlzLFwidHJhbnNsYXRpb25cIixuZXcgZyksdGhpcy5uYW1lPWV9fWNsYXNzIHJ1e2NvbnN0cnVjdG9yKGU9W10pe28odGhpcyxcImpvaW50c1wiKSx0aGlzLmpvaW50cz1lfWdldCBudW1Kb2ludCgpe3JldHVybiB0aGlzLmpvaW50cy5sZW5ndGh9YWRkSm9pbnQoZSl7ZS5pbmRleD10aGlzLmpvaW50cy5wdXNoKGUpLTF9Z2V0Sm9pbnROYW1lKGUpe3JldHVybiB0aGlzLmpvaW50c1tlXS5uYW1lfWdldEpvaW50UGFyZW50SW5kZXgoZSl7bGV0IHQ9dGhpcy5qb2ludHNbZV07cmV0dXJuIHQucGFyZW50P3QucGFyZW50LmluZGV4Oi0xfWdldEpvaW50QnlOYW1lKGUpe2ZvcihsZXQgdCBvZiB0aGlzLmpvaW50cylpZih0Lm5hbWU9PWUpcmV0dXJuIHQ7cmV0dXJuIG51bGx9fWNsYXNzIFJve2NvbnN0cnVjdG9yKGUsdD0hMSl7byh0aGlzLFwiaW5kZXhcIiksbyh0aGlzLFwid29ybGRNYXRyaXhcIiksdGhpcy5pbmRleD1lLHRoaXMud29ybGRNYXRyaXg9bmV3IFYoIXQpfX1jbGFzcyBzc3tjb25zdHJ1Y3RvcihlLHQ9ITEpe28odGhpcyxcInRpbWVcIiksbyh0aGlzLFwiX3NrZWxldG9uXCIpLG8odGhpcyxcIl9qb2ludHNQb3NlXCIpLG8odGhpcyxcIm1Kb2ludE1hdHJpeEluZGV4VGFibGVcIiksdGhpcy5fc2tlbGV0b249ZSx0aGlzLl9qb2ludHNQb3NlPW5ldyBBcnJheShlLm51bUpvaW50KSx0aGlzLm1Kb2ludE1hdHJpeEluZGV4VGFibGU9bmV3IEFycmF5KGUubnVtSm9pbnQpO2ZvcihsZXQgcj0wO3I8ZS5udW1Kb2ludDtyKyspe2xldCBzPW5ldyBSbyhyLHQpO3RoaXMuX2pvaW50c1Bvc2Vbcl09cyx0aGlzLm1Kb2ludE1hdHJpeEluZGV4VGFibGVbcl09cy53b3JsZE1hdHJpeC5pbmRleH19YnVpbGRTa2VsZXRvblBvc2UoZSl7bGV0IHQ9bmV3IGcscj1uZXcgcSxzPW5ldyBnLGE9bmV3IEFycmF5KHRoaXMuX3NrZWxldG9uLm51bUpvaW50KTt0aGlzLnRpbWU9ZVsxMV0+MD9lWzExXTplWzI0XTtmb3IobGV0IG49MDtuPHRoaXMuX3NrZWxldG9uLm51bUpvaW50O24rKyl7bGV0IGw9MTIqbio0LGg9bmV3IEZsb2F0MzJBcnJheShlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQrbCwxMiksdT1uZXcgVjt0LnNldChoWzBdLGhbMV0saFsyXSksci5zZXQoaFs0XSxoWzVdLGhbNl0saFs3XSkscy5zZXQoaFs4XSxoWzldLGhbMTBdKSxScyhyLmdldEV1bGVyQW5nbGVzKCkscyx0LHUpLGFbbl09dTtsZXQgYz1uZXcgUm8obik7Y29uc3QgZj10aGlzLl9za2VsZXRvbi5nZXRKb2ludFBhcmVudEluZGV4KG4pO2lmKGY8MCljLndvcmxkTWF0cml4LmNvcHlGcm9tKHUpO2Vsc2V7bGV0IGQ9dGhpcy5fam9pbnRzUG9zZVtmXTtfbChkLndvcmxkTWF0cml4LHUsYy53b3JsZE1hdHJpeCl9dGhpcy5fam9pbnRzUG9zZVtuXT1jfX1nZXQgbnVtSm9pbnQoKXtyZXR1cm4gdGhpcy5fc2tlbGV0b24ubnVtSm9pbnR9Z2V0IGpvaW50cygpe3JldHVybiB0aGlzLl9qb2ludHNQb3NlfWdldCBqb2ludE1hdHJpeEluZGV4VGFibGUoKXtyZXR1cm4gdGhpcy5tSm9pbnRNYXRyaXhJbmRleFRhYmxlfWxlcnAoZSx0LHIpe2ZvcihsZXQgcz0wO3M8dGhpcy5fam9pbnRzUG9zZS5sZW5ndGg7cysrKXtsZXQgYT1lLl9qb2ludHNQb3NlW3NdLG49dC5fam9pbnRzUG9zZVtzXTt0aGlzLl9qb2ludHNQb3NlW3NdLndvcmxkTWF0cml4LmxlcnAoYS53b3JsZE1hdHJpeCxuLndvcmxkTWF0cml4LHIpfX1jb3B5RnJvbShlKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2pvaW50c1Bvc2UubGVuZ3RoO3QrKyl0aGlzLl9qb2ludHNQb3NlW3RdLndvcmxkTWF0cml4LmNvcHlGcm9tKGUuX2pvaW50c1Bvc2VbdF0ud29ybGRNYXRyaXgpfXJlc2V0KCl7Zm9yKGxldCBlPTA7ZTx0aGlzLl9qb2ludHNQb3NlLmxlbmd0aDtlKyspdGhpcy5fam9pbnRzUG9zZVtlXS53b3JsZE1hdHJpeC5pZGVudGl0eSgpfX1jbGFzcyBzdSBleHRlbmRzIGple2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSxvKHRoaXMsXCJza2VsZXRvbkFuaW1hdGlvblwiKSx0aGlzLnR5cGU9ZSx0aGlzLnRpbWU9dH19Y2xhc3MgbWF7Y29uc3RydWN0b3IoZSx0LHIscyl7aWYobyh0aGlzLFwibmFtZVwiLFwiXCIpLG8odGhpcyxcIl9za2VsZXRvblwiKSxvKHRoaXMsXCJfc2tlbGV0b25Qb3Nlc1wiKSxvKHRoaXMsXCJfYW5pbWF0aW9uQ2xpcERhdGFcIiksbyh0aGlzLFwiX2V2ZW50c1wiKSx0aGlzLm5hbWU9ZSx0aGlzLl9za2VsZXRvbj10LHRoaXMuX2FuaW1hdGlvbkNsaXBEYXRhPXMscj4wJiZzKXt0aGlzLl9za2VsZXRvblBvc2VzPW5ldyBBcnJheShyKTtsZXQgYT0xMip0Lm51bUpvaW50O2ZvcihsZXQgbj0wO248cjtuKyspe2xldCBsPWEqbio0LGg9bmV3IEZsb2F0MzJBcnJheShzLmJ1ZmZlcixsLGEpLHU9bmV3IHNzKHQpO3UuYnVpbGRTa2VsZXRvblBvc2UoaCksdGhpcy5fc2tlbGV0b25Qb3Nlc1tuXT11fX19Z2V0IHRvdGFsVGltZSgpe3JldHVybiB0aGlzLl9za2VsZXRvblBvc2VzW3RoaXMuX3NrZWxldG9uUG9zZXMubGVuZ3RoLTFdLnRpbWV9Z2V0IGZyYW1lUmF0ZSgpe3JldHVybiB0aGlzLnRvdGFsVGltZS90aGlzLl9za2VsZXRvblBvc2VzLmxlbmd0aH1nZXQgc2tlbGV0b24oKXtyZXR1cm4gdGhpcy5fc2tlbGV0b259Z2V0IG51bUZyYW1lKCl7cmV0dXJuIHRoaXMuX3NrZWxldG9uUG9zZXMubGVuZ3RoLTF9Z2V0IGFuaW1hdGlvbkNsaXBEYXRhKCl7cmV0dXJuIHRoaXMuX2FuaW1hdGlvbkNsaXBEYXRhfWdldFNrZWxldG9uUG9zZShlKXtyZXR1cm4gdGhpcy5fc2tlbGV0b25Qb3Nlc1tlXX1nZXRMZXJwU2tlbGV0b25Qb3NlKGUsdCxyLHMpe2xldCBhPXRoaXMuZ2V0U2tlbGV0b25Qb3NlKGUpLG49dGhpcy5nZXRTa2VsZXRvblBvc2UodCk7cmV0dXJuIHMubGVycChhLG4sciksc31jcmVhdGVTdWJDbGlwKGUsdCxyKXt2YXIgcz1uZXcgbWEoZSx0aGlzLl9za2VsZXRvbiwwLG51bGwpO2NvbnN0IGE9TWF0aC5tYXgoTWF0aC5mbG9vcih0L3RoaXMuZnJhbWVSYXRlKSwwKSxuPU1hdGgubWluKE1hdGguZmxvb3Ioci90aGlzLmZyYW1lUmF0ZSksdGhpcy5fc2tlbGV0b25Qb3Nlcy5sZW5ndGgtMSk7cy5fc2tlbGV0b25Qb3Nlcz10aGlzLl9za2VsZXRvblBvc2VzLnNsaWNlKGEsbik7Y29uc3QgbD0xMip0aGlzLl9za2VsZXRvbi5udW1Kb2ludCo0O3JldHVybiB0aGlzLl9hbmltYXRpb25DbGlwRGF0YT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuX2FuaW1hdGlvbkNsaXBEYXRhLGEqbCwobi1hKSpsKSxzfWFkZEV2ZW50KGUsdCl7dGhpcy5fZXZlbnRzfHwodGhpcy5fZXZlbnRzPW5ldyBBcnJheSksdGhpcy5fZXZlbnRzLnB1c2gobmV3IHN1KGUsdCkpfXJlbW92ZUV2ZW50KGUpe3RoaXMuX2V2ZW50cyYmKHRoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKHQ9PnQudHlwZSE9ZSkpfWdldEV2ZW50cygpe3JldHVybiB0aGlzLl9ldmVudHN9fWNsYXNzIExve2NvbnN0cnVjdG9yKGUpe28odGhpcyxcImdsdGZcIiksbyh0aGlzLFwic3ViUGFyc2VyXCIpLHRoaXMuZ2x0Zj1lLmdsdGYsdGhpcy5zdWJQYXJzZXI9ZX1wYXJzZShlKXtsZXQgdD1uZXcgcnU7cmV0dXJuIHRoaXMuYnVpbGRTa2VsZXRvbih0LHZvaWQgMCxlKSx0fXBhcnNlU2tlbGV0b25BbmltYXRpb24oZSx0KXtsZXQgcj10aGlzLnN1YlBhcnNlci5wYXJzZUFjY2Vzc29yKHQuc2FtcGxlcnNbMF0uaW5wdXQpLmRhdGEubGVuZ3RoLHM9MTIqZS5udW1Kb2ludCxhPW5ldyBGbG9hdDMyQXJyYXkocypyKTtmb3IodmFyIG49MDtuPGUubnVtSm9pbnQ7bisrKWZvcih2YXIgbD0wO2w8cjtsKyspe3ZhciBoPXMqbCsxMipuO2FbaCswXT0xLGFbaCsxXT0xLGFbaCsyXT0xLGFbaCszXT0xfWZvcihsZXQgZiBvZiB0LmNoYW5uZWxzKXtsZXQgZD10LnNhbXBsZXJzW2Yuc2FtcGxlcl07Y29uc3QgcD10aGlzLnN1YlBhcnNlci5wYXJzZUFjY2Vzc29yKGQuaW5wdXQpLG09dGhpcy5zdWJQYXJzZXIucGFyc2VBY2Nlc3NvcihkLm91dHB1dCk7bGV0IF89Zi50YXJnZXQubm9kZSx2PWYudGFyZ2V0LnBhdGgseT10aGlzLmdsdGYubm9kZXNbX107aWYoIXkpY29udGludWU7bGV0IEM9ZS5nZXRKb2ludEJ5TmFtZSh5Lm5hbWUpO3N3aXRjaCh2KXtjYXNlXCJzY2FsZVwiOmZvcih2YXIgbD0wO2w8cjtsKyspe3ZhciB1PWwqbS5udW1Db21wb25lbnRzLGg9cypsKzEyKkMuaW5kZXg7YVtoKzBdPW0uZGF0YVt1KzBdLGFbaCsxXT1tLmRhdGFbdSsxXSxhW2grMl09bS5kYXRhW3UrMl0sYVtoKzNdPTF9YnJlYWs7Y2FzZVwicm90YXRpb25cIjpmb3IodmFyIGw9MDtsPHI7bCsrKXt2YXIgdT1sKm0ubnVtQ29tcG9uZW50cyxoPXMqbCsxMipDLmluZGV4KzQ7YVtoKzBdPW0uZGF0YVt1KzBdLGFbaCsxXT1tLmRhdGFbdSsxXSxhW2grMl09bS5kYXRhW3UrMl0sYVtoKzNdPW0uZGF0YVt1KzNdfWJyZWFrO2Nhc2VcInRyYW5zbGF0aW9uXCI6Zm9yKHZhciBsPTA7bDxyO2wrKyl7dmFyIHU9bCptLm51bUNvbXBvbmVudHMsaD1zKmwrMTIqQy5pbmRleCs4O2FbaCswXT1tLmRhdGFbdSswXSxhW2grMV09bS5kYXRhW3UrMV0sYVtoKzJdPW0uZGF0YVt1KzJdLGFbaCszXT1wLmRhdGFbbCpwLm51bUNvbXBvbmVudHNdfWJyZWFrfX1yZXR1cm4gbmV3IG1hKHQubmFtZSxlLHIsYSl9YnVpbGRTa2VsZXRvbihlLHQscixzPTApe2xldCBhPXRoaXMuZ2x0Zi5ub2Rlc1tyXTthLm5hbWV8fChhLm5hbWU9XCJOb2RlX1wiK3IpO2xldCBuPW5ldyBpdShhLm5hbWUpO2lmKG4ucGFyZW50PXQsYS5zY2FsZSYmbi5zY2FsZS5zZXQoYS5zY2FsZVswXSxhLnNjYWxlWzFdLGEuc2NhbGVbMl0pLGEucm90YXRpb24mJm4ucm90YXRpb24uc2V0KGEucm90YXRpb25bMF0sYS5yb3RhdGlvblsxXSxhLnJvdGF0aW9uWzJdLGEucm90YXRpb25bM10pLGEudHJhbnNsYXRpb24mJm4udHJhbnNsYXRpb24uc2V0KGEudHJhbnNsYXRpb25bMF0sYS50cmFuc2xhdGlvblsxXSxhLnRyYW5zbGF0aW9uWzJdKSxlLmFkZEpvaW50KG4pLGEuY2hpbGRyZW4pZm9yKGxldCBsIG9mIGEuY2hpbGRyZW4pdGhpcy5idWlsZFNrZWxldG9uKGUsbixsLHMrMSl9fWNsYXNzIGF1e2NvbnN0cnVjdG9yKGUpe28odGhpcyxcImxvb3BcIiwhMCksbyh0aGlzLFwic3BlZWRcIiwxKSxvKHRoaXMsXCJ0XCIsMCksbyh0aGlzLFwidGltZVwiLDApLG8odGhpcyxcIndlaWdodFwiLDApLG8odGhpcyxcImN1cnJGcmFtZVwiLDApLG8odGhpcyxcImxhc3RGcmFtZVwiLC0xKSxvKHRoaXMsXCJuZXh0RnJhbWVcIiwwKSxvKHRoaXMsXCJjbGlwXCIpLG8odGhpcyxcImFuaW1hdGlvblwiKSxvKHRoaXMsXCJfaXNFbmRcIiwhMSksbyh0aGlzLFwiX2N1cnJTa2VsZXRvblBvc2VcIiksdGhpcy5jbGlwPWUsdGhpcy5fY3VyclNrZWxldG9uUG9zZT1uZXcgc3ModGhpcy5jbGlwLnNrZWxldG9uKX1yZXNldCgpe3RoaXMudGltZT0wLHRoaXMud2VpZ2h0PTAsdGhpcy5faXNFbmQ9ITF9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpcy5jbGlwLm5hbWV9Z2V0IGN1cnJTa2VsZXRvblBvc2UoKXtyZXR1cm4gdGhpcy5fY3VyclNrZWxldG9uUG9zZX11cGRhdGUoZSl7dGhpcy50aW1lPSh0aGlzLnRpbWUrZSp0aGlzLnNwZWVkKSV0aGlzLmNsaXAudG90YWxUaW1lO2xldCB0PXRoaXMudGltZS90aGlzLmNsaXAuZnJhbWVSYXRlO2lmKHRoaXMuY3VyckZyYW1lPU1hdGgudHJ1bmModCksdGhpcy50PXQtdGhpcy5jdXJyRnJhbWUsdGhpcy5jdXJyRnJhbWU8MCYmKHRoaXMuY3VyckZyYW1lPXRoaXMuY2xpcC5udW1GcmFtZSt0aGlzLmN1cnJGcmFtZSksdGhpcy50aW1lPj0wP3RoaXMubmV4dEZyYW1lPSh0aGlzLmN1cnJGcmFtZSsxKSV0aGlzLmNsaXAubnVtRnJhbWU6KHRoaXMubmV4dEZyYW1lPXRoaXMuY3VyckZyYW1lLTEsdGhpcy5uZXh0RnJhbWU8MCYmKHRoaXMubmV4dEZyYW1lPXRoaXMuY2xpcC5udW1GcmFtZSt0aGlzLm5leHRGcmFtZSksdGhpcy50PTEtdGhpcy50KSx0aGlzLl9pc0VuZCl0aGlzLmN1cnJGcmFtZT10aGlzLm5leHRGcmFtZT10aGlzLnNwZWVkPDA/MDp0aGlzLmNsaXAubnVtRnJhbWUtMTtlbHNlIGlmKHRoaXMuY3VyckZyYW1lIT10aGlzLmxhc3RGcmFtZSl7bGV0IGE9dGhpcy5zcGVlZDwwPzA6dGhpcy5jbGlwLm51bUZyYW1lO3RoaXMuY3VyckZyYW1lPT1hJiYodGhpcy5sb29wPyh0aGlzLmN1cnJGcmFtZT0wLHRoaXMubmV4dEZyYW1lPTEsdGhpcy50aW1lPXRoaXMudD0wKToodGhpcy5jdXJyRnJhbWU9dGhpcy5uZXh0RnJhbWU9dGhpcy5zcGVlZDwwPzA6dGhpcy5jbGlwLm51bUZyYW1lLTEsdGhpcy5faXNFbmQ9ITApKTt2YXIgcj10aGlzLmNsaXAuZ2V0RXZlbnRzKCk7aWYocilmb3IobGV0IG4gb2Ygcil7dmFyIHM9TWF0aC5mbG9vcihuLnRpbWUvdGhpcy5jbGlwLmZyYW1lUmF0ZSk7aWYocz1NYXRoLm1pbihzLHRoaXMuY2xpcC5udW1GcmFtZSkscz1NYXRoLm1heChzLDApLHM9PXRoaXMuY3VyckZyYW1lKXtuLnNrZWxldG9uQW5pbWF0aW9uPXRoaXMuYW5pbWF0aW9uLHRoaXMuYW5pbWF0aW9uLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KG4pO2JyZWFrfX10aGlzLmxhc3RGcmFtZT10aGlzLmN1cnJGcmFtZX10aGlzLmNsaXAuZ2V0TGVycFNrZWxldG9uUG9zZSh0aGlzLmN1cnJGcmFtZSx0aGlzLm5leHRGcmFtZSx0aGlzLnQsdGhpcy5fY3VyclNrZWxldG9uUG9zZSl9fWNsYXNzIHZpIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcImlzUGxheWluZ1wiLCEwKSxvKHRoaXMsXCJ0aW1lU2NhbGVcIiwxKSxvKHRoaXMsXCJfc2tlbGV0b25cIiksbyh0aGlzLFwiX2NsaXBzXCIsW10pLG8odGhpcyxcIl9jbGlwU3RhdGVzXCIsbmV3IE1hcCksbyh0aGlzLFwiX21peFNrZWxldG9uUG9zZVwiKSxvKHRoaXMsXCJfbWl4VGVtcFNrZWxldG9uUG9zZVwiKSxvKHRoaXMsXCJfY3VycmVudENsaXBTdGF0ZVwiKSxvKHRoaXMsXCJfYmluZExpc3RcIixbXSksbyh0aGlzLFwiX2pvaW50TWF0cml4SW5kZXhUYWJsZUJ1ZmZlclwiKSxvKHRoaXMsXCJfY3Jvc3NGYWRlU3RhdGVcIil9c3RhcnQoKXt9Z2V0IGN1cnJOYW1lKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRDbGlwU3RhdGU/dGhpcy5fY3VycmVudENsaXBTdGF0ZS5uYW1lOlwiXCJ9c2V0IHNrZWxldG9uKGUpe3RoaXMuX3NrZWxldG9uPWUsdGhpcy5fbWl4U2tlbGV0b25Qb3NlPW5ldyBzcyh0aGlzLl9za2VsZXRvbiwhMCksdGhpcy5fbWl4VGVtcFNrZWxldG9uUG9zZT1uZXcgc3ModGhpcy5fc2tlbGV0b24pO2NvbnN0IHQ9bmV3IEZsb2F0MzJBcnJheSh0aGlzLl9taXhTa2VsZXRvblBvc2Uuam9pbnRNYXRyaXhJbmRleFRhYmxlKTt0aGlzLl9qb2ludE1hdHJpeEluZGV4VGFibGVCdWZmZXI9bmV3IGdlKHRoaXMuX3NrZWxldG9uLm51bUpvaW50KjQsMCx0KX1nZXQgc2tlbGV0b24oKXtyZXR1cm4gdGhpcy5fc2tlbGV0b259Z2V0IGZpbmFsU2tlbGV0b25Qb3NlKCl7cmV0dXJuIHRoaXMuX21peFNrZWxldG9uUG9zZX1nZXQgam9pbnRNYXRyaXhJbmRleFRhYmxlQnVmZmVyKCl7cmV0dXJuIHRoaXMuX2pvaW50TWF0cml4SW5kZXhUYWJsZUJ1ZmZlcn1nZXRKb2ludEluZGV4VGFibGUoZSl7bGV0IHQ9bmV3IEFycmF5O2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtjb25zdCBzPWVbcl07bGV0IGE9dGhpcy5fc2tlbGV0b24uZ2V0Sm9pbnRCeU5hbWUocyk7dFtyXT1hP2EuaW5kZXg6LTF9cmV0dXJuIHR9YWRkQW5pbWF0aW9uQ2xpcChlKXtpZighdGhpcy5fY2xpcFN0YXRlcy5oYXMoZS5uYW1lKSl7dGhpcy5fY2xpcHMucHVzaChlKTtsZXQgdD1uZXcgYXUoZSk7dC5hbmltYXRpb249dGhpcyx0aGlzLl9jbGlwU3RhdGVzLnNldChlLm5hbWUsdCksdGhpcy5fY3VycmVudENsaXBTdGF0ZXx8dGhpcy5zZXRDdXJyZW50Q2xpcFN0YXRlKHQpfX1nZXRBbmltYXRpb25DbGlwKGUpe3ZhciB0PXRoaXMuZ2V0QW5pbWF0aW9uQ2xpcFN0YXRlKGUpO3JldHVybiB0P3QuY2xpcDpudWxsfWdldEFuaW1hdGlvbkNsaXBzKCl7cmV0dXJuIHRoaXMuX2NsaXBzfWdldEFuaW1hdGlvbkNsaXBTdGF0ZShlKXtyZXR1cm4gdGhpcy5fY2xpcFN0YXRlcy5oYXMoZSk/dGhpcy5fY2xpcFN0YXRlcy5nZXQoZSk6bnVsbH1nZXRBbmltYXRpb25DbGlwU3RhdGVzKCl7cmV0dXJuIHRoaXMuX2NsaXBTdGF0ZXN9cGF1c2UoKXt0aGlzLmlzUGxheWluZz0hMX1yZXN1bWUoKXt0aGlzLmlzUGxheWluZz0hMH1wbGF5KGUsdD0xLHI9ITEpe2lmKHRoaXMuX2N1cnJlbnRDbGlwU3RhdGUmJnRoaXMuX2N1cnJlbnRDbGlwU3RhdGUubmFtZT09ZSlyZXR1cm4gciYmdGhpcy5fY3VycmVudENsaXBTdGF0ZS5yZXNldCgpLCExO2xldCBzPXRoaXMuZ2V0QW5pbWF0aW9uQ2xpcFN0YXRlKGUpO3JldHVybiBzPyhzLnNwZWVkPXQscy5yZXNldCgpLHRoaXMuX2NsaXBTdGF0ZXMuZm9yRWFjaCgoYSxuKT0+e2Eud2VpZ2h0PTB9KSx0aGlzLnNldEN1cnJlbnRDbGlwU3RhdGUocyksITApOiExfWNyb3NzRmFkZShlLHQpe2lmKHQ8LjAxKXt0aGlzLnBsYXkoZSk7cmV0dXJufWlmKHRoaXMuX2N1cnJlbnRDbGlwU3RhdGUubmFtZT09ZSlyZXR1cm47bGV0IHI9dGhpcy5nZXRBbmltYXRpb25DbGlwU3RhdGUoZSk7ciYmKHIucmVzZXQoKSx0aGlzLl9jcm9zc0ZhZGVTdGF0ZT8odGhpcy5fY3Jvc3NGYWRlU3RhdGUuaW5DbGlwJiYodGhpcy5fY3Jvc3NGYWRlU3RhdGUuaW5DbGlwLndlaWdodD0wKSx0aGlzLl9jcm9zc0ZhZGVTdGF0ZS5vdXRDbGlwJiYodGhpcy5fY3Jvc3NGYWRlU3RhdGUub3V0Q2xpcC53ZWlnaHQ9MCksdGhpcy5fY3Jvc3NGYWRlU3RhdGUucmVzZXQocix0aGlzLl9jdXJyZW50Q2xpcFN0YXRlLHQpKTp0aGlzLl9jcm9zc0ZhZGVTdGF0ZT1uZXcgTmcocix0aGlzLl9jdXJyZW50Q2xpcFN0YXRlLHQpLHRoaXMuX2N1cnJlbnRDbGlwU3RhdGU9cil9c2V0QW5pbUlzTG9vcChlLHQpe3RoaXMuX2NsaXBTdGF0ZXMuaGFzKGUpJiYodGhpcy5fY2xpcFN0YXRlcy5nZXQoZSkubG9vcD10KX1hZGRKb2ludEJpbmQoZSx0KXt0aGlzLl9iaW5kTGlzdC5wdXNoKHtqb2ludE5hbWU6ZSxvYmo6dH0pfXJlbW92ZUpvaW50QmluZChlKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2JpbmRMaXN0Lmxlbmd0aDt0KyspaWYodGhpcy5fYmluZExpc3RbdF0ub2JqPT1lKXt0aGlzLl9iaW5kTGlzdC5zcGxpY2UodCwxKTticmVha319b25VcGRhdGUoKXtpZighdGhpcy5pc1BsYXlpbmcpcmV0dXJuO2xldCBlPWhlLmRlbHRhKi4wMDEqdGhpcy50aW1lU2NhbGU7dGhpcy5fY3Jvc3NGYWRlU3RhdGUmJnRoaXMuX2Nyb3NzRmFkZVN0YXRlLnVwZGF0ZShlKTt2YXIgdD0wLHI9W107aWYodGhpcy5fY2xpcFN0YXRlcy5mb3JFYWNoKChhLG4pPT57YS53ZWlnaHQ+MCYmKGEudXBkYXRlKGUpLHQrPWEud2VpZ2h0LHIucHVzaChhKSl9KSxyLmxlbmd0aD4wKXt0aGlzLl9taXhTa2VsZXRvblBvc2UuY29weUZyb20oclswXS5jdXJyU2tlbGV0b25Qb3NlKTtmb3IodmFyIHM9MTtzPHIubGVuZ3RoOysrcyl7Y29uc3QgYT1yW3NdO3RoaXMuX21peFRlbXBTa2VsZXRvblBvc2UubGVycCh0aGlzLl9taXhTa2VsZXRvblBvc2UsYS5jdXJyU2tlbGV0b25Qb3NlLGEud2VpZ2h0L3QpLHRoaXMuX21peFNrZWxldG9uUG9zZS5jb3B5RnJvbSh0aGlzLl9taXhUZW1wU2tlbGV0b25Qb3NlKX19fWNsb25lVG8oZSl7bGV0IHQ9ZS5hZGRDb21wb25lbnQodmkpO3Quc2tlbGV0b249dGhpcy5za2VsZXRvbjtmb3IodmFyIHI9MDtyPHRoaXMuX2NsaXBzLmxlbmd0aDsrK3IpdC5hZGRBbmltYXRpb25DbGlwKHRoaXMuX2NsaXBzW3JdKX1zZXRDdXJyZW50Q2xpcFN0YXRlKGUpe3RoaXMuX2N1cnJlbnRDbGlwU3RhdGUhPWUmJih0aGlzLl9jdXJyZW50Q2xpcFN0YXRlPWUsdGhpcy5fY3VycmVudENsaXBTdGF0ZS53ZWlnaHQ9MSl9fWNsYXNzIE5ne2NvbnN0cnVjdG9yKGUsdCxyKXtvKHRoaXMsXCJpbkNsaXBcIiksbyh0aGlzLFwib3V0Q2xpcFwiKSxvKHRoaXMsXCJjdXJyZW50VGltZVwiKSxvKHRoaXMsXCJjcm9zc0ZhZGVUaW1lXCIpLHRoaXMucmVzZXQoZSx0LHIpfXJlc2V0KGUsdCxyKXt0aGlzLmluQ2xpcD1lLHRoaXMub3V0Q2xpcD10LHRoaXMuY3VycmVudFRpbWU9MCx0aGlzLmNyb3NzRmFkZVRpbWU9cn11cGRhdGUoZSl7IXRoaXMuaW5DbGlwfHwhdGhpcy5vdXRDbGlwfHwodGhpcy5jdXJyZW50VGltZSs9ZSx0aGlzLmluQ2xpcC53ZWlnaHQ9TWF0aC5taW4oTWF0aC5hYnModGhpcy5jdXJyZW50VGltZSV0aGlzLmNyb3NzRmFkZVRpbWUpL3RoaXMuY3Jvc3NGYWRlVGltZSwxKSx0aGlzLm91dENsaXAud2VpZ2h0PTEtdGhpcy5pbkNsaXAud2VpZ2h0LE1hdGguYWJzKHRoaXMuY3VycmVudFRpbWUpPj10aGlzLmNyb3NzRmFkZVRpbWUmJih0aGlzLmluQ2xpcC53ZWlnaHQ9MSx0aGlzLm91dENsaXAud2VpZ2h0PTAsdGhpcy5pbkNsaXA9bnVsbCx0aGlzLm91dENsaXA9bnVsbCkpfX1jbGFzcyBYc3tzdGF0aWMgYWRkKGUpe3RoaXMubGlzdC5pbmRleE9mKGUpPT0tMSYmdGhpcy5saXN0LnB1c2goZSl9c3RhdGljIHJlbW92ZShlKXtsZXQgdD10aGlzLmxpc3QuaW5kZXhPZihlKTt0IT0tMSYmdGhpcy5saXN0LnNwbGljZSh0LDEpfX1vKFhzLFwibGlzdFwiLFtdKTtjbGFzcyBXcyBleHRlbmRzIEVle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJuYW1lXCIpLG8odGhpcyxcInNpemVcIiwxKSxvKHRoaXMsXCJsaWdodERhdGFcIiksbyh0aGlzLFwiZGlyRml4XCIsMSksbyh0aGlzLFwiYmluZE9uQ2hhbmdlXCIpLG8odGhpcyxcIm5lZWRVcGRhdGVTaGFkb3dcIiwhMCksbyh0aGlzLFwicmVhbFRpbWVTaGFkb3dcIiwhMCksbyh0aGlzLFwiX2Nhc3RHSVwiLCExKSxvKHRoaXMsXCJfY2FzdFNoYWRvd1wiLCExKSxvKHRoaXMsXCJfaWVzUHJvZmlsZXNcIil9aW5pdCgpe3RoaXMudHJhbnNmb3JtLm9iamVjdDNELmJvdW5kPW5ldyBCZShuZXcgZyxuZXcgZyksdGhpcy5saWdodERhdGE9bmV3IEdyLHRoaXMubGlnaHREYXRhLmxpZ2h0TWF0cml4SW5kZXg9dGhpcy50cmFuc2Zvcm0ud29ybGRNYXRyaXguaW5kZXh9b25DaGFuZ2UoKXt0aGlzLmJpbmRPbkNoYW5nZSYmdGhpcy5iaW5kT25DaGFuZ2UoKSx0aGlzLnRyYW5zZm9ybS5vYmplY3QzRC5ib3VuZC5zZXRGcm9tQ2VudGVyQW5kU2l6ZSh0aGlzLnRyYW5zZm9ybS53b3JsZFBvc2l0aW9uLG5ldyBnKHRoaXMuc2l6ZSx0aGlzLnNpemUsdGhpcy5zaXplKSksdGhpcy5fY2FzdEdJJiYoUS5pbnN0YW5jZS5zdGF0ZS5naUxpZ2h0aW5nQ2hhbmdlPSEwKSx0aGlzLl9jYXN0U2hhZG93Pyh0aGlzLm5lZWRVcGRhdGVTaGFkb3c9ITAsVmUuYWRkU2hhZG93TGlnaHQodGhpcykpOlZlLnJlbW92ZVNoYWRvd0xpZ2h0KHRoaXMpfXN0YXJ0KCl7dGhpcy50cmFuc2Zvcm0ub25Qb3NpdGlvbkNoYW5nZT0oKT0+dGhpcy5vblBvc2l0aW9uQ2hhbmdlKCksdGhpcy50cmFuc2Zvcm0ub25TY2FsZUNoYW5nZT0oKT0+dGhpcy5vblNjYWxlQ2hhbmdlKCksdGhpcy50cmFuc2Zvcm0ub25Sb3RhdGlvbkNoYW5nZT0oKT0+dGhpcy5vblJvdENoYW5nZSgpLHRoaXMub25Qb3NpdGlvbkNoYW5nZSgpLHRoaXMub25Sb3RDaGFuZ2UoKSx0aGlzLm9uU2NhbGVDaGFuZ2UoKX1vblBvc2l0aW9uQ2hhbmdlKCl7dGhpcy5saWdodERhdGEubGlnaHRQb3NpdGlvbi5jb3B5RnJvbSh0aGlzLnRyYW5zZm9ybS53b3JsZFBvc2l0aW9uKX1vblJvdENoYW5nZSgpe3RoaXMuZGlyRml4PT0xP3RoaXMubGlnaHREYXRhLmRpcmVjdGlvbi5jb3B5RnJvbSh0aGlzLnRyYW5zZm9ybS5mb3J3YXJkKTp0aGlzLmxpZ2h0RGF0YS5kaXJlY3Rpb24uY29weUZyb20odGhpcy50cmFuc2Zvcm0uYmFjayksdGhpcy5saWdodERhdGEubGlnaHRUYW5nZW50LmNvcHlGcm9tKHRoaXMudHJhbnNmb3JtLnVwKSx0aGlzLm9uQ2hhbmdlKCl9b25TY2FsZUNoYW5nZSgpe3RoaXMub25DaGFuZ2UoKX1vbkVuYWJsZSgpe3RoaXMub25DaGFuZ2UoKSxRLmluc3RhbmNlLmFkZExpZ2h0KHRoaXMudHJhbnNmb3JtLnNjZW5lM0QsdGhpcyl9b25EaXNhYmxlKCl7dGhpcy5vbkNoYW5nZSgpLFEuaW5zdGFuY2UucmVtb3ZlTGlnaHQodGhpcy50cmFuc2Zvcm0uc2NlbmUzRCx0aGlzKSxWZS5yZW1vdmVTaGFkb3dMaWdodCh0aGlzKX1zZXQgaWVzUHJvZmlsZXMoZSl7dGhpcy5faWVzUHJvZmlsZXM9ZSx0aGlzLmxpZ2h0RGF0YS5pZXNJbmRleD1lLmluZGV4LEJpLnVzZT0hMCx0aGlzLm9uQ2hhbmdlKCl9Z2V0IGllc1Byb2ZpbGUoKXtyZXR1cm4gdGhpcy5faWVzUHJvZmlsZXN9Z2V0IHIoKXtyZXR1cm4gdGhpcy5saWdodERhdGEubGlnaHRDb2xvci5yfXNldCByKGUpe3RoaXMubGlnaHREYXRhLmxpZ2h0Q29sb3Iucj1lLHRoaXMub25DaGFuZ2UoKX1nZXQgZygpe3JldHVybiB0aGlzLmxpZ2h0RGF0YS5saWdodENvbG9yLmd9c2V0IGcoZSl7dGhpcy5saWdodERhdGEubGlnaHRDb2xvci5nPWUsdGhpcy5vbkNoYW5nZSgpfWdldCBiKCl7cmV0dXJuIHRoaXMubGlnaHREYXRhLmxpZ2h0Q29sb3IuYn1zZXQgYihlKXt0aGlzLmxpZ2h0RGF0YS5saWdodENvbG9yLmI9ZSx0aGlzLm9uQ2hhbmdlKCl9Z2V0IGxpZ2h0Q29sb3IoKXtyZXR1cm4gdGhpcy5saWdodERhdGEubGlnaHRDb2xvcn1zZXQgbGlnaHRDb2xvcihlKXt0aGlzLmxpZ2h0RGF0YS5saWdodENvbG9yPWUsdGhpcy5vbkNoYW5nZSgpfWdldCBpbnRlbnNpdHkoKXtyZXR1cm4gdGhpcy5saWdodERhdGEuaW50ZW5zaXR5fXNldCBpbnRlbnNpdHkoZSl7dGhpcy5saWdodERhdGEuaW50ZW5zaXR5PWUsdGhpcy5vbkNoYW5nZSgpfXNldCBjYXN0U2hhZG93KGUpe2UhPXRoaXMuX2Nhc3RTaGFkb3cmJih0aGlzLl9jYXN0U2hhZG93PWUsdGhpcy5vbkNoYW5nZSgpKX1nZXQgY2FzdFNoYWRvdygpe3JldHVybiB0aGlzLl9jYXN0U2hhZG93fWdldCBzaGFkb3dJbmRleCgpe3JldHVybiB0aGlzLmxpZ2h0RGF0YS5jYXN0U2hhZG93SW5kZXh9Z2V0IGNhc3RHSSgpe3JldHVybiB0aGlzLl9jYXN0R0l9c2V0IGNhc3RHSShlKXtlP1hzLmFkZCh0aGlzKTpYcy5yZW1vdmUodGhpcyksdGhpcy5fY2FzdEdJPWUsZSYmdGhpcy5vbkNoYW5nZSgpfWdldCBkaXJlY3Rpb24oKXtyZXR1cm4gdGhpcy5saWdodERhdGEuZGlyZWN0aW9ufWRlc3Ryb3koZSl7dGhpcy5iaW5kT25DaGFuZ2U9bnVsbCxRLmluc3RhbmNlLnJlbW92ZUxpZ2h0KHRoaXMudHJhbnNmb3JtLnNjZW5lM0QsdGhpcyksVmUucmVtb3ZlU2hhZG93TGlnaHQodGhpcyksdGhpcy50cmFuc2Zvcm0uZXZlbnREaXNwYXRjaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoT2UuUk9UQVRJT05fT05DSEFOR0UsdGhpcy5vblJvdENoYW5nZSx0aGlzKSx0aGlzLnRyYW5zZm9ybS5ldmVudERpc3BhdGNoZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihPZS5TQ0FMRV9PTkNIQU5HRSx0aGlzLm9uU2NhbGVDaGFuZ2UsdGhpcyksc3VwZXIuZGVzdHJveShlKX19Y2xhc3Mgb3UgZXh0ZW5kcyBXc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwic2hhZG93Q2FtZXJhXCIpfWluaXQoKXtzdXBlci5pbml0KCksdGhpcy5vYmplY3QzRC5uYW1lPT1cIlwiJiYodGhpcy5vYmplY3QzRC5uYW1lPVwiRGlyZWN0aW9uTGlnaHRfXCIrUHQoKSksdGhpcy5yYWRpdXM9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsdGhpcy5saWdodERhdGEubGlnaHRUeXBlPVFlLkRpcmVjdGlvbkxpZ2h0LHRoaXMubGlnaHREYXRhLmxpbmVhcj0wLHRoaXMubGlnaHREYXRhLnF1YWRyYXRpYz0uM31zdGFydCgpe3N1cGVyLnN0YXJ0KCksdGhpcy5jYXN0R0k9ITB9Z2V0IHJhZGl1cygpe3JldHVybiB0aGlzLmxpZ2h0RGF0YS5yYW5nZX1zZXQgcmFkaXVzKGUpe3RoaXMubGlnaHREYXRhLnJhbmdlPWUsdGhpcy5vbkNoYW5nZSgpfWdldCBpbmRpcmVjdCgpe3JldHVybiB0aGlzLmxpZ2h0RGF0YS5xdWFkcmF0aWN9c2V0IGluZGlyZWN0KGUpe3RoaXMubGlnaHREYXRhLnF1YWRyYXRpYz1lLHRoaXMub25DaGFuZ2UoKX1kZWJ1Zygpe319Y2xhc3MgbnUgZXh0ZW5kcyBXc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9aW5pdCgpe3N1cGVyLmluaXQoKSx0aGlzLmxpZ2h0RGF0YS5saWdodFR5cGU9UWUuUG9pbnRMaWdodCx0aGlzLm9iamVjdDNELm5hbWU9PVwiXCImJih0aGlzLm9iamVjdDNELm5hbWU9XCJQb2ludExpZ2h0XCIrUHQoKSl9Z2V0IHJhbmdlKCl7cmV0dXJuIHRoaXMubGlnaHREYXRhLnJhbmdlfXNldCByYW5nZShlKXt0aGlzLmxpZ2h0RGF0YS5yYW5nZT1lLHRoaXMub25DaGFuZ2UoKX1nZXQgYXQoKXtyZXR1cm4gdGhpcy5saWdodERhdGEubGluZWFyfXNldCBhdChlKXt0aGlzLmxpZ2h0RGF0YS5saW5lYXI9ZSx0aGlzLm9uQ2hhbmdlKCl9Z2V0IHJhZGl1cygpe3JldHVybiB0aGlzLmxpZ2h0RGF0YS5yYWRpdXN9c2V0IHJhZGl1cyhlKXt0aGlzLmxpZ2h0RGF0YS5yYWRpdXM9ZSx0aGlzLm9uQ2hhbmdlKCl9Z2V0IHF1YWRyYXRpYygpe3JldHVybiB0aGlzLmxpZ2h0RGF0YS5xdWFkcmF0aWN9c2V0IHF1YWRyYXRpYyhlKXt0aGlzLmxpZ2h0RGF0YS5xdWFkcmF0aWM9ZSx0aGlzLm9uQ2hhbmdlKCl9c3RhcnQoKXt0aGlzLnRyYW5zZm9ybS5yb3RhdGlvblg9OTAsc3VwZXIuc3RhcnQoKX1vblVwZGF0ZSgpe31vbkdyYXBoaWMoZSl7bGV0IHQ9ZS5ncmFwaGljM0QuY3JlYXRlQ3VzdG9tU2hhcGUoYFBvaW50TGlnaHRfJHt0aGlzLm9iamVjdDNELmluc3RhbmNlSUR9YCx0aGlzLnRyYW5zZm9ybSk7dC5idWlsZEF4aXMoKSx0LmJ1aWxkQ2lyY2xlKGcuWkVSTyx0aGlzLnJhbmdlLDMyLGcuWF9BWElTKSx0LmJ1aWxkQ2lyY2xlKGcuWkVSTyx0aGlzLnJhbmdlLDMyLGcuWV9BWElTKSx0LmJ1aWxkQ2lyY2xlKGcuWkVSTyx0aGlzLnJhbmdlLDMyLGcuWl9BWElTKX1kZWJ1Zygpe31kZWJ1Z0RyYXcoZSl7fX1jbGFzcyBsdSBleHRlbmRzIFdze2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1pbml0KCl7c3VwZXIuaW5pdCgpLHRoaXMubGlnaHREYXRhLmxpZ2h0VHlwZT1RZS5TcG90TGlnaHQsdGhpcy5vYmplY3QzRC5uYW1lPT1cIlwiJiYodGhpcy5vYmplY3QzRC5uYW1lPVwiU3BvdExpZ2h0XCIrUHQoKSl9Z2V0IGlubmVyQW5nbGUoKXtyZXR1cm4gdGhpcy5saWdodERhdGEuaW5uZXJBbmdsZS90aGlzLmxpZ2h0RGF0YS5vdXRlckFuZ2xlKjEwMH1zZXQgaW5uZXJBbmdsZShlKXt0aGlzLmxpZ2h0RGF0YS5pbm5lckFuZ2xlPUsoZSwwLDEwMCkvMTAwKnRoaXMubGlnaHREYXRhLm91dGVyQW5nbGUsdGhpcy5vbkNoYW5nZSgpfWdldCBvdXRlckFuZ2xlKCl7cmV0dXJuIHRoaXMubGlnaHREYXRhLm91dGVyQW5nbGUqcWkqMn1zZXQgb3V0ZXJBbmdsZShlKXt0aGlzLmxpZ2h0RGF0YS5vdXRlckFuZ2xlPUsoZSwxLDE3OSkqX2UqLjUsdGhpcy5vbkNoYW5nZSgpfWdldCByYWRpdXMoKXtyZXR1cm4gdGhpcy5saWdodERhdGEucmFkaXVzfXNldCByYWRpdXMoZSl7dGhpcy5saWdodERhdGEucmFkaXVzPWUsdGhpcy5vbkNoYW5nZSgpfWdldCByYW5nZSgpe3JldHVybiB0aGlzLmxpZ2h0RGF0YS5yYW5nZX1zZXQgcmFuZ2UoZSl7dGhpcy5saWdodERhdGEucmFuZ2U9ZSx0aGlzLm9uQ2hhbmdlKCl9Z2V0IGF0KCl7cmV0dXJuIHRoaXMubGlnaHREYXRhLmxpbmVhcn1zZXQgYXQoZSl7dGhpcy5saWdodERhdGEubGluZWFyPWUsdGhpcy5vbkNoYW5nZSgpfXN0YXJ0KCl7c3VwZXIuc3RhcnQoKSx0aGlzLmxpZ2h0RGF0YS5saWdodFR5cGU9UWUuU3BvdExpZ2h0fW9uVXBkYXRlKCl7fW9uR3JhcGhpYyhlKXtsZXQgdD1lLmdyYXBoaWMzRC5jcmVhdGVDdXN0b21TaGFwZShgU3BvdExpZ2h0XyR7dGhpcy5vYmplY3QzRC5pbnN0YW5jZUlEfWAsdGhpcy50cmFuc2Zvcm0pO2NvbnN0IHI9dGhpcy5yYW5nZSxzPXRoaXMub3V0ZXJBbmdsZS8yO3QuYnVpbGRBeGlzKCk7bGV0IGE9KDkwLXMpKl9lLG49cipNYXRoLmNvcyhhKSxsPXIqTWF0aC5zaW4oYSk7dC5idWlsZExpbmVzKFtnLlpFUk8sbmV3IGcoMCxuLGwpXSksdC5idWlsZExpbmVzKFtnLlpFUk8sbmV3IGcobiwwLGwpXSksYT0oOTArcykqX2Usbj1yKk1hdGguY29zKGEpLGw9cipNYXRoLnNpbihhKSx0LmJ1aWxkTGluZXMoW2cuWkVSTyxuZXcgZygwLG4sbCldKSx0LmJ1aWxkTGluZXMoW2cuWkVSTyxuZXcgZyhuLDAsbCldKSx0LmJ1aWxkQXJjTGluZShnLlpFUk8sciw5MC1zLDkwK3MsMTYsZy5YX0FYSVMpLHQuYnVpbGRBcmNMaW5lKGcuWkVSTyxyLDkwLXMsOTArcywxNixnLllfQVhJUyksdC5idWlsZENpcmNsZShuZXcgZygwLDAscipNYXRoLnNpbihhKSkscipNYXRoLmNvcyhhKSwzMixnLlpfQVhJUyl9ZGVidWcoKXt9ZGVidWdEcmF3KGUpe319Y2xhc3MgQWEgZXh0ZW5kcyBjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwic2tpbkpvaW50c05hbWVcIiksbyh0aGlzLFwibUludmVyc2VCaW5kTWF0cml4RGF0YVwiKSxvKHRoaXMsXCJtSW52ZXJzZUJpbmRNYXRyaXhCdWZmZXJcIiksbyh0aGlzLFwibVNrZWxldG9uQW5pbWF0aW9uXCIpLG8odGhpcyxcIm1Kb2ludEluZGV4VGFibGVCdWZmZXJcIiksdGhpcy5hZGRSZW5kZXJlck1hc2soVWUuU2tpbm5lZE1lc2gpfXN0YXJ0KCl7aWYoc3VwZXIuc3RhcnQoKSx0aGlzLnNrZWxldG9uQW5pbWF0aW9uPXRoaXMub2JqZWN0M0QuZ2V0Q29tcG9uZW50KHZpKSwhdGhpcy5za2VsZXRvbkFuaW1hdGlvbil7bGV0IGU9dGhpcy5vYmplY3QzRC5wYXJlbnRPYmplY3QucGFyZW50T2JqZWN0LmdldENvbXBvbmVudHNJbkNoaWxkKHZpKTtlLmxlbmd0aD4wJiYodGhpcy5za2VsZXRvbkFuaW1hdGlvbj1lWzBdKSx0aGlzLnNrZWxldG9uQW5pbWF0aW9ufHwodGhpcy5za2VsZXRvbkFuaW1hdGlvbj10aGlzLm9iamVjdDNELmdldENvbXBvbmVudEZyb21QYXJlbnQodmkpKX19b25FbmFibGUoKXtzdXBlci5vbkVuYWJsZSgpfWdldCBza2VsZXRvbkFuaW1hdGlvbigpe3JldHVybiB0aGlzLm1Ta2VsZXRvbkFuaW1hdGlvbn1zZXQgc2tlbGV0b25BbmltYXRpb24oZSl7aWYodGhpcy5tU2tlbGV0b25BbmltYXRpb249ZSwhIWUmJiF0aGlzLm1Kb2ludEluZGV4VGFibGVCdWZmZXIpe2xldCB0PXRoaXMubVNrZWxldG9uQW5pbWF0aW9uLmdldEpvaW50SW5kZXhUYWJsZSh0aGlzLnNraW5Kb2ludHNOYW1lKTt0aGlzLm1Kb2ludEluZGV4VGFibGVCdWZmZXI9bmV3IGdlKHQubGVuZ3RoKjQsMCxuZXcgRmxvYXQzMkFycmF5KHQpKSx0aGlzLm1Kb2ludEluZGV4VGFibGVCdWZmZXIudmlzaWJpbGl0eT1HUFVTaGFkZXJTdGFnZS5WRVJURVh8R1BVU2hhZGVyU3RhZ2UuQ09NUFVURX19Z2V0IHNraW5JbnZlcnNlQmluZE1hdHJpY2VzKCl7cmV0dXJuIHRoaXMubUludmVyc2VCaW5kTWF0cml4RGF0YX1zZXQgc2tpbkludmVyc2VCaW5kTWF0cmljZXMoZSl7dGhpcy5tSW52ZXJzZUJpbmRNYXRyaXhEYXRhPWU7dmFyIHQ9bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCoxNik7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBzPXIqMTYsYT1lW3JdO3Quc2V0KGEscyl9dGhpcy5tSW52ZXJzZUJpbmRNYXRyaXhCdWZmZXI9bmV3IGdlKHQuYnl0ZUxlbmd0aCwwLHQpLHRoaXMubUludmVyc2VCaW5kTWF0cml4QnVmZmVyLnZpc2liaWxpdHk9R1BVU2hhZGVyU3RhZ2UuVkVSVEVYfEdQVVNoYWRlclN0YWdlLkNPTVBVVEV9Z2V0IGludmVyc2VCaW5kTWF0cml4QnVmZmVyKCl7cmV0dXJuIHRoaXMubUludmVyc2VCaW5kTWF0cml4QnVmZmVyfWdldCBqb2ludEluZGV4VGFibGVCdWZmZXIoKXtyZXR1cm4gdGhpcy5tSm9pbnRJbmRleFRhYmxlQnVmZmVyLmJ1ZmZlcn1jbG9uZVRvKGUpe2xldCB0PWUuYWRkQ29tcG9uZW50KEFhKTt0Lmdlb21ldHJ5PXRoaXMuZ2VvbWV0cnksdC5tYXRlcmlhbD10aGlzLm1hdGVyaWFsLmNsb25lKCksdC5jYXN0U2hhZG93PXRoaXMuY2FzdFNoYWRvdyx0LmNhc3RHST10aGlzLmNhc3RHSSx0LnJlY2VpdmVTaGFkb3c9dGhpcy5yZWNlaXZlU2hhZG93LHQucmVuZGVyZXJNYXNrPXRoaXMucmVuZGVyZXJNYXNrLHQuc2tpbkpvaW50c05hbWU9dGhpcy5za2luSm9pbnRzTmFtZSx0LnNraW5JbnZlcnNlQmluZE1hdHJpY2VzPXRoaXMuc2tpbkludmVyc2VCaW5kTWF0cmljZXMsdC5tSm9pbnRJbmRleFRhYmxlQnVmZmVyPXRoaXMubUpvaW50SW5kZXhUYWJsZUJ1ZmZlcn1ub2RlVXBkYXRlKGUsdCxyLHMpe2ZvcihsZXQgYT0wO2E8dGhpcy5tYXRlcmlhbHMubGVuZ3RoO2ErKyl7bGV0IGw9dGhpcy5tYXRlcmlhbHNbYV0uZ2V0UGFzcyh0KTtpZihsKWZvcihsZXQgaD0wO2g8bC5sZW5ndGg7aCsrKXtjb25zdCB1PWxbaF07dS5waXBlbGluZXx8KHUuc2V0U3RvcmFnZUJ1ZmZlcihcImpvaW50c01hdHJpeEluZGV4VGFibGVcIix0aGlzLm1Ta2VsZXRvbkFuaW1hdGlvbi5qb2ludE1hdHJpeEluZGV4VGFibGVCdWZmZXIpLHUuc2V0U3RvcmFnZUJ1ZmZlcihcImpvaW50c0ludmVyc2VNYXRyaXhcIix0aGlzLm1JbnZlcnNlQmluZE1hdHJpeEJ1ZmZlciksdS5zZXRTdG9yYWdlQnVmZmVyKFwiam9pbnRzSW5kZXhNYXBpbmdUYWJsZVwiLHRoaXMubUpvaW50SW5kZXhUYWJsZUJ1ZmZlcikpfX1zdXBlci5ub2RlVXBkYXRlKGUsdCxyLHMpfX1jbGFzcyBodXtzdGF0aWMgYXBwbHkoZSx0LHIpe2xldCBzPXQuZXh0ZW5zaW9ucztpZihzJiZzLktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0KXtyLmRlZmF1bHRQYXNzLnNldERlZmluZShcIlVTRV9DTEVBUkNPQVRcIiwhMCk7bGV0IGE9cy5LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdDtcImNsZWFyY29hdEZhY3RvclwiaW4gYSYmKHQuY2xlYXJjb2F0RmFjdG9yPWEuY2xlYXJjb2F0RmFjdG9yLHIuY2xlYXJjb2F0RmFjdG9yPXQuY2xlYXJjb2F0RmFjdG9yKSxcImNsZWFyY29hdFJvdWdobmVzc0ZhY3RvclwiaW4gYSYmKHQuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yPWEuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yLHIuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yPXQuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yKX19fWNsYXNzIHV1e3N0YXRpYyBhcHBseShlLHQscil7bGV0IHM9dC5leHRlbnNpb25zO3MmJnMuS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aD8oci5lbWlzc2l2ZUludGVuc2l0eT1zLktIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGguZW1pc3NpdmVTdHJlbmd0aCouNSxyLmVtaXNzaXZlTWFwPT1BLnJlcy5ibGFja1RleHR1cmUmJihyLmVtaXNzaXZlTWFwPUEucmVzLndoaXRlVGV4dHVyZSkpOnIuZW1pc3NpdmVJbnRlbnNpdHk9MX19Y2xhc3MgY3V7c3RhdGljIGFwcGx5KGUsdCxyKXtsZXQgcz10LmV4dGVuc2lvbnM7cyYmcy5LSFJfbWF0ZXJpYWxzX3VubGl0P3Iuc3VwcG9ydExpZ2h0PSEwOnIuc3VwcG9ydExpZ2h0PSExfX1jbGFzcyBmdXtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJnbHRmXCIpLG8odGhpcyxcInN1YlBhcnNlclwiKSxvKHRoaXMsXCJfdGVzdENvdW50XCIsOCksbyh0aGlzLFwiX2hhc0Nhc3RTaGFkb3dcIiwhMSksdGhpcy5nbHRmPWUuZ2x0Zix0aGlzLnN1YlBhcnNlcj1lfWFzeW5jIGNvbnZlcnROb2RlVG9PYmplY3QzRChlLHQpe2NvbnN0IHI9bmV3IHRlO2lmKHIubmFtZT1lLm5hbWUscltsZS5HTFRGX05PREVfSU5ERVhfUFJPUEVSVFldPWUubm9kZUlkLGUubm9kZU9iaj1yLGUubWF0cml4JiYoZS50cmFuc2xhdGlvbj1bMCwwLDBdLGUucm90YXRpb249WzAsMCwwLDFdLGUuc2NhbGU9WzEsMSwxXSksZS50cmFuc2xhdGlvbiYmKHIudHJhbnNmb3JtLng9ZS50cmFuc2xhdGlvblswXSxyLnRyYW5zZm9ybS55PWUudHJhbnNsYXRpb25bMV0sci50cmFuc2Zvcm0uej1lLnRyYW5zbGF0aW9uWzJdKSxlLnJvdGF0aW9uKXtsZXQgcz1uZXcgcTtzLnNldEZyb21BcnJheShlLnJvdGF0aW9uKSxyLnRyYW5zZm9ybS5sb2NhbFJvdFF1YXQ9c31pZihlLnNjYWxlJiYoci50cmFuc2Zvcm0uc2NhbGVYPWUuc2NhbGVbMF0sci50cmFuc2Zvcm0uc2NhbGVZPWUuc2NhbGVbMV0sci50cmFuc2Zvcm0uc2NhbGVaPWUuc2NhbGVbMl0pLHQuYWRkQ2hpbGQociksZS5saWdodCYmdGhpcy5jb252ZXJ0TGlnaHQoZSxyKSxlLnByaW1pdGl2ZXMmJnRoaXMuY29udmVydHByaW1pdGl2ZXMoZSxyKSxlLnNrZWxldG9uKXtsZXQgcz1yLmFkZENvbXBvbmVudCh2aSk7aWYocyl7cy5za2VsZXRvbj10aGlzLnN1YlBhcnNlci5wYXJzZVNrZWxldG9uKGUuc2tlbGV0b24uc2tlbGV0b24pO2ZvcihsZXQgYT0wO2E8dGhpcy5nbHRmLmFuaW1hdGlvbnMubGVuZ3RoO2ErKyl7bGV0IG49dGhpcy5nbHRmLmFuaW1hdGlvbnNbYV07bi5uYW1lfHwobi5uYW1lPWEudG9TdHJpbmcoKSk7bGV0IGw9dGhpcy5zdWJQYXJzZXIucGFyc2VTa2VsZXRvbkFuaW1hdGlvbihzLnNrZWxldG9uLG4pO3MuYWRkQW5pbWF0aW9uQ2xpcChsKX19fXJldHVybiByfWNvbnZlcnRMaWdodChlLHQpe3N3aXRjaChlLmxpZ2h0LnR5cGUpe2Nhc2VcImRpcmVjdGlvbmFsXCI6bGV0IHI9dC5hZGRDb21wb25lbnQob3UpO3QubmFtZT1lLmxpZ2h0Lm5hbWUsci5pbnRlbnNpdHk9ZS5saWdodC5pbnRlbnNpdHkqLjEsci5yYWRpdXM9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsci5kaXJGaXg9LTEsdGhpcy5faGFzQ2FzdFNoYWRvd3x8KHRoaXMuX2hhc0Nhc3RTaGFkb3c9ITAsci5jYXN0U2hhZG93PXRoaXMuX2hhc0Nhc3RTaGFkb3cpLHIubGlnaHRDb2xvcj1lLmxpZ2h0LmNvbG9yP25ldyB6KGUubGlnaHQuY29sb3JbMF0sZS5saWdodC5jb2xvclsxXSxlLmxpZ2h0LmNvbG9yWzJdKTpuZXcgeigxLDEsMSwxKSxyLmRlYnVnKCk7YnJlYWs7Y2FzZVwicG9pbnRcIjppZih0aGlzLl90ZXN0Q291bnQ+MCl7bGV0IGE9dC5hZGRDb21wb25lbnQobnUpO2EubmFtZT1lLmxpZ2h0Lm5hbWUsYS5pbnRlbnNpdHk9ZS5saWdodC5pbnRlbnNpdHk/ZS5saWdodC5pbnRlbnNpdHkqOCoyOjEsYS5yYWRpdXM9OCxhLmF0PTIsYS5yYW5nZT1lLmxpZ2h0LnJhbmdlP2UubGlnaHQucmFuZ2U6OCxhLmxpZ2h0Q29sb3I9ZS5saWdodC5jb2xvcj9uZXcgeihlLmxpZ2h0LmNvbG9yWzBdLGUubGlnaHQuY29sb3JbMV0sZS5saWdodC5jb2xvclsyXSk6bmV3IHooMSwxLDEsMSl9dGhpcy5fdGVzdENvdW50LS07YnJlYWs7Y2FzZVwic3BvdFwiOmxldCBzPXQuYWRkQ29tcG9uZW50KGx1KTtzLm5hbWU9ZS5saWdodC5uYW1lLHMuaW50ZW5zaXR5PWUubGlnaHQuaW50ZW5zaXR5KjUscy5yYWRpdXM9MSxzLmRpckZpeD0tMSxzLmF0PTIscy5yYW5nZT1lLmxpZ2h0LnJhbmdlP2UubGlnaHQucmFuZ2U6OCxzLm91dGVyQW5nbGU9ZS5saWdodC5zcG90Lm91dGVyQ29uZUFuZ2xlKnFpLHMubGlnaHRDb2xvcj1lLmxpZ2h0LmNvbG9yP25ldyB6KGUubGlnaHQuY29sb3JbMF0sZS5saWdodC5jb2xvclsxXSxlLmxpZ2h0LmNvbG9yWzJdKTpuZXcgeigxLDEsMSwxKTticmVha319Y29udmVydHByaW1pdGl2ZXMoZSx0KXtmb3IobGV0IHI9MDtyPGUucHJpbWl0aXZlcy5sZW5ndGg7cisrKXtjb25zdCBzPWUucHJpbWl0aXZlc1tyXTtzLm1vZGVsTmFtZTtsZXQgYT1zLm1hdGVyaWFsO2EubmFtZT09bnVsbCYmKGEubmFtZT1QdCgpKTtsZXQgbixsPWBtYXRrZXlfJHthLm5hbWV9YDtpZihhJiZ0aGlzLmdsdGYucmVzb3VyY2VzW2xdKW49dGhpcy5nbHRmLnJlc291cmNlc1tsXTtlbHNle2xldCBkPW49bmV3IHlpO2lmKHRoaXMuZ2x0Zi5yZXNvdXJjZXNbbF09ZCxkLm5hbWU9YS5uYW1lLHMubWF0ZXJpYWwpe2NvbnN0e2Jhc2VDb2xvclRleHR1cmU6cCxiYXNlQ29sb3JGYWN0b3I6bSxtZXRhbGxpY0ZhY3RvcjpfLHJvdWdobmVzc0ZhY3Rvcjp2LGRvdWJsZVNpZGVkOnksbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOkMsbm9ybWFsVGV4dHVyZTpCLG9jY2x1c2lvblRleHR1cmU6VCxlbWlzc2l2ZVRleHR1cmU6TSxlbWlzc2l2ZUZhY3RvcjpELGVuYWJsZUJsZW5kOlAsYWxwaGFDdXRvZmY6TH09cy5tYXRlcmlhbDtsZXQgST1kPXRoaXMuYXBwbHlNYXRlcmlhbEV4dGVuc2lvbnMocy5tYXRlcmlhbCxkKTtpZihcImVuYWJsZUJsZW5kXCJpbiBzLm1hdGVyaWFsJiYocy5tYXRlcmlhbC5lbmFibGVCbGVuZD8oSS5ibGVuZE1vZGU9eGUuTk9STUFMLEkuZGVwdGhXcml0ZUVuYWJsZWQ9ITEpOkkuYmxlbmRNb2RlPXhlLk5PTkUscy5tYXRlcmlhbC5kZWZpbmVzJiZzLm1hdGVyaWFsLmRlZmluZXMuaW5kZXhPZihcIkFMUEhBX0JMRU5EXCIpIT0tMSYmKEkuYmxlbmRNb2RlPXhlLkFMUEhBLEkudHJhbnNwYXJlbnQ9ITAsSS5kZXB0aFdyaXRlRW5hYmxlZD0hMSkpLFwiYWxwaGFDdXRvZmZcImluIHMubWF0ZXJpYWwmJkw+MCYmKEkuYWxwaGFDdXRvZmY9TCxJLmJsZW5kTW9kZT14ZS5OT1JNQUwsSS50cmFuc3BhcmVudD0hMCxJLmRlcHRoV3JpdGVFbmFibGVkPSExKSxzLm1hdGVyaWFsLnRyYW5zZm9ybVVWMSYmKEkudXZUcmFuc2Zvcm1fMT1zLm1hdGVyaWFsLnRyYW5zZm9ybVVWMSkscy5tYXRlcmlhbC50cmFuc2Zvcm1VVjImJihJLnV2VHJhbnNmb3JtXzI9cy5tYXRlcmlhbC50cmFuc2Zvcm1VVjIpLEkuYmFzZUNvbG9yPW5ldyB6KG1bMF0sbVsxXSxtWzJdLG1bM10pLEkucm91Z2huZXNzPXYsSS5tZXRhbGxpYz1fLEkuZG91YmxlU2lkZT15LEkuYW89MSxwJiYoSS5iYXNlTWFwPXApLEImJihJLm5vcm1hbE1hcD1CKSxDJiYoSS5tYXNrTWFwPUMpLFQmJkMhPVQmJihJLmFvTWFwPVQpLE0mJihJLmVtaXNzaXZlTWFwPU0pLEQmJihEWzBdPjB8fERbMV0+MHx8RFsyXT4wKSl7SS5lbWlzc2l2ZU1hcCYmSS5lbWlzc2l2ZU1hcD09QS5yZXMuYmxhY2tUZXh0dXJlJiYoSS5lbWlzc2l2ZU1hcD1BLnJlcy53aGl0ZVRleHR1cmUpO2xldCBPPURbM10/RFszXToxO0kuZW1pc3NpdmVDb2xvcj1uZXcgeihEWzBdLERbMV0sRFsyXSxPKSxJLmVtaXNzaXZlSW50ZW5zaXR5PTF9fX1jb25zdHthdHRyaWJBcnJheXM6aCxtb2RlbE5hbWU6dSxkcmF3TW9kZTpjfT1zO2xldCBmO2lmKCFoLmluZGljZXMuZGF0YSl7bGV0IGQ9W10scD1oLnBvc2l0aW9uLmRhdGEubGVuZ3RoLzMvMztmb3IobGV0IG09MDttPHA7bSsrKXtsZXQgXz1tKjM7ZC5wdXNoKF8rMiksZC5wdXNoKF8rMCksZC5wdXNoKF8rMSl9aC5pbmRpY2VzPXtkYXRhOm5ldyBVaW50OEFycmF5KGQpLG5vcm1hbGl6ZTohMSxudW1Db21wb25lbnRzOjF9fWlmKCFoLm5vcm1hbCl7bGV0IGQ9W10scD1oLnBvc2l0aW9uLmRhdGEubGVuZ3RoLzM7Zm9yKGxldCBtPTA7bTxwO20rKylkLnB1c2goMCksZC5wdXNoKDApLGQucHVzaCgwKTtoLm5vcm1hbD17ZGF0YTpuZXcgRmxvYXQzMkFycmF5KGQpLG5vcm1hbGl6ZTohMSxudW1Db21wb25lbnRzOjN9fWlmKGguaW5kaWNlcy5kYXRhJiZoLmluZGljZXMuZGF0YS5sZW5ndGg+Myl7bGV0IGQ9cy5tZXNoTmFtZSgpO3RoaXMuZ2x0Zi5yZXNvdXJjZXNbZF0/Zj10aGlzLmdsdGYucmVzb3VyY2VzW2RdOihmfHwoZj10aGlzLmNyZWF0ZUdlb21ldHJ5QmFzZShkLGgscykpLHRoaXMuZ2x0Zi5yZXNvdXJjZXNbZF09Zik7Y29uc3QgcD1uZXcgdGU7aWYocC5uYW1lPXUrcix0aGlzLmdsdGYuYW5pbWF0aW9ucyYmaFtZLmpvaW50czBdIT1udWxsKXtmfHwoZj10aGlzLmNyZWF0ZUdlb21ldHJ5QmFzZSh1LGgscykpLHRoaXMuZ2x0Zi5yZXNvdXJjZXNbZF09ZjtsZXQgbT10aGlzLmdsdGYubm9kZXNbZS5za2luLnNrZWxldG9uXTtpZihtLmRub2RlJiZtLmRub2RlLm5vZGVPYmope2xldCB5PW0uZG5vZGUubm9kZU9iai5hZGRDb21wb25lbnQodmkpO2lmKHkpe3kuc2tlbGV0b249dGhpcy5zdWJQYXJzZXIucGFyc2VTa2VsZXRvbihlLnNraW4uc2tlbGV0b24pO2ZvcihsZXQgQz0wO0M8dGhpcy5nbHRmLmFuaW1hdGlvbnMubGVuZ3RoO0MrKyl7bGV0IEI9dGhpcy5nbHRmLmFuaW1hdGlvbnNbQ107Qi5uYW1lfHwoQi5uYW1lPUMudG9TdHJpbmcoKSk7bGV0IFQ9dGhpcy5zdWJQYXJzZXIucGFyc2VTa2VsZXRvbkFuaW1hdGlvbih5LnNrZWxldG9uLEIpO3kuYWRkQW5pbWF0aW9uQ2xpcChUKX19fWVsc2UgbS5kbm9kZS5za2VsZXRvbj1lLnNraW47bGV0IF89cC5hZGRDb21wb25lbnQoQWEpO18uY2FzdFNoYWRvdz0hMCxfLmNhc3RHST0hMCxfLmdlb21ldHJ5PWYsXy5tYXRlcmlhbD1uLF8uc2tpbkpvaW50c05hbWU9dGhpcy5wYXJzZVNraW5Kb2ludHMoZS5za2luKSxfLnNraW5JbnZlcnNlQmluZE1hdHJpY2VzPWUuc2tpbi5pbnZlcnNlQmluZE1hdHJpY2VzfWVsc2V7Znx8KGY9dGhpcy5jcmVhdGVHZW9tZXRyeUJhc2UodSxoLHMpKSx0aGlzLmdsdGYucmVzb3VyY2VzW2RdPWYsZi5oYXNBdHRyaWJ1dGUoWS5qb2ludHMwKSYmZi52ZXJ0ZXhBdHRyaWJ1dGVNYXAuZGVsZXRlKFkuam9pbnRzMCk7bGV0IG09cC5hZGRDb21wb25lbnQoY2UpO20uY2FzdFNoYWRvdz0hMCxtLmNhc3RHST0hMCxtLmdlb21ldHJ5PWYsbS5tYXRlcmlhbD1ufWUuc2tpbiYmZS5za2luLmRlZmluZXMsdC5hZGRDaGlsZChwKX19fWNyZWF0ZUdlb21ldHJ5QmFzZShlLHQscil7bGV0IHM9bmV3IHR0O3MubmFtZT1lLHMubW9ycGhUYXJnZXRzUmVsYXRpdmU9ci5tb3JwaFRhcmdldHNSZWxhdGl2ZTtsZXQgYT1yLnRhcmdldE5hbWVzO2lmKGEmJmEubGVuZ3RoPjApe2xldCBsPXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5PXt9O2ZvcihsZXQgaD0wO2g8YS5sZW5ndGg7aCsrKWxbYVtoXV09aH1pZihzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSl7bGV0IGw9dC5wb3NpdGlvbi5kYXRhLmxlbmd0aC8zLGg9bmV3IEZsb2F0MzJBcnJheShsKTtmb3IobGV0IHU9MDt1PGw7dSsrKWhbdV09dTt0LnZJbmRleD17ZGF0YTpoLG5vcm1hbGl6ZTohMSxudW1Db21wb25lbnRzOjF9fWZvcihjb25zdCBsIGluIHQpe2xldCBoPXRbbF07cy5zZXRBdHRyaWJ1dGUobCxoLmRhdGEpfWxldCBuPXMuZ2V0QXR0cmlidXRlKFkuaW5kaWNlcyk7cmV0dXJuIHMuYWRkU3ViR2VvbWV0cnkoe2luZGV4U3RhcnQ6MCxpbmRleENvdW50Om4uZGF0YS5sZW5ndGgsdmVydGV4U3RhcnQ6MCxpbmRleDowfSksc31hcHBseU1hdGVyaWFsRXh0ZW5zaW9ucyhlLHQpe3JldHVybiBodS5hcHBseSh0aGlzLmdsdGYsZSx0KSxjdS5hcHBseSh0aGlzLmdsdGYsZSx0KSx1dS5hcHBseSh0aGlzLmdsdGYsZSx0KSx0fXBhcnNlU2tpbkpvaW50cyhlKXtsZXQgdD1bXTtmb3IobGV0IHIgb2YgZS5qb2ludHMpe2xldCBzPXRoaXMuZ2x0Zi5ub2Rlc1tyXTt0LnB1c2gocy5uYW1lKX1yZXR1cm4gdH19Y2xhc3MganN7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJjdXJyZW50U2NlbmVOYW1lXCIpLG8odGhpcyxcImdsdGZcIiksbyh0aGlzLFwiaW5pdFVybFwiKSxvKHRoaXMsXCJfZ2VuZXJhdG9yXCIpLG8odGhpcyxcIl92ZXJzaW9uXCIpLG8odGhpcyxcIl9CQVNFNjRfTUFSS0VSXCIsXCI7YmFzZTY0LFwiKSxvKHRoaXMsXCJfY2FtZXJhUGFyc2VyXCIsbnVsbCksbyh0aGlzLFwiX21lc2hQYXJzZXJcIixudWxsKSxvKHRoaXMsXCJfbWF0ZXJpYWxQYXJzZXJcIixudWxsKSxvKHRoaXMsXCJfc2tpblBhcnNlclwiLG51bGwpLG8odGhpcyxcIl9za2VsZXRvblBhcnNlclwiLG51bGwpLG8odGhpcyxcIl9jb252ZXJ0ZXJcIixudWxsKX1nZXQgdmVyc2lvbigpe3JldHVybiB0aGlzLnZlcnNpb24/dGhpcy52ZXJzaW9uOnRoaXMuZ2x0Zj90aGlzLmdsdGYuYXNzZXQ/KHRoaXMuX3ZlcnNpb249dGhpcy5nbHRmLmFzc2V0LnZlcnNpb24sdGhpcy5nbHRmLmFzc2V0Lm1pblZlcnNpb24mJih0aGlzLl92ZXJzaW9uKz1gXFxyIG1pblZlcnNpb24ke3RoaXMuZ2x0Zi5hc3NldC5taW5WZXJzaW9ufWApLHRoaXMudmVyc2lvbik6dGhpcy5lcnJvck1pc3MoXCJhc3NldFwiKTooY29uc29sZS53YXJuKFwiZ2xURiBub3QgbG9hZGVkLlwiKSxudWxsKX1hc3luYyBwYXJzZShlLHQscil7dGhpcy5nbHRmPXQsdGhpcy5pbml0VXJsPWU7Y29uc3R7dmVyc2lvbjpzLGdlbmVyYXRvcjphfT10aGlzLmdsdGYuYXNzZXQ7aWYodGhpcy5fZ2VuZXJhdG9yPWEscyE9PVwiMi4wXCIpcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEdMVEZQYXJzZXIgb25seSBzdXBwb3J0IGdsVEYgMi4wIGZvciBub3chIFJlY2VpdmVkIGdsVEYgdmVyc2lvbjogJHt0aGlzLnZlcnNpb259YCksITE7Y29uc3Qgbj17bm9kZXM6YXdhaXQgdGhpcy5wYXJzZVNjZW5lKHIpLGFuaW1hdGlvbnM6dGhpcy5wYXJzZUFuaW1hdGlvbnMoKSxuYW1lOnRoaXMuY3VycmVudFNjZW5lTmFtZX07cmV0dXJuIGF3YWl0IHRoaXMuY29udmVydFRvTm9kZShuKX1kZXN0b3J5KCl7cnMudW5sb2FkKHRoaXMuZ2x0ZiksdGhpcy5nbHRmPW51bGx9YXN5bmMgcGFyc2VTY2VuZShlKXtjb25zdCB0PWV8fHRoaXMuZ2x0Zi5zY2VuZXx8MCxyPXRoaXMuZ2x0Zi5zY2VuZXNbdF07aWYodHlwZW9mIHI+XCJ1XCIpcmV0dXJuIHRoaXMuZXJyb3JNaXNzKFwic2NlbmVcIix0KTt0aGlzLmN1cnJlbnRTY2VuZU5hbWU9ci5uYW1lfHxcIkdMVEZfTk9fTkFNRV9TQ0VORVwiO2NvbnN0IHM9W10sYT1yLm5vZGVzO2ZvcihsZXQgbj0wO248YS5sZW5ndGg7bisrKXtjb25zdCBsPWF3YWl0IHRoaXMucGFyc2VOb2RlKGFbbl0pO2wmJnMucHVzaChsKX1yZXR1cm4gc31hc3luYyBwYXJzZU5vZGUoZSl7Y29uc3QgdD10aGlzLmdsdGYubm9kZXNbZV07aWYoIXQpcmV0dXJuIHRoaXMuZXJyb3JNaXNzKFwibm9kZVwiLGUpO2lmKHQuaXNQYXJzZWQpcmV0dXJuIHQuZG5vZGU7Y29uc3R7bmFtZTpyLG1hdHJpeDpzLHRyYW5zbGF0aW9uOmEscm90YXRpb246bixzY2FsZTpsfT10LGg9e25hbWU6cixtYXRyaXg6cyx0cmFuc2xhdGlvbjphLHJvdGF0aW9uOm4sc2NhbGU6bCxub2RlSWQ6ZSxjYW1lcmE6bnVsbCxwcmltaXRpdmVzOm51bGwsc2tpbjpudWxsLGNoaWxkcmVuOm51bGwsbGlnaHQ6bnVsbH07aWYodC5jYW1lcmEhPT12b2lkIDAmJihoLmNhbWVyYT10aGlzLnBhcnNlQ2FtZXJhKHQuY2FtZXJhKSksdC5tZXNoIT09dm9pZCAwJiYoaC5wcmltaXRpdmVzPWF3YWl0IHRoaXMucGFyc2VNZXNoKHQubWVzaCkpLHQuZXh0ZW5zaW9ucyE9PXZvaWQgMCYmdGhpcy5hcHBseU5vZGVFeHRlbnNpb25zKHQsaCksdC5za2luIT09dm9pZCAwKXtjb25zdCB1PXRoaXMucGFyc2VTa2luKHQuc2tpbik7dSYmKGguc2tpbj11KX1pZihoLmNoaWxkcmVuPVtdLHQuY2hpbGRyZW4pZm9yKGxldCB1PTA7dTx0LmNoaWxkcmVuLmxlbmd0aDt1KyspaC5jaGlsZHJlbi5wdXNoKGF3YWl0IHRoaXMucGFyc2VOb2RlKHQuY2hpbGRyZW5bdV0pKTtyZXR1cm4gdC5kbm9kZT1oLHQuaXNQYXJzZWQ9ITAsdC5kbm9kZX1lcnJvck1pc3MoZSx0KXt0aHJvdyBuZXcgRXJyb3IoZSt0KX1wYXJzZUNhbWVyYShlKXtyZXR1cm4gdGhpcy5fY2FtZXJhUGFyc2VyfHwodGhpcy5fY2FtZXJhUGFyc2VyPW5ldyBKaCh0aGlzLmdsdGYpKSx0aGlzLl9jYW1lcmFQYXJzZXIucGFyc2UoZSl9YXN5bmMgcGFyc2VNZXNoKGUpe3JldHVybiB0aGlzLl9tZXNoUGFyc2VyfHwodGhpcy5fbWVzaFBhcnNlcj1uZXcgJGgodGhpcykpLHRoaXMuX21lc2hQYXJzZXIucGFyc2UoZSl9YXN5bmMgcGFyc2VUZXh0dXJlKGUpe2xldCB0PXRoaXMuZ2x0Zi50ZXh0dXJlc1tlXTtpZih0JiYhdC5kdGV4dHVyZSl7aWYodCYmdC5zb3VyY2UhPW51bGwpe2xldCByPXRoaXMuZ2x0Zi5pbWFnZXNbdC5zb3VyY2VdO2lmKHIudXJpKXtsZXQgcz1yLnVyaTtzPWl0LmdldFVSTE5hbWUocyksdC5kdGV4dHVyZT10aGlzLmdsdGYucmVzb3VyY2VzW3NdfWVsc2UgaWYoci5idWZmZXJWaWV3KXtsZXQgcz10aGlzLnBhcnNlQnVmZmVyVmlldyhyLmJ1ZmZlclZpZXcpLGE9bmV3IGlpLG49bmV3IEJsb2IoW3NdLHt0eXBlOnIubWltZVR5cGV9KTthd2FpdCBhLmxvYWRGcm9tQmxvYihuKSx0LmR0ZXh0dXJlPWF9ZWxzZSB0LmR0ZXh0dXJlPXRoaXMuZ2x0Zi5yZXNvdXJjZXNbci5uYW1lXX1lbHNlIGlmKHQubmFtZSl7bGV0IHI9aXQuZ2V0VVJMTmFtZSh0Lm5hbWUpO3QuZHRleHR1cmU9dGhpcy5nbHRmLnJlc291cmNlc1tyXX19cmV0dXJuIHQuZHRleHR1cmV8fGNvbnNvbGUubG9nKFwibWlzcyB0ZXh0dXJlICwgcGxlYXNlIGNoZWNrIHRleHR1cmUhXCIsZSx0KSx0LmR0ZXh0dXJlfWFzeW5jIHBhcnNlTWF0ZXJpYWwoZSl7cmV0dXJuIHRoaXMuX21hdGVyaWFsUGFyc2VyfHwodGhpcy5fbWF0ZXJpYWxQYXJzZXI9bmV3IGV1KHRoaXMpKSx0aGlzLl9tYXRlcmlhbFBhcnNlci5wYXJzZShlKX1wYXJzZUFuaW1hdGlvbnMoKXtyZXR1cm5bXX1hc3luYyBwYXJzZU9iamVjdDNEKGUsdCl7cmV0dXJuIHRoaXMuX2NvbnZlcnRlcnx8KHRoaXMuX2NvbnZlcnRlcj1uZXcgZnUodGhpcykpLHRoaXMuX2NvbnZlcnRlci5jb252ZXJ0Tm9kZVRvT2JqZWN0M0QoZSx0KX1wYXJzZVNrZWxldG9uKGUpe3JldHVybiB0aGlzLl9za2VsZXRvblBhcnNlcnx8KHRoaXMuX3NrZWxldG9uUGFyc2VyPW5ldyBMbyh0aGlzKSksdGhpcy5fc2tlbGV0b25QYXJzZXIucGFyc2UoZSl9cGFyc2VTa2VsZXRvbkFuaW1hdGlvbihlLHQpe3JldHVybiB0aGlzLl9za2VsZXRvblBhcnNlcnx8KHRoaXMuX3NrZWxldG9uUGFyc2VyPW5ldyBMbyh0aGlzKSksdGhpcy5fc2tlbGV0b25QYXJzZXIucGFyc2VTa2VsZXRvbkFuaW1hdGlvbihlLHQpfWFzeW5jIHRyYXZlcnNlKGUsdCl7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IHM9YXdhaXQgdGhpcy5wYXJzZU9iamVjdDNEKHRbcl0sZSk7YXdhaXQgdGhpcy50cmF2ZXJzZShzLHRbcl0uY2hpbGRyZW4pfX1hc3luYyBjb252ZXJ0VG9Ob2RlKGUpe2NvbnN0IHQ9bmV3IHRlO3QubmFtZT1lLm5hbWU7Y29uc3Qgcj1lLm5vZGVzO2UuYW5pbWF0aW9ucztjb25zdCBzPVtdLGE9W107YXdhaXQgdGhpcy50cmF2ZXJzZSh0LHIpO2xldCBuO3JldHVybntyb290Tm9kZTp0LHRleHR1cmVzOnMsYW5pbWF0aW9uczpuLGNhbWVyYXM6YX19cGFyc2VTa2luKGUpe3JldHVybiB0aGlzLl9za2luUGFyc2VyfHwodGhpcy5fc2tpblBhcnNlcj1uZXcgdHUodGhpcykpLHRoaXMuX3NraW5QYXJzZXIucGFyc2UoZSl9cGFyc2VBY2Nlc3NvcihlKXtjb25zdCB0PXRoaXMuZ2x0Zi5hY2Nlc3NvcnNbZV07aWYoIXQpcmV0dXJuIHRoaXMuZXJyb3JNaXNzKFwiYWNjZXNzb3JcIixlKTtpZih0LmlzUGFyc2VkKXJldHVybiB0LmRhY2Nlc3Nvcjt0LmlzUGFyc2VkPSEwLHQuZGFjY2Vzc29yPSExO2NvbnN0IHI9ISF0Lm5vcm1hbGl6ZWQscz10aGlzLmdsdGYuYnVmZmVyVmlld3NbdC5idWZmZXJWaWV3XSxhPXMmJnMuYnl0ZVN0cmlkZSxuPVBvKHQuY29tcG9uZW50VHlwZSk7bGV0IGw9MTtzd2l0Y2godC50eXBlKXtjYXNlXCJTQ0FMQVJcIjpsPTE7YnJlYWs7Y2FzZVwiVkVDMlwiOmw9MjticmVhaztjYXNlXCJWRUMzXCI6bD0zO2JyZWFrO2Nhc2VcIlZFQzRcIjpjYXNlXCJNQVQyXCI6bD00O2JyZWFrO2Nhc2VcIk1BVDNcIjpsPTk7YnJlYWs7Y2FzZVwiTUFUNFwiOmw9MTY7YnJlYWs7ZGVmYXVsdDpsPTA7YnJlYWt9aWYobD09PTApcmV0dXJuIGNvbnNvbGUuZXJyb3IoYGdsVEYgaGFzIHVua25vd24gZGF0YSB0eXBlIGluIGFjY2Vzc29yOiAke3QudHlwZX1gKSwhMTtjb25zdCBoPWwqbi5CWVRFU19QRVJfRUxFTUVOVDtsZXQgdTtpZihzIT09dm9pZCAwKXtpZih1PXRoaXMucGFyc2VCdWZmZXJWaWV3KHQuYnVmZmVyVmlldyksIXUpcmV0dXJuIHQuZGFjY2Vzc29yfWVsc2UgdT1uZXcgVWludDhBcnJheShoKnQuY291bnQpLmJ1ZmZlcjtsZXQgYz10aGlzLmdldFR5cGVkQXJyYXlGcm9tQXJyYXlCdWZmZXIodSxhLHQuYnl0ZU9mZnNldHx8MCxuLGwsdC5jb3VudCk7aWYodC5zcGFyc2Upe2NvbnN0e2NvdW50OmYsaW5kaWNlczpkLHZhbHVlczpwfT10LnNwYXJzZTtjPW5ldyBuKGMpO2NvbnN0IG09ZC5ieXRlT2Zmc2V0fHwwLF89dGhpcy5nbHRmLmJ1ZmZlclZpZXdzW2QuYnVmZmVyVmlld10sdj1QbyhkLmNvbXBvbmVudFR5cGUpLHk9dGhpcy5wYXJzZUJ1ZmZlclZpZXcoZC5idWZmZXJWaWV3KSxDPXRoaXMuZ2V0VHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcih5LF8uYnl0ZVN0cmlkZSxtLHYsMSxmKSxCPXAuYnl0ZU9mZnNldHx8MCxUPXRoaXMuZ2x0Zi5idWZmZXJWaWV3c1twLmJ1ZmZlclZpZXddLE09dGhpcy5wYXJzZUJ1ZmZlclZpZXcocC5idWZmZXJWaWV3KSxEPXRoaXMuZ2V0VHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcihNLFQuYnl0ZVN0cmlkZSxCLG4sbCxmKTtmb3IobGV0IFA9MDtQPEMubGVuZ3RoO1ArKyljLnNldChELnNsaWNlKFAqbCxQKmwrbCksQ1tQXSpsKX1yZXR1cm4gdC5jb21wdXRlUmVzdWx0PXt0eXBlZEFycmF5OmMsYXJyYXlUeXBlOm4sbnVtQ29tcG9uZW50czpsfSx0LmRhY2Nlc3Nvcj17ZGF0YTpjLG51bUNvbXBvbmVudHM6bCxub3JtYWxpemU6cn0sdC5kYWNjZXNzb3J9Z2V0VHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcihlLHQscixzLGEsbil7bGV0IGw7Y29uc3QgaD1hKnMuQllURVNfUEVSX0VMRU1FTlQ7aWYodCYmaCE9PXQpe2NvbnN0IHU9YSpuO2w9bmV3IHModSk7Zm9yKGxldCBjPTA7YzxuO2MrKyl7Y29uc3QgZj1uZXcgcyhlLHIrYyp0LGEpO2ZvcihsZXQgZD0wO2Q8YTtkKyspbFtjKmErZF09ZltkXX19ZWxzZSBsPW5ldyBzKGUscixuKmEpO3JldHVybiBsfXBhcnNlQnVmZmVyVmlldyhlKXtjb25zdCB0PXRoaXMuZ2x0Zi5idWZmZXJWaWV3c1tlXTtpZighdClyZXR1cm4gdGhpcy5lcnJvck1pc3MoXCJidWZmZXJWaWV3XCIsZSk7aWYodC5pc1BhcnNlZClyZXR1cm4gdC5kYnVmZmVyVmlldzt0LmlzUGFyc2VkPSEwLHQuZGJ1ZmZlclZpZXc9ITE7Y29uc3Qgcj10aGlzLnBhcnNlQnVmZmVyKHQuYnVmZmVyKTtpZihyKXtjb25zdHtieXRlT2Zmc2V0OnMsYnl0ZUxlbmd0aDphfT10LG49bmV3IFVpbnQ4QXJyYXkocixzfHwwLGEpO3QuZGJ1ZmZlclZpZXc9bmV3IFVpbnQ4QXJyYXkobikuYnVmZmVyfXJldHVybiB0LmRidWZmZXJWaWV3fXBhcnNlQnVmZmVyKGUpe2NvbnN0IHQ9dGhpcy5nbHRmLmJ1ZmZlcnNbZV07aWYoIXQpcmV0dXJuIHRoaXMuZXJyb3JNaXNzKFwiYnVmZmVyXCIsZSk7aWYodC5pc1BhcnNlZClyZXR1cm4gdC5kYnVmZmVyO2lmKHQuaXNQYXJzZWQ9ITAsdC5kYnVmZmVyPSExLHQudXJpLnN1YnN0cmluZygwLDUpIT09XCJkYXRhOlwiKXtjb25zdCByPXQudXJpLHM9dGhpcy5nbHRmLnJlc291cmNlc1tyXTtzP3MuYnl0ZUxlbmd0aD09PXQuYnl0ZUxlbmd0aD90LmRidWZmZXI9dGhpcy5nbHRmLnJlc291cmNlc1tyXTpjb25zb2xlLmVycm9yKGBsb2FkIGdsdGYgcmVzb3VyY2UgXCIke3J9XCIgYXQgYnVmZmVyc1ske2V9IGZhaWxlZCwgQXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCBub3QgZXF1YWxzIGJ1ZmZlcidzIGJ5dGVMZW5ndGhdYCk6Y29uc29sZS5lcnJvcihgbG9hZCBnbHRmIHJlc291cmNlIFwiJHtyfVwiIGF0IGJ1ZmZlcnNbJHtlfV0gZmFpbGVkYCl9ZWxzZXtjb25zdCByPXQudXJpLmluZGV4T2YodGhpcy5fQkFTRTY0X01BUktFUikrdGhpcy5fQkFTRTY0X01BUktFUi5sZW5ndGgscz13aW5kb3cuYXRvYih0LnVyaS5zdWJzdHJpbmcocikpLGE9bmV3IFVpbnQ4QXJyYXkocy5sZW5ndGgpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKWFbbl09cy5jaGFyQ29kZUF0KG4pO3QuZGJ1ZmZlcj1hLmJ1ZmZlcn1yZXR1cm4gdC5kYnVmZmVyfWdldExpZ2h0KGUpe3JldHVybiB0aGlzLmdsdGYuZXh0ZW5zaW9ucy5LSFJfbGlnaHRzX3B1bmN0dWFsLmxpZ2h0c1tlXX1hcHBseU5vZGVFeHRlbnNpb25zKGUsdCl7bGV0IHI9ZS5leHRlbnNpb25zO3IuS0hSX2xpZ2h0c19wdW5jdHVhbCYmdGhpcy5nbHRmLmV4dGVuc2lvbnMuS0hSX2xpZ2h0c19wdW5jdHVhbCYmKHQubGlnaHQ9dGhpcy5nZXRMaWdodChyLktIUl9saWdodHNfcHVuY3R1YWwubGlnaHQpKX19Y2xhc3MgZHV7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJtYWdpY1wiKSxvKHRoaXMsXCJ2ZXJzaW9uXCIpLG8odGhpcyxcImxlbmd0aFwiKX19Y2xhc3MgZ3V7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJjaHVua0xlbmd0aFwiKSxvKHRoaXMsXCJjaHVua1R5cGVcIiksbyh0aGlzLFwiY2h1bmtEYXRhXCIpfX1jbGFzcyBxcyBleHRlbmRzIFh0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxvKHRoaXMsXCJfZ2x0ZlwiKX1hc3luYyBwYXJzZUJ1ZmZlcihlKXtsZXQgdD1uZXcgVWludDhBcnJheShlKTt0LnBvcz0wO2NvbnN0IHI9dGhpcy5wYXJzZUhlYWRlcih0KTtpZihyLm1hZ2ljIT0xMTc5OTM3ODk1KXJldHVybiBjb25zb2xlLmVycm9yKFwiaW52YWxpZCBHTEIgZmlsZVwiKSwhMTtpZihyLnZlcnNpb24hPT0yKXJldHVybiBjb25zb2xlLmVycm9yKGBHTEJQYXJzZXIgb25seSBzdXBwb3J0IGdsVEYgMi4wIGZvciBub3chIFJlY2VpdmVkIGdsVEYgdmVyc2lvbjogJHtyLnZlcnNpb259YCksITE7bGV0IHM9W107Zm9yKDt0LnBvczx0Lmxlbmd0aDspe2xldCBmPXRoaXMucGFyc2VDaHVuayh0KTtzLnB1c2goZil9aWYoc1swXS5jaHVua1R5cGUhPTEzMTM4MjE1MTQpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJpbnZhbGlkIEdMQkNodW5rXCIpLCExO2xldCBhPVwiXCIsbj02NTUzNSxsPXNbMF0uY2h1bmtEYXRhO2ZvcihsZXQgZj0wO2Y8bC5sZW5ndGg7Zis9bil7bGV0IGQ9bC5sZW5ndGgtZjtkPU1hdGgubWluKGQsbik7bGV0IHA9bC5zdWJhcnJheShmLGYrZCk7YSs9U3RyaW5nLmZyb21DaGFyQ29kZSguLi5wKX1sZXQgaD1KU09OLnBhcnNlKGEpO3RoaXMuX2dsdGY9bmV3IFlzLHRoaXMuX2dsdGY9ey4uLnRoaXMuX2dsdGYsLi4uaH0sdGhpcy5fZ2x0Zi5yZXNvdXJjZXM9e307Zm9yKGxldCBmPTA7Zjx0aGlzLl9nbHRmLmJ1ZmZlcnMubGVuZ3RoO2YrKyl7bGV0IGQ9dGhpcy5fZ2x0Zi5idWZmZXJzW2ZdO2QuaXNQYXJzZWQ9ITAsZC5kYnVmZmVyPXNbZisxXS5jaHVua0RhdGEuYnVmZmVyfWlmKHRoaXMuX2dsdGYuaW1hZ2VzKWZvcihsZXQgZj0wO2Y8dGhpcy5fZ2x0Zi5pbWFnZXMubGVuZ3RoO2YrKyl7bGV0IGQ9dGhpcy5fZ2x0Zi5pbWFnZXNbZl07ZC5uYW1lPWQubmFtZXx8XCJidWZmZXJWaWV3X1wiK2QuYnVmZmVyVmlldy50b1N0cmluZygpO2NvbnN0IHA9dGhpcy5fZ2x0Zi5idWZmZXJWaWV3c1tkLmJ1ZmZlclZpZXddLG09dGhpcy5fZ2x0Zi5idWZmZXJzW3AuYnVmZmVyXTtsZXQgXz1uZXcgVWludDhBcnJheShtLmRidWZmZXIscC5ieXRlT2Zmc2V0LHAuYnl0ZUxlbmd0aCksdj1uZXcgQmxvYihbX10se3R5cGU6ZC5taW1lVHlwZX0pLHk9bmV3IGlpO2F3YWl0IHkubG9hZEZyb21CbG9iKHYpLHkubmFtZT1kLm5hbWUsdGhpcy5fZ2x0Zi5yZXNvdXJjZXNbZC5uYW1lXT15fWxldCBjPWF3YWl0IG5ldyBqcygpLnBhcnNlKHRoaXMuaW5pdFVybCx0aGlzLl9nbHRmLHRoaXMuX2dsdGYuc2NlbmUpO3JldHVybiBjPyh0aGlzLmRhdGE9Yy5yb290Tm9kZSxjLnJvb3ROb2RlKTpudWxsfWFzeW5jIHBhcnNlSnNvbkFuZEJ1ZmZlcihlLHQpe3RoaXMuX2dsdGY9bmV3IFlzLHRoaXMuX2dsdGY9ey4uLnRoaXMuX2dsdGYsLi4uZX0sdGhpcy5fZ2x0Zi5yZXNvdXJjZXM9e307bGV0IHI9dGhpcy5fZ2x0Zi5idWZmZXJzWzBdO2lmKHIuaXNQYXJzZWQ9ITAsci5kYnVmZmVyPXQsdGhpcy5fZ2x0Zi5pbWFnZXMpZm9yKGxldCBuPTA7bjx0aGlzLl9nbHRmLmltYWdlcy5sZW5ndGg7bisrKXtsZXQgbD10aGlzLl9nbHRmLmltYWdlc1tuXTtsLm5hbWU9bC5uYW1lfHxcImJ1ZmZlclZpZXdfXCIrbC5idWZmZXJWaWV3LnRvU3RyaW5nKCk7Y29uc3QgaD10aGlzLl9nbHRmLmJ1ZmZlclZpZXdzW2wuYnVmZmVyVmlld10sdT10aGlzLl9nbHRmLmJ1ZmZlcnNbaC5idWZmZXJdO2xldCBjPW5ldyBVaW50OEFycmF5KHUuZGJ1ZmZlcixoLmJ5dGVPZmZzZXQsaC5ieXRlTGVuZ3RoKSxmPW5ldyBCbG9iKFtjXSx7dHlwZTpsLm1pbWVUeXBlfSksZD1uZXcgaWk7YXdhaXQgZC5sb2FkRnJvbUJsb2IoZiksZC5uYW1lPWwubmFtZSx0aGlzLl9nbHRmLnJlc291cmNlc1tsLm5hbWVdPWR9bGV0IGE9YXdhaXQgbmV3IGpzKCkucGFyc2UodGhpcy5pbml0VXJsLHRoaXMuX2dsdGYsdGhpcy5fZ2x0Zi5zY2VuZSk7cmV0dXJuIGE/KHRoaXMuZGF0YT1hLnJvb3ROb2RlLGEucm9vdE5vZGUpOm51bGx9dmVyaWZpY2F0aW9uKCl7aWYodGhpcy5kYXRhKXJldHVybiEwO3Rocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpfXBhcnNlSGVhZGVyKGUpe2xldCB0PWUucG9zLHI9bmV3IGR1LHM9bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyLHQsMyk7cmV0dXJuIGUucG9zKz1zLmJ5dGVMZW5ndGgsci5tYWdpYz1zWzBdLHIudmVyc2lvbj1zWzFdLHIubGVuZ3RoPXNbMl0scn1wYXJzZUNodW5rKGUpe2xldCB0PWUucG9zLHI9bmV3IGd1LHM9bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyLHQsMik7dD1lLnBvcys9cy5ieXRlTGVuZ3RoLHIuY2h1bmtMZW5ndGg9c1swXSxyLmNodW5rVHlwZT1zWzFdLHIuY2h1bmtEYXRhPW5ldyBVaW50OEFycmF5KGUuYnVmZmVyLHQsci5jaHVua0xlbmd0aCk7Y29uc3QgYT1uZXcgVWludDhBcnJheShyLmNodW5rTGVuZ3RoKTtmb3IobGV0IG49MDtuPHIuY2h1bmtMZW5ndGg7bisrKWFbbl09ci5jaHVua0RhdGFbbl07cmV0dXJuIHIuY2h1bmtEYXRhPWEsZS5wb3MrPXIuY2h1bmtMZW5ndGgscn19byhxcyxcImZvcm1hdFwiLFwiYmluXCIpO2NsYXNzIGFze2NvbnN0cnVjdG9yKGU9MCx0PVwiXFwwXCIpe28odGhpcyxcIlR5cGVcIiwwKSxvKHRoaXMsXCJMaW5lXCIsMCksbyh0aGlzLFwiQ29sdW1lXCIsMCksbyh0aGlzLFwiTGl0ZXJhbFwiLFwiXCIpLHRoaXMuVHlwZT1lLHRoaXMuTGl0ZXJhbD10fWlzVHlwZUVxdWFsKGUpe3JldHVybiB0aGlzLlR5cGU9PWV9aXNMaXRlcmFsRXF1YWwoZSl7cmV0dXJuIHRoaXMuTGl0ZXJhbD09ZX1pc0J1aWx0aW5UeXBlKCl7cmV0dXJuIHRoaXMuVHlwZT4zMyYmdGhpcy5UeXBlPDEwMX1pc0RhdGFUeXBlKCl7cmV0dXJuIHRoaXMuVHlwZT09MXx8dGhpcy5pc0J1aWx0aW5UeXBlKCl9aXNPcGVyYXRpb24oKXtyZXR1cm4gdGhpcy5UeXBlPjEwMiYmdGhpcy5UeXBlPDEyN31pc0Fzc2lnbk9wZXJhdGlvbigpe3JldHVybiB0aGlzLlR5cGU+MTI4JiZ0aGlzLlR5cGU8MTMzfWdldCBuT3BlcmF0aW9uUHJpb3JpdHlMZXZlbCgpe3N3aXRjaCh0aGlzLlR5cGUpe2Nhc2UgMjY6cmV0dXJuIDE7Y2FzZSAyNzpyZXR1cm4gMTtjYXNlIDEyNTpyZXR1cm4gMjtjYXNlIDExMDpyZXR1cm4gMztjYXNlIDExNDpyZXR1cm4gMztjYXNlIDEwNTpyZXR1cm4gNDtjYXNlIDEwNjpyZXR1cm4gNDtjYXNlIDEwMzpyZXR1cm4gNTtjYXNlIDEwNDpyZXR1cm4gNTtjYXNlIDExNTpyZXR1cm4gNjtjYXNlIDExNjpyZXR1cm4gNjtjYXNlIDExOTpyZXR1cm4gNztjYXNlIDEyMDpyZXR1cm4gNztjYXNlIDEyMjpyZXR1cm4gNztjYXNlIDEyMzpyZXR1cm4gNztjYXNlIDEyMTpyZXR1cm4gODtjYXNlIDEyNDpyZXR1cm4gODtjYXNlIDExMTpyZXR1cm4gOTtjYXNlIDExMzpyZXR1cm4gMTA7Y2FzZSAxMTI6cmV0dXJuIDExO2Nhc2UgMTA3OnJldHVybiAxMjtjYXNlIDEwOTpyZXR1cm4gMTM7Y2FzZSAxMDg6cmV0dXJuIDE0O2Nhc2UgMjQ6cmV0dXJuIDE1O2Nhc2UgMTI2OnJldHVybiAxNjtjYXNlIDEyOTpyZXR1cm4gMTY7Y2FzZSAxMzA6cmV0dXJuIDE2O2Nhc2UgMTMxOnJldHVybiAxNjtjYXNlIDEzMjpyZXR1cm4gMTZ9cmV0dXJuIDk5fX12YXIgeD0oaT0+KGlbaS5FT0Y9MF09XCJFT0ZcIixpW2kuSURFTlQ9MV09XCJJREVOVFwiLGlbaS5WT0lEPTJdPVwiVk9JRFwiLGlbaS5DT05TVD0zXT1cIkNPTlNUXCIsaVtpLkxBWU9VVD00XT1cIkxBWU9VVFwiLGlbaS5QUkVDSVNJT049NV09XCJQUkVDSVNJT05cIixpW2kuQVRUUklCVVRFPTZdPVwiQVRUUklCVVRFXCIsaVtpLlVOSUZPUk09N109XCJVTklGT1JNXCIsaVtpLlZBUllJTkc9OF09XCJWQVJZSU5HXCIsaVtpLklOVkFSSUFOVD05XT1cIklOVkFSSUFOVFwiLGlbaS5JTj0xMF09XCJJTlwiLGlbaS5PVVQ9MTFdPVwiT1VUXCIsaVtpLklOT1VUPTEyXT1cIklOT1VUXCIsaVtpLklGPTEzXT1cIklGXCIsaVtpLkVMU0U9MTRdPVwiRUxTRVwiLGlbaS5GT1I9MTVdPVwiRk9SXCIsaVtpLldISUxFPTE2XT1cIldISUxFXCIsaVtpLkRPPTE3XT1cIkRPXCIsaVtpLkJSRUFLPTE4XT1cIkJSRUFLXCIsaVtpLlJFVFVSTj0xOV09XCJSRVRVUk5cIixpW2kuQ09OVElOVUU9MjBdPVwiQ09OVElOVUVcIixpW2kuU1RSVUNUPTIxXT1cIlNUUlVDVFwiLGlbaS5DT01NQT0yMl09XCJDT01NQVwiLGlbaS5DT0xPTj0yM109XCJDT0xPTlwiLGlbaS5RVUVNQVJLPTI0XT1cIlFVRU1BUktcIixpW2kuU0VNSUNPTE9OPTI1XT1cIlNFTUlDT0xPTlwiLGlbaS5MRUZUU0FNTEw9MjZdPVwiTEVGVFNBTUxMXCIsaVtpLlJJR0hUU0FNTEw9MjddPVwiUklHSFRTQU1MTFwiLGlbaS5MRUZUTUVEST0yOF09XCJMRUZUTUVESVwiLGlbaS5SSUdIVE1FREk9MjldPVwiUklHSFRNRURJXCIsaVtpLkxFRlRCSUc9MzBdPVwiTEVGVEJJR1wiLGlbaS5SSUdIVEJJRz0zMV09XCJSSUdIVEJJR1wiLGlbaS5MSVRFUkFMPTMyXT1cIkxJVEVSQUxcIixpW2kuQmVnaW5CdWlsdGluVHlwZT0zM109XCJCZWdpbkJ1aWx0aW5UeXBlXCIsaVtpLklOVD0zNF09XCJJTlRcIixpW2kuSU5UX0FSUkFZPTM1XT1cIklOVF9BUlJBWVwiLGlbaS5VSU5UPTM2XT1cIlVJTlRcIixpW2kuVUlOVF9BUlJBWT0zN109XCJVSU5UX0FSUkFZXCIsaVtpLkJPT0w9MzhdPVwiQk9PTFwiLGlbaS5CT09MX0FSUkFZPTM5XT1cIkJPT0xfQVJSQVlcIixpW2kuRkxPQVQ9NDBdPVwiRkxPQVRcIixpW2kuRkxPQVRfQVJSQVk9NDFdPVwiRkxPQVRfQVJSQVlcIixpW2kuRE9VQkxFPTQyXT1cIkRPVUJMRVwiLGlbaS5ET1VCTEVfQVJSQVk9NDNdPVwiRE9VQkxFX0FSUkFZXCIsaVtpLlZFQzI9NDRdPVwiVkVDMlwiLGlbaS5WRUMyX0FSUkFZPTQ1XT1cIlZFQzJfQVJSQVlcIixpW2kuVkVDMz00Nl09XCJWRUMzXCIsaVtpLlZFQzNfQVJSQVk9NDddPVwiVkVDM19BUlJBWVwiLGlbaS5WRUM0PTQ4XT1cIlZFQzRcIixpW2kuVkVDNF9BUlJBWT00OV09XCJWRUM0X0FSUkFZXCIsaVtpLkJWRUMyPTUwXT1cIkJWRUMyXCIsaVtpLkJWRUMyX0FSUkFZPTUxXT1cIkJWRUMyX0FSUkFZXCIsaVtpLkJWRUMzPTUyXT1cIkJWRUMzXCIsaVtpLkJWRUMzX0FSUkFZPTUzXT1cIkJWRUMzX0FSUkFZXCIsaVtpLkJWRUM0PTU0XT1cIkJWRUM0XCIsaVtpLkJWRUM0X0FSUkFZPTU1XT1cIkJWRUM0X0FSUkFZXCIsaVtpLklWRUMyPTU2XT1cIklWRUMyXCIsaVtpLklWRUMyX0FSUkFZPTU3XT1cIklWRUMyX0FSUkFZXCIsaVtpLklWRUMzPTU4XT1cIklWRUMzXCIsaVtpLklWRUMzX0FSUkFZPTU5XT1cIklWRUMzX0FSUkFZXCIsaVtpLklWRUM0PTYwXT1cIklWRUM0XCIsaVtpLklWRUM0X0FSUkFZPTYxXT1cIklWRUM0X0FSUkFZXCIsaVtpLlVWRUMyPTYyXT1cIlVWRUMyXCIsaVtpLlVWRUMyX0FSUkFZPTYzXT1cIlVWRUMyX0FSUkFZXCIsaVtpLlVWRUMzPTY0XT1cIlVWRUMzXCIsaVtpLlVWRUMzX0FSUkFZPTY1XT1cIlVWRUMzX0FSUkFZXCIsaVtpLlVWRUM0PTY2XT1cIlVWRUM0XCIsaVtpLlVWRUM0X0FSUkFZPTY3XT1cIlVWRUM0X0FSUkFZXCIsaVtpLk1BVDJ4Mj02OF09XCJNQVQyeDJcIixpW2kuTUFUMngyX0FSUkFZPTY5XT1cIk1BVDJ4Ml9BUlJBWVwiLGlbaS5NQVQyeDM9NzBdPVwiTUFUMngzXCIsaVtpLk1BVDJ4M19BUlJBWT03MV09XCJNQVQyeDNfQVJSQVlcIixpW2kuTUFUMng0PTcyXT1cIk1BVDJ4NFwiLGlbaS5NQVQyeDRfQVJSQVk9NzNdPVwiTUFUMng0X0FSUkFZXCIsaVtpLk1BVDN4Mj03NF09XCJNQVQzeDJcIixpW2kuTUFUM3gyX0FSUkFZPTc1XT1cIk1BVDN4Ml9BUlJBWVwiLGlbaS5NQVQzeDM9NzZdPVwiTUFUM3gzXCIsaVtpLk1BVDN4M19BUlJBWT03N109XCJNQVQzeDNfQVJSQVlcIixpW2kuTUFUM3g0PTc4XT1cIk1BVDN4NFwiLGlbaS5NQVQzeDRfQVJSQVk9NzldPVwiTUFUM3g0X0FSUkFZXCIsaVtpLk1BVDR4Mj04MF09XCJNQVQ0eDJcIixpW2kuTUFUNHgyX0FSUkFZPTgxXT1cIk1BVDR4Ml9BUlJBWVwiLGlbaS5NQVQ0eDM9ODJdPVwiTUFUNHgzXCIsaVtpLk1BVDR4M19BUlJBWT04M109XCJNQVQ0eDNfQVJSQVlcIixpW2kuTUFUNHg0PTg0XT1cIk1BVDR4NFwiLGlbaS5NQVQ0eDRfQVJSQVk9ODVdPVwiTUFUNHg0X0FSUkFZXCIsaVtpLlNBTVBMRVI9ODZdPVwiU0FNUExFUlwiLGlbaS5TQU1QTEVSXzFEPTg3XT1cIlNBTVBMRVJfMURcIixpW2kuU0FNUExFUl8yRD04OF09XCJTQU1QTEVSXzJEXCIsaVtpLlNBTVBMRVJfM0Q9ODldPVwiU0FNUExFUl8zRFwiLGlbaS5TQU1QTEVSX0NVQkU9OTBdPVwiU0FNUExFUl9DVUJFXCIsaVtpLlNBTVBMRVJfU0hBRE9XPTkxXT1cIlNBTVBMRVJfU0hBRE9XXCIsaVtpLlNBTVBMRVJfMURfU0hBRE9XPTkyXT1cIlNBTVBMRVJfMURfU0hBRE9XXCIsaVtpLlNBTVBMRVJfMkRfU0hBRE9XPTkzXT1cIlNBTVBMRVJfMkRfU0hBRE9XXCIsaVtpLlRFWFRVUkVfMUQ9OTRdPVwiVEVYVFVSRV8xRFwiLGlbaS5URVhUVVJFXzFEX0FSUkFZPTk1XT1cIlRFWFRVUkVfMURfQVJSQVlcIixpW2kuVEVYVFVSRV8yRD05Nl09XCJURVhUVVJFXzJEXCIsaVtpLlRFWFRVUkVfMkRfQVJSQVk9OTddPVwiVEVYVFVSRV8yRF9BUlJBWVwiLGlbaS5URVhUVVJFXzNEPTk4XT1cIlRFWFRVUkVfM0RcIixpW2kuVEVYVFVSRV9DVUJFPTk5XT1cIlRFWFRVUkVfQ1VCRVwiLGlbaS5URVhUVVJFX0NVQkVfQVJSQVk9MTAwXT1cIlRFWFRVUkVfQ1VCRV9BUlJBWVwiLGlbaS5FbmRCdWlsdGluVHlwZT0xMDFdPVwiRW5kQnVpbHRpblR5cGVcIixpW2kuQmVnaW5PcGVyYXRpb249MTAyXT1cIkJlZ2luT3BlcmF0aW9uXCIsaVtpLkFERD0xMDNdPVwiQUREXCIsaVtpLlNVQj0xMDRdPVwiU1VCXCIsaVtpLk1VTD0xMDVdPVwiTVVMXCIsaVtpLkRJVj0xMDZdPVwiRElWXCIsaVtpLkFORD0xMDddPVwiQU5EXCIsaVtpLk9SPTEwOF09XCJPUlwiLGlbaS5YT1I9MTA5XT1cIlhPUlwiLGlbaS5OT1Q9MTEwXT1cIk5PVFwiLGlbaS5CSVRBTkQ9MTExXT1cIkJJVEFORFwiLGlbaS5CSVRPUj0xMTJdPVwiQklUT1JcIixpW2kuQklUWE9SPTExM109XCJCSVRYT1JcIixpW2kuQklUTk9UPTExNF09XCJCSVROT1RcIixpW2kuQklUU0hJRlRfTD0xMTVdPVwiQklUU0hJRlRfTFwiLGlbaS5CSVRTSElGVF9SPTExNl09XCJCSVRTSElGVF9SXCIsaVtpLklOQz0xMTddPVwiSU5DXCIsaVtpLkRFQz0xMThdPVwiREVDXCIsaVtpLkdSRUFURVI9MTE5XT1cIkdSRUFURVJcIixpW2kuR1JFQVRFUkVRVUFMPTEyMF09XCJHUkVBVEVSRVFVQUxcIixpW2kuRVFVQUw9MTIxXT1cIkVRVUFMXCIsaVtpLkxFU1M9MTIyXT1cIkxFU1NcIixpW2kuTEVTU0VRVUFMPTEyM109XCJMRVNTRVFVQUxcIixpW2kuTk9URVFVQUw9MTI0XT1cIk5PVEVRVUFMXCIsaVtpLkRPVD0xMjVdPVwiRE9UXCIsaVtpLkFTU0lHTj0xMjZdPVwiQVNTSUdOXCIsaVtpLkVuZE9wZXJhdGlvbj0xMjddPVwiRW5kT3BlcmF0aW9uXCIsaVtpLkJlZ2luQXNzaWduT3BlcmF0aW9uPTEyOF09XCJCZWdpbkFzc2lnbk9wZXJhdGlvblwiLGlbaS5BRERBU1NJR049MTI5XT1cIkFEREFTU0lHTlwiLGlbaS5TVUJBU1NJR049MTMwXT1cIlNVQkFTU0lHTlwiLGlbaS5NVUxBU1NJR049MTMxXT1cIk1VTEFTU0lHTlwiLGlbaS5ESVZBU1NJR049MTMyXT1cIkRJVkFTU0lHTlwiLGlbaS5FbmRBc3NpZ25PcGVyYXRpb249MTMzXT1cIkVuZEFzc2lnbk9wZXJhdGlvblwiLGkpKSh4fHx7fSk7Y2xhc3MgbnJ7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwiX2NoYXJcIiksbyh0aGlzLFwiX2xpbmVcIiksbyh0aGlzLFwiX2NvbHVtblwiKSxvKHRoaXMsXCJfc291cmNlXCIpLG8odGhpcyxcIl9jdXJyUG9zaXRpb25cIiksbyh0aGlzLFwiX25leHRQb3NpdGlvblwiKSx0aGlzLnJlc2V0KGUpfXJlc2V0KGUpe3RoaXMuX2NoYXI9XCJcIix0aGlzLl9saW5lPTAsdGhpcy5fY29sdW1uPTAsdGhpcy5fc291cmNlPWUsdGhpcy5fY3VyclBvc2l0aW9uPTAsdGhpcy5fbmV4dFBvc2l0aW9uPTB9Z2V0IHNvdXJjZSgpe3JldHVybiB0aGlzLl9zb3VyY2V9Z2V0Q2hhcigpe3JldHVybiB0aGlzLl9jaGFyfWdldCBjdXJyUG9zaXRpb24oKXtyZXR1cm4gdGhpcy5fY3VyclBvc2l0aW9ufXBlZWtDaGFyKCl7cmV0dXJuIHRoaXMuX25leHRQb3NpdGlvbj49dGhpcy5fc291cmNlLmxlbmd0aD9cIlxcMFwiOnRoaXMuX3NvdXJjZVt0aGlzLl9uZXh0UG9zaXRpb25dfXJlYWRDaGFyKCl7dGhpcy5fY2hhcj10aGlzLl9uZXh0UG9zaXRpb24+PXRoaXMuX3NvdXJjZS5sZW5ndGg/XCJcXDBcIjp0aGlzLl9zb3VyY2VbdGhpcy5fbmV4dFBvc2l0aW9uXSx0aGlzLl9jaGFyIT09YFxuYD90aGlzLl9jb2x1bW4rKzoodGhpcy5fbGluZSsrLHRoaXMuX2NvbHVtbj0wKSx0aGlzLl9jdXJyUG9zaXRpb249dGhpcy5fbmV4dFBvc2l0aW9uLHRoaXMuX25leHRQb3NpdGlvbisrfXJlYWRDaGFyQW5kU2tpcFdoaXRlc3BhY2UoKXt0aGlzLnJlYWRDaGFyKCksdGhpcy5za2lwV2hpdGVzcGFjZSgpfXJlYWRJZGVudGlmaWVyKCl7Zm9yKHZhciBlPXRoaXMuX2N1cnJQb3NpdGlvbjt0aGlzLmlzSWRlbnRpZmllcih0aGlzLl9jaGFyKTspdGhpcy5yZWFkQ2hhcigpO3JldHVybiB0aGlzLl9zb3VyY2Uuc3Vic3RyaW5nKGUsdGhpcy5fY3VyclBvc2l0aW9uKX1pc0lkZW50aWZpZXIoZSl7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3JldHVybiA5Nzw9dCYmdDw9MTIyfHw2NTw9dCYmdDw9OTB8fDQ4PD10JiZ0PD01N3x8dD09OTV9c2tpcFdoaXRlc3BhY2UoKXtmb3IoO3RoaXMuSXNXaGl0ZXNwYWNlKHRoaXMuX2NoYXIpOyl0aGlzLnJlYWRDaGFyKCl9SXNXaGl0ZXNwYWNlKGUpe3JldHVybiBlPT09XCIgXCJ8fGU9PT1cIlx0XCJ8fGU9PT1cIlxcclwifHxlPT09YFxuYH1za2lwQ29tbWVudCgpe2Zvcig7dGhpcy5fY2hhciE9PWBcbmAmJnRoaXMuX2NoYXIhPT1cIlxcMFwiOyl0aGlzLnJlYWRDaGFyKCk7dGhpcy5za2lwV2hpdGVzcGFjZSgpfXNraXBNdWx0aWxpbmVDb21tZW50KCl7aWYoISh0aGlzLl9jaGFyIT09XCIvXCImJnRoaXMucGVla0NoYXIoKSE9PVwiKlwiKSl7dGhpcy5yZWFkQ2hhcigpLHRoaXMucmVhZENoYXIoKTtmb3IobGV0IGU9MTtlPjAmJnRoaXMuX2NoYXIhPT1cIlxcMFwiOylpZih0aGlzLnJlYWRDaGFyKCksdGhpcy5fY2hhcj09PVwiL1wiJiZ0aGlzLnBlZWtDaGFyKCk9PT1cIipcIil7ZSsrLHRoaXMucmVhZENoYXIoKTtjb250aW51ZX1lbHNlIGlmKHRoaXMuX2NoYXI9PT1cIipcIiYmdGhpcy5wZWVrQ2hhcigpPT09XCIvXCIpe2UtLSx0aGlzLnJlYWRDaGFyKCk7Y29udGludWV9dGhpcy5yZWFkQ2hhcigpLHRoaXMucmVhZENoYXIoKSx0aGlzLnNraXBXaGl0ZXNwYWNlKCl9fWlzRGlnaXQoZSl7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3JldHVybiA0ODw9dCYmdDw9NTd9cmVhZE51bWJlcigpe2Zvcih2YXIgZT10aGlzLl9jdXJyUG9zaXRpb247dGhpcy5pc0RpZ2l0KHRoaXMuX2NoYXIpOyl0aGlzLnJlYWRDaGFyKCk7aWYodGhpcy5fY2hhcj09PVwiLlwiKWZvcih0aGlzLnJlYWRDaGFyKCk7dGhpcy5pc0RpZ2l0KHRoaXMuX2NoYXIpOyl0aGlzLnJlYWRDaGFyKCk7cmV0dXJuIHRoaXMuX3NvdXJjZS5zdWJzdHJpbmcoZSx0aGlzLl9jdXJyUG9zaXRpb24pfXJlYWRWYWx1ZSgpe3JldHVybiB0aGlzLmlzRGlnaXQodGhpcy5fY2hhcik/dGhpcy5yZWFkTnVtYmVyKCk6dGhpcy5yZWFkSWRlbnRpZmllcigpfXJlYWRMaW5lKCl7dmFyIGU9dGhpcy5fY3VyclBvc2l0aW9uLHQ9dGhpcy5fc291cmNlLmluZGV4T2YoYFxuYCx0aGlzLl9jdXJyUG9zaXRpb24pO3JldHVybiB0PT0tMSYmKHQ9dGhpcy5fc291cmNlLmxlbmd0aCksdGhpcy5fbGluZSsrLHRoaXMuX2NvbHVtbj0wLHRoaXMuX2N1cnJQb3NpdGlvbj10LHRoaXMuX25leHRQb3NpdGlvbj10KzEsdGhpcy5fc291cmNlLnN1YnN0cmluZyhlLHQrMSl9fWNsYXNzIHB1IGV4dGVuZHMgbnJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZS5zb3VyY2UpLG8odGhpcyxcIl90b2tlblBvc2l0aW9uXCIsMCksbyh0aGlzLFwiX3Rva2Vuc1wiLFtdKSx0aGlzLnBhcnNlKCl9c2tpcFRva2VuKGUpe3RoaXMuX3Rva2VuUG9zaXRpb24rPWV9cGVla1Rva2VuKGUpe3JldHVybiB0aGlzLl90b2tlblBvc2l0aW9uK2U+PXRoaXMuX3Rva2Vucy5sZW5ndGg/bmV3IGFzKHguRU9GLFwiXFwwXCIpOnRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlblBvc2l0aW9uK2VdfUdldE5leHRUb2tlbigpe2lmKHRoaXMuX3Rva2VuUG9zaXRpb24+PXRoaXMuX3Rva2Vucy5sZW5ndGgpcmV0dXJuIG5ldyBhcyh4LkVPRixcIlxcMFwiKTtsZXQgZT10aGlzLl90b2tlbnNbdGhpcy5fdG9rZW5Qb3NpdGlvbl07cmV0dXJuIHRoaXMuX3Rva2VuUG9zaXRpb24rKyxlfWdldCBjdXJyVG9rZW5Qb3NpdGlvbigpe3JldHVybiB0aGlzLl90b2tlblBvc2l0aW9ufXBhcnNlKCl7dGhpcy5yZWFkQ2hhcigpLHRoaXMuX3Rva2Vucz1uZXcgQXJyYXk7dmFyIGU7ZG8gZT10aGlzLm5leHRUb2tlbigpLHRoaXMuX3Rva2Vucy5wdXNoKGUpO3doaWxlKGUuVHlwZSE9eC5FT0YpfW5leHRUb2tlbigpe2lmKHRoaXMuc2tpcFdoaXRlc3BhY2UoKSx0aGlzLl9jaGFyPT09XCIvXCIpe2lmKHRoaXMucGVla0NoYXIoKT09PVwiL1wiKXJldHVybiB0aGlzLnNraXBDb21tZW50KCksdGhpcy5uZXh0VG9rZW4oKTtpZih0aGlzLnBlZWtDaGFyKCk9PT1cIipcIilyZXR1cm4gdGhpcy5za2lwTXVsdGlsaW5lQ29tbWVudCgpLHRoaXMubmV4dFRva2VuKCl9dmFyIGU9bmV3IGFzO3N3aXRjaChlLkxpbmU9dGhpcy5fbGluZSxlLkNvbHVtZT10aGlzLl9jb2x1bW4sdGhpcy5fY2hhcil7Y2FzZVwiXFwwXCI6ZS5UeXBlPXguRU9GLGUuTGl0ZXJhbD1cIkVPRlwiO2JyZWFrO2Nhc2VcIi5cIjplLlR5cGU9eC5ET1QsZS5MaXRlcmFsPVwiLlwiO2JyZWFrO2Nhc2VcIixcIjplLlR5cGU9eC5DT01NQSxlLkxpdGVyYWw9XCIsXCI7YnJlYWs7Y2FzZVwiOlwiOmUuVHlwZT14LkNPTE9OLGUuTGl0ZXJhbD1cIjpcIjticmVhaztjYXNlXCI/XCI6ZS5UeXBlPXguUVVFTUFSSyxlLkxpdGVyYWw9XCI/XCI7YnJlYWs7Y2FzZVwiO1wiOmUuVHlwZT14LlNFTUlDT0xPTixlLkxpdGVyYWw9XCI7XCI7YnJlYWs7Y2FzZVwiKFwiOmUuVHlwZT14LkxFRlRTQU1MTCxlLkxpdGVyYWw9XCIoXCI7YnJlYWs7Y2FzZVwiKVwiOmUuVHlwZT14LlJJR0hUU0FNTEwsZS5MaXRlcmFsPVwiKVwiO2JyZWFrO2Nhc2VcIltcIjplLlR5cGU9eC5MRUZUTUVESSxlLkxpdGVyYWw9XCJbXCI7YnJlYWs7Y2FzZVwiXVwiOmUuVHlwZT14LlJJR0hUTUVESSxlLkxpdGVyYWw9XCJdXCI7YnJlYWs7Y2FzZVwie1wiOmUuVHlwZT14LkxFRlRCSUcsZS5MaXRlcmFsPVwie1wiO2JyZWFrO2Nhc2VcIn1cIjplLlR5cGU9eC5SSUdIVEJJRyxlLkxpdGVyYWw9XCJ9XCI7YnJlYWs7Y2FzZVwiK1wiOmlmKHRoaXMucGVla0NoYXIoKT09PVwiK1wiKXt0aGlzLnJlYWRDaGFyKCksZS5UeXBlPXguSU5DLGUuTGl0ZXJhbD1cIisrXCI7YnJlYWt9ZWxzZSBpZih0aGlzLnBlZWtDaGFyKCk9PT1cIj1cIil7dGhpcy5yZWFkQ2hhcigpLGUuVHlwZT14LkFEREFTU0lHTixlLkxpdGVyYWw9XCIrPVwiO2JyZWFrfWUuVHlwZT14LkFERCxlLkxpdGVyYWw9XCIrXCI7YnJlYWs7Y2FzZVwiLVwiOmlmKHRoaXMucGVla0NoYXIoKT09PVwiLVwiKXt0aGlzLnJlYWRDaGFyKCksZS5UeXBlPXguREVDLGUuTGl0ZXJhbD1cIi0tXCI7YnJlYWt9ZWxzZSBpZih0aGlzLnBlZWtDaGFyKCk9PT1cIj1cIil7dGhpcy5yZWFkQ2hhcigpLGUuVHlwZT14LlNVQkFTU0lHTixlLkxpdGVyYWw9XCItPVwiO2JyZWFrfWUuVHlwZT14LlNVQixlLkxpdGVyYWw9XCItXCI7YnJlYWs7Y2FzZVwiKlwiOmlmKHRoaXMucGVla0NoYXIoKT09PVwiPVwiKXt0aGlzLnJlYWRDaGFyKCksZS5UeXBlPXguTVVMQVNTSUdOLGUuTGl0ZXJhbD1cIio9XCI7YnJlYWt9ZS5UeXBlPXguTVVMLGUuTGl0ZXJhbD1cIipcIjticmVhaztjYXNlXCIvXCI6aWYodGhpcy5wZWVrQ2hhcigpPT09XCI9XCIpe3RoaXMucmVhZENoYXIoKSxlLlR5cGU9eC5ESVZBU1NJR04sZS5MaXRlcmFsPVwiLz1cIjticmVha31lLlR5cGU9eC5ESVYsZS5MaXRlcmFsPVwiL1wiO2JyZWFrO2Nhc2VcIiZcIjppZih0aGlzLnBlZWtDaGFyKCk9PT1cIiZcIil7dGhpcy5yZWFkQ2hhcigpLGUuVHlwZT14LkFORCxlLkxpdGVyYWw9XCImJlwiO2JyZWFrfWUuVHlwZT14LkJJVEFORCxlLkxpdGVyYWw9XCImXCI7YnJlYWs7Y2FzZVwifFwiOmlmKHRoaXMucGVla0NoYXIoKT09PVwifFwiKXt0aGlzLnJlYWRDaGFyKCksZS5UeXBlPXguT1IsZS5MaXRlcmFsPVwifHxcIjticmVha31lLlR5cGU9eC5CSVRPUixlLkxpdGVyYWw9XCImXCI7YnJlYWs7Y2FzZVwiXlwiOmUuVHlwZT14LkJJVFhPUixlLkxpdGVyYWw9XCJeXCI7YnJlYWs7Y2FzZVwiIVwiOmlmKHRoaXMucGVla0NoYXIoKT09PVwiPVwiKXt0aGlzLnJlYWRDaGFyKCksZS5UeXBlPXguTk9URVFVQUwsZS5MaXRlcmFsPVwiIT1cIjticmVha31lLlR5cGU9eC5OT1QsZS5MaXRlcmFsPVwiIVwiO2JyZWFrO2Nhc2VcIj5cIjppZih0aGlzLnBlZWtDaGFyKCk9PT1cIj1cIil7dGhpcy5yZWFkQ2hhcigpLGUuVHlwZT14LkdSRUFURVJFUVVBTCxlLkxpdGVyYWw9XCI+PVwiO2JyZWFrfWVsc2UgaWYodGhpcy5wZWVrQ2hhcigpPT09XCI+XCIpe3RoaXMucmVhZENoYXIoKSxlLlR5cGU9eC5CSVRTSElGVF9SLGUuTGl0ZXJhbD1cIj4+XCI7YnJlYWt9ZS5UeXBlPXguR1JFQVRFUixlLkxpdGVyYWw9XCI+XCI7YnJlYWs7Y2FzZVwiPVwiOmlmKHRoaXMucGVla0NoYXIoKT09PVwiPVwiKXt0aGlzLnJlYWRDaGFyKCksZS5UeXBlPXguRVFVQUwsZS5MaXRlcmFsPVwiPT1cIjticmVha31lLlR5cGU9eC5BU1NJR04sZS5MaXRlcmFsPVwiPVwiO2JyZWFrO2Nhc2VcIjxcIjppZih0aGlzLnBlZWtDaGFyKCk9PT1cIj1cIil7dGhpcy5yZWFkQ2hhcigpLGUuVHlwZT14LkxFU1NFUVVBTCxlLkxpdGVyYWw9XCI8PVwiO2JyZWFrfWVsc2UgaWYodGhpcy5wZWVrQ2hhcigpPT09XCI8XCIpe3RoaXMucmVhZENoYXIoKSxlLlR5cGU9eC5CSVRTSElGVF9MLGUuTGl0ZXJhbD1cIjw8XCI7YnJlYWt9ZS5UeXBlPXguTEVTUyxlLkxpdGVyYWw9XCI8XCI7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gdGhpcy5pc0RpZ2l0KHRoaXMuX2NoYXIpP3RoaXMucmVhZERlY2ltYWwoKTooZS5MaXRlcmFsPXRoaXMucmVhZElkZW50aWZpZXIoKSxlLlR5cGU9dGhpcy5sb29rdXBJZGVudGlmaWVyKGUuTGl0ZXJhbCksdGhpcy5nZXRDaGFyKCk9PVwiW1wiJiZ0aGlzLnBlZWtDaGFyKCk9PVwiXVwiJiZlLmlzQnVpbHRpblR5cGUoKSYmKGUuVHlwZSsrLGUuTGl0ZXJhbCs9XCJbXVwiLHRoaXMucmVhZENoYXIoKSx0aGlzLnJlYWRDaGFyKCkpLGUpfXJldHVybiB0aGlzLnJlYWRDaGFyKCksZX1yZWFkRGVjaW1hbCgpe3ZhciBlPW5ldyBhcztlLkxpbmU9dGhpcy5fbGluZSxlLkNvbHVtZT10aGlzLl9jb2x1bW4sZS5UeXBlPXguTElURVJBTDt2YXIgdD10aGlzLnJlYWROdW1iZXIoKTtyZXR1cm4gdGhpcy5fY2hhcj09PVwiZVwiPyhlLkxpdGVyYWw9dCt0aGlzLl9jaGFyLHRoaXMucmVhZENoYXIoKSxlLkxpdGVyYWwrPXRoaXMuX2NoYXIsdGhpcy5yZWFkQ2hhcigpLGUuTGl0ZXJhbCs9dGhpcy5yZWFkTnVtYmVyKCksZS5UeXBlPXguTElURVJBTCxlKTp0aGlzLl9jaGFyPT09XCJ1XCI/KHRoaXMucmVhZENoYXIoKSxlLlR5cGU9eC5MSVRFUkFMLGUuTGl0ZXJhbD10K1widVwiLGUpOnRoaXMuX2NoYXI9PT1cImZcIj8odGhpcy5yZWFkQ2hhcigpLGUuVHlwZT14LkxJVEVSQUwsZS5MaXRlcmFsPXQrXCJmXCIsZSk6KGUuVHlwZT14LkxJVEVSQUwsZS5MaXRlcmFsPXQsZSl9bG9va3VwSWRlbnRpZmllcihlKXtzd2l0Y2goZSl7Y2FzZVwidm9pZFwiOnJldHVybiB4LlZPSUQ7Y2FzZVwiaW50XCI6cmV0dXJuIHguSU5UO2Nhc2VcInVpbnRcIjpyZXR1cm4geC5VSU5UO2Nhc2VcImJvb2xcIjpyZXR1cm4geC5CT09MO2Nhc2VcInRydWVcIjpyZXR1cm4geC5CT09MO2Nhc2VcImZhbHNlXCI6cmV0dXJuIHguQk9PTDtjYXNlXCJmbG9hdFwiOnJldHVybiB4LkZMT0FUO2Nhc2VcInZlYzJcIjpyZXR1cm4geC5WRUMyO2Nhc2VcInZlYzNcIjpyZXR1cm4geC5WRUMzO2Nhc2VcInZlYzRcIjpyZXR1cm4geC5WRUM0O2Nhc2VcImJ2ZWMyXCI6cmV0dXJuIHguQlZFQzI7Y2FzZVwiYnZlYzNcIjpyZXR1cm4geC5CVkVDMztjYXNlXCJidmVjNFwiOnJldHVybiB4LkJWRUM0O2Nhc2VcIml2ZWMyXCI6cmV0dXJuIHguSVZFQzI7Y2FzZVwiaXZlYzNcIjpyZXR1cm4geC5JVkVDMztjYXNlXCJpdmVjNFwiOnJldHVybiB4LklWRUM0O2Nhc2VcInV2ZWMyXCI6cmV0dXJuIHguVVZFQzI7Y2FzZVwidXZlYzNcIjpyZXR1cm4geC5VVkVDMztjYXNlXCJ1dmVjNFwiOnJldHVybiB4LlVWRUM0O2Nhc2VcIm1hdDJcIjpyZXR1cm4geC5NQVQyeDI7Y2FzZVwibWF0MngyXCI6cmV0dXJuIHguTUFUMngyO2Nhc2VcIm1hdDJ4M1wiOnJldHVybiB4Lk1BVDJ4MztjYXNlXCJtYXQyeDRcIjpyZXR1cm4geC5NQVQyeDQ7Y2FzZVwibWF0M1wiOnJldHVybiB4Lk1BVDN4MztjYXNlXCJtYXQzeDJcIjpyZXR1cm4geC5NQVQzeDI7Y2FzZVwibWF0M3gzXCI6cmV0dXJuIHguTUFUM3gzO2Nhc2VcIm1hdDN4NFwiOnJldHVybiB4Lk1BVDN4NDtjYXNlXCJtYXQ0XCI6cmV0dXJuIHguTUFUNHg0O2Nhc2VcIm1hdDR4MlwiOnJldHVybiB4Lk1BVDR4MjtjYXNlXCJtYXQ0eDNcIjpyZXR1cm4geC5NQVQ0eDM7Y2FzZVwibWF0NHg0XCI6cmV0dXJuIHguTUFUNHg0O2Nhc2VcInNhbXBsZXJcIjpyZXR1cm4geC5TQU1QTEVSO2Nhc2VcInNhbXBsZXIxRFwiOnJldHVybiB4LlNBTVBMRVJfMUQ7Y2FzZVwic2FtcGxlcjJEXCI6cmV0dXJuIHguU0FNUExFUl8yRDtjYXNlXCJzYW1wbGVyM0RcIjpyZXR1cm4geC5TQU1QTEVSXzNEO2Nhc2VcInNhbXBsZXJDdWJlXCI6cmV0dXJuIHguU0FNUExFUl9DVUJFO2Nhc2VcInNhbXBsZXJTaGFkb3dcIjpyZXR1cm4geC5TQU1QTEVSX1NIQURPVztjYXNlXCJzYW1wbGVyMURTaGFkb3dcIjpyZXR1cm4geC5TQU1QTEVSXzFEX1NIQURPVztjYXNlXCJzYW1wbGVyMkRTaGFkb3dcIjpyZXR1cm4geC5TQU1QTEVSXzJEX1NIQURPVztjYXNlXCJ0ZXh0dXJlMURcIjpyZXR1cm4geC5URVhUVVJFXzFEO2Nhc2VcInRleHR1cmUyRFwiOnJldHVybiB4LlRFWFRVUkVfMkQ7Y2FzZVwidGV4dHVyZTNEXCI6cmV0dXJuIHguVEVYVFVSRV8zRDtjYXNlXCJ0ZXh0dXJlQ3ViZVwiOnJldHVybiB4LlRFWFRVUkVfQ1VCRTtjYXNlXCJ0ZXh0dXJlMURBcnJheVwiOnJldHVybiB4LlRFWFRVUkVfMURfQVJSQVk7Y2FzZVwidGV4dHVyZTJEQXJyYXlcIjpyZXR1cm4geC5URVhUVVJFXzJEX0FSUkFZO2Nhc2VcInRleHR1cmVDdWJlQXJyYXlcIjpyZXR1cm4geC5URVhUVVJFX0NVQkVfQVJSQVk7Y2FzZVwiY29uc3RcIjpyZXR1cm4geC5DT05TVDtjYXNlXCJsYXlvdXRcIjpyZXR1cm4geC5MQVlPVVQ7Y2FzZVwicHJlY2lzaW9uXCI6cmV0dXJuIHguUFJFQ0lTSU9OO2Nhc2VcImF0dHJpYnV0ZVwiOnJldHVybiB4LkFUVFJJQlVURTtjYXNlXCJ1bmlmb3JtXCI6cmV0dXJuIHguVU5JRk9STTtjYXNlXCJ2YXJ5aW5nXCI6cmV0dXJuIHguVkFSWUlORztjYXNlXCJpbnZhcmlhbnRcIjpyZXR1cm4geC5JTlZBUklBTlQ7Y2FzZVwiaW5cIjpyZXR1cm4geC5JTjtjYXNlXCJvdXRcIjpyZXR1cm4geC5PVVQ7Y2FzZVwiaW5vdXRcIjpyZXR1cm4geC5JTk9VVDtjYXNlXCJpZlwiOnJldHVybiB4LklGO2Nhc2VcImVsc2VcIjpyZXR1cm4geC5FTFNFO2Nhc2VcImZvclwiOnJldHVybiB4LkZPUjtjYXNlXCJ3aGlsZVwiOnJldHVybiB4LldISUxFO2Nhc2VcImRvXCI6cmV0dXJuIHguRE87Y2FzZVwiYnJlYWtcIjpyZXR1cm4geC5CUkVBSztjYXNlXCJyZXR1cm5cIjpyZXR1cm4geC5SRVRVUk47Y2FzZVwiY29udGludWVcIjpyZXR1cm4geC5DT05USU5VRTtjYXNlXCJzdHJ1Y3RcIjpyZXR1cm4geC5TVFJVQ1R9cmV0dXJuIHguSURFTlR9fWNsYXNzIEZne2NvbnN0cnVjdG9yKCl7byh0aGlzLFwibmFtZVwiLFwiXCIpLG8odGhpcyxcInZhbHVlXCIsXCJcIiksbyh0aGlzLFwiYXJnc1wiLFtdKX19Y2xhc3MgbXUgZXh0ZW5kcyBucntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSxvKHRoaXMsXCJfcmVzdWx0XCIpLG8odGhpcyxcIl9za2lwTGluZVwiKSxvKHRoaXMsXCJfZGVmaW5pdGlvblRhYmxlc1wiKSx0aGlzLl9yZXN1bHQ9XCJcIix0aGlzLl9za2lwTGluZT0hMSx0aGlzLl9kZWZpbml0aW9uVGFibGVzPW5ldyBNYXAsdGhpcy5wYXJzZSgpfXBhcnNlKCl7Zm9yKHRoaXMucmVhZENoYXIoKTt0aGlzLl9jaGFyIT09XCJcXDBcIjspe2lmKHRoaXMuc2tpcFdoaXRlc3BhY2UoKSx0aGlzLl9jaGFyPT09XCIvXCIpe2lmKHRoaXMucGVla0NoYXIoKT09PVwiL1wiKXt0aGlzLnNraXBDb21tZW50KCk7Y29udGludWV9aWYodGhpcy5wZWVrQ2hhcigpPT09XCIqXCIpe3RoaXMuc2tpcE11bHRpbGluZUNvbW1lbnQoKTtjb250aW51ZX19aWYodGhpcy5fY2hhcj09PVwiI1wiKXt0aGlzLnJlYWRDaGFyQW5kU2tpcFdoaXRlc3BhY2UoKTt2YXIgZT10aGlzLnJlYWRJZGVudGlmaWVyKCk7c3dpdGNoKGUpe2Nhc2VcInZlcnNpb25cIjp0aGlzLnJlYWRMaW5lKCkudHJpbSgpO2JyZWFrO2Nhc2VcImRlZmluZVwiOnRoaXMucmVhZENoYXJBbmRTa2lwV2hpdGVzcGFjZSgpO3ZhciB0PXRoaXMucmVhZElkZW50aWZpZXIoKTtpZih0aGlzLmdldENoYXIoKT09PVwiKFwiKXtsZXQgbD1uZXcgRmc7aWYodGhpcy5yZWFkQ2hhckFuZFNraXBXaGl0ZXNwYWNlKCksdGhpcy5nZXRDaGFyKCkhPT1cIilcIilkb3t2YXIgcj10aGlzLnJlYWRJZGVudGlmaWVyKCk7aWYobC5hcmdzLnB1c2gociksdGhpcy5za2lwV2hpdGVzcGFjZSgpLHRoaXMuZ2V0Q2hhcigpPT09XCIsXCIpe3RoaXMucmVhZENoYXJBbmRTa2lwV2hpdGVzcGFjZSgpO2NvbnRpbnVlfX13aGlsZSh0aGlzLmdldENoYXIoKSE9PVwiKVwiKTt0aGlzLnJlYWRDaGFyQW5kU2tpcFdoaXRlc3BhY2UoKSxsLm5hbWU9dCxsLnZhbHVlPXRoaXMucmVhZExpbmUoKS50cmltKCksdGhpcy5fZGVmaW5pdGlvblRhYmxlcy5zZXQodCxsKSx0aGlzLnJlYWRDaGFyQW5kU2tpcFdoaXRlc3BhY2UoKX1lbHNle2xldCBsPXRoaXMucmVhZExpbmUoKS50cmltKCk7bFswXT09XCI9XCImJihsPWwuc3Vic3RyaW5nKDEpKSx0aGlzLl9kZWZpbml0aW9uVGFibGVzLnNldCh0LGwpfWJyZWFrO2Nhc2VcImlmXCI6bGV0IG49dGhpcy5yZWFkTGluZSgpLnRyaW0oKTtpZihuPT1cIjBcInx8bj09XCJmYWxzZVwiKXt0aGlzLl9za2lwTGluZT0hMDticmVha31pZih0aGlzLl9kZWZpbml0aW9uVGFibGVzLmhhcyhuKSYmKG49dGhpcy5fZGVmaW5pdGlvblRhYmxlcy5nZXQobiksbj09XCIwXCJ8fG49PVwiZmFsc2VcIikpe3RoaXMuX3NraXBMaW5lPSEwO2JyZWFrfWJyZWFrO2Nhc2VcImlmZGVmXCI6dGhpcy5yZWFkQ2hhckFuZFNraXBXaGl0ZXNwYWNlKCk7dmFyIHM9dGhpcy5yZWFkSWRlbnRpZmllcigpO3RoaXMuX3NraXBMaW5lPSF0aGlzLl9kZWZpbml0aW9uVGFibGVzLmhhcyhzKTticmVhaztjYXNlXCJlbHNlXCI6dGhpcy5fc2tpcExpbmU9IXRoaXMuX3NraXBMaW5lO2JyZWFrO2Nhc2VcImVuZGlmXCI6dGhpcy5fc2tpcExpbmU9ITE7YnJlYWs7ZGVmYXVsdDp0aHJvd1wiVW5rbm93biBwcmVwcm9jZXNzaW5nIGNvbW1hbmQ6XCIrZX19ZWxzZXt2YXIgYT10aGlzLnJlYWRMaW5lKCk7aWYoIXRoaXMuX3NraXBMaW5lKXtmb3IobGV0IG4gb2YgdGhpcy5fZGVmaW5pdGlvblRhYmxlcy5rZXlzKCkpe2xldCBsPWEuaW5kZXhPZihuKTtpZihsIT0tMSl7bGV0IGg9dGhpcy5fZGVmaW5pdGlvblRhYmxlcy5nZXQobik7aWYodHlwZW9mIGg9PVwic3RyaW5nXCIpYT1hLnJlcGxhY2UobixoKTtlbHNle2xldCB1PWgsYz1uZXcgbnIoYS5zdWJzdHJpbmcobCtuLmxlbmd0aCkpO2lmKGMucmVhZENoYXJBbmRTa2lwV2hpdGVzcGFjZSgpLGMuZ2V0Q2hhcigpPT09XCIoXCIpe2MucmVhZENoYXJBbmRTa2lwV2hpdGVzcGFjZSgpO2ZvcihsZXQgbT0xO2MuZ2V0Q2hhcigpIT09XCJcXDBcIiYmbT4wOyl7c3dpdGNoKGMuZ2V0Q2hhcigpKXtjYXNlXCIoXCI6bSsrO2JyZWFrO2Nhc2VcIilcIjptLS07YnJlYWt9Yy5yZWFkQ2hhckFuZFNraXBXaGl0ZXNwYWNlKCl9fWxldCBmPWwsZD1mK24ubGVuZ3RoK2MuY3VyclBvc2l0aW9uLHA9YS5zdWJzdHJpbmcoZixkKS50cmltKCk7aWYodS5hcmdzLmxlbmd0aD4wKXtsZXQgbT1bXSxfPXAuc3Vic3RyaW5nKHAuaW5kZXhPZihcIihcIikrMSxwLmxhc3RJbmRleE9mKFwiKVwiKSkudHJpbSgpO18ubGVuZ3RoPjAmJihtPXRoaXMucGFyc2VBcmdzKF8pKTtsZXQgdj11LnZhbHVlLnN1YnN0cmluZyh1LnZhbHVlLmluZGV4T2YoXCIoXCIpKTtmb3IobGV0IHk9MDt5PHUuYXJncy5sZW5ndGg7eSsrKXY9di5yZXBsYWNlKHUuYXJnc1t5XSxtW3ldKTt2PXUudmFsdWUuc3Vic3RyaW5nKDAsdS52YWx1ZS5pbmRleE9mKFwiKFwiKSkrdixhPWEucmVwbGFjZShwLHYpfWVsc2UgYT1hLnJlcGxhY2UocCx1LnZhbHVlKX19fXRoaXMuX3Jlc3VsdCs9YX10aGlzLnJlYWRDaGFyKCl9fX1nZXQgc291cmNlKCl7cmV0dXJuIHRoaXMuX3Jlc3VsdH1wYXJzZUFyZ3MoZSl7bGV0IHQ9W10scj0wLHM9bmV3IG5yKGUpLGE9cy5jdXJyUG9zaXRpb247aWYocy5yZWFkQ2hhckFuZFNraXBXaGl0ZXNwYWNlKCkscy5nZXRDaGFyKCkhPT1cIlxcMFwiKWZvcihzLnJlYWRDaGFyQW5kU2tpcFdoaXRlc3BhY2UoKTtzLmdldENoYXIoKSE9PVwiXFwwXCI7KXtzd2l0Y2gocy5nZXRDaGFyKCkpe2Nhc2VcIihcIjpyKys7YnJlYWs7Y2FzZVwiKVwiOnItLTticmVhaztjYXNlXCIsXCI6aWYocj09MCl7bGV0IG49ZS5zdWJzdHJpbmcoYSxzLmN1cnJQb3NpdGlvbik7dC5wdXNoKG4pLGE9cy5jdXJyUG9zaXRpb24rMX1icmVha31zLnJlYWRDaGFyQW5kU2tpcFdoaXRlc3BhY2UoKX1pZihhPHMuY3VyclBvc2l0aW9uKXtsZXQgbj1lLnN1YnN0cmluZyhhLHMuY3VyclBvc2l0aW9uKTt0LnB1c2gobil9cmV0dXJuIHR9fWNsYXNzIEF1e2NvbnN0cnVjdG9yKGUpe28odGhpcyxcInJlc3VsdFwiKSxvKHRoaXMsXCJBU1RSb290XCIpLG8odGhpcyxcIl9zeW50YXhcIiksdGhpcy5yZXN1bHQ9XCJcIix0aGlzLl9zeW50YXg9ZSx0aGlzLkFTVFJvb3Q9ZS5BU1RSb290fWdlbmVyYXRlV0dTTCgpe2xldCBlPW5ldyBVbzt2YXIgdD1uZXcgeXU7bGV0IHI9W10scz1bXSxhPVtdO2ZvcihsZXQgYyBvZiB0aGlzLkFTVFJvb3Qubm9kZXMpaWYoYyBpbnN0YW5jZW9mIHZzKWlmKGMuc2NvcGU9PVwiaW5cIilpZihjLm5vZGVzWzBdaW5zdGFuY2VvZiBUZSl7ZS5sYXlvdXRzSW4ucHVzaChjKTtsZXQgZj1uZXcgTm87Zi5uYW1lPWMubm9kZXNbMF0ubmFtZSxmLnR5cGU9Yy5ub2Rlc1swXS50eXBlLGYubG9jYXRpb25JRD1OdW1iZXIucGFyc2VJbnQoYy5xdWFsaWZpZXIuZ2V0KFwibG9jYXRpb25cIikpLHQuaW5wdXRBdHRyaWJ1dGUucHVzaChmKX1lbHNlIGlmKGMucXVhbGlmaWVyLmhhcyhcImxvY2FsX3NpemVfeFwiKSllLndvcmtHcm91cFNpemU9YztlbHNlIHRocm93XCJub3QgaW1wbFwiO2Vsc2UgaWYoYy5zY29wZT09XCJvdXRcIilpZihlLmxheW91dHNPdXQucHVzaChjKSxjLm5vZGVzWzBdaW5zdGFuY2VvZiBUZSl7bGV0IGY9bmV3IE5vO2YubmFtZT1jLm5vZGVzWzBdLm5hbWUsZi50eXBlPWMubm9kZXNbMF0udHlwZSxmLmxvY2F0aW9uSUQ9TnVtYmVyLnBhcnNlSW50KGMucXVhbGlmaWVyLmdldChcImxvY2F0aW9uXCIpKSx0Lm91dHB1dEF0dHJpYnV0ZS5wdXNoKGYpfWVsc2UgdGhyb3dcIm5vdCBpbXBsXCI7ZWxzZSBpZihjLnNjb3BlPT1cInVuaWZvcm1cIilpZihzLnB1c2goYyksYy5ub2Rlc1swXWluc3RhbmNlb2YgVGUpe2xldCBmPW5ldyBPbztmLm5hbWU9Yy5ub2Rlc1swXS5uYW1lLGYudHlwZT1jLm5vZGVzWzBdLnR5cGUsZi5zZXRJRD1OdW1iZXIucGFyc2VJbnQoYy5xdWFsaWZpZXIuZ2V0KFwic2V0XCIpKSxmLmJpbmRpbmdJRD1OdW1iZXIucGFyc2VJbnQoYy5xdWFsaWZpZXIuZ2V0KFwiYmluZGluZ1wiKSksdC51bmlmb3JtSW5mby5wdXNoKGYpfWVsc2UgaWYoYy5ub2Rlc1swXWluc3RhbmNlb2Ygb2kpe2xldCBmPW5ldyBPbztmLm5hbWU9XCJ1bmlmXCIrdC51bmlmb3JtSW5mby5sZW5ndGgudG9TdHJpbmcoKSxmLnR5cGU9Yy5ub2Rlc1swXS5uYW1lLGYuc2V0SUQ9TnVtYmVyLnBhcnNlSW50KGMucXVhbGlmaWVyLmdldChcInNldFwiKSksZi5iaW5kaW5nSUQ9TnVtYmVyLnBhcnNlSW50KGMucXVhbGlmaWVyLmdldChcImJpbmRpbmdcIikpLHQudW5pZm9ybUluZm8ucHVzaChmKX1lbHNlIHRocm93XCJub3QgaW1wbFwiO2Vsc2UgYy5zY29wZT09XCJidWZmZXJcIiYmci5wdXNoKGMpO2Vsc2UgYS5wdXNoKGMpO2Uuc3RhZ2U9XCJmcmFnbWVudFwiO2xldCBuPTAsbD1uZXcgbnIoXCJcIiksaD10aGlzLl9zeW50YXgubGV4ZXIuc291cmNlLHU9bmV3IE1hcDtmb3IoOyhuPWguaW5kZXhPZihcImdsX1wiLG4pKSE9LTE7KXtsLnJlc2V0KGguc3Vic3RyaW5nKG4sbiszMikpLGwucmVhZENoYXIoKTtsZXQgYz1sLnJlYWRJZGVudGlmaWVyKCk7aWYobis9Yy5sZW5ndGgsIXUuaGFzKGMpKXN3aXRjaCh1LnNldChjLGMpLGMpe2Nhc2VcImdsX0luc3RhbmNlSURcIjplLnN0YWdlPVwidmVydGV4XCIsZS5idWlsdGluSW4ucHVzaChcIkBidWlsdGluKGluc3RhbmNlX2luZGV4KSBnbF9JbnN0YW5jZUlEOiB1MzJcIik7YnJlYWs7Y2FzZVwiZ2xfUG9zaXRpb25cIjplLnN0YWdlPVwidmVydGV4XCIsZS5idWlsdGluT3V0LnB1c2goXCJAYnVpbHRpbihwb3NpdGlvbikgZ2xfUG9zaXRpb246IHZlYzQ8ZjMyPlwiKSxlLmFkZElkZW50aWZpZXIoXCJnbF9Qb3NpdGlvblwiLFwic3RvdXQuZ2xfUG9zaXRpb25cIik7YnJlYWs7Y2FzZVwiZ2xfVmVydGV4SW5kZXhcIjplLnN0YWdlPVwidmVydGV4XCIsZS5idWlsdGluSW4ucHVzaChcIkBidWlsdGluKHZlcnRleF9pbmRleCkgZ2xfVmVydGV4SW5kZXg6IHUzMlwiKTticmVhaztjYXNlXCJnbF9Gcm9udEZhY2luZ1wiOmUuc3RhZ2U9XCJmcmFnbWVudFwiLGUuYnVpbHRpbkluLnB1c2goXCJAYnVpbHRpbihmcm9udF9mYWNpbmcpIGdsX0Zyb250RmFjaW5nOiBib29sXCIpO2JyZWFrO2Nhc2VcImdsX0ZyYWdEZXB0aFwiOmUuc3RhZ2U9XCJmcmFnbWVudFwiLGUuYnVpbHRpbk91dC5wdXNoKFwiQGJ1aWx0aW4oZnJhZ19kZXB0aCkgZ2xfRnJhZ0RlcHRoOiBmMzJcIiksZS5hZGRJZGVudGlmaWVyKFwiZ2xfRnJhZ0RlcHRoXCIsXCJzdG91dC5nbF9GcmFnRGVwdGhcIik7YnJlYWs7Y2FzZVwiZ2xfV29ya0dyb3VwSURcIjplLnN0YWdlPVwiY29tcHV0ZVwiLGUuYnVpbHRpbkluLnB1c2goXCJAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIGdsX1dvcmtHcm91cElEOiB2ZWMzPHUzMj5cIik7YnJlYWs7Y2FzZVwiZ2xfTnVtV29ya0dyb3Vwc1wiOmUuc3RhZ2U9XCJjb21wdXRlXCIsZS5idWlsdGluSW4ucHVzaChcIkBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBnbF9OdW1Xb3JrR3JvdXBzOiB2ZWMzPHUzMj5cIik7YnJlYWs7Y2FzZVwiZ2xfTG9jYWxJbnZvY2F0aW9uSURcIjplLnN0YWdlPVwiY29tcHV0ZVwiLGUuYnVpbHRpbkluLnB1c2goXCJAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBnbF9Mb2NhbEludm9jYXRpb25JRDogdmVjMzx1MzI+XCIpO2JyZWFrO2Nhc2VcImdsX0xvY2FsSW52b2NhdGlvbkluZGV4XCI6ZS5zdGFnZT1cImNvbXB1dGVcIixlLmJ1aWx0aW5Jbi5wdXNoKFwiQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgZ2xfTG9jYWxJbnZvY2F0aW9uSW5kZXg6IHUzMlwiKTticmVhaztjYXNlXCJnbF9HbG9iYWxJbnZvY2F0aW9uSURcIjplLnN0YWdlPVwiY29tcHV0ZVwiLGUuYnVpbHRpbkluLnB1c2goXCJAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xfR2xvYmFsSW52b2NhdGlvbklEOiB2ZWMzPHUzMj5cIik7YnJlYWs7ZGVmYXVsdDp0aHJvd1wiVW5wcm9jZXNzZWQgYnVpbHQtaW4gdmFyaWFibGVzOiBcIitjfX1mb3IobGV0IGMgb2YgcyljLm5vZGVzWzBdaW5zdGFuY2VvZiBvaSYmKHQuc291cmNlQ29kZSs9Yy5ub2Rlc1swXS5mb3JtYXRUb1dHU0woZSwwKSx0LnNvdXJjZUNvZGUrPWBcXHJcbmApO2ZvcihsZXQgYyBvZiBzKXQuc291cmNlQ29kZSs9Yy5mb3JtYXRUb1dHU0woZSwwKTt0LnNvdXJjZUNvZGUrPWBcXHJcbmA7Zm9yKGxldCBjIG9mIHIpYy5ub2Rlc1swXWluc3RhbmNlb2Ygb2kmJih0LnNvdXJjZUNvZGUrPWMubm9kZXNbMF0uZm9ybWF0VG9XR1NMKGUsMCksdC5zb3VyY2VDb2RlKz1gXFxyXG5gKTtmb3IobGV0IGMgb2Ygcil0LnNvdXJjZUNvZGUrPWMuZm9ybWF0VG9XR1NMKGUsMCk7dC5zb3VyY2VDb2RlKz1gXFxyXG5gO2ZvcihsZXQgYyBvZiBhKXQuc291cmNlQ29kZSs9Yy5mb3JtYXRUb1dHU0woZSwwKSxjIGluc3RhbmNlb2YgVGUmJih0LnNvdXJjZUNvZGUrPWA7XFxyXG5gKTtyZXR1cm4gdH19Y2xhc3MgVW97Y29uc3RydWN0b3IoZSl7byh0aGlzLFwiX3N0YWdlXCIsXCJmcmFnbWVudFwiKSxvKHRoaXMsXCJfYnVpbHRpbkluXCIsW10pLG8odGhpcyxcIl9idWlsdGluT3V0XCIsW10pLG8odGhpcyxcIl9sYXlvdXRzSW5cIixbXSksbyh0aGlzLFwiX2xheW91dHNPdXRcIixbXSksbyh0aGlzLFwiX2xheW91dFVuaWZvcm1Db3VudFwiLDApLG8odGhpcyxcIl93b3JrR3JvdXBTaXplXCIpLG8odGhpcyxcIl9wYXJlbnRDb250ZXh0XCIpLG8odGhpcyxcIl9pZGVudGlmaWVyRW52XCIsbmV3IE1hcCksdGhpcy5fcGFyZW50Q29udGV4dD1lfWdldCBzdGFnZSgpe3JldHVybiB0aGlzLnBhcmVudENvbnRleHQhPW51bGw/dGhpcy5wYXJlbnRDb250ZXh0LnN0YWdlOnRoaXMuX3N0YWdlfXNldCBzdGFnZShlKXt0aGlzLnBhcmVudENvbnRleHQhPW51bGwmJih0aGlzLnBhcmVudENvbnRleHQuc3RhZ2U9ZSksdGhpcy5fc3RhZ2U9ZX1nZXQgYnVpbHRpbkluKCl7cmV0dXJuIHRoaXMucGFyZW50Q29udGV4dCE9bnVsbD90aGlzLnBhcmVudENvbnRleHQuYnVpbHRpbkluOnRoaXMuX2J1aWx0aW5Jbn1nZXQgYnVpbHRpbk91dCgpe3JldHVybiB0aGlzLnBhcmVudENvbnRleHQhPW51bGw/dGhpcy5wYXJlbnRDb250ZXh0LmJ1aWx0aW5PdXQ6dGhpcy5fYnVpbHRpbk91dH1nZXQgbGF5b3V0c0luKCl7cmV0dXJuIHRoaXMucGFyZW50Q29udGV4dCE9bnVsbD90aGlzLnBhcmVudENvbnRleHQubGF5b3V0c0luOnRoaXMuX2xheW91dHNJbn1nZXQgbGF5b3V0c091dCgpe3JldHVybiB0aGlzLnBhcmVudENvbnRleHQhPW51bGw/dGhpcy5wYXJlbnRDb250ZXh0LmxheW91dHNPdXQ6dGhpcy5fbGF5b3V0c091dH1nZXQgbGF5b3V0VW5pZm9ybUNvdW50KCl7cmV0dXJuIHRoaXMucGFyZW50Q29udGV4dCE9bnVsbD90aGlzLnBhcmVudENvbnRleHQubGF5b3V0VW5pZm9ybUNvdW50OnRoaXMuX2xheW91dFVuaWZvcm1Db3VudH1zZXQgbGF5b3V0VW5pZm9ybUNvdW50KGUpe2lmKHRoaXMucGFyZW50Q29udGV4dCE9bnVsbCl7dGhpcy5wYXJlbnRDb250ZXh0LmxheW91dFVuaWZvcm1Db3VudD1lO3JldHVybn10aGlzLl9sYXlvdXRVbmlmb3JtQ291bnQ9ZX1nZXQgd29ya0dyb3VwU2l6ZSgpe3JldHVybiB0aGlzLnBhcmVudENvbnRleHQhPW51bGw/dGhpcy5wYXJlbnRDb250ZXh0LndvcmtHcm91cFNpemU6dGhpcy5fd29ya0dyb3VwU2l6ZX1zZXQgd29ya0dyb3VwU2l6ZShlKXt0aGlzLnBhcmVudENvbnRleHQhPW51bGwmJih0aGlzLnBhcmVudENvbnRleHQud29ya0dyb3VwU2l6ZT1lKSx0aGlzLl93b3JrR3JvdXBTaXplPWV9Z2V0IHBhcmVudENvbnRleHQoKXtyZXR1cm4gdGhpcy5fcGFyZW50Q29udGV4dH1maW5kSWRlbnRpZmllcihlKXtyZXR1cm4gdGhpcy5faWRlbnRpZmllckVudi5oYXMoZSk/dGhpcy5faWRlbnRpZmllckVudi5nZXQoZSk6dGhpcy5fcGFyZW50Q29udGV4dCE9bnVsbD90aGlzLl9wYXJlbnRDb250ZXh0LmZpbmRJZGVudGlmaWVyKGUpOmV9YWRkSWRlbnRpZmllcihlLHQpe3RoaXMuX2lkZW50aWZpZXJFbnYuc2V0KGUsdCl9aGFzSWRlbnRpZmllcihlKXtyZXR1cm4gdGhpcy5faWRlbnRpZmllckVudi5oYXMoZSl9fWNsYXNzIG1le2NvbnN0cnVjdG9yKCl7byh0aGlzLFwibm9kZXNcIixbXSl9YWRkTm9kZShlKXt0aGlzLm5vZGVzLnB1c2goZSl9Zm9ybWF0VG9XR1NMKGUsdCl7cmV0dXJuXCJcIn19Y2xhc3Mgb2kgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcIm5hbWVcIixcIlwiKSxvKHRoaXMsXCJmaWVsZHNcIixbXSksdGhpcy5uYW1lPWV9c3RhdGljIHBhcnNlKGUpe2lmKGUucGVla1Rva2VuKDApLlR5cGU9PXguSURFTlQmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguTEVGVEJJRyl7bGV0IHQ9bmV3IG9pKGUucGVla1Rva2VuKDApLkxpdGVyYWwpO2ZvcihlLnNraXBUb2tlbigyKTtlLnBlZWtUb2tlbigwKS5UeXBlIT14LlJJR0hUQklHOyl7bGV0IHI9VGUucGFyc2UoZSk7dC5maWVsZHMucHVzaChyKX1yZXR1cm4gZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SSUdIVEJJRyYmZS5za2lwVG9rZW4oMSksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5TRU1JQ09MT04mJmUuc2tpcFRva2VuKDEpLHR9dGhyb3dcIkVycm9yIHBhcnNpbmcgc3RydWN0dXJlOiBVbmV4cGVjdGVkIGNoYXJhY3RlclwifWZvcm1hdFRvV0dTTChlLHQpe2xldCByPVwiXCIscz10PD0wP1wiXCI6XCIgICAgXCIucmVwZWF0KHQpO3IrPXMrXCJzdHJ1Y3QgXCIrdGhpcy5uYW1lK2Age1xcclxuYDtmb3IobGV0IGEgb2YgdGhpcy5maWVsZHMpYS5hcnJheVNpemUubm9kZXMubGVuZ3RoPD0wP3IrPXMrXCIgIFwiK2EubmFtZStcIjogXCIrU3QoYS50eXBlKStgLFxcclxuYDphLmFycmF5U2l6ZS5ub2Rlc1swXWluc3RhbmNlb2Ygbmk/cis9cytcIiAgXCIrYS5uYW1lK1wiOiBhcnJheTxcIitTdChhLnR5cGUpK1wiLCBcIithLmFycmF5U2l6ZS5ub2Rlc1swXS52YWx1ZStgPixcXHJcbmA6cis9cytcIiAgXCIrYS5uYW1lK1wiOiBhcnJheTxcIitTdChhLnR5cGUpK1wiLCBcIithLmFycmF5U2l6ZS5ub2Rlc1swXS5mb3JtYXRUb1dHU0woZSwwKStgPixcXHJcbmA7cmV0dXJuIHIrPXMrYH07XFxyXG5gLHJ9fWNsYXNzIF9hIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoZSx0LHIscyl7c3VwZXIoKSxvKHRoaXMsXCJuYW1lXCIpLG8odGhpcyxcImFyZ3NcIiksbyh0aGlzLFwiYm9keVwiKSxvKHRoaXMsXCJyZXR1cm5UeXBlXCIpLHRoaXMubmFtZT1lLHRoaXMuYXJncz10LHRoaXMuYm9keT1yLHRoaXMucmV0dXJuVHlwZT1zfXN0YXRpYyBwYXJzZShlKXtpZigoZS5wZWVrVG9rZW4oMCkuaXNCdWlsdGluVHlwZSgpfHxlLnBlZWtUb2tlbigwKS5UeXBlPT14LlZPSUQpJiZlLnBlZWtUb2tlbigxKS5UeXBlPT14LklERU5UJiZlLnBlZWtUb2tlbigyKS5UeXBlPT14LkxFRlRTQU1MTCl7bGV0IHQ9ZS5wZWVrVG9rZW4oMCkuTGl0ZXJhbCxyPWUucGVla1Rva2VuKDEpLkxpdGVyYWw7ZS5za2lwVG9rZW4oMik7bGV0IHM9bmV3IEFycmF5O2lmKGUucGVla1Rva2VuKDApLlR5cGUhPXguTEVGVFNBTUxMKXRocm93XCJFcnJvciBwYXJzaW5nIGZ1bmN0aW9uIHBhcmFtZXRlciBsaXN0OiBVbmV4cGVjdGVkIGNoYXJhY3RlclwiO2ZvcihlLnNraXBUb2tlbigxKTtlLnBlZWtUb2tlbigwKS5UeXBlIT14LkVPRjspe2lmKGUucGVla1Rva2VuKDApLlR5cGU9PXguUklHSFRTQU1MTCl7ZS5za2lwVG9rZW4oMSk7YnJlYWt9KGUucGVla1Rva2VuKDApLlR5cGU9PXguSU5PVVR8fGUucGVla1Rva2VuKDApLlR5cGU9PXguSU58fGUucGVla1Rva2VuKDApLlR5cGU9PXguT1VUKSYmZS5za2lwVG9rZW4oMSk7bGV0IG49VGUucGFyc2UoZSk7cy5wdXNoKG4pLGUucGVla1Rva2VuKDApLlR5cGU9PXguQ09NTUEmJmUuc2tpcFRva2VuKDEpfWxldCBhPUd0LnBhcnNlKGUpO3JldHVybiBuZXcgX2EocixzLGEsdCl9dGhyb3dcIkVycm9yIHBhcnNpbmcgZnVuY3Rpb246IFVuZXhwZWN0ZWQgY2hhcmFjdGVyXCJ9Zm9ybWF0VG9XR1NMKGUsdCl7bGV0IHI9XCJcIixzPXQ8PTA/XCJcIjpcIiAgICBcIi5yZXBlYXQodCksYSxuPWUubGF5b3V0c091dC5sZW5ndGg+MHx8ZS5idWlsdGluT3V0Lmxlbmd0aD4wO3N3aXRjaChlLnN0YWdlKXtjYXNlXCJjb21wdXRlXCI6YT1cIkNvbXB1dGVPdXRwdXRcIjticmVhaztjYXNlXCJ2ZXJ0ZXhcIjphPVwiVmVydGV4T3V0cHV0XCI7YnJlYWs7Y2FzZVwiZnJhZ21lbnRcIjphPVwiRnJhZ21lbnRPdXRwdXRcIjticmVhaztkZWZhdWx0OmE9XCJTdHJ1Y3RPdXRwdXRcIjticmVha31pZih0aGlzLm5hbWU9PVwibWFpblwiJiZuKXtyKz1cInN0cnVjdCBcIithK2Age1xcclxuYDtmb3IobGV0IGMgb2YgZS5sYXlvdXRzT3V0KWlmKGMubm9kZXNbMF1pbnN0YW5jZW9mIFRlKXtsZXQgZj1jLm5vZGVzWzBdO2MucXVhbGlmaWVyLnNpemU9PTEmJmMucXVhbGlmaWVyLmhhcyhcImxvY2F0aW9uXCIpJiYocis9XCIgIEBsb2NhdGlvbihcIitjLnF1YWxpZmllci5nZXQoXCJsb2NhdGlvblwiKStcIikgXCIpLHIrPWYubmFtZStcIjogXCIrU3QoZi50eXBlKStgLFxcclxuYCxlLmFkZElkZW50aWZpZXIoZi5uYW1lLFwic3RvdXQuXCIrZi5uYW1lKX1sZXQgdT1lLmJ1aWx0aW5PdXQ7Zm9yKGxldCBjIG9mIHUpcis9XCIgIFwiK2MrYCxcXHJcbmA7cis9YH07XFxyXG5cXHJcbmB9bGV0IGw9XCJcIjtpZih0aGlzLm5hbWU9PVwibWFpblwiJiYoZS53b3JrR3JvdXBTaXplIT1udWxsP2wrPVwiQFwiK2Uuc3RhZ2UrXCIgXCIrZS53b3JrR3JvdXBTaXplLmZvcm1hdFRvV0dTTChlLDApK2AgXFxyXG5gOmwrPVwiQFwiK2Uuc3RhZ2UrYFxcclxuYCksZT1uZXcgVW8oZSksbCs9cytcImZuIFwiK3RoaXMubmFtZStcIihcIix0aGlzLm5hbWUhPVwibWFpblwiKXtmb3IobGV0IHU9MDt1PHRoaXMuYXJncy5sZW5ndGg7dSsrKXtsZXQgYz10aGlzLmFyZ3NbdV07dT4wJiYobCs9XCIsIFwiKSxsKz1jLm5hbWUrXCI6IFwiK1N0KGMudHlwZSksZS5hZGRJZGVudGlmaWVyKGMubmFtZSxjLm5hbWUpfWwrPVwiKSAtPiBcIitTdCh0aGlzLnJldHVyblR5cGUpfWVsc2V7bGV0IHU9ZS5sYXlvdXRzSW47Zm9yKGxldCBmPTA7Zjx1Lmxlbmd0aDtmKyspe2xldCBkPXVbZl07aWYoZj4wP2wrPWAsXFxyXG4gICAgYDpsKz1gXFxyXG4gICAgYCxkLm5vZGVzWzBdaW5zdGFuY2VvZiBUZSl7bGV0IHA9ZC5ub2Rlc1swXTtkLnF1YWxpZmllci5zaXplPT0xJiZkLnF1YWxpZmllci5oYXMoXCJsb2NhdGlvblwiKSYmKGwrPVwiQGxvY2F0aW9uKFwiK2QucXVhbGlmaWVyLmdldChcImxvY2F0aW9uXCIpK1wiKSBcIiksbCs9cC5uYW1lK1wiOiBcIitTdChwLnR5cGUpLGUuYWRkSWRlbnRpZmllcihwLm5hbWUscC5uYW1lKX19dS5sZW5ndGg+MCYmKGwrPWAsXFxyXG4gICAgYCk7bGV0IGM9ZS5idWlsdGluSW47Zm9yKGxldCBmIG9mIGMpbCs9ZitgLFxcclxuICAgIGA7bj9sKz1cIikgLT4gXCIrYTpsKz1cIikgXCJ9bGV0IGg9XCJcIjt0aGlzLm5hbWU9PVwibWFpblwiJiZuJiYoaCs9XCIgICAgdmFyIHN0b3V0OiBcIithK2AgO1xcclxuYCk7Zm9yKGxldCB1IG9mIHRoaXMuYm9keS5ub2RlcyloKz11LmZvcm1hdFRvV0dTTChlLHQrMSksISh1IGluc3RhbmNlb2YgR2kpJiYhKHUgaW5zdGFuY2VvZiBYaSkmJiEodSBpbnN0YW5jZW9mIFlpKSYmKGgrPWA7XFxyXG5gKTtyZXR1cm4gdGhpcy5uYW1lPT1cIm1haW5cIiYmbiYmKGgrPWAgICAgcmV0dXJuIHN0b3V0O1xcclxuYCkscis9bCtgIHtcXHJcbmAscis9aCxyKz1zK2B9XFxyXG5gLHIrPWBcXHJcbmAscn19Y2xhc3MgeGEgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiYXJnc1wiLFtdKX1zdGF0aWMgcGFyc2UoZSl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5MRUZUU0FNTEwpe2Uuc2tpcFRva2VuKDEpO2xldCB0PW5ldyB4YTtmb3IoO2UucGVla1Rva2VuKDApLlR5cGUhPXguRU9GOyl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SSUdIVFNBTUxMKXtlLnNraXBUb2tlbigxKTticmVha31sZXQgcj1pZS5wYXJzZShlKTt0LmFyZ3MucHVzaChyKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LkNPTU1BJiZlLnNraXBUb2tlbigxKX1yZXR1cm4gdH10aHJvd1wiRXJyb3IgcGFyc2luZyBmdW5jdGlvbiBhcmd1bWVudCB0YWJsZTogVW5leHBlY3RlZCBjaGFyYWN0ZXJcIn19Y2xhc3MgSGkgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksbyh0aGlzLFwibmFtZVwiKSxvKHRoaXMsXCJhcmdzXCIpLHRoaXMubmFtZT1lLHRoaXMuYXJncz10fXN0YXRpYyBwYXJzZShlKXtpZihlLnBlZWtUb2tlbigwKS5pc0RhdGFUeXBlKCkmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguTEVGVFNBTUxMKXtsZXQgdD1lLnBlZWtUb2tlbigwKS5MaXRlcmFsO2Uuc2tpcFRva2VuKDEpO2xldCByPXhhLnBhcnNlKGUpO3JldHVybiBuZXcgSGkodCxyKX10aHJvd1wiRXJyb3IgcGFyc2luZyBmdW5jdGlvbiBhcmd1bWVudCB0YWJsZTogVW5leHBlY3RlZCBjaGFyYWN0ZXJcIn1mb3JtYXRUb1dHU0woZSx0KXtsZXQgcj1cIlwiLHM9dDw9MD9cIlwiOlwiICAgIFwiLnJlcGVhdCh0KTtpZih0aGlzLm5hbWU9PVwidGV4dHVyZVwiJiZ0aGlzLmFyZ3MuYXJnc1swXS5ub2Rlc1swXWluc3RhbmNlb2YgSGkpe2xldCBhPXRoaXMuYXJncy5hcmdzWzBdLm5vZGVzWzBdO2lmKGEubmFtZT09XCJzYW1wbGVyMkRcIil7cis9cytcInRleHR1cmVTYW1wbGUoXCI7Zm9yKGxldCBuPTA7bjxhLmFyZ3MuYXJncy5sZW5ndGg7bisrKXtsZXQgbD1hLmFyZ3MuYXJnc1tuXTtuPjAmJihyKz1cIiwgXCIpLHIrPWwuZm9ybWF0VG9XR1NMKGUsMCl9Zm9yKGxldCBuPTE7bjx0aGlzLmFyZ3MuYXJncy5sZW5ndGg7bisrKXtsZXQgbD10aGlzLmFyZ3MuYXJnc1tuXTtuPjAmJihyKz1cIiwgXCIpLHIrPWwuZm9ybWF0VG9XR1NMKGUsMCl9cmV0dXJuIHIrPVwiKVwiLHJ9fXIrPXMrU3QodGhpcy5uYW1lKStcIihcIjtmb3IobGV0IGE9MDthPHRoaXMuYXJncy5hcmdzLmxlbmd0aDthKyspe2xldCBuPXRoaXMuYXJncy5hcmdzW2FdO2E+MCYmKHIrPVwiLCBcIikscis9bi5mb3JtYXRUb1dHU0woZSwwKX1yZXR1cm4gcis9XCIpXCIscn19Y2xhc3MgVGUgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlLHQscj1uZXcgaWUpe3N1cGVyKCksbyh0aGlzLFwidHlwZVwiKSxvKHRoaXMsXCJuYW1lXCIpLG8odGhpcyxcImFycmF5U2l6ZVwiKSxvKHRoaXMsXCJoYXNJblwiKSxvKHRoaXMsXCJoYXNPdXRcIiksbyh0aGlzLFwiaGFzQ29uc3RcIiksdGhpcy50eXBlPWUsdGhpcy5uYW1lPXQsdGhpcy5oYXNJbj0hMSx0aGlzLmhhc091dD0hMSx0aGlzLmhhc0NvbnN0PSExLHRoaXMuYXJyYXlTaXplPXJ9c3RhdGljIHBhcnNlKGUpe2xldCB0PW5ldyBUZShcIlwiLFwiXCIpLHI9ZS5wZWVrVG9rZW4oMCk7aWYoci5UeXBlPT14LkNPTlNUKWUuc2tpcFRva2VuKDEpLHQuaGFzQ29uc3Q9ITA7ZWxzZSBpZihyLlR5cGU9PXguSU4pZS5za2lwVG9rZW4oMSksdC5oYXNJbj0hMDtlbHNlIGlmKHIuVHlwZT09eC5PVVQpZS5za2lwVG9rZW4oMSksdC5oYXNPdXQ9ITA7ZWxzZSBpZihyLlR5cGU9PXguSU5PVVQpZS5za2lwVG9rZW4oMSksdC5oYXNJbj0hMCx0Lmhhc091dD0hMDtlbHNlIGlmKCFyLmlzRGF0YVR5cGUoKSl0aHJvd1wiRXJyb3IgcGFyc2luZyBkZWNsYXJhdGlvbiBleHByZXNzaW9uOiBVbmV4cGVjdGVkIGNoYXJhY3RlcihcIityLkxpdGVyYWwrXCIpXCI7aWYocj1lLnBlZWtUb2tlbigwKSxyLmlzRGF0YVR5cGUoKSYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5MRUZUTUVESSl7aWYodC50eXBlPXIuTGl0ZXJhbCxlLnNraXBUb2tlbigyKSx0LmFycmF5U2l6ZT1pZS5wYXJzZShlKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LlJJR0hUTUVESSYmZS5za2lwVG9rZW4oMSksZS5wZWVrVG9rZW4oMCkuVHlwZSE9eC5JREVOVCl0aHJvd1wiVW5leHBlY3RlZFwiO3QubmFtZT1lLnBlZWtUb2tlbigwKS5MaXRlcmFsLGUuc2tpcFRva2VuKDEpfWVsc2UgaWYoci5pc0RhdGFUeXBlKCkmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguSURFTlQmJmUucGVla1Rva2VuKDIpLlR5cGU9PXguTEVGVE1FREkpdC50eXBlPWUucGVla1Rva2VuKDApLkxpdGVyYWwsdC5uYW1lPWUucGVla1Rva2VuKDEpLkxpdGVyYWwsZS5za2lwVG9rZW4oMyksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SSUdIVE1FREk/ZS5za2lwVG9rZW4oMSk6KHQuYXJyYXlTaXplPWllLnBhcnNlKGUpLGUucGVla1Rva2VuKDApLlR5cGU9PXguUklHSFRNRURJJiZlLnNraXBUb2tlbigxKSk7ZWxzZSBpZihyLmlzRGF0YVR5cGUoKSYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5JREVOVCl0LnR5cGU9ZS5wZWVrVG9rZW4oMCkuTGl0ZXJhbCx0Lm5hbWU9ZS5wZWVrVG9rZW4oMSkuTGl0ZXJhbCxlLnNraXBUb2tlbigyKTtlbHNlIHRocm93XCJFcnJvciBwYXJzaW5nIGRlY2xhcmF0aW9uIGV4cHJlc3Npb246IFVuZXhwZWN0ZWQgY2hhcmFjdGVyKFwiK3IuTGl0ZXJhbCtcIilcIjtpZihyPWUucGVla1Rva2VuKDApLHIuVHlwZT09eC5TRU1JQ09MT04pcmV0dXJuIGUuc2tpcFRva2VuKDEpLHQ7aWYoci5UeXBlPT14LlJJR0hUU0FNTEwpcmV0dXJuIHQ7aWYoci5UeXBlPT14LkFTU0lHTil7bGV0IHM9ZS5wZWVrVG9rZW4oMCk7ZS5za2lwVG9rZW4oMSk7bGV0IGE9bmV3IHJpKHQubmFtZSksbj1pZS5wYXJzZShlKTtyZXR1cm4gZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5TRU1JQ09MT04mJmUuc2tpcFRva2VuKDEpLHQuYWRkTm9kZShuZXcgQWkocyxhLG4pKSx0fWVsc2UgaWYoci5UeXBlPT14LkNPTU1BKXtmb3IoO2UucGVla1Rva2VuKDApLlR5cGU9PXguQ09NTUEmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguSURFTlQ7KXtsZXQgcz1uZXcgVGUodC50eXBlLGUucGVla1Rva2VuKDEpLkxpdGVyYWwpO3QuYWRkTm9kZShzKSxlLnNraXBUb2tlbigyKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LkFTU0lHTiYmKGUuc2tpcFRva2VuKC0xKSxzLmFkZE5vZGUoaWUucGFyc2UoZSkpKX1yZXR1cm4gdH10aHJvd1wiRXJyb3IgcGFyc2luZyBkZWNsYXJhdGlvbiBleHByZXNzaW9uOiBVbmV4cGVjdGVkIGNoYXJhY3RlcihcIitlLnBlZWtUb2tlbigwKS5MaXRlcmFsK1wiKVwifWZvcm1hdFRvV0dTTChlLHQpe2xldCByPVwiXCIscz10PD0wP1wiXCI6XCIgICAgXCIucmVwZWF0KHQpO2lmKHRoaXMuaGFzQ29uc3Q/cis9cytcImxldCBcIjpyKz1zK1widmFyIFwiLGUuYWRkSWRlbnRpZmllcih0aGlzLm5hbWUsdGhpcy5uYW1lKSx0aGlzLmFycmF5U2l6ZS5ub2Rlcy5sZW5ndGg8PTA/cis9dGhpcy5uYW1lK1wiOiBcIitTdCh0aGlzLnR5cGUpOnRoaXMuYXJyYXlTaXplLm5vZGVzWzBdaW5zdGFuY2VvZiBuaT9yKz10aGlzLm5hbWUrXCI6IGFycmF5PFwiK1N0KHRoaXMudHlwZSkrXCIsIFwiK3RoaXMuYXJyYXlTaXplLm5vZGVzWzBdLnZhbHVlK1wiPlwiOnIrPXRoaXMubmFtZStcIjogYXJyYXk8XCIrU3QodGhpcy50eXBlKStcIiwgXCIrdGhpcy5hcnJheVNpemUubm9kZXNbMF0uZm9ybWF0VG9XR1NMKGUsMCkrXCI+XCIsdGhpcy5ub2Rlcy5sZW5ndGg+MCYmdGhpcy5ub2Rlc1swXWluc3RhbmNlb2YgQWkpcis9XCIgPSBcIit0aGlzLm5vZGVzWzBdLnJpZ2h0VmFsdWUuZm9ybWF0VG9XR1NMKGUsMCk7ZWxzZSBpZih0aGlzLm5vZGVzLmxlbmd0aD4wJiZ0aGlzLm5vZGVzWzBdaW5zdGFuY2VvZiBpZSYmdGhpcy5ub2Rlc1swXS5ub2Rlc1swXWluc3RhbmNlb2YgQWkpcis9XCIgPSBcIit0aGlzLm5vZGVzWzBdLm5vZGVzWzBdLnJpZ2h0VmFsdWUuZm9ybWF0VG9XR1NMKGUsMCk7ZWxzZSBpZih0aGlzLm5vZGVzLmxlbmd0aD4wJiZ0aGlzLm5vZGVzWzBdaW5zdGFuY2VvZiBUZSl7cis9YDtcXHJcbmA7Zm9yKGxldCBhIG9mIHRoaXMubm9kZXMpcis9YS5mb3JtYXRUb1dHU0woZSx0KStgO1xcclxuYH1lbHNlIHIrPWA7XFxyXG5gO3JldHVybiByfX1jbGFzcyBZaSBleHRlbmRzIG1le2NvbnN0cnVjdG9yKGUsdCxyLHMpe3N1cGVyKCksbyh0aGlzLFwiZXhwcmVzc2lvbjFcIiksbyh0aGlzLFwiY29uZGl0aW9uXCIpLG8odGhpcyxcImV4cHJlc3Npb24yXCIpLG8odGhpcyxcImxvb3BCb2R5XCIpLHRoaXMuZXhwcmVzc2lvbjE9ZSx0aGlzLmNvbmRpdGlvbj10LHRoaXMuZXhwcmVzc2lvbjI9cix0aGlzLmxvb3BCb2R5PXN9c3RhdGljIHBhcnNlKGUpe2lmKGUucGVla1Rva2VuKDApLlR5cGU9PXguRk9SJiZlLnBlZWtUb2tlbigxKS5UeXBlPT14LkxFRlRTQU1MTCl7ZS5za2lwVG9rZW4oMik7bGV0IHQ7ZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5TRU1JQ09MT04/KGUuc2tpcFRva2VuKDEpLHQ9bmV3IGllKTplLnBlZWtUb2tlbigwKS5pc0RhdGFUeXBlKCkmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguSURFTlQmJmUucGVla1Rva2VuKDIpLlR5cGU9PXguQVNTSUdOPyh0PW5ldyBUZShlLnBlZWtUb2tlbigwKS5MaXRlcmFsLGUucGVla1Rva2VuKDEpLkxpdGVyYWwpLGUuc2tpcFRva2VuKDEpLHQuYWRkTm9kZShpZS5wYXJzZShlKSksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5TRU1JQ09MT04mJmUuc2tpcFRva2VuKDEpKToodD1pZS5wYXJzZShlKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LlNFTUlDT0xPTiYmZS5za2lwVG9rZW4oMSkpO2xldCByO2UucGVla1Rva2VuKDApLlR5cGU9PXguU0VNSUNPTE9OPyhlLnNraXBUb2tlbigxKSxyPW5ldyBpZSk6KHI9aWUucGFyc2UoZSksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5TRU1JQ09MT04mJmUuc2tpcFRva2VuKDEpKTtsZXQgcztlLnBlZWtUb2tlbigwKS5UeXBlPT14LlNFTUlDT0xPTj8oZS5za2lwVG9rZW4oMSkscz1uZXcgaWUpOihzPWllLnBhcnNlKGUpLGUucGVla1Rva2VuKDApLlR5cGU9PXguU0VNSUNPTE9OJiZlLnNraXBUb2tlbigxKSksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SSUdIVFNBTUxMJiZlLnNraXBUb2tlbigxKTtsZXQgYTtyZXR1cm4gZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5MRUZUQklHP2E9R3QucGFyc2UoZSk6YT1uZXcgR3QsbmV3IFlpKHQscixzLGEpfXRocm93XCJFcnJvciBwYXJzaW5nIGZvciBsb29wOiBVbmV4cGVjdGVkIGNoYXJhY3RlclwifWZvcm1hdFRvV0dTTChlLHQpe2xldCByPVwiXCIscz10PD0wP1wiXCI6XCIgICAgXCIucmVwZWF0KHQpO3IrPXMrXCJmb3IgKFwiLHIrPXRoaXMuZXhwcmVzc2lvbjEuZm9ybWF0VG9XR1NMKGUsMCkrXCI7IFwiLHIrPXRoaXMuY29uZGl0aW9uLmZvcm1hdFRvV0dTTChlLDApK1wiOyBcIixyKz10aGlzLmV4cHJlc3Npb24yLmZvcm1hdFRvV0dTTChlLDApK1wiKVwiLHIrPWAgeyBcXHJcbmA7Zm9yKGxldCBhIG9mIHRoaXMubG9vcEJvZHkubm9kZXMpcis9YS5mb3JtYXRUb1dHU0woZSx0KzEpLCEoYSBpbnN0YW5jZW9mIEdpKSYmIShhIGluc3RhbmNlb2YgWGkpJiYhKGEgaW5zdGFuY2VvZiBZaSkmJihyKz1gO1xcclxuYCk7cmV0dXJuIHIrPXMrYH0gXFxyXG5gLHJ9fWNsYXNzIFhpIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLG8odGhpcyxcImNvbmRpdGlvbkV4cHJcIiksbyh0aGlzLFwibG9vcEJvZHlcIiksdGhpcy5jb25kaXRpb25FeHByPWUsdGhpcy5sb29wQm9keT10fXN0YXRpYyBwYXJzZShlKXtpZihlLnBlZWtUb2tlbigwKS5UeXBlPT14LldISUxFKXtlLnNraXBUb2tlbigxKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LkxFRlRTQU1MTCYmZS5za2lwVG9rZW4oMSk7bGV0IHQ9aWUucGFyc2UoZSk7ZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SSUdIVFNBTUxMJiZlLnNraXBUb2tlbigxKTtsZXQgcj1HdC5wYXJzZShlKTtyZXR1cm4gbmV3IFhpKHQscil9dGhyb3dcIkVycm9yIHBhcnNpbmcgd2hpbGUgbG9vcDogVW5leHBlY3RlZCBjaGFyYWN0ZXJcIn1mb3JtYXRUb1dHU0woZSx0KXtsZXQgcj1cIlwiLHM9dDw9MD9cIlwiOlwiICAgIFwiLnJlcGVhdCh0KTtyKz1zK2Bsb29wIHtcXHJcbmAscis9cytcIiAgICBpZiAoXCIrdGhpcy5jb25kaXRpb25FeHByLmZvcm1hdFRvV0dTTChlLDApK2ApIHsgYnJlYWs7IH1cXHJcblxcclxuYDtmb3IobGV0IGEgb2YgdGhpcy5sb29wQm9keS5ub2RlcylyKz1hLmZvcm1hdFRvV0dTTChlLHQrMSksIShhIGluc3RhbmNlb2YgR2kpJiYhKGEgaW5zdGFuY2VvZiBYaSkmJiEoYSBpbnN0YW5jZW9mIFlpKSYmKHIrPWA7XFxyXG5gKTtyZXR1cm4gcis9cytgfVxcclxuYCxyfX1jbGFzcyBrZyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKX19Y2xhc3MgR2kgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlLHQscil7c3VwZXIoKSxvKHRoaXMsXCJjb25kaXRpb25FeHByXCIpLG8odGhpcyxcInRydWVCcmFuY2hcIiksbyh0aGlzLFwiZmFsc2VCcmFuY2hcIiksdGhpcy5jb25kaXRpb25FeHByPWUsdGhpcy50cnVlQnJhbmNoPXQsdGhpcy5mYWxzZUJyYW5jaD1yfXN0YXRpYyBwYXJzZShlKXtpZihlLnBlZWtUb2tlbigwKS5UeXBlPT14LklGKXtlLnNraXBUb2tlbigxKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LkxFRlRTQU1MTCYmZS5za2lwVG9rZW4oMSk7bGV0IHQ9aWUucGFyc2UoZSkscixzPW5ldyBHdDtpZihlLnBlZWtUb2tlbigwKS5UeXBlPT14LlJJR0hUU0FNTEwmJmUuc2tpcFRva2VuKDEpLGUucGVla1Rva2VuKDApLlR5cGU9PXguTEVGVEJJRz9yPUd0LnBhcnNlKGUpOihyPW5ldyBHdCxlLnBlZWtUb2tlbigwKS5UeXBlPT14LlJFVFVSTj9yLmFkZE5vZGUoX3MucGFyc2UoZSkpOnIuYWRkTm9kZShpZS5wYXJzZShlKSkpLGUucGVla1Rva2VuKDApLlR5cGU9PXguRUxTRSlpZihlLnNraXBUb2tlbigxKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LkxFRlRCSUcpcz1HdC5wYXJzZShlKTtlbHNlIHRocm93XCJub3QgaW1wbFwiO3JldHVybiBuZXcgR2kodCxyLHMpfXRocm93XCJFcnJvciBwYXJzaW5nIElGIGJyYW5jaCBzdGF0ZW1lbnQ6IFVuZXhwZWN0ZWQgY2hhcmFjdGVyXCJ9Zm9ybWF0VG9XR1NMKGUsdCl7bGV0IHI9XCJcIixzPXQ8PTA/XCJcIjpcIiAgICBcIi5yZXBlYXQodCk7cis9cytcImlmIChcIit0aGlzLmNvbmRpdGlvbkV4cHIuZm9ybWF0VG9XR1NMKGUsMCkrYCkge1xcclxuYDtmb3IobGV0IGEgb2YgdGhpcy50cnVlQnJhbmNoLm5vZGVzKXIrPWEuZm9ybWF0VG9XR1NMKGUsdCsxKStgO1xcclxuYDtpZih0aGlzLmZhbHNlQnJhbmNoLm5vZGVzLmxlbmd0aD4wKXtyKz1zK2B9IGVsc2Uge1xcclxuYDtmb3IobGV0IGEgb2YgdGhpcy5mYWxzZUJyYW5jaC5ub2RlcylyKz1hLmZvcm1hdFRvV0dTTChlLHQrMSkrYDtcXHJcbmB9cmV0dXJuIHIrPXMrYH1cXHJcbmAscn19Y2xhc3MgaWUgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9c3RhdGljIHBhcnNlKGUpe2xldCB0PW5ldyBBcnJheSxyPW5ldyBBcnJheSxzPTA7Zm9yKDtlLnBlZWtUb2tlbigwKS5UeXBlIT14LkVPRjspe2xldCBhPWUucGVla1Rva2VuKDApO2lmKGEuVHlwZT09eC5TRU1JQ09MT058fGEuVHlwZT09eC5SSUdIVE1FREl8fGEuVHlwZT09eC5DT01NQXx8YS5UeXBlPT14LkNPTE9OfHxhLlR5cGU9PXguUklHSFRCSUcpYnJlYWs7aWYoYS5pc09wZXJhdGlvbigpKXtpZihhLmlzT3BlcmF0aW9uKCkpe2lmKGEuVHlwZT09eC5JTkN8fGEuVHlwZT09eC5ERUMpe2xldCBuPWE7ZS5za2lwVG9rZW4oMSk7bGV0IGw9aWUucGFyc2UoZSk7ci5wdXNoKG5ldyBscihuLHZvaWQgMCxsKSk7Y29udGludWV9ZWxzZSBpZih0Lmxlbmd0aD4wKXtpZih0W3QubGVuZ3RoLTFdLm5PcGVyYXRpb25Qcmlvcml0eUxldmVsPD1hLm5PcGVyYXRpb25Qcmlvcml0eUxldmVsKWllLnVuaW9uT3BlcmF0aW9uKHQscik7ZWxzZSBpZih0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdLkxpdGVyYWw9PVwiLVwiKXtsZXQgbD10LnBvcCgpLGg9ci5wb3AoKTtyLnB1c2gobmV3IGxyKGwsdm9pZCAwLGgpKX19dC5wdXNoKGEpLGUuc2tpcFRva2VuKDEpfX1lbHNlIGlmKGEuVHlwZT09eC5MSVRFUkFMKXtyLnB1c2gobmV3IG5pKGEuTGl0ZXJhbCkpLGUuc2tpcFRva2VuKDEpO2NvbnRpbnVlfWVsc2UgaWYoYS5UeXBlPT14LkxFRlRTQU1MTCl7cysrLHQucHVzaChhKSxlLnNraXBUb2tlbigxKTtjb250aW51ZX1lbHNlIGlmKGEuVHlwZT09eC5SSUdIVFNBTUxMKXtpZihzPD0wKWJyZWFrO2ZvcihzLS07aWUudW5pb25PcGVyYXRpb24odCxyKTspO2lmKHRbdC5sZW5ndGgtMV0uVHlwZT09eC5MRUZUU0FNTEwpe3QucG9wKCk7bGV0IG49bmV3IF91O24uYWRkTm9kZShyLnBvcCgpKSxyLnB1c2gobil9ZS5za2lwVG9rZW4oMSk7Y29udGludWV9ZWxzZSBpZihhLlR5cGU9PXguSURFTlQpe2lmKGUucGVla1Rva2VuKDEpLlR5cGU9PXguSU5DfHxlLnBlZWtUb2tlbigxKS5UeXBlPT14LkRFQyl7bGV0IG49ZS5wZWVrVG9rZW4oMSksbD1uZXcgcmkoYS5MaXRlcmFsKTtyLnB1c2gobmV3IGxyKG4sbCx2b2lkIDApKSxlLnNraXBUb2tlbigyKTtjb250aW51ZX1lbHNlIGlmKGUucGVla1Rva2VuKDEpLlR5cGU9PXguTEVGVFNBTUxMKXtyLnB1c2goSGkucGFyc2UoZSkpO2NvbnRpbnVlfWVsc2UgaWYoZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5ET1Qpe3IucHVzaCh4cy5wYXJzZShlKSk7Y29udGludWV9ZWxzZSBpZihlLnBlZWtUb2tlbigxKS5UeXBlPT14LkxFRlRNRURJKXtyLnB1c2goV2kucGFyc2UoZSkpO2NvbnRpbnVlfXIucHVzaChuZXcgcmkoYS5MaXRlcmFsKSksZS5za2lwVG9rZW4oMSk7Y29udGludWV9ZWxzZXtpZihhLmlzQnVpbHRpblR5cGUoKSYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5MRUZUU0FNTEwpe3IucHVzaChIaS5wYXJzZShlKSk7Y29udGludWV9aWYoYS5pc0Fzc2lnbk9wZXJhdGlvbigpKXtsZXQgbj1hO2Uuc2tpcFRva2VuKDEpO2xldCBsPXIucG9wKCksaD1pZS5wYXJzZShlKTtyLnB1c2gobmV3IEFpKG4sbCxoKSk7Y29udGludWV9aWYoYS5UeXBlPT14LkxFRlRCSUcmJihlLnBlZWtUb2tlbigxKS5UeXBlPT14LkxJVEVSQUx8fGUucGVla1Rva2VuKDEpLlR5cGU9PXguU1VCJiZlLnBlZWtUb2tlbigyKS5UeXBlPT14LkxJVEVSQUwpKXtyLnB1c2goSXMucGFyc2UoZSkpO2NvbnRpbnVlfWlmKGEuVHlwZT09eC5RVUVNQVJLKXt0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdLm5PcGVyYXRpb25Qcmlvcml0eUxldmVsPD1hLm5PcGVyYXRpb25Qcmlvcml0eUxldmVsJiZpZS51bmlvbk9wZXJhdGlvbih0LHIpLGUuc2tpcFRva2VuKDEpO2xldCBuPXIucG9wKCksbD1pZS5wYXJzZShlKTtlLnBlZWtUb2tlbigwKS5UeXBlPT14LkNPTE9OJiZlLnNraXBUb2tlbigxKTtsZXQgaD1pZS5wYXJzZShlKTtpZihyLnB1c2gobmV3IHh1KG4sbCxoKSksZS5wZWVrVG9rZW4oLTEpLlR5cGU9PXguU0VNSUNPTE9OKWJyZWFrO2NvbnRpbnVlfWlmKGEuVHlwZT09eC5MRUZUTUVESSl7ZS5za2lwVG9rZW4oMSk7bGV0IG49aWUucGFyc2UoZSk7ZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SSUdIVE1FREkmJmUuc2tpcFRva2VuKDEpO2xldCBsPXIucG9wKCk7ci5wdXNoKG5ldyBXaShsLG4pKTtjb250aW51ZX10aHJvd1wiQW4gdW5leHBlY3RlZCBjaGFyYWN0ZXJcIn19Zm9yKDt0Lmxlbmd0aD4wJiZpZS51bmlvbk9wZXJhdGlvbih0LHIpOyk7aWYodC5sZW5ndGg8PTAmJnIubGVuZ3RoPT0xKXtsZXQgYT1uZXcgaWU7cmV0dXJuIGEuYWRkTm9kZShyLnBvcCgpKSxhfXRocm93XCJFcnJvciBwYXJzaW5nIGV4cHJlc3Npb246IFVuZXhwZWN0ZWQgY2hhcmFjdGVyKFwiK2UucGVla1Rva2VuKDApLkxpdGVyYWwrXCIpXCJ9Zm9ybWF0VG9XR1NMKGUsdCl7cmV0dXJuIHRoaXMubm9kZXNbMF0uZm9ybWF0VG9XR1NMKGUsdCl9c3RhdGljIHVuaW9uT3BlcmF0aW9uKGUsdCl7aWYoZS5sZW5ndGg8MHx8dC5sZW5ndGg8Mil7aWYoZS5sZW5ndGg+MCYmZVtlLmxlbmd0aC0xXS5MaXRlcmFsPT1cIi1cIil7bGV0IHI9ZS5wb3AoKSxzPXQucG9wKCk7cmV0dXJuIHQucHVzaChuZXcgbHIocix2b2lkIDAscykpLCEwfXJldHVybiExfWlmKGVbZS5sZW5ndGgtMV0uaXNPcGVyYXRpb24oKSl7bGV0IHI9dC5wb3AoKSxzPWUucG9wKCksYT10LnBvcCgpO3JldHVybiBzLlR5cGU9PXguRE9UP3QucHVzaChuZXcgeHMoYSxyKSk6dC5wdXNoKG5ldyBBaShzLGEscikpLCEwfXJldHVybiExfX1jbGFzcyBfdSBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1mb3JtYXRUb1dHU0woZSx0KXtyZXR1cm4odDw9MD9cIlwiOlwiICAgIFwiLnJlcGVhdCh0KSkrXCIoXCIrdGhpcy5ub2Rlc1swXS5mb3JtYXRUb1dHU0woZSwwKStcIilcIn19Y2xhc3MgcmkgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcIm5hbWVcIiksdGhpcy5uYW1lPWV9Zm9ybWF0VG9XR1NMKGUsdCl7cmV0dXJuKHQ8PTA/XCJcIjpcIiAgICBcIi5yZXBlYXQodCkpK2UuZmluZElkZW50aWZpZXIodGhpcy5uYW1lKX19Y2xhc3MgbmkgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcInZhbHVlXCIpLHRoaXMudmFsdWU9ZX1zdGF0aWMgcGFyc2UoZSl7bGV0IHQ9ZS5wZWVrVG9rZW4oMCk7aWYodC5UeXBlPT14LlNVQiYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5MSVRFUkFMKXtsZXQgcj1uZXcgbmkoXCItXCIrZS5wZWVrVG9rZW4oMSkuTGl0ZXJhbCk7cmV0dXJuIGUuc2tpcFRva2VuKDIpLHJ9ZWxzZSBpZih0LlR5cGU9PXguTElURVJBTCl7bGV0IHI9bmV3IG5pKHQuTGl0ZXJhbCk7cmV0dXJuIGUuc2tpcFRva2VuKDEpLHJ9dGhyb3dcIkVycm9yIHBhcnNpbmcgbGl0ZXJhbCBjb25zdGFudHM6IFVuZXhwZWN0ZWQgY2hhcmFjdGVycyhcIit0LkxpdGVyYWwrXCIpXCJ9Zm9ybWF0VG9XR1NMKGUsdCl7cmV0dXJuKHQ8PTA/XCJcIjpcIiAgICBcIi5yZXBlYXQodCkpK3RoaXMudmFsdWV9fWNsYXNzIElzIGV4dGVuZHMgbml7Y29uc3RydWN0b3IoZSl7c3VwZXIoXCJcIiksbyh0aGlzLFwiYXJyYXlWYWx1ZVwiKSx0aGlzLmFycmF5VmFsdWU9ZX1zdGF0aWMgcGFyc2UoZSl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5MRUZUQklHJiZlLnBlZWtUb2tlbigxKS5UeXBlPT14LkxJVEVSQUx8fGUucGVla1Rva2VuKDApLlR5cGU9PXguTEVGVEJJRyYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5TVUImJmUucGVla1Rva2VuKDIpLlR5cGU9PXguTElURVJBTCl7ZS5za2lwVG9rZW4oMSk7bGV0IHQ9W107Zm9yKDtlLnBlZWtUb2tlbigwKS5UeXBlIT14LlJJR0hUQklHOyl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5MRUZUU0FNTEwpe3QucHVzaChJcy5wYXJzZShlKSk7Y29udGludWV9aWYodC5wdXNoKG5pLnBhcnNlKGUpKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LkNPTU1BKXtlLnNraXBUb2tlbigxKTtjb250aW51ZX1lbHNlIGlmKGUucGVla1Rva2VuKDApLlR5cGU9PXguUklHSFRCSUcpe2Uuc2tpcFRva2VuKDEpO2JyZWFrfWVsc2UgdGhyb3dcIkVycm9yIHBhcnNpbmcgYXJyYXkgY29uc3RhbnRzOiBVbmV4cGVjdGVkIGNoYXJhY3RlcnNcIn1yZXR1cm4gbmV3IElzKHQpfXRocm93XCJFcnJvciBwYXJzaW5nIGFycmF5IGNvbnN0YW50czogVW5leHBlY3RlZCBjaGFyYWN0ZXJzXCJ9Zm9ybWF0VG9XR1NMKGUsdCl7bGV0IHI9XCJcIixzPXQ8PTA/XCJcIjpcIiAgICBcIi5yZXBlYXQodCk7dGhpcy5hcnJheVZhbHVlWzBdLnZhbHVlLmluY2x1ZGVzKFwiLlwiKT9yKz1zK1wiYXJyYXk8ZjMyLCBcIit0aGlzLmFycmF5VmFsdWUubGVuZ3RoLnRvU3RyaW5nKCkrXCI+KFwiOnIrPXMrXCJhcnJheTxpMzIsIFwiK3RoaXMuYXJyYXlWYWx1ZS5sZW5ndGgudG9TdHJpbmcoKStcIj4oXCI7Zm9yKGxldCBhPTA7YTx0aGlzLmFycmF5VmFsdWUubGVuZ3RoO2ErKylhPjAmJihyKz1cIiwgXCIpLHIrPXRoaXMuYXJyYXlWYWx1ZVthXS5mb3JtYXRUb1dHU0woZSwwKTtyZXR1cm4gcis9XCIpXCIscn19Y2xhc3MgemcgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9fWNsYXNzIEdnIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpfX1jbGFzcyB2YSBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1zdGF0aWMgcGFyc2UoZSl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5DT05USU5VRSYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5TRU1JQ09MT04pcmV0dXJuIGUuc2tpcFRva2VuKDIpLG5ldyB2YTt0aHJvd1wiRXJyb3IgcGFyc2luZyBjb250aW51ZTogVW5leHBlY3RlZCBjaGFyYWN0ZXJcIn1mb3JtYXRUb1dHU0woZSx0KXtsZXQgcj1cIlwiLHM9dDw9MD9cIlwiOlwiICAgIFwiLnJlcGVhdCh0KTtyZXR1cm4gcis9cytcImNvbnRpbnVlXCIscn19Y2xhc3MgX3MgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcInZhbHVlXCIpLHRoaXMudmFsdWU9ZX1zdGF0aWMgcGFyc2UoZSl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SRVRVUk4pe2Uuc2tpcFRva2VuKDEpO2xldCB0PWllLnBhcnNlKGUpO3JldHVybiBlLnBlZWtUb2tlbigwKS5UeXBlPT14LlNFTUlDT0xPTiYmZS5za2lwVG9rZW4oMSksbmV3IF9zKHQpfXRocm93XCJFcnJvciBwYXJzaW5nIHJldHVybiBleHByZXNzaW9uOiBVbmV4cGVjdGVkIGNoYXJhY3RlclwifWZvcm1hdFRvV0dTTChlLHQpe2xldCByPVwiXCIscz10PD0wP1wiXCI6XCIgICAgXCIucmVwZWF0KHQpO3JldHVybiByKz1zK1wicmV0dXJuIFwiK3RoaXMudmFsdWUuZm9ybWF0VG9XR1NMKGUsMCkscn19Y2xhc3MgbHIgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlLHQscil7c3VwZXIoKSxvKHRoaXMsXCJvcFwiKSxvKHRoaXMsXCJsZWZ0VmFsdWVcIiksbyh0aGlzLFwicmlnaHRWYWx1ZVwiKSx0aGlzLm9wPWUsdGhpcy5sZWZ0VmFsdWU9dCx0aGlzLnJpZ2h0VmFsdWU9cn1mb3JtYXRUb1dHU0woZSx0KXtsZXQgcj1cIlwiLHM9dDw9MD9cIlwiOlwiICAgIFwiLnJlcGVhdCh0KTtpZih0aGlzLm9wLkxpdGVyYWw9PVwiKytcInx8dGhpcy5vcC5MaXRlcmFsPT1cIi0tXCIpaWYodGhpcy5sZWZ0VmFsdWUhPW51bGwpe2xldCBhPXRoaXMubGVmdFZhbHVlLmZvcm1hdFRvV0dTTChlLDApO3IrPXMrYStcIiA9IFwiK2ErXCIgXCIrdGhpcy5vcC5MaXRlcmFsWzBdK1wiIDFcIn1lbHNle2xldCBhPXRoaXMucmlnaHRWYWx1ZS5mb3JtYXRUb1dHU0woZSwwKTtyKz1zK2ErXCIgPSBcIithK1wiIFwiK3RoaXMub3AuTGl0ZXJhbFswXStcIiAxXCJ9ZWxzZSB0aGlzLmxlZnRWYWx1ZSE9bnVsbD9yKz1zK3RoaXMubGVmdFZhbHVlLmZvcm1hdFRvV0dTTChlLDApK3RoaXMub3AuTGl0ZXJhbDpyKz1zK3RoaXMub3AuTGl0ZXJhbCt0aGlzLnJpZ2h0VmFsdWUuZm9ybWF0VG9XR1NMKGUsMCk7cmV0dXJuIHJ9fWNsYXNzIEFpIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKCksbyh0aGlzLFwib3BcIiksbyh0aGlzLFwibGVmdFZhbHVlXCIpLG8odGhpcyxcInJpZ2h0VmFsdWVcIiksdGhpcy5vcD1lLHRoaXMubGVmdFZhbHVlPXQsdGhpcy5yaWdodFZhbHVlPXJ9Zm9ybWF0VG9XR1NMKGUsdCl7bGV0IHI9XCJcIixzPXQ8PTA/XCJcIjpcIiAgICBcIi5yZXBlYXQodCk7cmV0dXJuIHIrPXMrdGhpcy5sZWZ0VmFsdWUuZm9ybWF0VG9XR1NMKGUsMCkrXCIgXCIrdGhpcy5vcC5MaXRlcmFsK1wiIFwiK3RoaXMucmlnaHRWYWx1ZS5mb3JtYXRUb1dHU0woZSwwKSxyfX1jbGFzcyB4dSBleHRlbmRzIG1le2NvbnN0cnVjdG9yKGUsdCxyKXtzdXBlcigpLG8odGhpcyxcImNvbmRpdGlvblwiKSxvKHRoaXMsXCJleHByZXNzaW9uMVwiKSxvKHRoaXMsXCJleHByZXNzaW9uMlwiKSx0aGlzLmNvbmRpdGlvbj1lLHRoaXMuZXhwcmVzc2lvbjE9dCx0aGlzLmV4cHJlc3Npb24yPXJ9c3RhdGljIHBhcnNlKGUpe3Rocm93XCJFcnJvciBwYXJzaW5nIHRlcm5hcnkgb3BlcmF0aW9uIGV4cHJlc3Npb246IFVuZXhwZWN0ZWQgY2hhcmFjdGVyXCJ9Zm9ybWF0VG9XR1NMKGUsdCl7cmV0dXJuXCJcIn19Y2xhc3MgeHMgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksbyh0aGlzLFwibGVmdFZhbHVlXCIpLG8odGhpcyxcInJpZ2h0VmFsdWVcIiksdGhpcy5sZWZ0VmFsdWU9ZSx0aGlzLnJpZ2h0VmFsdWU9dH1zdGF0aWMgcGFyc2UoZSl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5JREVOVCYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5ET1QmJmUucGVla1Rva2VuKDIpLlR5cGU9PXguSURFTlQpe2xldCB0PW5ldyByaShlLnBlZWtUb2tlbigwKS5MaXRlcmFsKSxyPW5ldyByaShlLnBlZWtUb2tlbigyKS5MaXRlcmFsKTtyZXR1cm4gZS5za2lwVG9rZW4oMyksbmV3IHhzKHQscil9dGhyb3dcIkVycm9yIHBhcnNpbmcgc2VsZWN0aW9uIGV4cHJlc3Npb246IFVuZXhwZWN0ZWQgY2hhcmFjdGVyXCJ9Zm9ybWF0VG9XR1NMKGUsdCl7cmV0dXJuKHQ8PTA/XCJcIjpcIiAgICBcIi5yZXBlYXQodCkpK3RoaXMubGVmdFZhbHVlLmZvcm1hdFRvV0dTTChlLDApK1wiLlwiK3RoaXMucmlnaHRWYWx1ZS5mb3JtYXRUb1dHU0woZSwwKX19Y2xhc3MgV2kgZXh0ZW5kcyBtZXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksbyh0aGlzLFwibGVmdFZhbHVlXCIpLG8odGhpcyxcImluZGV4VmFsdWVcIiksdGhpcy5sZWZ0VmFsdWU9ZSx0aGlzLmluZGV4VmFsdWU9dH1zdGF0aWMgcGFyc2UoZSl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5JREVOVCYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5MRUZUTUVESSl7bGV0IHQ9bmV3IHJpKGUucGVla1Rva2VuKDApLkxpdGVyYWwpO2Uuc2tpcFRva2VuKDIpO2xldCByPWllLnBhcnNlKGUpO2UucGVla1Rva2VuKDApLlR5cGU9PXguUklHSFRNRURJJiZlLnNraXBUb2tlbigxKTtsZXQgcz1uZXcgV2kodCxyKTtmb3IoO2UucGVla1Rva2VuKDApLlR5cGU9PXguTEVGVE1FREk7KWUuc2tpcFRva2VuKDEpLHI9aWUucGFyc2UoZSksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5SSUdIVE1FREkmJmUuc2tpcFRva2VuKDEpLHM9bmV3IFdpKHMscik7cmV0dXJuIHN9dGhyb3dcIkVycm9yIHBhcnNpbmcgaW5kZXggZXhwcmVzc2lvbjogVW5leHBlY3RlZCBjaGFyYWN0ZXJcIn1mb3JtYXRUb1dHU0woZSx0KXtyZXR1cm4odDw9MD9cIlwiOlwiICAgIFwiLnJlcGVhdCh0KSkrdGhpcy5sZWZ0VmFsdWUuZm9ybWF0VG9XR1NMKGUsMCkrXCJbXCIrdGhpcy5pbmRleFZhbHVlLmZvcm1hdFRvV0dTTChlLDApK1wiXVwifX1jbGFzcyBHdCBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1zdGF0aWMgcGFyc2UoZSl7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5MRUZUQklHKXtlLnNraXBUb2tlbigxKTtsZXQgdD1uZXcgR3Q7Zm9yKGxldCByPTE7cj4wJiZlLnBlZWtUb2tlbigwKS5UeXBlIT14LkVPRjspe2xldCBzPWUucGVla1Rva2VuKDApO2lmKHMuVHlwZT09eC5MRUZUQklHKXtyKyssZS5za2lwVG9rZW4oMSk7Y29udGludWV9aWYocy5UeXBlPT14LlJJR0hUQklHKXtyLS0sZS5za2lwVG9rZW4oMSk7Y29udGludWV9aWYocy5UeXBlPT14LlNFTUlDT0xPTil7ZS5za2lwVG9rZW4oMSk7Y29udGludWV9aWYocy5pc0RhdGFUeXBlKCkmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguSURFTlQpe3QuYWRkTm9kZShUZS5wYXJzZShlKSk7Y29udGludWV9aWYocy5UeXBlPT14LkNPTlNUJiZlLnBlZWtUb2tlbigxKS5pc0RhdGFUeXBlKCkmJmUucGVla1Rva2VuKDIpLlR5cGU9PXguSURFTlQpe3QuYWRkTm9kZShUZS5wYXJzZShlKSk7Y29udGludWV9ZWxzZSBpZihzLlR5cGU9PXguSURFTlQmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguQVNTSUdOKXt0LmFkZE5vZGUoaWUucGFyc2UoZSkpLGUucGVla1Rva2VuKDApLlR5cGU9PXguU0VNSUNPTE9OJiZlLnNraXBUb2tlbigxKTtjb250aW51ZX1lbHNlIGlmKHMuVHlwZT09eC5JREVOVCYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5MRUZUTUVESSl7bGV0IGE9V2kucGFyc2UoZSk7aWYoZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5BU1NJR04pe2xldCBuPWUucGVla1Rva2VuKDApO2Uuc2tpcFRva2VuKDEpO2xldCBsPWllLnBhcnNlKGUpO2UucGVla1Rva2VuKDApLlR5cGU9PXguUklHSFRNRURJJiZlLnNraXBUb2tlbigxKSx0LmFkZE5vZGUobmV3IEFpKG4sYSxsKSk7Y29udGludWV9dC5hZGROb2RlKGEpO2NvbnRpbnVlfWVsc2UgaWYocy5UeXBlPT14LklERU5UJiZlLnBlZWtUb2tlbigxKS5UeXBlPT14LkRPVCl7bGV0IGE9aWUucGFyc2UoZSk7dC5hZGROb2RlKGEpO2NvbnRpbnVlfWVsc2UgaWYocy5UeXBlPT14LklERU5UJiZlLnBlZWtUb2tlbigxKS5pc0Fzc2lnbk9wZXJhdGlvbigpKXtsZXQgYT1lLnBlZWtUb2tlbigxKSxuPW5ldyByaShzLkxpdGVyYWwpO2Uuc2tpcFRva2VuKDIpO2xldCBsPWllLnBhcnNlKGUpO2UucGVla1Rva2VuKDApLlR5cGU9PXguU0VNSUNPTE9OJiZlLnNraXBUb2tlbigxKSx0LmFkZE5vZGUobmV3IEFpKGEsbixsKSk7Y29udGludWV9ZWxzZSBpZihzLlR5cGU9PXguSURFTlQmJihlLnBlZWtUb2tlbigxKS5UeXBlPT14LklOQ3x8ZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5ERUMpJiZlLnBlZWtUb2tlbigyKS5UeXBlPT14LlNFTUlDT0xPTil7bGV0IGE9ZS5wZWVrVG9rZW4oMSk7dC5hZGROb2RlKG5ldyBscihhLG5ldyByaShzLkxpdGVyYWwpLHZvaWQgMCkpLGUuc2tpcFRva2VuKDMpO2NvbnRpbnVlfWVsc2UgaWYocy5UeXBlPT14LlJFVFVSTil7dC5hZGROb2RlKF9zLnBhcnNlKGUpKTtjb250aW51ZX1lbHNlIGlmKHMuVHlwZT09eC5DT05USU5VRSl7dC5hZGROb2RlKHZhLnBhcnNlKGUpKTtjb250aW51ZX1lbHNlIGlmKHMuVHlwZT09eC5XSElMRSl7dC5hZGROb2RlKFhpLnBhcnNlKGUpKTtjb250aW51ZX1lbHNlIGlmKHMuVHlwZT09eC5GT1Ipe3QuYWRkTm9kZShZaS5wYXJzZShlKSk7Y29udGludWV9ZWxzZSBpZihzLlR5cGU9PXguSUYpe3QuYWRkTm9kZShHaS5wYXJzZShlKSk7Y29udGludWV9ZWxzZSBpZihzLlR5cGU9PXguSURFTlQmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguTEVGVFNBTUxMKXt0LmFkZE5vZGUoSGkucGFyc2UoZSkpLGUucGVla1Rva2VuKDApLlR5cGU9PXguU0VNSUNPTE9OJiZlLnNraXBUb2tlbigwKTtjb250aW51ZX10aHJvd1wiRXJyb3IgcGFyc2luZyBibG9jazogVW5leHBlY3RlZCBzeW1ib2woXCIrcy5MaXRlcmFsK1wiKVwifXJldHVybiB0fXRocm93XCJFcnJvciBwYXJzaW5nIGJsb2NrOiBVbmV4cGVjdGVkIHN5bWJvbFwifX1jbGFzcyB5YSBleHRlbmRzIG1le2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSxvKHRoaXMsXCJ0eXBlXCIpLG8odGhpcyxcInF1YWxpZmllclwiKSx0aGlzLnR5cGU9dCx0aGlzLnF1YWxpZmllcj1lfXN0YXRpYyBwYXJzZShlKXtpZihlLnBlZWtUb2tlbigwKS5UeXBlPT14LlBSRUNJU0lPTiYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5JREVOVCYmZS5wZWVrVG9rZW4oMikuaXNCdWlsdGluVHlwZSgpKXtsZXQgdD1uZXcgeWEoZS5wZWVrVG9rZW4oMSkuTGl0ZXJhbCxlLnBlZWtUb2tlbigyKS5MaXRlcmFsKTtyZXR1cm4gZS5za2lwVG9rZW4oMyksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5TRU1JQ09MT04mJmUuc2tpcFRva2VuKDEpLHR9dGhyb3dcIkVycm9yIHBhcnNpbmcgcHJlY2lzaW9uIHF1YWxpZmllcjogVW5leHBlY3RlZCBjaGFyYWN0ZXJcIn1mb3JtYXRUb1dHU0woZSx0KXtyZXR1cm5cIlwifX1jbGFzcyB2cyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJzY29wZVwiLFwiXCIpLG8odGhpcyxcInF1YWxpZmllclwiLG5ldyBNYXApfWFkZFF1YWxpZmllcihlLHQ9XCJcIil7dGhpcy5xdWFsaWZpZXIuc2V0KGUsdCl9c3RhdGljIHBhcnNlKGUpe2lmKGUucGVla1Rva2VuKDApLlR5cGU9PXguTEFZT1VUJiZlLnBlZWtUb2tlbigxKS5UeXBlPT14LkxFRlRTQU1MTCl7bGV0IHQ9bmV3IHZzO2Uuc2tpcFRva2VuKDIpO2RvIGlmKGUucGVla1Rva2VuKDApLlR5cGU9PXguSURFTlQpe2lmKGUucGVla1Rva2VuKDEpLlR5cGU9PXguQVNTSUdOJiZlLnBlZWtUb2tlbigyKS5UeXBlPT14LkxJVEVSQUwpe2xldCBzPWUucGVla1Rva2VuKDApLkxpdGVyYWwsYT1lLnBlZWtUb2tlbigyKS5MaXRlcmFsO2lmKHQuYWRkUXVhbGlmaWVyKHMsYSksZS5za2lwVG9rZW4oMyksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5DT01NQSl7ZS5za2lwVG9rZW4oMSk7Y29udGludWV9bGV0IG49ZS5wZWVrVG9rZW4oMCk7bi5MaW5lPTB9ZWxzZSBpZihlLnBlZWtUb2tlbigxKS5UeXBlPT14LlJJR0hUU0FNTEwpe2xldCBzPWUucGVla1Rva2VuKDApLkxpdGVyYWw7dC5hZGRRdWFsaWZpZXIocyxcIlwiKSxlLnNraXBUb2tlbigxKTticmVha31lbHNlIGlmKGUucGVla1Rva2VuKDEpLlR5cGU9PXguQ09NTUEpe2xldCBzPWUucGVla1Rva2VuKDApLkxpdGVyYWw7dC5hZGRRdWFsaWZpZXIocyxcIlwiKSxlLnNraXBUb2tlbigyKTtjb250aW51ZX19d2hpbGUoZS5wZWVrVG9rZW4oMCkuVHlwZSE9eC5SSUdIVFNBTUxMKTtpZihlLnBlZWtUb2tlbigwKS5UeXBlPT14LlJJR0hUU0FNTEwmJmUuc2tpcFRva2VuKDEpLHQuc2NvcGU9ZS5wZWVrVG9rZW4oMCkuTGl0ZXJhbCxlLnNraXBUb2tlbigxKSxlLnBlZWtUb2tlbigwKS5UeXBlPT14LlNFTUlDT0xPTilyZXR1cm4gZS5za2lwVG9rZW4oMSksdDtpZihlLnBlZWtUb2tlbigwKS5pc0J1aWx0aW5UeXBlKCkmJmUucGVla1Rva2VuKDEpLlR5cGU9PXguSURFTlQmJmUucGVla1Rva2VuKDIpLlR5cGU9PXguU0VNSUNPTE9OKXtsZXQgcj1uZXcgVGUoZS5wZWVrVG9rZW4oMCkuTGl0ZXJhbCxlLnBlZWtUb2tlbigxKS5MaXRlcmFsKTtyZXR1cm4gdC5hZGROb2RlKHIpLGUuc2tpcFRva2VuKDMpLHR9ZWxzZSBpZihlLnBlZWtUb2tlbigwKS5UeXBlPT14LklERU5UJiZlLnBlZWtUb2tlbigxKS5UeXBlPT14LkxFRlRCSUcpe2xldCByPW9pLnBhcnNlKGUpO3JldHVybiB0LmFkZE5vZGUociksZS5wZWVrVG9rZW4oMCkuVHlwZT09eC5JREVOVCYmZS5wZWVrVG9rZW4oMSkuVHlwZT09eC5TRU1JQ09MT04mJihyLmFkZE5vZGUobmV3IFRlKHIubmFtZSxlLnBlZWtUb2tlbigwKS5MaXRlcmFsKSksZS5za2lwVG9rZW4oMikpLHR9ZWxzZSB0aHJvd1wiRXJyb3IgcGFyc2luZyBsYXlvdXQgcXVhbGlmaWVyIHR5cGU6IFVuZXhwZWN0ZWQgc3ltYm9sKFwiK2UucGVla1Rva2VuKDApLkxpdGVyYWwrXCIpXCJ9dGhyb3dcIkVycm9yIHBhcnNpbmcgbGF5b3V0IHF1YWxpZmllcjogVW5leHBlY3RlZCBzeW1ib2xcIn1mb3JtYXRUb1dHU0woZSx0KXtsZXQgcj1cIlwiO2lmKHRoaXMucXVhbGlmaWVyLnNpemU9PTEmJnRoaXMucXVhbGlmaWVyLmhhcyhcImxvY2F0aW9uXCIpKXIrPVwiQGxvY2F0aW9uKFwiK3RoaXMucXVhbGlmaWVyLmdldChcImxvY2F0aW9uXCIpK1wiKSBcIjtlbHNlIGlmKHRoaXMucXVhbGlmaWVyLnNpemU9PTImJnRoaXMucXVhbGlmaWVyLmhhcyhcInNldFwiKSYmdGhpcy5xdWFsaWZpZXIuaGFzKFwiYmluZGluZ1wiKSlyKz1cIkBncm91cChcIit0aGlzLnF1YWxpZmllci5nZXQoXCJzZXRcIikrXCIpIEBiaW5kaW5nKFwiK3RoaXMucXVhbGlmaWVyLmdldChcImJpbmRpbmdcIikrXCIpIFwiO2Vsc2UgaWYodGhpcy5xdWFsaWZpZXIuc2l6ZT49MSYmdGhpcy5xdWFsaWZpZXIuaGFzKFwiYmluZGluZ1wiKSlyKz1cIkBncm91cCgwKSBAYmluZGluZyhcIit0aGlzLnF1YWxpZmllci5nZXQoXCJiaW5kaW5nXCIpK1wiKSBcIjtlbHNlIGlmKHRoaXMucXVhbGlmaWVyLnNpemU9PTEmJnRoaXMucXVhbGlmaWVyLmhhcyhcInB1c2hfY29uc3RhbnRcIikpcis9XCJAcHVzaF9jb25zdGFudCBcIjtlbHNlIGlmKHRoaXMucXVhbGlmaWVyLnNpemU+PTEmJnRoaXMucXVhbGlmaWVyLmhhcyhcImxvY2FsX3NpemVfeFwiKSlyKz1cIkB3b3JrZ3JvdXBfc2l6ZShcIixyKz10aGlzLnF1YWxpZmllci5nZXQoXCJsb2NhbF9zaXplX3hcIikrXCIsIFwiLHIrPXRoaXMucXVhbGlmaWVyLmhhcyhcImxvY2FsX3NpemVfeVwiKT90aGlzLnF1YWxpZmllci5nZXQoXCJsb2NhbF9zaXplX3lcIikrXCIsIFwiOlwiMSwgXCIscis9dGhpcy5xdWFsaWZpZXIuaGFzKFwibG9jYWxfc2l6ZV96XCIpP3RoaXMucXVhbGlmaWVyLmdldChcImxvY2FsX3NpemVfelwiKStcIlwiOlwiMVwiLHIrPVwiKVwiO2Vsc2UgaWYodGhpcy5ub2Rlcy5sZW5ndGg8PTApcmV0dXJuXCJcIjtsZXQgcz10aGlzLm5vZGVzWzBdO2lmKHMgaW5zdGFuY2VvZiBUZSl7c3dpdGNoKHMudHlwZSl7Y2FzZVwic2FtcGxlclwiOmNhc2VcInRleHR1cmUyRFwiOnIrPVwidmFyIFwiO2JyZWFrO2RlZmF1bHQ6dGhpcy5zY29wZT09XCJidWZmZXJcIj9lLnN0YWdlPT1cImNvbXB1dGVcIj9yKz1cInZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBcIjpyKz1cInZhcjxzdG9yYWdlLCByZWFkPiBcIjpyKz1cInZhcjxcIit0aGlzLnNjb3BlK1wiPiBcIjticmVha31lLmFkZElkZW50aWZpZXIocy5uYW1lLHMubmFtZSkscis9cy5uYW1lK1wiOiBcIitTdChzLnR5cGUpK2A7XFxyXG5gfWVsc2UgaWYocyBpbnN0YW5jZW9mIG9pKXtpZih0aGlzLnNjb3BlPT1cImJ1ZmZlclwiP2Uuc3RhZ2U9PVwiY29tcHV0ZVwiP3IrPVwidmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IFwiOnIrPVwidmFyPHN0b3JhZ2UsIHJlYWQ+IFwiOnIrPVwidmFyPFwiK3RoaXMuc2NvcGUrXCI+IFwiLHMubm9kZXMubGVuZ3RoPD0wKXtsZXQgYT1cInVuaWZcIitlLmxheW91dFVuaWZvcm1Db3VudC50b1N0cmluZygpO2Zvcig7ZS5oYXNJZGVudGlmaWVyKGEpOyllLmxheW91dFVuaWZvcm1Db3VudCsrLGE9XCJ1bmlmXCIrZS5sYXlvdXRVbmlmb3JtQ291bnQudG9TdHJpbmcoKTtmb3IobGV0IG4gb2Ygcy5maWVsZHMpZS5hZGRJZGVudGlmaWVyKG4ubmFtZSxhK1wiLlwiK24ubmFtZSk7cis9YStcIjogXCIrcy5uYW1lK2A7XFxyXG5gLGUubGF5b3V0VW5pZm9ybUNvdW50Kyt9ZWxzZXtsZXQgYT1zLm5vZGVzWzBdO3IrPWEubmFtZStcIjogXCIrYS50eXBlK2A7XFxyXG5gfXJldHVybiByfXJldHVybiByfX1mdW5jdGlvbiBTdChpKXtzd2l0Y2goaSl7Y2FzZVwiaW50XCI6cmV0dXJuXCJpMzJcIjtjYXNlXCJpbnRbXVwiOnJldHVyblwiYXJyYXk8aTMyPlwiO2Nhc2VcInVpbnRcIjpyZXR1cm5cInUzMlwiO2Nhc2VcInVpbnRbXVwiOnJldHVyblwiYXJyYXk8dTMyPlwiO2Nhc2VcImZsb2F0XCI6cmV0dXJuXCJmMzJcIjtjYXNlXCJmbG9hdFtdXCI6cmV0dXJuXCJhcnJheTxmMzI+XCI7Y2FzZVwidmVjMlwiOnJldHVyblwidmVjMjxmMzI+XCI7Y2FzZVwidmVjM1wiOnJldHVyblwidmVjMzxmMzI+XCI7Y2FzZVwidmVjNFwiOnJldHVyblwidmVjNDxmMzI+XCI7Y2FzZVwidmVjMltdXCI6cmV0dXJuXCJhcnJheTx2ZWMyPGYzMj4+XCI7Y2FzZVwidmVjM1tdXCI6cmV0dXJuXCJhcnJheTx2ZWMzPGYzMj4+XCI7Y2FzZVwidmVjNFtdXCI6cmV0dXJuXCJhcnJheTx2ZWM0PGYzMj4+XCI7Y2FzZVwiaXZlYzJcIjpyZXR1cm5cInZlYzI8aTMyPlwiO2Nhc2VcIml2ZWMzXCI6cmV0dXJuXCJ2ZWMzPGkzMj5cIjtjYXNlXCJpdmVjNFwiOnJldHVyblwidmVjNDxpMzI+XCI7Y2FzZVwiaXZlYzJbXVwiOnJldHVyblwiYXJyYXk8dmVjMjxpMzI+PlwiO2Nhc2VcIml2ZWMzW11cIjpyZXR1cm5cImFycmF5PHZlYzM8aTMyPj5cIjtjYXNlXCJpdmVjNFtdXCI6cmV0dXJuXCJhcnJheTx2ZWM0PGkzMj4+XCI7Y2FzZVwibWF0MlwiOnJldHVyblwibWF0MngyPGYzMj5cIjtjYXNlXCJtYXQyeDJcIjpyZXR1cm5cIm1hdDJ4MjxmMzI+XCI7Y2FzZVwibWF0MngzXCI6cmV0dXJuXCJtYXQyeDM8ZjMyPlwiO2Nhc2VcIm1hdDJ4NFwiOnJldHVyblwibWF0Mng0PGYzMj5cIjtjYXNlXCJtYXQyW11cIjpyZXR1cm5cImFycmF5PG1hdDJ4MjxmMzI+PlwiO2Nhc2VcIm1hdDJ4MltdXCI6cmV0dXJuXCJhcnJheTxtYXQyeDI8ZjMyPj5cIjtjYXNlXCJtYXQyeDNbXVwiOnJldHVyblwiYXJyYXk8bWF0MngzPGYzMj4+XCI7Y2FzZVwibWF0Mng0W11cIjpyZXR1cm5cImFycmF5PG1hdDJ4NDxmMzI+PlwiO2Nhc2VcIm1hdDNcIjpyZXR1cm5cIm1hdDN4MzxmMzI+XCI7Y2FzZVwibWF0M3gyXCI6cmV0dXJuXCJtYXQzeDI8ZjMyPlwiO2Nhc2VcIm1hdDN4M1wiOnJldHVyblwibWF0M3gzPGYzMj5cIjtjYXNlXCJtYXQzeDRcIjpyZXR1cm5cIm1hdDN4NDxmMzI+XCI7Y2FzZVwibWF0M1tdXCI6cmV0dXJuXCJhcnJheTxtYXQzeDM8ZjMyPj5cIjtjYXNlXCJtYXQzeDJbXVwiOnJldHVyblwiYXJyYXk8bWF0M3gyPGYzMj4+XCI7Y2FzZVwibWF0M3gzW11cIjpyZXR1cm5cImFycmF5PG1hdDN4MzxmMzI+PlwiO2Nhc2VcIm1hdDN4NFtdXCI6cmV0dXJuXCJhcnJheTxtYXQzeDQ8ZjMyPj5cIjtjYXNlXCJtYXQ0XCI6cmV0dXJuXCJtYXQ0eDQ8ZjMyPlwiO2Nhc2VcIm1hdDR4MlwiOnJldHVyblwibWF0NHgyPGYzMj5cIjtjYXNlXCJtYXQ0eDNcIjpyZXR1cm5cIm1hdDR4MzxmMzI+XCI7Y2FzZVwibWF0NHg0XCI6cmV0dXJuXCJtYXQ0eDQ8ZjMyPlwiO2Nhc2VcIm1hdDRbXVwiOnJldHVyblwiYXJyYXk8bWF0NHg0PGYzMj4+XCI7Y2FzZVwibWF0NHgyW11cIjpyZXR1cm5cImFycmF5PG1hdDR4MjxmMzI+PlwiO2Nhc2VcIm1hdDR4M1tdXCI6cmV0dXJuXCJhcnJheTxtYXQ0eDM8ZjMyPj5cIjtjYXNlXCJtYXQ0eDRbXVwiOnJldHVyblwiYXJyYXk8bWF0NHg0PGYzMj4+XCI7Y2FzZVwidGV4dHVyZTJEXCI6cmV0dXJuXCJ0ZXh0dXJlXzJkPGYzMj5cIn1yZXR1cm4gaX1jbGFzcyB2dXtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJfbGV4ZXJcIiksbyh0aGlzLFwiX3Jvb3ROb2RlXCIpLHRoaXMuX2xleGVyPWUsdGhpcy5fcm9vdE5vZGU9bmV3IG1lLHRoaXMucGFyc2UoKX1nZXQgbGV4ZXIoKXtyZXR1cm4gdGhpcy5fbGV4ZXJ9cGFyc2UoKXtmb3IoO3RoaXMucGVla1Rva2VuKDApLlR5cGUhPT14LkVPRjspe2lmKHRoaXMucGVla1Rva2VuKDApLlR5cGU9PXguU0VNSUNPTE9OKXt0aGlzLnNraXBUb2tlbigxKTtjb250aW51ZX1sZXQgZT10aGlzLnBhcnNlU3RhdGVtZW50KCk7ZSE9PW51bGwmJnRoaXMuX3Jvb3ROb2RlLmFkZE5vZGUoZSl9fXBhcnNlU3RhdGVtZW50KCl7bGV0IGU9dGhpcy5wZWVrVG9rZW4oKTtpZihlLlR5cGU9PXguTEFZT1VUJiZ0aGlzLnBlZWtUb2tlbigxKS5UeXBlPT14LkxFRlRTQU1MTClyZXR1cm4gdnMucGFyc2UodGhpcy5fbGV4ZXIpO2lmKGUuVHlwZT09eC5TVFJVQ1QpcmV0dXJuIHRoaXMuc2tpcFRva2VuKDEpLG9pLnBhcnNlKHRoaXMuX2xleGVyKTtpZigoZS5pc0J1aWx0aW5UeXBlKCl8fGUuVHlwZT09eC5WT0lEKSYmdGhpcy5wZWVrVG9rZW4oMSkuVHlwZT09eC5JREVOVCYmdGhpcy5wZWVrVG9rZW4oMikuVHlwZT09eC5MRUZUU0FNTEwpcmV0dXJuIF9hLnBhcnNlKHRoaXMuX2xleGVyKTtpZihlLlR5cGU9PXguQ09OU1QmJnRoaXMucGVla1Rva2VuKDEpLmlzRGF0YVR5cGUoKSlyZXR1cm4gVGUucGFyc2UodGhpcy5fbGV4ZXIpO2lmKGUuaXNEYXRhVHlwZSgpJiZ0aGlzLnBlZWtUb2tlbigxKS5UeXBlPT14LklERU5UKXJldHVybiBUZS5wYXJzZSh0aGlzLl9sZXhlcik7aWYoZS5UeXBlPT14Lk9VVCYmdGhpcy5wZWVrVG9rZW4oMSkuaXNEYXRhVHlwZSgpJiZ0aGlzLnBlZWtUb2tlbigyKS5UeXBlPT14LklERU5UKXJldHVybiBUZS5wYXJzZSh0aGlzLl9sZXhlcik7aWYoZS5UeXBlPT14LlBSRUNJU0lPTilyZXR1cm4geWEucGFyc2UodGhpcy5fbGV4ZXIpO3Rocm93XCJFcnJvciBwYXJzaW5nIHN0YXRlbWVudDogVW5leHBlY3RlZCBjaGFyYWN0ZXJcIn1za2lwVG9rZW4oZSl7dGhpcy5fbGV4ZXIuc2tpcFRva2VuKGUpfXBlZWtUb2tlbihlPTApe3JldHVybiB0aGlzLl9sZXhlci5wZWVrVG9rZW4oZSl9Z2V0TmV4dFRva2VuKCl7cmV0dXJuIHRoaXMuX2xleGVyLkdldE5leHRUb2tlbigpfWdldCBBU1RSb290KCl7cmV0dXJuIHRoaXMuX3Jvb3ROb2RlfX1jbGFzcyBLc3tzdGF0aWMgY29udmVydEdMU0woZSl7dmFyIHQ9bmV3IG11KGUpLHI9bmV3IHB1KHQpLHM9bmV3IHZ1KHIpLGE9bmV3IEF1KHMpO3JldHVybiBhLmdlbmVyYXRlV0dTTCgpfX1vKEtzLFwiVmVydGV4U2hhZGVyXCIsXCJWZXJ0ZXhTaGFkZXJcIiksbyhLcyxcIkZyYWdtZW50U2hhZGVyXCIsXCJGcmFnbWVudFNoYWRlclwiKTtjbGFzcyBPb3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcInNldElEXCIsMCksbyh0aGlzLFwiYmluZGluZ0lEXCIsMCksbyh0aGlzLFwibmFtZVwiLFwiXCIpLG8odGhpcyxcInR5cGVcIixcIlwiKX19Y2xhc3MgTm97Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJuYW1lXCIsXCJcIiksbyh0aGlzLFwidHlwZVwiLFwiXCIpLG8odGhpcyxcImxvY2F0aW9uSURcIiwwKSxvKHRoaXMsXCJidWlsdGluTmFtZVwiLFwiXCIpfWlzQnVpbHRpbkF0dHJpYnV0ZSgpe3JldHVybiB0aGlzLmJ1aWx0aW5OYW1lIT1cIlwifX1jbGFzcyB5dXtjb25zdHJ1Y3Rvcigpe28odGhpcyxcInVuaWZvcm1JbmZvXCIsW10pLG8odGhpcyxcImlucHV0QXR0cmlidXRlXCIsW10pLG8odGhpcyxcIm91dHB1dEF0dHJpYnV0ZVwiLFtdKSxvKHRoaXMsXCJzb3VyY2VDb2RlXCIsXCJcIil9fXZhciBVdD0oaT0+KGlbaS52ZXJ0ZXg9MF09XCJ2ZXJ0ZXhcIixpW2kuZnJhZ21lbnQ9MV09XCJmcmFnbWVudFwiLGlbaS5jb21wdXRlcj0yXT1cImNvbXB1dGVyXCIsaSkpKFV0fHx7fSk7Y2xhc3MgQ3V7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJibGVuZE1vZGVcIix4ZS5OT05FKSxvKHRoaXMsXCJkZXB0aENvbXBhcmVcIix2dC5sZXNzKSxvKHRoaXMsXCJkZXB0aFdyaXRlRW5hYmxlZFwiLCEwKSxvKHRoaXMsXCJmcm9udEZhY2VcIixcImNjd1wiKSxvKHRoaXMsXCJjdWxsTW9kZVwiLHVpLmJhY2spLG8odGhpcyxcInRvcG9sb2d5XCIsTXMudHJpYW5nbGVfbGlzdCksbyh0aGlzLFwiZGVwdGhCaWFzXCIsMTApLG8odGhpcyxcInVzZUxpZ2h0XCIsITEpLG8odGhpcyxcInVzZVByb2JlXCIsITEpLG8odGhpcyxcImFjY2VwdEdJXCIsITEpLG8odGhpcyxcImFjY2VwdFNoYWRvd1wiLCExKSxvKHRoaXMsXCJjYXN0U2hhZG93XCIsITEpLG8odGhpcyxcImNhc3RSZWZsZWN0aW9uXCIsITEpLG8odGhpcyxcInJlY2VpdmVFbnZcIiwhMSksbyh0aGlzLFwicmVuZGVyTGF5ZXJcIiwxZTMpLG8odGhpcyxcInJlbmRlck9yZGVyXCIsMmUzKSxvKHRoaXMsXCJ1bmNsaXBwZWREZXB0aFwiLCExKSxvKHRoaXMsXCJ0cmFuc3BhcmVudFwiLCExKSxvKHRoaXMsXCJtdWx0aXNhbXBsZVwiLDApLG8odGhpcyxcImxhYmVsXCIpLG8odGhpcyxcInVzZVpcIiwhMCksbyh0aGlzLFwic3BsaXRUZXh0dXJlXCIsITEpLG8odGhpcyxcImFscGhhQ3V0b2ZmXCIpLG8odGhpcyxcInVzZUZyYWdEZXB0aFwiLCExKX1zZXRGcm9tTWFwVmFsdWVzKGUpe2UuaGFzKFwiYmxlbmRNb2RlXCIpJiYodGhpcy5ibGVuZE1vZGU9dGhpcy5jb252ZXJ0QmxlbmRNb2RlKGUuZ2V0KFwiYmxlbmRNb2RlXCIpKSksZS5oYXMoXCJkZXB0aENvbXBhcmVcIikmJih0aGlzLmRlcHRoQ29tcGFyZT1lLmdldChcImRlcHRoQ29tcGFyZVwiKSksZS5oYXMoXCJkZXB0aFdyaXRlRW5hYmxlZFwiKSYmKHRoaXMuZGVwdGhXcml0ZUVuYWJsZWQ9ZS5nZXQoXCJkZXB0aFdyaXRlRW5hYmxlZFwiKSksZS5oYXMoXCJmcm9udEZhY2VcIikmJih0aGlzLmZyb250RmFjZT1lLmdldChcImZyb250RmFjZVwiKSksZS5oYXMoXCJjdWxsTW9kZVwiKSYmKHRoaXMuY3VsbE1vZGU9ZS5nZXQoXCJjdWxsTW9kZVwiKSksZS5oYXMoXCJ0b3BvbG9neVwiKSYmKHRoaXMudG9wb2xvZ3k9ZS5nZXQoXCJ0b3BvbG9neVwiKSksZS5oYXMoXCJkZXB0aEJpYXNcIikmJih0aGlzLmRlcHRoQmlhcz1lLmdldChcImRlcHRoQmlhc1wiKSksZS5oYXMoXCJ1c2VMaWdodFwiKSYmKHRoaXMudXNlTGlnaHQ9ZS5nZXQoXCJ1c2VMaWdodFwiKSksZS5oYXMoXCJ1c2VQcm9iZVwiKSYmKHRoaXMudXNlUHJvYmU9ZS5nZXQoXCJ1c2VQcm9iZVwiKSksZS5oYXMoXCJhY2NlcHRHSVwiKSYmKHRoaXMuYWNjZXB0R0k9ZS5nZXQoXCJhY2NlcHRHSVwiKSksZS5oYXMoXCJhY2NlcHRTaGFkb3dcIikmJih0aGlzLmFjY2VwdFNoYWRvdz1lLmdldChcImFjY2VwdFNoYWRvd1wiKSksZS5oYXMoXCJjYXN0U2hhZG93XCIpJiYodGhpcy5jYXN0U2hhZG93PWUuZ2V0KFwiY2FzdFNoYWRvd1wiKSksZS5oYXMoXCJyZWNlaXZlRW52XCIpJiYodGhpcy5yZWNlaXZlRW52PWUuZ2V0KFwicmVjZWl2ZUVudlwiKSksZS5oYXMoXCJyZW5kZXJMYXllclwiKSYmKHRoaXMucmVuZGVyTGF5ZXI9ZS5nZXQoXCJyZW5kZXJMYXllclwiKSksZS5oYXMoXCJyZW5kZXJPcmRlclwiKSYmKHRoaXMucmVuZGVyT3JkZXI9ZS5nZXQoXCJyZW5kZXJPcmRlclwiKSksZS5oYXMoXCJ1bmNsaXBwZWREZXB0aFwiKSYmKHRoaXMudW5jbGlwcGVkRGVwdGg9ZS5nZXQoXCJ1bmNsaXBwZWREZXB0aFwiKSksZS5oYXMoXCJtdWx0aXNhbXBsZVwiKSYmKHRoaXMubXVsdGlzYW1wbGU9ZS5nZXQoXCJtdWx0aXNhbXBsZVwiKSksZS5oYXMoXCJsYWJlbFwiKSYmKHRoaXMubGFiZWw9ZS5nZXQoXCJsYWJlbFwiKSksZS5oYXMoXCJ1c2VaXCIpJiYodGhpcy51c2VaPWUuZ2V0KFwidXNlWlwiKSl9Y29udmVydEJsZW5kTW9kZShlKXtzd2l0Y2goZSl7Y2FzZVwiQUJPVkVcIjpyZXR1cm4geGUuQUJPVkU7Y2FzZVwiQUxQSEFcIjpyZXR1cm4geGUuQUxQSEE7Y2FzZVwiTk9STUFMXCI6cmV0dXJuIHhlLk5PUk1BTDtjYXNlXCJBRERcIjpyZXR1cm4geGUuQUREO2Nhc2VcIkJFTE9XXCI6cmV0dXJuIHhlLkJFTE9XO2Nhc2VcIkVSQVNFXCI6cmV0dXJuIHhlLkVSQVNFO2Nhc2VcIk1VTFwiOnJldHVybiB4ZS5NVUw7Y2FzZVwiU0NSRUVOXCI6cmV0dXJuIHhlLlNDUkVFTjtjYXNlXCJESVZEXCI6cmV0dXJuIHhlLkRJVkQ7Y2FzZVwiU09GVF9BRERcIjpyZXR1cm4geGUuU09GVF9BRER9cmV0dXJuIHhlLk5PTkV9fWNsYXNzIHd1IGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcInVuaWZvcm1Ob2Rlc1wiLFtdKSxvKHRoaXMsXCJfb25DaGFuZ2VcIiwhMCksdGhpcy5idWZmZXJUeXBlPU10Lk1hdGVyaWFsRGF0YVVuaWZvcm1HUFVCdWZmZXJ9aW5pdERhdGFVbmlmb3JtKGUpe3RoaXMudW5pZm9ybU5vZGVzPWU7bGV0IHQ9MDtmb3IoY29uc3QgciBpbiBlKXtjb25zdCBzPWVbcl07c3x8Y29uc29sZS5lcnJvcihyLFwiaXMgZW1wdHlcIiksdCs9cy5zaXplKjR9dD1NYXRoLmZsb29yKHQvMjU2KzEpKjI1Nix0aGlzLmNyZWF0ZUJ1ZmZlcihHUFVCdWZmZXJVc2FnZS5VTklGT1JNfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULHQvNCk7Zm9yKGNvbnN0IHIgaW4gZSl7Y29uc3Qgcz1lW3JdO3N8fGNvbnNvbGUuZXJyb3IocixcImlzIGVtcHR5XCIpO2xldCBhPXRoaXMubWVtb3J5LmFsbG9jYXRpb25fbm9kZShzLnNpemUqNCk7cy5tZW1vcnlJbmZvPWEscy5iaW5kT25DaGFuZ2U9KCk9PnRoaXMub25DaGFuZ2UoKX19b25DaGFuZ2UoKXt0aGlzLl9vbkNoYW5nZT0hMH1hcHBseSgpe2lmKHRoaXMudW5pZm9ybU5vZGVzLmxlbmd0aCE9MCYmdGhpcy5fb25DaGFuZ2Upe2Zvcihjb25zdCBlIGluIHRoaXMudW5pZm9ybU5vZGVzKXRoaXMudW5pZm9ybU5vZGVzW2VdLnVwZGF0ZSgpO3N1cGVyLmFwcGx5KCksdGhpcy5fb25DaGFuZ2U9ITF9fX1jbGFzcyBPdHtzdGF0aWMgaW5pdCgpe3RoaXMucmVuZGVyU2hhZGVyTW9kdWxlUG9vbD1uZXcgTWFwLHRoaXMucmVuZGVyU2hhZGVyPW5ldyBNYXB9fW8oT3QsXCJyZW5kZXJTaGFkZXJNb2R1bGVQb29sXCIpLG8oT3QsXCJyZW5kZXJTaGFkZXJcIik7Y2xhc3MgSnN7c3RhdGljIGdldFNoYXJlUGlwZWxpbmUoZSl7bGV0IHQ9dGhpcy5waXBlbGluZU1hcC5nZXQoZSk7cmV0dXJuIHR8fG51bGx9c3RhdGljIHNldFNoYXJlUGlwZWxpbmUoZSx0KXt0aGlzLnBpcGVsaW5lTWFwLnNldChlLHQpfX1vKEpzLFwicGlwZWxpbmVNYXBcIixuZXcgTWFwKTtjbGFzcyBXZSBleHRlbmRzIEthe2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSxvKHRoaXMsXCJ1c2VSelwiLCExKSxvKHRoaXMsXCJ2c05hbWVcIiksbyh0aGlzLFwiZnNOYW1lXCIpLG8odGhpcyxcInNoYWRlclN0YXRlXCIpLG8odGhpcyxcInRleHR1cmVzXCIpLG8odGhpcyxcInBpcGVsaW5lXCIpLG8odGhpcyxcImJpbmRHcm91cExheW91dHNcIiksbyh0aGlzLFwibWF0ZXJpYWxEYXRhVW5pZm9ybUJ1ZmZlclwiKSxvKHRoaXMsXCJlbnZNYXBcIiksbyh0aGlzLFwicHJlZmlsdGVyTWFwXCIpLG8odGhpcyxcIl9zb3VyY2VWU1wiKSxvKHRoaXMsXCJfc291cmNlRlNcIiksbyh0aGlzLFwiX2Rlc3RWU1wiKSxvKHRoaXMsXCJfZGVzdEZTXCIpLG8odGhpcyxcIl92c1NoYWRlck1vZHVsZVwiKSxvKHRoaXMsXCJfZnNTaGFkZXJNb2R1bGVcIiksbyh0aGlzLFwiX3RleHR1cmVHcm91cFwiLC0xKSxvKHRoaXMsXCJfdGV4dHVyZUNoYW5nZVwiLCExKSxvKHRoaXMsXCJfZ3JvdXBzU2hhZGVyUmVmbGVjdGlvblZhckluZm9zXCIpLG8odGhpcyxcIl9jYWNoZUVudHJpZXNcIiksdGhpcy52c05hbWU9ZS50b0xvd2VyQ2FzZSgpLHRoaXMuZnNOYW1lPXQudG9Mb3dlckNhc2UoKSx0aGlzLnZzTmFtZSBpbiBOfHxjb25zb2xlLmVycm9yKFwiU2hhZGVyIE5vdCBSZWdpc3RlciwgUGxlYXNlIFJlZ2lzdGVyIFNoYWRlciFcIix0aGlzLnZzTmFtZSksdGhpcy5mc05hbWUgaW4gTnx8Y29uc29sZS5lcnJvcihcIlNoYWRlciBOb3QgUmVnaXN0ZXIsIFBsZWFzZSBSZWdpc3RlciBTaGFkZXIhXCIsdGhpcy5mc05hbWUpLE5bdGhpcy52c05hbWVdJiYodGhpcy5fc291cmNlVlM9Tlt0aGlzLnZzTmFtZV0pLE5bdGhpcy5mc05hbWVdJiYodGhpcy5fc291cmNlRlM9Tlt0aGlzLmZzTmFtZV0pLHRoaXMudGV4dHVyZXM9e30sdGhpcy5iaW5kR3JvdXBzPVtdLHRoaXMuc2hhZGVyU3RhdGU9bmV3IEN1LHRoaXMubWF0ZXJpYWxEYXRhVW5pZm9ybUJ1ZmZlcj1uZXcgd3UsdGhpcy5tYXRlcmlhbERhdGFVbmlmb3JtQnVmZmVyLnZpc2liaWxpdHk9R1BVU2hhZGVyU3RhZ2UuVkVSVEVYfEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULHRoaXMuX2J1ZmZlckRpYy5zZXQoXCJnbG9iYWxcIix0aGlzLm1hdGVyaWFsRGF0YVVuaWZvcm1CdWZmZXIpLHRoaXMuX2J1ZmZlckRpYy5zZXQoXCJtYXRlcmlhbFVuaWZvcm1cIix0aGlzLm1hdGVyaWFsRGF0YVVuaWZvcm1CdWZmZXIpfWdldCByZW5kZXJPcmRlcigpe3JldHVybiB0aGlzLnNoYWRlclN0YXRlLnJlbmRlck9yZGVyfXNldCByZW5kZXJPcmRlcihlKXt0aGlzLnNoYWRlclN0YXRlLnJlbmRlck9yZGVyIT1lJiYodGhpcy5fdmFsdWVDaGFuZ2U9ITApLHRoaXMuc2hhZGVyU3RhdGUucmVuZGVyT3JkZXI9ZX1nZXQgZG91YmxlU2lkZSgpe3JldHVybiB0aGlzLnNoYWRlclN0YXRlLmN1bGxNb2RlPT11aS5ub25lfXNldCBkb3VibGVTaWRlKGUpe2xldCB0PWU/dWkubm9uZTp0aGlzLmN1bGxNb2RlO3RoaXMuc2hhZGVyU3RhdGUuY3VsbE1vZGUhPXQmJih0aGlzLl92YWx1ZUNoYW5nZT0hMCksdGhpcy5zaGFkZXJTdGF0ZS5jdWxsTW9kZT10fWdldCBjdWxsTW9kZSgpe3JldHVybiB0aGlzLnNoYWRlclN0YXRlLmN1bGxNb2RlfXNldCBjdWxsTW9kZShlKXt0aGlzLnNoYWRlclN0YXRlLmN1bGxNb2RlIT1lJiYodGhpcy5fdmFsdWVDaGFuZ2U9ITApLHRoaXMuc2hhZGVyU3RhdGUuY3VsbE1vZGU9ZX1nZXQgZnJvbnRGYWNlKCl7cmV0dXJuIHRoaXMuc2hhZGVyU3RhdGUuZnJvbnRGYWNlfXNldCBmcm9udEZhY2UoZSl7dGhpcy5zaGFkZXJTdGF0ZS5mcm9udEZhY2UhPWUmJih0aGlzLl92YWx1ZUNoYW5nZT0hMCksdGhpcy5zaGFkZXJTdGF0ZS5mcm9udEZhY2U9ZX1nZXQgZGVwdGhCaWFzKCl7cmV0dXJuIHRoaXMuc2hhZGVyU3RhdGUuZGVwdGhCaWFzfXNldCBkZXB0aEJpYXMoZSl7dGhpcy5zaGFkZXJTdGF0ZS5kZXB0aEJpYXMhPWUmJih0aGlzLl92YWx1ZUNoYW5nZT0hMCksdGhpcy5zaGFkZXJTdGF0ZS5kZXB0aEJpYXM9ZX1nZXQgdG9wb2xvZ3koKXtyZXR1cm4gdGhpcy5zaGFkZXJTdGF0ZS50b3BvbG9neX1zZXQgdG9wb2xvZ3koZSl7dGhpcy5zaGFkZXJTdGF0ZS50b3BvbG9neSE9ZSYmKHRoaXMuX3ZhbHVlQ2hhbmdlPSEwKSx0aGlzLnNoYWRlclN0YXRlLnRvcG9sb2d5PWV9Z2V0IGJsZW5kTW9kZSgpe3JldHVybiB0aGlzLnNoYWRlclN0YXRlLmJsZW5kTW9kZX1zZXQgYmxlbmRNb2RlKGUpe3RoaXMuc2hhZGVyU3RhdGUuYmxlbmRNb2RlIT1lJiYodGhpcy5fdmFsdWVDaGFuZ2U9ITAsZSE9eGUuTk9STUFMJiZlIT14ZS5OT05FJiYodGhpcy5yZW5kZXJPcmRlcj0zZTMpKSx0aGlzLnNoYWRlclN0YXRlLmJsZW5kTW9kZT1lfWdldCBkZXB0aENvbXBhcmUoKXtyZXR1cm4gdGhpcy5zaGFkZXJTdGF0ZS5kZXB0aENvbXBhcmV9c2V0IGRlcHRoQ29tcGFyZShlKXt0aGlzLnNoYWRlclN0YXRlLmRlcHRoQ29tcGFyZSE9ZSYmKHRoaXMuX3ZhbHVlQ2hhbmdlPSEwKSx0aGlzLnNoYWRlclN0YXRlLmRlcHRoQ29tcGFyZT1lfXNldFNoYWRlckVudHJ5KGU9XCJcIix0PVwiXCIpe3RoaXMudnNFbnRyeVBvaW50PWUsdGhpcy5mc0VudHJ5UG9pbnQ9dH1zZXRVbmlmb3JtKGUsdCl7c3VwZXIuc2V0VW5pZm9ybShlLHQpLHRoaXMubWF0ZXJpYWxEYXRhVW5pZm9ybUJ1ZmZlci5vbkNoYW5nZSgpfXNldFRleHR1cmUoZSx0KXt0JiZ0aGlzLnRleHR1cmVzW2VdIT10JiYodGhpcy50ZXh0dXJlc1tlXSYmdGhpcy50ZXh0dXJlc1tlXS51bkJpbmRTdGF0ZUNoYW5nZSh0aGlzKSx0aGlzLl90ZXh0dXJlQ2hhbmdlPSEwLHRoaXMudGV4dHVyZXNbZV09dCxlPT1cImVudk1hcFwiP3RoaXMuZW52TWFwPXQ6ZT09XCJwcmVmaWx0ZXJNYXBcIiYmKHRoaXMucHJlZmlsdGVyTWFwPXQpLHQuYmluZFN0YXRlQ2hhbmdlKCgpPT57dGhpcy5fdGV4dHVyZUNoYW5nZT0hMH0sdGhpcykpfWdldCBiYXNlQ29sb3IoKXtyZXR1cm4gdGhpcy5nZXRVbmlmb3JtKFwiYmFzZUNvbG9yXCIpfXNldCBiYXNlQ29sb3IoZSl7dGhpcy5zZXRVbmlmb3JtKFwiYmFzZUNvbG9yXCIsZSl9Z2V0VGV4dHVyZShlKXtyZXR1cm4gdGhpcy50ZXh0dXJlc1tlXX1nZW5SZW5kZXJQaXBlbGluZShlLHQpe2xldCByPXRoaXMuY3JlYXRlR3JvdXBMYXlvdXRzKCk7dGhpcy5jcmVhdGVQaXBlbGluZShlLHQscil9cmVCdWlsZChlLHQpe3RoaXMuY29tcGlsZVNoYWRlcihVdC52ZXJ0ZXgsdGhpcy5fZGVzdFZTLHQpLHRoaXMuY29tcGlsZVNoYWRlcihVdC5mcmFnbWVudCx0aGlzLl9kZXN0RlMsdCksdGhpcy5nZW5SZW5kZXJQaXBlbGluZShlLHQpfWFwcGx5KGUsdCxyKXt0aGlzLm1hdGVyaWFsRGF0YVVuaWZvcm1CdWZmZXIuYXBwbHkoKSx0aGlzLl90ZXh0dXJlQ2hhbmdlJiZ0aGlzLl90ZXh0dXJlR3JvdXAhPS0xJiYodGhpcy5fdGV4dHVyZUNoYW5nZT0hMSx0aGlzLmdlbkdyb3Vwcyh0aGlzLl90ZXh0dXJlR3JvdXAsdGhpcy5zaGFkZXJSZWZsZWN0aW9uLmdyb3VwcywhMCkpLHRoaXMuX3ZhbHVlQ2hhbmdlJiYodGhpcy5fc2hhZGVyQ2hhbmdlJiYodGhpcy5wcmVDb21waWxlKGUpLHRoaXMuX3NoYWRlckNoYW5nZT0hMSksdGhpcy5zaGFkZXJWYXJpYW50PWN0LmdlblJlbmRlclNoYWRlclZhcmlhbnQodGhpcyksdGhpcy5yZUJ1aWxkKGUsdCksdGhpcy5fdmFsdWVDaGFuZ2U9ITEsciYmcigpKX1wcmVDb21waWxlKGUpe3RoaXMucHJlRGVmaW5lKGUpLHRoaXMucHJlQ29tcGlsZVNoYWRlcihVdC52ZXJ0ZXgsdGhpcy5fc291cmNlVlMuY29uY2F0KCkpLHRoaXMucHJlQ29tcGlsZVNoYWRlcihVdC5mcmFnbWVudCx0aGlzLl9zb3VyY2VGUy5jb25jYXQoKSksdGhpcy5nZW5SZWZsZWN0aW9uKCl9YXBwbHlQb3N0RGVmaW5lKGUsdCl7cmV0dXJuIHQub3V0QXR0YWNobWVudHMubGVuZ3RoPjE/KHRoaXMuZGVmaW5lVmFsdWUuVVNFX1dPUkxEUE9TPSEwLHRoaXMuZGVmaW5lVmFsdWUuVVNFR0JVRkZFUj0hMCk6KHRoaXMuZGVmaW5lVmFsdWUuVVNFX1dPUkxEUE9TPSExLHRoaXMuZGVmaW5lVmFsdWUuVVNFR0JVRkZFUj0hMSksdXQucGFyc2UoZSx0aGlzLmRlZmluZVZhbHVlKX1zZXRCaW5kR3JvdXAoZSx0KXt0aGlzLmJpbmRHcm91cHNbZV09dH1jaGVja0J1ZmZlcihlLHQpe31wcmVDb21waWxlU2hhZGVyKGUsdCxyKXtsZXQgcz10O2lmKHMuaW5kZXhPZihcInZlcnNpb24gXCIpIT0tMSl7dmFyIGE9S3MuY29udmVydEdMU0wocyk7cz1hLnNvdXJjZUNvZGV9Zm9yKGNvbnN0IG4gaW4gdGhpcy5jb25zdFZhbHVlcylpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25zdFZhbHVlcyxuKSl7Y29uc3QgbD10aGlzLmNvbnN0VmFsdWVzW25dO3M9cy5yZXBsYWNlQWxsKGAmJHtufWAsbC50b1N0cmluZygpKX1zd2l0Y2goZSl7Y2FzZSBVdC52ZXJ0ZXg6dGhpcy5fZGVzdFZTPXM7YnJlYWs7Y2FzZSBVdC5mcmFnbWVudDp0aGlzLl9kZXN0RlM9czticmVha319Y29tcGlsZVNoYWRlcihlLHQscil7bGV0IHM9dDtzPXRoaXMuYXBwbHlQb3N0RGVmaW5lKHMscik7bGV0IGE9dDtmb3IobGV0IGwgaW4gdGhpcy5kZWZpbmVWYWx1ZSlhKz1gJHtsfT0ke3RoaXMuZGVmaW5lVmFsdWVbbF19LGA7bGV0IG49T3QucmVuZGVyU2hhZGVyTW9kdWxlUG9vbC5nZXQoYSk7c3dpdGNoKG58fChzPXRoaXMuYXBwbHlQb3N0RGVmaW5lKHMsciksbj1TLmRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe2xhYmVsOmU9PVV0LnZlcnRleD90aGlzLnZzTmFtZTp0aGlzLmZzTmFtZSxjb2RlOnN9KSxuLmdldENvbXBpbGF0aW9uSW5mbygpLnRoZW4obD0+e2wubWVzc2FnZXMubGVuZ3RoPjAmJihjb25zb2xlLmxvZyhzKSxjb25zb2xlLmxvZyhsKSl9KSxPdC5yZW5kZXJTaGFkZXJNb2R1bGVQb29sLnNldChhLG4pKSxlKXtjYXNlIFV0LnZlcnRleDp0aGlzLl92c1NoYWRlck1vZHVsZT1uLHRoaXMuX2Rlc3RWUz1zO2JyZWFrO2Nhc2UgVXQuZnJhZ21lbnQ6dGhpcy5fZnNTaGFkZXJNb2R1bGU9bix0aGlzLl9kZXN0RlM9czticmVha319Z2V0R3JvdXBMYXlvdXQoZSx0KXtsZXQgcj1bXTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl7Y29uc3QgYT10W3NdO2lmKGEpaWYoYS52YXJUeXBlPT1cInVuaWZvcm1cIil7dGhpcy5fYnVmZmVyRGljLmhhcyhhLnZhck5hbWUpfHxjb25zb2xlLmVycm9yKGBub3Qgc2V0ICR7YS52YXJOYW1lfSBidWZmZXJgKTtsZXQgbj10aGlzLl9idWZmZXJEaWMuZ2V0KGEudmFyTmFtZSkudmlzaWJpbGl0eSxsPXtiaW5kaW5nOmEuYmluZGluZyx2aXNpYmlsaXR5Om4sYnVmZmVyOnt0eXBlOlwidW5pZm9ybVwifX07ci5wdXNoKGwpfWVsc2UgaWYoYS52YXJUeXBlPT1cInN0b3JhZ2UtcmVhZFwiKXt0aGlzLl9idWZmZXJEaWMuaGFzKGEudmFyTmFtZSl8fGNvbnNvbGUuZXJyb3IoYG5vdCBzZXQgJHthLnZhck5hbWV9IGJ1ZmZlcmApO2xldCBuPXRoaXMuX2J1ZmZlckRpYy5nZXQoYS52YXJOYW1lKS52aXNpYmlsaXR5LGw9e2JpbmRpbmc6YS5iaW5kaW5nLHZpc2liaWxpdHk6bixidWZmZXI6e3R5cGU6XCJyZWFkLW9ubHktc3RvcmFnZVwifX07ci5wdXNoKGwpfWVsc2UgaWYoYS52YXJUeXBlPT1cInZhclwiKXN3aXRjaChhLmRhdGFUeXBlKXtjYXNlXCJzYW1wbGVyXCI6e2xldCBuPWEudmFyTmFtZS5yZXBsYWNlKFwiU2FtcGxlclwiLFwiXCIpLGw9dGhpcy50ZXh0dXJlc1tuXT90aGlzLnRleHR1cmVzW25dOkEucmVzLnJlZFRleHR1cmUsaD17YmluZGluZzphLmJpbmRpbmcsdmlzaWJpbGl0eTpsLnZpc2liaWxpdHksc2FtcGxlcjpsLnNhbXBsZXJCaW5kaW5nTGF5b3V0fTtyLnB1c2goaCksdGhpcy5fdGV4dHVyZUdyb3VwPWV9YnJlYWs7Y2FzZVwic2FtcGxlcl9jb21wYXJpc29uXCI6e2xldCBuPWEudmFyTmFtZS5yZXBsYWNlKFwiU2FtcGxlclwiLFwiXCIpLGw9dGhpcy50ZXh0dXJlc1tuXT90aGlzLnRleHR1cmVzW25dOkEucmVzLnJlZFRleHR1cmUsaD17YmluZGluZzphLmJpbmRpbmcsdmlzaWJpbGl0eTpsLnZpc2liaWxpdHksc2FtcGxlcjpsLnNhbXBsZXJfY29tcGFyaXNvbkJpbmRpbmdMYXlvdXR9O3IucHVzaChoKSx0aGlzLl90ZXh0dXJlR3JvdXA9ZX1icmVhaztjYXNlXCJ0ZXh0dXJlXzJkPGYzMj5cIjpjYXNlXCJ0ZXh0dXJlXzJkX2FycmF5PGYzMj5cIjpjYXNlXCJ0ZXh0dXJlX2N1YmU8ZjMyPlwiOmNhc2VcInRleHR1cmVfZGVwdGhfMmRcIjpjYXNlXCJ0ZXh0dXJlX2RlcHRoXzJkX2FycmF5XCI6Y2FzZVwidGV4dHVyZV9kZXB0aF9jdWJlXCI6Y2FzZVwidGV4dHVyZV9kZXB0aF9jdWJlX2FycmF5XCI6e2xldCBuPXRoaXMudGV4dHVyZXNbYS52YXJOYW1lXT90aGlzLnRleHR1cmVzW2EudmFyTmFtZV06QS5yZXMucmVkVGV4dHVyZSxsPXtiaW5kaW5nOmEuYmluZGluZyx2aXNpYmlsaXR5Om4udmlzaWJpbGl0eSx0ZXh0dXJlOm4udGV4dHVyZUJpbmRpbmdMYXlvdXR9O3IucHVzaChsKSx0aGlzLl90ZXh0dXJlR3JvdXA9ZSxzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKG4sdGhpcyl9YnJlYWs7Y2FzZVwidGV4dHVyZV9leHRlcm5hbFwiOntsZXQgbj10aGlzLnRleHR1cmVzW2EudmFyTmFtZV0/dGhpcy50ZXh0dXJlc1thLnZhck5hbWVdOkEucmVzLnJlZFRleHR1cmUsbD17YmluZGluZzphLmJpbmRpbmcsdmlzaWJpbGl0eTpuLnZpc2liaWxpdHksZXh0ZXJuYWxUZXh0dXJlOnt9fTtyLnB1c2gobCksdGhpcy5fdGV4dHVyZUdyb3VwPWUsc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZChuLHRoaXMpfWJyZWFrO2RlZmF1bHQ6e2xldCBuPXRoaXMudGV4dHVyZXNbYS52YXJOYW1lXT90aGlzLnRleHR1cmVzW2EudmFyTmFtZV06QS5yZXMucmVkVGV4dHVyZSxsPXtiaW5kaW5nOmEuYmluZGluZyx2aXNpYmlsaXR5Om4udmlzaWJpbGl0eSx0ZXh0dXJlOm4udGV4dHVyZUJpbmRpbmdMYXlvdXR9O3IucHVzaChsKSx0aGlzLl90ZXh0dXJlR3JvdXA9ZSxzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKG4sdGhpcyl9YnJlYWt9ZWxzZXtkZWJ1Z2dlcjtjb25zb2xlLmVycm9yKFwiYmluZCBncm91cCBjYW4ndCBlbXB0eVwiKX19cmV0dXJuIHJ9Z2VuR3JvdXBzKGUsdCxyPSExKXtpZighdGhpcy5iaW5kR3JvdXBzW2VdfHxyKXtjb25zdCBzPXRbZV07bGV0IGE9W107Zm9yKGxldCBsPTA7bDxzLmxlbmd0aDtsKyspe2NvbnN0IGg9c1tsXTtpZihoKXtpZihoLnZhclR5cGU9PVwidW5pZm9ybVwiKXtsZXQgdT10aGlzLl9idWZmZXJEaWMuZ2V0KGgudmFyTmFtZSk7aWYodSl7aWYodS5idWZmZXJUeXBlPT1NdC5NYXRlcmlhbERhdGFVbmlmb3JtR1BVQnVmZmVyKXtsZXQgZj1bXTtmb3IobGV0IGQ9MDtkPGguZGF0YUZpZWxkcy5sZW5ndGg7ZCsrKXtjb25zdCBwPWguZGF0YUZpZWxkc1tkXTt0aGlzLnVuaWZvcm1zW3AubmFtZV18fGNvbnNvbGUuZXJyb3IoYHNoYWRlci0ke3RoaXMudnNOYW1lfToke3RoaXMuZnNOYW1lfSAke3AubmFtZX1pcyBlbXB0eWApLGYucHVzaCh0aGlzLnVuaWZvcm1zW3AubmFtZV0pfXRoaXMubWF0ZXJpYWxEYXRhVW5pZm9ybUJ1ZmZlci5pbml0RGF0YVVuaWZvcm0oZil9bGV0IGM9e2JpbmRpbmc6aC5iaW5kaW5nLHJlc291cmNlOntidWZmZXI6dS5idWZmZXIsb2Zmc2V0OjAsc2l6ZTp1Lm1lbW9yeS5zaGFyZURhdGFCdWZmZXIuYnl0ZUxlbmd0aH19O2EucHVzaChjKSx0aGlzLmNoZWNrQnVmZmVyKGgudmFyTmFtZSx1KX1lbHNlIGNvbnNvbGUuZXJyb3IoYHNoYWRlciR7dGhpcy52c05hbWV9LSR7dGhpcy5mc05hbWV9YCxgYnVmZmVyICR7aC52YXJOYW1lfSBpcyBtaXNzaW5nIWApfWVsc2UgaWYoaC52YXJUeXBlPT1cInN0b3JhZ2UtcmVhZFwiKXtsZXQgdT10aGlzLl9idWZmZXJEaWMuZ2V0KGgudmFyTmFtZSk7aWYodSl7bGV0IGM9e2JpbmRpbmc6aC5iaW5kaW5nLHJlc291cmNlOntidWZmZXI6dS5idWZmZXIsb2Zmc2V0OjAsc2l6ZTp1Lm1lbW9yeS5zaGFyZURhdGFCdWZmZXIuYnl0ZUxlbmd0aH19O2EucHVzaChjKSx0aGlzLmNoZWNrQnVmZmVyKGgudmFyTmFtZSx1KX1lbHNlIGNvbnNvbGUuZXJyb3IoYGJ1ZmZlciAke2gudmFyTmFtZX0gaXMgbWlzc2luZyFgKX1lbHNlIGlmKGgudmFyVHlwZT09XCJ2YXJcIilpZihoLmRhdGFUeXBlPT1cInNhbXBsZXJcIil7bGV0IHU9aC52YXJOYW1lLnJlcGxhY2UoXCJTYW1wbGVyXCIsXCJcIiksYz10aGlzLnRleHR1cmVzW3VdO2lmKGN8fChjPUEucmVzLmJsYWNrVGV4dHVyZSx0aGlzLnNldFRleHR1cmUodSxjKSksYyl7bGV0IGY9e2JpbmRpbmc6aC5iaW5kaW5nLHJlc291cmNlOmMuZ3B1U2FtcGxlcn07YS5wdXNoKGYpfWVsc2UgY29uc29sZS5lcnJvcihgc2hhZGVyJHt0aGlzLnZzTmFtZX0tJHt0aGlzLmZzTmFtZX1gLGB0ZXh0dXJlICR7aC52YXJOYW1lfSBpcyBtaXNzaW5nISBgKX1lbHNlIGlmKGguZGF0YVR5cGU9PVwic2FtcGxlcl9jb21wYXJpc29uXCIpe2xldCB1PWgudmFyTmFtZS5yZXBsYWNlKFwiU2FtcGxlclwiLFwiXCIpLGM9dGhpcy50ZXh0dXJlc1t1XTtpZihjKXtsZXQgZj17YmluZGluZzpoLmJpbmRpbmcscmVzb3VyY2U6Yy5ncHVTYW1wbGVyX2NvbXBhcmlzb259O2EucHVzaChmKX1lbHNlIGNvbnNvbGUuZXJyb3IoYHNoYWRlciR7dGhpcy52c05hbWV9LSR7dGhpcy5mc05hbWV9YCxgdGV4dHVyZSAke2gudmFyTmFtZX0gaXMgbWlzc2luZyEgYCl9ZWxzZXtsZXQgdT10aGlzLnRleHR1cmVzW2gudmFyTmFtZV07aWYodXx8KHU9QS5yZXMud2hpdGVUZXh0dXJlLHRoaXMuc2V0VGV4dHVyZShoLnZhck5hbWUsdSkpLHUpe2xldCBjPXtiaW5kaW5nOmguYmluZGluZyxyZXNvdXJjZTp1LmdldEdQVVZpZXcoKX07YS5wdXNoKGMpfWVsc2UgY29uc29sZS5lcnJvcihgc2hhZGVyJHt0aGlzLnZzTmFtZX0tJHt0aGlzLmZzTmFtZX1gLGB0ZXh0dXJlICR7aC52YXJOYW1lfSBpcyBtaXNzaW5nISBgKX19fWxldCBuPVMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnRoaXMuYmluZEdyb3VwTGF5b3V0c1tlXSxlbnRyaWVzOmF9KTt0aGlzLmJpbmRHcm91cHNbZV09bn19Y3JlYXRlUGlwZWxpbmUoZSx0LHIpe2xldCBzPWUsYT10aGlzLnNoYWRlclN0YXRlLG49dC5vdXRBdHRhY2htZW50cztpZih0Lm91dENvbG9yIT0tMSl7bGV0IHU9blt0Lm91dENvbG9yXTthLmJsZW5kTW9kZSE9eGUuTk9ORT91LmJsZW5kPW5vLmdldEJsZW5kKGEuYmxlbmRNb2RlKTpkZWxldGUgdS5ibGVuZH1sZXQgbD17bGFiZWw6dGhpcy52c05hbWUrXCJ8XCIrdGhpcy5mc05hbWUsbGF5b3V0OnIscHJpbWl0aXZlOnt0b3BvbG9neTphLnRvcG9sb2d5LGN1bGxNb2RlOmEuY3VsbE1vZGUsZnJvbnRGYWNlOmEuZnJvbnRGYWNlfSx2ZXJ0ZXg6dm9pZCAwfTt0aGlzLnZzRW50cnlQb2ludCE9XCJcIiYmKGwudmVydGV4PXttb2R1bGU6dGhpcy5fdnNTaGFkZXJNb2R1bGUsZW50cnlQb2ludDp0aGlzLnZzRW50cnlQb2ludCxidWZmZXJzOnMudmVydGV4QnVmZmVyLnZlcnRleEJ1ZmZlckxheW91dHN9KSx0aGlzLmZzRW50cnlQb2ludCE9XCJcIiYmKGwuZnJhZ21lbnQ9e21vZHVsZTp0aGlzLl9mc1NoYWRlck1vZHVsZSxlbnRyeVBvaW50OnRoaXMuZnNFbnRyeVBvaW50LHRhcmdldHM6bn0pLGEubXVsdGlzYW1wbGU+MCYmKGwubXVsdGlzYW1wbGU9e2NvdW50OmEubXVsdGlzYW1wbGV9KSwodC56UHJlVGV4dHVyZXx8dC5kZXB0aFRleHR1cmUpJiYoYS5ibGVuZE1vZGUhPXhlLk5PTkUsQS5zZXR0aW5nLnJlbmRlci56UHJlUGFzcyYmdC56UHJlVGV4dHVyZSYmYS51c2VaP2wuZGVwdGhTdGVuY2lsPXtkZXB0aFdyaXRlRW5hYmxlZDohMSxkZXB0aENvbXBhcmU6dnQubGVzcyxmb3JtYXQ6dC56UHJlVGV4dHVyZS5mb3JtYXR9OmwuZGVwdGhTdGVuY2lsPXtkZXB0aFdyaXRlRW5hYmxlZDphLmRlcHRoV3JpdGVFbmFibGVkLGRlcHRoQ29tcGFyZTphLmRlcHRoQ29tcGFyZSxmb3JtYXQ6dC5kZXB0aFRleHR1cmUuZm9ybWF0fSk7bGV0IGg9SnMuZ2V0U2hhcmVQaXBlbGluZSh0aGlzLnNoYWRlclZhcmlhbnQpO2g/dGhpcy5waXBlbGluZT1oOih0aGlzLnBpcGVsaW5lPXcuY3JlYXRlUGlwZWxpbmUobCksSnMuc2V0U2hhcmVQaXBlbGluZSh0aGlzLnNoYWRlclZhcmlhbnQsdGhpcy5waXBlbGluZSkpfWNyZWF0ZUdyb3VwTGF5b3V0cygpe3RoaXMuX2dyb3Vwc1NoYWRlclJlZmxlY3Rpb25WYXJJbmZvcz1bXTtsZXQgZT10aGlzLnNoYWRlclJlZmxlY3Rpb247dGhpcy5iaW5kR3JvdXBMYXlvdXRzPVtIci5nZXRHbG9iYWxEYXRhQmluZEdyb3VwTGF5b3V0KCldO2ZvcihsZXQgcj0xO3I8ZS5ncm91cHMubGVuZ3RoO3IrKyl7bGV0IHM9ZS5ncm91cHNbcl07aWYocyl7bGV0IGE9dGhpcy5nZXRHcm91cExheW91dChyLHMpO3RoaXMuX2dyb3Vwc1NoYWRlclJlZmxlY3Rpb25WYXJJbmZvc1tyXT1zO2xldCBuPVMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7ZW50cmllczphLGxhYmVsOmB2cyR7dGhpcy52c05hbWV9IGZzJHt0aGlzLmZzTmFtZX0gJHtzLmxlbmd0aH1gfSk7dGhpcy5iaW5kR3JvdXBMYXlvdXRzW3JdPW59ZWxzZSBjb25zb2xlLmVycm9yKFwiY2FuJ3Qgc2V0IGVtcHR5IGdyb3VwIVwiLHIpfWxldCB0PVMuZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtiaW5kR3JvdXBMYXlvdXRzOnRoaXMuYmluZEdyb3VwTGF5b3V0c30pO3JldHVybiB0aGlzLl9ncm91cHNTaGFkZXJSZWZsZWN0aW9uVmFySW5mb3NbMF0sdGhpcy5fZ3JvdXBzU2hhZGVyUmVmbGVjdGlvblZhckluZm9zWzFdJiZ0aGlzLmdlbkdyb3VwcygxLHRoaXMuX2dyb3Vwc1NoYWRlclJlZmxlY3Rpb25WYXJJbmZvcyksdGhpcy5fZ3JvdXBzU2hhZGVyUmVmbGVjdGlvblZhckluZm9zWzJdJiZ0aGlzLmdlbkdyb3VwcygyLHRoaXMuX2dyb3Vwc1NoYWRlclJlZmxlY3Rpb25WYXJJbmZvcyksdGhpcy5fZ3JvdXBzU2hhZGVyUmVmbGVjdGlvblZhckluZm9zWzNdJiZ0aGlzLmdlbkdyb3VwcygzLHRoaXMuX2dyb3Vwc1NoYWRlclJlZmxlY3Rpb25WYXJJbmZvcyksdH1wcmVEZWZpbmUoZSl7bGV0IHQ9ZS5oYXNBdHRyaWJ1dGUoWS5qb2ludHMwKSxyPWUuaGFzQXR0cmlidXRlKFkuYV9tb3JwaFBvc2l0aW9uc18wKSxzPWUuaGFzQXR0cmlidXRlKFkuVEFOR0VOVCksYT1lLmhhc0F0dHJpYnV0ZShZLmNvbG9yKSxuPXRoaXMuc2hhZGVyU3RhdGUuYWNjZXB0R0ksbD10aGlzLnNoYWRlclN0YXRlLnVzZUxpZ2h0O3RoaXMuZGVmaW5lVmFsdWUuVVNFX1NLRUxFVE9OPXQsdGhpcy5kZWZpbmVWYWx1ZS5VU0VfTU9SUEhUQVJHRVRTPXIsXCJVU0VfVEFOR0VOVFwiaW4gdGhpcy5kZWZpbmVWYWx1ZXx8KHRoaXMuZGVmaW5lVmFsdWUuVVNFX1RBTkdFTlQ9cyksdGhpcy5kZWZpbmVWYWx1ZS5VU0VfR0k9bix0aGlzLmRlZmluZVZhbHVlLlVTRV9DQVNUU0hBRE9XPXRoaXMuc2hhZGVyU3RhdGUuY2FzdFNoYWRvdyx0aGlzLmRlZmluZVZhbHVlLlVTRV9TSEFET1dNQVBJTkc9dGhpcy5zaGFkZXJTdGF0ZS5hY2NlcHRTaGFkb3csdGhpcy5kZWZpbmVWYWx1ZS5VU0VfTElHSFQ9bCx0aGlzLmRlZmluZVZhbHVlLlVTRV9WRVJUWENPTE9SPWEsQS5zZXR0aW5nLnBpY2subW9kZT09XCJwaXhlbFwiJiYodGhpcy5kZWZpbmVWYWx1ZS5VU0VfV09STERQT1M9ITApLEEuc2V0dGluZy5naS5lbmFibGU/dGhpcy5kZWZpbmVWYWx1ZS5VU0VHST0hMDp0aGlzLmRlZmluZVZhbHVlLlVTRUdJPSExLEEuc2V0dGluZy5yZW5kZXIuZGVidWcmJih0aGlzLmRlZmluZVZhbHVlLlVTRV9ERUJVRz0hMCx0aGlzLmRlZmluZVZhbHVlLkRFQlVHX0NMVVNURVI9ITApLHRoaXMuc2hhZGVyU3RhdGUudXNlTGlnaHQ/dGhpcy5kZWZpbmVWYWx1ZS5VU0VfTElHSFQ9ITA6dGhpcy5kZWZpbmVWYWx1ZS5VU0VfTElHSFQ9ITEsQS5zZXR0aW5nLnJlbmRlci51c2VMb2dEZXB0aD8odGhpcy5kZWZpbmVWYWx1ZS5VU0VfTE9HREVQVEg9ITAsdGhpcy5zaGFkZXJTdGF0ZS51c2VGcmFnRGVwdGg9ITApOnRoaXMuZGVmaW5lVmFsdWUuVVNFX0xPR0RFUFRIPSExLHRoaXMuc2hhZGVyU3RhdGUudXNlRnJhZ0RlcHRoP3RoaXMuZGVmaW5lVmFsdWUuVVNFX09VVERFUFRIPSEwOnRoaXMuZGVmaW5lVmFsdWUuVVNFX09VVERFUFRIPSExLHRoaXMuZGVmaW5lVmFsdWUuVVNFX1BDRl9TSEFET1c9QS5zZXR0aW5nLnNoYWRvdy50eXBlPT1cIlBDRlwiLHRoaXMuZGVmaW5lVmFsdWUuVVNFX0hBUkRfU0hBRE9XPUEuc2V0dGluZy5zaGFkb3cudHlwZT09XCJIQVJEXCIsdGhpcy5kZWZpbmVWYWx1ZS5VU0VfU09GVF9TSEFET1c9QS5zZXR0aW5nLnNoYWRvdy50eXBlPT1cIlNPRlRcIix0aGlzLmRlZmluZVZhbHVlLlVTRV9DU009bHQuQ2FzY2FkZXM+MSx0aGlzLmRlZmluZVZhbHVlLlVTRV9JRVNfUFJPRklMRT1CaS51c2V9Z2VuUmVmbGVjdGlvbigpe3RoaXMuc2hhZGVyVmFyaWFudD1jdC5nZW5SZW5kZXJTaGFkZXJWYXJpYW50KHRoaXMpO2xldCBlPWN0LnBvb2xHZXRSZWZsZWN0aW9uKHRoaXMuc2hhZGVyVmFyaWFudCk7aWYoZSl0aGlzLnNoYWRlclJlZmxlY3Rpb249ZTtlbHNle2xldCB0PXV0LnBhcnNlKHRoaXMuX2Rlc3RWUyx0aGlzLmRlZmluZVZhbHVlKTt0PXV0LnBhcnNlKHQsdGhpcy5kZWZpbmVWYWx1ZSksY3QuZ2V0U2hhZGVyUmVmbGVjdGlvbjIodCx0aGlzKTtsZXQgcj11dC5wYXJzZSh0aGlzLl9kZXN0RlMsdGhpcy5kZWZpbmVWYWx1ZSk7cj11dC5wYXJzZShyLHRoaXMuZGVmaW5lVmFsdWUpLGN0LmdldFNoYWRlclJlZmxlY3Rpb24yKHIsdGhpcyksY3QuZmluYWwodGhpcyl9dGhpcy5zaGFkZXJTdGF0ZS5zcGxpdFRleHR1cmU9dGhpcy5zaGFkZXJSZWZsZWN0aW9uLnVzZVNwbGl0fWRlc3Ryb3koZSl7Zm9yKGNvbnN0IHQgaW4gdGhpcy50ZXh0dXJlcylpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50ZXh0dXJlcyx0KSl7Y29uc3Qgcj10aGlzLnRleHR1cmVzW3RdO2lmKHNlLmdldEluc3RhbmNlKCkuZGV0YWNoZWQocix0aGlzKSxlJiYhc2UuZ2V0SW5zdGFuY2UoKS5oYXNSZWZlcmVuY2Uocikpci5kZXN0cm95KGUpO2Vsc2V7ci5kZXN0cm95KCExKTtsZXQgcz1zZS5nZXRJbnN0YW5jZSgpLmdldFJlZmVyZW5jZShyKSxhPVtdO3MuZm9yRWFjaCgobixsKT0+e1wibmFtZVwiaW4gbj9hLnB1c2gobi5uYW1lKTphLnB1c2goXCJOYU5cIil9KX19dGhpcy5iaW5kR3JvdXBzLmxlbmd0aD0wLHRoaXMuc2hhZGVyU3RhdGU9bnVsbCx0aGlzLnRleHR1cmVzPW51bGwsdGhpcy5waXBlbGluZT1udWxsLHRoaXMuYmluZEdyb3VwTGF5b3V0cz1udWxsLHRoaXMuX3NvdXJjZVZTPW51bGwsdGhpcy5fc291cmNlRlM9bnVsbCx0aGlzLl9kZXN0VlM9bnVsbCx0aGlzLl9kZXN0RlM9bnVsbCx0aGlzLl92c1NoYWRlck1vZHVsZT1udWxsLHRoaXMuX2ZzU2hhZGVyTW9kdWxlPW51bGwsdGhpcy5tYXRlcmlhbERhdGFVbmlmb3JtQnVmZmVyLmRlc3Ryb3koZSksdGhpcy5tYXRlcmlhbERhdGFVbmlmb3JtQnVmZmVyPW51bGx9c3RhdGljIGRlc3Ryb3lTaGFkZXIoZSl7T3QucmVuZGVyU2hhZGVyLmhhcyhlKSYmKE90LnJlbmRlclNoYWRlci5nZXQoZSkuZGVzdHJveSgpLE90LnJlbmRlclNoYWRlci5kZWxldGUoZSkpfXN0YXRpYyBnZXRTaGFkZXIoZSl7cmV0dXJuIE90LnJlbmRlclNoYWRlci5nZXQoZSl9c3RhdGljIGNyZWF0ZVNoYWRlcihlLHQpe2xldCByPW5ldyBXZShlLHQpO3JldHVybiBPdC5yZW5kZXJTaGFkZXIuc2V0KHIuaW5zdGFuY2VJRCxyKSxyLmluc3RhbmNlSUR9fWNsYXNzIF9pe2NvbnN0cnVjdG9yKCl7byh0aGlzLFwibmFtZVwiKSxvKHRoaXMsXCJpbnN0YW5jZUlEXCIpLG8odGhpcyxcImVuYWJsZVwiLCEwKSxvKHRoaXMsXCJfZGVmYXVsdFBhc3NcIiksbyh0aGlzLFwiX3JlbmRlclBhc3Nlc1wiKSxvKHRoaXMsXCJfZGVwdGhDb21wYXJlXCIsdnQubGVzcyksdGhpcy5fcmVuZGVyUGFzc2VzPW5ldyBNYXB9Z2V0IGRlcHRoQ29tcGFyZSgpe3JldHVybiB0aGlzLl9kZXB0aENvbXBhcmV9c2V0IGRlcHRoQ29tcGFyZShlKXt0aGlzLl9kZXB0aENvbXBhcmU9ZSx0aGlzLl9kZWZhdWx0UGFzcy5kZXB0aENvbXBhcmU9ZX1nZXQgZGVmYXVsdFBhc3MoKXtyZXR1cm4gdGhpcy5fZGVmYXVsdFBhc3N9c2V0IGRlZmF1bHRQYXNzKGUpe3RoaXMuX2RlZmF1bHRQYXNzPWUsdGhpcy5hZGRQYXNzKHJlLkNPTE9SLGUpfWdldCBkb3VibGVTaWRlKCl7cmV0dXJuIHRoaXMuX2RlZmF1bHRQYXNzLmRvdWJsZVNpZGV9c2V0IGRvdWJsZVNpZGUoZSl7dGhpcy5fZGVmYXVsdFBhc3MuZG91YmxlU2lkZT1lfWdldCBjYXN0U2hhZG93KCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3Muc2hhZGVyU3RhdGUuY2FzdFNoYWRvd31zZXQgY2FzdFNoYWRvdyhlKXtsZXQgdD10aGlzLmRlZmF1bHRQYXNzO3Quc2hhZGVyU3RhdGUuY2FzdFNoYWRvdz1lfWdldCBibGVuZE1vZGUoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy5ibGVuZE1vZGV9c2V0IGJsZW5kTW9kZShlKXtsZXQgdD10aGlzLmRlZmF1bHRQYXNzO3QuYmxlbmRNb2RlPWV9Z2V0IHRyYW5zcGFyZW50KCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3Muc2hhZGVyU3RhdGUudHJhbnNwYXJlbnR9c2V0IHRyYW5zcGFyZW50KGUpe2xldCB0PXRoaXMuZGVmYXVsdFBhc3M7dC5zaGFkZXJTdGF0ZS50cmFuc3BhcmVudD1lLGUmJih0LnJlbmRlck9yZGVyPTNlMyl9Z2V0IGN1bGxNb2RlKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MuY3VsbE1vZGV9c2V0IGN1bGxNb2RlKGUpe2xldCB0PXRoaXMuZGVmYXVsdFBhc3M7dC5jdWxsTW9kZT1lfWhhc1Bhc3MoZSl7cmV0dXJuIHRoaXMuX3JlbmRlclBhc3Nlcy5oYXMoZSl9Z2V0UGFzcyhlKXtyZXR1cm4gdGhpcy5fcmVuZGVyUGFzc2VzLmdldChlKX1nZXRBbGxQYXNzKCl7cmV0dXJuIHRoaXMuX3JlbmRlclBhc3Nlcy5nZXQocmUuQ09MT1IpfWFkZFBhc3MoZSx0LHI9LTEpe3RoaXMuX3JlbmRlclBhc3Nlcy5oYXMoZSl8fHRoaXMuX3JlbmRlclBhc3Nlcy5zZXQoZSxbXSk7bGV0IHM9dGhpcy5fcmVuZGVyUGFzc2VzLmdldChlKTtyZXR1cm4gZT09cmUuQ09MT1ImJnMubGVuZ3RoPT0wJiYodGhpcy5fZGVmYXVsdFBhc3M9dCkscy5pbmRleE9mKHQpIT0tMXx8KHI9PS0xP3MucHVzaCh0KTpzLnNwbGljZShyLC0xLHQpKSxzfXJlbW92ZVBhc3MoZSx0KXtpZih0aGlzLl9yZW5kZXJQYXNzZXMuaGFzKGUpKXtsZXQgcj10aGlzLl9yZW5kZXJQYXNzZXMuZ2V0KGUpO3Q8ci5sZW5ndGgmJnIuc3BsaWNlKHQsMSl9fWNsb25lKCl7cmV0dXJuIG51bGx9ZGVzdHJveShlKXtmb3IoY29uc3QgdCBvZiB0aGlzLl9yZW5kZXJQYXNzZXMpe2xldCByPXRbMV07Zm9yKGNvbnN0IHMgb2Ygcilmb3IoY29uc3QgYSBpbiBzLnRleHR1cmVzKWEuaW5kZXhPZihcImRlZmF1bHRPcmlcIik9PS0xJiZzLnRleHR1cmVzW2FdLmRlc3Ryb3koZSl9fX1jbGFzcyBvcyBleHRlbmRzIF9pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKX1zZXREZWZhdWx0KCl7bGV0IGU9dGhpcy5kZWZhdWx0UGFzcztlLnNldFVuaWZvcm1GbG9hdChcInNoYWRvd0JpYXNcIiwzNWUtNSksZS5zZXRVbmlmb3JtVmVjdG9yNChcInRyYW5zZm9ybVVWMVwiLG5ldyBqKDAsMCwxLDEpKSxlLnNldFVuaWZvcm1WZWN0b3I0KFwidHJhbnNmb3JtVVYyXCIsbmV3IGooMCwwLDEsMSkpLGUuc2V0VW5pZm9ybUNvbG9yKFwiYmFzZUNvbG9yXCIsbmV3IHopLGUuc2V0VW5pZm9ybUNvbG9yKFwiZW1pc3NpdmVDb2xvclwiLG5ldyB6KDEsMSwxKSksZS5zZXRVbmlmb3JtVmVjdG9yNChcIm1hdGVyaWFsRjBcIixuZXcgaiguMDQsLjA0LC4wNCwxKSksZS5zZXRVbmlmb3JtRmxvYXQoXCJlbnZJbnRlbnNpdHlcIiwxKSxlLnNldFVuaWZvcm1GbG9hdChcIm5vcm1hbFNjYWxlXCIsMSksZS5zZXRVbmlmb3JtRmxvYXQoXCJyb3VnaG5lc3NcIiwxKSxlLnNldFVuaWZvcm1GbG9hdChcIm1ldGFsbGljXCIsMCksZS5zZXRVbmlmb3JtRmxvYXQoXCJhb1wiLDEpLGUuc2V0VW5pZm9ybUZsb2F0KFwicm91Z2huZXNzX21pblwiLDApLGUuc2V0VW5pZm9ybUZsb2F0KFwicm91Z2huZXNzX21heFwiLDEpLGUuc2V0VW5pZm9ybUZsb2F0KFwibWV0YWxsaWNfbWluXCIsMCksZS5zZXRVbmlmb3JtRmxvYXQoXCJtZXRhbGxpY19tYXhcIiwxKSxlLnNldFVuaWZvcm1GbG9hdChcImVtaXNzaXZlSW50ZW5zaXR5XCIsMCksZS5zZXRVbmlmb3JtRmxvYXQoXCJhbHBoYUN1dG9mZlwiLDApLGUuc2V0VW5pZm9ybUZsb2F0KFwiaW9yXCIsMS41KSxlLnNldFVuaWZvcm1GbG9hdChcImNsZWFyY29hdEZhY3RvclwiLDApLGUuc2V0VW5pZm9ybUZsb2F0KFwiY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yXCIsMCksZS5zZXRVbmlmb3JtQ29sb3IoXCJjbGVhcmNvYXRDb2xvclwiLG5ldyB6KDEsMSwxKSksZS5zZXRVbmlmb3JtRmxvYXQoXCJjbGVhcmNvYXRXZWlnaHRcIiwwKX1nZXQgYmFzZU1hcCgpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLmdldFRleHR1cmUoXCJiYXNlTWFwXCIpfXNldCBiYXNlTWFwKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VGV4dHVyZShcImJhc2VNYXBcIixlKX1nZXQgYmFzZUNvbG9yKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MuZ2V0VW5pZm9ybShcImJhc2VDb2xvclwiKX1zZXQgYmFzZUNvbG9yKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybUNvbG9yKFwiYmFzZUNvbG9yXCIsZSl9Z2V0IG5vcm1hbE1hcCgpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLmdldFRleHR1cmUoXCJub3JtYWxNYXBcIil9c2V0IG5vcm1hbE1hcChlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFRleHR1cmUoXCJub3JtYWxNYXBcIixlKX1nZXQgZG91YmxlU2lkZSgpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLmRvdWJsZVNpZGV9c2V0IGRvdWJsZVNpZGUoZSl7dGhpcy5kZWZhdWx0UGFzcy5kb3VibGVTaWRlPWV9Z2V0IGFscGhhQ3V0b2ZmKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3Muc2hhZGVyU3RhdGUuYWxwaGFDdXRvZmZ9c2V0IGFscGhhQ3V0b2ZmKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0RGVmaW5lKFwiVVNFX0FMUEhBQ1VUXCIsITApLHRoaXMuZGVmYXVsdFBhc3Muc2hhZGVyU3RhdGUuYWxwaGFDdXRvZmY9ZSx0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm0oXCJhbHBoYUN1dG9mZlwiLGUpfWdldCBlbWlzc2l2ZUNvbG9yKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MuZ2V0VW5pZm9ybShcImVtaXNzaXZlQ29sb3JcIil9c2V0IGVtaXNzaXZlQ29sb3IoZSl7dGhpcy5kZWZhdWx0UGFzcy5zZXRVbmlmb3JtKFwiZW1pc3NpdmVDb2xvclwiLGUpfWdldCBlbWlzc2l2ZUludGVuc2l0eSgpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLmdldFVuaWZvcm0oXCJlbWlzc2l2ZUludGVuc2l0eVwiKX1zZXQgZW1pc3NpdmVJbnRlbnNpdHkoZSl7dGhpcy5kZWZhdWx0UGFzcy5zZXRVbmlmb3JtKFwiZW1pc3NpdmVJbnRlbnNpdHlcIixlKX1nZXQgdXZUcmFuc2Zvcm1fMSgpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLnVuaWZvcm1zLnRyYW5zZm9ybVVWMS52ZWN0b3I0fXNldCB1dlRyYW5zZm9ybV8xKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybVZlY3RvcjQoXCJ0cmFuc2Zvcm1VVjFcIixlKX1nZXQgdXZUcmFuc2Zvcm1fMigpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLnVuaWZvcm1zLnRyYW5zZm9ybVVWMi52ZWN0b3I0fXNldCB1dlRyYW5zZm9ybV8yKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybVZlY3RvcjQoXCJ0cmFuc2Zvcm1VVjJcIixlKX1nZXQgZGVwdGhXcml0ZUVuYWJsZWQoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy5zaGFkZXJTdGF0ZS5kZXB0aFdyaXRlRW5hYmxlZH1zZXQgZGVwdGhXcml0ZUVuYWJsZWQoZSl7dGhpcy5kZWZhdWx0UGFzcy5zaGFkZXJTdGF0ZS5kZXB0aFdyaXRlRW5hYmxlZD1lfWdldCBtYXRlcmlhbEYwKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MudW5pZm9ybXMubWF0ZXJpYWxGMC52ZWN0b3I0fXNldCBtYXRlcmlhbEYwKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybVZlY3RvcjQoXCJtYXRlcmlhbEYwXCIsZSl9Z2V0IHJvdWdobmVzcygpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLnVuaWZvcm1zLnJvdWdobmVzcy52YWx1ZX1zZXQgcm91Z2huZXNzKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybUZsb2F0KFwicm91Z2huZXNzXCIsZSl9Z2V0IG1ldGFsbGljKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MudW5pZm9ybXMubWV0YWxsaWMudmFsdWV9c2V0IG1ldGFsbGljKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybUZsb2F0KFwibWV0YWxsaWNcIixlKX1nZXQgYW8oKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5hby52YWx1ZX1zZXQgYW8oZSl7dGhpcy5kZWZhdWx0UGFzcy5zZXRVbmlmb3JtRmxvYXQoXCJhb1wiLGUpfWdldCBtZXRhbGxpY19taW4oKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5tZXRhbGxpY19taW4udmFsdWV9c2V0IG1ldGFsbGljX21pbihlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcIm1ldGFsbGljX21pblwiLGUpfWdldCBtZXRhbGxpY19tYXgoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5tZXRhbGxpY19tYXgudmFsdWV9c2V0IG1ldGFsbGljX21heChlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcIm1ldGFsbGljX21heFwiLGUpfWdldCByb3VnaG5lc3NfbWluKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MudW5pZm9ybXMucm91Z2huZXNzX21pbi52YWx1ZX1zZXQgcm91Z2huZXNzX21pbihlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcInJvdWdobmVzc19taW5cIixlKX1nZXQgcm91Z2huZXNzX21heCgpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLnVuaWZvcm1zLnJvdWdobmVzc19tYXgudmFsdWV9c2V0IHJvdWdobmVzc19tYXgoZSl7dGhpcy5kZWZhdWx0UGFzcy5zZXRVbmlmb3JtRmxvYXQoXCJyb3VnaG5lc3NfbWF4XCIsZSl9Z2V0IG5vcm1hbFNjYWxlKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MudW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWV9c2V0IG5vcm1hbFNjYWxlKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybUZsb2F0KFwibm9ybWFsU2NhbGVcIixlKX1nZXQgbWFza01hcCgpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLnRleHR1cmVzLm1hc2tNYXB9c2V0IG1hc2tNYXAoZSl7dGhpcy5kZWZhdWx0UGFzcy5zZXREZWZpbmUoXCJVU0VfTVJcIiwhMCksdGhpcy5kZWZhdWx0UGFzcy5zZXRUZXh0dXJlKFwibWFza01hcFwiLGUpfXNldCBhb01hcChlKXtlJiYodGhpcy5kZWZhdWx0UGFzcy5zZXRUZXh0dXJlKFwiYW9NYXBcIixlKSxlIT1BLnJlcy53aGl0ZVRleHR1cmUmJnRoaXMuZGVmYXVsdFBhc3Muc2V0RGVmaW5lKFwiVVNFX0FPVEVYXCIsITApKX1nZXQgYW9NYXAoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy50ZXh0dXJlcy5hb01hcH1zZXQgY2xlYXJDb2F0Um91Z2huZXNzTWFwKGUpe2UmJihjb25zb2xlLmxvZyhcIlVTRV9DTEVBUkNPQVRfUk9VR0hORVNTXCIpLHRoaXMuZGVmYXVsdFBhc3Muc2V0VGV4dHVyZShcImNsZWFyQ29hdFJvdWdobmVzc01hcFwiLGUpLHRoaXMuZGVmYXVsdFBhc3Muc2V0RGVmaW5lKFwiVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NcIiwhMCkpfWdldCBjbGVhckNvYXRSb3VnaG5lc3NNYXAoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy50ZXh0dXJlcy5jbGVhckNvYXRSb3VnaG5lc3NNYXB9Z2V0IGJyZGZMVVQoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy50ZXh0dXJlcy5icmRmTFVUfXNldCBicmRmTFVUKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VGV4dHVyZShcImJyZGZMVVRcIixlKSx0aGlzLmRlZmF1bHRQYXNzLnNldFRleHR1cmUoXCJicmRmbHV0TWFwXCIsZSl9Z2V0IGVtaXNzaXZlTWFwKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MudGV4dHVyZXMuZW1pc3NpdmVNYXB9c2V0IGVtaXNzaXZlTWFwKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VGV4dHVyZShcImVtaXNzaXZlTWFwXCIsZSl9c2V0IGVudkludGVuc2l0eShlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcImVudkludGVuc2l0eVwiLGUpfWdldCBlbnZJbnRlbnNpdHkoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5lbnZJbnRlbnNpdHkudmFsdWV9c2V0IGlvcihlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcImlvclwiLGUpfWdldCBpb3IoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5pb3IudmFsdWV9dXNlQ2xlYW5Db2F0KCl7dGhpcy5kZWZhdWx0UGFzcy5zZXREZWZpbmUoXCJVU0VfQ0xFQVJDT0FUXCIsITApfXNldCBjbGVhcmNvYXRGYWN0b3IoZSl7dGhpcy5kZWZhdWx0UGFzcy5zZXRVbmlmb3JtRmxvYXQoXCJjbGVhcmNvYXRGYWN0b3JcIixlKSx0aGlzLnVzZUNsZWFuQ29hdCgpfWdldCBjbGVhcmNvYXRGYWN0b3IoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5jbGVhcmNvYXRGYWN0b3IudmFsdWV9c2V0IGNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcihlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcImNsZWFyY29hdFJvdWdobmVzc0ZhY3RvclwiLGUpLHRoaXMudXNlQ2xlYW5Db2F0KCl9Z2V0IGNsZWFyY29hdFJvdWdobmVzc0ZhY3Rvcigpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLnVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzc0ZhY3Rvci52YWx1ZX1zZXQgY2xlYXJjb2F0V2VpZ2h0KGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybUZsb2F0KFwiY2xlYXJjb2F0V2VpZ2h0XCIsZSksdGhpcy51c2VDbGVhbkNvYXQoKX1nZXQgY2xlYXJjb2F0V2VpZ2h0KCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MudW5pZm9ybXMuY2xlYXJjb2F0V2VpZ2h0LnZhbHVlfXNldCBjbGVhcmNvYXRDb2xvcihlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1Db2xvcihcImNsZWFyY29hdENvbG9yXCIsZSksdGhpcy51c2VDbGVhbkNvYXQoKX1nZXQgY2xlYXJjb2F0Q29sb3IoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5jbGVhcmNvYXRDb2xvci5jb2xvcn19Y2xhc3MgeWkgZXh0ZW5kcyBvc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7bGV0IGU9bmV3IFdlKFwiUEJSTEl0U2hhZGVyXCIsXCJQQlJMSXRTaGFkZXJcIik7dGhpcy5kZWZhdWx0UGFzcz1lLGUuc2V0U2hhZGVyRW50cnkoXCJWZXJ0TWFpblwiLFwiRnJhZ01haW5cIik7bGV0IHQ9ZS5zaGFkZXJTdGF0ZTt0LmFjY2VwdFNoYWRvdz0hMCx0LmNhc3RTaGFkb3c9ITAsdC5yZWNlaXZlRW52PSEwLHQuYWNjZXB0R0k9ITAsdC51c2VMaWdodD0hMDtsZXQgcj1BLnJlcy5nZXRUZXh0dXJlKFwiQlJERkxVVFwiKTt0aGlzLmJyZGZMVVQ9cixlLnNldERlZmluZShcIlVTRV9CUkRGXCIsITApLHRoaXMuc2V0RGVmYXVsdCgpLHRoaXMuYmFzZU1hcD1BLnJlcy53aGl0ZVRleHR1cmUsdGhpcy5ub3JtYWxNYXA9QS5yZXMubm9ybWFsVGV4dHVyZSx0aGlzLmVtaXNzaXZlTWFwPUEucmVzLmJsYWNrVGV4dHVyZSx0aGlzLmFscGhhQ3V0b2ZmPS41fWNsb25lKCl7bGV0IGU9bmV3IHlpLHQ9ZS5kZWZhdWx0UGFzcztyZXR1cm4gdC5zZXRVbmlmb3JtKFwic2hhZG93Qmlhc1wiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VW5pZm9ybShcInNoYWRvd0JpYXNcIikpLHQuc2V0VW5pZm9ybShcInRyYW5zZm9ybVVWMVwiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VW5pZm9ybShcInRyYW5zZm9ybVVWMVwiKSksdC5zZXRVbmlmb3JtKFwidHJhbnNmb3JtVVYyXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwidHJhbnNmb3JtVVYyXCIpKSx0LnNldFVuaWZvcm0oXCJiYXNlQ29sb3JcIix0aGlzLmRlZmF1bHRQYXNzLmdldFVuaWZvcm0oXCJiYXNlQ29sb3JcIikpLHQuc2V0VW5pZm9ybShcImVtaXNzaXZlQ29sb3JcIix0aGlzLmRlZmF1bHRQYXNzLmdldFVuaWZvcm0oXCJlbWlzc2l2ZUNvbG9yXCIpKSx0LnNldFVuaWZvcm0oXCJtYXRlcmlhbEYwXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwibWF0ZXJpYWxGMFwiKSksdC5zZXRVbmlmb3JtKFwiZW52SW50ZW5zaXR5XCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwiZW52SW50ZW5zaXR5XCIpKSx0LnNldFVuaWZvcm0oXCJub3JtYWxTY2FsZVwiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VW5pZm9ybShcIm5vcm1hbFNjYWxlXCIpKSx0LnNldFVuaWZvcm0oXCJyb3VnaG5lc3NcIix0aGlzLmRlZmF1bHRQYXNzLmdldFVuaWZvcm0oXCJyb3VnaG5lc3NcIikpLHQuc2V0VW5pZm9ybShcIm1ldGFsbGljXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwibWV0YWxsaWNcIikpLHQuc2V0VW5pZm9ybShcImFvXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwiYW9cIikpLHQuc2V0VW5pZm9ybShcInJvdWdobmVzc19taW5cIix0aGlzLmRlZmF1bHRQYXNzLmdldFVuaWZvcm0oXCJyb3VnaG5lc3NfbWluXCIpKSx0LnNldFVuaWZvcm0oXCJyb3VnaG5lc3NfbWF4XCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwicm91Z2huZXNzX21heFwiKSksdC5zZXRVbmlmb3JtKFwibWV0YWxsaWNfbWluXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwibWV0YWxsaWNfbWluXCIpKSx0LnNldFVuaWZvcm0oXCJtZXRhbGxpY19tYXhcIix0aGlzLmRlZmF1bHRQYXNzLmdldFVuaWZvcm0oXCJtZXRhbGxpY19tYXhcIikpLHQuc2V0VW5pZm9ybShcImVtaXNzaXZlSW50ZW5zaXR5XCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwiZW1pc3NpdmVJbnRlbnNpdHlcIikpLHQuc2V0VW5pZm9ybShcImFscGhhQ3V0b2ZmXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwiYWxwaGFDdXRvZmZcIikpLHQuc2V0VW5pZm9ybShcImlvclwiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VW5pZm9ybShcImlvclwiKSksdC5zZXRVbmlmb3JtKFwiY2xlYXJjb2F0RmFjdG9yXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwiY2xlYXJjb2F0RmFjdG9yXCIpKSx0LnNldFVuaWZvcm0oXCJjbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3JcIix0aGlzLmRlZmF1bHRQYXNzLmdldFVuaWZvcm0oXCJjbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3JcIikpLHQuc2V0VW5pZm9ybShcImNsZWFyY29hdENvbG9yXCIsdGhpcy5kZWZhdWx0UGFzcy5nZXRVbmlmb3JtKFwiY2xlYXJjb2F0Q29sb3JcIikpLHQuc2V0VW5pZm9ybShcImNsZWFyY29hdFdlaWdodFwiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VW5pZm9ybShcImNsZWFyY29hdFdlaWdodFwiKSksdC5zZXRUZXh0dXJlKFwiYmFzZU1hcFwiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VGV4dHVyZShcImJhc2VNYXBcIikpLHQuc2V0VGV4dHVyZShcIm5vcm1hbE1hcFwiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VGV4dHVyZShcIm5vcm1hbE1hcFwiKSksdC5zZXRUZXh0dXJlKFwiZW1pc3NpdmVNYXBcIix0aGlzLmRlZmF1bHRQYXNzLmdldFRleHR1cmUoXCJlbWlzc2l2ZU1hcFwiKSksdC5zZXRUZXh0dXJlKFwiYW9NYXBcIix0aGlzLmRlZmF1bHRQYXNzLmdldFRleHR1cmUoXCJhb01hcFwiKSksdC5zZXRUZXh0dXJlKFwibWFza01hcFwiLHRoaXMuZGVmYXVsdFBhc3MuZ2V0VGV4dHVyZShcIm1hc2tNYXBcIikpLGV9fWNsYXNzIEZvIGV4dGVuZHMgWHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcInRleHREYXRhXCIsXCJcIiksbyh0aGlzLFwic291cmNlX3ZlcnRpY2VzXCIpLG8odGhpcyxcInNvdXJjZV9ub3JtYWxzXCIpLG8odGhpcyxcInNvdXJjZV90YW5nZW50c1wiKSxvKHRoaXMsXCJzb3VyY2VfdGV4dHVyZUNvb3Jkc1wiKSxvKHRoaXMsXCJtYXRMaWJzXCIpLG8odGhpcyxcImdlb21ldHJ5c1wiKSxvKHRoaXMsXCJhY3RpdmVHZW9cIiksbyh0aGlzLFwiZmFjZXNNYXRlcmlhbHNJbmRleFwiKSxvKHRoaXMsXCJtdGxcIiksbyh0aGlzLFwibXRsVXJsXCIpfWFzeW5jIHBhcnNlU3RyaW5nKGUpe3JldHVybiB0aGlzLnNvdXJjZV92ZXJ0aWNlcz1bXSx0aGlzLnNvdXJjZV9ub3JtYWxzPVtdLHRoaXMuc291cmNlX3RhbmdlbnRzPVtdLHRoaXMuc291cmNlX3RleHR1cmVDb29yZHM9W10sdGhpcy5tYXRMaWJzPXt9LHRoaXMuZ2VvbWV0cnlzPXt9LHRoaXMudGV4dERhdGE9ZSxhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wYXJzZXJPQkooKSx0aGlzLmxvYWRNVEwoKV0pLHRoaXMucGFyc2VyX21lc2goKSxcIm51bGxcIn1hcHBseVZlY3RvcjIoZSx0LHIpe3RbZV0mJnRbZV0ubGVuZ3RoPjA/KHIucHVzaCh0W2VdWzBdKSxyLnB1c2godFtlXVsxXSkpOihyLnB1c2goMCksci5wdXNoKDApKX1hcHBseVZlY3RvcjMoZSx0LHIpe3IucHVzaCh0W2VdWzBdKSxyLnB1c2godFtlXVsxXSksci5wdXNoKHRbZV1bMl0pfWFwcGx5VmVjdG9yNChlLHQscil7ci5wdXNoKHRbZV1bMF0pLHIucHVzaCh0W2VdWzFdKSxyLnB1c2godFtlXVsyXSksci5wdXNoKHRbZV1bM10pfWFzeW5jIGxvYWRNVEwoKXtsZXQgdD1hd2FpdCBuZXcgaHQoKS5sb2FkVHh0KHRoaXMuYmFzZVVybCt0aGlzLm10bFVybCkscj10LmRhdGEscyxhPXIuc3BsaXQoYFxcclxuYCk7Zm9yKGxldCBoPTA7aDxhLmxlbmd0aDtoKyspe2xldCB1PWFbaF07dmFyIG49dS5pbmRleE9mKFwiI1wiKTtuIT0tMSYmKHU9dS5zdWJzdHJpbmcoMCxuKSksdT11LnRyaW0oKTt2YXIgbD11LnNwbGl0KC9cXHMrLyk7bFswXT09PVwibmV3bXRsXCI/KHM9e25hbWU6bFsxXX0sdGhpcy5tYXRMaWJzW2xbMV1dPXMpOmxbMF0uaW5kZXhPZihcIm1hcF9cIikhPS0xPyhzW2xbMF1dPWxbMV0scy50ZXh0dXJlc3x8KHMudGV4dHVyZXM9W2xbbC5sZW5ndGgtMV1dKSxzLnRleHR1cmVzLnB1c2gobFtsLmxlbmd0aC0xXSkpOmwubGVuZ3RoPT0yP3NbbFswXV09TnVtYmVyKGxbMV0pOmwubGVuZ3RoPT0zP3NbbFswXV09W051bWJlcihsWzFdKSxOdW1iZXIobFsyXSldOmwubGVuZ3RoPT00JiYoc1tsWzBdXT1bTnVtYmVyKGxbMV0pLE51bWJlcihsWzJdKSxOdW1iZXIobFszXSldKX1mb3IoY29uc3QgaCBpbiB0aGlzLm1hdExpYnMpe2NvbnN0IHU9dGhpcy5tYXRMaWJzW2hdO2lmKHUudGV4dHVyZXMmJnUudGV4dHVyZXMubGVuZ3RoPjApZm9yKGxldCBjPTA7Yzx1LnRleHR1cmVzLmxlbmd0aDtjKyspe2NvbnN0IGY9aXQubm9ybWFsaXplUGF0aCh0aGlzLmJhc2VVcmwrdS50ZXh0dXJlc1tjXSk7YXdhaXQgQS5yZXMubG9hZFRleHR1cmUoZil9fXJldHVybiB0PW51bGwsITB9YXN5bmMgbG9hZF90ZXh0dXJlcygpe31wYXJzZXJMaW5lKGUpe3ZhciB0PWUuaW5kZXhPZihcIiNcIik7aWYodCE9LTEpe2lmKGUuaW5kZXhPZihcIiMgb2JqZWN0XCIpIT0tMSl7dmFyIHI9ZS5zcGxpdCgvXFxzKy8pO2xldCBkPXJbMV0scD1yWzJdO3RoaXMuYWN0aXZlR2VvPXt0eXBlOmQsbmFtZTpwWzFdLHNvdXJjZV9tYXQ6XCJcIixzb3VyY2VfZmFjZXM6W119LHRoaXMuZ2VvbWV0cnlzW3BdPXRoaXMuYWN0aXZlR2VvfWU9ZS5zdWJzdHJpbmcoMCx0KX1lPWUudHJpbSgpO3ZhciByPWUuc3BsaXQoL1xccysvKTtpZihyWzBdPT09XCJ2XCIpe3ZhciBzPVtOdW1iZXIoclsxXSksTnVtYmVyKHJbMl0pLE51bWJlcihyWzNdKSxyWzRdPzE6TnVtYmVyKHJbNF0pXTt0aGlzLnNvdXJjZV92ZXJ0aWNlcy5wdXNoKHMpfWVsc2UgaWYoclswXT09PVwidnRcIil7dmFyIGE9W051bWJlcihyWzFdKSxOdW1iZXIoclsyXSksclszXT8xOk51bWJlcihyWzNdKV07dGhpcy5zb3VyY2VfdGV4dHVyZUNvb3Jkcy5wdXNoKGEpfWVsc2UgaWYoclswXT09PVwidm5cIil7dmFyIG49W051bWJlcihyWzFdKSxOdW1iZXIoclsyXSksTnVtYmVyKHJbM10pXTt0aGlzLnNvdXJjZV9ub3JtYWxzLnB1c2gobil9ZWxzZSBpZihyWzBdPT09XCJmXCIpe2Zvcih2YXIgbD17aW5kaWNlczpbXSx0ZXh0dXJlOltdLG5vcm1hbDpbXX0saD0xO2g8ci5sZW5ndGg7KytoKXt2YXIgdT1yW2hdLmluZGV4T2YoXCIvL1wiKSxjPXJbaF0uc3BsaXQoL1xcVysvKTt1PjA/KGwuaW5kaWNlcy5wdXNoKGNbMF0pLGwubm9ybWFsLnB1c2goY1sxXSkpOmMubGVuZ3RoPT09MT9sLmluZGljZXMucHVzaChjWzBdKTpjLmxlbmd0aD09PTI/KGwuaW5kaWNlcy5wdXNoKGNbMF0pLGwudGV4dHVyZS5wdXNoKGNbMV0pKTpjLmxlbmd0aD09PTMmJihsLmluZGljZXMucHVzaChjWzBdKSxsLnRleHR1cmUucHVzaChjWzFdKSxsLm5vcm1hbC5wdXNoKGNbMl0pKX10aGlzLmFjdGl2ZUdlby5zb3VyY2VfZmFjZXMucHVzaChsKX1lbHNlIHJbMF09PT1cInVzZW10bFwiP3RoaXMuYWN0aXZlR2VvLnNvdXJjZV9tYXQ9clsxXTpyWzBdPT09XCJtdGxsaWJcIiYmKHRoaXMubXRsVXJsPXJbMV0pfWFzeW5jIHBhcnNlck9CSigpe2xldCBlPXRoaXMudGV4dERhdGEuc3BsaXQoYFxcclxuYCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9ZVt0XTt0aGlzLnBhcnNlckxpbmUocil9cmV0dXJuIHRoaXMudGV4dERhdGE9XCJcIiwhMH1hc3luYyBwYXJzZXJfbWVzaCgpe2Zvcihjb25zdCBlIGluIHRoaXMuZ2VvbWV0cnlzKXtjb25zdCB0PXRoaXMuZ2VvbWV0cnlzW2VdO3QudmVydGV4X2Fycj1bXSx0Lm5vcm1hbF9hcnI9W10sdC51dl9hcnI9W10sdC5pbmRlaWNlX2Fycj1bXTtsZXQgcj0wO2ZvcihsZXQgYT0wO2E8dC5zb3VyY2VfZmFjZXMubGVuZ3RoO2ErKyl7Y29uc3Qgbj10LnNvdXJjZV9mYWNlc1thXTtsZXQgbD1wYXJzZUludChuLmluZGljZXNbMF0pLTEsaD1wYXJzZUludChuLmluZGljZXNbMV0pLTEsdT1wYXJzZUludChuLmluZGljZXNbMl0pLTEsYz1wYXJzZUludChuLm5vcm1hbFswXSktMSxmPXBhcnNlSW50KG4ubm9ybWFsWzFdKS0xLGQ9cGFyc2VJbnQobi5ub3JtYWxbMl0pLTEscD1wYXJzZUludChuLnRleHR1cmVbMF0pLTEsbT1wYXJzZUludChuLnRleHR1cmVbMV0pLTEsXz1wYXJzZUludChuLnRleHR1cmVbMl0pLTE7aWYodGhpcy5hcHBseVZlY3RvcjMobCx0aGlzLnNvdXJjZV92ZXJ0aWNlcyx0LnZlcnRleF9hcnIpLHRoaXMuYXBwbHlWZWN0b3IzKGMsdGhpcy5zb3VyY2Vfbm9ybWFscyx0Lm5vcm1hbF9hcnIpLHRoaXMuYXBwbHlWZWN0b3IyKHAsdGhpcy5zb3VyY2VfdGV4dHVyZUNvb3Jkcyx0LnV2X2FyciksdC5pbmRlaWNlX2FycltyXT1yKyssdGhpcy5hcHBseVZlY3RvcjMoaCx0aGlzLnNvdXJjZV92ZXJ0aWNlcyx0LnZlcnRleF9hcnIpLHRoaXMuYXBwbHlWZWN0b3IzKGYsdGhpcy5zb3VyY2Vfbm9ybWFscyx0Lm5vcm1hbF9hcnIpLHRoaXMuYXBwbHlWZWN0b3IyKG0sdGhpcy5zb3VyY2VfdGV4dHVyZUNvb3Jkcyx0LnV2X2FyciksdC5pbmRlaWNlX2FycltyXT1yKyssdGhpcy5hcHBseVZlY3RvcjModSx0aGlzLnNvdXJjZV92ZXJ0aWNlcyx0LnZlcnRleF9hcnIpLHRoaXMuYXBwbHlWZWN0b3IzKGQsdGhpcy5zb3VyY2Vfbm9ybWFscyx0Lm5vcm1hbF9hcnIpLHRoaXMuYXBwbHlWZWN0b3IyKF8sdGhpcy5zb3VyY2VfdGV4dHVyZUNvb3Jkcyx0LnV2X2FyciksdC5pbmRlaWNlX2FycltyXT1yKyssbi5pbmRpY2VzLmxlbmd0aD4zKXtsZXQgdj1wYXJzZUludChuLmluZGljZXNbM10pLTEseT1wYXJzZUludChuLm5vcm1hbFszXSktMSxDPXBhcnNlSW50KG4udGV4dHVyZVszXSktMTt0aGlzLmFwcGx5VmVjdG9yMyhsLHRoaXMuc291cmNlX3ZlcnRpY2VzLHQudmVydGV4X2FyciksdGhpcy5hcHBseVZlY3RvcjMoYyx0aGlzLnNvdXJjZV9ub3JtYWxzLHQubm9ybWFsX2FyciksdGhpcy5hcHBseVZlY3RvcjIocCx0aGlzLnNvdXJjZV90ZXh0dXJlQ29vcmRzLHQudXZfYXJyKSx0LmluZGVpY2VfYXJyW3JdPXIrKyx0aGlzLmFwcGx5VmVjdG9yMyh1LHRoaXMuc291cmNlX3ZlcnRpY2VzLHQudmVydGV4X2FyciksdGhpcy5hcHBseVZlY3RvcjMoZCx0aGlzLnNvdXJjZV9ub3JtYWxzLHQubm9ybWFsX2FyciksdGhpcy5hcHBseVZlY3RvcjIoXyx0aGlzLnNvdXJjZV90ZXh0dXJlQ29vcmRzLHQudXZfYXJyKSx0LmluZGVpY2VfYXJyW3JdPXIrKyx0aGlzLmFwcGx5VmVjdG9yMyh2LHRoaXMuc291cmNlX3ZlcnRpY2VzLHQudmVydGV4X2FyciksdGhpcy5hcHBseVZlY3RvcjMoeSx0aGlzLnNvdXJjZV9ub3JtYWxzLHQubm9ybWFsX2FyciksdGhpcy5hcHBseVZlY3RvcjIoQyx0aGlzLnNvdXJjZV90ZXh0dXJlQ29vcmRzLHQudXZfYXJyKSx0LmluZGVpY2VfYXJyW3JdPXIrK319bGV0IHM9bmV3IHRlO2Zvcihjb25zdCBhIGluIHRoaXMuZ2VvbWV0cnlzKXtjb25zdCBuPXRoaXMuZ2VvbWV0cnlzW2FdO2xldCBsPW5ldyB0dDtsLnNldEluZGljZXMobmV3IFVpbnQzMkFycmF5KG4uaW5kZWljZV9hcnIpKSxsLnNldEF0dHJpYnV0ZShZLnBvc2l0aW9uLG5ldyBGbG9hdDMyQXJyYXkobi52ZXJ0ZXhfYXJyKSksbC5zZXRBdHRyaWJ1dGUoWS5ub3JtYWwsbmV3IEZsb2F0MzJBcnJheShuLm5vcm1hbF9hcnIpKSxsLnNldEF0dHJpYnV0ZShZLnV2LG5ldyBGbG9hdDMyQXJyYXkobi51dl9hcnIpKSxsLnNldEF0dHJpYnV0ZShZLlRFWENPT1JEXzEsbmV3IEZsb2F0MzJBcnJheShuLnV2X2FycikpLGwuYWRkU3ViR2VvbWV0cnkoe2luZGV4U3RhcnQ6MCxpbmRleENvdW50Om4uaW5kZWljZV9hcnIubGVuZ3RoLHZlcnRleFN0YXJ0OjAsaW5kZXg6MH0pO2xldCBoPW5ldyB5aSx1PXRoaXMubWF0TGlic1tuLnNvdXJjZV9tYXRdO2guYmFzZU1hcD1BLnJlcy5nZXRUZXh0dXJlKGl0Lm5vcm1hbGl6ZVBhdGgodGhpcy5iYXNlVXJsK3UubWFwX0tkKSk7bGV0IGM9bmV3IHRlLGY9Yy5hZGRDb21wb25lbnQoY2UpO2YuZ2VvbWV0cnk9bCxmLm1hdGVyaWFsPWgscy5hZGRDaGlsZChjKX10aGlzLmRhdGE9c319dmVyaWZpY2F0aW9uKCl7aWYodGhpcy5kYXRhKXJldHVybiEwO3Rocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpfX1vKEZvLFwiZm9ybWF0XCIsXCJ0ZXh0XCIpO2xldCBidT1gXG4gICAgc3RydWN0IEltYWdlU2l6ZSB7XG4gICAgICAgIHNyY1dpZHRoOiBpMzIsXG4gICAgICAgICAgICBzcmNIZWlnaHQgOiBpMzIsXG4gICAgICAgICAgICAgICAgZHN0V2lkdGggOiBpMzIsXG4gICAgICAgICAgICAgICAgICAgIGRzdEhlaWdodCA6IGkzMixcbiAgICB9O1xuXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPnNpemUgOiBJbWFnZVNpemU7XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBpbnB1dFRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIG91dHB1dFRleHR1cmU6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhOHVub3JtLCB3cml0ZT47XG5cbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoOCwgOCwgMSlcbiAgICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcbiAgICAgICAgdmFyIHV2OiB2ZWMyPGYzMj4gPSB2ZWMyPGYzMj4oZjMyKEdsb2JhbEludm9jYXRpb25JRC54KSAvIGYzMihzaXplLmRzdFdpZHRoKSwgZjMyKEdsb2JhbEludm9jYXRpb25JRC55KSAvIGYzMihzaXplLmRzdEhlaWdodCkpO1xuICAgICAgICB1diA9IHV2ICogdmVjMjxmMzI+KGYzMihzaXplLnNyY1dpZHRoKSwgZjMyKHNpemUuc3JjSGVpZ2h0KSk7XG4gICAgICAgIHZhciBkc3RJZDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueCksIGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueSkpO1xuICAgICAgICB2YXIgc3JjSWQ6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPihpMzIoR2xvYmFsSW52b2NhdGlvbklELnggKiAydSksIGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueSAqIDJ1KSk7XG4gICAgICAgIHRleHR1cmVTdG9yZShvdXRwdXRUZXh0dXJlLCBkc3RJZCwgdGV4dHVyZUxvYWQoaW5wdXRUZXh0dXJlLCBzcmNJZCwgMCkpO1xuICAgIH1cbmAsU3U9YFxuICAgIHN0cnVjdCBJbWFnZVNpemUge1xuICAgICAgICBzcmNXaWR0aDogaTMyLFxuICAgICAgICAgICAgc3JjSGVpZ2h0IDogaTMyLFxuICAgICAgICAgICAgICAgIGRzdFdpZHRoIDogaTMyLFxuICAgICAgICAgICAgICAgICAgICBkc3RIZWlnaHQgOiBpMzIsXG4gICAgfTtcblxuICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT5zaXplIDogSW1hZ2VTaXplO1xuICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgaW5wdXRUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciBvdXRwdXRUZXh0dXJlOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTh1bm9ybSwgd3JpdGU+O1xuXG4gICAgZm4gcmVwZWF0X2kzMihpZDogaTMyLCBtYXg6IGkzMikgLT4gaTMyIHtcbiAgICAgICAgdmFyIHJldCA9IGlkO1xuICAgICAgICBpZiAoaWQgPCAwKSB7XG4gICAgICAgICAgICByZXQgPSBtYXggKyBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgPj0gbWF4KSB7XG4gICAgICAgICAgICByZXQgPSBpZCAtIG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZuIGNsYW1wX2kzMihpZDogaTMyLCBtYXg6IGkzMikgLT4gaTMyIHtcbiAgICAgICAgdmFyIHJldCA9IGlkO1xuICAgICAgICBpZiAoaWQgPCAwKSB7XG4gICAgICAgICAgICByZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCA+PSBtYXgpIHtcbiAgICAgICAgICAgIHJldCA9IG1heCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmbiBibHVyKGlkeDogdTMyKSAtPiB2ZWM0IDwgZjMyID4ge1xuICAgICAgICB2YXIgaWQ6IHZlYzI8aTMyPjtcbiAgICAgICAgaWQueSA9IGkzMihpZHgpIC8gc2l6ZS5zcmNXaWR0aDtcbiAgICAgICAgaWQueCA9IGkzMihpZHgpIC0gaTMyKGlkLnkpICogc2l6ZS5zcmNXaWR0aDtcbiAgICAgICAgdmFyIF9CbHVyU3ByZWFkOiBpMzIgPSAxO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdmVjNDxmMzI+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGxldCBnOiBhcnJheSA8IGYzMiwgM3UgPiA9IGFycmF5PGYzMiwgM3UgPiAoMC40MDI2LCAwLjI0NDIsIDAuMDU0NSk7XG4gICAgICAgIHZhciB1djogdmVjMjxpMzI+O1xuICAgICAgICBmb3IodmFyIGg6IGkzMiA9IDA7IGg8IDU7IGggPSBoICsgMSkge1xuICAgICAgICBsZXQgb2Zmc2V0VTogaTMyID0gKGggLSAyKSAqIF9CbHVyU3ByZWFkO1xuICAgICAgICB1di54ID0gaWQueCArIG9mZnNldFU7XG4gICAgICAgIHV2LnggPSBjbGFtcF9pMzIodXYueCwgc2l6ZS5zcmNXaWR0aCk7XG4gICAgICAgIGZvciAodmFyIHY6IGkzMiA9IDA7IHYgPCA1OyB2ID0gdiArIDEpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXRWOiBpMzIgPSAodiAtIDIpICogX0JsdXJTcHJlYWQ7XG4gICAgICAgICAgICB1di55ID0gaWQueSArIG9mZnNldFY7XG4gICAgICAgICAgICB1di55ID0gY2xhbXAodXYueSwgMCwgc2l6ZS5zcmNIZWlnaHQpO1xuICAgICAgICAgICAgbGV0IHdlaWdodFU6IGkzMiA9IGFicyhoIC0gMik7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0VjogaTMyID0gYWJzKHYgLSAyKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRXZWlnaHQ6IGYzMiA9IGdbd2VpZ2h0VV0gKiBnW3dlaWdodFZdO1xuICAgICAgICAgICAgdmFyIGNvbG9yZjMyOiB2ZWM0PGYzMj4gPSB0ZXh0dXJlTG9hZChpbnB1dFRleHR1cmUsIHV2LCAwKTtcbiAgICAgICAgICAgIGxldCBzYW1wbGVDb2xvcjogdmVjNDxmMzI+ID0gdmVjNDxmMzI+KGNvbG9yZjMyICogcmVzdWx0V2VpZ2h0KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHNhbXBsZUNvbG9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoOCwgOCwgMSlcbiAgICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcbiAgICAgICAgdmFyIHV2OiB2ZWMyPGYzMj4gPSB2ZWMyPGYzMj4oZjMyKEdsb2JhbEludm9jYXRpb25JRC54KSAvIGYzMihzaXplLmRzdFdpZHRoKSwgZjMyKEdsb2JhbEludm9jYXRpb25JRC55KSAvIGYzMihzaXplLmRzdEhlaWdodCkpO1xuICAgICAgICB1diA9IHV2ICogdmVjMjxmMzI+KGYzMihzaXplLnNyY1dpZHRoKSwgZjMyKHNpemUuc3JjSGVpZ2h0KSk7XG4gICAgICAgIGxldCBzcmNJZHggPSBpMzIodXYueSkgKiBzaXplLnNyY1dpZHRoICsgaTMyKHV2LngpO1xuICAgICAgICB2YXIgZHN0SWQ6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPihpMzIoR2xvYmFsSW52b2NhdGlvbklELngpLCBpMzIoR2xvYmFsSW52b2NhdGlvbklELnkpKTtcbiAgICAgICAgdGV4dHVyZVN0b3JlKG91dHB1dFRleHR1cmUsIGRzdElkLCBibHVyKHUzMihzcmNJZHgpKSk7XG4gICAgfVxuYDtjbGFzcyBJdXtzdGF0aWMgYmx1ckltYWdlRnJvbVRleHR1cmUoZSx0LHIscyl7Y29uc3QgYT1TLmRldmljZTtsZXQgbj1zP1N1OmJ1O2NvbnN0IGw9YS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2xheW91dDpcImF1dG9cIixjb21wdXRlOnttb2R1bGU6YS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6bn0pLGVudHJ5UG9pbnQ6XCJtYWluXCJ9fSksaD00KjQsdT1hLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpoLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk18R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KTthLnF1ZXVlLndyaXRlQnVmZmVyKHUsMCxuZXcgVWludDMyQXJyYXkoW2Uud2lkdGgsZS5oZWlnaHQsdCxyXSkpO2NvbnN0IGM9YS5jcmVhdGVUZXh0dXJlKHtzaXplOlt0LHIsMV0sbWlwTGV2ZWxDb3VudDoxLGZvcm1hdDpcInJnYmE4dW5vcm1cIix1c2FnZTpHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HfEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUfEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ3xHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQsbGFiZWw6XCJibHVySW1hZ2VGcm9tVGV4dHVyZVwifSk7bGV0IGY9W3tiaW5kaW5nOjAscmVzb3VyY2U6e2J1ZmZlcjp1LHNpemU6NCo0fX0se2JpbmRpbmc6MSxyZXNvdXJjZTplLmdwdVRleHR1cmUuY3JlYXRlVmlldyh7Zm9ybWF0OlwicmdiYTh1bm9ybVwiLGRpbWVuc2lvbjpcIjJkXCIsYmFzZU1pcExldmVsOjAsbWlwTGV2ZWxDb3VudDoxfSl9LHtiaW5kaW5nOjIscmVzb3VyY2U6Yy5jcmVhdGVWaWV3KHtmb3JtYXQ6XCJyZ2JhOHVub3JtXCIsZGltZW5zaW9uOlwiMmRcIixiYXNlTWlwTGV2ZWw6MCxtaXBMZXZlbENvdW50OjF9KX1dO2NvbnN0IGQ9YS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDpsLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOmZ9KSxwPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLG09cC5iZWdpbkNvbXB1dGVQYXNzKCk7cmV0dXJuIG0uc2V0UGlwZWxpbmUobCksbS5zZXRCaW5kR3JvdXAoMCxkKSxtLmRpc3BhdGNoV29ya2dyb3VwcyhNYXRoLmZsb29yKHQvOCksTWF0aC5mbG9vcihyLzgpKSxtLmVuZCgpLHcuZW5kQ29tbWFuZEVuY29kZXIocCksdS5kZXN0cm95KCksY319Y2xhc3MgWnMgZXh0ZW5kcyBhdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKDQsNCksbyh0aGlzLFwid2lkdGhcIiw0KSxvKHRoaXMsXCJoZWlnaHRcIiw0KSxvKHRoaXMsXCJkZXB0aE9yQXJyYXlMYXllcnNcIiw2KSxvKHRoaXMsXCJ2aXNpYmlsaXR5XCIsR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQpLG8odGhpcyxcInRleHR1cmVCaW5kaW5nTGF5b3V0XCIse3ZpZXdEaW1lbnNpb246XCJjdWJlXCIsbXVsdGlzYW1wbGVkOiExfSksbyh0aGlzLFwic2FtcGxlckJpbmRpbmdMYXlvdXRcIix7dHlwZTpcImZpbHRlcmluZ1wifSksdGhpcy5hZGRyZXNzTW9kZVU9QnQuY2xhbXBfdG9fZWRnZSx0aGlzLmFkZHJlc3NNb2RlVj1CdC5jbGFtcF90b19lZGdlLHRoaXMuYWRkcmVzc01vZGVXPUJ0LmNsYW1wX3RvX2VkZ2UsdGhpcy5tYWdGaWx0ZXI9dGhpcy5taW5GaWx0ZXI9XCJsaW5lYXJcIix0aGlzLm1pcG1hcEZpbHRlcj1cImxpbmVhclwiLHRoaXMudmlzaWJpbGl0eT1HUFVTaGFkZXJTdGFnZS5GUkFHTUVOVH1jcmVhdGVUZXh0dXJlRGVzY3JpcHRvcihlLHQscixzLGE9R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDfEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULG49MSl7dGhpcy53aWR0aD1lLHRoaXMuaGVpZ2h0PXQsdGhpcy5mb3JtYXQ9cyx0aGlzLnVzYWdlPWEsdGhpcy50ZXh0dXJlRGVzY3JpcHRvcj17c2l6ZTp7d2lkdGg6ZSxoZWlnaHQ6dCxkZXB0aE9yQXJyYXlMYXllcnM6Nn0sbWlwTGV2ZWxDb3VudDpyLGZvcm1hdDpzLHVzYWdlOmEsZGltZW5zaW9uOlwiMmRcIn0sbj4xP3RoaXMudmlld0Rlc2NyaXB0b3I9e2RpbWVuc2lvbjpcImN1YmUtYXJyYXlcIn06dGhpcy52aWV3RGVzY3JpcHRvcj17ZGltZW5zaW9uOnRoaXMudGV4dHVyZUJpbmRpbmdMYXlvdXQudmlld0RpbWVuc2lvbn19fWNvbnN0IEV1PWNsYXNze3N0YXRpYyBjcmVhdGVGYWNlKGksZSx0LHIpe2NvbnN0IHM9Uy5kZXZpY2U7dGhpcy5waXBlbGluZT09bnVsbCYmKHRoaXMucGlwZWxpbmU9cy5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2xheW91dDpcImF1dG9cIixjb21wdXRlOnttb2R1bGU6cy5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6RXUuY3JlYXRlQ3ViZX0pLGVudHJ5UG9pbnQ6XCJtYWluXCJ9fSkpO2NvbnN0IGE9dGhpcy5waXBlbGluZSxuPTQqNDt0aGlzLmNvbmZpZ0J1ZmZlcnx8KHRoaXMuY29uZmlnQnVmZmVyPXMuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuVU5JRk9STXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pKSxzLnF1ZXVlLndyaXRlQnVmZmVyKHRoaXMuY29uZmlnQnVmZmVyLDAsbmV3IFVpbnQzMkFycmF5KFtpLDAsMCwwXSkpLHRoaXMuYmx1clNldHRpbmdCdWZmZXJ8fCh0aGlzLmJsdXJTZXR0aW5nQnVmZmVyPXMuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuVU5JRk9STXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pKSxzLnF1ZXVlLndyaXRlQnVmZmVyKHRoaXMuYmx1clNldHRpbmdCdWZmZXIsMCxuZXcgRmxvYXQzMkFycmF5KFswLDAsMCwwXSkpO2xldCBsPVt7YmluZGluZzowLHJlc291cmNlOntidWZmZXI6dGhpcy5jb25maWdCdWZmZXIsc2l6ZTo0KjR9fSx7YmluZGluZzoxLHJlc291cmNlOnQuZ2V0R1BVVmlldygpfSx7YmluZGluZzoyLHJlc291cmNlOnIuZ2V0R1BVVmlldygpfV07Y29uc3QgaD1zLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OmEuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6bH0pLHU9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCksYz11LmJlZ2luQ29tcHV0ZVBhc3MoKTtjLnNldFBpcGVsaW5lKGEpLGMuc2V0QmluZEdyb3VwKDAsaCksYy5kaXNwYXRjaFdvcmtncm91cHMoZS84LGUvOCksYy5lbmQoKSx3LmVuZENvbW1hbmRFbmNvZGVyKHUpfX07bGV0IGhyPUV1O28oaHIsXCJjcmVhdGVDdWJlXCIsYFxuXG5zdHJ1Y3QgU2V0dGluZ1VuaWZvcm0ge1xuICBmYWNlSW5kZXggOiBpMzIsXG4gIHNyY0hlaWdodCA6IGkzMixcbiAgZHN0V2lkdGggOiBpMzIsXG4gIGRzdEhlaWdodCA6IGkzMlxufTtcblxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBzZXR0aW5nVW5pZm9ybSA6IFNldHRpbmdVbmlmb3JtO1xuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBpbnB1dFRleCA6IHRleHR1cmVfMmQ8ZjMyPjtcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXIgb3V0VGV4IDogdGV4dHVyZV9zdG9yYWdlXzJkPHJnYmE4dW5vcm0sIHdyaXRlPjtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDgsIDgsIDEpXG5mbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGNvb3JkID0gdmVjMjxpMzI+KEdsb2JhbEludm9jYXRpb25JRC54eSk7XG4gIFxuICBsZXQgb3V0VGV4U2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKG91dFRleCkueHk7XG4gIGxldCBvdXRUZXhlbCA9IDEuMCAvIHZlYzI8ZjMyPihvdXRUZXhTaXplIC0gMSk7XG4gIFxuICBsZXQgdXZfMCA9IHZlYzI8ZjMyPihjb29yZCkgKiBvdXRUZXhlbDtcbiAgdmFyIG9jID0gc2FtcGxlUGl4ZWwoc2V0dGluZ1VuaWZvcm0uZmFjZUluZGV4LCB1dl8wKTtcbiAgdGV4dHVyZVN0b3JlKG91dFRleCwgY29vcmQsIG9jKTtcbn1cblxuZm4gc2FtcGxlUGl4ZWwoZmFjZTppMzIsIHV2MDE6dmVjMjxmMzI+KSAtPiB2ZWM0PGYzMj4ge1xuICAgIGxldCByZWN0YW5nbGVfdjJfZjMyID0gcm91bmQodmVjMjxmMzI+KDAuMjUsIDAuMzMzMzMpICogdmVjMjxmMzI+KHRleHR1cmVEaW1lbnNpb25zKGlucHV0VGV4KS54eSkpO1xuICAgIGxldCByZWN0YW5nbGUgPSB2ZWMyPGkzMj4ocmVjdGFuZ2xlX3YyX2YzMik7XG4gICAgXG4gICAgdmFyIG9mZnNldEluZGV4ID0gdmVjMjxpMzI+KDApO1xuICAgIGlmKGZhY2UgPT0gMCl7XG4gICAgICAgIG9mZnNldEluZGV4LnggPSAyO1xuICAgICAgICBvZmZzZXRJbmRleC55ID0gMTtcbiAgICB9ZWxzZSBpZihmYWNlID09IDEpe1xuICAgICAgICBvZmZzZXRJbmRleC54ID0gMDtcbiAgICAgICAgb2Zmc2V0SW5kZXgueSA9IDE7XG4gICAgfWVsc2UgaWYoZmFjZSA9PSAyKXtcbiAgICAgICAgb2Zmc2V0SW5kZXgueCA9IDE7XG4gICAgICAgIG9mZnNldEluZGV4LnkgPSAwO1xuICAgIH1lbHNlIGlmKGZhY2UgPT0gMyl7XG4gICAgICAgIG9mZnNldEluZGV4LnggPSAxO1xuICAgICAgICBvZmZzZXRJbmRleC55ID0gMjtcbiAgICB9ZWxzZSBpZihmYWNlID09IDQpe1xuICAgICAgICBvZmZzZXRJbmRleC54ID0gMTtcbiAgICAgICAgb2Zmc2V0SW5kZXgueSA9IDE7XG4gICAgfWVsc2UgaWYoZmFjZSA9PSA1KXtcbiAgICAgICAgb2Zmc2V0SW5kZXgueCA9IDM7XG4gICAgICAgIG9mZnNldEluZGV4LnkgPSAxO1xuICAgIH1cbiAgICBcbiAgICBsZXQgY29vcmRPZmZzZXQgPSByZWN0YW5nbGUgKiBvZmZzZXRJbmRleDtcbiAgICBsZXQgY29vcmRJbmRleCA9IHZlYzI8aTMyPih2ZWMyPGYzMj4ocmVjdGFuZ2xlIC0gMSkgKiB1djAxKTtcbiAgICB2YXIgb2MgPSB0ZXh0dXJlTG9hZChpbnB1dFRleCwgY29vcmRPZmZzZXQgKyBjb29yZEluZGV4LCAwKTtcbiAgICByZXR1cm4gb2M7XG59XG5gKSxvKGhyLFwiY29uZmlnQnVmZmVyXCIsbnVsbCksbyhocixcImJsdXJTZXR0aW5nQnVmZmVyXCIsbnVsbCksbyhocixcInBpcGVsaW5lXCIpO2NsYXNzIGtvIGV4dGVuZHMgWnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcIl9pbWFnZXNcIiksbyh0aGlzLFwiX3VybFwiKSx0aGlzLnVzZU1pcG1hcD0hMH1nZW5lcmF0ZUltYWdlcyhlKXtsZXQgdD1TLmRldmljZTt0aGlzLndpZHRoPXRoaXMuaGVpZ2h0PTMyLFwid2lkdGhcImluIGVbMF0mJih0aGlzLndpZHRoPXRoaXMuaGVpZ2h0PWVbMF0ud2lkdGgpO2xldCByPU1hdGgubWluKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO2Zvcih0aGlzLm1pcG1hcENvdW50PTE7cj4xNjspci89Mix0aGlzLm1pcG1hcENvdW50Kys7dGhpcy50ZXh0dXJlQmluZGluZ0xheW91dC52aWV3RGltZW5zaW9uPVwiY3ViZVwiLHRoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cImZpbHRlcmluZ1wiLHRoaXMuY3JlYXRlVGV4dHVyZURlc2NyaXB0b3IodGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLm1pcG1hcENvdW50LHRoaXMuZm9ybWF0KSx0aGlzLnRleHR1cmVEZXNjcmlwdG9yLnNpemU9e3dpZHRoOnRoaXMud2lkdGgsaGVpZ2h0OnRoaXMuaGVpZ2h0LGRlcHRoT3JBcnJheUxheWVyczo2fSx0aGlzLnRleHR1cmVEZXNjcmlwdG9yLmRpbWVuc2lvbj1cIjJkXCIsdGhpcy5ncHVUZXh0dXJlPXQuY3JlYXRlVGV4dHVyZSh0aGlzLnRleHR1cmVEZXNjcmlwdG9yKTtsZXQgcz1bXSxhPXMsbj10aGlzLndpZHRoLGw9dGhpcy5oZWlnaHQ7aWYoZVswXWluc3RhbmNlb2YgYXQpe2ZvcihsZXQgaD0wO2g8NjtoKyspe2xldCB1PWVbaF07c1toXT11LmdldEdQVVRleHR1cmUoKX10aGlzLnVwbG9hZE1pcG1hcEdQVVRleHR1cmUoMCx0aGlzLndpZHRoLHRoaXMud2lkdGgscyl9ZWxzZXt0aGlzLnVwbG9hZEJhc2VJbWFnZXModGhpcy53aWR0aCxlKTtmb3IobGV0IGg9MDtoPDY7aCsrKXtsZXQgdT1uZXcgaWkoITEpO3UuZm9ybWF0PXRoaXMuZm9ybWF0LHUuc291cmNlPWVbaF0sc1toXT11LmdldEdQVVRleHR1cmUoKX19Zm9yKGxldCBoPTE7aDx0aGlzLm1pcG1hcENvdW50O2grKyl7YT1zLHM9W107bGV0IHU9e3dpZHRoOm4saGVpZ2h0OmwsZ3B1VGV4dHVyZTpudWxsfTtuPW4vMixsPWwvMjtmb3IobGV0IGM9MDtjPDY7YysrKXUuZ3B1VGV4dHVyZT1hW2NdLHNbY109SXUuYmx1ckltYWdlRnJvbVRleHR1cmUodSxuLGwsITEpO3RoaXMudXBsb2FkTWlwbWFwR1BVVGV4dHVyZShoLG4sbCxzKX10aGlzLmdwdVNhbXBsZXI9dC5jcmVhdGVTYW1wbGVyKHRoaXMpfXVwbG9hZEJhc2VJbWFnZXMoZSx0KXtsZXQgcj1TLmRldmljZTtjb25zdCBzPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO2ZvcihsZXQgYT0wO2E8NjthKyspci5xdWV1ZS5jb3B5RXh0ZXJuYWxJbWFnZVRvVGV4dHVyZSh7c291cmNlOnRbYV19LHt0ZXh0dXJlOnRoaXMuZ3B1VGV4dHVyZSxtaXBMZXZlbDowLG9yaWdpbjp7eDowLHk6MCx6OmF9fSx7d2lkdGg6ZSxoZWlnaHQ6ZSxkZXB0aE9yQXJyYXlMYXllcnM6MX0pO3cuZW5kQ29tbWFuZEVuY29kZXIocyl9dXBsb2FkTWlwbWFwR1BVVGV4dHVyZShlLHQscixzKXtjb25zdCBhPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO2ZvcihsZXQgbj0wO248NjtuKyspYS5jb3B5VGV4dHVyZVRvVGV4dHVyZSh7dGV4dHVyZTpzW25dLG1pcExldmVsOjAsb3JpZ2luOnt4OjAseTowLHo6MH19LHt0ZXh0dXJlOnRoaXMuZ3B1VGV4dHVyZSxtaXBMZXZlbDplLG9yaWdpbjp7eDowLHk6MCx6Om59fSx7d2lkdGg6dCxoZWlnaHQ6cixkZXB0aE9yQXJyYXlMYXllcnM6MX0pO3cuZW5kQ29tbWFuZEVuY29kZXIoYSl9Z2V0IGltYWdlcygpe3JldHVybiB0aGlzLl9pbWFnZXN9c2V0IGltYWdlcyhlKXtpZih0aGlzLl9pbWFnZXM9ZSx0aGlzLl9pbWFnZXNbMF1pbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpe2xldCB0PWZ1bmN0aW9uKG4sbCl7bC5kZWNvZGUoKS50aGVuKGFzeW5jKCk9PntyW25dPWF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGwpLHMtLSxzPT0wJiZhLmdlbmVyYXRlSW1hZ2VzKHIpfSl9LHI9W10scz02LGE9dGhpcztmb3IobGV0IG49MDtuPDY7bisrKXQobix0aGlzLl9pbWFnZXNbbl0pfWVsc2UodGhpcy5faW1hZ2VzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fHRoaXMuX2ltYWdlcyBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSYmdGhpcy5nZW5lcmF0ZUltYWdlcyh0aGlzLl9pbWFnZXMpfWFzeW5jIGxvYWQoZSl7dGhpcy5fdXJsPWU7bGV0IHQ9NixyPVtdO3RoaXMuZm9ybWF0PUcucmdiYTh1bm9ybTtsZXQgcz10aGlzO2FzeW5jIGZ1bmN0aW9uIGEobixsKXtjb25zdCBoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7aWYoaC5zcmM9bCxoLnNldEF0dHJpYnV0ZShcImNyb3NzT3JpZ2luXCIsXCJcIiksYXdhaXQgaC5kZWNvZGUoKSxyW25dPWF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGgpLHQtLSx0PT0wKXJldHVybiBzLmdlbmVyYXRlSW1hZ2VzKHIpLCEwfWZvcihsZXQgbj0wO248NjtuKyspYXdhaXQgYShuLGVbbl0pO3JldHVybiEwfWFzeW5jIGxvYWRTdGQoZSl7dGhpcy5fdXJsPWUsdGhpcy5mb3JtYXQ9Ry5yZ2JhOHVub3JtO2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTt0LnNyYz1lLHQuc2V0QXR0cmlidXRlKFwiY3Jvc3NPcmlnaW5cIixcIlwiKSxhd2FpdCB0LmRlY29kZSgpO2xldCByPW5ldyBpaSghMSk7ci5uYW1lPWl0LmdldFVSTE5hbWUoZSksci5mb3JtYXQ9XCJyZ2JhOHVub3JtXCIsci5zb3VyY2U9YXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAodCk7bGV0IHM9TWF0aC5yb3VuZChNYXRoLmxvZzIoci53aWR0aC80KSk7cz1NYXRoLnBvdygyLHMpLHRoaXMud2lkdGg9dGhpcy5oZWlnaHQ9cztsZXQgYT1bXTtmb3IobGV0IG49MDtuPDY7bisrKXtsZXQgbD1uZXcgb2UocyxzLHRoaXMuZm9ybWF0LCExLEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDfEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcpO2wubmFtZT1cImZhY2UgXCIrbixhLnB1c2gobCksaHIuY3JlYXRlRmFjZShuLHRoaXMud2lkdGgscixsKX1yZXR1cm4gdGhpcy5nZW5lcmF0ZUltYWdlcyhhKSwhMH19dmFyIEJ1PShpPT4oaVtpLkxlZnQ9MF09XCJMZWZ0XCIsaVtpLlJpZ2h0PTFdPVwiUmlnaHRcIixpW2kuQm90dG9tPTJdPVwiQm90dG9tXCIsaVtpLlRvcD0zXT1cIlRvcFwiLGlbaS5CYWNrPTRdPVwiQmFja1wiLGlbaS5Gcm9udD01XT1cIkZyb250XCIsaSkpKEJ1fHx7fSk7Y2xhc3Mgem97c3RhdGljIGdldFJvdGF0aW9uVG9GYWNlKGUpe2xldCB0PXEuaWRlbnRpdHkoKS5jbG9uZSgpLHI9bmV3IGcscz1uZXcgVigpLmlkZW50aXR5KCksYT1uZXcgZztzd2l0Y2goZSl7Y2FzZSAzOnIuc2V0KDAsLTEsMCksYS5zZXQoMCwwLC0xKTticmVhaztjYXNlIDI6ci5zZXQoMCwxLDApLGEuc2V0KDAsMCwxKTticmVhaztjYXNlIDE6ci5zZXQoMSwwLDApLGEuc2V0KDAsMSwwKTticmVhaztjYXNlIDA6ci5zZXQoLTEsMCwwKSxhLnNldCgwLDEsMCk7YnJlYWs7Y2FzZSA0OnIuc2V0KDAsMCwtMSksYS5zZXQoMCwxLDApO2JyZWFrO2Nhc2UgNTpyZXR1cm4gcS5pZGVudGl0eSgpfXJldHVybiBzLmxvb2tBdChuZXcgZyxyLGEpLHQuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHMpLHR9fWxldCBUdT1gXG4gIHN0cnVjdCBJbWFnZVNpemUge1xuICAgIHNyY1dpZHRoIDogaTMyLFxuICAgIHNyY0hlaWdodCA6IGkzMixcbiAgICBkc3RXaWR0aCA6IGkzMixcbiAgICBkc3RIZWlnaHQgOiBpMzJcbiAgfTtcblxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHNpemUgOiBJbWFnZVNpemU7XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSxyZWFkX3dyaXRlPiBmYWNlUm90YXRpb246IGFycmF5PHZlYzQ8ZjMyPj47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXIgaW5wdXRUZXhTYW1wbGVyIDogc2FtcGxlcjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhciBpbnB1dFRleCA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICBAZ3JvdXAoMSkgQGJpbmRpbmcoMCkgdmFyIG91dHB1dEJ1ZmZlcjAgOiB0ZXh0dXJlX3N0b3JhZ2VfMmRfYXJyYXk8cmdiYTE2ZmxvYXQsIHdyaXRlPjtcblxuICBmbiBTYW1wbGVTcGhlcmljYWxNYXAodjogdmVjMzxmMzI+KSAtPiB2ZWMyPGYzMj4ge1xuICAgICAgdmFyIHV2OnZlYzI8ZjMyPiA9IHZlYzI8ZjMyPihhdGFuMih2LnosIHYueCksIGFzaW4odi55KSk7XG4gICAgICAvL3V2ID0gKHV2ICogKHZlYzI8ZjMyPigwLjE1OTA5OTk5NjA4OTkzNTMsIDAuMzE4MzAwMDA4NzczODAzNykgKyB2ZWMyPGYzMj4oMC4wMDEwMDAwMDAwNDc0OTc0NTEzKSkpO1xuICAgICAgdXYgPSB1diAqIHZlYzI8ZjMyPigwLjE1OTA5OTk5NjA4OTkzNTMsIDAuMzE4MzAwMDA4NzczODAzNyk7XG4gICAgICB1diA9IHV2ICsgdmVjMjxmMzI+KDAuNSk7XG4gICAgICB1diA9IGNsYW1wKHV2LCB2ZWMyPGYzMj4oMC4wKSwgdmVjMjxmMzI+KDEuMCkpO1xuICAgICAgcmV0dXJuIHV2O1xuICB9XG5cblxuICBmbiBhcHBseVF1YXRlcm5pb24ocG9zaXRpb246dmVjMzxmMzI+LCBxOnZlYzQ8ZjMyPikgLT4gdmVjMzxmMzI+e1xuICAgICAgbGV0IHg6ZjMyID0gcG9zaXRpb24ueDtcbiAgICAgIGxldCB5OmYzMiA9IHBvc2l0aW9uLnk7XG4gICAgICBsZXQgejpmMzIgPSBwb3NpdGlvbi56O1xuXG4gICAgICBsZXQgcXg6ZjMyID0gcS54O1xuICAgICAgbGV0IHF5OmYzMiA9IHEueTtcbiAgICAgIGxldCBxejpmMzIgPSBxLno7XG4gICAgICBsZXQgcXc6ZjMyID0gcS53O1xuXG4gICAgICBsZXQgaXg6ZjMyID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgICAgbGV0IGl5OmYzMiA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgICAgIGxldCBpejpmMzIgPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gICAgICBsZXQgaXc6ZjMyID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgICAgdmFyIHJldDogdmVjMzxmMzI+O1xuICAgICAgcmV0LnggPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgICAgcmV0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgICAgcmV0LnogPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuXG4gICAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZm4gY29udmVydElkVG9EaXIzKHV2X2kzMjp2ZWMyPGkzMj4sIHF1YXRlcm5pb246dmVjNDxmMzI+KSAtPiB2ZWMzPGYzMj57XG4gICAgICB2YXIgdXZfZjMyOnZlYzI8ZjMyPiA9IHZlYzI8ZjMyPih1dl9pMzIueHkpO1xuICAgICAgdmFyIGhhbGZTaXplOmYzMiA9IGYzMihzaXplLmRzdFdpZHRoIC8gMikgLSAwLjU7XG4gICAgICB2YXIgd29ybGREaXJlY3Rpb246dmVjMzxmMzI+ID0gdmVjMzxmMzI+KHV2X2YzMi54IC0gaGFsZlNpemUsIHV2X2YzMi55IC0gaGFsZlNpemUsIC1oYWxmU2l6ZSk7XG4gICAgICB3b3JsZERpcmVjdGlvbiA9IG5vcm1hbGl6ZSh3b3JsZERpcmVjdGlvbik7XG4gICAgICB3b3JsZERpcmVjdGlvbiA9IGFwcGx5UXVhdGVybmlvbih3b3JsZERpcmVjdGlvbiwgcXVhdGVybmlvbik7XG4gICAgICByZXR1cm4gd29ybGREaXJlY3Rpb247XG4gIH1cblxuICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoOCwgOCwgMSlcbiAgZm4gbWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSW52b2NhdGlvbklEIDogdmVjMzx1MzI+KSB7XG4gICAgbGV0IGNvb3JkID0gdmVjMjxpMzI+KEdsb2JhbEludm9jYXRpb25JRC54eSk7XG4gICAgbGV0IHF1YXRlcm5pb24gPSBmYWNlUm90YXRpb25bR2xvYmFsSW52b2NhdGlvbklELnpdO1xuICAgIHZhciB3b3JsZERpcmVjdGlvbjp2ZWMzPGYzMj4gPSBjb252ZXJ0SWRUb0RpcjMoY29vcmQsIHF1YXRlcm5pb24pO1xuICAgIGxldCB1dl9mMzI6dmVjMjxmMzI+ID0gU2FtcGxlU3BoZXJpY2FsTWFwKHdvcmxkRGlyZWN0aW9uKTtcbiAgICBsZXQgb2MgPSB0ZXh0dXJlU2FtcGxlTGV2ZWwoaW5wdXRUZXgsIGlucHV0VGV4U2FtcGxlciwgdXZfZjMyICwgMC4wKTtcbiAgICB0ZXh0dXJlU3RvcmUob3V0cHV0QnVmZmVyMCwgY29vcmQsIGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueiksIG9jKTtcbiAgfVxuYCxNdT1gXG4gIHN0cnVjdCBJbWFnZVNpemUge1xuICAgIHNyY1dpZHRoIDogaTMyLFxuICAgIHNyY0hlaWdodCA6IGkzMixcbiAgICBkc3RXaWR0aCA6IGkzMixcbiAgICBkc3RIZWlnaHQgOiBpMzJcbiAgfTtcblxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHNpemUgOiBJbWFnZVNpemU7XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gdGV4X2luOiBhcnJheTx2ZWM0PGYzMj4+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIG91dHB1dEJ1ZmZlciA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuXG4gIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSg4LCA4LCAxKVxuICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgZnJhZ0Nvb3JkID0gdmVjMjxpMzI+KGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueCksIGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueSkpO1xuICAgIHZhciBvYzp2ZWM0PGYzMj4gPSB0ZXhfaW5bZnJhZ0Nvb3JkLnkgKiBzaXplLnNyY1dpZHRoICsgZnJhZ0Nvb3JkLnhdIC8gMjU2LjA7XG4gICAgdmFyIGUgPSBwb3coMi4wLCBvYy53ICogMjU1LjAgLSAxMjguMCk7XG4gICAgb2MgPSBvYyAqIGU7XG4gICAgb2MgPSBzY2FsZUJ5VGhyZXNob2xkKG9jLCA0MC4wKTtcbiAgICB0ZXh0dXJlU3RvcmUob3V0cHV0QnVmZmVyLCBmcmFnQ29vcmQgLCB2ZWM0PGYzMj4ob2MueHl6LCAxLjApICk7XG4gIH1cblxuICBmbiBzY2FsZUJ5VGhyZXNob2xkKGNvbG9yOnZlYzQ8ZjMyPiwgdGhyZXNob2xkOmYzMikgLT4gdmVjNDxmMzI+e1xuICAgIHZhciBvYyA9IGNvbG9yO1xuICAgIGxldCBicmlnaHRuZXNzID0gbGVuZ3RoKHZlYzM8ZjMyPihvYy54eXopKTtcbiAgICB2YXIgc2NhbGUgPSBicmlnaHRuZXNzIC8gdGhyZXNob2xkO1xuICAgIGlmKHNjYWxlID4gMS4wKXtcbiAgICAgICAgc2NhbGUgPSAxLjAgLyBwb3coc2NhbGUsIDAuNyk7XG4gICAgICAgIG9jID0gb2MgKiBzY2FsZTtcbiAgICB9XG4gICAgb2MuYSA9IDEuMDtcbiAgICByZXR1cm4gb2M7XG4gIH1cbmA7Y29uc3QgSXQ9Y2xhc3N7c3RhdGljIGNvbnZlcnRSR0JFMlJHQkEoaSxlKXtjb25zdCB0PVMuZGV2aWNlLHI9dC5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2xheW91dDpcImF1dG9cIixjb21wdXRlOnttb2R1bGU6dC5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6TXV9KSxlbnRyeVBvaW50OlwibWFpblwifX0pLHM9dC5jcmVhdGVCdWZmZXIoe3NpemU6NCo0LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk18R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KTt0LnF1ZXVlLndyaXRlQnVmZmVyKHMsMCxuZXcgVWludDMyQXJyYXkoW2kud2lkdGgsaS5oZWlnaHQsaS53aWR0aCxpLmhlaWdodF0pKTtjb25zdCBhPXQuY3JlYXRlQnVmZmVyKHtzaXplOmUuYnl0ZUxlbmd0aCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSk7dC5xdWV1ZS53cml0ZUJ1ZmZlcihhLDAsZSk7bGV0IG49W3tiaW5kaW5nOjAscmVzb3VyY2U6e2J1ZmZlcjpzLHNpemU6NCo0fX0se2JpbmRpbmc6MSxyZXNvdXJjZTp7YnVmZmVyOmEsc2l6ZTplLmJ5dGVMZW5ndGh9fSx7YmluZGluZzoyLHJlc291cmNlOmkuZ2V0R1BVVmlldygpfV07Y29uc3QgbD10LmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnIuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6bn0pLGg9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCksdT1oLmJlZ2luQ29tcHV0ZVBhc3MoKTt1LnNldFBpcGVsaW5lKHIpLHUuc2V0QmluZEdyb3VwKDAsbCksdS5kaXNwYXRjaFdvcmtncm91cHMoTWF0aC5mbG9vcihpLndpZHRoLzgpLE1hdGguZmxvb3IoaS5oZWlnaHQvOCkpLHUuZW5kKCksdy5lbmRDb21tYW5kRW5jb2RlcihoKSxzLmRlc3Ryb3koKX1zdGF0aWMgbWFrZVRleHR1cmVDdWJlKGksZSx0KXtjb25zdCByPVMuZGV2aWNlO0l0Lm1ha2VGYWNlVGV4dHVyZVBpcGVsaW5lfHwoSXQubWFrZUZhY2VUZXh0dXJlUGlwZWxpbmU9ci5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2xheW91dDpcImF1dG9cIixjb21wdXRlOnttb2R1bGU6ci5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6VHV9KSxlbnRyeVBvaW50OlwibWFpblwifX0pKTtjb25zdCBzPUl0Lm1ha2VGYWNlVGV4dHVyZVBpcGVsaW5lLGE9NCo0O0l0LmNvbmZpZ0J1ZmZlcnx8KEl0LmNvbmZpZ0J1ZmZlcj1yLmNyZWF0ZUJ1ZmZlcih7c2l6ZTphLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk18R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSksci5xdWV1ZS53cml0ZUJ1ZmZlcihJdC5jb25maWdCdWZmZXIsMCxuZXcgVWludDMyQXJyYXkoW2kud2lkdGgsaS5oZWlnaHQsZSxlXSkpO2NvbnN0IG49NCo2O2lmKCFJdC5xdWF0ZXJuaW9uQnVmZmVyKXtJdC5xdWF0ZXJuaW9uQnVmZmVyPXIuY3JlYXRlQnVmZmVyKHtzaXplOm4qNCo2LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KTtsZXQgcD1uZXcgRmxvYXQzMkFycmF5KDQqNik7Zm9yKGxldCBtPTA7bTw2O20rKyl7bGV0IF89em8uZ2V0Um90YXRpb25Ub0ZhY2UobSk7cFttKjQrMF09Xy54LHBbbSo0KzFdPV8ueSxwW20qNCsyXT1fLnoscFttKjQrM109Xy53fXIucXVldWUud3JpdGVCdWZmZXIoSXQucXVhdGVybmlvbkJ1ZmZlciwwLHApfWxldCBsPVt7YmluZGluZzowLHJlc291cmNlOntidWZmZXI6SXQuY29uZmlnQnVmZmVyLHNpemU6NCo0fX0se2JpbmRpbmc6MSxyZXNvdXJjZTp7YnVmZmVyOkl0LnF1YXRlcm5pb25CdWZmZXIsc2l6ZTpuKjR9fSx7YmluZGluZzoyLHJlc291cmNlOmkuZ3B1U2FtcGxlcn0se2JpbmRpbmc6MyxyZXNvdXJjZTppLmdldEdQVVZpZXcoKX1dLGg9W3tiaW5kaW5nOjAscmVzb3VyY2U6dH1dO2NvbnN0IHU9ci5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDpzLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOmx9KSxjPXIuY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6cy5nZXRCaW5kR3JvdXBMYXlvdXQoMSksZW50cmllczpofSksZj13LmJlZ2luQ29tbWFuZEVuY29kZXIoKSxkPWYuYmVnaW5Db21wdXRlUGFzcygpO2Quc2V0UGlwZWxpbmUocyksZC5zZXRCaW5kR3JvdXAoMCx1KSxkLnNldEJpbmRHcm91cCgxLGMpLGQuZGlzcGF0Y2hXb3JrZ3JvdXBzKGUvOCxlLzgsNiksZC5lbmQoKSx3LmVuZENvbW1hbmRFbmNvZGVyKGYpfX07bGV0IERpPUl0O28oRGksXCJtYWtlRmFjZVRleHR1cmVQaXBlbGluZVwiKSxvKERpLFwiY29uZmlnQnVmZmVyXCIpLG8oRGksXCJxdWF0ZXJuaW9uQnVmZmVyXCIpO2NsYXNzIEdvIGV4dGVuZHMgYXR7Y29uc3RydWN0b3IoKXtzdXBlcigzMiwzMixudWxsKSx0aGlzLmlzSERSVGV4dHVyZT0hMH1jcmVhdGUoZT0zMix0PTMyLHI9bnVsbCxzPSEwKXt0aGlzLndpZHRoPWUsdGhpcy5oZWlnaHQ9dDtsZXQgYT1TLmRldmljZTtjb25zdCBuPTIsbD1lKjQqbjtsZXQgaD1yO3RoaXMuZm9ybWF0PUcucmdiYTE2ZmxvYXQsdGhpcy51c2VNaXBtYXA9cyx0aGlzLnVwZGF0ZVRleHR1cmVEZXNjcmlwdGlvbigpLHRoaXMudXBkYXRlR1BVVGV4dHVyZSgpO2NvbnN0IHU9YS5jcmVhdGVCdWZmZXIoe3NpemU6aC5ieXRlTGVuZ3RoLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSk7YS5xdWV1ZS53cml0ZUJ1ZmZlcih1LDAsaCk7Y29uc3QgYz13LmJlZ2luQ29tbWFuZEVuY29kZXIoKTtyZXR1cm4gYy5jb3B5QnVmZmVyVG9UZXh0dXJlKHtidWZmZXI6dSxieXRlc1BlclJvdzpsfSx7dGV4dHVyZTp0aGlzLmdldEdQVVRleHR1cmUoKX0se3dpZHRoOmUsaGVpZ2h0OnQsZGVwdGhPckFycmF5TGF5ZXJzOjF9KSx3LmVuZENvbW1hbmRFbmNvZGVyKGMpLHRoaXMudXNlTWlwbWFwfHwodGhpcy5zYW1wbGVyQmluZGluZ0xheW91dC50eXBlPVwiZmlsdGVyaW5nXCIsdGhpcy50ZXh0dXJlQmluZGluZ0xheW91dC5zYW1wbGVUeXBlPVwiZmxvYXRcIiksdGhpcy5ncHVTYW1wbGVyPWEuY3JlYXRlU2FtcGxlcih0aGlzKSx0aGlzfWFzeW5jIGxvYWQoZSx0KXtyZXR1cm4oYXdhaXQgbmV3IGh0KCkubG9hZChlLCRzLHQpKS5nZXRIRFJUZXh0dXJlKCl9fWNvbnN0IER1PW5ldyBGbG9hdDMyQXJyYXkoMSksUWc9bmV3IEludDMyQXJyYXkoRHUuYnVmZmVyKTtsZXQgdXI9ZnVuY3Rpb24oaSl7RHVbMF09aTtjb25zdCBlPVFnWzBdO2xldCB0PWU+PjE2JjMyNzY4LHI9ZT4+MTImMjA0Nztjb25zdCBzPWU+PjIzJjI1NTtyZXR1cm4gczwxMDM/dDpzPjE0Mj8odHw9MzE3NDQsdHw9KHM9PTI1NT8xOjApJiZlJjgzODg2MDcsdCk6czwxMTQ/KHJ8PTIwNDgsdHw9KHI+PjExNC1zKSsocj4+MTEzLXMmMSksdCk6KHR8PXMtMTEyPDwxMHxyPj4xLHQrPXImMSx0KX07dmFyIFB1PShpPT4oaVtpLlJHQkVfUkVUVVJOX0ZBSUxVUkU9LTFdPVwiUkdCRV9SRVRVUk5fRkFJTFVSRVwiLGlbaS5yZ2JlX3JlYWRfZXJyb3I9MV09XCJyZ2JlX3JlYWRfZXJyb3JcIixpW2kucmdiZV93cml0ZV9lcnJvcj0yXT1cInJnYmVfd3JpdGVfZXJyb3JcIixpW2kucmdiZV9mb3JtYXRfZXJyb3I9M109XCJyZ2JlX2Zvcm1hdF9lcnJvclwiLGlbaS5yZ2JlX21lbW9yeV9lcnJvcj00XT1cInJnYmVfbWVtb3J5X2Vycm9yXCIsaSkpKFB1fHx7fSk7Y2xhc3MgUW97Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJ2YWxpZFwiKSxvKHRoaXMsXCJzdHJpbmdcIiksbyh0aGlzLFwiY29tbWVudHNcIiksbyh0aGlzLFwicHJvZ3JhbXR5cGVcIiksbyh0aGlzLFwiZm9ybWF0XCIpLG8odGhpcyxcImdhbW1hXCIpLG8odGhpcyxcImV4cG9zdXJlXCIpLG8odGhpcyxcIndpZHRoXCIpLG8odGhpcyxcImhlaWdodFwiKX19Y2xhc3MgJHMgZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwiX3JnYmVBcnJheVwiKSxvKHRoaXMsXCJfd2lkdGhcIiksbyh0aGlzLFwiX2hlaWdodFwiKSxvKHRoaXMsXCJfUkdCRV9SRVRVUk5fRkFJTFVSRVwiLC0xKSxvKHRoaXMsXCJfcGFyc2VyVHlwZVwiLEcucmdiYTh1aW50KX1wYXJzZUJ1ZmZlcihlKXtsZXQgdCxyPW5ldyBVaW50OEFycmF5KGUpO3IucG9zPTA7Y29uc3Qgcz10aGlzLnBhc2VySGVhZGVyKHIpO2lmKHMgaW5zdGFuY2VvZiBRbyl7Y29uc3QgYT10aGlzLl93aWR0aD1zLndpZHRoLG49dGhpcy5faGVpZ2h0PXMuaGVpZ2h0O2xldCBsPXRoaXMucGFyc2VyUGl4ZWwoci5zdWJhcnJheShyLnBvcyksYSxuKTtpZihsIGluc3RhbmNlb2YgVWludDhBcnJheSl7c3dpdGNoKHRoaXMuX3JnYmVBcnJheT1sLHRoaXMuX3BhcnNlclR5cGUpe31yZXR1cm4gdGhpcy5kYXRhPXQsdH19cmV0dXJuIG51bGx9dmVyaWZpY2F0aW9uKCl7aWYodGhpcy5kYXRhJiZ0aGlzLmRhdGEgaW5zdGFuY2VvZiBhdClyZXR1cm4hMDtpZih0aGlzLl9yZ2JlQXJyYXkpcmV0dXJuITA7dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIil9Z2V0VGV4dHVyZSgpe3JldHVybiB0aGlzLmRhdGF9Z2V0Q3ViZVRleHR1cmUoKXtsZXQgZT10aGlzLl93aWR0aC80O3JldHVybiBuZXcgZWEoKS5jcmVhdGVGcm9tSERSRGF0YShlLHt3aWR0aDp0aGlzLl93aWR0aCxoZWlnaHQ6dGhpcy5faGVpZ2h0LGFycmF5OnRoaXMuX3JnYmVBcnJheX0pfWdldEhEUlRleHR1cmUoKXtyZXR1cm4gbmV3IEdvKCkuY3JlYXRlKHRoaXMuX3dpZHRoLHRoaXMuX2hlaWdodCx0aGlzLl9yZ2JlQXJyYXkpfXBhcnNlRXJyb3IoZSx0KXtzd2l0Y2goZSl7Y2FzZSAxOmNvbnNvbGUuZXJyb3IoXCJSZWFkIEVycm9yOiBcIisodHx8XCJcIikpO2JyZWFrO2Nhc2UgMjpjb25zb2xlLmVycm9yKFwiV3JpdGUgRXJyb3I6IFwiKyh0fHxcIlwiKSk7YnJlYWs7Y2FzZSAzOmNvbnNvbGUuZXJyb3IoXCJCYWQgRmlsZSBGb3JtYXQ6IFwiKyh0fHxcIlwiKSk7YnJlYWs7ZGVmYXVsdDpjYXNlIDQ6Y29uc29sZS5lcnJvcihcIkVycm9yOiBcIisodHx8XCJcIikpfXJldHVybi0xfXBhcnNlckJsb2NrKGUsdCxyKXt0PXR8fDEwMjQ7bGV0IGE9ZS5wb3Msbj0tMSxsPTAsaD1cIlwiLHU9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50MTZBcnJheShlLnN1YmFycmF5KGEsYSsxMjgpKSk7Y29uc3QgYz1gXG5gO2Zvcig7MD4obj11LmluZGV4T2YoYykpJiZsPHQmJmE8ZS5ieXRlTGVuZ3RoOyloKz11LGwrPXUubGVuZ3RoLGErPTEyOCx1Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQxNkFycmF5KGUuc3ViYXJyYXkoYSxhKzEyOCkpKTtyZXR1cm4tMTxuPyhyIT09ITEmJihlLnBvcys9bCtuKzEpLGgrdS5zbGljZSgwLG4pKTohMX1wYXNlckhlYWRlcihlKXtjb25zdCB0PS9eI1xcPyhcXFMrKS8scj0vXlxccypHQU1NQVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8scz0vXlxccypFWFBPU1VSRVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8sYT0vXlxccypGT1JNQVQ9KFxcUyspXFxzKiQvLG49L15cXHMqXFwtWVxccysoXFxkKylcXHMrXFwrWFxccysoXFxkKylcXHMqJC8sbD1uZXcgUW87bGV0IGgsdTtpZihlLnBvcz49ZS5ieXRlTGVuZ3RofHwhKGg9dGhpcy5wYXJzZXJCbG9jayhlKSkpcmV0dXJuIHRoaXMucGFyc2VFcnJvcigxLFwibm8gaGVhZGVyIGZvdW5kXCIpO2lmKCEodT1oLm1hdGNoKHQpKSlyZXR1cm4gdGhpcy5wYXJzZUVycm9yKDMsXCJiYWQgaW5pdGlhbCB0b2tlblwiKTtjb25zdCBjPTEsZj0yLGQ9NDtmb3IobC52YWxpZHw9YyxsLnByb2dyYW10eXBlPXVbMV0sbC5zdHJpbmcrPWgrYFxuYDtoPXRoaXMucGFyc2VyQmxvY2soZSksaCE9PSExOyl7aWYobC5zdHJpbmcrPWgrYFxuYCxoLmNoYXJBdCgwKT09PVwiI1wiKXtsLmNvbW1lbnRzKz1oK2BcbmA7Y29udGludWV9aWYoKHU9aC5tYXRjaChyKSkmJihsLmdhbW1hPU1hdGguZmxvb3IocGFyc2VGbG9hdCh1WzFdKSoxMCkvMTApLCh1PWgubWF0Y2gocykpJiYobC5leHBvc3VyZT1NYXRoLmZsb29yKHBhcnNlRmxvYXQodVsxXSkqMTApLzEwKSwodT1oLm1hdGNoKGEpKSYmKGwudmFsaWR8PWYsbC5mb3JtYXQ9dVsxXSksKHU9aC5tYXRjaChuKSkmJihsLnZhbGlkfD1kLGwuaGVpZ2h0PXBhcnNlSW50KHVbMV0sMTApLGwud2lkdGg9cGFyc2VJbnQodVsyXSwxMCkpLGwudmFsaWQmZiYmbC52YWxpZCZkKWJyZWFrfXJldHVybiBsLnZhbGlkJmY/bC52YWxpZCZkP2w6KHRoaXMucGFyc2VFcnJvcigzLFwibWlzc2luZyBpbWFnZSBzaXplIHNwZWNpZmllclwiKSxudWxsKToodGhpcy5wYXJzZUVycm9yKDMsXCJtaXNzaW5nIGZvcm1hdCBzcGVjaWZpZXJcIiksbnVsbCl9cGFyc2VyUGl4ZWwoZSx0LHIpe2NvbnN0IHM9dDtpZihzPDh8fHM+MzI3Njd8fGVbMF0hPT0yfHxlWzFdIT09Mnx8ZVsyXSYxMjgpcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO2lmKHMhPT0oZVsyXTw8OHxlWzNdKSlyZXR1cm4gdGhpcy5wYXJzZUVycm9yKDMsXCJ3cm9uZyBzY2FubGluZSB3aWR0aFwiKTtjb25zdCBhPW5ldyBVaW50OEFycmF5KDQqdCpyKTtpZighYS5sZW5ndGgpcmV0dXJuIHRoaXMucGFyc2VFcnJvcig0LFwidW5hYmxlIHRvIGFsbG9jYXRlIGJ1ZmZlciBzcGFjZVwiKTtsZXQgbj0wLGw9MDtjb25zdCBoPTQqcyx1PW5ldyBVaW50OEFycmF5KDQpLGM9bmV3IFVpbnQ4QXJyYXkoaCk7bGV0IGY9cjtmb3IoO2Y+MCYmbDxlLmJ5dGVMZW5ndGg7KXtpZihsKzQ+ZS5ieXRlTGVuZ3RoKXJldHVybiB0aGlzLnBhcnNlRXJyb3IoMSxcIlwiKTtpZih1WzBdPWVbbCsrXSx1WzFdPWVbbCsrXSx1WzJdPWVbbCsrXSx1WzNdPWVbbCsrXSx1WzBdIT0yfHx1WzFdIT0yfHwodVsyXTw8OHx1WzNdKSE9cylyZXR1cm4gdGhpcy5wYXJzZUVycm9yKDMsXCJiYWQgcmdiZSBzY2FubGluZSBmb3JtYXRcIik7bGV0IGQ9MCxwO2Zvcig7ZDxoJiZsPGUuYnl0ZUxlbmd0aDspe3A9ZVtsKytdO2NvbnN0IF89cD4xMjg7aWYoXyYmKHAtPTEyOCkscD09PTB8fGQrcD5oKXJldHVybiB0aGlzLnBhcnNlRXJyb3IoMyxcImJhZCBzY2FubGluZSBkYXRhXCIpO2lmKF8pe2NvbnN0IHY9ZVtsKytdO2ZvcihsZXQgeT0wO3k8cDt5KyspY1tkKytdPXZ9ZWxzZSBjLnNldChlLnN1YmFycmF5KGwsbCtwKSxkKSxkKz1wLGwrPXB9Y29uc3QgbT1zO2ZvcihsZXQgXz0wO188bTtfKyspe2xldCB2PTA7YVtuXT1jW18rdl0sdis9cyxhW24rMV09Y1tfK3ZdLHYrPXMsYVtuKzJdPWNbXyt2XSx2Kz1zLGFbbiszXT1jW18rdl0sbis9NH1mLS19cmV0dXJuIGF9cmJnZVRvRmxvYXQoZSx0LHIscyl7Y29uc3QgYT1lW3QrM10sbj1NYXRoLnBvdygyLGEtMTI4KS8yNTU7cltzKzBdPWVbdCswXSpuLHJbcysxXT1lW3QrMV0qbixyW3MrMl09ZVt0KzJdKm4scltzKzNdPTF9cmJnZVRvSGFsZkZsb2F0KGUsdCxyLHMpe2NvbnN0IGE9ZVt0KzNdLG49TWF0aC5wb3coMixhLTEyOCkvMjU1O3JbcyswXT11cihlW3QrMF0qbikscltzKzFdPXVyKGVbdCsxXSpuKSxyW3MrMl09dXIoZVt0KzJdKm4pLHJbcyszXT11cigxKX19bygkcyxcImZvcm1hdFwiLFwiYmluXCIpO2xldCBSdT1gXG4gICAgc3RydWN0IEltYWdlU2l6ZSB7XG4gICAgICAgIHNyY1dpZHRoIDogaTMyLFxuICAgICAgICBzcmNIZWlnaHQgOiBpMzIsXG4gICAgICAgIGRzdFdpZHRoIDogaTMyLFxuICAgICAgICBkc3RIZWlnaHQgOiBpMzJcbiAgICB9O1xuICAgIFxuICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gc2l6ZSA6IEltYWdlU2l6ZTtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UscmVhZF93cml0ZT4gZmFjZVJvdGF0aW9uOiBhcnJheTx2ZWM0PGYzMj4+O1xuICAgIEBncm91cCgwKSBAYmluZGluZygyKSB2YXIgaW5wdXRUZXhTYW1wbGVyIDogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyIGlucHV0VGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICAgIFxuICAgIEBncm91cCgxKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gYmx1clNldHRpbmcgOiB2ZWM0PGYzMj47XG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKDEpIHZhciBvdXRwdXRCdWZmZXIwIDogdGV4dHVyZV9zdG9yYWdlXzJkX2FycmF5PHJnYmExNmZsb2F0LCB3cml0ZT47XG4gICAgXG4gICAgdmFyPHByaXZhdGU+IFBJOiBmMzIgPSAzLjE0MTU5MjY1MzU5O1xuICAgIFxuICAgIGZuIGFwcGx5UXVhdGVybmlvbihwb3NpdGlvbjp2ZWMzPGYzMj4sIHE6dmVjNDxmMzI+KSAtPiB2ZWMzPGYzMj57XG4gICAgICAgIGxldCB4OmYzMiA9IHBvc2l0aW9uLng7XG4gICAgICAgIGxldCB5OmYzMiA9IHBvc2l0aW9uLnk7XG4gICAgICAgIGxldCB6OmYzMiA9IHBvc2l0aW9uLno7XG4gICAgXG4gICAgICAgIGxldCBxeDpmMzIgPSBxLng7XG4gICAgICAgIGxldCBxeTpmMzIgPSBxLnk7XG4gICAgICAgIGxldCBxejpmMzIgPSBxLno7XG4gICAgICAgIGxldCBxdzpmMzIgPSBxLnc7XG4gICAgXG4gICAgICAgIGxldCBpeDpmMzIgPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgICAgIGxldCBpeTpmMzIgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgICAgIGxldCBpejpmMzIgPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gICAgICAgIGxldCBpdzpmMzIgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuICAgIFxuICAgICAgICB2YXIgcmV0OiB2ZWMzPGYzMj47XG4gICAgICAgIHJldC54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICAgICAgcmV0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgICAgICByZXQueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFxuICAgIGZuIGNvbnZlcnRJZFRvRGlyMyh1dl9pMzI6dmVjMjxpMzI+LCBxdWF0ZXJuaW9uOnZlYzQ8ZjMyPikgLT4gdmVjMzxmMzI+e1xuICAgICAgICB2YXIgdXZfZjMyOnZlYzI8ZjMyPiA9IHZlYzI8ZjMyPih1dl9pMzIueHkpO1xuICAgICAgICB2YXIgaGFsZlNpemU6ZjMyID0gZjMyKHNpemUuZHN0V2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHdvcmxkRGlyZWN0aW9uOnZlYzM8ZjMyPiA9IHZlYzM8ZjMyPih1dl9mMzIueCAtIGhhbGZTaXplLCB1dl9mMzIueSAtIGhhbGZTaXplLCAtaGFsZlNpemUpO1xuICAgICAgICB3b3JsZERpcmVjdGlvbiA9IG5vcm1hbGl6ZSh3b3JsZERpcmVjdGlvbik7XG4gICAgICAgIHdvcmxkRGlyZWN0aW9uID0gYXBwbHlRdWF0ZXJuaW9uKHdvcmxkRGlyZWN0aW9uLCBxdWF0ZXJuaW9uKTtcbiAgICAgICAgcmV0dXJuIHdvcmxkRGlyZWN0aW9uO1xuICAgIH1cbiAgICBcbiAgICBmbiBWYW5EZXJDb3JwdXMobjA6dTMyLCBiYXNlMDp1MzIpIC0+IGYzMlxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBuMDtcbiAgICAgICAgdmFyIGJhc2UgPSBiYXNlMDtcbiAgICAgICAgdmFyIGludkJhc2U6ZjMyID0gMS4wIC8gZjMyKGJhc2UpO1xuICAgICAgICB2YXIgZGVub206ZjMyICAgPSAxLjA7XG4gICAgICAgIHZhciByZXN1bHQ6ZjMyICA9IDAuMDtcbiAgICBcbiAgICAgICAgZm9yKHZhciBpOnUzMiA9IDB1OyBpIDwgMzJ1OyBpID0gaSArIDF1KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihuID4gMHUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVub20gICA9IGYzMihuKSAlIDIuMDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBkZW5vbSAqIGludkJhc2U7XG4gICAgICAgICAgICAgICAgaW52QmFzZSA9IGludkJhc2UgLyAyLjA7XG4gICAgICAgICAgICAgICAgbiAgICAgICA9IHUzMihmMzIobikgLyAyLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFxuICAgIGZuIEhhbW1lcnNsZXlOb0JpdE9wcyhpOnUzMiwgTjp1MzIpIC0+IHZlYzI8ZjMyPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZlYzIoZjMyKGkpL2YzMihOKSwgVmFuRGVyQ29ycHVzKGksIDJ1KSk7XG4gICAgfVxuICAgIFxuICAgIGZuIGhhbW1lcnNsZXkoIGkgOiB1MzIgLCAgTiA6IHUzMiApIC0+IHZlYzI8ZjMyPlxuICAgIHtcbiAgICAgICAgLy8gUmFkaWNhbCBpbnZlcnNlIGJhc2VkIG9uIGh0dHA6Ly9ob2xnZXIuZGFtbWVydHoub3JnL3N0dWZmL25vdGVzX0hhbW1lcnNsZXlPbkhlbWlzcGhlcmUuaHRtbFxuICAgICAgICB2YXIgYml0cyA9IChpIDw8IDE2dSkgfCAoaSA+PiAxNnUpO1xuICAgICAgICBiaXRzID0gKChiaXRzICYgMHg1NTU1NTU1NXUpIDw8IDF1KSB8ICgoYml0cyAmIDB4QUFBQUFBQUF1KSA+PiAxdSk7XG4gICAgICAgIGJpdHMgPSAoKGJpdHMgJiAweDMzMzMzMzMzdSkgPDwgMnUpIHwgKChiaXRzICYgMHhDQ0NDQ0NDQ3UpID4+IDJ1KTtcbiAgICAgICAgYml0cyA9ICgoYml0cyAmIDB4MEYwRjBGMEZ1KSA8PCA0dSkgfCAoKGJpdHMgJiAweEYwRjBGMEYwdSkgPj4gNHUpO1xuICAgICAgICBiaXRzID0gKChiaXRzICYgMHgwMEZGMDBGRnUpIDw8IDh1KSB8ICgoYml0cyAmIDB4RkYwMEZGMDB1KSA+PiA4dSk7XG4gICAgICAgIHZhciByZGkgPSBmMzIoYml0cykgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwO1xuICAgICAgICByZXR1cm4gdmVjMjxmMzI+KGYzMihpKSAvZjMyKE4pLCByZGkpO1xuICAgIH1cbiAgICBcbiAgICBmbiBJbXBvcnRhbmNlU2FtcGxlR0dYKCBYaTp2ZWMyPGYzMj4sIE46dmVjMzxmMzI+LCByb3VnaG5lc3M6ZjMyKSAtPnZlYzM8ZjMyPlxuICAgIHtcbiAgICAgICAgdmFyIGEgPSByb3VnaG5lc3Mqcm91Z2huZXNzO1xuICAgIFxuICAgICAgICB2YXIgcGhpID0gMi4wICogUEkgKiBYaS54O1xuICAgICAgICB2YXIgY29zVGhldGEgPSBzcXJ0KCgxLjAgLSBYaS55KSAvICgxLjAgKyAoYSphIC0gMS4wKSAqIFhpLnkpKTtcbiAgICAgICAgdmFyIHNpblRoZXRhID0gc3FydCgxLjAgLSBjb3NUaGV0YSpjb3NUaGV0YSk7XG4gICAgXG4gICAgICAgIC8vIGZyb20gc3BoZXJpY2FsIGNvb3JkaW5hdGVzIHRvIGNhcnRlc2lhbiBjb29yZGluYXRlc1xuICAgICAgICB2YXIgSDp2ZWMzPGYzMj47XG4gICAgICAgIEgueCA9IGNvcyhwaGkpICogc2luVGhldGE7XG4gICAgICAgIEgueSA9IHNpbihwaGkpICogc2luVGhldGE7XG4gICAgICAgIEgueiA9IGNvc1RoZXRhO1xuICAgIFxuICAgICAgICAvLyBmcm9tIHRhbmdlbnQtc3BhY2UgdmVjdG9yIHRvIHdvcmxkLXNwYWNlIHNhbXBsZSB2ZWN0b3JcbiAgICAgICAgdmFyIHVwOnZlYzM8ZjMyPjtcbiAgICAgICAgaWYoYWJzKE4ueikgPCAwLjk5OSlcbiAgICAgICAge1xuICAgICAgICAgICAgdXAgPSB2ZWMzPGYzMj4oMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB1cCA9IHZlYzM8ZjMyPigxLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFuZ2VudDp2ZWMzPGYzMj4gID0gbm9ybWFsaXplKGNyb3NzKHVwLCBOKSk7XG4gICAgICAgIHZhciBiaXRhbmdlbnQ6dmVjMzxmMzI+ID0gY3Jvc3MoTiwgdGFuZ2VudCk7XG4gICAgICAgIHZhciBzYW1wbGVWZWM6dmVjMzxmMzI+ID0gdGFuZ2VudCAqIEgueCArIGJpdGFuZ2VudCAqIEgueSArIE4gKiBILno7XG4gICAgICAgIHJldHVybiBub3JtYWxpemUoc2FtcGxlVmVjKTtcbiAgICB9XG4gICAgXG4gICAgZm4gbXVsdGlTYW1wbGUobG9jYWxQb3M6dmVjMzxmMzI+LCByb3VnaG5lc3M6ZjMyKSAtPiB2ZWM0PGYzMj5cbiAgICB7XG4gICAgICAgIHZhciBOOiB2ZWMzPGYzMj4gPSBub3JtYWxpemUobG9jYWxQb3MpO1xuICAgICAgICB2YXIgUjogdmVjMzxmMzI+ID0gTjtcbiAgICAgICAgdmFyIFY6IHZlYzM8ZjMyPiA9IFI7XG4gICAgXG4gICAgICAgIGxldCBTQU1QTEVfQ09VTlQ6dTMyID0gMTAyNHU7XG4gICAgICAgIHZhciB0b3RhbFdlaWdodDpmMzIgPSAwLjA7XG4gICAgICAgIHZhciBwcmVmaWx0ZXJlZENvbG9yOnZlYzM8ZjMyPiA9IHZlYzM8ZjMyPigwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yKHZhciBpOnUzMiA9IDB1OyBpIDwgU0FNUExFX0NPVU5UOyBpID0gaSArIDF1KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgWGk6dmVjMjxmMzI+ID0gaGFtbWVyc2xleShpLCBTQU1QTEVfQ09VTlQpO1xuICAgICAgICAgICAgdmFyIEggOnZlYzM8ZjMyPiA9IEltcG9ydGFuY2VTYW1wbGVHR1goWGksIE4sIHJvdWdobmVzcyk7XG4gICAgICAgICAgICB2YXIgTCA6dmVjMzxmMzI+ID0gbm9ybWFsaXplKDIuMCAqIGRvdChWLCBIKSAqIEggLSBWKTtcbiAgICBcbiAgICAgICAgICAgIHZhciBOZG90TDpmMzIgPSBtYXgoZG90KE4sIEwpLCAwLjApO1xuICAgICAgICAgICAgaWYoTmRvdEwgPiAwLjApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dCA9IDEuMCA7Ly8oIGYzMihTQU1QTEVfQ09VTlQgLSBpKSAvIGYzMihTQU1QTEVfQ09VTlQpKSA7XG4gICAgXG4gICAgICAgICAgICAgICAgcHJlZmlsdGVyZWRDb2xvciA9IHByZWZpbHRlcmVkQ29sb3IgKyBzYW1wbGVDb2xvcihMKS5yZ2IgKiBOZG90TDtcbiAgICAgICAgICAgICAgICBwcmVmaWx0ZXJlZENvbG9yID0gcHJlZmlsdGVyZWRDb2xvciAqIGF0dCA7XG4gICAgICAgICAgICAgICAgdG90YWxXZWlnaHQgICAgICA9IHRvdGFsV2VpZ2h0ICsgTmRvdEw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJlZmlsdGVyZWRDb2xvciA9IHByZWZpbHRlcmVkQ29sb3IgLyB0b3RhbFdlaWdodDtcbiAgICBcbiAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPihwcmVmaWx0ZXJlZENvbG9yLCAxLjApO1xuICAgIH1cbiAgICBcbiAgICBmbiBTYW1wbGVTcGhlcmljYWxNYXAodjogdmVjMzxmMzI+KSAtPiB2ZWMyPGYzMj4ge1xuICAgICAgICB2YXIgdXY6dmVjMjxmMzI+ID0gdmVjMjxmMzI+KGF0YW4yKHYueiwgdi54KSwgYXNpbih2LnkpKTtcbiAgICAgICAgLy91diA9ICh1diAqICh2ZWMyPGYzMj4oMC4xNTkwOTk5OTYwODk5MzUzLCAwLjMxODMwMDAwODc3MzgwMzcpICsgdmVjMjxmMzI+KDAuMDAxMDAwMDAwMDQ3NDk3NDUxMykpKTtcbiAgICAgICAgdXYgPSB1diAqIHZlYzI8ZjMyPigwLjE1OTA5OTk5NjA4OTkzNTMsIDAuMzE4MzAwMDA4NzczODAzNyk7XG4gICAgICAgIHV2ID0gdXYgKyB2ZWMyPGYzMj4oMC41KTtcbiAgICAgICAgdXYgPSBjbGFtcCh1diwgdmVjMjxmMzI+KDAuMCksIHZlYzI8ZjMyPigxLjApKTtcbiAgICAgICAgcmV0dXJuIHV2O1xuICAgIH1cbiAgICBcbiAgICBmbiBzYW1wbGVDb2xvcihkOnZlYzM8ZjMyPikgLT4gdmVjNDxmMzI+XG4gICAge1xuICAgICAgICBsZXQgdXZfZjMyOnZlYzI8ZjMyPiA9IFNhbXBsZVNwaGVyaWNhbE1hcChkKTtcbiAgICAgICAgbGV0IG9jID0gdGV4dHVyZVNhbXBsZUxldmVsKGlucHV0VGV4LCBpbnB1dFRleFNhbXBsZXIsIHV2X2YzMiAsIDAuMCk7XG4gICAgICAgIC8vbGV0IGRpciA9IHZlYzM8ZjMyPigtZC54LCAtZC55LCBkLnopO1xuICAgICAgICAvL3ZhciBvYzp2ZWM0PGYzMj4gPSB0ZXh0dXJlU2FtcGxlTGV2ZWwoY3ViZU1hcCwgY3ViZU1hcFNhbXBsZXIsIGRpciwgMC4wKTtcbiAgICAgICAgcmV0dXJuIG9jO1xuICAgIH1cbiAgICBcbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoOCwgOCwgMSlcbiAgICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcbiAgICAgICAgbGV0IGNvb3JkID0gdmVjMjxpMzI+KEdsb2JhbEludm9jYXRpb25JRC54eSk7XG4gICAgICAgIGxldCBxdWF0ZXJuaW9uID0gZmFjZVJvdGF0aW9uW0dsb2JhbEludm9jYXRpb25JRC56XTtcbiAgICAgICAgdmFyIHdvcmxkRGlyZWN0aW9uOnZlYzM8ZjMyPiA9IGNvbnZlcnRJZFRvRGlyMyhjb29yZCwgcXVhdGVybmlvbik7XG4gICAgICAgIHZhciBvYzp2ZWM0PGYzMj4gPSBtdWx0aVNhbXBsZSh3b3JsZERpcmVjdGlvbiwgYmx1clNldHRpbmcueCk7XG4gICAgICAgIHRleHR1cmVTdG9yZShvdXRwdXRCdWZmZXIwLCBjb29yZCwgaTMyKEdsb2JhbEludm9jYXRpb25JRC56KSwgb2MpO1xuICAgIH1cblxuYDtjbGFzcyBjcntzdGF0aWMgaW1wb3J0YW50U2FtcGxlKGUsdCxyLHMpe2NvbnN0IGE9Uy5kZXZpY2U7dGhpcy5waXBlbGluZT09bnVsbCYmKHRoaXMucGlwZWxpbmU9YS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2xheW91dDpcImF1dG9cIixjb21wdXRlOnttb2R1bGU6YS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6UnV9KSxlbnRyeVBvaW50OlwibWFpblwifX0pKTtjb25zdCBuPXRoaXMucGlwZWxpbmUsbD00KjQ7dGhpcy5jb25maWdCdWZmZXJ8fCh0aGlzLmNvbmZpZ0J1ZmZlcj1hLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpsLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk18R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSksYS5xdWV1ZS53cml0ZUJ1ZmZlcih0aGlzLmNvbmZpZ0J1ZmZlciwwLG5ldyBVaW50MzJBcnJheShbZS53aWR0aCxlLmhlaWdodCx0LHRdKSk7Y29uc3QgaD00KjY7aWYoIXRoaXMucXVhdGVybmlvbkJ1ZmZlcil7dGhpcy5xdWF0ZXJuaW9uQnVmZmVyPWEuY3JlYXRlQnVmZmVyKHtzaXplOmgqNCo2LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KTtsZXQgdj1uZXcgRmxvYXQzMkFycmF5KDQqNik7Zm9yKGxldCB5PTA7eTw2O3krKyl7bGV0IEM9em8uZ2V0Um90YXRpb25Ub0ZhY2UoeSk7dlt5KjQrMF09Qy54LHZbeSo0KzFdPUMueSx2W3kqNCsyXT1DLnosdlt5KjQrM109Qy53fWEucXVldWUud3JpdGVCdWZmZXIodGhpcy5xdWF0ZXJuaW9uQnVmZmVyLDAsdil9dGhpcy5ibHVyU2V0dGluZ0J1ZmZlcnx8KHRoaXMuYmx1clNldHRpbmdCdWZmZXI9YS5jcmVhdGVCdWZmZXIoe3NpemU6bCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5VTklGT1JNfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfSkpLGEucXVldWUud3JpdGVCdWZmZXIodGhpcy5ibHVyU2V0dGluZ0J1ZmZlciwwLG5ldyBGbG9hdDMyQXJyYXkoW3IsMCwwLDBdKSk7Y29uc3QgdT1lLmVycFRleHR1cmU7bGV0IGM9W3tiaW5kaW5nOjAscmVzb3VyY2U6e2J1ZmZlcjp0aGlzLmNvbmZpZ0J1ZmZlcixzaXplOjQqNH19LHtiaW5kaW5nOjEscmVzb3VyY2U6e2J1ZmZlcjp0aGlzLnF1YXRlcm5pb25CdWZmZXIsc2l6ZTpoKjR9fSx7YmluZGluZzoyLHJlc291cmNlOnUuZ3B1U2FtcGxlcn0se2JpbmRpbmc6MyxyZXNvdXJjZTp1LmdldEdQVVZpZXcoKX1dLGY9W3tiaW5kaW5nOjAscmVzb3VyY2U6e2J1ZmZlcjp0aGlzLmJsdXJTZXR0aW5nQnVmZmVyLHNpemU6NCo0fX0se2JpbmRpbmc6MSxyZXNvdXJjZTpzfV07Y29uc3QgZD1hLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0Om4uZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6Y30pLHA9YS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDpuLmdldEJpbmRHcm91cExheW91dCgxKSxlbnRyaWVzOmZ9KSxtPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpLF89bS5iZWdpbkNvbXB1dGVQYXNzKCk7Xy5zZXRQaXBlbGluZShuKSxfLnNldEJpbmRHcm91cCgwLGQpLF8uc2V0QmluZEdyb3VwKDEscCksXy5kaXNwYXRjaFdvcmtncm91cHModC84LHQvOCw2KSxfLmVuZCgpLHcuZW5kQ29tbWFuZEVuY29kZXIobSl9fW8oY3IsXCJjb25maWdCdWZmZXJcIixudWxsKSxvKGNyLFwicXVhdGVybmlvbkJ1ZmZlclwiLG51bGwpLG8oY3IsXCJibHVyU2V0dGluZ0J1ZmZlclwiLG51bGwpLG8oY3IsXCJwaXBlbGluZVwiKTtjbGFzcyBWb3tjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJmYWNlVGV4dHVyZVJlZlwiKSxvKHRoaXMsXCJfdGV4dHVyZVwiKSx0aGlzLl90ZXh0dXJlPWUsdGhpcy5mYWNlVGV4dHVyZVJlZj17fX11cGxvYWRUZXh0dXJlKGUsdCl7bGV0IHI9dGhpcy5nZXRHcHVTb3VyY2UoZSk7cmV0dXJuIERpLm1ha2VUZXh0dXJlQ3ViZSh0LHRoaXMuX3RleHR1cmUud2lkdGgsci52KSx0aGlzfXVwbG9hZEVycFRleHR1cmUoZSl7bGV0IHQ9dGhpcy5nZXRHcHVTb3VyY2UoMCk7cmV0dXJuIERpLm1ha2VUZXh0dXJlQ3ViZShlLHRoaXMuX3RleHR1cmUud2lkdGgsdC52KSx0aGlzLmdlbmVyYXRlTWlwbWFwKGUpLHRoaXN9Z2V0R3B1U291cmNlKGUpe2xldCB0PXRoaXMuZmFjZVRleHR1cmVSZWZbZV07cmV0dXJuIHR8fCh0PXt0OnRoaXMuX3RleHR1cmUuZ2V0R1BVVGV4dHVyZSgpLHY6dGhpcy5fdGV4dHVyZS5nZXRHUFVUZXh0dXJlKCkuY3JlYXRlVmlldyh7Zm9ybWF0OnRoaXMuX3RleHR1cmUuZm9ybWF0LGRpbWVuc2lvbjpcIjJkLWFycmF5XCIsYmFzZU1pcExldmVsOmUsbWlwTGV2ZWxDb3VudDoxLGFycmF5TGF5ZXJDb3VudDo2fSl9LHRoaXMuZmFjZVRleHR1cmVSZWZbZV09dCksdH1nZW5lcmF0ZU1pcG1hcChlKXtsZXQgdD0xO2Zvcig7dDx0aGlzLl90ZXh0dXJlLm1pcG1hcENvdW50Oyl0aGlzLmdlbmVyYXRlTWlwbWFwQXRMZXZlbCh0LGUpLHQrK31nZW5lcmF0ZU1pcG1hcEF0TGV2ZWwoZSx0LHI9Myl7bGV0IHM9dGhpcy5fdGV4dHVyZS53aWR0aC9NYXRoLnBvdygyLGUpLGE9e3dpZHRoOnMsaGVpZ2h0OnMsZXJwVGV4dHVyZTp0fSxuPShlKzEpL3RoaXMuX3RleHR1cmUubWlwbWFwQ291bnQ7bj1NYXRoLnBvdyhuLHIpO2xldCBsPXRoaXMuZ2V0R3B1U291cmNlKGUpO2NyLmltcG9ydGFudFNhbXBsZShhLHMsbixsLnYpfX1jbGFzcyBlYSBleHRlbmRzIFpze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJfdXJsXCIpLG8odGhpcyxcIl9mYWNlRGF0YVwiKSx0aGlzLnVzZU1pcG1hcD0hMCx0aGlzLmZvcm1hdD1HLnJnYmExNmZsb2F0LHRoaXMuaXNIRFJUZXh0dXJlPSEwLHRoaXMuX2ZhY2VEYXRhPW5ldyBWbyh0aGlzKX1jcmVhdGVGcm9tSERSRGF0YShlLHQpe2xldCByPW5ldyBvZSh0LndpZHRoLHQuaGVpZ2h0LEcucmdiYTE2ZmxvYXQsITEsR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HKSxzPW5ldyBGbG9hdDMyQXJyYXkodC5hcnJheSk7cmV0dXJuIERpLmNvbnZlcnRSR0JFMlJHQkEocixzKSx0aGlzLmNyZWF0ZUZyb21UZXh0dXJlKGUsciksdGhpc31jcmVhdGVGcm9tVGV4dHVyZShlLHQpe3RoaXMud2lkdGg9dGhpcy5oZWlnaHQ9ZSx0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnZpZXdEaW1lbnNpb249XCJjdWJlXCI7bGV0IHI9dGhpcy53aWR0aDtmb3IodGhpcy5taXBtYXBDb3VudD0xO3I+MTY7KXIvPTIsdGhpcy5taXBtYXBDb3VudCsrO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEZXNjcmlwdG9yKGUsZSx0aGlzLm1pcG1hcENvdW50LHRoaXMuZm9ybWF0KSx0aGlzLnRleHR1cmVEZXNjcmlwdG9yLnNpemU9e3dpZHRoOmUsaGVpZ2h0OmUsZGVwdGhPckFycmF5TGF5ZXJzOjZ9LHRoaXMudGV4dHVyZURlc2NyaXB0b3IuZGltZW5zaW9uPVwiMmRcIix0aGlzLmdwdVNhbXBsZXI9Uy5kZXZpY2UuY3JlYXRlU2FtcGxlcih0aGlzKSx0aGlzLl9mYWNlRGF0YS51cGxvYWRFcnBUZXh0dXJlKHQpLHRoaXN9YXN5bmMgbG9hZChlLHQpe3JldHVybiB0aGlzLl91cmw9ZSwoYXdhaXQgbmV3IGh0KCkubG9hZChlLCRzLHQpKS5nZXRDdWJlVGV4dHVyZSgpfX1mdW5jdGlvbiBMdShpKXtyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGkpfWNsYXNzIHRhe2NvbnN0cnVjdG9yKGUsdCxyLHMpe28odGhpcyxcImJ1ZmZlclwiKSxvKHRoaXMsXCJiaW5PZmZzZXRcIiksbyh0aGlzLFwiYmluTGVuZ3RoXCIpLG8odGhpcyxcImhlYWRlclwiKSx0aGlzLmJ1ZmZlcj1lLHRoaXMuYmluT2Zmc2V0PXQrcix0aGlzLmJpbkxlbmd0aD1zO2xldCBhPW51bGw7aWYociE9PTApe2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoZSx0LHIpO2E9SlNPTi5wYXJzZShMdShuKSl9ZWxzZSBhPXt9O3RoaXMuaGVhZGVyPWF9Z2V0S2V5cygpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcil9Z2V0RGF0YShlLHQscj1udWxsLHM9bnVsbCl7Y29uc3QgYT10aGlzLmhlYWRlcjtpZighKGUgaW4gYSkpcmV0dXJuIG51bGw7Y29uc3Qgbj1hW2VdO2lmKG4gaW5zdGFuY2VvZiBPYmplY3Qpe2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIG47e2NvbnN0e2J1ZmZlcjpsLGJpbk9mZnNldDpoLGJpbkxlbmd0aDp1fT10aGlzLGM9bi5ieXRlT2Zmc2V0fHwwLGY9bi50eXBlfHxzLGQ9bi5jb21wb25lbnRUeXBlfHxyO2lmKFwidHlwZVwiaW4gbiYmcyYmbi50eXBlIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlVGFibGU6IFNwZWNpZmllZCB0eXBlIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHR5cGUuXCIpO2xldCBwO3N3aXRjaChmKXtjYXNlXCJTQ0FMQVJcIjpwPTE7YnJlYWs7Y2FzZVwiVkVDMlwiOnA9MjticmVhaztjYXNlXCJWRUMzXCI6cD0zO2JyZWFrO2Nhc2VcIlZFQzRcIjpwPTQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEZlYXR1cmVUYWJsZSA6IEZlYXR1cmUgdHlwZSBub3QgcHJvdmlkZWQgZm9yIFwiJHtlfVwiLmApfWxldCBtO2NvbnN0IF89aCtjLHY9dCpwO3N3aXRjaChkKXtjYXNlXCJCWVRFXCI6bT1uZXcgSW50OEFycmF5KGwsXyx2KTticmVhaztjYXNlXCJVTlNJR05FRF9CWVRFXCI6bT1uZXcgVWludDhBcnJheShsLF8sdik7YnJlYWs7Y2FzZVwiU0hPUlRcIjptPW5ldyBJbnQxNkFycmF5KGwsXyx2KTticmVhaztjYXNlXCJVTlNJR05FRF9TSE9SVFwiOm09bmV3IFVpbnQxNkFycmF5KGwsXyx2KTticmVhaztjYXNlXCJJTlRcIjptPW5ldyBJbnQzMkFycmF5KGwsXyx2KTticmVhaztjYXNlXCJVTlNJR05FRF9JTlRcIjptPW5ldyBVaW50MzJBcnJheShsLF8sdik7YnJlYWs7Y2FzZVwiRkxPQVRcIjptPW5ldyBGbG9hdDMyQXJyYXkobCxfLHYpO2JyZWFrO2Nhc2VcIkRPVUJMRVwiOm09bmV3IEZsb2F0NjRBcnJheShsLF8sdik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEZlYXR1cmVUYWJsZSA6IEZlYXR1cmUgY29tcG9uZW50IHR5cGUgbm90IHByb3ZpZGVkIGZvciBcIiR7ZX1cIi5gKX1pZihfK3YqbS5CWVRFU19QRVJfRUxFTUVOVD5oK3UpdGhyb3cgbmV3IEVycm9yKFwiRmVhdHVyZVRhYmxlOiBGZWF0dXJlIGRhdGEgcmVhZCBvdXRzaWRlIGJpbmFyeSBib2R5IGxlbmd0aC5cIik7cmV0dXJuIG19fWVsc2UgcmV0dXJuIG59fWNsYXNzIEhvIGV4dGVuZHMgdGF7Y29uc3RydWN0b3IoZSx0LHIscyxhKXtzdXBlcihlLHIscyxhKSxvKHRoaXMsXCJiYXRjaFNpemVcIiksdGhpcy5iYXRjaFNpemU9dH1nZXREYXRhKGUsdD1udWxsLHI9bnVsbCl7cmV0dXJuIHN1cGVyLmdldERhdGEoZSx0aGlzLmJhdGNoU2l6ZSx0LHIpfX1mdW5jdGlvbiBZbyhpKXtsZXQgZTtpZihpIGluc3RhbmNlb2YgRGF0YVZpZXc/ZT1pOmU9bmV3IERhdGFWaWV3KGkpLFN0cmluZy5mcm9tQ2hhckNvZGUoZS5nZXRVaW50OCgwKSk9PT1cIntcIilyZXR1cm4gbnVsbDtsZXQgdD1cIlwiO2ZvcihsZXQgcj0wO3I8NDtyKyspdCs9U3RyaW5nLmZyb21DaGFyQ29kZShlLmdldFVpbnQ4KHIpKTtyZXR1cm4gdH1jbGFzcyBVdXthc3luYyBwYXJzZShlKXtjb25zdCB0PW5ldyBEYXRhVmlldyhlKSxyPVlvKHQpO2NvbnNvbGUuYXNzZXJ0KHI9PT1cImIzZG1cIik7Y29uc3Qgcz10LmdldFVpbnQzMig0LCEwKTtjb25zb2xlLmFzc2VydChzPT09MSk7Y29uc3QgYT10LmdldFVpbnQzMig4LCEwKTtjb25zb2xlLmFzc2VydChhPT09ZS5ieXRlTGVuZ3RoKTtjb25zdCBuPXQuZ2V0VWludDMyKDEyLCEwKSxsPXQuZ2V0VWludDMyKDE2LCEwKSxoPXQuZ2V0VWludDMyKDIwLCEwKSx1PXQuZ2V0VWludDMyKDI0LCEwKSxjPTI4LGY9bmV3IHRhKGUsYyxuLGwpLGQ9YytuK2wscD1uZXcgSG8oZSxmLmdldERhdGEoXCJCQVRDSF9MRU5HVEhcIiksZCxoLHUpLG09ZCtoK3UsXz1uZXcgVWludDhBcnJheShlLG0sYS1tKTtyZXR1cm57dmVyc2lvbjpzLGZlYXR1cmVUYWJsZTpmLGJhdGNoVGFibGU6cCxnbGJCeXRlczpffX19Y29uc3QgaWE9Y2xhc3MgZXh0ZW5kcyBVdXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiYWRqdXN0bWVudFRyYW5zZm9ybVwiKSxvKHRoaXMsXCJnbHRmQnVmZmVyXCIpLHRoaXMuYWRqdXN0bWVudFRyYW5zZm9ybT1uZXcgVigpLmlkZW50aXR5KCksaWEudGVtcE1hdHJpeHx8KGlhLnRlbXBNYXRyaXg9bmV3IFYoKS5pZGVudGl0eSgpKX1hc3luYyBwYXJzZShpKXtjb25zdCBlPWF3YWl0IHN1cGVyLnBhcnNlKGkpO3RoaXMuZ2x0ZkJ1ZmZlcj1lLmdsYkJ5dGVzLnNsaWNlKCkuYnVmZmVyO2xldCByPWF3YWl0IG5ldyBqbygpLnBhcnNlQmluYXJ5KHRoaXMuZ2x0ZkJ1ZmZlcikse2JhdGNoVGFibGU6cyxmZWF0dXJlVGFibGU6YX09ZTtjb25zdCBuPWEuZ2V0RGF0YShcIlJUQ19DRU5URVJcIik7biYmKHIueCs9blswXSxyLnkrPW5bMV0sci56Kz1uWzJdKTtsZXQgbD1yLmdldENvbXBvbmVudChPZSk7bC51cGRhdGVXb3JsZE1hdHJpeCgpO2xldCBoPWlhLnRlbXBNYXRyaXg7aC5jb21wb3NlKGwubG9jYWxQb3NpdGlvbixsLmxvY2FsUm90UXVhdCxsLmxvY2FsU2NhbGUpLGgubXVsdGlwbHkodGhpcy5hZGp1c3RtZW50VHJhbnNmb3JtKTtsZXQgdT1oLmRlY29tcG9zZSh5dC5RVUFURVJOSU9OKTtyZXR1cm4gbC5sb2NhbFJvdFF1YXQuY29weUZyb20odVsxXSksbC5sb2NhbFJvdFF1YXQ9bC5sb2NhbFJvdFF1YXQsbC5sb2NhbFBvc2l0aW9uLmNvcHlGcm9tKHVbMF0pLGwubG9jYWxQb3NpdGlvbj1sLmxvY2FsUG9zaXRpb24sbC5sb2NhbFNjYWxlLmNvcHlGcm9tKHVbMl0pLGwubG9jYWxTY2FsZT1sLmxvY2FsU2NhbGUsbC51cGRhdGVXb3JsZE1hdHJpeCgpLHIuYmF0Y2hUYWJsZT1zLHIuZmVhdHVyZVRhYmxlPWEscn1zdGF0aWMgZGVjb2RlVGV4dChpKXtpZih0eXBlb2YgVGV4dERlY29kZXI8XCJ1XCIpcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpKTtsZXQgZT1cIlwiO2ZvcihsZXQgdD0wLHI9aS5sZW5ndGg7dDxyO3QrKyllKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGlbdF0pO3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlKSl9Y2F0Y2h7cmV0dXJuIGV9fX07bGV0IFBpPWlhO28oUGksXCJ0ZW1wTWF0cml4XCIpO2NsYXNzIFhvIGV4dGVuZHMgWHR7YXN5bmMgcGFyc2VCdWZmZXIoZSl7bGV0IHQ9bmV3IFBpO3QuYWRqdXN0bWVudFRyYW5zZm9ybT10aGlzLnVzZXJEYXRhLHRoaXMuZGF0YT1hd2FpdCB0LnBhcnNlKGUpfXZlcmlmaWNhdGlvbigpe2lmKHRoaXMuZGF0YSlyZXR1cm4hMDt0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKX19byhYbyxcImZvcm1hdFwiLFwiYmluXCIpO2NvbnN0IE91PVwiZ2xURlwiLG5zPTEyLE51PXtKU09OOjEzMTM4MjE1MTQsQklOOjUxMzA1NjJ9LFdvPXtLSFJfQklOQVJZX0dMVEY6XCJLSFJfYmluYXJ5X2dsVEZcIixLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcIktIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXCIsS0hSX0xJR0hUU19QVU5DVFVBTDpcIktIUl9saWdodHNfcHVuY3R1YWxcIixLSFJfTUFURVJJQUxTX0NMRUFSQ09BVDpcIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCIsS0hSX01BVEVSSUFMU19JT1I6XCJLSFJfbWF0ZXJpYWxzX2lvclwiLEtIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1M6XCJLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1wiLEtIUl9NQVRFUklBTFNfU0hFRU46XCJLSFJfbWF0ZXJpYWxzX3NoZWVuXCIsS0hSX01BVEVSSUFMU19TUEVDVUxBUjpcIktIUl9tYXRlcmlhbHNfc3BlY3VsYXJcIixLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjpcIktIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXCIsS0hSX01BVEVSSUFMU19VTkxJVDpcIktIUl9tYXRlcmlhbHNfdW5saXRcIixLSFJfTUFURVJJQUxTX1ZPTFVNRTpcIktIUl9tYXRlcmlhbHNfdm9sdW1lXCIsS0hSX1RFWFRVUkVfQkFTSVNVOlwiS0hSX3RleHR1cmVfYmFzaXN1XCIsS0hSX1RFWFRVUkVfVFJBTlNGT1JNOlwiS0hSX3RleHR1cmVfdHJhbnNmb3JtXCIsS0hSX01FU0hfUVVBTlRJWkFUSU9OOlwiS0hSX21lc2hfcXVhbnRpemF0aW9uXCIsRVhUX1RFWFRVUkVfV0VCUDpcIkVYVF90ZXh0dXJlX3dlYnBcIixFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjpcIkVYVF9tZXNob3B0X2NvbXByZXNzaW9uXCJ9O2NsYXNzIEZ1e2NvbnN0cnVjdG9yKGUpe28odGhpcyxcIm5hbWVcIiksbyh0aGlzLFwiY29udGVudFwiKSxvKHRoaXMsXCJib2R5XCIpLG8odGhpcyxcImhlYWRlclwiKSx0aGlzLm5hbWU9V28uS0hSX0JJTkFSWV9HTFRGLHRoaXMuY29udGVudD1udWxsLHRoaXMuYm9keT1udWxsO2NvbnN0IHQ9bmV3IERhdGFWaWV3KGUsMCxucyk7aWYodGhpcy5oZWFkZXI9e21hZ2ljOlBpLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZS5zbGljZSgwLDQpKSksdmVyc2lvbjp0LmdldFVpbnQzMig0LCEwKSxsZW5ndGg6dC5nZXRVaW50MzIoOCwhMCl9LHRoaXMuaGVhZGVyLm1hZ2ljIT09T3UpdGhyb3cgbmV3IEVycm9yKFwiR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtpZih0aGlzLmhlYWRlci52ZXJzaW9uPDIpdGhyb3cgbmV3IEVycm9yKFwiR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLlwiKTtjb25zdCByPXRoaXMuaGVhZGVyLmxlbmd0aC1ucyxzPW5ldyBEYXRhVmlldyhlLG5zKTtsZXQgYT0wO2Zvcig7YTxyOyl7Y29uc3Qgbj1zLmdldFVpbnQzMihhLCEwKTthKz00O2NvbnN0IGw9cy5nZXRVaW50MzIoYSwhMCk7aWYoYSs9NCxsPT09TnUuSlNPTil7Y29uc3QgaD1uZXcgVWludDhBcnJheShlLG5zK2Esbik7dGhpcy5jb250ZW50PVBpLmRlY29kZVRleHQoaCl9ZWxzZSBpZihsPT09TnUuQklOKXtjb25zdCBoPW5zK2E7dGhpcy5ib2R5PWUuc2xpY2UoaCxoK24pfWErPW59aWYodGhpcy5jb250ZW50PT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJHTFRGTG9hZGVyOiBKU09OIGNvbnRlbnQgbm90IGZvdW5kLlwiKX19Y2xhc3Mgam97Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJfYmluYXJ5XCIpfWFzeW5jIHBhcnNlQmluYXJ5KGUpe3RoaXMuX2JpbmFyeT1lO2NvbnN0IHQ9UGkuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheSh0aGlzLl9iaW5hcnksMCw0KSkscj17fTtsZXQgcyxhO2lmKHQ9PT1PdSl7dHJ5e2E9cltXby5LSFJfQklOQVJZX0dMVEZdPW5ldyBGdSh0aGlzLl9iaW5hcnkpfWNhdGNoe3JldHVybn1zPXJbV28uS0hSX0JJTkFSWV9HTFRGXS5jb250ZW50fWVsc2Ugcz1QaS5kZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KHRoaXMuX2JpbmFyeSkpO2NvbnN0IG49SlNPTi5wYXJzZShzKTtyZXR1cm4gYXdhaXQgdGhpcy5wYXJzZUdMQihuLGEuYm9keSl9YXN5bmMgcGFyc2VHTEIoZSx0KXtyZXR1cm4gYXdhaXQgbmV3IHFzKCkucGFyc2VKc29uQW5kQnVmZmVyKGUsdCl9fWNsYXNzIGt1e2FzeW5jIHBhcnNlKGUpe2NvbnN0IHQ9bmV3IERhdGFWaWV3KGUpLHI9WW8odCk7Y29uc29sZS5hc3NlcnQocj09PVwiaTNkbVwiKTtjb25zdCBzPXQuZ2V0VWludDMyKDQsITApO2NvbnNvbGUuYXNzZXJ0KHM9PT0xKTtjb25zdCBhPXQuZ2V0VWludDMyKDgsITApO2NvbnNvbGUuYXNzZXJ0KGE9PT1lLmJ5dGVMZW5ndGgpO2NvbnN0IG49dC5nZXRVaW50MzIoMTIsITApLGw9dC5nZXRVaW50MzIoMTYsITApLGg9dC5nZXRVaW50MzIoMjAsITApLHU9dC5nZXRVaW50MzIoMjQsITApO3QuZ2V0VWludDMyKDI4LCEwKTtjb25zdCBjPTMyLGY9bmV3IHRhKGUsYyxuLGwpLGQ9YytuK2wscD1uZXcgSG8oZSxmLmdldERhdGEoXCJJTlNUQU5DRVNfTEVOR1RIXCIpLGQsaCx1KSxtPWQraCt1LF89bmV3IFVpbnQ4QXJyYXkoZSxtLGEtbSk7cmV0dXJue3ZlcnNpb246cyxmZWF0dXJlVGFibGU6ZixiYXRjaFRhYmxlOnAsZ2xiQnl0ZXM6X319fWNsYXNzIHp1IGV4dGVuZHMgdGV7Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKCksbyh0aGlzLFwiX2dlb21ldHJ5XCIpLG8odGhpcyxcIl9tYXRlcmlhbFwiKSxvKHRoaXMsXCJfaW5zdGFuY2VMaXN0XCIpLHRoaXMuX2dlb21ldHJ5PWUsdGhpcy5fbWF0ZXJpYWw9dCx0aGlzLl9pbnN0YW5jZUxpc3Q9W107Zm9yKGxldCBzPTA7czxyO3MrKyl7bGV0IGEsbj1uZXcgdGU7YT1uLmFkZENvbXBvbmVudChjZSksYS5nZW9tZXRyeT10aGlzLl9nZW9tZXRyeSxhLm1hdGVyaWFsPXRoaXMuX21hdGVyaWFsLHRoaXMuYWRkQ2hpbGQobiksdGhpcy5faW5zdGFuY2VMaXN0LnB1c2gobil9fXNldE1hdHJpeEF0KGUsdCl7bGV0IHI9dGhpcy5faW5zdGFuY2VMaXN0W2VdLHM9dC5kZWNvbXBvc2UoeXQuUVVBVEVSTklPTiksYT1yLnRyYW5zZm9ybTtyZXR1cm4gYS5sb2NhbFJvdFF1YXQuY29weUZyb20oc1sxXSksYS5sb2NhbFJvdFF1YXQ9YS5sb2NhbFJvdFF1YXQsYS5sb2NhbFBvc2l0aW9uLmNvcHlGcm9tKHNbMF0pLGEubG9jYWxQb3NpdGlvbj1hLmxvY2FsUG9zaXRpb24sYS5sb2NhbFNjYWxlLmNvcHlGcm9tKHNbMl0pLGEubG9jYWxTY2FsZT1hLmxvY2FsU2NhbGUsdGhpc319Y29uc3QgcnQ9Y2xhc3MgZXh0ZW5kcyBrdXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiYWRqdXN0bWVudFRyYW5zZm9ybVwiKSxvKHRoaXMsXCJfZ2x0ZkJ1ZmZlclwiKSxydC50ZW1wRndkfHwocnQudGVtcEZ3ZD1uZXcgZykscnQudGVtcFVwfHwocnQudGVtcFVwPW5ldyBnKSxydC50ZW1wUmlnaHR8fChydC50ZW1wUmlnaHQ9bmV3IGcpLHJ0LnRlbXBQb3N8fChydC50ZW1wUG9zPW5ldyBnKSxydC50ZW1wUXVhdHx8KHJ0LnRlbXBRdWF0PW5ldyBxKSxydC50ZW1wU2NhfHwocnQudGVtcFNjYT1uZXcgZykscnQudGVtcE1hdHx8KHJ0LnRlbXBNYXQ9bmV3IFYpLHRoaXMuYWRqdXN0bWVudFRyYW5zZm9ybT1uZXcgVigpLmlkZW50aXR5KCl9YXN5bmMgcGFyc2UoaSl7Y29uc3QgZT1hd2FpdCBzdXBlci5wYXJzZShpKTt0aGlzLl9nbHRmQnVmZmVyPWUuZ2xiQnl0ZXMuc2xpY2UoKS5idWZmZXI7bGV0IHI9YXdhaXQgbmV3IGpvKCkucGFyc2VCaW5hcnkodGhpcy5fZ2x0ZkJ1ZmZlcikse2JhdGNoVGFibGU6cyxmZWF0dXJlVGFibGU6YX09ZTtjb25zdCBuPXRoaXMuYWRqdXN0bWVudFRyYW5zZm9ybSxsPWEuZ2V0RGF0YShcIklOU1RBTkNFU19MRU5HVEhcIiksaD1hLmdldERhdGEoXCJQT1NJVElPTlwiLGwsXCJGTE9BVFwiLFwiVkVDM1wiKSx1PWEuZ2V0RGF0YShcIk5PUk1BTF9VUFwiLGwsXCJGTE9BVFwiLFwiVkVDM1wiKSxjPWEuZ2V0RGF0YShcIk5PUk1BTF9SSUdIVFwiLGwsXCJGTE9BVFwiLFwiVkVDM1wiKSxmPWEuZ2V0RGF0YShcIlNDQUxFX05PTl9VTklGT1JNXCIsbCxcIkZMT0FUXCIsXCJWRUMzXCIpLGQ9YS5nZXREYXRhKFwiU0NBTEVcIixsLFwiRkxPQVRcIixcIlNDQUxBUlwiKSxwPW5ldyBNYXAsbT1bXTtyLnRyYXZlcnNlKHk9PntsZXQgQztpZihDPXk/eS5nZXRDb21wb25lbnQoY2UpOm51bGwsQyl7Y29uc3R7Z2VvbWV0cnk6QixtYXRlcmlhbDpUfT1DLE09bmV3IHp1KEIsVCxsKTtNLmxvY2FsUG9zaXRpb249TS5sb2NhbFBvc2l0aW9uLmNvcHkoeS5sb2NhbFBvc2l0aW9uKSxNLmxvY2FsUm90YXRpb249TS5sb2NhbFJvdGF0aW9uLmNvcHkoeS5sb2NhbFJvdGF0aW9uKSxNLmxvY2FsU2NhbGU9TS5sb2NhbFNjYWxlLmNvcHkoeS5sb2NhbFNjYWxlKSxtLnB1c2goTSkscC5zZXQoeSxNKX19KTtjb25zdCBfPW5ldyBnO2ZvcihsZXQgeT0wO3k8bDt5KyspXy54Kz1oW3kqMyswXS9sLF8ueSs9aFt5KjMrMV0vbCxfLnorPWhbeSozKzJdL2w7cC5mb3JFYWNoKCh5LEMpPT57Y29uc3QgQj1DLnBhcmVudD9DLnBhcmVudE9iamVjdDpudWxsO0ImJihCLnJlbW92ZUNoaWxkKEMpLEIuYWRkQ2hpbGQoeSkseS50cmFuc2Zvcm0udXBkYXRlV29ybGRNYXRyaXgoKSx5LnRyYW5zZm9ybS53b3JsZE1hdHJpeC50cmFuc2Zvcm1WZWN0b3I0KF8seS5sb2NhbFBvc2l0aW9uKSl9KTtjb25zdCB2PXJ0O2ZvcihsZXQgeT0wO3k8bDt5Kyspe3YudGVtcE1hdC5pZGVudGl0eSgpLHYudGVtcFBvcy5zZXQoaFt5KjMrMF0tXy54LGhbeSozKzFdLV8ueSxoW3kqMysyXS1fLnopLHU/KHYudGVtcFVwLnNldCh1W3kqMyswXSx1W3kqMysxXSx1W3kqMysyXSksdi50ZW1wUmlnaHQuc2V0KGNbeSozKzBdLGNbeSozKzFdLGNbeSozKzJdKSx2LnRlbXBSaWdodC5jcm9zc1Byb2R1Y3Qodi50ZW1wVXAsdi50ZW1wRndkKS5ub3JtYWxpemUoKSx2LnRlbXBNYXQubWFrZUJhc2lzKHYudGVtcFJpZ2h0LHYudGVtcFVwLHYudGVtcEZ3ZCksdi50ZW1wUXVhdC5zZXRGcm9tUm90YXRpb25NYXRyaXgodi50ZW1wTWF0KSk6di50ZW1wUXVhdC5zZXQoMCwwLDAsMSksZD92LnRlbXBTY2Euc2V0U2NhbGFyKGRbeV0pOmY/di50ZW1wU2NhLnNldChmW3kqMyswXSxmW3kqMysxXSxmW3kqMysyXSk6di50ZW1wU2NhLnNldCgxLDEsMSksdi50ZW1wTWF0LmNvbXBvc2Uodi50ZW1wUG9zLHYudGVtcFF1YXQsdi50ZW1wU2NhKSx2LnRlbXBNYXQubXVsdGlwbHlNYXRyaWNlcyh2LnRlbXBNYXQsbik7Zm9yKGxldCBDPTAsQj1tLmxlbmd0aDtDPEI7QysrKW1bQ10uc2V0TWF0cml4QXQoeSx2LnRlbXBNYXQpfXJldHVybiByLmJhdGNoVGFibGU9cyxyLmZlYXR1cmVUYWJsZT1hLHJ9fTtsZXQgc2k9cnQ7byhzaSxcInRlbXBGd2RcIiksbyhzaSxcInRlbXBVcFwiKSxvKHNpLFwidGVtcFJpZ2h0XCIpLG8oc2ksXCJ0ZW1wUG9zXCIpLG8oc2ksXCJ0ZW1wUXVhdFwiKSxvKHNpLFwidGVtcFNjYVwiKSxvKHNpLFwidGVtcE1hdFwiKTtjbGFzcyBxbyBleHRlbmRzIFh0e2FzeW5jIHBhcnNlQnVmZmVyKGUpe2xldCB0PW5ldyBzaTt0LmFkanVzdG1lbnRUcmFuc2Zvcm09dGhpcy51c2VyRGF0YSx0aGlzLmRhdGE9YXdhaXQgdC5wYXJzZShlKX12ZXJpZmljYXRpb24oKXtpZih0aGlzLmRhdGEpcmV0dXJuITA7dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIil9fW8ocW8sXCJmb3JtYXRcIixcImJpblwiKTtjbGFzcyByYSBleHRlbmRzIFpze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJfZmFjZURhdGFcIiksbyh0aGlzLFwiX3VybFwiKSx0aGlzLnVzZU1pcG1hcD0hMCx0aGlzLmZvcm1hdD1HLnJnYmExNmZsb2F0LHRoaXMuX2ZhY2VEYXRhPW5ldyBWbyh0aGlzKX1nZXQgbGRySW1hZ2VVcmwoKXtyZXR1cm4gdGhpcy5fdXJsfWFzeW5jIGxvYWQoZSx0KXt0aGlzLl91cmw9ZTtsZXQgcj1uZXcgaWkoITEpO3JldHVybiBhd2FpdCByLmxvYWQoZSx0KSx0aGlzLmNyZWF0ZUZyb21MRFJUZXh0dXJlKHIpLHRoaXN9Y3JlYXRlRnJvbUxEUlRleHR1cmUoZSl7bGV0IHQ9TWF0aC5sb2cyKGUud2lkdGgvNCk7cmV0dXJuIHQ9TWF0aC5wb3coMixNYXRoLnJvdW5kKHQpKSx0aGlzLmNyZWF0ZUZyb21UZXh0dXJlKHQsZSksdGhpc31jcmVhdGVGcm9tVGV4dHVyZShlLHQpe3RoaXMud2lkdGg9dGhpcy5oZWlnaHQ9ZSx0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnZpZXdEaW1lbnNpb249XCJjdWJlXCI7bGV0IHI9dGhpcy53aWR0aDtmb3IodGhpcy5taXBtYXBDb3VudD0xO3I+MTY7KXIvPTIsdGhpcy5taXBtYXBDb3VudCsrO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEZXNjcmlwdG9yKGUsZSx0aGlzLm1pcG1hcENvdW50LHRoaXMuZm9ybWF0KSx0aGlzLnRleHR1cmVEZXNjcmlwdG9yLnNpemU9e3dpZHRoOmUsaGVpZ2h0OmUsZGVwdGhPckFycmF5TGF5ZXJzOjZ9LHRoaXMudGV4dHVyZURlc2NyaXB0b3IuZGltZW5zaW9uPVwiMmRcIix0aGlzLmdwdVNhbXBsZXI9Uy5kZXZpY2UuY3JlYXRlU2FtcGxlcih0aGlzKSx0aGlzLl9mYWNlRGF0YS51cGxvYWRFcnBUZXh0dXJlKHQpLHRoaXN9fWxldCBHdT1gXG52YXI8cHJpdmF0ZT5QSTogZjMyID0gMy4xNDE1OTI2NTM1ODk3OTM7XG5cbi8vIGZuIHNhdHVyYXRlKCB4IDogZjMyICkgLT4gZjMyIHtcbi8vICAgICByZXR1cm4gY2xhbXAoeCwgMC4wLCAxLjApO1xuLy8gfVxuXG5mbiBoYW1tZXJzbGV5KGkgOiB1MzIsIE4gOiB1MzIpIC0+IHZlYzI8ZjMyPlxue1xuICAgIC8vIFJhZGljYWwgaW52ZXJzZSBiYXNlZCBvbiBodHRwOi8vaG9sZ2VyLmRhbW1lcnR6Lm9yZy9zdHVmZi9ub3Rlc19IYW1tZXJzbGV5T25IZW1pc3BoZXJlLmh0bWxcbiAgICB2YXIgYml0cyA9IChpIDw8IDE2dSkgfCAoaSA+PiAxNnUpO1xuICAgIGJpdHMgPSAoKGJpdHMgJiAweDU1NTU1NTU1dSkgPDwgMXUpIHwgKChiaXRzICYgMHhBQUFBQUFBQXUpID4+IDF1KTtcbiAgICBiaXRzID0gKChiaXRzICYgMHgzMzMzMzMzM3UpIDw8IDJ1KSB8ICgoYml0cyAmIDB4Q0NDQ0NDQ0N1KSA+PiAydSk7XG4gICAgYml0cyA9ICgoYml0cyAmIDB4MEYwRjBGMEZ1KSA8PCA0dSkgfCAoKGJpdHMgJiAweEYwRjBGMEYwdSkgPj4gNHUpO1xuICAgIGJpdHMgPSAoKGJpdHMgJiAweDAwRkYwMEZGdSkgPDwgOHUpIHwgKChiaXRzICYgMHhGRjAwRkYwMHUpID4+IDh1KTtcbiAgICB2YXIgcmRpID0gZjMyKGJpdHMpICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDtcbiAgICByZXR1cm4gdmVjMjxmMzI+KGYzMihpKSAvIGYzMihOKSwgcmRpKTtcbn1cblxuZm4gR19TbWl0aChOb1Y6IGYzMiwgTm9MIDogZjMyLCByb3VnaG5lc3MgOiBmMzIpIC0+IGYzMlxue1xuICAgIHZhciBrID0gKHJvdWdobmVzcyAqIHJvdWdobmVzcykgLyAyLjA7XG4gICAgdmFyIEdHWEwgPSBOb0wgLyAoTm9MICogKDEuMCAtIGspICsgayk7XG4gICAgdmFyIEdHWFYgPSBOb1YgLyAoTm9WICogKDEuMCAtIGspICsgayk7XG4gICAgcmV0dXJuIEdHWEwgKiBHR1hWO1xufVxuXG5mbiBWX1NtaXRoR0dYQ29ycmVsYXRlZChOb1Y6IGYzMiwgTm9MIDogZjMyLCByb3VnaG5lc3MgOiBmMzIpIC0+IGYzMlxue1xuICAgIHZhciBhMiA9IHBvdyhyb3VnaG5lc3MsIDQuMCk7XG4gICAgdmFyIEdHWFYgPSBOb0wgKiBzcXJ0KE5vViAqIE5vViAqICgxLjAgLSBhMikgKyBhMik7XG4gICAgdmFyIEdHWEwgPSBOb1YgKiBzcXJ0KE5vTCAqIE5vTCAqICgxLjAgLSBhMikgKyBhMik7XG4gICAgcmV0dXJuIDAuNSAvIChHR1hWICsgR0dYTCk7XG59XG5cblxuLy8gQmFzZWQgb24gS2FyaXMgMjAxNFxuZm4gaW1wb3J0YW5jZVNhbXBsZUdHWChYaTogdmVjMjxmMzI+LCByb3VnaG5lc3M6IGYzMiwgTjogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj5cbntcbiAgICB2YXIgYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcbiAgICAvLyBTYW1wbGUgaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgdmFyIFBoaSA9IDIuMCAqIFBJICogWGkueDtcbiAgICB2YXIgQ29zVGhldGEgPSBzcXJ0KCgxLjAgLSBYaS55KSAvICgxLjAgKyAoYSAqIGEgLSAxLjApICogWGkueSkpO1xuICAgIHZhciBTaW5UaGV0YSA9IHNxcnQoMS4wIC0gQ29zVGhldGEgKiBDb3NUaGV0YSk7XG4gICAgLy8gQ29uc3RydWN0IHRhbmdlbnQgc3BhY2UgdmVjdG9yXG4gICAgdmFyIEg6IHZlYzM8ZjMyPjtcbiAgICBILnggPSBTaW5UaGV0YSAqIGNvcyhQaGkpO1xuICAgIEgueSA9IFNpblRoZXRhICogc2luKFBoaSk7XG4gICAgSC56ID0gQ29zVGhldGE7XG5cbiAgICAvLyBUYW5nZW50IHRvIHdvcmxkIHNwYWNlXG4gICAgdmFyIFVwVmVjdG9yID0gdmVjMzxmMzI+KDEuMCwgMC4wLCAwLjApO1xuICAgIGlmIChhYnMoTi56KSA8IDAuOTk5KSB7XG4gICAgICAgIFVwVmVjdG9yID0gdmVjMzxmMzI+KDAuMCwgMC4wLCAxLjApO1xuICAgIH1cbiAgICB2YXIgVGFuZ2VudFggPSBub3JtYWxpemUoY3Jvc3MoVXBWZWN0b3IsIE4pKTtcbiAgICB2YXIgVGFuZ2VudFkgPSBjcm9zcyhOLCBUYW5nZW50WCk7XG4gICAgcmV0dXJuIFRhbmdlbnRYICogSC54ICsgVGFuZ2VudFkgKiBILnkgKyBOICogSC56O1xufVxuXG5cbi8vIEthcmlzIDIwMTRcbmZuIGludGVncmF0ZUJSREYocm91Z2huZXNzOiBmMzIsIE5vVjogZjMyKSAtPiB2ZWMyPGYzMj5cbntcbiAgICB2YXIgVjogdmVjMzxmMzI+O1xuICAgIFYueCA9IHNxcnQoMS4wIC0gTm9WICogTm9WKTsgLy8gc2luXG4gICAgVi55ID0gMC4wO1xuICAgIFYueiA9IE5vVjsgLy8gY29zXG5cbiAgICAvLyBOIHBvaW50cyBzdHJhaWdodCB1cHdhcmRzIGZvciB0aGlzIGludGVncmF0aW9uXG4gICAgdmFyIE4gPSB2ZWMzPGYzMj4oMC4wLCAwLjAsIDEuMCk7XG5cbiAgICB2YXIgQSA9IDAuMDtcbiAgICB2YXIgQiA9IDAuMDtcbiAgICB2YXIgbnVtU2FtcGxlcyA9IDEwMjR1O1xuXG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgbnVtU2FtcGxlczsgaSArPSAxdSkge1xuICAgICAgICB2YXIgWGkgPSBoYW1tZXJzbGV5KGksIG51bVNhbXBsZXMpO1xuICAgICAgICAvLyBTYW1wbGUgbWljcm9mYWNldCBkaXJlY3Rpb25cbiAgICAgICAgdmFyIEggPSBpbXBvcnRhbmNlU2FtcGxlR0dYKFhpLCByb3VnaG5lc3MsIE4pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbGlnaHQgZGlyZWN0aW9uXG4gICAgICAgIHZhciBMID0gMi4wICogZG90KFYsIEgpICogSCAtIFY7XG5cbiAgICAgICAgdmFyIE5vTCA9IHNhdHVyYXRlKGRvdChOLCBMKSk7XG4gICAgICAgIHZhciBOb0ggPSBzYXR1cmF0ZShkb3QoTiwgSCkpO1xuICAgICAgICB2YXIgVm9IID0gc2F0dXJhdGUoZG90KFYsIEgpKTtcblxuICAgICAgICBpZiAoTm9MID4gMC4wKSB7XG4gICAgICAgICAgICB2YXIgVl9wZGYgPSBWX1NtaXRoR0dYQ29ycmVsYXRlZChOb1YsIE5vTCwgcm91Z2huZXNzKSAqIFZvSCAqIE5vTCAvIE5vSDtcbiAgICAgICAgICAgIHZhciBGYyA9IHBvdygxLjAgLSBWb0gsIDUuMCk7XG4gICAgICAgICAgICBBICs9ICgxLjAgLSBGYykgKiBWX3BkZjtcbiAgICAgICAgICAgIEIgKz0gRmMgKiBWX3BkZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiA0LjAgKiB2ZWMyPGYzMj4oQSwgQikgLyBmMzIobnVtU2FtcGxlcyk7XG59XG5cbkBncm91cCgwKSBAYmluZGluZygwKSB2YXIgYnJkZmx1dFRleHR1cmU6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhOHVub3JtLCB3cml0ZT47XG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoOCwgOCwgMSlcbi8vIGZuIENzTWFpbiggQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4gLCBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+ICl7XG5mbiBDc01haW4oQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KXtcbiAgICB2YXIgZnJhZ0Nvb3JkID0gdmVjMjx1MzI+KGdsb2JhbF9pbnZvY2F0aW9uX2lkLngsIGdsb2JhbF9pbnZvY2F0aW9uX2lkLnkpO1xuXG4gICAgdmFyIGZyYWdDb2xvciA9IHZlYzQ8ZjMyPigwLjApO1xuICAgIC8vIE91dHB1dCB0byBzY3JlZW5cbiAgICB2YXIgcmVzID0gaW50ZWdyYXRlQlJERihmMzIoZnJhZ0Nvb3JkLnkgKyAxdSkgLyAyNTYuMCwgZjMyKGZyYWdDb29yZC54ICsgMXUpIC8gMjU2LjApO1xuICAgIGZyYWdDb2xvciA9IHZlYzQ8ZjMyPihyZXMueCwgcmVzLnksIDAuMCwgMS4wKTtcblxuICAgIHRleHR1cmVTdG9yZShicmRmbHV0VGV4dHVyZSwgdmVjMjxpMzI+KGZyYWdDb29yZC54eSksIGZyYWdDb2xvcik7XG59XG5gO2NsYXNzIFF1e2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiY29tcHV0ZVwiKSx0aGlzLmNvbXB1dGU9bmV3IGJlKEd1KX1nZW5lcmF0ZUJSREZMVVRUZXh0dXJlKCl7bGV0IGU9bmV3IG9lKDI1NiwyNTYsRy5yZ2JhOHVub3JtLCExLEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyk7dGhpcy5jb21wdXRlLnNldFN0b3JhZ2VUZXh0dXJlKFwiYnJkZmx1dFRleHR1cmVcIixlKSx0aGlzLmNvbXB1dGUud29ya2VyU2l6ZVg9MjU2LzgsdGhpcy5jb21wdXRlLndvcmtlclNpemVZPTI1Ni84O2xldCB0PXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO3JldHVybiB3LmNvbXB1dGVDb21tYW5kKHQsW3RoaXMuY29tcHV0ZV0pLHcuZW5kQ29tbWFuZEVuY29kZXIodCksZX19Y2xhc3MgVnUgZXh0ZW5kcyBhdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwiX2RhdGFCdWZmZXJcIil9Y3JlYXRlKGUsdCxyLHM9ITEpe2xldCBhPVMuZGV2aWNlO2NvbnN0IG49TWF0aC5jZWlsKGUqNC8yNTYpKjI1Njt0aGlzLmZvcm1hdD1HLnJnYmE4dW5vcm0sdGhpcy5taXBtYXBDb3VudD1NYXRoLmZsb29yKHM/TWF0aC5sb2cyKGUpOjEpLHRoaXMuY3JlYXRlVGV4dHVyZURlc2NyaXB0b3IoZSx0LHRoaXMubWlwbWFwQ291bnQsdGhpcy5mb3JtYXQpO2NvbnN0IGw9dGhpcy5fZGF0YUJ1ZmZlcj1hLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpyLmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KTthLnF1ZXVlLndyaXRlQnVmZmVyKGwsMCxyKTtjb25zdCBoPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO3JldHVybiBoLmNvcHlCdWZmZXJUb1RleHR1cmUoe2J1ZmZlcjpsLGJ5dGVzUGVyUm93Om59LHt0ZXh0dXJlOnRoaXMuZ2V0R1BVVGV4dHVyZSgpfSx7d2lkdGg6ZSxoZWlnaHQ6dCxkZXB0aE9yQXJyYXlMYXllcnM6MX0pLHcuZW5kQ29tbWFuZEVuY29kZXIoaCkscyYmSHQud2ViR1BVR2VuZXJhdGVNaXBtYXAodGhpcyksdGhpc311cGRhdGVUZXh0dXJlKGUsdCxyKXtsZXQgcz1TLmRldmljZTtjb25zdCBhPU1hdGguY2VpbChlKjQvMjU2KSoyNTY7dGhpcy5taXBtYXBDb3VudD1NYXRoLmZsb29yKE1hdGgubG9nMihlKSksdGhpcy5fZGF0YUJ1ZmZlciYmdGhpcy5fZGF0YUJ1ZmZlci5kZXN0cm95KCksdGhpcy5fZGF0YUJ1ZmZlcj1udWxsO2NvbnN0IG49dGhpcy5fZGF0YUJ1ZmZlcj1zLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpyLmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KTtzLnF1ZXVlLndyaXRlQnVmZmVyKG4sMCxyKTtjb25zdCBsPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO2wuY29weUJ1ZmZlclRvVGV4dHVyZSh7YnVmZmVyOm4sYnl0ZXNQZXJSb3c6YX0se3RleHR1cmU6dGhpcy5nZXRHUFVUZXh0dXJlKCl9LHt3aWR0aDplLGhlaWdodDp0LGRlcHRoT3JBcnJheUxheWVyczoxfSksdy5lbmRDb21tYW5kRW5jb2RlcihsKSx0aGlzLmdwdVNhbXBsZXI9cy5jcmVhdGVTYW1wbGVyKHRoaXMpLHRoaXMubWlwbWFwQ291bnQ+MSYmSHQud2ViR1BVR2VuZXJhdGVNaXBtYXAodGhpcyl9fWNsYXNzIGZye2NvbnN0cnVjdG9yKGUpe28odGhpcyxcImlkXCIpLG8odGhpcyxcImd1aVRleHR1cmVcIiksbyh0aGlzLFwidXZSZWNcIixuZXcgaigwLDAsMSwxKSksbyh0aGlzLFwidXZCb3JkZXJcIixuZXcgaigwLDAsMCwwKSksbyh0aGlzLFwib2Zmc2V0U2l6ZVwiLG5ldyBqKDAsMCw0LDQpKSxvKHRoaXMsXCJib3JkZXJTaXplXCIsbmV3IGooMCwwLDAsMCkpLG8odGhpcyxcInRyaW1TaXplXCIsbmV3IFopLG8odGhpcyxcImlzU2xpY2VkXCIsITEpLG8odGhpcyxcImhlaWdodFwiLDQpLG8odGhpcyxcIndpZHRoXCIsNCksbyh0aGlzLFwieGFkdmFuY2VcIiwwKSxvKHRoaXMsXCJ4b2Zmc2V0XCIsMCksbyh0aGlzLFwieW9mZnNldFwiLDApLHRoaXMuZ3VpVGV4dHVyZT1lfHxBLnJlcy5kZWZhdWx0R1VJVGV4dHVyZX19Y29uc3QgS289Y2xhc3N7Y29uc3RydWN0b3IoaSl7byh0aGlzLFwiX3N0YXRpY0lkXCIsLTEpLG8odGhpcyxcImR5bmFtaWNJZFwiLC0xKSxvKHRoaXMsXCJ0ZXh0dXJlXCIpLG8odGhpcyxcIndpZHRoXCIsMSksbyh0aGlzLFwiaGVpZ2h0XCIsMSksaXx8KGk9QS5yZXMud2hpdGVUZXh0dXJlKSx0aGlzLnRleHR1cmU9aSxLby5fbWF4VWlkKyssdGhpcy5fc3RhdGljSWQ9S28uX21heFVpZCx0aGlzLmluaXQoKX1nZXQgc3RhdGljSWQoKXtyZXR1cm4gdGhpcy5fc3RhdGljSWR9aW5pdCgpe3RoaXMuZHluYW1pY0lkPS0xLHRoaXMud2lkdGg9dGhpcy50ZXh0dXJlLndpZHRoLHRoaXMuaGVpZ2h0PXRoaXMudGV4dHVyZS5oZWlnaHR9fTtsZXQgZHI9S287byhkcixcIl9tYXhVaWRcIiwtMSk7Y2xhc3MgVmd7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJmbnRDYWNoZVwiLHt9KSxvKHRoaXMsXCJmbnREYXRhXCIse30pfWFkZEZvbnREYXRhKGUsdCxyKXt0aGlzLmZudERhdGFbYCR7ZX0ke3R9YF09cn1nZXRGb250RGF0YShlLHQpe3JldHVybiB0aGlzLmZudERhdGFbYCR7ZX0ke3R9YF19YWRkRm50KGUsdCxyLHMpe2xldCBhPWAke2V9JHt0fWA7dGhpcy5mbnRDYWNoZVthXXx8KHRoaXMuZm50Q2FjaGVbYV09e30pLHRoaXMuZm50Q2FjaGVbYV1bcl09c31nZXRGbnQoZSx0LHIpe2xldCBzPWAke2V9JHt0fWAsYT10aGlzLmZudENhY2hlW3NdO3JldHVybiBhP2Fbcl06dGhpcy5mbnRDYWNoZVtcIiBcIl19fWxldCBncj1uZXcgVmc7Y2xhc3MgSHV7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJmYWNlXCIsXCJcIiksbyh0aGlzLFwic2l6ZVwiLDApLG8odGhpcyxcImJvbGRcIiwhMSksbyh0aGlzLFwiaXRhbGljXCIsITEpLG8odGhpcyxcInN0cmV0Y2hIXCIsMCksbyh0aGlzLFwic3BhY2luZ1wiLFwiXCIpLG8odGhpcyxcIm91dGxpbmVcIiwwKSxvKHRoaXMsXCJsaW5lSGVpZ2h0XCIsMCksbyh0aGlzLFwiYmFzZVwiLDApLG8odGhpcyxcInNjYWxlV1wiLDApLG8odGhpcyxcInNjYWxlSFwiLDApLG8odGhpcyxcInBhZ2VzXCIsMCksbyh0aGlzLFwicGFja2VkXCIsMCksbyh0aGlzLFwiYWxwaGFDaG5sXCIsMCksbyh0aGlzLFwicmVkQ2hubFwiLDApLG8odGhpcyxcImdyZWVuQ2hubFwiLDApLG8odGhpcyxcImJsdWVDaG5sXCIsMCksbyh0aGlzLFwiY291bnRcIiwwKSxvKHRoaXMsXCJmb250UGFnZVwiLFtdKSxvKHRoaXMsXCJmb250Q2hhclwiLHt9KX19Y2xhc3MgWXV7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJpZFwiLDApLG8odGhpcyxcImZpbGVcIixcIlwiKX19Y2xhc3MgWHV7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJpZFwiLC0xKSxvKHRoaXMsXCJ4XCIsMCksbyh0aGlzLFwieVwiLDApLG8odGhpcyxcIndpZHRoXCIsMCksbyh0aGlzLFwiaGVpZ2h0XCIsMCksbyh0aGlzLFwieG9mZnNldFwiLDApLG8odGhpcyxcInlvZmZzZXRcIiwwKSxvKHRoaXMsXCJ4YWR2YW5jZVwiLDApLG8odGhpcyxcInBhZ2VcIiwwKSxvKHRoaXMsXCJjaG5sXCIsMCl9fWNvbnN0IFJpPWNsYXNzIGV4dGVuZHMgWHR7c3RhdGljIHBhcnNlU3ByaXRlKGksZSl7Zm9yKGNvbnN0IHQgaW4gZS5mb250Q2hhcilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZS5mb250Q2hhcix0KSl7Y29uc3Qgcj1lLmZvbnRDaGFyW3RdO2xldCBzPW5ldyBmcjtzLmlkPXIuaWQudG9TdHJpbmcoKSxzLm9mZnNldFNpemUuc2V0KDAsMCxyLndpZHRoLHIuaGVpZ2h0KSxzLnRyaW1TaXplLnNldChyLndpZHRoLHIuaGVpZ2h0KSxzLndpZHRoPXIud2lkdGgscy5oZWlnaHQ9ci5oZWlnaHQscy54YWR2YW5jZT1yLnhhZHZhbmNlLHMueG9mZnNldD1yLnhvZmZzZXQscy55b2Zmc2V0PXIueW9mZnNldCxzLmd1aVRleHR1cmU9aVtyLnBhZ2VdLHMudXZSZWMuc2V0KHIueC9lLnNjYWxlVywoZS5zY2FsZUgtKHIueStyLmhlaWdodCkpL2Uuc2NhbGVILHIud2lkdGgvZS5zY2FsZVcsci5oZWlnaHQvZS5zY2FsZUgpLGdyLmFkZEZudChlLmZhY2UsZS5zaXplLHMuaWQscyl9fXZlcmlmaWNhdGlvbigpe2lmKHRoaXMuZGF0YSlyZXR1cm4hMDt0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKX1hc3luYyBwYXJzZVN0cmluZyhpKXtsZXQgZT10aGlzLmdldE5ld0xpbmUoaSksdD1pLHI9bmV3IEh1O3QudHJpbSgpLnNwbGl0KGUpLmZvckVhY2goKHMsYSk9PntpZihhPDIpUmkucmVhZExpbmVQcm9wZXJ0eShzLHIpO2Vsc2UgaWYoYTxyLnBhZ2VzKzIpe2xldCBuPW5ldyBZdTtSaS5yZWFkTGluZVByb3BlcnR5KHMsbiksci5mb250UGFnZS5wdXNoKG4pfWVsc2UgaWYoYTxyLnBhZ2VzKzMpUmkucmVhZExpbmVQcm9wZXJ0eShzLHIpO2Vsc2UgaWYoci5jb3VudD4wKXtsZXQgbj1uZXcgWHU7UmkucmVhZExpbmVQcm9wZXJ0eShzLG4pLHIuZm9udENoYXJbbi5pZF09bixyLmNvdW50LS19fSksdD1cIlwiLHRoaXMuZGF0YT1yLGF3YWl0IHRoaXMubG9hZEZvbnRUZXh0dXJlcygpfWdldE5ld0xpbmUoaSl7cmV0dXJuIGkuaW5kZXhPZihgXFxyXG5gKSE9LTE/YFxcclxuYDppLmluZGV4T2YoXCJcXHJcIikhPS0xP1wiXFxyXCI6YFxuYH1hc3luYyBsb2FkRm9udFRleHR1cmVzKCl7bGV0IGk9W10sZT10aGlzLmRhdGE7Zm9yKGNvbnN0IHQgb2YgZS5mb250UGFnZSl7bGV0IHI9dGhpcy5iYXNlVXJsK3QuZmlsZTthd2FpdCBBLnJlcy5sb2FkVGV4dHVyZShyLG51bGwsITApO2xldCBzPUEucmVzLmdldFRleHR1cmUociksYT1uZXcgZHIocyk7aS5wdXNoKGEpfVJpLnBhcnNlU3ByaXRlKGksZSksZS5mb250Q2hhcltcIiBcIl18fFJpLmluc2VydFNwYWNlQ2hhcihlLGlbMF0pfXN0YXRpYyBpbnNlcnRTcGFjZUNoYXIoaSxlKXtsZXQgdD1uZXcgZnIscj1pLnNpemUqLjUscz1pLmxpbmVIZWlnaHQqLjU7dC5pZD1cIiBcIix0Lm9mZnNldFNpemUuc2V0KDAsMCxpLnNpemUsaS5zaXplKSx0LnRyaW1TaXplLnNldChyLHMpLHQud2lkdGg9cix0LmhlaWdodD1zLHQueGFkdmFuY2U9MCx0LnhvZmZzZXQ9MCx0LnlvZmZzZXQ9MCx0Lmd1aVRleHR1cmU9ZSx0LnV2UmVjLnNldCgwLDAsMWUtNiwxZS02KSxnci5hZGRGbnQoaS5mYWNlLGkuc2l6ZSx0LmlkLHQpfXN0YXRpYyByZWFkTGluZVByb3BlcnR5KGksZSl7aS50cmltKCkuc3BsaXQoXCIgXCIpLmZvckVhY2goKHQscik9PntsZXQgcz10LnNwbGl0KFwiPVwiKTtpZihzLmxlbmd0aD4xKXtsZXQgYT1zWzBdLG49c1sxXTtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxhKSYmKG4uaW5kZXhPZignXCInKT09LTE/ZVthXT1wYXJzZUZsb2F0KHNbMV0pOmVbYV09bi5yZXBsYWNlKCdcIicsXCJcIikucmVwbGFjZSgnXCInLFwiXCIpKX19KX19O2xldCBKbz1SaTtvKEpvLFwiZm9ybWF0XCIsXCJ0ZXh0XCIpO2Z1bmN0aW9uIEhnKGksZSl7bGV0IHQ9bmV3IGZyO3JldHVybiB0LmlkPWksdC5vZmZzZXRTaXplLnNldCgwLDAsZS53aWR0aCxlLmhlaWdodCksdC50cmltU2l6ZS5zZXQoZS53aWR0aCxlLmhlaWdodCksdC53aWR0aD1lLndpZHRoLHQuaGVpZ2h0PWUuaGVpZ2h0LHQueGFkdmFuY2U9MCx0LnhvZmZzZXQ9MCx0LnlvZmZzZXQ9MCx0Lmd1aVRleHR1cmU9bmV3IGRyKGUpLHQudXZSZWMuc2V0KDAsMCwxLDEpLGUuaXNWaWRlb1RleHR1cmV8fChlLmZsaXBZPSEwKSx0fWZ1bmN0aW9uIFd1KGksZSx0KXtsZXQgcj1uZXcgZnI7ci5ndWlUZXh0dXJlPWksci5pZD1lLHIudXZSZWMuY29weUZyb20odC50ZXh0dXJlUmVjdCksci50cmltU2l6ZS54PXQudGV4dHVyZVJlY3QueixyLnRyaW1TaXplLnk9dC50ZXh0dXJlUmVjdC53LHIub2Zmc2V0U2l6ZS54PXQudGV4dHVyZVJlY3RPZmZzZXQueCxyLm9mZnNldFNpemUueT10LnRleHR1cmVSZWN0T2Zmc2V0Lnksci5vZmZzZXRTaXplLno9dC5zaXplLngsci5vZmZzZXRTaXplLnc9dC5zaXplLnksci53aWR0aD10LnNpemUueCxyLmhlaWdodD10LnNpemUueTtsZXQgcz0xL2kud2lkdGgsYT0xL2kuaGVpZ2h0O3IudXZSZWMuc2V0KHIudXZSZWMueCpzLHIudXZSZWMueSphLHIudXZSZWMueipzLHIudXZSZWMudyphKTtsZXQgbj0uMTtyZXR1cm4gdC5ib3JkZXIueDw9biYmdC5ib3JkZXIueTw9biYmdC5ib3JkZXIuejw9biYmdC5ib3JkZXIueDw9bj9yLmlzU2xpY2VkPSExOihyLmJvcmRlclNpemUuY29weUZyb20odC5ib3JkZXIpLHIudXZCb3JkZXIuY29weUZyb20odC5ib3JkZXIpLHIudXZCb3JkZXIueC09dC50ZXh0dXJlUmVjdE9mZnNldC54LHIudXZCb3JkZXIueS09dC50ZXh0dXJlUmVjdE9mZnNldC55LHIudXZCb3JkZXIuej10LmJvcmRlci56LSh0LnNpemUueC10LnRleHR1cmVSZWN0LnotdC50ZXh0dXJlUmVjdE9mZnNldC54KSxyLnV2Qm9yZGVyLnc9dC5ib3JkZXIudy0odC5zaXplLnktdC50ZXh0dXJlUmVjdC53LXQudGV4dHVyZVJlY3RPZmZzZXQueSksci51dkJvcmRlci54Lz10LnRleHR1cmVSZWN0Lnosci51dkJvcmRlci56Lz10LnRleHR1cmVSZWN0Lnosci51dkJvcmRlci55Lz10LnRleHR1cmVSZWN0Lncsci51dkJvcmRlci53Lz10LnRleHR1cmVSZWN0Lncsci5pc1NsaWNlZD0hMCkscn1jbGFzcyBqdXtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJfc3ByaXRlTWFwXCIsbmV3IE1hcCksbyh0aGlzLFwiX3Nwcml0ZUxpc3RcIixbXSksbyh0aGlzLFwidGV4dHVyZVNpemVcIixuZXcgWiksbyh0aGlzLFwibmFtZVwiKSx0aGlzLnRleHR1cmVTaXplLnNldChlLngsZS55KX1zZXRUZXh0dXJlKGUsdCxyKXtsZXQgcz1XdShlLHQscik7cmV0dXJuIHRoaXMuX3Nwcml0ZU1hcC5zZXQocy5pZCxzKSx0aGlzLl9zcHJpdGVMaXN0LnB1c2gocyksc31nZXRTcHJpdGUoZSl7cmV0dXJuIHRoaXMuX3Nwcml0ZU1hcC5nZXQoZSl9Z2V0IHNwcml0ZUxpc3QoKXtyZXR1cm4gdGhpcy5fc3ByaXRlTGlzdH19Y2xhc3MgWm8gZXh0ZW5kcyBYdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwiX2pzb25cIiksbyh0aGlzLFwiX3RleHR1cmVcIil9YXN5bmMgcGFyc2VTdHJpbmcoZSl7dGhpcy5fanNvbj1KU09OLnBhcnNlKGUpO2xldCB0PXRoaXMudXNlckRhdGEucmVwbGFjZShcIi5qc29uXCIsXCIucG5nXCIpO3RoaXMuX3RleHR1cmU9YXdhaXQgQS5yZXMubG9hZFRleHR1cmUodCxudWxsLCEwKSx0aGlzLmRhdGE9e2pzb246dGhpcy5fanNvbix0ZXh0dXJlOnRoaXMuX3RleHR1cmV9LHRoaXMucGFyc2VBdGxhcygpfXZlcmlmaWNhdGlvbigpe2lmKHRoaXMuZGF0YSlyZXR1cm4hMDt0aHJvdyBuZXcgRXJyb3IoXCJ2ZXJpZnkgZmFpbGVkLlwiKX1wYXJzZUF0bGFzKCl7bGV0IGU9bmV3IGp1KHRoaXMuX2pzb24uc2l6ZSksdD1uZXcgZHIodGhpcy5fdGV4dHVyZSkscj10aGlzLl9qc29uLmF0bGFzO2Zvcihjb25zdCBzIGluIHIpZS5zZXRUZXh0dXJlKHQscyxyW3NdKTtBLnJlcy5hZGRBdGxhcyh0aGlzLmJhc2VVcmwsZSksdGhpcy5kYXRhPWV9fW8oWm8sXCJmb3JtYXRcIixcInRleHRcIik7Y2xhc3MgcXV7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJfdGV4dHVyZVBvb2xcIiksbyh0aGlzLFwiX21hdGVyaWFsUG9vbFwiKSxvKHRoaXMsXCJfcHJlZmFiUG9vbFwiKSxvKHRoaXMsXCJfZ2x0ZlBvb2xcIiksbyh0aGlzLFwiX2F0bGFzTGlzdFwiKSxvKHRoaXMsXCJub3JtYWxUZXh0dXJlXCIpLG8odGhpcyxcIm1hc2tUZXh0dXJlXCIpLG8odGhpcyxcIndoaXRlVGV4dHVyZVwiKSxvKHRoaXMsXCJibGFja1RleHR1cmVcIiksbyh0aGlzLFwicmVkVGV4dHVyZVwiKSxvKHRoaXMsXCJibHVlVGV4dHVyZVwiKSxvKHRoaXMsXCJncmVlblRleHR1cmVcIiksbyh0aGlzLFwieWVsbG93VGV4dHVyZVwiKSxvKHRoaXMsXCJncmF5VGV4dHVyZVwiKSxvKHRoaXMsXCJkZWZhdWx0U2t5XCIpLG8odGhpcyxcImRlZmF1bHRHVUlUZXh0dXJlXCIpLG8odGhpcyxcImRlZmF1bHRHVUlTcHJpdGVcIiksdGhpcy5fdGV4dHVyZVBvb2w9bmV3IE1hcCx0aGlzLl9tYXRlcmlhbFBvb2w9bmV3IE1hcCx0aGlzLl9wcmVmYWJQb29sPW5ldyBNYXAsdGhpcy5fZ2x0ZlBvb2w9bmV3IE1hcCx0aGlzLl9hdGxhc0xpc3Q9bmV3IE1hcCx0aGlzLmluaXREZWZhdWx0KCl9Z2V0R2x0ZihlKXtyZXR1cm4gdGhpcy5fZ2x0ZlBvb2wuZ2V0KGUpfWFkZFRleHR1cmUoZSx0KXt0aGlzLl90ZXh0dXJlUG9vbC5zZXQoZSx0KX1nZXRUZXh0dXJlKGUpe3JldHVybiB0aGlzLl90ZXh0dXJlUG9vbC5nZXQoZSl9YWRkTWF0KGUsdCl7cmV0dXJuIHRoaXMuX21hdGVyaWFsUG9vbC5zZXQoZSx0KX1nZXRNYXQoZSl7cmV0dXJuIHRoaXMuX21hdGVyaWFsUG9vbC5nZXQoZSl9YWRkUHJlZmFiKGUsdCl7dGhpcy5fcHJlZmFiUG9vbC5zZXQoZSx0KX1nZXRQcmVmYWIoZSl7cmV0dXJuIHRoaXMuX3ByZWZhYlBvb2wuZ2V0KGUpLmluc3RhbnRpYXRlKCl9YWRkQXRsYXMoZSx0KXt0Lm5hbWU9ZSx0aGlzLl9hdGxhc0xpc3Quc2V0KGUsdCl9Z2V0QXRsYXMoZSl7cmV0dXJuIHRoaXMuX2F0bGFzTGlzdC5nZXQoZSl9Z2V0R1VJU3ByaXRlKGUpe2ZvcihsZXQgdCBvZiB0aGlzLl9hdGxhc0xpc3QudmFsdWVzKCkpe2xldCByPXQuZ2V0U3ByaXRlKGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIG51bGx9YXN5bmMgbG9hZEdsdGYoZSx0KXtpZih0aGlzLl9wcmVmYWJQb29sLmhhcyhlKSlyZXR1cm4gdGhpcy5fcHJlZmFiUG9vbC5nZXQoZSk7bGV0IHIscz1lLnN1YnN0cmluZyhlLmxhc3RJbmRleE9mKFwiLlwiKSkudG9Mb3dlckNhc2UoKSxhPW5ldyBodDtzPT1cIi5nbHRmXCI/cj1hd2FpdCBhLmxvYWQoZSxLZSx0KTpyPWF3YWl0IGEubG9hZChlLHFzLHQpO2xldCBuPXIuZGF0YTtyZXR1cm4gdGhpcy5fcHJlZmFiUG9vbC5zZXQoZSxuKSx0aGlzLl9nbHRmUG9vbC5zZXQoZSxyLmdsdGYpLG59YXN5bmMgbG9hZE9iaihlLHQpe2lmKHRoaXMuX3ByZWZhYlBvb2wuaGFzKGUpKXJldHVybiB0aGlzLl9wcmVmYWJQb29sLmdldChlKTtsZXQgcixzPWUuc3Vic3RyaW5nKGUubGFzdEluZGV4T2YoXCIuXCIpKS50b0xvd2VyQ2FzZSgpLGE9bmV3IGh0O3M9PVwiLm9ialwiJiYocj1hd2FpdCBhLmxvYWQoZSxGbyx0KSk7bGV0IG49ci5kYXRhO3JldHVybiB0aGlzLl9wcmVmYWJQb29sLnNldChlLG4pLG59YXN5bmMgbG9hZEIzRE0oZSx0LHIpe2lmKHRoaXMuX3ByZWZhYlBvb2wuaGFzKGUpKXJldHVybiB0aGlzLl9wcmVmYWJQb29sLmdldChlKTtsZXQgbj0oYXdhaXQgbmV3IGh0KCkubG9hZChlLFhvLHQscikpLmRhdGE7cmV0dXJuIHRoaXMuX3ByZWZhYlBvb2wuc2V0KGUsbiksbn1hc3luYyBsb2FkSTNETShlLHQscil7aWYodGhpcy5fcHJlZmFiUG9vbC5oYXMoZSkpcmV0dXJuIHRoaXMuX3ByZWZhYlBvb2wuZ2V0KGUpO2xldCBuPShhd2FpdCBuZXcgaHQoKS5sb2FkKGUscW8sdCxyKSkuZGF0YTtyZXR1cm4gdGhpcy5fcHJlZmFiUG9vbC5zZXQoZSxuKSxufWFzeW5jIGxvYWRUZXh0dXJlKGUsdCxyKXtpZih0aGlzLl90ZXh0dXJlUG9vbC5oYXMoZSkpcmV0dXJuIHRoaXMuX3RleHR1cmVQb29sLmdldChlKTtsZXQgcz1uZXcgaWk7cmV0dXJuIHMuZmxpcFk9cixhd2FpdCBzLmxvYWQoZSx0KSx0aGlzLl90ZXh0dXJlUG9vbC5zZXQoZSxzKSxzfWFzeW5jIGxvYWRIRFJUZXh0dXJlKGUsdCl7aWYodGhpcy5fdGV4dHVyZVBvb2wuaGFzKGUpKXJldHVybiB0aGlzLl90ZXh0dXJlUG9vbC5nZXQoZSk7bGV0IHI9bmV3IEdvO3JldHVybiByPWF3YWl0IHIubG9hZChlLHQpLHRoaXMuX3RleHR1cmVQb29sLnNldChlLHIpLHJ9YXN5bmMgbG9hZEhEUlRleHR1cmVDdWJlKGUsdCl7aWYodGhpcy5fdGV4dHVyZVBvb2wuaGFzKGUpKXJldHVybiB0aGlzLl90ZXh0dXJlUG9vbC5nZXQoZSk7bGV0IHI9bmV3IGVhO3JldHVybiByPWF3YWl0IHIubG9hZChlLHQpLHRoaXMuX3RleHR1cmVQb29sLnNldChlLHIpLHJ9YXN5bmMgbG9hZExEUlRleHR1cmVDdWJlKGUsdCl7aWYodGhpcy5fdGV4dHVyZVBvb2wuaGFzKGUpKXJldHVybiB0aGlzLl90ZXh0dXJlUG9vbC5nZXQoZSk7bGV0IHI9bmV3IHJhO3JldHVybiByPWF3YWl0IHIubG9hZChlLHQpLHRoaXMuX3RleHR1cmVQb29sLnNldChlLHIpLHJ9YXN5bmMgbG9hZFRleHR1cmVDdWJlTWFwcyhlKXtsZXQgdD1lWzBdO2lmKHRoaXMuX3RleHR1cmVQb29sLmhhcyh0KSlyZXR1cm4gdGhpcy5fdGV4dHVyZVBvb2wuZ2V0KHQpO2xldCByPW5ldyBrbztyZXR1cm4gYXdhaXQgci5sb2FkKGUpLHRoaXMuX3RleHR1cmVQb29sLnNldChlWzBdLHIpLHJ9YXN5bmMgbG9hZFRleHR1cmVDdWJlU3RkKGUsdCl7aWYodGhpcy5fdGV4dHVyZVBvb2wuaGFzKGUpKXJldHVybiB0aGlzLl90ZXh0dXJlUG9vbC5nZXQoZSk7bGV0IHI9bmV3IGtvO3JldHVybiBhd2FpdCByLmxvYWRTdGQoZSkscn1hc3luYyBsb2FkSlNPTihlLHQpe3JldHVybiBhd2FpdCBuZXcgaHQoKS5sb2FkSnNvbihlLHQpLnRoZW4oYXN5bmMgcj0+cikuY2F0Y2gocj0+e2NvbnNvbGUubG9nKHIpfSl9YXN5bmMgbG9hZEZvbnQoZSx0LHIpe2xldCBhPWF3YWl0IG5ldyBodCgpLmxvYWQoZSxKbyx0LHIpLG49YS5kYXRhO3JldHVybiBnci5hZGRGb250RGF0YShuLmZhY2Usbi5zaXplLG4pLGEuZGF0YX1hc3luYyBsb2FkQXRsYXMoZSx0KXtyZXR1cm4oYXdhaXQgbmV3IGh0KCkubG9hZChlLFpvLHQsZSkpLmRhdGF9Y3JlYXRlVGV4dHVyZShlLHQscixzLGEsbixsKXtsZXQgaD0zMix1PTMyLGM9bmV3IFVpbnQ4QXJyYXkoaCp1KjQpO3RoaXMuZmlsbENvbG9yKGMsZSx0LHIscyxhLG4pO2xldCBmPW5ldyBWdTtyZXR1cm4gZi5uYW1lPWwsZi5jcmVhdGUoMTYsMTYsYywhMCksbCYmdGhpcy5hZGRUZXh0dXJlKGwsZiksZn1maWxsQ29sb3IoZSx0LHIscyxhLG4sbCl7Zm9yKGxldCBoPTA7aDx0O2grKylmb3IobGV0IHU9MDt1PHI7dSsrKXtsZXQgYz11KnQraDtlW2MqNCswXT1zLGVbYyo0KzFdPWEsZVtjKjQrMl09bixlW2MqNCszXT1sfX1pbml0RGVmYXVsdCgpe3RoaXMubm9ybWFsVGV4dHVyZT10aGlzLmNyZWF0ZVRleHR1cmUoMzIsMzIsMjU1Ki41LDI1NSouNSwyNTUsMjU1LFwiZGVmYXVsdC1ub3JtYWxUZXh0dXJlXCIpLHRoaXMubWFza1RleHR1cmU9dGhpcy5jcmVhdGVUZXh0dXJlKDMyLDMyLDI1NSwyNTUqLjUsMCwyNTUsXCJkZWZhdWx0LW1hc2tUZXh0dXJlXCIpLHRoaXMud2hpdGVUZXh0dXJlPXRoaXMuY3JlYXRlVGV4dHVyZSgzMiwzMiwyNTUsMjU1LDI1NSwyNTUsXCJkZWZhdWx0LXdoaXRlVGV4dHVyZVwiKSx0aGlzLmJsYWNrVGV4dHVyZT10aGlzLmNyZWF0ZVRleHR1cmUoMzIsMzIsMCwwLDAsMjU1LFwiZGVmYXVsdC1ibGFja1RleHR1cmVcIiksdGhpcy5yZWRUZXh0dXJlPXRoaXMuY3JlYXRlVGV4dHVyZSgzMiwzMiwyNTUsMCwwLDI1NSxcImRlZmF1bHQtcmVkVGV4dHVyZVwiKSx0aGlzLmJsdWVUZXh0dXJlPXRoaXMuY3JlYXRlVGV4dHVyZSgzMiwzMiwwLDAsMjU1LDI1NSxcImRlZmF1bHQtYmx1ZVRleHR1cmVcIiksdGhpcy5ncmVlblRleHR1cmU9dGhpcy5jcmVhdGVUZXh0dXJlKDMyLDMyLDAsMjU1LDAsMjU1LFwiZGVmYXVsdC1ncmVlblRleHR1cmVcIiksdGhpcy55ZWxsb3dUZXh0dXJlPXRoaXMuY3JlYXRlVGV4dHVyZSgzMiwzMiwwLDI1NSwyNTUsMjU1LFwiZGVmYXVsdC15ZWxsb3dUZXh0dXJlXCIpLHRoaXMuZ3JheVRleHR1cmU9dGhpcy5jcmVhdGVUZXh0dXJlKDMyLDMyLDEyOCwxMjgsMTI4LDI1NSxcImRlZmF1bHQtZ3JheVRleHR1cmVcIik7bGV0IHQ9bmV3IFF1KCkuZ2VuZXJhdGVCUkRGTFVUVGV4dHVyZSgpLHI9dC5uYW1lPVwiQlJERkxVVFwiO3RoaXMuYWRkVGV4dHVyZShyLHQpLHRoaXMuZGVmYXVsdFNreT1uZXcgZWEsdGhpcy5kZWZhdWx0U2t5LmNyZWF0ZUZyb21UZXh0dXJlKDEyOCx0aGlzLmJsYWNrVGV4dHVyZSksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZCh0aGlzLmRlZmF1bHRTa3ksdGhpcyksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZCh0LHRoaXMpLHNlLmdldEluc3RhbmNlKCkuYXR0YWNoZWQodGhpcy5ub3JtYWxUZXh0dXJlLHRoaXMpLHNlLmdldEluc3RhbmNlKCkuYXR0YWNoZWQodGhpcy5tYXNrVGV4dHVyZSx0aGlzKSxzZS5nZXRJbnN0YW5jZSgpLmF0dGFjaGVkKHRoaXMud2hpdGVUZXh0dXJlLHRoaXMpLHNlLmdldEluc3RhbmNlKCkuYXR0YWNoZWQodGhpcy5ibGFja1RleHR1cmUsdGhpcyksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZCh0aGlzLnJlZFRleHR1cmUsdGhpcyksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZCh0aGlzLmJsdWVUZXh0dXJlLHRoaXMpLHNlLmdldEluc3RhbmNlKCkuYXR0YWNoZWQodGhpcy5ncmVlblRleHR1cmUsdGhpcyksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZCh0aGlzLnllbGxvd1RleHR1cmUsdGhpcyksc2UuZ2V0SW5zdGFuY2UoKS5hdHRhY2hlZCh0aGlzLmdyYXlUZXh0dXJlLHRoaXMpLHRoaXMuZGVmYXVsdEdVSVRleHR1cmU9bmV3IGRyKHRoaXMud2hpdGVUZXh0dXJlKSx0aGlzLmRlZmF1bHRHVUlTcHJpdGU9bmV3IGZyKHRoaXMuZGVmYXVsdEdVSVRleHR1cmUpLHRoaXMuZGVmYXVsdEdVSVNwcml0ZS50cmltU2l6ZS5zZXQoNCw0KX19Y2xhc3MgeWV7fW8oeWUsXCJwaXhlbFJhdGlvXCIsMSksbyh5ZSxcInNvbHV0aW9uXCIsbmV3IFooMTYwMCwxMjgwKSksbyh5ZSxcInF1YWRNYXhDb3VudEZvcldvcmxkXCIsMjU2KSxvKHllLFwicXVhZE1heENvdW50Rm9yVmlld1wiLDIwNDgpLG8oeWUsXCJTb3J0T3JkZXJTdGFydFdvcmxkXCIsN2UzKSxvKHllLFwiU29ydE9yZGVyU3RhcnRWaWV3XCIsOGUzKSxvKHllLFwiU29ydE9yZGVyQ2FudmFzU3BhblwiLDFlNCk7dmFyIE50PShpPT4oaVtpLlZpZXc9MF09XCJWaWV3XCIsaVtpLldvcmxkPTJdPVwiV29ybGRcIixpKSkoTnR8fHt9KSxwcj0oaT0+KGlbaS5TaW1wbGU9MF09XCJTaW1wbGVcIixpW2kuU2xpY2VkPTFdPVwiU2xpY2VkXCIsaVtpLlRpbGVkPTJdPVwiVGlsZWRcIixpW2kuRmlsbGVkPTNdPVwiRmlsbGVkXCIsaSkpKHByfHx7fSkseGk9KGk9PihpW2kuTm9uZT0wXT1cIk5vbmVcIixpW2kuQmlsbGJvYXJkWT05XT1cIkJpbGxib2FyZFlcIixpW2kuQmlsbGJvYXJkWFlaPTEwXT1cIkJpbGxib2FyZFhZWlwiLGkpKSh4aXx8e30pO2NsYXNzIEF7c3RhdGljIGdldCBmcmFtZVJhdGUoKXtyZXR1cm4gdGhpcy5fZnJhbWVSYXRlfXN0YXRpYyBzZXQgZnJhbWVSYXRlKGUpe3RoaXMuX2ZyYW1lUmF0ZT1lLHRoaXMuX2ZyYW1lUmF0ZVZhbHVlPTEvZSxlPj0zNjAmJih0aGlzLl9mcmFtZVJhdGVWYWx1ZT0wKX1zdGF0aWMgZ2V0IHNpemUoKXtyZXR1cm4gUy5wcmVzZW50YXRpb25TaXplfXN0YXRpYyBnZXQgYXNwZWN0KCl7cmV0dXJuIFMuYXNwZWN0fXN0YXRpYyBnZXQgd2lkdGgoKXtyZXR1cm4gUy53aW5kb3dXaWR0aH1zdGF0aWMgZ2V0IGhlaWdodCgpe3JldHVybiBTLndpbmRvd0hlaWdodH1zdGF0aWMgYXN5bmMgaW5pdChlPXt9KXtjb25zb2xlLmxvZyhcIkVuZ2luZSBWZXJzaW9uXCIsSGYpLHRoaXMuZGl2Qj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuZGl2Qi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy5kaXZCLnN0eWxlLnpJbmRleD1cIjk5OVwiLHRoaXMuZGl2Qi5zdHlsZS5jb2xvcj1cIiNGRkZGRkZcIix0aGlzLmRpdkIuc3R5bGUudG9wPVwiMTUwcHhcIixkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGl2QiksdGhpcy5zZXR0aW5nPXsuLi50aGlzLnNldHRpbmcsLi4uZS5lbmdpbmVTZXR0aW5nfSxhd2FpdCBlZS5pbml0KFYuYWxsb2NDb3VudCksYXdhaXQgUy5pbml0KGUuY2FudmFzQ29uZmlnKSxOLmluaXQoKSxPdC5pbml0KCkscGUuaW5pdCgpLEZlLmluaXQoKSxWZS5pbml0KCksdGhpcy5yZXM9bmV3IHF1LHRoaXMuX2JlZm9yZVJlbmRlcj1lLmJlZm9yZVJlbmRlcix0aGlzLl9yZW5kZXJMb29wPWUucmVuZGVyTG9vcCx0aGlzLl9sYXRlUmVuZGVyPWUubGF0ZVJlbmRlcix0aGlzLmlucHV0U3lzdGVtPW5ldyBJbix0aGlzLmlucHV0U3lzdGVtLmluaXRDYW52YXMoUy5jYW52YXMpfXN0YXRpYyBzdGFydFJlbmRlclZpZXcoZSl7dGhpcy5yZW5kZXJKb2JzfHwodGhpcy5yZW5kZXJKb2JzPW5ldyBNYXApLHRoaXMudmlld3M9W2VdO2xldCB0PW5ldyB3byhlKTtyZXR1cm4gdGhpcy5yZW5kZXJKb2JzLnNldChlLHQpLHQuYWRkUG9zdChuZXcgdW8pLHQuc3RhcnQoKSx0aGlzLnJlc3VtZSgpLHR9c3RhdGljIHN0YXJ0UmVuZGVyVmlld3MoZSl7dGhpcy5yZW5kZXJKb2JzfHwodGhpcy5yZW5kZXJKb2JzPW5ldyBNYXApLHRoaXMudmlld3M9ZTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgcj1lW3RdO2xldCBzPW5ldyB3byhyKTt0aGlzLnJlbmRlckpvYnMuc2V0KHIscykscy5hZGRQb3N0KG5ldyB1bykscy5zdGFydCgpfXRoaXMucmVzdW1lKCl9c3RhdGljIGdldFJlbmRlckpvYihlKXtyZXR1cm4gdGhpcy5yZW5kZXJKb2JzLmdldChlKX1zdGF0aWMgcGF1c2UoKXt0aGlzLl9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJRCE9MCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RBbmltYXRpb25GcmFtZUlEKSx0aGlzLl9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJRD0wKX1zdGF0aWMgcmVzdW1lKCl7dGhpcy5fcmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGU9PnRoaXMucmVuZGVyKGUpKX1zdGF0aWMgcmVuZGVyKGUpe3RoaXMuX2RlbHRhVGltZT1lLXRoaXMuX3RpbWUsdGhpcy5fdGltZT1lLHRoaXMuX2ZyYW1lUmF0ZVZhbHVlPjA/KHRoaXMuX2ZyYW1lVGltZUNvdW50Kz10aGlzLl9kZWx0YVRpbWUqLjAwMSx0aGlzLl9mcmFtZVRpbWVDb3VudD49dGhpcy5fZnJhbWVSYXRlVmFsdWUqLjk1JiYodGhpcy5fZnJhbWVUaW1lQ291bnQ9MCx0aGlzLnVwZGF0ZUZyYW1lKGUpKSk6dGhpcy51cGRhdGVGcmFtZShlKSx0aGlzLnJlc3VtZSgpfXN0YXRpYyB1cGRhdGVHVUlQaXhlbFJhdGlvKGUsdCl7bGV0IHI9eWUuc29sdXRpb24ueC95ZS5zb2x1dGlvbi55LHM9ZS90O3I8cz95ZS5waXhlbFJhdGlvPXQveWUuc29sdXRpb24ueTp5ZS5waXhlbFJhdGlvPWUveWUuc29sdXRpb24ueH1zdGF0aWMgdXBkYXRlRnJhbWUoZSl7aGUuZGVsdGE9ZS1oZS50aW1lLGhlLnRpbWU9ZSxoZS5mcmFtZSs9MSxTby50aWNrKGhlLmRlbHRhKTtsZXQgdD10aGlzLnZpZXdzLHI9MDtmb3Iocj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBuPXRbcl07bi5zY2VuZS53YWl0VXBkYXRlKCksbi5jYW1lcmEucmVzZXRQZXJzcGVjdGl2ZShTLmFzcGVjdCl9dGhpcy51cGRhdGVHVUlQaXhlbFJhdGlvKFMuY2FudmFzLmNsaWVudFdpZHRoLFMuY2FudmFzLmNsaWVudEhlaWdodCksdGhpcy5fYmVmb3JlUmVuZGVyJiZ0aGlzLl9iZWZvcmVSZW5kZXIoKTtmb3IoY29uc3QgbiBvZiBhZS5jb21wb25lbnRzQmVmb3JlVXBkYXRlTGlzdCl7bGV0IGw9blswXSxoPW5bMV07Zm9yKGNvbnN0IHUgb2YgaCl7bGV0IGM9dVswXSxmPXVbMV07Yy5lbmFibGUmJmYobCl9fWxldCBzPVMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7Zm9yKGNvbnN0IG4gb2YgYWUuY29tcG9uZW50c0NvbXB1dGVMaXN0KXtsZXQgbD1uWzBdLGg9blsxXTtmb3IoY29uc3QgdSBvZiBoKXtsZXQgYz11WzBdLGY9dVsxXTtjLmVuYWJsZSYmZihsLHMpfX1TLmRldmljZS5xdWV1ZS5zdWJtaXQoW3MuZmluaXNoKCldKTtmb3IoY29uc3QgbiBvZiBhZS5jb21wb25lbnRzVXBkYXRlTGlzdCl7bGV0IGw9blswXSxoPW5bMV07Zm9yKGNvbnN0IHUgb2YgaCl7bGV0IGM9dVswXSxmPXVbMV07Yy5lbmFibGUmJmYobCl9fXRoaXMuX3JlbmRlckxvb3AmJnRoaXMuX3JlbmRlckxvb3AoKSxlZS51cGRhdGVBbGxDb250aW51ZVRyYW5zZm9ybSgwLFYudXNlQ291bnQsMTYpLHBlLm1vZGVsTWF0cml4QmluZEdyb3VwLndyaXRlQnVmZmVyKFYudXNlQ291bnQqMTYpLHRoaXMucmVuZGVySm9icy5mb3JFYWNoKChuLGwpPT57bi5yZW5kZXJGcmFtZSgpfSk7Zm9yKGNvbnN0IG4gb2YgYWUuY29tcG9uZW50c0xhdGVVcGRhdGVMaXN0KXtsZXQgbD1uWzBdLGg9blsxXTtmb3IoY29uc3QgdSBvZiBoKXtsZXQgYz11WzBdLGY9dVsxXTtjLmVuYWJsZSYmZihsKX19dGhpcy5fbGF0ZVJlbmRlciYmdGhpcy5fbGF0ZVJlbmRlcigpfX1vKEEsXCJyZXNcIiksbyhBLFwiaW5wdXRTeXN0ZW1cIiksbyhBLFwidmlld3NcIiksbyhBLFwiX2ZyYW1lUmF0ZVZhbHVlXCIsMCksbyhBLFwiX2ZyYW1lUmF0ZVwiLDM2MCksbyhBLFwiX2ZyYW1lVGltZUNvdW50XCIsMCksbyhBLFwiX2RlbHRhVGltZVwiLDApLG8oQSxcIl90aW1lXCIsMCksbyhBLFwiX2JlZm9yZVJlbmRlclwiKSxvKEEsXCJfcmVuZGVyTG9vcFwiKSxvKEEsXCJfbGF0ZVJlbmRlclwiKSxvKEEsXCJfcmVxdWVzdEFuaW1hdGlvbkZyYW1lSURcIiwwKSxvKEEsXCJFbmdpbmUzRFwiKSxvKEEsXCJkaXZCXCIpLG8oQSxcInNldHRpbmdcIix7b2NjbHVzaW9uUXVlcnk6e2VuYWJsZTohMCxkZWJ1ZzohMX0scGljazp7ZW5hYmxlOiEwLG1vZGU6XCJib3VuZFwiLGRldGFpbDpcIm1lc2hcIn0scmVuZGVyOntkZWJ1ZzohMSxyZW5kZXJQYXNzU3RhdGU6NCxyZW5kZXJTdGF0ZV9sZWZ0OjUscmVuZGVyU3RhdGVfcmlnaHQ6NSxyZW5kZXJTdGF0ZV9zcGxpdDouNSxxdWFkU2NhbGU6MSxoZHJFeHBvc3VyZToxLjUsZGVidWdRdWFkOi0xLG1heFBvaW50TGlnaHQ6MWUzLG1heERpcmVjdExpZ2h0OjQsbWF4U3BvcnRMaWdodDoxZTMsZHJhd09wTWluOjAsZHJhd09wTWF4Ok51bWJlci5NQVhfU0FGRV9JTlRFR0VSLGRyYXdUck1pbjowLGRyYXdUck1heDpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUix6UHJlUGFzczohMSx1c2VMb2dEZXB0aDohMSxnaTohMSxwb3N0UHJvY2Vzc2luZzp7Z2xvYmFsRm9nOntkZWJ1ZzohMSxlbmFibGU6ITEsZm9nVHlwZTowLGZvZ0hlaWdodFNjYWxlOi4xLHN0YXJ0OjQwMCxlbmQ6MTAsZGVuc2l0eTouMDIsaW5zOi41LHNreUZhY3RvcjouNSxza3lSb3VnaG5lc3M6LjQsb3ZlcnJpZGVTa3lGYWN0b3I6LjgsZm9nQ29sb3I6bmV3IHooMTEyLzI1NSw2MS8yNTUsMTM5LzI1NSwxKSxmYWxsb2ZmOi43LHJheUxlbmd0aDoyMDAsc2NhdHRlcmluZ0V4cG9uZW50OjIuNyxkaXJIZWlnaHRMaW5lOjEwfSxzc2FvOntlbmFibGU6ITEscmFkaXVzOi4xNSxiaWFzOi0uMSxhb1Bvd2VyOjIsZGVidWc6ITB9LG91dGxpbmU6e2VuYWJsZTohMSxzdHJlbmd0aDoxLGdyb3VwQ291bnQ6NCxvdXRsaW5lUGl4ZWw6MixmYWRlT3V0bGluZVBpeGVsOjQsdGV4dHVyZVNjYWxlOi43LHVzZUFkZE1vZGU6ITEsZGVidWc6ITB9LHRhYTp7ZW5hYmxlOiExLGppdHRlclNlZWRDb3VudDo4LGJsZW5kRmFjdG9yOi4xLHNoYXJwRmFjdG9yOi42LHNoYXJwUHJlQmx1ckZhY3RvcjouNSx0ZW1wb3JhbEppdHRlclNjYWxlOi4xMyxkZWJ1ZzohMH0sZ3Rhbzp7ZW5hYmxlOiExLGRhcmtGYWN0b3I6MSxtYXhEaXN0YW5jZTo1LG1heFBpeGVsOjUwLHJheU1hcmNoU2VnbWVudDo2LG11bHRpQm91bmNlOiExLHVzZVBvc0Zsb2F0MzI6ITAsYmxlbmRDb2xvcjohMCxkZWJ1ZzohMH0sc3NyOntlbmFibGU6ITEscGl4ZWxSYXRpbzoxLGZhZGVFZGdlUmF0aW86LjIscmF5TWFyY2hSYXRpbzouNSxmYWRlRGlzdGFuY2VNaW46NjAwLGZhZGVEaXN0YW5jZU1heDoyZTMscm91Z2huZXNzVGhyZXNob2xkOi41LHBvd0RvdFJOOi4yLG1peFRocmVzaG9sZDouMSxkZWJ1ZzohMH0sYmxvb206e2VuYWJsZTohMSxibHVyWDo0LGJsdXJZOjQsc3RyZW5ndGg6LjI1LGV4cG9zdXJlOjEscmFkaXVzOjEuMyxsdW1pbm9zaXR5VGhyZXNob2xkOi45OCxkZWJ1ZzohMX0sZnhhYTp7ZW5hYmxlOiExfSxkZXB0aE9mVmlldzp7ZW5hYmxlOiExLGl0ZXJhdGlvbkNvdW50OjMscGl4ZWxPZmZzZXQ6MSxuZWFyOjE1MCxmYXI6MzAwfX19LHNoYWRvdzp7ZW5hYmxlOiEwLHR5cGU6XCJIQVJEXCIscG9pbnRTaGFkb3dCaWFzOi4wMDIsc2hhZG93U2l6ZToxMDI0LHBvaW50U2hhZG93U2l6ZToxMDI0LHNoYWRvd1NvZnQ6LjAwNSxuZWVkVXBkYXRlOiEwLGF1dG9VcGRhdGU6ITAsdXBkYXRlRnJhbWVSYXRlOjIsY3NtTWFyZ2luOi4xLGNzbVNjYXR0ZXJpbmdFeHA6LjcsY3NtQXJlYVNjYWxlOi40LGRlYnVnOiExfSxnaTp7ZW5hYmxlOiExLG9mZnNldFg6MCxvZmZzZXRZOjAsb2Zmc2V0WjowLHByb2JlU3BhY2U6NjQscHJvYmVYQ291bnQ6NCxwcm9iZVlDb3VudDoyLHByb2JlWkNvdW50OjQscHJvYmVTaXplOjMyLHByb2JlU291cmNlVGV4dHVyZVNpemU6MjA0OCxvY3RSVE1heFNpemU6MjA0OCxvY3RSVFNpZGVTaXplOjE2LG1heERpc3RhbmNlOjY0KjEuNzMsbm9ybWFsQmlhczouMjUsZGVwdGhTaGFycG5lc3M6MSxoeXN0ZXJlc2lzOi45OCxsZXJwSHlzdGVyZXNpczouMDEsaXJyYWRpYW5jZUNoZWJ5c2hldkJpYXM6LjAxLHJheU51bWJlcjoxNDQsaXJyYWRpYW5jZURpc3RhbmNlQmlhczozMixpbmRpcmVjdEludGVuc2l0eToxLGRkZ2lHYW1tYToyLjIsYm91bmNlSW50ZW5zaXR5Oi4wMjUscHJvYmVSb3VnaG5lc3M6MSxyZWFsVGltZUdJOiExLGRlYnVnOiExLGF1dG9SZW5kZXJQcm9iZTohMX0sc2t5Ont0eXBlOlwiSERSU0tZXCIsc2t5Om51bGwsc2t5RXhwb3N1cmU6MSxkZWZhdWx0RmFyOjY1NTM2LGRlZmF1bHROZWFyOjF9LGxpZ2h0OnttYXhMaWdodDo0MDk2fSxtYXRlcmlhbDp7bWF0ZXJpYWxDaGFubmVsRGVidWc6ITEsbWF0ZXJpYWxEZWJ1ZzohMX19KSxvKEEsXCJyZW5kZXJKb2JzXCIpO2xldCBZZz1gXG4jaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuXG5zdHJ1Y3QgVW5pZm9ybURhdGEge1xuICByYWRpdXM6IGYzMiAsXG4gIGJpYXM6IGYzMixcbiAgYW9Qb3dlcjogZjMyICxcbiAgYmx1clNpemU6IGYzMiAsXG59O1xuXG4vLyBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHN0YW5kVW5pZm9ybTogR2xvYmFsVW5pZm9ybTtcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gdW5pZm9ybURhdGE6IFVuaWZvcm1EYXRhO1xuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBjb2xvck1hcCA6IHRleHR1cmVfMmQ8ZjMyPjtcbi8vIEBncm91cCgwKSBAYmluZGluZygyKSB2YXIgc3Nhb01hcFNhbXBsZXIgOiBzYW1wbGVyO1xuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciBzc2FvTWFwIDogdGV4dHVyZV8yZDxmMzI+O1xuQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhciBvdXRUZXggOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTE2ZmxvYXQsIHdyaXRlPjtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCA4ICwgOCApXG5mbiBDc01haW4oIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxue1xuICB2YXIgZnJhZ0Nvb3JkID0gdmVjMjxpMzI+KCBnbG9iYWxJbnZvY2F0aW9uX2lkLnh5ICk7XG5cbiAgdmFyIHRleFNpemUgPSB2ZWMyPGYzMj4odGV4dHVyZURpbWVuc2lvbnMoc3Nhb01hcCkueHkpO1xuICB2YXIgdGV4Q29vcmQgPSB2ZWMyPGYzMj4oZnJhZ0Nvb3JkKSAvIHRleFNpemUgO1xuXG4gIGxldCBibHVyU2l6ZSA9IGkzMih1bmlmb3JtRGF0YS5ibHVyU2l6ZSk7XG5cbiAgdmFyIHJlc3VsdCA9IHZlYzQ8ZjMyPigwLjApIDtcbiAgdmFyIGlpID0gMC4wIDtcbiAgZm9yICh2YXIgaSA9IC0yOyBpIDwgMiA7IGkrPTEpIHtcbiAgICAgZm9yICh2YXIgaiA9IC0yOyBqIDwgMiA7IGorPTEpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHZlYzI8aTMyPiggaSAsIGogKSA7XG4gICAgICAgIHJlc3VsdCArPSB0ZXh0dXJlTG9hZChzc2FvTWFwLCBmcmFnQ29vcmQgKyBvZmZzZXQsIDAgKTtcbiAgICAgICAgLy8gcmVzdWx0ICs9IHRleHR1cmVTYW1wbGVMZXZlbChzc2FvTWFwLHNzYW9NYXBTYW1wbGVyLCB2ZWMyPGYzMj4oIGZyYWdDb29yZCArIG9mZnNldCkgLyB0ZXhTaXplICwgMC4wICk7XG4gICAgICAgIGlpICs9IDEuMCA7XG4gICAgIH1cbiAgfVxuICB2YXIgZlJlc3VsdCA9IHJlc3VsdC5yIC8gaWkgO1xuICB2YXIgY29sb3IgPSB0ZXh0dXJlTG9hZChjb2xvck1hcCwgZnJhZ0Nvb3JkICwgMCApO1xuICB0ZXh0dXJlU3RvcmUob3V0VGV4LCBmcmFnQ29vcmQgLCB2ZWM0KGNvbG9yLnJnYiAqIGZSZXN1bHQsMS4wKSApO1xufVxuYCxLdT1gXG4jaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuXG4gIHN0cnVjdCBCbHVyU2V0dGluZ3tcbiAgICBuZWFyOiBmMzIsXG4gICAgZmFyOiBmMzIsXG4gICAgcGl4ZWxPZmZzZXQ6IGYzMixcbiAgfVxuXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gc3RhbmRVbmlmb3JtOiBHbG9iYWxVbmlmb3JtO1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHVuaWZvcm0+IGJsdXJTZXR0aW5nOiBCbHVyU2V0dGluZztcblxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHBvc2l0aW9uQnVmZmVyVGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyIG5vcm1hbEJ1ZmZlclRleCA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhciBpblRleFNhbXBsZXIgOiBzYW1wbGVyO1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNSkgdmFyIGluVGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNikgdmFyIG91dFRleCA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuXG4gIHZhcjxwcml2YXRlPiBjYW1lcmFQb3NpdGlvbjogdmVjMzxmMzI+O1xuICB2YXI8cHJpdmF0ZT4gdGV4U2l6ZTogdmVjMjx1MzI+O1xuICB2YXI8cHJpdmF0ZT4gZnJhZ0Nvb3JkOiB2ZWMyPGkzMj47XG4gIHZhcjxwcml2YXRlPiB0ZXhlbFNpemU6IHZlYzI8ZjMyPjtcblxuICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoIDggLCA4ICwgMSApXG4gIGZuIENzTWFpbiggQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4gLCBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSW52b2NhdGlvbl9pZCA6IHZlYzM8dTMyPilcbiAge1xuICAgIGZyYWdDb29yZCA9IHZlYzI8aTMyPiggZ2xvYmFsSW52b2NhdGlvbl9pZC54eSApO1xuICAgIHRleFNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyhpblRleCkueHk7XG4gICAgdGV4ZWxTaXplID0gMS4wIC8gdmVjMjxmMzI+KHRleFNpemUgLSAxKTtcbiAgICBpZihmcmFnQ29vcmQueCA+PSBpMzIodGV4U2l6ZS54KSB8fCBmcmFnQ29vcmQueSA+PSBpMzIodGV4U2l6ZS55KSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FtZXJhUG9zaXRpb24gPSB2ZWMzPGYzMj4oc3RhbmRVbmlmb3JtLmNhbWVyYVdvcmxkTWF0cml4WzNdLnh5eik7XG4gICAgbGV0IHdQb3NpdGlvbjp2ZWMzPGYzMj4gPSB0ZXh0dXJlTG9hZChwb3NpdGlvbkJ1ZmZlclRleCwgZnJhZ0Nvb3JkICwgMCkueHl6O1xuICAgIHZhciBkaXN0YW5jZSA9IGxlbmd0aCh3UG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbik7XG4gICAgdmFyIG9jOnZlYzQ8ZjMyPiA9IHRleHR1cmVMb2FkKGluVGV4LCBmcmFnQ29vcmQsIDApO1xuICAgIGlmKGRpc3RhbmNlID4gYmx1clNldHRpbmcubmVhcil7XG4gICAgICAgIGxldCBub3JtYWwgPSB0ZXh0dXJlTG9hZChub3JtYWxCdWZmZXJUZXgsIGZyYWdDb29yZCwgMCk7XG4gICAgICAgIHZhciBwaXhlbFNjYWxlID0gMC41O1xuICAgICAgICBpZihub3JtYWwudyA+IDAuNSl7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IG1pbihkaXN0YW5jZSwgYmx1clNldHRpbmcuZmFyKTtcbiAgICAgICAgICAgIHBpeGVsU2NhbGUgPSAoZGlzdGFuY2UgLSBibHVyU2V0dGluZy5uZWFyKSAvIChibHVyU2V0dGluZy5mYXIgLSBibHVyU2V0dGluZy5uZWFyKTtcbiAgICAgICAgfVxuICAgICAgICBvYyA9IG1peEJsdXJDb2xvcihvYywgZnJhZ0Nvb3JkLCBibHVyU2V0dGluZy5waXhlbE9mZnNldCwgcGl4ZWxTY2FsZSk7XG4gICAgfVxuICAgIHRleHR1cmVTdG9yZShvdXRUZXgsIGZyYWdDb29yZCwgb2MpO1xuICB9XG5cbiAgZm4gbWl4Qmx1ckNvbG9yKG9yZ2luQ29sb3I6dmVjNDxmMzI+LCBjb29yZDp2ZWMyPGkzMj4sIHBpeGVsT2Zmc2V0OmYzMiwgc2NhbGU6ZjMyKSAtPiB2ZWM0PGYzMj4ge1xuXG4gICAgbGV0IHV2ID0gdmVjMjxmMzI+KGNvb3JkKTtcbiAgICB2YXIgdXYwID0gKHV2ICsgc2NhbGUgKiB2ZWMyPGYzMj4oIHBpeGVsT2Zmc2V0LCAgcGl4ZWxPZmZzZXQpKSAqIHRleGVsU2l6ZTtcbiAgICB2YXIgdXYxID0gKHV2ICsgc2NhbGUgKiB2ZWMyPGYzMj4oLXBpeGVsT2Zmc2V0LCAgcGl4ZWxPZmZzZXQpKSAqIHRleGVsU2l6ZTtcbiAgICB2YXIgdXYyID0gKHV2ICsgc2NhbGUgKiB2ZWMyPGYzMj4oLXBpeGVsT2Zmc2V0LCAtcGl4ZWxPZmZzZXQpKSAqIHRleGVsU2l6ZTtcbiAgICB2YXIgdXYzID0gKHV2ICsgc2NhbGUgKiB2ZWMyPGYzMj4oIHBpeGVsT2Zmc2V0LCAtcGl4ZWxPZmZzZXQpKSAqIHRleGVsU2l6ZTtcblxuICAgIHV2MC54ID0gcHJvY2Vzc1VWRWRnZSh1djAueCk7XG4gICAgdXYwLnkgPSBwcm9jZXNzVVZFZGdlKHV2MC55KTtcbiAgICB1djEueCA9IHByb2Nlc3NVVkVkZ2UodXYxLngpO1xuICAgIHV2MS55ID0gcHJvY2Vzc1VWRWRnZSh1djEueSk7XG4gICAgdXYyLnggPSBwcm9jZXNzVVZFZGdlKHV2Mi54KTtcbiAgICB1djIueSA9IHByb2Nlc3NVVkVkZ2UodXYyLnkpO1xuICAgIHV2My54ID0gcHJvY2Vzc1VWRWRnZSh1djMueCk7XG4gICAgdXYzLnkgPSBwcm9jZXNzVVZFZGdlKHV2My55KTtcblxuICAgIHZhciBvYiA9IHZlYzQ8ZjMyPigwLjApO1xuICAgIG9iICs9IHRleHR1cmVTYW1wbGVMZXZlbChpblRleCwgaW5UZXhTYW1wbGVyLCB1djAsIDAuMCk7XG4gICAgb2IgKz0gdGV4dHVyZVNhbXBsZUxldmVsKGluVGV4LCBpblRleFNhbXBsZXIsIHV2MSwgMC4wKTtcbiAgICBvYiArPSB0ZXh0dXJlU2FtcGxlTGV2ZWwoaW5UZXgsIGluVGV4U2FtcGxlciwgdXYyLCAwLjApO1xuICAgIG9iICs9IHRleHR1cmVTYW1wbGVMZXZlbChpblRleCwgaW5UZXhTYW1wbGVyLCB1djMsIDAuMCk7XG4gICAgcmV0dXJuIG1peChvcmdpbkNvbG9yLCBvYiAqIDAuMjUsIHNjYWxlKTtcbiAgfVxuXG4gIGZuIHByb2Nlc3NVVkVkZ2UodjogZjMyKSAtPiBmMzJ7XG4gICAgICB2YXIgdmFsdWUgPSB2O1xuICAgICAgaWYodmFsdWUgPCAwLjApe1xuICAgICAgICB2YWx1ZSA9IC0gdmFsdWU7XG4gICAgICB9ZWxzZSBpZih2YWx1ZSA+IDEuMCl7XG4gICAgICAgIHZhbHVlID0gMi4wIC0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbmAsSnU9YFxuICAgICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG4gICAgXG4gICAgc3RydWN0IEdUQU97XG4gICAgICBtYXhEaXN0YW5jZTogZjMyLFxuICAgICAgbWF4UGl4ZWw6IGYzMixcbiAgICAgIGRhcmtGYWN0b3I6IGYzMixcbiAgICAgIHJheU1hcmNoU2VnbWVudDogZjMyLFxuICAgICAgY2FtZXJhTmVhcjogZjMyLFxuICAgICAgY2FtZXJhRmFyOiBmMzIsXG4gICAgICBtdWx0aUJvdW5jZTogZjMyLFxuICAgICAgYmxlbmRDb2xvcjogZjMyLFxuICAgIH1cblxuICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8dW5pZm9ybT4gZ3Rhb0RhdGE6IEdUQU87XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBkaXJlY3Rpb25zIDogYXJyYXk8dmVjMjxmMzI+PjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IGFvQnVmZmVyIDogYXJyYXk8ZjMyPjtcblxuICAgIEBncm91cCgwKSBAYmluZGluZyg0KSB2YXIgcG9zVGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICAgIEBncm91cCgwKSBAYmluZGluZyg1KSB2YXIgbm9ybWFsVGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICAgIEBncm91cCgwKSBAYmluZGluZyg2KSB2YXIgaW5UZXggOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDcpIHZhciBvdXRUZXggOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTE2ZmxvYXQsIHdyaXRlPjtcbiAgICBcbiAgICB2YXI8cHJpdmF0ZT4gdGV4U2l6ZTogdmVjMjx1MzI+O1xuICAgIHZhcjxwcml2YXRlPiBmcmFnQ29vcmQ6IHZlYzI8aTMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gd1Bvc2l0aW9uOiB2ZWMzPGYzMj47XG4gICAgdmFyPHByaXZhdGU+IHdOb3JtYWw6IHZlYzQ8ZjMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gbWF4UGl4ZWxTY2FsZWQ6IGYzMjtcbiAgICBcbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoIDggLCA4ICwgMSApXG4gICAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICAgIHtcbiAgICAgIGZyYWdDb29yZCA9IHZlYzI8aTMyPiggZ2xvYmFsSW52b2NhdGlvbl9pZC54eSApO1xuICAgICAgdGV4U2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKGluVGV4KS54eTtcbiAgICAgIGlmKGZyYWdDb29yZC54ID49IGkzMih0ZXhTaXplLngpIHx8IGZyYWdDb29yZC55ID49IGkzMih0ZXhTaXplLnkpKXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3Tm9ybWFsID0gdGV4dHVyZUxvYWQobm9ybWFsVGV4LCBmcmFnQ29vcmQsIDApO1xuICAgICAgdmFyIG9jID0gdGV4dHVyZUxvYWQoaW5UZXgsIGZyYWdDb29yZCwgMCk7XG4gICAgICBsZXQgaW5kZXggPSBmcmFnQ29vcmQueCArIGZyYWdDb29yZC55ICogaTMyKHRleFNpemUueCk7XG4gICAgICBsZXQgbGFzdEZhY3RvciA9IGFvQnVmZmVyW2luZGV4XTtcbiAgICAgIHZhciBuZXdGYWN0b3IgPSAwLjA7XG4gICAgICBpZih3Tm9ybWFsLncgPCAwLjUpey8vc2t5XG4gICAgICAgICAgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgICB3UG9zaXRpb24gPSB0ZXh0dXJlTG9hZChwb3NUZXgsIGZyYWdDb29yZCwgMCkueHl6O1xuICAgICAgICAgIGxldCBuZGMgPSBnbG9iYWxVbmlmb3JtLnByb2pNYXQgKiBnbG9iYWxVbmlmb3JtLnZpZXdNYXQgKiB2ZWM0PGYzMj4od1Bvc2l0aW9uLCAxLjApO1xuICAgICAgICAgIGxldCBuZGNaID0gbmRjLnogLyBuZGMudztcbiAgICAgICAgICBtYXhQaXhlbFNjYWxlZCA9IGNhbGNQaXhlbEJ5TkRDKG5kY1opO1xuICAgICAgICAgIG5ld0ZhY3RvciA9IHJheU1hcmNoKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBmYWN0b3I6ZjMyID0gbWl4KGxhc3RGYWN0b3IsIG5ld0ZhY3RvciwgMC42KTtcbiAgICAgIGFvQnVmZmVyW2luZGV4XSA9IGZhY3RvcjtcbiAgICAgIGZhY3RvciA9IGJsdXJGYWN0b3IoZmFjdG9yKTtcbiAgICAgIGZhY3RvciA9IHNhdHVyYXRlKDEuMCAtIGZhY3RvciAqIGd0YW9EYXRhLmRhcmtGYWN0b3IpO1xuICAgICAgdmFyIGd0YW8gPSB2ZWMzPGYzMj4oZmFjdG9yKTtcbiAgICAgIGlmKGd0YW9EYXRhLm11bHRpQm91bmNlID4gMC41KXtcbiAgICAgICAgICBndGFvID0gTXVsdGlCb3VuY2UoZmFjdG9yLCBvYy54eXopO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgb3V0Q29sb3IgPSBndGFvO1xuICAgICAgaWYoZ3Rhb0RhdGEuYmxlbmRDb2xvciA+IDAuNSl7XG4gICAgICAgICAgb3V0Q29sb3IgPSBvYy54eXogKiBndGFvO1xuICAgICAgfVxuICAgICAgdGV4dHVyZVN0b3JlKG91dFRleCwgZnJhZ0Nvb3JkICwgdmVjNDxmMzI+KG91dENvbG9yLCBvYy53KSk7XG4gICAgfVxuICAgIFxuICAgIGZuIE11bHRpQm91bmNlKEFPOmYzMiwgQWxiZWRvOnZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAge1xuICAgICAgICB2YXIgQSA9IDIgKiBBbGJlZG8gLSAwLjMzO1xuICAgICAgICB2YXIgQiA9IC00LjggKiBBbGJlZG8gKyAwLjY0O1xuICAgICAgICB2YXIgQyA9IDIuNzUgKiBBbGJlZG8gKyAwLjY5O1xuICAgICAgICByZXR1cm4gbWF4KHZlYzM8ZjMyPihBTyksICgoQU8gKiBBICsgQikgKiBBTyArIEMpICogQU8pO1xuICAgIH1cbiAgICBcbiAgICBmbiBjYWxjUGl4ZWxCeU5EQyhuZGNaOmYzMikgLT4gZjMye1xuICAgICAgbGV0IG5lYXJBc3BlY3QgPSBndGFvRGF0YS5jYW1lcmFOZWFyIC8gKGd0YW9EYXRhLmNhbWVyYUZhciAtIGd0YW9EYXRhLmNhbWVyYU5lYXIpO1xuICAgICAgbGV0IGFzcGVjdCA9ICgxLjAgKyBuZWFyQXNwZWN0KSAvIChuZGNaICsgbmVhckFzcGVjdCk7XG4gICAgICB2YXIgdmlld1BvcnRNYXggPSBtaW4oZjMyKHRleFNpemUueCksIGYzMih0ZXhTaXplLnkpKTtcbiAgICAgIHZhciBtYXhQaXhlbCA9IG1pbih2aWV3UG9ydE1heCwgZ3Rhb0RhdGEubWF4UGl4ZWwgKiBhc3BlY3QpO1xuICAgICAgbWF4UGl4ZWwgPSBtYXgoMC4xLCBtYXhQaXhlbCk7XG4gICAgICByZXR1cm4gbWF4UGl4ZWw7XG4gICAgfVxuICAgIFxuICAgIGZuIGJsdXJGYWN0b3IoY2VudGVyRmFjdG9yOmYzMikgLT4gZjMye1xuICAgICAgdmFyIGNvb3JkMCA9IGNsYW1wKGZyYWdDb29yZCArIHZlYzI8aTMyPigxLCAwKSAsIHZlYzI8aTMyPigwKSwgdmVjMjxpMzI+KHRleFNpemUgLSAxKSk7XG4gICAgICB2YXIgY29vcmQxID0gY2xhbXAoZnJhZ0Nvb3JkICsgdmVjMjxpMzI+KC0xLCAwKSwgdmVjMjxpMzI+KDApLCB2ZWMyPGkzMj4odGV4U2l6ZSAtIDEpKTtcbiAgICAgIHZhciBjb29yZDIgPSBjbGFtcChmcmFnQ29vcmQgKyB2ZWMyPGkzMj4oMCwgMSkgLCB2ZWMyPGkzMj4oMCksIHZlYzI8aTMyPih0ZXhTaXplIC0gMSkpO1xuICAgICAgdmFyIGNvb3JkMyA9IGNsYW1wKGZyYWdDb29yZCArIHZlYzI8aTMyPigwLCAtMSksIHZlYzI8aTMyPigwKSwgdmVjMjxpMzI+KHRleFNpemUgLSAxKSk7XG4gICAgICB2YXIgaW5kZXgwID0gY29vcmQwLnggKyBjb29yZDAueSAqIGkzMih0ZXhTaXplLngpO1xuICAgICAgdmFyIGluZGV4MSA9IGNvb3JkMS54ICsgY29vcmQxLnkgKiBpMzIodGV4U2l6ZS54KTtcbiAgICAgIHZhciBpbmRleDIgPSBjb29yZDIueCArIGNvb3JkMi55ICogaTMyKHRleFNpemUueCk7XG4gICAgICB2YXIgaW5kZXgzID0gY29vcmQzLnggKyBjb29yZDMueSAqIGkzMih0ZXhTaXplLngpO1xuICAgICAgbGV0IGZhY3RvcjA6ZjMyID0gYW9CdWZmZXJbaW5kZXgwXTtcbiAgICAgIGxldCBmYWN0b3IxOmYzMiA9IGFvQnVmZmVyW2luZGV4MV07XG4gICAgICBsZXQgZmFjdG9yMjpmMzIgPSBhb0J1ZmZlcltpbmRleDJdO1xuICAgICAgbGV0IGZhY3RvcjM6ZjMyID0gYW9CdWZmZXJbaW5kZXgzXTtcbiAgICAgIHZhciBmYWN0b3IgPSAwLjI1ICogKGZhY3RvcjAgKyBmYWN0b3IxICsgZmFjdG9yMiArIGZhY3RvcjMpO1xuICAgICAgZmFjdG9yID0gbWl4KGZhY3RvciwgY2VudGVyRmFjdG9yLCAwLjgpO1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gICAgXG4gICAgZm4gcmF5TWFyY2goKSAtPiBmMzJ7XG4gICAgICBsZXQgb3JpZ2luTm9ybWFsID0gbm9ybWFsaXplKHZlYzM8ZjMyPih3Tm9ybWFsLnh5eikgKiAyLjAgLSAxLjApO1xuICAgICAgbGV0IHN0ZXBQaXhlbCA9IG1heFBpeGVsU2NhbGVkIC8gZ3Rhb0RhdGEucmF5TWFyY2hTZWdtZW50O1xuICAgICAgdmFyIHdlaWdodDpmMzIgPSAwLjA7XG4gICAgICB2YXIgdG90YWxXZWlnaHQ6ZjMyID0gMC4xO1xuICAgICAgZm9yKHZhciBpOmkzMiA9IDA7IGkgPCA4OyBpICs9IDEpe1xuICAgICAgICAgIGxldCBkaXJWZWMyID0gZGlyZWN0aW9uc1tpXTtcbiAgICAgICAgICBmb3IodmFyIGo6ZjMyID0gMS4xOyBqIDwgbWF4UGl4ZWxTY2FsZWQ7IGogKz0gc3RlcFBpeGVsKXtcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZUNvb3JkID0gdmVjMjxpMzI+KGRpclZlYzIgKiBqKSArIGZyYWdDb29yZDtcbiAgICAgICAgICAgICAgaWYoc2FtcGxlQ29vcmQueCA+PSAwICYmIHNhbXBsZUNvb3JkLnkgPj0gMCBcbiAgICAgICAgICAgICAgICAmJiBzYW1wbGVDb29yZC54IDwgaTMyKHRleFNpemUueCkgXG4gICAgICAgICAgICAgICAgJiYgc2FtcGxlQ29vcmQueSA8IGkzMih0ZXhTaXplLnkpIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IDEuMDtcbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlUG9zaXRpb24gPSB0ZXh0dXJlTG9hZChwb3NUZXgsIHNhbXBsZUNvb3JkLCAwKS54eXo7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlVmVjMiA9IHNhbXBsZVBvc2l0aW9uIC0gd1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGxlbmd0aChkaXN0YW5jZVZlYzIpO1xuICAgICAgICAgICAgICAgIGlmKGRpc3RhbmNlIDwgZ3Rhb0RhdGEubWF4RGlzdGFuY2UgJiYgZGlzdGFuY2UgPiAxLjApe1xuICAgICAgICAgICAgICAgICAgbGV0IHNhbXBsZURpciA9IG5vcm1hbGl6ZShkaXN0YW5jZVZlYzIpO1xuICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IHNhdHVyYXRlKGRvdChzYW1wbGVEaXIsIG9yaWdpbk5vcm1hbCkgLSAwLjEpO1xuICAgICAgICAgICAgICAgICAgZmFjdG9yICo9IDEuMCAtIGRpc3RhbmNlIC8gZ3Rhb0RhdGEubWF4RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICB3ZWlnaHQgKz0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICAgIHJldHVybiB3ZWlnaHQ7XG4gICAgfVxuICBgLFp1PWBcblxuICAgICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG4gICAgc3RydWN0IExpZ2h0RGF0YSB7XG4gICAgICBpbmRleDpmMzIsXG4gICAgICBsaWdodFR5cGU6aTMyLFxuICAgICAgcmFkaXVzOmYzMixcbiAgICAgIGxpbmVhcjpmMzIsXG4gICAgICBcbiAgICAgIHBvc2l0aW9uOnZlYzM8ZjMyPixcbiAgICAgIGxpZ2h0TWF0cml4SW5kZXg6ZjMyLFxuXG4gICAgICBkaXJlY3Rpb246dmVjMzxmMzI+LFxuICAgICAgcXVhZHJhdGljOmYzMixcblxuICAgICAgbGlnaHRDb2xvcjp2ZWMzPGYzMj4sXG4gICAgICBpbnRlbnNpdHk6ZjMyLFxuXG4gICAgICBpbm5lckN1dE9mZiA6ZjMyLFxuICAgICAgb3V0ZXJDdXRPZmY6ZjMyLFxuICAgICAgcmFuZ2UgOmYzMixcbiAgICAgIGNhc3RTaGFkb3c6aTMyLFxuXG4gICAgICBsaWdodFRhbmdlbnQ6dmVjMzxmMzI+LFxuICAgICAgaWVzOmYzMixcbiAgICB9O1xuXG4gICAgc3RydWN0IFVuaWZvcm1zIHtcbiAgICAgIG1hdHJpeCA6IGFycmF5PG1hdDR4NDxmMzI+PlxuICAgIH07XG5cbiAgICBzdHJ1Y3QgQ2FjaGVHb2RSYXkge1xuICAgICAgcG9zOnZlYzM8ZjMyPixcbiAgICAgIHZhbHVlOmYzMixcbiAgICB9O1xuXG4gICAgc3RydWN0IEdvZFJheVVuaWZvcm17XG4gICAgICBpbnRlbnNpdHk6IGYzMixcbiAgICAgIHJheU1hcmNoQ291bnQ6IGYzMixcbiAgICAgIHZpZXdQb3J0V2lkdGg6IGYzMixcbiAgICAgIHZpZXdQb3J0SGVpZ2h0OiBmMzIsXG5cbiAgICAgIGJsZW5kQ29sb3I6IGYzMixcbiAgICAgIHNjYXR0ZXJpbmdFeHBvbmVudDogZjMyLFxuICAgIH1cblxuICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8dW5pZm9ybT4gZ29kUmF5VW5pZm9ybTogR29kUmF5VW5pZm9ybTtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHBvc1RleCA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyIG5vcm1hbFRleCA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyIGluVGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICAgIEBncm91cCgwKSBAYmluZGluZyg1KSB2YXIgb3V0VGV4IDogdGV4dHVyZV9zdG9yYWdlXzJkPHJnYmExNmZsb2F0LCB3cml0ZT47XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDYpIHZhciBzaGFkb3dNYXBTYW1wbGVyIDogc2FtcGxlcl9jb21wYXJpc29uO1xuICAgIEBncm91cCgwKSBAYmluZGluZyg3KSB2YXIgc2hhZG93TWFwIDogdGV4dHVyZV9kZXB0aF8yZF9hcnJheTtcblxuICAgIEBncm91cCgxKSBAYmluZGluZygwKVxuICAgIHZhcjxzdG9yYWdlLHJlYWQ+IGxpZ2h0QnVmZmVyOiBhcnJheTxMaWdodERhdGE+O1xuICAgIEBncm91cCgxKSBAYmluZGluZygxKVxuICAgIHZhcjxzdG9yYWdlLCByZWFkPiBtb2RlbHMgOiBVbmlmb3JtcztcblxuICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gaGlzdG9yeUdvZFJheURhdGE6IGFycmF5PENhY2hlR29kUmF5PjtcbiAgICBcbiAgICBzdHJ1Y3QgU2hhZG93U3RydWN0e1xuICAgICAgZGlyZWN0U2hhZG93VmlzaWJpbGl0eTpmMzIsXG4gICAgICBwb2ludFNoYWRvd3M6YXJyYXk8ZjMyLDg+LFxuICAgICB9XG5cbiAgICB2YXI8cHJpdmF0ZT4gdmlld0RpcmVjdGlvbjogdmVjMzxmMzI+IDtcbiAgICB2YXI8cHJpdmF0ZT4gdGV4U2l6ZTogdmVjMjx1MzI+O1xuICAgIHZhcjxwcml2YXRlPiBmcmFnQ29vcmQ6IHZlYzI8aTMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gd1Bvc2l0aW9uOiB2ZWMzPGYzMj47XG4gICAgdmFyPHByaXZhdGU+IHdOb3JtYWw6IHZlYzQ8ZjMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gZGlyZWN0TGlnaHQ6IExpZ2h0RGF0YTtcbiAgICB2YXI8cHJpdmF0ZT4gc2hhZG93U3RydXQ6IFNoYWRvd1N0cnVjdCA7XG5cbiAgICBjb25zdCBjc21Db3VudDppMzIgPSAke2x0LkNhc2NhZGVzfSA7XG4gICAgZm4gZGlyZWN0U2hhZG93TWFwaW5nKFA6dmVjMzxmMzI+LCBOOnZlYzM8ZjMyPiwgc2hhZG93QmlhczogZjMyKSAge1xuICAgICAgbGV0IGVuYWJsZUNTTTpib29sID0gZ2xvYmFsVW5pZm9ybS5lbmFibGVDU00gPiAwLjU7XG4gICAgICB2YXIgbGlnaHQgPSBsaWdodEJ1ZmZlclswXTtcbiAgICAgIHZhciB2aXNpYmlsaXR5ID0gMS4wO1xuICAgICAgdmFyIHNoYWRvd0luZGV4ID0gaTMyKGxpZ2h0LmNhc3RTaGFkb3cpO1xuICAgICAgaWYgKHNoYWRvd0luZGV4ID49IDAgKSB7XG4gICAgICAgIHZhciBzaGFkb3dNYXRyaXg6bWF0NHg0PGYzMj47XG4gICAgICAgIGlmKGVuYWJsZUNTTSAmJiBjc21Db3VudCA+IDEpe1xuICAgICAgICAgIGZvcih2YXIgY3NtOmkzMiA9IDA7IGNzbSA8IGNzbUNvdW50OyBjc20gKyspe1xuICAgICAgICAgICAgdmFyIGNzbVNoYWRvd0JpYXMgPSBnbG9iYWxVbmlmb3JtLmNzbVNoYWRvd0JpYXNbY3NtXTtcbiAgICAgICAgICAgIHNoYWRvd01hdHJpeCA9IGdsb2JhbFVuaWZvcm0uY3NtTWF0cml4W2NzbV07XG4gICAgICAgICAgICBsZXQgY3NtU2hhZG93UmVzdWx0ID0gZGlyZWN0U2hhZG93TWFwaW5nSW5kZXgobGlnaHQsIHNoYWRvd01hdHJpeCwgUCwgTiwgY3NtLCBjc21TaGFkb3dCaWFzKTtcbiAgICAgICAgICAgIGlmKGNzbVNoYWRvd1Jlc3VsdC55IDwgMC41KXtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IGNzbVNoYWRvd1Jlc3VsdC54O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHNoYWRvd01hdHJpeCA9IGdsb2JhbFVuaWZvcm0uc2hhZG93TWF0cml4W3NoYWRvd0luZGV4XTtcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gZGlyZWN0U2hhZG93TWFwaW5nSW5kZXgobGlnaHQsIHNoYWRvd01hdHJpeCwgUCwgTiwgc2hhZG93SW5kZXgsIHNoYWRvd0JpYXMpLng7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNoYWRvd1N0cnV0LmRpcmVjdFNoYWRvd1Zpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xuICAgIH1cbiAgICBcbiAgICBmbiBkaXJlY3RTaGFkb3dNYXBpbmdJbmRleChsaWdodDpMaWdodERhdGEsIG1hdHJpeDptYXQ0eDQ8ZjMyPiwgUDp2ZWMzPGYzMj4sIE46dmVjMzxmMzI+LCBkZXB0aFRleEluZGV4OmkzMiwgc2hhZG93QmlhczpmMzIpIC0+IHZlYzI8ZjMyPlxuICAgIHtcbiAgICAgIHZhciB2aXNpYmlsaXR5ID0gMS4wO1xuICAgICAgdmFyIGlzT3V0U2lkZUFyZWE6ZjMyID0gMS4wO1xuICAgICAgdmFyIHNoYWRvd1Bvc1RtcCA9IG1hdHJpeCAqIHZlYzQ8ZjMyPihQLnh5eiwgMS4wKTtcbiAgICAgIHZhciBzaGFkb3dQb3MgPSBzaGFkb3dQb3NUbXAueHl6IC8gc2hhZG93UG9zVG1wLnc7XG4gICAgICB2YXIgdmFyeWluZ19zaGFkb3dVViA9IHNoYWRvd1Bvcy54eSAqIHZlYzI8ZjMyPigwLjUsIC0wLjUpICsgdmVjMjxmMzI+KDAuNSwgMC41KTtcbiAgICAgIGlmICh2YXJ5aW5nX3NoYWRvd1VWLnggPD0gMS4wXG4gICAgICAgICYmIHZhcnlpbmdfc2hhZG93VVYueCA+PSAwLjBcbiAgICAgICAgJiYgdmFyeWluZ19zaGFkb3dVVi55IDw9IDEuMFxuICAgICAgICAmJiB2YXJ5aW5nX3NoYWRvd1VWLnkgPj0gMC4wXG4gICAgICAgICYmIHNoYWRvd1Bvc1RtcC56IDw9IDEuMFxuICAgICAgICAmJiBzaGFkb3dQb3NUbXAueiA+PSAwLjApXG4gICAgICB7XG4gICAgICAgIGlzT3V0U2lkZUFyZWEgPSAwLjA7XG4gICAgICAgIHZhciB1dk9uZVBpeGVsID0gMS4wIC8gdmVjMjxmMzI+KGdsb2JhbFVuaWZvcm0uc2hhZG93TWFwU2l6ZSk7XG4gICAgICAgIHZhciBOb0wgPSBhYnMoZG90KE4sIG5vcm1hbGl6ZShsaWdodC5kaXJlY3Rpb24pKSk7XG4gICAgICAgIHZhciBiaWFzID0gc2hhZG93QmlhcyAvIG1heChOb0wsIDAuMDAwMDAxKTtcbiAgICAgICAgdmlzaWJpbGl0eSA9IHRleHR1cmVTYW1wbGVDb21wYXJlTGV2ZWwoc2hhZG93TWFwLCBzaGFkb3dNYXBTYW1wbGVyLCB2YXJ5aW5nX3NoYWRvd1VWLCBkZXB0aFRleEluZGV4LCBzaGFkb3dQb3MueiAtIGJpYXMpO1xuICAgICAgICB2aXNpYmlsaXR5ICs9IDAuMDAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZlYzI8ZjMyPih2aXNpYmlsaXR5LCBpc091dFNpZGVBcmVhKTtcbiAgICB9XG5cbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoIDggLCA4ICwgMSApXG4gICAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICAgIHtcbiAgICAgIGZyYWdDb29yZCA9IHZlYzI8aTMyPiggZ2xvYmFsSW52b2NhdGlvbl9pZC54eSApO1xuXG4gICAgICB0ZXhTaXplID0gdGV4dHVyZURpbWVuc2lvbnMoaW5UZXgpLnh5O1xuICAgICAgaWYoZnJhZ0Nvb3JkLnggPj0gaTMyKHRleFNpemUueCkgfHwgZnJhZ0Nvb3JkLnkgPj0gaTMyKHRleFNpemUueSkpe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdOb3JtYWwgPSB0ZXh0dXJlTG9hZChub3JtYWxUZXgsIGZyYWdDb29yZCwgMCk7XG4gICAgICB2YXIgb2MgPSB0ZXh0dXJlTG9hZChpblRleCwgZnJhZ0Nvb3JkLCAwKTtcbiAgICAgIHZhciBvdXRDb2xvciA9IG9jLnh5ejtcbiAgICAgIGRpcmVjdExpZ2h0ID0gbGlnaHRCdWZmZXJbMF0gO1xuICAgICAgaWYoZGlyZWN0TGlnaHQuY2FzdFNoYWRvdyA+PSAwKXtcbiAgICAgICAgbGV0IGluZGV4ID0gZnJhZ0Nvb3JkLnggKyBmcmFnQ29vcmQueSAqIGkzMih0ZXhTaXplLngpO1xuICAgICAgICB2YXIgaGlzdG9yeURhdGEgPSBoaXN0b3J5R29kUmF5RGF0YVtpbmRleF07XG4gICAgICAgIGxldCBsaWdodENvbG9yID0gZGlyZWN0TGlnaHQubGlnaHRDb2xvcjtcbiAgICAgICAgXG4gICAgICAgIHZhciBnb2RSYXlGYWN0b3IgPSAwLjA7XG4gICAgICAgIGlmKHdOb3JtYWwudyA+IDAuNSl7XG4gICAgICAgICAgLy9ub3Qgc2t5XG4gICAgICAgICAgbGV0IGxpZ2h0UG9zID0gbW9kZWxzLm1hdHJpeFt1MzIoZGlyZWN0TGlnaHQubGlnaHRNYXRyaXhJbmRleCldWzNdLnh5ejtcbiAgICAgICAgICB3UG9zaXRpb24gPSB0ZXh0dXJlTG9hZChwb3NUZXgsIGZyYWdDb29yZCwgMCkueHl6O1xuICAgICAgICAgIHZpZXdEaXJlY3Rpb24gPSBub3JtYWxpemUoZ2xvYmFsVW5pZm9ybS5DYW1lcmFQb3MgLSB3UG9zaXRpb24pIDtcbiAgICAgICAgICBnb2RSYXlGYWN0b3IgPSByYXlNYXJjaCgpO1xuICAgICAgICAgIGdvZFJheUZhY3RvciA9IHVwZGF0ZUdvZFJheShoaXN0b3J5RGF0YSwgZ29kUmF5RmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBoaXN0b3J5RGF0YS5wb3MgPSB3UG9zaXRpb247XG4gICAgICAgIGhpc3RvcnlEYXRhLnZhbHVlID0gZ29kUmF5RmFjdG9yO1xuICAgICAgICBoaXN0b3J5R29kUmF5RGF0YVtpbmRleF0gPSBoaXN0b3J5RGF0YTtcblxuICAgICAgICBvdXRDb2xvciA9IG9jLnh5eiArIHZlYzM8ZjMyPihnb2RSYXlGYWN0b3IgKiBnb2RSYXlVbmlmb3JtLmludGVuc2l0eSAqIGxpZ2h0Q29sb3IpO1xuICAgICAgfVxuICAgICAgdGV4dHVyZVN0b3JlKG91dFRleCwgZnJhZ0Nvb3JkICwgdmVjNDxmMzI+KG91dENvbG9yLCBvYy53KSk7XG4gICAgfVxuXG4gICAgZm4gdXBkYXRlR29kUmF5KGhpc3RvcnlEYXRhOkNhY2hlR29kUmF5LCBuZXdGYWN0b3I6ZjMyKSAtPiBmMzIge1xuICAgICAgdmFyIGNoYW5nZUZhY3RvciA9IDAuMjtcbiAgICAgIGlmKGxlbmd0aChoaXN0b3J5RGF0YS5wb3MgLSB3UG9zaXRpb24pID4gMC4wMSl7XG4gICAgICAgIGNoYW5nZUZhY3RvciA9IDAuNDtcbiAgICAgIH1cbiAgICAgIHZhciBmYWN0b3IgPSBtaXgoaGlzdG9yeURhdGEudmFsdWUsIG5ld0ZhY3RvciwgY2hhbmdlRmFjdG9yKTtcbiAgICAgIFxuICAgICAgbGV0IHBpeGVsT2Zmc2V0ID0gMSArIGkzMihnbG9iYWxVbmlmb3JtLmZyYW1lKSAlIDM7XG4gICAgICBsZXQgY29vcmRSYW5nZSA9IHZlYzI8aTMyPih0ZXhTaXplKTtcbiAgICAgIGxldCBjb29yZEluZGV4MCA9IGdldENvb3JkSW5kZXgoZnJhZ0Nvb3JkLnggKyBwaXhlbE9mZnNldCwgZnJhZ0Nvb3JkLnkgLSBwaXhlbE9mZnNldCwgY29vcmRSYW5nZSk7XG4gICAgICBsZXQgY29vcmRJbmRleDEgPSBnZXRDb29yZEluZGV4KGZyYWdDb29yZC54IC0gcGl4ZWxPZmZzZXQsIGZyYWdDb29yZC55IC0gcGl4ZWxPZmZzZXQsIGNvb3JkUmFuZ2UpO1xuICAgICAgbGV0IGNvb3JkSW5kZXgyID0gZ2V0Q29vcmRJbmRleChmcmFnQ29vcmQueCwgZnJhZ0Nvb3JkLnkgKyBwaXhlbE9mZnNldCAqIDIsIGNvb3JkUmFuZ2UpO1xuXG4gICAgICBsZXQgb2xkT0MwID0gaGlzdG9yeUdvZFJheURhdGFbY29vcmRJbmRleDBdLnZhbHVlO1xuICAgICAgbGV0IG9sZE9DMSA9IGhpc3RvcnlHb2RSYXlEYXRhW2Nvb3JkSW5kZXgxXS52YWx1ZTtcbiAgICAgIGxldCBvbGRPQzIgPSBoaXN0b3J5R29kUmF5RGF0YVtjb29yZEluZGV4Ml0udmFsdWU7XG5cbiAgICAgIGxldCBvcFJvdW5kID0gKG9sZE9DMCArIG9sZE9DMSArIG9sZE9DMikgKiAwLjMzMzMzMzM7XG4gICAgICBmYWN0b3IgPSBtaXgob3BSb3VuZCwgZmFjdG9yLCAwLjUpO1xuXG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cblxuICAgIGZuIGdldENvb3JkSW5kZXgoeDA6aTMyLCB5MDppMzIsIHNpemU6dmVjMjxpMzI+KSAtPiBpMzJ7XG4gICAgICBsZXQgeCA9IGNsYW1wKHgwLCAwLCBzaXplLnggLSAxKTtcbiAgICAgIGxldCB5ID0gY2xhbXAoeTAsIDAsIHNpemUueSAtIDEpO1xuICAgICAgcmV0dXJuIHkgKiBzaXplLnggKyB4O1xuICAgIH1cbiAgICBcbiAgICBcbiAgICBmbiByYXlNYXJjaCgpIC0+IGYzMntcbiAgICAgIHZhciBnb2RSYXlGYWN0b3IgPSAwLjA7XG4gICAgICBsZXQgTCA9IG5vcm1hbGl6ZShkaXJlY3RMaWdodC5kaXJlY3Rpb24pO1xuICAgICAgbGV0IHJheU1hcmNoQ291bnQgPSBnb2RSYXlVbmlmb3JtLnJheU1hcmNoQ291bnQ7XG4gICAgICBpZihnb2RSYXlVbmlmb3JtLmJsZW5kQ29sb3IgPiAwLjUpe1xuICAgICAgICBsZXQgZXllUG9zaXRpb24gPSBnbG9iYWxVbmlmb3JtLkNhbWVyYVBvcztcbiAgICAgICAgdmFyIHNhbXBsZVBvc2l0aW9uID0gZXllUG9zaXRpb247XG4gICAgICAgIHZhciBsYXN0U2FtcGxlUG9zaXRpb24gPSBleWVQb3NpdGlvbjtcbiAgICAgICAgXG4gICAgICAgIHZhciBmcmFtZU9mZnNldCA9IGYzMihpMzIoZ2xvYmFsVW5pZm9ybS5mcmFtZSkgJSA0KTtcbiAgICAgICAgZnJhbWVPZmZzZXQgKj0gMC4yNTtcbiAgICAgICAgdmFyIE4gPSBub3JtYWxpemUod05vcm1hbC54eXopO1xuICAgICAgICBmb3IodmFyIGk6ZjMyID0gMS4wOyBpIDwgcmF5TWFyY2hDb3VudDsgaSArPSAxLjApe1xuICAgICAgICAgIHZhciB0ID0gKGkgKyBmcmFtZU9mZnNldCkgLyByYXlNYXJjaENvdW50O1xuICAgICAgICAgIGxhc3RTYW1wbGVQb3NpdGlvbiA9IHNhbXBsZVBvc2l0aW9uO1xuICAgICAgICAgIHNhbXBsZVBvc2l0aW9uID0gbWl4KGV5ZVBvc2l0aW9uLCB3UG9zaXRpb24sIHQgKiB0KTtcblxuICAgICAgICAgIC8vIHZhciBzaGFkb3dWaXNpYmlsaXR5ID0gZGlyZWN0aW9uU2hhZG93TWFwcGluZyhzYW1wbGVQb3NpdGlvbiwgZ2xvYmFsVW5pZm9ybS5zaGFkb3dCaWFzKTtcbiAgICAgICAgICBkaXJlY3RTaGFkb3dNYXBpbmcoc2FtcGxlUG9zaXRpb24ueHl6LCBOLCBnbG9iYWxVbmlmb3JtLnNoYWRvd0JpYXMpO1xuICAgICAgICAgIHZhciBzaGFkb3dWaXNpYmlsaXR5ID0gc2hhZG93U3RydXQuZGlyZWN0U2hhZG93VmlzaWJpbGl0eTtcbiAgICAgICAgICBpZihzaGFkb3dWaXNpYmlsaXR5ID4gMC41KXtcbiAgICAgICAgICAgIHZhciBzdGVwRmFjdG9yID0gY2FsY0dvZFJheVZhbHVlKHNhbXBsZVBvc2l0aW9uLCBMLCB2aWV3RGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHN0ZXBGYWN0b3IgKj0gbGVuZ3RoKGxhc3RTYW1wbGVQb3NpdGlvbiAtIHNhbXBsZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIGdvZFJheUZhY3RvciArPSBzdGVwRmFjdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnb2RSYXlGYWN0b3IgLz0gbGVuZ3RoKHdQb3NpdGlvbiAtIGV5ZVBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnb2RSYXlGYWN0b3I7XG4gICAgfVxuXG4gICAgZm4gY2FsY0dvZFJheVZhbHVlKHBvczp2ZWMzPGYzMj4sIEw6dmVjMzxmMzI+LCBWOnZlYzM8ZjMyPikgLT4gZjMye1xuICAgICAgdmFyIGhhbGZMb1YgPSBub3JtYWxpemUoTCArIFYpO1xuICAgICAgdmFyIExvViA9IHNhdHVyYXRlKGRvdChWLGhhbGZMb1YpKTtcbiAgICAgIExvViA9IHBvdyhMb1YsIGdvZFJheVVuaWZvcm0uc2NhdHRlcmluZ0V4cG9uZW50KTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGxlbmd0aChwb3MgLSBnbG9iYWxVbmlmb3JtLkNhbWVyYVBvcykgLyAoZ2xvYmFsVW5pZm9ybS5mYXIpO1xuICAgICAgZGlzdGFuY2UgPSAxLjAgLSBzYXR1cmF0ZShkaXN0YW5jZSk7XG4gICAgICBkaXN0YW5jZSAqPSBkaXN0YW5jZTtcbiAgICAgIHJldHVybiBMb1YgKiBkaXN0YW5jZTtcbiAgICB9XG4gIGAsJHU9YFxuICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXIgdGV4dHVyZVIgOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB0ZXh0dXJlRyA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIHRleHR1cmVCIDogdGV4dHVyZV8yZDxmMzI+O1xuICAgIEBncm91cCgwKSBAYmluZGluZygzKSB2YXIgdGV4dHVyZUEgOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhciBvdXRUZXggOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTh1bm9ybSwgd3JpdGU+O1xuXG4gICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDgsIDgsIDEpXG4gICAgZm4gbWFpbihAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSW52b2NhdGlvbklEIDogdmVjMzx1MzI+KSB7XG4gICAgICAgIGxldCBzaXplID0gdGV4dHVyZURpbWVuc2lvbnMob3V0VGV4KTtcbiAgICAgICAgbGV0IGZyYWdDb29yZCA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPihHbG9iYWxJbnZvY2F0aW9uSUQueHkpOyBcbiAgICAgICAgdmFyIHV2OnZlYzI8ZjMyPjtcbiAgICAgICAgdXYueCA9IGYzMihmcmFnQ29vcmQueCkvZjMyKHNpemUueCk7XG4gICAgICAgIHV2LnkgPSBmMzIoZnJhZ0Nvb3JkLnkpL2YzMihzaXplLnkpO1xuICAgICAgICB2YXIgb2M6dmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKGF0bGFzVGV4dHVyZSwgYXRsYXNUZXh0dXJlU2FtcGxlciwgdGFyZ2V0VVYsIDAuMCk7XG5cbiAgICAgICAgbGV0IHNpemVSID0gdGV4dHVyZURpbWVuc2lvbnModGV4dHVyZVIpO1xuICAgICAgICBsZXQgc2l6ZUcgPSB0ZXh0dXJlRGltZW5zaW9ucyh0ZXh0dXJlRyk7XG4gICAgICAgIGxldCBzaXplQiA9IHRleHR1cmVEaW1lbnNpb25zKHRleHR1cmVCKTtcbiAgICAgICAgbGV0IHNpemVBID0gdGV4dHVyZURpbWVuc2lvbnModGV4dHVyZUEpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHRyID0gdGV4dHVyZUxvYWQodGV4dHVyZVIsIHZlYzI8aTMyPih1diAqIHNpemVSKSAsIDAgKSA7XG4gICAgICAgIHZhciB0ZyA9IHRleHR1cmVMb2FkKHRleHR1cmVHLCB2ZWMyPGkzMj4odXYgKiBzaXplRykgLCAwICkgO1xuICAgICAgICB2YXIgdGIgPSB0ZXh0dXJlTG9hZCh0ZXh0dXJlQiwgdmVjMjxpMzI+KHV2ICogc2l6ZUIpICwgMCApIDtcbiAgICAgICAgdmFyIHRhID0gdGV4dHVyZUxvYWQodGV4dHVyZUEsIHZlYzI8aTMyPih1diAqIHNpemVBKSAsIDAgKSA7XG5cbiAgICAgICAgbGV0IGNvbG9yID0gdmVjNDxmMzI+KHRyLHRnLHRiLHRhKTtcbiAgICAgICAgdGV4dHVyZVN0b3JlKG91dFRleCwgZnJhZ0Nvb3JkICwgdmVjNChjb2xvcikpO1xuICAgIH1cblxuYCxlYz1gXG4gICBzdHJ1Y3QgT3V0bGluZVNldHRpbmdEYXRhe1xuICAgICAgc3RyZW5ndGg6IGYzMixcbiAgICAgIHVzZUFkZE1vZGU6IGYzMixcbiAgICAgIG91dGxpbmVQaXhlbDogZjMyLFxuICAgICAgZmFkZU91dGxpbmVQaXhlbDogZjMyLFxuICAgICAgbG93VGV4V2lkdGg6IGYzMixcbiAgICAgIGxvd1RleEhlaWdodDogZjMyLFxuICAgICAgc2xvdDA6IGYzMixcbiAgICAgIHNsb3QxOiBmMzIsXG4gICB9XG5cbiAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gb3V0bGluZVNldHRpbmc6IE91dGxpbmVTZXR0aW5nRGF0YTtcbiAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgaW5UZXggOiB0ZXh0dXJlXzJkPGYzMj47XG4gICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIGxvd1RleFNhbXBsZXIgOiBzYW1wbGVyO1xuICAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhciBsb3dUZXggOiB0ZXh0dXJlXzJkPGYzMj47XG4gICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyIG91dGxpbmVUZXggOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTE2ZmxvYXQsIHdyaXRlPjtcbiAgIFxuICAgdmFyPHByaXZhdGU+IHRleFNpemU6IHZlYzI8dTMyPjtcbiAgIHZhcjxwcml2YXRlPiBmcmFnQ29vcmQ6IHZlYzI8aTMyPjtcblxuICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCA4ICwgOCAsIDEgKVxuICAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICAge1xuICAgICAgZnJhZ0Nvb3JkID0gdmVjMjxpMzI+KCBnbG9iYWxJbnZvY2F0aW9uX2lkLnh5ICk7XG4gICAgICB0ZXhTaXplID0gdGV4dHVyZURpbWVuc2lvbnMob3V0bGluZVRleCkueHk7XG4gICAgICBpZihmcmFnQ29vcmQueCA+PSBpMzIodGV4U2l6ZS54KSB8fCBmcmFnQ29vcmQueSA+PSBpMzIodGV4U2l6ZS55KSl7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1djAxID0gdmVjMjxmMzI+KGZyYWdDb29yZCkgLyAodmVjMjxmMzI+KHRleFNpemUpIC0gMS4wKTtcbiAgICAgIHZhciBvZmZzZXQgPSB2ZWMyPGYzMj4odGV4U2l6ZSkgLyB2ZWMyPGYzMj4ob3V0bGluZVNldHRpbmcubG93VGV4V2lkdGgsIG91dGxpbmVTZXR0aW5nLmxvd1RleEhlaWdodCk7XG4gICAgICBvZmZzZXQgPSAwLjUgKiBvZmZzZXQgLyAodmVjMjxmMzI+KHRleFNpemUpIC0gMS4wKTtcbiAgICAgIHV2MDEgKz0gb2Zmc2V0O1xuICAgICAgdmFyIG91dExpbmVDb2xvciA9IHRleHR1cmVTYW1wbGVMZXZlbChsb3dUZXgsIGxvd1RleFNhbXBsZXIsIHV2MDEsIDAuMCk7XG5cbiAgICAgIG91dExpbmVDb2xvci54ICo9IG91dGxpbmVTZXR0aW5nLnN0cmVuZ3RoO1xuICAgICAgb3V0TGluZUNvbG9yLnkgKj0gb3V0bGluZVNldHRpbmcuc3RyZW5ndGg7XG4gICAgICBvdXRMaW5lQ29sb3IueiAqPSBvdXRsaW5lU2V0dGluZy5zdHJlbmd0aDtcblxuICAgICAgdmFyIGluQ29sb3IgPSB0ZXh0dXJlTG9hZChpblRleCwgZnJhZ0Nvb3JkLCAwKTtcbiAgICAgIHZhciBibGVuZENvbG9yOnZlYzM8ZjMyPiA9IHZlYzM8ZjMyPigwLjApO1xuICAgICAgaWYob3V0bGluZVNldHRpbmcudXNlQWRkTW9kZSA+IDAuNSl7XG4gICAgICAgICBibGVuZENvbG9yID0gaW5Db2xvci54eXogKyBvdXRMaW5lQ29sb3IueHl6ICogb3V0TGluZUNvbG9yLnc7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgIGJsZW5kQ29sb3IgPSBtaXgoaW5Db2xvci54eXosIG91dExpbmVDb2xvci54eXosIG91dExpbmVDb2xvci53KTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmVTdG9yZShvdXRsaW5lVGV4LCBmcmFnQ29vcmQsIHZlYzQ8ZjMyPihibGVuZENvbG9yLCBpbkNvbG9yLncpKTtcbiAgIH1cblxuYCx0Yz1gXG4gIHN0cnVjdCBPdXRsaW5lU2V0dGluZ0RhdGF7XG4gICAgc3RyZW5ndGg6IGYzMixcbiAgICB1c2VBZGRNb2RlOiBmMzIsXG4gICAgb3V0bGluZVBpeGVsOiBmMzIsXG4gICAgZmFkZU91dGxpbmVQaXhlbDogZjMyLFxuICAgIGxvd1RleFdpZHRoOiBmMzIsXG4gICAgbG93VGV4SGVpZ2h0OiBmMzIsXG4gICAgc2xvdDA6IGYzMixcbiAgICBzbG90MTogZjMyLFxuICB9XG5cbiAgc3RydWN0IE91dGxpbmVTbG90RGF0YXtcbiAgICBjb2xvcjogdmVjMzxmMzI+LFxuICAgIGNvdW50OiBmMzIsXG4gIH1cblxuICBzdHJ1Y3QgT3V0bGluZVdlaWdodERhdGF7XG4gICAgc2xvdEluZGV4OmYzMixcbiAgICBvdXRlclNsb3RJbmRleDpmMzIsXG4gICAgZW50aXR5SW5kZXg6ZjMyLFxuICAgIHdlaWdodDpmMzJcbiAgfVxuXG4gIHN0cnVjdCBPdXRsaW5lRW50aXRpZXN7XG4gICAgbGlzdDogYXJyYXk8ZjMyLCAxNnU+LFxuICB9XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBvdXRsaW5lU2V0dGluZzogT3V0bGluZVNldHRpbmdEYXRhO1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHNsb3RzQnVmZmVyIDogYXJyYXk8T3V0bGluZVNsb3REYXRhPjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiB3ZWlnaHRCdWZmZXIgOiBhcnJheTxPdXRsaW5lV2VpZ2h0RGF0YT47XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gZW50aXRpZXNCdWZmZXIgOiBhcnJheTxPdXRsaW5lRW50aXRpZXM+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyIGluZGV4VGV4dHVyZSA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICB2YXI8cHJpdmF0ZT4gdGV4U2l6ZTogdmVjMjx1MzI+O1xuICB2YXI8cHJpdmF0ZT4gbG93U2l6ZTogdmVjMjxpMzI+O1xuICB2YXI8cHJpdmF0ZT4gZnJhZ0Nvb3JkOiB2ZWMyPGkzMj47XG4gIHZhcjxwcml2YXRlPiBmcmFnQ29vcmRMb3c6IHZlYzI8aTMyPjtcbiAgdmFyPHByaXZhdGU+IGNvb3JkSW5kZXg6IGkzMjtcblxuICB2YXI8cHJpdmF0ZT4gZnJhZ091dGxpbmU6IE91dGxpbmVXZWlnaHREYXRhO1xuXG4gIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSggOCAsIDggLCAxIClcbiAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICB7XG4gICAgZnJhZ0Nvb3JkTG93ID0gdmVjMjxpMzI+KCBnbG9iYWxJbnZvY2F0aW9uX2lkLnh5ICk7XG4gICAgdGV4U2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKGluZGV4VGV4dHVyZSkueHk7XG4gICAgbG93U2l6ZSA9IHZlYzI8aTMyPihpMzIob3V0bGluZVNldHRpbmcubG93VGV4V2lkdGgpLCBpMzIob3V0bGluZVNldHRpbmcubG93VGV4SGVpZ2h0KSk7XG4gICAgbGV0IHNjYWxlVmFsdWUgPSBmMzIodGV4U2l6ZS54KSAvIGYzMihsb3dTaXplLngpO1xuICAgIGZyYWdDb29yZC54ID0gaTMyKGYzMihmcmFnQ29vcmRMb3cueCkgKiBzY2FsZVZhbHVlKTtcbiAgICBmcmFnQ29vcmQueSA9IGkzMihmMzIoZnJhZ0Nvb3JkTG93LnkpICogc2NhbGVWYWx1ZSk7XG5cbiAgICBpZihmcmFnQ29vcmQueCA+PSBpMzIodGV4U2l6ZS54KSB8fCBmcmFnQ29vcmQueSA+PSBpMzIodGV4U2l6ZS55KSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYoZnJhZ0Nvb3JkTG93LnggPj0gbG93U2l6ZS54IHx8IGZyYWdDb29yZExvdy55ID49IGxvd1NpemUueSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29vcmRJbmRleCA9IGZyYWdDb29yZExvdy54ICsgZnJhZ0Nvb3JkTG93LnkgKiBsb3dTaXplLng7XG4gICAgZnJhZ091dGxpbmUgPSB3ZWlnaHRCdWZmZXJbY29vcmRJbmRleF07XG4gICAgdmFyIHdQb3MgPSB0ZXh0dXJlTG9hZChpbmRleFRleHR1cmUsIGZyYWdDb29yZCwgMCApIDtcbiAgICBcbiAgICBmcmFnT3V0bGluZS5lbnRpdHlJbmRleCA9IHJvdW5kKHdQb3Mudyk7XG4gICAgZnJhZ091dGxpbmUuc2xvdEluZGV4ID0gLTEuMDtcbiAgICBmcmFnT3V0bGluZS5vdXRlclNsb3RJbmRleCA9IC0xLjA7XG4gICAgZnJhZ091dGxpbmUud2VpZ2h0ID0gMC4wO1xuICAgIFxuICAgIGlmKGZyYWdPdXRsaW5lLmVudGl0eUluZGV4ID49IDAuMCl7XG4gICAgICBmcmFnT3V0bGluZS5zbG90SW5kZXggPSBmMzIobWF0Y2hPdXRsaW5lU2xvdCgpKTtcbiAgICB9XG4gICAgd2VpZ2h0QnVmZmVyW2Nvb3JkSW5kZXhdID0gZnJhZ091dGxpbmU7XG4gIH1cblxuICBmbiBtYXRjaE91dGxpbmVTbG90KCkgLT4gaTMyXG4gIHtcbiAgICBmb3IodmFyIGk6aTMyID0gMDsgaSA8IDg7IGkgKyspe1xuICAgICAgICB2YXIgc2xvdERhdGE6T3V0bGluZVNsb3REYXRhID0gc2xvdHNCdWZmZXJbaV07XG4gICAgICAgIHZhciBlbnRpdGllczphcnJheTxmMzIsIDE2dT4gPSBlbnRpdGllc0J1ZmZlcltpXS5saXN0O1xuICAgICAgICBsZXQgY291bnQ6aTMyID0gaTMyKHNsb3REYXRhLmNvdW50KTtcbiAgICAgICAgZm9yKHZhciBqOmkzMiA9IDA7IGogPCBjb3VudDsgaiArKyl7XG4gICAgICAgICAgICB2YXIgb3V0bGluZUluZGV4ID0gZW50aXRpZXNbal07XG4gICAgICAgICAgICBpZihhYnMoZnJhZ091dGxpbmUuZW50aXR5SW5kZXggLSBvdXRsaW5lSW5kZXgpIDwgMC4xKXsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5gLGljPWBcbiAgICBzdHJ1Y3QgT3V0bGluZVNldHRpbmdEYXRhe1xuICAgICAgICBzdHJlbmd0aDogZjMyLFxuICAgICAgICB1c2VBZGRNb2RlOiBmMzIsXG4gICAgICAgIG91dGxpbmVQaXhlbDogZjMyLFxuICAgICAgICBmYWRlT3V0bGluZVBpeGVsOiBmMzIsXG4gICAgICAgIGxvd1RleFdpZHRoOiBmMzIsXG4gICAgICAgIGxvd1RleEhlaWdodDogZjMyLFxuICAgICAgICBzbG90MDogZjMyLFxuICAgICAgICBzbG90MTogZjMyLFxuICAgIH1cbiAgICBcbiAgICBzdHJ1Y3QgT3V0bGluZVNsb3REYXRhe1xuICAgICAgICBjb2xvcjogdmVjMzxmMzI+LFxuICAgICAgICBjb3VudDogZjMyLFxuICAgIH1cbiAgICBcbiAgICBzdHJ1Y3QgT3V0bGluZVdlaWdodERhdGF7XG4gICAgICAgIHNsb3RJbmRleDpmMzIsXG4gICAgICAgIG91dGVyU2xvdEluZGV4OmYzMixcbiAgICAgICAgZW50aXR5SW5kZXg6ZjMyLFxuICAgICAgICB3ZWlnaHQ6ZjMyXG4gICAgfVxuXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBvdXRsaW5lU2V0dGluZzogT3V0bGluZVNldHRpbmdEYXRhO1xuICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gc2xvdHNCdWZmZXIgOiBhcnJheTxPdXRsaW5lU2xvdERhdGE+O1xuICAgIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gd2VpZ2h0QnVmZmVyIDogYXJyYXk8T3V0bGluZVdlaWdodERhdGE+O1xuICAgIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb2xkT3V0bGluZUNvbG9yIDogYXJyYXk8dmVjNDxmMzI+PjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyIGxvd1RleCA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuICAgIFxuICAgIHZhcjxwcml2YXRlPiB0ZXhTaXplOiB2ZWMyPHUzMj47XG4gICAgdmFyPHByaXZhdGU+IGZyYWdDb29yZDogdmVjMjxpMzI+O1xuICAgIHZhcjxwcml2YXRlPiBjb29yZEluZGV4OiBpMzI7XG4gICAgdmFyPHByaXZhdGU+IGZyYWdPdXRsaW5lOiBPdXRsaW5lV2VpZ2h0RGF0YTtcbiAgICBcbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoIDggLCA4ICwgMSApXG4gICAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICAgIHtcbiAgICAgICAgZnJhZ0Nvb3JkID0gdmVjMjxpMzI+KCBnbG9iYWxJbnZvY2F0aW9uX2lkLnh5ICk7XG4gICAgICAgIHRleFNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyhsb3dUZXgpLnh5O1xuICAgICAgICBpZihmcmFnQ29vcmQueCA+PSBpMzIodGV4U2l6ZS54KSB8fCBmcmFnQ29vcmQueSA+PSBpMzIodGV4U2l6ZS55KSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvb3JkSW5kZXggPSBmcmFnQ29vcmQueCArIGZyYWdDb29yZC55ICogaTMyKHRleFNpemUueCk7XG4gICAgICAgIGZyYWdPdXRsaW5lID0gd2VpZ2h0QnVmZmVyW2Nvb3JkSW5kZXhdO1xuICAgICAgICBcbiAgICAgICAgdmFyIG5ld09DID0gdmVjNDxmMzI+KDAuMCk7XG4gICAgICAgIFxuICAgICAgICBjYWxjT3V0bGluZSgpO1xuICAgICAgICBsZXQgb3V0ZXJTbG90SW5kZXg6aTMyID0gaTMyKHJvdW5kKGZyYWdPdXRsaW5lLm91dGVyU2xvdEluZGV4KSk7XG4gICAgICAgIGlmKG91dGVyU2xvdEluZGV4ID49IDApe1xuICAgICAgICAgICAgbGV0IG91dExpbmVDb2xvciA9IHNsb3RzQnVmZmVyW291dGVyU2xvdEluZGV4XS5jb2xvcjtcbiAgICAgICAgICAgIG5ld09DID0gdmVjNDxmMzI+KG91dExpbmVDb2xvciwgZnJhZ091dGxpbmUud2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IGNvb3JkSW5kZXgwID0gZnJhZ0Nvb3JkLnggKyAxICsgKGZyYWdDb29yZC55ICsgMSkgKiBpMzIodGV4U2l6ZS54KTtcbiAgICAgICAgbGV0IGNvb3JkSW5kZXgxID0gZnJhZ0Nvb3JkLnggLSAxICsgKGZyYWdDb29yZC55ICsgMSkgKiBpMzIodGV4U2l6ZS54KTtcbiAgICAgICAgbGV0IGNvb3JkSW5kZXgyID0gZnJhZ0Nvb3JkLnggKyAoZnJhZ0Nvb3JkLnkgLSAxKSAqIGkzMih0ZXhTaXplLngpO1xuXG4gICAgICAgIGxldCBvbGRPQyA9IG9sZE91dGxpbmVDb2xvcltjb29yZEluZGV4XTtcbiAgICAgICAgbGV0IG9sZE9DMCA9IG9sZE91dGxpbmVDb2xvcltjb29yZEluZGV4MF07XG4gICAgICAgIGxldCBvbGRPQzEgPSBvbGRPdXRsaW5lQ29sb3JbY29vcmRJbmRleDFdO1xuICAgICAgICBsZXQgb2xkT0MyID0gb2xkT3V0bGluZUNvbG9yW2Nvb3JkSW5kZXgyXTtcbiAgICAgICAgXG4gICAgICAgIG5ld09DID0gbWl4KChvbGRPQyArIG9sZE9DMCArIG9sZE9DMSArIG9sZE9DMikgKiAwLjI1LCBuZXdPQywgMC41KTtcbiAgICAgICAgb2xkT3V0bGluZUNvbG9yW2Nvb3JkSW5kZXhdID0gbmV3T0M7XG4gICAgICAgIHRleHR1cmVTdG9yZShsb3dUZXgsIGZyYWdDb29yZCwgbmV3T0MpO1xuICAgIH1cbiAgICBcbiAgICBmbiBjYWxjT3V0bGluZSgpXG4gICAge1xuICAgICAgICBsZXQgb3V0bGluZVBpeGVsID0gb3V0bGluZVNldHRpbmcub3V0bGluZVBpeGVsO1xuICAgICAgICBsZXQgcGl4ZWxSYWRpdXMgPSBvdXRsaW5lUGl4ZWwgKyBvdXRsaW5lU2V0dGluZy5mYWRlT3V0bGluZVBpeGVsO1xuICAgICAgICBsZXQgbWluWCA9IG1heCgwLjAsIGYzMihmcmFnQ29vcmQueCkgLSBwaXhlbFJhZGl1cyk7XG4gICAgICAgIGxldCBtYXhYID0gbWluKGYzMih0ZXhTaXplLngpLCBmMzIoZnJhZ0Nvb3JkLngpICsgcGl4ZWxSYWRpdXMpO1xuICAgICAgICBsZXQgbWluWSA9IG1heCgwLjAsIGYzMihmcmFnQ29vcmQueSkgLSBwaXhlbFJhZGl1cyk7XG4gICAgICAgIGxldCBtYXhZID0gbWluKGYzMih0ZXhTaXplLnkpLCBmMzIoZnJhZ0Nvb3JkLnkpICsgcGl4ZWxSYWRpdXMpO1xuICAgICAgICB2YXIgY29vcmRUZW1wX2YzMiA9IHZlYzI8ZjMyPigwLjApO1xuICAgICAgICB2YXIgY29vcmRDdXJyZW50X2YzMiA9IHZlYzI8ZjMyPihmcmFnQ29vcmQpO1xuICAgICAgICB2YXIgdGVtcENvb3JkSW5kZXggPSAwO1xuICAgICAgICB2YXIgdGVtcFdlaWdodERhdGE6IE91dGxpbmVXZWlnaHREYXRhO1xuICAgICAgICBmb3IodmFyIHg6ZjMyID0gbWluWDsgeCA8IG1heFg7IHggKz0gMS4wKXtcbiAgICAgICAgICAgIGZvcih2YXIgeTpmMzIgPSBtaW5ZOyB5IDwgbWF4WTsgeSArPSAxLjApe1xuICAgICAgICAgICAgICAgIGNvb3JkVGVtcF9mMzIueCA9IHg7XG4gICAgICAgICAgICAgICAgY29vcmRUZW1wX2YzMi55ID0geTtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2VUb091dGVyID0gbGVuZ3RoKGNvb3JkVGVtcF9mMzIgLSBjb29yZEN1cnJlbnRfZjMyKTtcbiAgICAgICAgICAgICAgICBpZihkaXN0YW5jZVRvT3V0ZXIgPCBwaXhlbFJhZGl1cyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZF9pMzIgPSB2ZWMyPGkzMj4oY29vcmRUZW1wX2YzMik7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDb29yZEluZGV4ID0gY29vcmRfaTMyLnggKyBjb29yZF9pMzIueSAqIGkzMih0ZXhTaXplLngpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wV2VpZ2h0RGF0YSA9IHdlaWdodEJ1ZmZlclt0ZW1wQ29vcmRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRsaW5lR2FwID0gYWJzKHRlbXBXZWlnaHREYXRhLnNsb3RJbmRleCAtIGZyYWdPdXRsaW5lLnNsb3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG91dGxpbmVHYXAgPiAwLjEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGVtcFdlaWdodERhdGEuc2xvdEluZGV4ID4gZnJhZ091dGxpbmUuc2xvdEluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhYnModGVtcFdlaWdodERhdGEuc2xvdEluZGV4IC0gZnJhZ091dGxpbmUub3V0ZXJTbG90SW5kZXgpIDwgMC4xKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ091dGxpbmUud2VpZ2h0ID0gbWF4KGZyYWdPdXRsaW5lLndlaWdodCwgY2FsY1dlaWdodChwaXhlbFJhZGl1cywgZGlzdGFuY2VUb091dGVyLCBvdXRsaW5lUGl4ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ091dGxpbmUub3V0ZXJTbG90SW5kZXggPSB0ZW1wV2VpZ2h0RGF0YS5zbG90SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodEJ1ZmZlclt0ZW1wQ29vcmRJbmRleF0gPSB0ZW1wV2VpZ2h0RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZih0ZW1wV2VpZ2h0RGF0YS5zbG90SW5kZXggPiBmcmFnT3V0bGluZS5vdXRlclNsb3RJbmRleCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdPdXRsaW5lLndlaWdodCA9IGNhbGNXZWlnaHQocGl4ZWxSYWRpdXMsIGRpc3RhbmNlVG9PdXRlciwgb3V0bGluZVBpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ091dGxpbmUub3V0ZXJTbG90SW5kZXggPSB0ZW1wV2VpZ2h0RGF0YS5zbG90SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodEJ1ZmZlclt0ZW1wQ29vcmRJbmRleF0gPSB0ZW1wV2VpZ2h0RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm4gY2FsY1dlaWdodCh0b3RhbFJhZGl1czpmMzIsIGRpc3RhbmNlOmYzMiwgaW5uZXJSYWRpdXM6ZjMyKSAtPiBmMzJ7XG4gICAgICAgIGlmKGRpc3RhbmNlIDwgaW5uZXJSYWRpdXMpe1xuICAgICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gMS4wIC0gKGRpc3RhbmNlIC0gaW5uZXJSYWRpdXMpICAvICh0b3RhbFJhZGl1cyAtIGlubmVyUmFkaXVzKTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbmAscmM9YFxuXG4gICAgI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcblxuICAgIHN0cnVjdCBQaWNrUmVzdWx0e1xuICAgICAgICBwaWNrX21lc2hJRDpmMzIsXG4gICAgICAgIHBpY2tfbWVzaElEMjpmMzIsXG4gICAgICAgIHBpY2tfVVY6dmVjMjxmMzI+LFxuICAgICAgICBwaWNrX1Bvc2l0aW9uOnZlYzQ8ZjMyPixcbiAgICAgICAgcGlja19Ob3JtYWw6dmVjNDxmMzI+LFxuICAgICAgICBwaWNrX1RhbmdlbnQ6dmVjNDxmMzI+LFxuICAgIH1cblxuICAgIC8vQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBnbG9iYWxVbmlmb3JtOiBHbG9iYWxVbmlmb3JtO1xuICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSxyZWFkX3dyaXRlPiBvdXRCdWZmZXI6IFBpY2tSZXN1bHQ7XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB2aXNpYmxlTWFwIDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCAxIClcbiAgICBmbiBDc01haW4oIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+ICwgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbEludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4pXG4gICAge1xuICAgIHZhciByZXN1bHQ6UGlja1Jlc3VsdCA7XG4gICAgLy8gcmVzdWx0LnBpY2tfbWVzaElEXG4gICAgbGV0IHRleFNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyh2aXNpYmxlTWFwKS54eTtcbiAgICBsZXQgc2NyZWVuUG9pbnQgPSB2ZWMyPGYzMj4oZ2xvYmFsVW5pZm9ybS5tb3VzZVgvZ2xvYmFsVW5pZm9ybS53aW5kb3dXaWR0aCxnbG9iYWxVbmlmb3JtLm1vdXNlWS9nbG9iYWxVbmlmb3JtLndpbmRvd0hlaWdodCk7XG5cbiAgICBsZXQgbW91c2VVViA9IHNjcmVlblBvaW50ICogdmVjMjxmMzI+KHRleFNpemUueHkpOyBcbiAgICBsZXQgaW5mbyA9IHRleHR1cmVMb2FkKHZpc2libGVNYXAsIHZlYzI8aTMyPihtb3VzZVVWKSAsIDApO1xuXG4gICAgb3V0QnVmZmVyLnBpY2tfbWVzaElEID0gZjMyKGluZm8udykgO1xuICAgIG91dEJ1ZmZlci5waWNrX21lc2hJRDIgPSBmMzIoaW5mby53KSA7XG4gICAgb3V0QnVmZmVyLnBpY2tfVGFuZ2VudCA9IHZlYzQ8ZjMyPigyLjAsMi4wLDIuMCwyLjApIDtcbiAgICBvdXRCdWZmZXIucGlja19VViA9IHZlYzI8ZjMyPihnbG9iYWxVbmlmb3JtLm1vdXNlWCxnbG9iYWxVbmlmb3JtLm1vdXNlWSkgO1xuICAgIG91dEJ1ZmZlci5waWNrX1Bvc2l0aW9uID0gdmVjNDxmMzI+KGluZm8ueHl6dykgO1xuICAgIG91dEJ1ZmZlci5waWNrX05vcm1hbCA9IHZlYzQ8ZjMyPihpbmZvLnh5encpIDtcbiAgICB9XG5gLFhnPWBcbiNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG4gIHN0cnVjdCBVbmlmb3JtRGF0YSB7XG4gICAgcmFkaXVzOiBmMzIgLFxuICAgIGJpYXM6IGYzMixcbiAgICBhb1Bvd2VyOiBmMzIgLFxuICAgIGJsdXJTaXplOiBmMzIgLFxuICB9O1xuXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gc3RhbmRVbmlmb3JtOiBHbG9iYWxVbmlmb3JtO1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1EYXRhOiBVbmlmb3JtRGF0YTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLHJlYWQ+IHNhbXBsZURhdGE6IGFycmF5PHZlYzQ8ZjMyPj47XG5cbiAgLy8gQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhciBjb2xvck1hcCA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhciBwb3NpdGlvbk1hcCA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhciBub3JtYWxNYXAgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDUpIHZhciBub2lzZU1hcFNhbXBsZXI6IHNhbXBsZXI7XG4gIEBncm91cCgwKSBAYmluZGluZyg2KSB2YXIgbm9pc2VNYXAgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDcpIHZhciBvdXRUZXggOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTE2ZmxvYXQsIHdyaXRlPjtcblxuICB2YXI8cHJpdmF0ZT4ga2VybmVsU2l6ZTogaTMyID0gMzIgO1xuXG4gIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSggOCAsIDggKVxuICBmbiBDc01haW4oIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+ICwgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbEludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4pXG4gIHtcbiAgICB2YXIgZnJhZ0Nvb3JkID0gdmVjMjxpMzI+KCBnbG9iYWxJbnZvY2F0aW9uX2lkLnh5ICk7XG5cbiAgICB2YXIgdGV4U2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKHBvc2l0aW9uTWFwKS54eTtcbiAgICB2YXIgdGV4Q29vcmQgPSB2ZWMyPGYzMj4oZnJhZ0Nvb3JkKSAvIHZlYzI8ZjMyPih0ZXhTaXplKTtcblxuICAgIHZhciBmcmFnQ29sb3IgPSB2ZWM0PGYzMj4oMS4wKTtcblxuICAgIHZhciB2aWV3TWF0ID0gc3RhbmRVbmlmb3JtLnZpZXdNYXQgIDtcbiAgICAvLyB2YXIgY29sb3IgPSB0ZXh0dXJlTG9hZChjb2xvck1hcCwgZnJhZ0Nvb3JkICwgMCApIDtcbiAgICB2YXIgd1BvcyA9IHRleHR1cmVMb2FkKHBvc2l0aW9uTWFwLCBmcmFnQ29vcmQgLCAwICkgO1xuXG4gICAgdmFyIGZyYWdQb3NpdGlvbiA9IHZpZXdNYXQgKiB2ZWM0PGYzMj4od1Bvcy54eXosMS4wKTtcbiAgICBmcmFnUG9zaXRpb24gPSB2ZWM0KGZyYWdQb3NpdGlvbi54eXogLyBmcmFnUG9zaXRpb24udywxLjApIDtcblxuICAgIHZhciB0ZXhOb3JtYWwgPSB0ZXh0dXJlTG9hZChub3JtYWxNYXAsIGZyYWdDb29yZCAsIDAgKSA7XG4gICAgdmFyIHNhbXBsZU5vcm1hbCA9IHRleE5vcm1hbC54eXogO1xuICAgIHNhbXBsZU5vcm1hbCA9IHNhbXBsZU5vcm1hbCAqIDIuMCAtIDEuMDtcbiAgICB2YXIgZnJhZ05vcm1hbCA9IHZpZXdNYXQgKiB2ZWM0PGYzMj4oKHNhbXBsZU5vcm1hbC54eXopLDAuMCk7XG5cbiAgICB2YXIgcGVzID0gdmVjMjxmMzI+KHRleFNpemUueHkpIC8gNC4wIDtcbiAgICB2YXIgbm9pc2VUZXg6dmVjNDxmMzI+ID0gdGV4dHVyZVNhbXBsZUxldmVsKG5vaXNlTWFwLCBub2lzZU1hcFNhbXBsZXIsIHRleENvb3JkICogcGVzICwgMC4wKTtcbiAgICB2YXIgcmFuZG9tVmVjICA9ICh2aWV3TWF0ICogdmVjNDxmMzI+KG5vcm1hbGl6ZShub2lzZVRleC54eXopLDAuMCkpLnh5ejtcblxuICAgIHZhciB0YW5nZW50ID0gbm9ybWFsaXplKHJhbmRvbVZlYyAtIGZyYWdOb3JtYWwueHl6ICogZG90KHJhbmRvbVZlYyAsIGZyYWdOb3JtYWwueHl6KSk7XG4gICAgdmFyIGJUYW5nZW50ID0gY3Jvc3MoZnJhZ05vcm1hbC54eXosIHRhbmdlbnQpICsgMC4wMDAxIDtcbiAgICB2YXIgdGJuID0gbWF0M3gzPGYzMj4odGFuZ2VudCwgYlRhbmdlbnQsIGZyYWdOb3JtYWwueHl6KTtcblxuICAgIHZhciBvZmZzZXQ6dmVjNDxmMzI+O1xuICAgIHZhciBzYW1wbGVQb3MgOnZlYzM8ZjMyPjtcbiAgICB2YXIgb2Zmc2V0UG9zaXRpb246ZjMyO1xuICAgIHZhciBzYW1wbGVfZGVwdGhfdjp2ZWM0PGYzMj47XG4gICAgdmFyIG9jY2x1c2lvbjpmMzIgPSAwLjA7XG4gICAgdmFyIHJhbmdlQ2hlY2s6ZjMyID0gMC4wIDtcbiAgICB2YXIgcmFkaXVzOmYzMiA9IHVuaWZvcm1EYXRhLnJhZGl1cyAqIDMyLjAgKiBmcmFnUG9zaXRpb24ueiA7XG5cbiAgICBmb3IodmFyIGk6aTMyID0gMDsgaSA8IDMyIDsgaSA9IGkgKyAxICl7XG4gICAgICBzYW1wbGVQb3MgID0gKHRibiAqIHNhbXBsZURhdGFbaV0ueHl6ICkgO1xuICAgICAgc2FtcGxlUG9zICA9IGZyYWdQb3NpdGlvbi54eXogKyBzYW1wbGVQb3MgKiByYWRpdXMgO1xuXG4gICAgICBvZmZzZXQgPSB2ZWM0KHNhbXBsZVBvcywgMS4wKTtcbiAgICAgIG9mZnNldCA9IHN0YW5kVW5pZm9ybS5wcm9qTWF0ICogb2Zmc2V0O1xuXG4gICAgICB2YXIgb2ZmID0gb2Zmc2V0Lnh5eiAvIG9mZnNldC53O1xuICAgICAgb2ZmID0gKG9mZi54eXogKiAwLjUgKSArIDAuNSA7XG4gICAgICBvZmYueSA9IDEuMCAtIG9mZi55IDtcbiAgICAgIHZhciBvZmZzZXRVViA9IHZlYzI8aTMyPihvZmYueHkgKiB2ZWMyPGYzMj4odGV4U2l6ZS54eSkpO1xuXG4gICAgICBzYW1wbGVfZGVwdGhfdiA9IHRleHR1cmVMb2FkKHBvc2l0aW9uTWFwLCBvZmZzZXRVVi54eSAsIDAgKSA7XG4gICAgICBzYW1wbGVfZGVwdGhfdiA9IHZlYzQ8ZjMyPigodmlld01hdCAqIHZlYzQ8ZjMyPihzYW1wbGVfZGVwdGhfdi54eXosMS4wKSkueHl6LDEuMCk7XG4gICAgICBvZmZzZXRQb3NpdGlvbiA9IHNhbXBsZV9kZXB0aF92LnogLyBzYW1wbGVfZGVwdGhfdi53IDtcblxuICAgICAgcmFuZ2VDaGVjayA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIHJhZGl1cyAvIGFicyhvZmZzZXRQb3NpdGlvbiAtIGZyYWdQb3NpdGlvbi56ICkpO1xuICAgICAgLy8gcmFuZ2VDaGVjayA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIHJhZGl1cyAvIHVuaWZvcm1EYXRhLmJpYXMpO1xuXG4gICAgICB2YXIgYSA9IDEuMCA7XG4gICAgICBpZihvZmZzZXRQb3NpdGlvbiA+PSAoc2FtcGxlUG9zLnogKyB1bmlmb3JtRGF0YS5iaWFzKSl7XG4gICAgICAgIGEgPSAwLjAgO1xuICAgICAgfVxuICAgICAgYSA9IGEgKiByYW5nZUNoZWNrIDtcbiAgICAgIG9jY2x1c2lvbiA9IG9jY2x1c2lvbiArIGEgO1xuICAgIH1cblxuICAgIG9jY2x1c2lvbiA9IDEuMCAtICggb2NjbHVzaW9uIC8gZjMyKGtlcm5lbFNpemUpICogdGV4Tm9ybWFsLncgKTtcbiAgICBvY2NsdXNpb24gPSBwb3cob2NjbHVzaW9uLCB1bmlmb3JtRGF0YS5hb1Bvd2VyKSA7XG5cbiAgICAvLyBjb2xvciA9IGNvbG9yICogb2NjbHVzaW9uIDtcblxuICAgIHRleHR1cmVTdG9yZShvdXRUZXgsIGZyYWdDb29yZCAsIHZlYzQob2NjbHVzaW9uKSk7XG4gIH1cbmAsc2M9YFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByYXlUcmFjZUJ1ZmZlciA6IGFycmF5PFJheVRyYWNlUmV0RGF0YT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgY29sb3JNYXAgOiB0ZXh0dXJlXzJkPGYzMj47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXIgc3NyTWFwU2FtcGxlciA6IHNhbXBsZXI7XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXIgc3NyTWFwIDogdGV4dHVyZV8yZDxmMzI+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyIG91dFRleCA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuXG4gIHZhcjxwcml2YXRlPiBjb2xvclRleFNpemU6IHZlYzI8dTMyPjtcbiAgdmFyPHByaXZhdGU+IHNzclRleFNpemU6IHZlYzI8dTMyPjtcbiAgdmFyPHByaXZhdGU+IGZyYWdDb29yZDogdmVjMjxpMzI+O1xuICB2YXI8cHJpdmF0ZT4gc3NyQ29vcmQ6IHZlYzI8aTMyPjtcblxuICBzdHJ1Y3QgUmF5VHJhY2VSZXREYXRhe1xuICAgIHNreUNvbG9yOnZlYzM8ZjMyPixcbiAgICByb3VnaG5lc3M6ZjMyLFxuXG4gICAgaGl0Q29vcmQ6dmVjMjxmMzI+LFxuICAgIGFscGhhOmYzMixcbiAgICBmcmVzbmVsOmYzMixcbiAgfVxuICBcbiAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCA4ICwgOCAsIDEgKVxuICBmbiBDc01haW4oIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+ICwgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbEludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4pXG4gIHtcbiAgICBmcmFnQ29vcmQgPSB2ZWMyPGkzMj4oIGdsb2JhbEludm9jYXRpb25faWQueHkgKTtcbiAgICBjb2xvclRleFNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyhjb2xvck1hcCkueHk7XG4gICAgc3NyVGV4U2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKHNzck1hcCkueHk7XG4gICAgaWYoZnJhZ0Nvb3JkLnggPj0gaTMyKGNvbG9yVGV4U2l6ZS54KSB8fCBmcmFnQ29vcmQueSA+PSBpMzIoY29sb3JUZXhTaXplLnkpKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2NhbGU6ZjMyID0gZjMyKHNzclRleFNpemUueCkgLyBmMzIoY29sb3JUZXhTaXplLngpO1xuICAgIHNzckNvb3JkID0gdmVjMjxpMzI+KHZlYzI8ZjMyPihmcmFnQ29vcmQueHkpICogc2NhbGUpO1xuICAgIGxldCBpbmRleCA9IHNzckNvb3JkLnggKyBzc3JDb29yZC55ICogaTMyKHNzclRleFNpemUueCk7XG4gICAgbGV0IGhpdERhdGEgPSByYXlUcmFjZUJ1ZmZlcltpbmRleF07XG4gICAgdmFyIGNvbG9yID0gdGV4dHVyZUxvYWQoY29sb3JNYXAsIGZyYWdDb29yZCAsIDApO1xuICAgIHZhciB1djAxID0gdmVjMjxmMzI+KGYzMihmcmFnQ29vcmQueCksIGYzMihmcmFnQ29vcmQueSkpO1xuICAgIHV2MDEgPSB1djAxIC8gdmVjMjxmMzI+KGNvbG9yVGV4U2l6ZSAtIDEpO1xuICAgIFxuICAgIHZhciBzc3JDb2xvciA9IHRleHR1cmVTYW1wbGVMZXZlbChzc3JNYXAsIHNzck1hcFNhbXBsZXIsIHV2MDEsIDAuMCk7XG4gICAgdmFyIHRjID0gbWl4KGNvbG9yLCBzc3JDb2xvciwgaGl0RGF0YS5mcmVzbmVsKSA7XG4gICAgdmFyIG91dENvbG9yID0gdGMgO1xuICAgIG91dENvbG9yLmEgPSBjb2xvci5hIDsgXG4gICAgdGV4dHVyZVN0b3JlKG91dFRleCwgZnJhZ0Nvb3JkICwgb3V0Q29sb3IgKTtcbiAgfVxuXG5gLGFjPWBcbiAgc3RydWN0IFNTUlVuaWZvcm1EYXRhIHtcbiAgICBzc3JCdWZmZXJTaXplWDogZjMyLFxuICAgIHNzckJ1ZmZlclNpemVZOiBmMzIsXG4gICAgY29sb3JNYXBTaXplWDogZjMyLFxuICAgIGNvbG9yTWFwU2l6ZVk6IGYzMixcblxuICAgIGZhZGVFZGdlUmF0aW86IGYzMixcbiAgICByYXlNYXJjaFJhdGlvOiBmMzIsXG4gICAgZmFkZURpc3RhbmNlTWluOiBmMzIsXG4gICAgZmFkZURpc3RhbmNlTWF4OiBmMzIsXG4gICAgXG4gICAgbWl4VGhyZXNob2xkOiBmMzIsXG4gICAgcm91Z2huZXNzVGhyZXNob2xkOiBmMzIsXG4gICAgcmVmbGVjdGlvblJhdGlvOiBmMzIsXG4gICAgcG93RG90Uk46IGYzMixcblxuICAgIHJhbmRvbVNlZWRYOiBmMzIsXG4gICAgcmFuZG9tU2VlZFk6IGYzMixcbiAgICBzbG90MTogZjMyLFxuICAgIHNsb3QyOiBmMzIsXG4gIH07XG5cbiAgc3RydWN0IFJheVRyYWNlUmV0RGF0YXtcbiAgICBza3lDb2xvcjp2ZWMzPGYzMj4sXG4gICAgcm91Z2huZXNzOmYzMixcblxuICAgIGhpdENvb3JkOnZlYzI8ZjMyPixcbiAgICBhbHBoYTpmMzIsXG4gICAgZnJlc25lbDpmMzIsXG4gIH1cblxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHNzclVuaWZvcm06IFNTUlVuaWZvcm1EYXRhO1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJheVRyYWNlQnVmZmVyIDogYXJyYXk8UmF5VHJhY2VSZXREYXRhPjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBzc3JDb2xvckRhdGEgOiBhcnJheTx2ZWM0PGYzMj4+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IGhpc3RvcnlQb3NpdGlvbiA6IGFycmF5PHZlYzQ8ZjMyPj47XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhciBjb2xvck1hcDogdGV4dHVyZV8yZDxmMzI+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNSkgdmFyIG91dFRleCA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuXG4gIHZhcjxwcml2YXRlPiBzc3JCdWZmZXJDb29yZDogdmVjMjxpMzI+O1xuICB2YXI8cHJpdmF0ZT4gY29sb3JUZXhTaXplOiB2ZWMyPGkzMj47XG4gIHZhcjxwcml2YXRlPiBidWZmZXJEYXRhOiBSYXlUcmFjZVJldERhdGE7XG4gIHZhcjxwcml2YXRlPiBzc3JCdWZmZXJTaXplOiB2ZWMyPGkzMj47XG4gIHZhcjxwcml2YXRlPiBjb29yZEluZGV4OiBpMzI7XG5cbiAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCA4ICwgOCAsIDEgKVxuICBmbiBDc01haW4oIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+ICwgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbEludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4pXG4gIHtcbiAgICBzc3JCdWZmZXJDb29yZCA9IHZlYzI8aTMyPiggZ2xvYmFsSW52b2NhdGlvbl9pZC54eSApO1xuICAgIHNzckJ1ZmZlclNpemUgPSB2ZWMyPGkzMj4oaTMyKHNzclVuaWZvcm0uc3NyQnVmZmVyU2l6ZVgpLCBpMzIoc3NyVW5pZm9ybS5zc3JCdWZmZXJTaXplWSkpO1xuICAgIGNvbG9yVGV4U2l6ZSA9IHZlYzI8aTMyPihpMzIoc3NyVW5pZm9ybS5jb2xvck1hcFNpemVYKSwgaTMyKHNzclVuaWZvcm0uY29sb3JNYXBTaXplWSkpO1xuXG4gICAgaWYoc3NyQnVmZmVyQ29vcmQueCA+PSBzc3JCdWZmZXJTaXplLnggfHwgc3NyQnVmZmVyQ29vcmQueSA+PSBzc3JCdWZmZXJTaXplLnkpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29vcmRJbmRleCA9IHNzckJ1ZmZlckNvb3JkLnggKyBzc3JCdWZmZXJDb29yZC55ICogc3NyQnVmZmVyU2l6ZS54O1xuICAgIGJ1ZmZlckRhdGEgPSByYXlUcmFjZUJ1ZmZlcltjb29yZEluZGV4XTtcbiAgICB2YXIgb2MgPSB2ZWM0PGYzMj4oMC4wLCAwLjAsIDAuMCwgLTEuMCk7XG4gICAgXG4gICAgdmFyIG1peEZhY3RvciA9IGhpc3RvcnlQb3NpdGlvbltjb29yZEluZGV4XS53O1xuICAgIFxuICAgIGlmKGJ1ZmZlckRhdGEuYWxwaGEgPj0gMC4wICYmIGJ1ZmZlckRhdGEucm91Z2huZXNzIDwgc3NyVW5pZm9ybS5yb3VnaG5lc3NUaHJlc2hvbGQpe1xuICAgICAgbGV0IHJvdWdobmVzcyA9IGNsYW1wKGJ1ZmZlckRhdGEucm91Z2huZXNzLCAwLjAsIDEuMCk7XG4gICAgICBsZXQgcHJlZmlsdGVyQ29sb3IgPSBidWZmZXJEYXRhLnNreUNvbG9yO1xuICAgICAgdmFyIHNzckNvbG9yID0gdGV4dHVyZUxvYWQoY29sb3JNYXAsIHZlYzI8aTMyPihidWZmZXJEYXRhLmhpdENvb3JkKSwgMCk7XG4gICAgICBzc3JDb2xvci53ID0gYnVmZmVyRGF0YS5hbHBoYTtcbiAgICAgIG9jID0gc3NyQ29sb3I7XG4gICAgfVxuICAgIGxldCBza3lDb2xvciA9IHZlYzQ8ZjMyPihidWZmZXJEYXRhLnNreUNvbG9yLCAxLjApO1xuICAgIG9jID0gbWl4KG9jLCBza3lDb2xvciwgMS4wIC0gYnVmZmVyRGF0YS5hbHBoYSk7XG4gICAgXG4gICAgbGV0IGxhc3RDb2xvciA9IHNzckNvbG9yRGF0YVtjb29yZEluZGV4XTtcbiAgICB2YXIgbmV3Q29sb3IgPSBtaXgob2MsIGxhc3RDb2xvciwgbWl4RmFjdG9yKTtcbiAgICBuZXdDb2xvci53ID0gb2MudztcbiAgICBcbiAgICBzc3JDb2xvckRhdGFbY29vcmRJbmRleF0gPSBuZXdDb2xvcjtcbiAgICBcbiAgICB0ZXh0dXJlU3RvcmUob3V0VGV4LCBzc3JCdWZmZXJDb29yZCAsIG5ld0NvbG9yKTtcbiAgfVxuYCxvYz1gXG4gICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG5cbiAgc3RydWN0IFNTUlVuaWZvcm1EYXRhIHtcbiAgICBzc3JCdWZmZXJTaXplWDogZjMyLFxuICAgIHNzckJ1ZmZlclNpemVZOiBmMzIsXG4gICAgY29sb3JNYXBTaXplWDogZjMyLFxuICAgIGNvbG9yTWFwU2l6ZVk6IGYzMixcblxuICAgIGZhZGVFZGdlUmF0aW86IGYzMixcbiAgICByYXlNYXJjaFJhdGlvOiBmMzIsXG4gICAgZmFkZURpc3RhbmNlTWluOiBmMzIsXG4gICAgZmFkZURpc3RhbmNlTWF4OiBmMzIsXG4gICAgXG4gICAgbWl4VGhyZXNob2xkOiBmMzIsXG4gICAgcm91Z2huZXNzVGhyZXNob2xkOiBmMzIsXG4gICAgcmVmbGVjdGlvblJhdGlvOiBmMzIsXG4gICAgcG93RG90Uk46IGYzMixcblxuICAgIHJhbmRvbVNlZWRYOiBmMzIsXG4gICAgcmFuZG9tU2VlZFk6IGYzMixcbiAgICBzbG90MTogZjMyLFxuICAgIHNsb3QyOiBmMzIsXG4gIH07XG5cbiAgc3RydWN0IEhpdERhdGF7XG4gICAgaGl0UG9zOnZlYzM8ZjMyPixcbiAgICBoaXROb3JtYWw6dmVjMzxmMzI+LFxuICAgIGZhZGVBbHBoYTp2ZWM0PGYzMj4sXG4gICAgaGl0Q29vcmQ6dmVjMjxpMzI+LFxuICAgIGhpdFJlc3VsdDppMzIsXG4gICAgaGl0U2t5OmkzMixcbiAgfTtcblxuICBzdHJ1Y3QgUmF5VHJhY2VSZXREYXRhe1xuICAgIHNreUNvbG9yOnZlYzM8ZjMyPixcbiAgICByb3VnaG5lc3M6ZjMyLFxuXG4gICAgaGl0Q29vcmQ6dmVjMjxmMzI+LFxuICAgIGFscGhhOmYzMixcbiAgICBmcmVzbmVsOmYzMixcbiAgfVxuXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gc3RhbmRVbmlmb3JtOiBHbG9iYWxVbmlmb3JtO1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHVuaWZvcm0+IHNzclVuaWZvcm06IFNTUlVuaWZvcm1EYXRhO1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJheVRyYWNlQnVmZmVyIDogYXJyYXk8UmF5VHJhY2VSZXREYXRhPjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBoaXN0b3J5UG9zaXRpb24gOiBhcnJheTx2ZWM0PGYzMj4+O1xuXG4gIEBncm91cCgwKSBAYmluZGluZyg1KSB2YXIgekJ1ZmZlclRleHR1cmUgOiB0ZXh0dXJlXzJkPGYzMj47XG4gIEBncm91cCgwKSBAYmluZGluZyg2KSB2YXIgbm9ybWFsQnVmZmVyVGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNykgdmFyIG1hdGVyaWFsQnVmZmVyVGV4IDogdGV4dHVyZV8yZDxmMzI+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoOCkgdmFyIHByZWZpbHRlck1hcFNhbXBsZXI6IHNhbXBsZXI7XG4gIEBncm91cCgwKSBAYmluZGluZyg5KSB2YXIgcHJlZmlsdGVyTWFwOiB0ZXh0dXJlX2N1YmU8ZjMyPjtcblxuICB2YXI8cHJpdmF0ZT4gcmF5T3JpZ2luOiB2ZWMzPGYzMj47XG4gIHZhcjxwcml2YXRlPiByYXlEaXJlY3Rpb246IHZlYzM8ZjMyPjtcbiAgdmFyPHByaXZhdGU+IGNhbWVyYVBvc2l0aW9uOiB2ZWMzPGYzMj47XG4gIHZhcjxwcml2YXRlPiByZWZsZWN0aW9uRGlyOiB2ZWMzPGYzMj47XG4gIHZhcjxwcml2YXRlPiBjb2xvclRleFNpemU6IHZlYzI8aTMyPjtcbiAgdmFyPHByaXZhdGU+IGZyYWdDb29yZENvbG9yOiB2ZWMyPGkzMj47XG4gIHZhcjxwcml2YXRlPiBzc3JCdWZmZXJDb29yZDogdmVjMjxpMzI+O1xuICB2YXI8cHJpdmF0ZT4gc3NyQnVmZmVyU2l6ZTogdmVjMjxpMzI+O1xuICB2YXI8cHJpdmF0ZT4gaGl0RGF0YTogSGl0RGF0YTtcbiAgdmFyPHByaXZhdGU+IHJheVRyYWNlUmV0OiBSYXlUcmFjZVJldERhdGE7XG4gIHZhcjxwcml2YXRlPiB3b3JsZFBvc2l0aW9uOiB2ZWMzPGYzMj47XG4gIHZhcjxwcml2YXRlPiB3b3JsZE5vcm1hbDogdmVjMzxmMzI+O1xuICB2YXI8cHJpdmF0ZT4gcm91Z2huZXNzOiBmMzI7XG4gIHZhcjxwcml2YXRlPiBmcmVzbmVsOiBmMzI7XG5cbiAgdmFyPHByaXZhdGU+IGhpc3RvcnlQb3M6IHZlYzM8ZjMyPjtcbiAgdmFyPHByaXZhdGU+IGNvb3JkSW5kZXg6IGkzMjtcblxuICB2YXIgPHByaXZhdGU+IFBJOiBmMzIgPSAzLjE0MTU5O1xuXG4gIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSggOCAsIDggLCAxIClcbiAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICB7XG4gICAgc3NyQnVmZmVyQ29vcmQgPSB2ZWMyPGkzMj4oIGdsb2JhbEludm9jYXRpb25faWQueHkpO1xuICAgIHNzckJ1ZmZlclNpemUgPSB2ZWMyPGkzMj4oaTMyKHNzclVuaWZvcm0uc3NyQnVmZmVyU2l6ZVgpLCBpMzIoc3NyVW5pZm9ybS5zc3JCdWZmZXJTaXplWSkpO1xuICAgIGlmKHNzckJ1ZmZlckNvb3JkLnggPj0gc3NyQnVmZmVyU2l6ZS54IHx8IHNzckJ1ZmZlckNvb3JkLnkgPj0gc3NyQnVmZmVyU2l6ZS55KXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb29yZEluZGV4ID0gc3NyQnVmZmVyQ29vcmQueCArIHNzckJ1ZmZlckNvb3JkLnkgKiBzc3JCdWZmZXJTaXplLng7XG5cbiAgICBjb2xvclRleFNpemUgPSB2ZWMyPGkzMj4oaTMyKHNzclVuaWZvcm0uY29sb3JNYXBTaXplWCksIGkzMihzc3JVbmlmb3JtLmNvbG9yTWFwU2l6ZVkpKTtcbiAgICBmcmFnQ29vcmRDb2xvciA9IGNvbnZlcnRDb2xvckNvb3JkRnJvbVNTUkNvb3JkKHNzckJ1ZmZlckNvb3JkKTtcblxuICAgIGhpdERhdGEuZmFkZUFscGhhID0gdmVjNDxmMzI+KDAuMCk7XG4gICAgaGl0RGF0YS5oaXRDb29yZCA9IHZlYzI8aTMyPigwKTtcbiAgICBoaXREYXRhLmhpdFJlc3VsdCA9IDA7XG4gICAgaGl0RGF0YS5oaXROb3JtYWwgPSB2ZWMzPGYzMj4oMC4wLCAxLjAsIDAuMCk7XG4gICAgaGl0RGF0YS5oaXRTa3kgPSAxO1xuXG4gICAgd29ybGRQb3NpdGlvbiA9IHRleHR1cmVMb2FkKHpCdWZmZXJUZXh0dXJlLCBmcmFnQ29vcmRDb2xvciAsIDApLnh5ejtcbiAgICBoaXN0b3J5UG9zID0gaGlzdG9yeVBvc2l0aW9uW2Nvb3JkSW5kZXhdLnh5ejtcbiAgICBcbiAgICB2YXIgbWl4RmFjdG9yID0gMC4yO1xuICAgIGlmKGxlbmd0aChoaXN0b3J5UG9zIC0gd29ybGRQb3NpdGlvbikgPCBzc3JVbmlmb3JtLm1peFRocmVzaG9sZCl7XG4gICAgICAgIG1peEZhY3RvciA9IDAuOTtcbiAgICB9XG4gICAgaGlzdG9yeVBvc2l0aW9uW2Nvb3JkSW5kZXhdID0gdmVjNDxmMzI+KHdvcmxkUG9zaXRpb24sIG1peEZhY3Rvcik7XG4gICAgXG4gICAgbGV0IG5vcm1hbF92NCA9IHRleHR1cmVMb2FkKG5vcm1hbEJ1ZmZlclRleCwgZnJhZ0Nvb3JkQ29sb3IgLCAwKTtcbiAgICB3b3JsZE5vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMzPGYzMj4obm9ybWFsX3Y0Lnh5eikgKiAyLjAgLSAxLjApO1xuICAgIGxldCBtYXRlcmlhbERhdGEgPSB0ZXh0dXJlTG9hZChtYXRlcmlhbEJ1ZmZlclRleCwgZnJhZ0Nvb3JkQ29sb3IgLCAwICk7XG4gICAgbGV0IHJvdWdobmVzcyA9IG1hdGVyaWFsRGF0YS5nICogKDEuMCAtIG1hdGVyaWFsRGF0YS5iKTtcbiAgICBmcmVzbmVsID0gKDEuMCAtIHJvdWdobmVzcykgKiBzc3JVbmlmb3JtLnJlZmxlY3Rpb25SYXRpbztcblxuICAgIGNhbWVyYVBvc2l0aW9uID0gdmVjMzxmMzI+KHN0YW5kVW5pZm9ybS5jYW1lcmFXb3JsZE1hdHJpeFszXS54eXopO1xuICAgIHJheU9yaWdpbiA9IHZlYzM8ZjMyPih3b3JsZFBvc2l0aW9uLnh5eik7XG5cbiAgICByYXlEaXJlY3Rpb24gPSBub3JtYWxpemUodmVjMzxmMzI+KHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24pKTtcbiAgICBcbiAgICB2YXIgcmFuZG9tU2VlZCA9IGZyYWN0KHNzclVuaWZvcm0ucmFuZG9tU2VlZFggKyB3b3JsZFBvc2l0aW9uLngpO1xuICAgIHJhbmRfc2VlZC54ID0gcmFuZG9tU2VlZDtcbiAgICByYW5kX3NlZWQueSA9IGZyYWN0KHNzclVuaWZvcm0ucmFuZG9tU2VlZFkgKyB3b3JsZFBvc2l0aW9uLnkgKyB3b3JsZFBvc2l0aW9uLnopO1xuICAgIHJhbmRvbVNlZWQgPSByYW5kKCk7XG4gICAgXG4gICAgbGV0IG5vcm1hbFJhbmRvbSA9IG1ha2VSYW5kb21EaXJlY3Rpb24od29ybGROb3JtYWwsIHUzMihyYW5kb21TZWVkICogMjU2LjApLCAyNTYsIHJvdWdobmVzcyk7XG4gICAgXG4gICAgcmVmbGVjdGlvbkRpciA9IG5vcm1hbGl6ZShyZWZsZWN0KHJheURpcmVjdGlvbiwgbm9ybWFsUmFuZG9tKSk7XG5cbiAgICBpZihub3JtYWxfdjQudyA+IDAuNSAmJiByb3VnaG5lc3MgPCBzc3JVbmlmb3JtLnJvdWdobmVzc1RocmVzaG9sZCl7XG4gICAgICBsZXQgdXZPcmlnaW4gPSB2ZWMyPGYzMj4oZjMyKGZyYWdDb29yZENvbG9yLngpLCBmMzIoZnJhZ0Nvb3JkQ29sb3IueSkpO1xuICAgICAgbGV0IHJheU1hcmNoUG9zaXRpb24gPSByYXlPcmlnaW4gKyByZWZsZWN0aW9uRGlyICogMTAwLjA7XG4gICAgICB2YXIgdXZSYXlNYXJjaCA9IHN0YW5kVW5pZm9ybS5wcm9qTWF0ICogKHN0YW5kVW5pZm9ybS52aWV3TWF0ICogdmVjNDxmMzI+KHJheU1hcmNoUG9zaXRpb24sIDEuMCkpO1xuICAgICAgdmFyIHV2T2Zmc2V0ID0gKHZlYzI8ZjMyPih1dlJheU1hcmNoLnh5IC8gdXZSYXlNYXJjaC53KSArIDEuMCkgKiAwLjU7XG4gICAgICB1dk9mZnNldC55ID0gMS4wIC0gdXZPZmZzZXQueTtcbiAgICAgIHV2T2Zmc2V0ID0gdXZPZmZzZXQgKiB2ZWMyPGYzMj4oY29sb3JUZXhTaXplIC0gMSkgLSB1dk9yaWdpbjtcbiAgICAgIHV2T2Zmc2V0ID0gbm9ybWFsaXplKHV2T2Zmc2V0KTtcblxuICAgICAgcmF5VHJhY2UodXZPZmZzZXQpO1xuICAgICAgaWYoaGl0RGF0YS5oaXRSZXN1bHQgPT0gMSl7XG4gICAgICAgICAgaGlkaW5nQXJ0aWZhY3QoKTtcbiAgICAgICAgICByYXlUcmFjZVJldC5hbHBoYSA9IGhpdERhdGEuZmFkZUFscGhhLnggKiBoaXREYXRhLmZhZGVBbHBoYS55ICogaGl0RGF0YS5mYWRlQWxwaGEueiAqIGhpdERhdGEuZmFkZUFscGhhLnc7XG4gICAgICAgICAgaWYoaGl0RGF0YS5oaXRTa3kgPT0gMSl7XG4gICAgICAgICAgICByYXlUcmFjZVJldC5hbHBoYSA9IDAuMDtcbiAgICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmF5VHJhY2VSZXQuYWxwaGEgPSAwLjA7XG4gICAgICB9XG4gICAgICByYXlUcmFjZVJldC5za3lDb2xvciA9IGdldFNreUNvbG9yKCk7XG4gICAgfWVsc2V7XG4gICAgICByYXlUcmFjZVJldC5hbHBoYSA9IC0xLjA7XG4gICAgICByYXlUcmFjZVJldC5za3lDb2xvciA9IHZlYzM8ZjMyPigwLjApO1xuICAgIH1cblxuICAgIHJheVRyYWNlUmV0LnJvdWdobmVzcyA9IHJvdWdobmVzcztcbiAgICByYXlUcmFjZVJldC5mcmVzbmVsID0gZnJlc25lbDtcbiAgICByYXlUcmFjZVJldC5oaXRDb29yZCA9IHZlYzI8ZjMyPihoaXREYXRhLmhpdENvb3JkKTtcblxuICAgIGxldCBpbmRleDppMzIgPSBzc3JCdWZmZXJDb29yZC54ICsgc3NyQnVmZmVyQ29vcmQueSAqIHNzckJ1ZmZlclNpemUueDtcbiAgICByYXlUcmFjZUJ1ZmZlcltpbmRleF0gPSByYXlUcmFjZVJldDtcbiAgfVxuXG4gIGZuIG1ha2VSYW5kb21EaXJlY3Rpb24oc3JjRGlyZWN0aW9uOnZlYzM8ZjMyPiwgaTp1MzIsIFNBTVBMRV9DT1VOVDp1MzIsIHJvdWdobmVzczpmMzIpIC0+IHZlYzM8ZjMyPlxuICB7XG4gICAgdmFyIE46IHZlYzM8ZjMyPiA9IG5vcm1hbGl6ZShzcmNEaXJlY3Rpb24pO1xuICAgIHZhciBYaTp2ZWMyPGYzMj4gPSBoYW1tZXJzbGV5KGksIFNBTVBMRV9DT1VOVCk7XG4gICAgcmV0dXJuIEltcG9ydGFuY2VTYW1wbGVHR1goWGksIE4sIHJvdWdobmVzcyk7XG4gIH1cblxuICBmbiBoYW1tZXJzbGV5KCBpIDogdTMyICwgIE4gOiB1MzIgKSAtPiB2ZWMyPGYzMj5cbiAge1xuICAgIC8vIFJhZGljYWwgaW52ZXJzZSBiYXNlZCBvbiBodHRwOi8vaG9sZ2VyLmRhbW1lcnR6Lm9yZy9zdHVmZi9ub3Rlc19IYW1tZXJzbGV5T25IZW1pc3BoZXJlLmh0bWxcbiAgICB2YXIgYml0cyA9IChpIDw8IDE2dSkgfCAoaSA+PiAxNnUpO1xuICAgIGJpdHMgPSAoKGJpdHMgJiAweDU1NTU1NTU1dSkgPDwgMXUpIHwgKChiaXRzICYgMHhBQUFBQUFBQXUpID4+IDF1KTtcbiAgICBiaXRzID0gKChiaXRzICYgMHgzMzMzMzMzM3UpIDw8IDJ1KSB8ICgoYml0cyAmIDB4Q0NDQ0NDQ0N1KSA+PiAydSk7XG4gICAgYml0cyA9ICgoYml0cyAmIDB4MEYwRjBGMEZ1KSA8PCA0dSkgfCAoKGJpdHMgJiAweEYwRjBGMEYwdSkgPj4gNHUpO1xuICAgIGJpdHMgPSAoKGJpdHMgJiAweDAwRkYwMEZGdSkgPDwgOHUpIHwgKChiaXRzICYgMHhGRjAwRkYwMHUpID4+IDh1KTtcbiAgICB2YXIgcmRpID0gZjMyKGJpdHMpICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDtcbiAgICByZXR1cm4gdmVjMjxmMzI+KGYzMihpKSAvZjMyKE4pLCByZGkpO1xuICB9XG5cbiAgZm4gSW1wb3J0YW5jZVNhbXBsZUdHWCggWGk6dmVjMjxmMzI+LCBOOnZlYzM8ZjMyPiwgcm91Z2huZXNzOmYzMikgLT52ZWMzPGYzMj5cbiAge1xuICAgIHZhciBhID0gcm91Z2huZXNzKnJvdWdobmVzcztcblxuICAgIHZhciBwaGkgPSAyLjAgKiBQSSAqIFhpLng7XG4gICAgdmFyIGNvc1RoZXRhID0gc3FydCgoMS4wIC0gWGkueSkgLyAoMS4wICsgKGEqYSAtIDEuMCkgKiBYaS55KSk7XG4gICAgdmFyIHNpblRoZXRhID0gc3FydCgxLjAgLSBjb3NUaGV0YSpjb3NUaGV0YSk7XG5cbiAgICAvLyBmcm9tIHNwaGVyaWNhbCBjb29yZGluYXRlcyB0byBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXNcbiAgICB2YXIgSDp2ZWMzPGYzMj47XG4gICAgSC54ID0gY29zKHBoaSkgKiBzaW5UaGV0YTtcbiAgICBILnkgPSBzaW4ocGhpKSAqIHNpblRoZXRhO1xuICAgIEgueiA9IGNvc1RoZXRhO1xuXG4gICAgLy8gZnJvbSB0YW5nZW50LXNwYWNlIHZlY3RvciB0byB3b3JsZC1zcGFjZSBzYW1wbGUgdmVjdG9yXG4gIHZhciB1cDp2ZWMzPGYzMj47XG4gICAgaWYoYWJzKE4ueikgPCAwLjk5OSlcbiAgICB7XG4gICAgICAgIHVwID0gdmVjMzxmMzI+KDAuMCwgMC4wLCAxLjApO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB1cCA9IHZlYzM8ZjMyPigxLjAsIDAuMCwgMC4wKTtcbiAgICB9XG4gIHZhciB0YW5nZW50OnZlYzM8ZjMyPiAgPSBub3JtYWxpemUoY3Jvc3ModXAsIE4pKTtcbiAgdmFyIGJpdGFuZ2VudDp2ZWMzPGYzMj4gPSBjcm9zcyhOLCB0YW5nZW50KTtcbiAgdmFyIHNhbXBsZVZlYzp2ZWMzPGYzMj4gPSB0YW5nZW50ICogSC54ICsgYml0YW5nZW50ICogSC55ICsgTiAqIEguejtcbiAgcmV0dXJuIG5vcm1hbGl6ZShzYW1wbGVWZWMpO1xuICB9XG5cbiAgdmFyPHByaXZhdGU+IHJhbmRfc2VlZCA6dmVjMjxmMzI+ID0gdmVjMjxmMzI+KDAuMCk7XG4gIGZuIHJhbmQoKSAtPiBmMzIge1xuICAgIHJhbmRfc2VlZC54ID0gZnJhY3QoY29zKGRvdChyYW5kX3NlZWQsIHZlYzI8ZjMyPigyMy4xNDA3NzkyNiwgMjMyLjYxNjkwMjI1KSkpICogMTM2LjgxNjgpO1xuICAgIHJhbmRfc2VlZC55ID0gZnJhY3QoY29zKGRvdChyYW5kX3NlZWQsIHZlYzI8ZjMyPig1NC40Nzg1NjU1MywgMzQ1Ljg0MTUzMTM2KSkpICogNTM0Ljc2NDUpO1xuICAgIHJldHVybiByYW5kX3NlZWQueTtcbiAgfVxuXG4gIGZuIGdldFNreUNvbG9yKCkgLT4gdmVjMzxmMzI+e1xuICAgIGxldCBjYWxjUm91Z2huZXNzID0gY2xhbXAocm91Z2huZXNzLCAwLjAsIDEuMCk7XG4gICAgbGV0IE1BWF9SRUZMRUNUSU9OX0xPRCAgPSBmMzIodGV4dHVyZU51bUxldmVscyhwcmVmaWx0ZXJNYXApKSA7XG4gICAgdmFyIHByZWZpbHRlckNvbG9yID0gdGV4dHVyZVNhbXBsZUxldmVsKHByZWZpbHRlck1hcCwgcHJlZmlsdGVyTWFwU2FtcGxlciwgcmVmbGVjdGlvbkRpciwgY2FsY1JvdWdobmVzcyAqIE1BWF9SRUZMRUNUSU9OX0xPRCk7XG4gICAgcmV0dXJuIExpbmVhclRvR2FtbWFTcGFjZSh2ZWMzPGYzMj4ocHJlZmlsdGVyQ29sb3IueHl6KSkgKiBzdGFuZFVuaWZvcm0uc2t5RXhwb3N1cmU7XG4gIH1cblxuICBmbiBMaW5lYXJUb0dhbW1hU3BhY2UobGluUkdCOiB2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPiB7XG4gICAgICB2YXIgbGluUkdCMSA9IG1heChsaW5SR0IsIHZlYzM8ZjMyPigwLjApKTtcbiAgICAgIGxpblJHQjEgPSBwb3cobGluUkdCMSwgdmVjMzxmMzI+KDAuNDE2NjY2NjU2NzMyNTU5MikpO1xuICAgICAgcmV0dXJuIG1heCgoKDEuMDU0OTk5OTQ3NTQ3OTEyNiAqIGxpblJHQjEpIC0gdmVjMzxmMzI+KDAuMDU0OTk5OTk5NzAxOTc2Nzc2KSksIHZlYzM8ZjMyPigwLjApKTtcbiAgfVxuXG4gIGZuIGNvbnZlcnRDb2xvckNvb3JkRnJvbVNTUkNvb3JkKGNvb3JkOnZlYzI8aTMyPikgLT4gdmVjMjxpMzI+e1xuICAgIGxldCBjb2xvcl9zc3JfcmF0aW8gPSBzc3JVbmlmb3JtLmNvbG9yTWFwU2l6ZVggLyBzc3JVbmlmb3JtLnNzckJ1ZmZlclNpemVYO1xuICAgIGxldCB0YXJnZXRDb29yZCA9IHZlYzI8ZjMyPihjb29yZCkgKiBjb2xvcl9zc3JfcmF0aW87XG4gICAgcmV0dXJuIHZlYzI8aTMyPih0YXJnZXRDb29yZCk7XG4gIH1cblxuICBmbiBoaWRpbmdBcnRpZmFjdCgpe1xuICAgIGxldCB0ZXhTaXplRjMyID0gdmVjMjxmMzI+KGYzMihjb2xvclRleFNpemUueCksIGYzMihjb2xvclRleFNpemUueSkpO1xuICAgIGxldCBoYWxmVGV4U2l6ZUYzMiA9IHRleFNpemVGMzIgKiAwLjU7XG5cbiAgICAvL25lYXIgc2NyZWVuIGVkZ2VcbiAgICB2YXIgZGlzdGFuY2UyQ2VudGVyID0gYWJzKHZlYzI8ZjMyPihmMzIoaGl0RGF0YS5oaXRDb29yZC54KSwgZjMyKGhpdERhdGEuaGl0Q29vcmQueSkpIC0gaGFsZlRleFNpemVGMzIpO1xuICAgIGxldCBoYWxmRWRnZVNpemU6ZjMyID0gbWluKHRleFNpemVGMzIueCwgdGV4U2l6ZUYzMi55KSAqIGNsYW1wKDAuMDEsIHNzclVuaWZvcm0uZmFkZUVkZ2VSYXRpbywgMS4wKSAqIDAuNTtcbiAgICB2YXIgZGlzdGFuY2UyRWRnZSA9IG1pbih2ZWMyPGYzMj4oaGFsZkVkZ2VTaXplKSwgaGFsZlRleFNpemVGMzIgLSBkaXN0YW5jZTJDZW50ZXIpO1xuICAgIHZhciByYXRpb1hZID0gZGlzdGFuY2UyRWRnZSAvIGhhbGZFZGdlU2l6ZTtcbiAgICBoaXREYXRhLmZhZGVBbHBoYS54ID0gc3FydChyYXRpb1hZLnggKiByYXRpb1hZLnkpO1xuXG4gICAgLy9iYWNrIGZhY2UgaGl0XG4gICAgdmFyIGJhY2tGYWNlQmlhcyA9IG1heCgwLjAsIGRvdChoaXREYXRhLmhpdE5vcm1hbCwgLXJlZmxlY3Rpb25EaXIpKTtcbiAgICBoaXREYXRhLmZhZGVBbHBoYS55ID0gcG93KGJhY2tGYWNlQmlhcywgbWF4KDAuMDAwMSwgc3NyVW5pZm9ybS5wb3dEb3RSTikpO1xuXG4gICAgLy9zY3JlZW4gZGlzdGFuY2UgcmF0aW9cbiAgICBsZXQgbWF4TGVuZ3RoID0gbWF4KGYzMihjb2xvclRleFNpemUueCksIGYzMihjb2xvclRleFNpemUueSkpICogc3NyVW5pZm9ybS5yYXlNYXJjaFJhdGlvO1xuICAgIGxldCBzY3JlZW5Qb2ludGVyID0gaGl0RGF0YS5oaXRDb29yZCAtIGZyYWdDb29yZENvbG9yO1xuICAgIHZhciBzY3JlZW5EaXN0YW5jZSA9IGxlbmd0aCh2ZWMyPGYzMj4oZjMyKHNjcmVlblBvaW50ZXIueCksIGYzMihzY3JlZW5Qb2ludGVyLnkpKSk7XG4gICAgc2NyZWVuRGlzdGFuY2UgPSBjbGFtcChzY3JlZW5EaXN0YW5jZSAvIG1heExlbmd0aCwgMC4wLCAxLjApO1xuICAgIGhpdERhdGEuZmFkZUFscGhhLnogPSAxLjAgLSBzY3JlZW5EaXN0YW5jZTtcblxuICAgIC8vcG9zaXRpb24gZGlzdGFuY2UgcmF0aW9cbiAgICB2YXIgZmFkZURpc3RhbmNlID0gbGVuZ3RoKHZlYzM8ZjMyPihoaXREYXRhLmhpdFBvcyAtIGNhbWVyYVBvc2l0aW9uKSk7XG4gICAgdmFyIGRGYXIgPSBzc3JVbmlmb3JtLmZhZGVEaXN0YW5jZU1heDtcbiAgICB2YXIgZE5lYXIgPSBzc3JVbmlmb3JtLmZhZGVEaXN0YW5jZU1pbjtcbiAgICBkRmFyID0gbWF4KDEuMCwgZEZhcik7XG4gICAgZE5lYXIgPSBjbGFtcChkTmVhciwgMC4wMDEsIGRGYXIgLSAwLjAwMSk7XG4gICAgZmFkZURpc3RhbmNlID0gY2xhbXAoZmFkZURpc3RhbmNlLCBkTmVhciwgZEZhcik7XG4gICAgZmFkZURpc3RhbmNlID0gKGZhZGVEaXN0YW5jZSAtIGROZWFyKSAvIChkRmFyIC0gZE5lYXIpO1xuICAgIGhpdERhdGEuZmFkZUFscGhhLncgPSAxLjAgLSBmYWRlRGlzdGFuY2U7XG4gIH1cblxuICBmbiByYXlUcmFjZShyYXlNYXJjaERpcjp2ZWMyPGYzMj4pe1xuICAgIGxldCBzdGVwTGVuZ3RoID0gNC4wO1xuICAgIGxldCBtYXhMZW5ndGggPSBtYXgoZjMyKGNvbG9yVGV4U2l6ZS54KSwgZjMyKGNvbG9yVGV4U2l6ZS55KSkgKiBzc3JVbmlmb3JtLnJheU1hcmNoUmF0aW87XG4gICAgZm9yKHZhciBpOmYzMiA9IDEuMDsgaSA8IG1heExlbmd0aDsgaSA9IGkgKyBzdGVwTGVuZ3RoKXtcbiAgICAgICAgbGV0IG9mZnNldEZsb2F0MzIgPSBpICogcmF5TWFyY2hEaXI7XG4gICAgICAgIHZhciB1diA9IGZyYWdDb29yZENvbG9yICsgdmVjMjxpMzI+KGkzMihvZmZzZXRGbG9hdDMyLngpLCBpMzIob2Zmc2V0RmxvYXQzMi55KSk7XG4gICAgICAgIGxldCBoaXRSZXQgPSByYXlJbnRlcmVzdFNjZW5lKHV2KTtcbiAgICAgICAgaWYoaGl0UmV0ID4gMCl7XG4gICAgICAgICAgaGl0RGF0YS5oaXRSZXN1bHQgPSBoaXRSZXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoaGl0RGF0YS5oaXRSZXN1bHQgPT0gMSl7XG4gICAgICAgIGxldCBmcm9tVVYgPSBoaXREYXRhLmhpdENvb3JkO1xuICAgICAgICBmb3IodmFyIGk6ZjMyID0gLXN0ZXBMZW5ndGg7IGkgPD0gMC4wOyBpID0gaSArIDEuMCl7XG4gICAgICAgICAgbGV0IG9mZnNldEZsb2F0MzIgPSBpICogcmF5TWFyY2hEaXI7XG4gICAgICAgICAgdmFyIHV2ID0gZnJvbVVWICsgdmVjMjxpMzI+KGkzMihvZmZzZXRGbG9hdDMyLngpLCBpMzIob2Zmc2V0RmxvYXQzMi55KSk7XG4gICAgICAgICAgbGV0IGhpdFJldCA9IHJheUludGVyZXN0U2NlbmUodXYpO1xuICAgICAgICAgIGlmKGhpdFJldCA9PSAxKXtcbiAgICAgICAgICAgIGxldCBXTiA9IHRleHR1cmVMb2FkKG5vcm1hbEJ1ZmZlclRleCwgaGl0RGF0YS5oaXRDb29yZCAsIDAgKTtcbiAgICAgICAgICAgIGlmKFdOLncgPiAwLjUpe1xuICAgICAgICAgICAgICAgIGhpdERhdGEuaGl0U2t5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBub3JtYWwgPSB2ZWMzPGYzMj4oV04ueHl6KSAqIDIuMCAtIDEuMDtcbiAgICAgICAgICAgIGhpdERhdGEuaGl0Tm9ybWFsID0gbm9ybWFsaXplKHZlYzM8ZjMyPihub3JtYWwueHl6KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbiByYXlJbnRlcmVzdFNjZW5lKHV2OnZlYzI8aTMyPikgLT4gaTMyIHtcbiAgICBpZih1di54IDwgMCB8fCB1di55IDwgMCB8fCB1di54ID49IGNvbG9yVGV4U2l6ZS54IHx8IHV2LnkgPj0gY29sb3JUZXhTaXplLnkpe1xuICAgICAgcmV0dXJuIDI7XG4gICAgfWVsc2V7XG4gICAgICBsZXQgaGl0UG9zID0gdGV4dHVyZUxvYWQoekJ1ZmZlclRleHR1cmUsIHV2ICwgMCApO1xuICAgICAgbGV0IHRlc3REaXIgPSBub3JtYWxpemUodmVjMzxmMzI+KGhpdFBvcy54eXogLSByYXlPcmlnaW4pKTtcbiAgICAgIGxldCBjb3NWYWx1ZSA9IGRvdChyZWZsZWN0aW9uRGlyLCB0ZXN0RGlyKTtcblxuICAgICAgaWYoY29zVmFsdWUgPiAwLjk5OTYpe1xuICAgICAgICBsZXQgY3Jvc3MxID0gY3Jvc3MocmVmbGVjdGlvbkRpciwgLXJheURpcmVjdGlvbik7XG4gICAgICAgIGxldCBjcm9zczIgPSBjcm9zcyhyZWZsZWN0aW9uRGlyLCB0ZXN0RGlyKTtcbiAgICAgICAgaWYoZG90KGNyb3NzMSwgY3Jvc3MyKSA+IDAuMCl7XG4gICAgICAgICAgaGl0RGF0YS5oaXRQb3MgPSB2ZWMzPGYzMj4oaGl0UG9zLnh5eik7XG4gICAgICAgICAgaGl0RGF0YS5oaXRDb29yZCA9IHV2O1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5gLG5jPWBcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHByZUNvbG9yIDogYXJyYXk8dmVjNDxmMzI+PjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHByZUNvbG9yVGV4IDogdGV4dHVyZV9zdG9yYWdlXzJkPHJnYmExNmZsb2F0LCB3cml0ZT47XG5cbiAgICB2YXI8cHJpdmF0ZT4gdGV4U2l6ZTogdmVjMjx1MzI+O1xuICAgIHZhcjxwcml2YXRlPiBmcmFnQ29vcmQ6IHZlYzI8aTMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gY29vcmRJbmRleDogaTMyO1xuICAgIFxuICAgIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSggOCAsIDggLCAxIClcbiAgICBmbiBDc01haW4oIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+ICwgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbEludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4pXG4gICAge1xuICAgICAgZnJhZ0Nvb3JkID0gdmVjMjxpMzI+KCBnbG9iYWxJbnZvY2F0aW9uX2lkLnh5ICk7XG4gICAgICB0ZXhTaXplID0gdGV4dHVyZURpbWVuc2lvbnMocHJlQ29sb3JUZXgpLnh5O1xuICAgICAgaWYoZnJhZ0Nvb3JkLnggPj0gaTMyKHRleFNpemUueCkgfHwgZnJhZ0Nvb3JkLnkgPj0gaTMyKHRleFNpemUueSkpe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvb3JkSW5kZXggPSBmcmFnQ29vcmQueCArIGZyYWdDb29yZC55ICogaTMyKHRleFNpemUueCk7XG4gICAgICB0ZXh0dXJlU3RvcmUocHJlQ29sb3JUZXgsIGZyYWdDb29yZCAsIHByZUNvbG9yW2Nvb3JkSW5kZXhdKTtcbiAgICB9XG4gYCxsYz1gXG4gICAgc3RydWN0IFRBQURhdGF7XG4gICAgICBwcmVQcm9qTWF0cml4OiBtYXQ0eDQ8ZjMyPixcbiAgICAgIHByZVZpZXdNYXRyaXg6IG1hdDR4NDxmMzI+LFxuICAgICAgaml0dGVyRnJhbWVJbmRleDogZjMyLFxuICAgICAgYmxlbmRGYWN0b3I6IGYzMixcbiAgICAgIHNoYXJwRmFjdG9yOiBmMzIsXG4gICAgICBzaGFycFByZUJsdXJGYWN0b3I6IGYzMixcbiAgICAgIGppdHRlclg6IGYzMixcbiAgICAgIGppdHRlclk6IGYzMixcbiAgICAgIHNsb3QwOiBmMzIsXG4gICAgICBzbG90MTogZjMyLFxuICAgIH1cbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHRhYURhdGE6IFRBQURhdGE7XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBpblRleCA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIG91dFRleCA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuXG4gICAgdmFyPHByaXZhdGU+IHRleFNpemU6IHZlYzI8dTMyPjtcbiAgICB2YXI8cHJpdmF0ZT4gZnJhZ0Nvb3JkOiB2ZWMyPGkzMj47XG5cbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoIDggLCA4ICwgMSApXG4gICAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICAgIHtcbiAgICAgIGZyYWdDb29yZCA9IHZlYzI8aTMyPiggZ2xvYmFsSW52b2NhdGlvbl9pZC54eSApO1xuICAgICAgdGV4U2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKG91dFRleCkueHk7XG4gICAgICBpZihmcmFnQ29vcmQueCA+PSBpMzIodGV4U2l6ZS54KSB8fCBmcmFnQ29vcmQueSA+PSBpMzIodGV4U2l6ZS55KSl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgYzAgPSB0ZXh0dXJlTG9hZChpblRleCwgdmVjMjxpMzI+KGZyYWdDb29yZC54LCBmcmFnQ29vcmQueSAtIDEpLCAwKTtcbiAgICAgIGxldCBjMSA9IHRleHR1cmVMb2FkKGluVGV4LCB2ZWMyPGkzMj4oZnJhZ0Nvb3JkLngsIGZyYWdDb29yZC55ICsgMSksIDApO1xuICAgICAgbGV0IGMyID0gdGV4dHVyZUxvYWQoaW5UZXgsIHZlYzI8aTMyPihmcmFnQ29vcmQueCAtIDEsIGZyYWdDb29yZC55KSwgMCk7XG4gICAgICBsZXQgYzMgPSB0ZXh0dXJlTG9hZChpblRleCwgdmVjMjxpMzI+KGZyYWdDb29yZC54ICsgMSwgZnJhZ0Nvb3JkLnkpLCAwKTtcbiAgICAgIFxuICAgICAgdmFyIHJvdW5kQ29sb3IgPSAoYzAgKyBjMSArIGMyICsgYzMpICogMC4yNTtcbiAgICAgIGxldCBvcmlnaW5Db2xvciA9IHRleHR1cmVMb2FkKGluVGV4LCBmcmFnQ29vcmQsIDApO1xuICAgICAgbGV0IGJsdXJDb2xvciA9IG1peChyb3VuZENvbG9yLCBvcmlnaW5Db2xvciwgdGFhRGF0YS5zaGFycFByZUJsdXJGYWN0b3IpO1xuICAgICAgdmFyIG9jID0gKG9yaWdpbkNvbG9yIC0gYmx1ckNvbG9yICogdGFhRGF0YS5zaGFycEZhY3RvcikgLyAoMS4wIC0gdGFhRGF0YS5zaGFycEZhY3Rvcik7XG4gICAgICBvYyA9IGNsYW1wKG9jLCB2ZWM0PGYzMj4oMC4wKSwgb2MpO1xuICAgICAgdGV4dHVyZVN0b3JlKG91dFRleCwgZnJhZ0Nvb3JkICwgb2MpO1xuICAgIH1cbmAsaGM9YFxuI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcblxuc3RydWN0IFRBQURhdGF7XG4gIHByZVByb2pNYXRyaXg6IG1hdDR4NDxmMzI+LFxuICBwcmVWaWV3TWF0cml4OiBtYXQ0eDQ8ZjMyPixcbiAgaml0dGVyRnJhbWVJbmRleDogZjMyLFxuICBibGVuZEZhY3RvcjogZjMyLFxuICBzaGFycEZhY3RvcjogZjMyLFxuICBzaGFycFByZUJsdXJGYWN0b3I6IGYzMixcbiAgaml0dGVyWDogZjMyLFxuICBqaXR0ZXJZOiBmMzIsXG4gIHNsb3QwOiBmMzIsXG4gIHNsb3QxOiBmMzIsXG59XG5cbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gc3RhbmRVbmlmb3JtOiBHbG9iYWxVbmlmb3JtO1xuQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjx1bmlmb3JtPiB0YWFEYXRhOiBUQUFEYXRhO1xuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBwcmVDb2xvckJ1ZmZlciA6IGFycmF5PHZlYzQ8ZjMyPj47XG5cbkBncm91cCgwKSBAYmluZGluZygzKSB2YXIgcHJlQ29sb3JUZXhTYW1wbGVyIDogc2FtcGxlcjtcbkBncm91cCgwKSBAYmluZGluZyg0KSB2YXIgcHJlQ29sb3JUZXggOiB0ZXh0dXJlXzJkPGYzMj47XG5AZ3JvdXAoMCkgQGJpbmRpbmcoNSkgdmFyIHBvc1RleCA6IHRleHR1cmVfMmQ8ZjMyPjtcbkBncm91cCgwKSBAYmluZGluZyg2KSB2YXIgaW5UZXhTYW1wbGVyIDogc2FtcGxlcjtcbkBncm91cCgwKSBAYmluZGluZyg3KSB2YXIgaW5UZXggOiB0ZXh0dXJlXzJkPGYzMj47XG5AZ3JvdXAoMCkgQGJpbmRpbmcoOCkgdmFyIG91dFRleCA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuXG52YXI8cHJpdmF0ZT4gdGV4U2l6ZTogdmVjMjx1MzI+O1xudmFyPHByaXZhdGU+IGZyYWdDb29yZDogdmVjMjxpMzI+O1xudmFyPHByaXZhdGU+IGNvb3JkSW5kZXg6IGkzMjtcbnZhcjxwcml2YXRlPiBjb2xvcl9taW46IHZlYzQ8ZjMyPjtcbnZhcjxwcml2YXRlPiBjb2xvcl9tYXg6IHZlYzQ8ZjMyPjtcbnZhcjxwcml2YXRlPiBjb2xvcl9hdmc6IHZlYzQ8ZjMyPjtcbnZhcjxwcml2YXRlPiByZV9wcm9qX3V2MDE6IHZlYzI8ZjMyPjtcbnZhcjxwcml2YXRlPiBGTFRfRVBTOmYzMiA9IDUuOTYwNDY0NDc4ZS04OyAgLy8gMl4tMjQsIG1hY2hpbmUgZXBzaWxvbjogMSArIEVQUyA9IDEgKGhhbGYgb2YgdGhlIFVMUCBmb3IgMS4wZilcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCA4ICwgOCAsIDEgKVxuZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxue1xuICBmcmFnQ29vcmQgPSB2ZWMyPGkzMj4oIGdsb2JhbEludm9jYXRpb25faWQueHkgKTtcbiAgdGV4U2l6ZSA9IHRleHR1cmVEaW1lbnNpb25zKGluVGV4KS54eTtcbiAgaWYoZnJhZ0Nvb3JkLnggPj0gaTMyKHRleFNpemUueCkgfHwgZnJhZ0Nvb3JkLnkgPj0gaTMyKHRleFNpemUueSkpe1xuICAgICAgcmV0dXJuO1xuICB9XG4gIGxldCBmcmFtZSA9IHN0YW5kVW5pZm9ybS5mcmFtZTtcbiAgY29vcmRJbmRleCA9IGZyYWdDb29yZC54ICsgZnJhZ0Nvb3JkLnkgKiBpMzIodGV4U2l6ZS54KTtcbiAgXG4gIGxldCBvYyA9IGJsZW5kQ29sb3IoKTtcbiAgcHJlQ29sb3JCdWZmZXJbY29vcmRJbmRleF0gPSBvYztcbiAgdGV4dHVyZVN0b3JlKG91dFRleCwgZnJhZ0Nvb3JkICwgb2MpO1xufVxuXG5mbiBibGVuZENvbG9yKCkgLT4gdmVjNDxmMzI+XG57XG4gIHZhciBwcmVDb29yZCA9IGZyYWdDb29yZDtcbiAgdmFyIG1peFdlaWdodCA9IDEuMDtcbiAgcmVfcHJval91djAxID0gdmVjMjxmMzI+KDAuMCk7XG4gIHZhciByZVByb2plY3Rpb25Db29yZDp2ZWMyPGYzMj4gPSB2ZWMyPGYzMj4oZnJhZ0Nvb3JkKTtcbiAgLy92YXIgaml0dGVyVVZPZmZzZXQgPSAwLjUgKiB2ZWMyPGYzMj4odGFhRGF0YS5qaXR0ZXJYLCAtdGFhRGF0YS5qaXR0ZXJZKTtcbiAgaWYodGFhRGF0YS5qaXR0ZXJGcmFtZUluZGV4ID4gMC41KXtcbiAgICAgIHZhciB3UG9zID0gdGV4dHVyZUxvYWQocG9zVGV4LCBmcmFnQ29vcmQsIDApO1xuICAgICAgbGV0IG5kYyA9IHRhYURhdGEucHJlUHJvak1hdHJpeCAqICh0YWFEYXRhLnByZVZpZXdNYXRyaXggKiB2ZWM0PGYzMj4od1Bvcy54eXosIDEuMCkpO1xuICAgICAgcmVfcHJval91djAxID0gdmVjMjxmMzI+KG5kYy54LCAtbmRjLnkpIC8gbmRjLnc7XG4gICAgICByZV9wcm9qX3V2MDEgPSAocmVfcHJval91djAxICsgMS4wKSAqIDAuNTtcbiAgICAgIFxuICAgICAgaWYocmVfcHJval91djAxLnggPj0gMC4wICYmIHJlX3Byb2pfdXYwMS54IDw9IDEuMCAmJiByZV9wcm9qX3V2MDEueSA+PSAwLjAgJiYgcmVfcHJval91djAxLnkgPD0gMS4wKXtcbiAgICAgICAgICBtaXhXZWlnaHQgPSB0YWFEYXRhLmJsZW5kRmFjdG9yO1xuICAgICAgICAgIC8vcmVQcm9qZWN0aW9uQ29vcmQgPSByZV9wcm9qX3V2MDEgKyBqaXR0ZXJVVk9mZnNldDtcbiAgICAgICAgICByZVByb2plY3Rpb25Db29yZC54ID0gcmVfcHJval91djAxLnggKiBmMzIodGV4U2l6ZS54IC0gMSk7XG4gICAgICAgICAgcmVQcm9qZWN0aW9uQ29vcmQueSA9IHJlX3Byb2pfdXYwMS55ICogZjMyKHRleFNpemUueSAtIDEpO1xuICAgICAgICAgIHByZUNvb3JkID0gdmVjMjxpMzI+KHJlUHJvamVjdGlvbkNvb3JkKTtcbiAgICAgIH1lbHNleyBcbiAgICAgICAgICAvL291dHNpZGUgb2Ygc2NyZWVuXG4gICAgICAgICAgbWl4V2VpZ2h0ID0gMS4wO1xuICAgICAgfVxuICB9XG4gIFxuICB2YXIgY3VyVVYwMSA9IHZlYzI8ZjMyPihmcmFnQ29vcmQpIC8gdmVjMjxmMzI+KHRleFNpemUgLSAxKTtcbiAgLy9jdXJVVjAxICs9IGppdHRlclVWT2Zmc2V0O1xuICBcbiAgbGV0IGN1ckNvbG9yID0gdGV4dHVyZVNhbXBsZUxldmVsKGluVGV4LCBpblRleFNhbXBsZXIsIGN1clVWMDEsIDAuMCk7XG4gIFxuICBsZXQgcHJlSW5kZXggPSBwcmVDb29yZC54ICsgcHJlQ29vcmQueSAqIGkzMih0ZXhTaXplLngpO1xuICB2YXIgcHJlQ29sb3IgPSB0ZXh0dXJlU2FtcGxlTGV2ZWwocHJlQ29sb3JUZXgsIHByZUNvbG9yVGV4U2FtcGxlciwgcmVfcHJval91djAxLCAwLjApO1xuICBcbiAgLy9taW5tYXg5KGZyYWdDb29yZCk7XG4gIG1pbm1heDQoZnJhZ0Nvb3JkKTtcbiAgXG4gIHByZUNvbG9yID0gY2xpcF9hYWJiKGNvbG9yX21pbi54eXosIGNvbG9yX21heC54eXosIGNvbG9yX2F2ZywgcHJlQ29sb3IpO1xuICB2YXIgb3V0Q29sb3IgPSBtaXgocHJlQ29sb3IsIGN1ckNvbG9yLCBtaXhXZWlnaHQpO1xuXG4gIHJldHVybiBvdXRDb2xvcjtcbn1cblxuZm4gY2xhbXBDb29yZChjb29yZDA6dmVjMjxpMzI+KSAtPiB2ZWMyPGkzMj57XG4gIHJldHVybiBjbGFtcChjb29yZDAsIHZlYzI8aTMyPigwKSwgdmVjMjxpMzI+KHRleFNpemUgLSAxKSk7XG59XG5cbmZuIG1pbm1heDQoY29vcmQ6dmVjMjxpMzI+KSB7XG4gICAgICBsZXQgdXYwID0gY2xhbXBDb29yZCh2ZWMyPGkzMj4oY29vcmQueCAtIDEsIGNvb3JkLnkpKTtcbiAgICAgIGxldCB1djEgPSBjbGFtcENvb3JkKHZlYzI8aTMyPihjb29yZC54LCBjb29yZC55IC0gMSkpO1xuICAgICAgbGV0IHV2MiA9IGNsYW1wQ29vcmQodmVjMjxpMzI+KGNvb3JkLngsIGNvb3JkLnkgKyAxKSk7XG4gICAgICBsZXQgdXYzID0gY2xhbXBDb29yZCh2ZWMyPGkzMj4oY29vcmQueCArIDEsIGNvb3JkLnkpKTtcbiAgICAgIFxuICAgICAgbGV0IGMwID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2MCwgMCk7XG4gICAgICBsZXQgYzEgPSB0ZXh0dXJlTG9hZChpblRleCwgdXYxLCAwKTtcbiAgICAgIGxldCBjMiA9IHRleHR1cmVMb2FkKGluVGV4LCB1djIsIDApO1xuICAgICAgbGV0IGMzID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2MywgMCk7XG4gICAgICBcbiAgICAgIGNvbG9yX21pbiA9IG1pbihjMCwgbWluKGMxLCBtaW4oYzIsIGMzKSkpO1xuICAgICAgY29sb3JfbWF4ID0gbWF4KGMwLCBtYXgoYzEsIG1heChjMiwgYzMpKSk7XG4gICAgICBjb2xvcl9hdmcgPSAoYzAgKyBjMSArIGMyICsgYzMpICogMC4yNTtcbiAgfVxuICBcbiBmbiBtaW5tYXg5KGNvb3JkOnZlYzI8aTMyPikge1xuICAgICAgbGV0IHV2MCA9IGNsYW1wQ29vcmQodmVjMjxpMzI+KGNvb3JkLnggLSAxLCBjb29yZC55IC0gMSkpO1xuICAgICAgbGV0IHV2MSA9IGNsYW1wQ29vcmQodmVjMjxpMzI+KGNvb3JkLnggLSAxLCBjb29yZC55KSk7XG4gICAgICBsZXQgdXYyID0gY2xhbXBDb29yZCh2ZWMyPGkzMj4oY29vcmQueCAtIDEsIGNvb3JkLnkgKyAxKSk7XG4gICAgICBsZXQgdXYzID0gY2xhbXBDb29yZCh2ZWMyPGkzMj4oY29vcmQueCwgY29vcmQueSAtIDEpKTtcbiAgICAgIGxldCB1djQgPSBjbGFtcENvb3JkKHZlYzI8aTMyPihjb29yZC54LCBjb29yZC55KSk7XG4gICAgICBsZXQgdXY1ID0gY2xhbXBDb29yZCh2ZWMyPGkzMj4oY29vcmQueCwgY29vcmQueSArIDEpKTtcbiAgICAgIGxldCB1djYgPSBjbGFtcENvb3JkKHZlYzI8aTMyPihjb29yZC54ICsgMSwgY29vcmQueSAtIDEpKTtcbiAgICAgIGxldCB1djcgPSBjbGFtcENvb3JkKHZlYzI8aTMyPihjb29yZC54ICsgMSwgY29vcmQueSkpO1xuICAgICAgbGV0IHV2OCA9IGNsYW1wQ29vcmQodmVjMjxpMzI+KGNvb3JkLnggKyAxLCBjb29yZC55ICsgMSkpO1xuICAgICAgXG4gICAgICBsZXQgY3RsID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2MCwgMCk7XG4gICAgICBsZXQgY3RjID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2MSwgMCk7XG4gICAgICBsZXQgY3RyID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2MiwgMCk7XG4gICAgICBsZXQgY21sID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2MywgMCk7XG4gICAgICBsZXQgY21jID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2NCwgMCk7XG4gICAgICBsZXQgY21yID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2NSwgMCk7XG4gICAgICBsZXQgY2JsID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2NiwgMCk7XG4gICAgICBsZXQgY2JjID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2NywgMCk7XG4gICAgICBsZXQgY2JyID0gdGV4dHVyZUxvYWQoaW5UZXgsIHV2OCwgMCk7XG4gICAgICBcbiAgICAgIGNvbG9yX21pbiA9IG1pbihjdGwsIG1pbihjdGMsIG1pbihjdHIsIG1pbihjbWwsIG1pbihjbWMsIG1pbihjbXIsIG1pbihjYmwsIG1pbihjYmMsIGNicikpKSkpKSkpO1xuICAgICAgY29sb3JfbWF4ID0gbWF4KGN0bCwgbWF4KGN0YywgbWF4KGN0ciwgbWF4KGNtbCwgbWF4KGNtYywgbWF4KGNtciwgbWF4KGNibCwgbWF4KGNiYywgY2JyKSkpKSkpKSk7XG4gICAgICBjb2xvcl9hdmcgPSAoY3RsICsgY3RjICsgY3RyICsgY21sICsgY21jICsgY21yICsgY2JsICsgY2JjICsgY2JyKSAvIDkuMDtcbiAgfVxuICBcbiAgZm4gY2xpcF9hYWJiKGFhYmJfbWF4OnZlYzM8ZjMyPiwgYWFiYl9taW46dmVjMzxmMzI+LCBjb2xvcl9hdmc6dmVjNDxmMzI+LCBpbnB1dF90ZXhlbDp2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPlxuICB7XG4gICAgICB2YXIgcF9jbGlwOnZlYzM8ZjMyPiA9IDAuNSAqIChhYWJiX21heCArIGFhYmJfbWluKTtcbiAgICAgIHZhciBlX2NsaXA6dmVjMzxmMzI+ID0gMC41ICogKGFhYmJfbWF4IC0gYWFiYl9taW4pICsgRkxUX0VQUztcbiAgICAgIHZhciB2X2NsaXA6dmVjNDxmMzI+ID0gaW5wdXRfdGV4ZWwgLSB2ZWM0PGYzMj4ocF9jbGlwLCBjb2xvcl9hdmcudyk7XG4gICAgICB2YXIgdl91bml0OnZlYzM8ZjMyPiA9IHZfY2xpcC54eXogLyBlX2NsaXA7XG4gICAgICB2YXIgYV91bml0OnZlYzM8ZjMyPiA9IGFicyh2X3VuaXQpO1xuICAgICAgdmFyIG1hX3VuaXQ6ZjMyID0gbWF4KGFfdW5pdC54LCBtYXgoYV91bml0LnksIGFfdW5pdC56KSk7XG5cbiAgICAgIGlmIChtYV91bml0ID4gMS4wKXtcbiAgICAgICAgICByZXR1cm4gdmVjNDxmMzI+KHBfY2xpcCwgY29sb3JfYXZnLncpICsgdl9jbGlwIC8gbWFfdW5pdDtcbiAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiBpbnB1dF90ZXhlbDtcbiAgICAgIH1cbiAgfWAsdWM9YFxuI2luY2x1ZGUgXCJXb3JsZE1hdHJpeFVuaWZvcm1cIlxuI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcblxuc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+LFxuICAgIEBidWlsdGluKHBvc2l0aW9uKSBtZW1iZXI6IHZlYzQ8ZjMyPlxufTtcblxuI2lmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAke0xlLmdldE1vcnBoVGFyZ2V0U2hhZGVyQmluZGluZygyLDEpfVxuI2VuZGlmXG5cbiNpZiBVU0VfU0tFTEVUT05cbiAgICAke09yLmdyb3VwQmluZGluZ0FuZEZ1bmN0aW9ucygyLDEpfSBcbiNlbmRpZlxuXG52YXI8cHJpdmF0ZT4gd29ybGRNYXRyaXg6IG1hdDR4NDxmMzI+O1xuXG5zdHJ1Y3QgVmVydGV4QXR0cmlidXRlc3tcbiAgQGJ1aWx0aW4oaW5zdGFuY2VfaW5kZXgpIGluZGV4IDogdTMyLFxuICBAbG9jYXRpb24oMCkgcG9zaXRpb246IHZlYzM8ZjMyPixcbiAgQGxvY2F0aW9uKDEpIG5vcm1hbDogdmVjMzxmMzI+LFxuICBAbG9jYXRpb24oMikgdXY6IHZlYzI8ZjMyPixcbiAgQGxvY2F0aW9uKDMpIFRFWENPT1JEXzE6IHZlYzI8ZjMyPixcblxuICAjaWYgVVNFX1RBTkdFTlRcbiAgICAgIEBsb2NhdGlvbig0KSBUQU5HRU5UOiB2ZWM0PGYzMj4sXG4gICAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgICAgQGxvY2F0aW9uKDUpIGpvaW50czA6IHZlYzQ8ZjMyPixcbiAgICAgICAgICBAbG9jYXRpb24oNikgd2VpZ2h0czA6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAjaWYgVVNFX0pPSU5UX1ZFQzhcbiAgICAgICAgICBAbG9jYXRpb24oNykgam9pbnRzMTogdmVjNDxmMzI+LFxuICAgICAgICAgIEBsb2NhdGlvbig4KSB3ZWlnaHRzMTogdmVjNDxmMzI+LFxuICAgICAgI2VuZGlmXG4gICAgICAjZWxzZWlmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAgICAgICAke0xlLmdldE1vcnBoVGFyZ2V0QXR0cig1KX1cbiAgICAgICNlbmRpZlxuICAjZWxzZWlmIFVTRV9TS0VMRVRPTlxuICAgICAgQGxvY2F0aW9uKDQpIGpvaW50czA6IHZlYzQ8ZjMyPixcbiAgICAgIEBsb2NhdGlvbig1KSB3ZWlnaHRzMDogdmVjNDxmMzI+LFxuICAgICAgI2lmIFVTRV9KT0lOVF9WRUM4XG4gICAgICBAbG9jYXRpb24oNikgam9pbnRzMTogdmVjNDxmMzI+LFxuICAgICAgQGxvY2F0aW9uKDcpIHdlaWdodHMxOiB2ZWM0PGYzMj4sXG4gICAgICAjZW5kaWZcbiAgI2Vsc2VpZiBVU0VfTU9SUEhUQVJHRVRTXG4gICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRBdHRyKDQpfVxuICAjZW5kaWZcbn1cblxuXG5cbkB2ZXJ0ZXhcbmZuIG1haW4odmVydGV4OlZlcnRleEF0dHJpYnV0ZXMpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgd29ybGRNYXRyaXggPSBtb2RlbHMubWF0cml4W3ZlcnRleC5pbmRleF07XG4gICAgbGV0IHNoYWRvd01hdHJpeDogbWF0NHg0PGYzMj4gPSBnbG9iYWxVbmlmb3JtLnByb2pNYXQgKiBnbG9iYWxVbmlmb3JtLnZpZXdNYXQgO1xuICAgIHZhciB2ZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleC5wb3NpdGlvbi54eXo7XG4gICAgdmFyIHZlcnRleE5vcm1hbCA9IHZlcnRleC5ub3JtYWwueHl6O1xuXG4gICAgI2lmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAgJHtMZS5nZXRNb3JwaFRhcmdldENhbGNWZXJ0ZXgoKX0gICAgXG4gICAgI2VuZGlmXG5cbiAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgICNpZiBVU0VfSk9JTlRfVkVDOFxuICAgICAgICAgIHdvcmxkTWF0cml4ICo9IGdldFNrZWxldG9uV29ybGRNYXRyaXhfOCh2ZXJ0ZXguam9pbnRzMCwgdmVydGV4LndlaWdodHMwLCB2ZXJ0ZXguam9pbnRzMSwgdmVydGV4LndlaWdodHMxKTtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICB3b3JsZE1hdHJpeCAqPSBnZXRTa2VsZXRvbldvcmxkTWF0cml4XzQodmVydGV4LmpvaW50czAsIHZlcnRleC53ZWlnaHRzMCk7XG4gICAgICAgICNlbmRpZlxuICAgICNlbmRpZlxuXG4gICAgdmFyIHdvcmxkUG9zID0gd29ybGRNYXRyaXggKiB2ZWM0PGYzMj4odmVydGV4UG9zaXRpb24sIDEuMCkgO1xuICAgIHZhciB2UG9zID0gc2hhZG93TWF0cml4ICogd29ybGRQb3M7XG5cbiAgICByZXR1cm4gVmVydGV4T3V0cHV0KHZlcnRleC51diwgdlBvcyApOyAgXG59XG5gLGNjPWBcbiNpbmNsdWRlIFwiV29ybGRNYXRyaXhVbmlmb3JtXCJcbiNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG5cbnN0cnVjdCBWZXJ0ZXhPdXRwdXQge1xuICAgIEBsb2NhdGlvbigwKSBmcmFnVVY6IHZlYzI8ZjMyPixcbiAgICBAbG9jYXRpb24oMSkgd29ybGRQb3M6IHZlYzM8ZjMyPixcbiAgICBAYnVpbHRpbihwb3NpdGlvbikgbWVtYmVyOiB2ZWM0PGYzMj5cbn07XG5cbiNpZiBVU0VfTU9SUEhUQVJHRVRTXG4gICAgJHtMZS5nZXRNb3JwaFRhcmdldFNoYWRlckJpbmRpbmcoMiwxKX1cbiMjZW5kaWZcbiBcbiNpZiBVU0VfU0tFTEVUT05cbiAgICAke09yLmdyb3VwQmluZGluZ0FuZEZ1bmN0aW9ucygyLDEpfSBcbiNlbmRpZlxuXG52YXI8cHJpdmF0ZT4gd29ybGRNYXRyaXg6IG1hdDR4NDxmMzI+O1xuXG5zdHJ1Y3QgVmVydGV4QXR0cmlidXRlc3tcbiAgQGJ1aWx0aW4oaW5zdGFuY2VfaW5kZXgpIGluZGV4IDogdTMyLFxuICBAbG9jYXRpb24oMCkgcG9zaXRpb246IHZlYzM8ZjMyPixcbiAgQGxvY2F0aW9uKDEpIG5vcm1hbDogdmVjMzxmMzI+LFxuICBAbG9jYXRpb24oMikgdXY6IHZlYzI8ZjMyPixcbiAgQGxvY2F0aW9uKDMpIFRFWENPT1JEXzE6IHZlYzI8ZjMyPixcblxuICAjaWYgVVNFX1RBTkdFTlRcbiAgICAgIEBsb2NhdGlvbig0KSBUQU5HRU5UOiB2ZWM0PGYzMj4sXG4gICAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgICAgQGxvY2F0aW9uKDUpIGpvaW50czA6IHZlYzQ8ZjMyPixcbiAgICAgICAgICBAbG9jYXRpb24oNikgd2VpZ2h0czA6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAjaWYgVVNFX0pPSU5UX1ZFQzhcbiAgICAgICAgICBAbG9jYXRpb24oNykgam9pbnRzMTogdmVjNDxmMzI+LFxuICAgICAgICAgIEBsb2NhdGlvbig4KSB3ZWlnaHRzMTogdmVjNDxmMzI+LFxuICAgICAgI2VuZGlmXG4gICAgICAjZWxzZWlmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAgICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRBdHRyKDUpfVxuICAgICAgI2VuZGlmXG4gICNlbHNlaWYgVVNFX1NLRUxFVE9OXG4gICAgICBAbG9jYXRpb24oNCkgam9pbnRzMDogdmVjNDxmMzI+LFxuICAgICAgQGxvY2F0aW9uKDUpIHdlaWdodHMwOiB2ZWM0PGYzMj4sXG4gICAgICAjaWYgVVNFX0pPSU5UX1ZFQzhcbiAgICAgIEBsb2NhdGlvbig2KSBqb2ludHMxOiB2ZWM0PGYzMj4sXG4gICAgICBAbG9jYXRpb24oNykgd2VpZ2h0czE6IHZlYzQ8ZjMyPixcbiAgICAgICNlbmRpZlxuICAjZWxzZWlmIFVTRV9NT1JQSFRBUkdFVFNcbiAgICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRBdHRyKDQpfVxuICAjZW5kaWZcbn1cblxuQHZlcnRleFxuZm4gbWFpbih2ZXJ0ZXg6VmVydGV4QXR0cmlidXRlcykgLT4gVmVydGV4T3V0cHV0IHtcbiAgICB3b3JsZE1hdHJpeCA9IG1vZGVscy5tYXRyaXhbdmVydGV4LmluZGV4XTtcbiAgICBsZXQgc2hhZG93TWF0cml4OiBtYXQ0eDQ8ZjMyPiA9IGdsb2JhbFVuaWZvcm0ucHJvak1hdCAqIGdsb2JhbFVuaWZvcm0udmlld01hdCA7XG4gICAgdmFyIHZlcnRleFBvc2l0aW9uID0gdmVydGV4LnBvc2l0aW9uLnh5ejtcblxuICAgICNpZiBVU0VfTU9SUEhUQVJHRVRTXG4gICAgICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRDYWxjVmVydGV4KCl9XG4gICAgI2VuZGlmXG5cbiAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgICNpZiBVU0VfSk9JTlRfVkVDOFxuICAgICAgICAgIHdvcmxkTWF0cml4ICo9IGdldFNrZWxldG9uV29ybGRNYXRyaXhfOCh2ZXJ0ZXguam9pbnRzMCwgdmVydGV4LndlaWdodHMwLCB2ZXJ0ZXguam9pbnRzMSwgdmVydGV4LndlaWdodHMxKTtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICB3b3JsZE1hdHJpeCAqPSBnZXRTa2VsZXRvbldvcmxkTWF0cml4XzQodmVydGV4LmpvaW50czAsIHZlcnRleC53ZWlnaHRzMCk7XG4gICAgICAgICNlbmRpZlxuICAgICNlbmRpZlxuXG4gICAgdmFyIHdvcmxkUG9zID0gd29ybGRNYXRyaXggKiB2ZWM0PGYzMj4odmVydGV4UG9zaXRpb24sIDEuMCkgO1xuICAgIHZhciB2UG9zID0gc2hhZG93TWF0cml4ICogd29ybGRQb3M7XG4gICAgcmV0dXJuIFZlcnRleE91dHB1dCh2ZXJ0ZXgudXYsIHdvcmxkUG9zLnh5eiAsIHZQb3MgKTsgXG59XG5gLGZjPWBcbiAgICAjaWYgVVNFX0FMUEhBQ1VUXG4gICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMClcbiAgICAgIHZhciBiYXNlTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgIEBncm91cCgxKSBAYmluZGluZygxKVxuICAgICAgdmFyIGJhc2VNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAjZW5kaWZcblxuICAgIHN0cnVjdCBGcmFnbWVudE91dHB1dCB7XG4gICAgICBAbG9jYXRpb24oMCkgb19UYXJnZXQ6IHZlYzQ8ZjMyPixcbiAgICAgIEBidWlsdGluKGZyYWdfZGVwdGgpIG91dF9kZXB0aDogZjMyXG4gICAgfTtcblxuICAgIHN0cnVjdCBNYXRlcmlhbFVuaWZvcm0ge1xuICAgICAgbGlnaHRXb3JsZFBvczogdmVjMzxmMzI+LFxuICAgICAgY2FtZXJhRmFyOiBmMzIsXG4gICAgfTtcblxuICAgIEBncm91cCgyKSBAYmluZGluZygwKVxuICAgIHZhcjx1bmlmb3JtPiBtYXRlcmlhbFVuaWZvcm06IE1hdGVyaWFsVW5pZm9ybTtcblxuICAgIEBmcmFnbWVudFxuICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+ICwgQGxvY2F0aW9uKDEpIHdvcmxkUG9zOnZlYzM8ZjMyPiApIC0+IEZyYWdtZW50T3V0cHV0IHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gbGVuZ3RoKHdvcmxkUG9zLnh5eiAtIG1hdGVyaWFsVW5pZm9ybS5saWdodFdvcmxkUG9zICkgO1xuICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlIC8gbWF0ZXJpYWxVbmlmb3JtLmNhbWVyYUZhciA7XG4gICAgICAgIHZhciBmcmFnT3V0OkZyYWdtZW50T3V0cHV0OyBcblxuICAgICAgI2lmIFVTRV9BTFBIQUNVVFxuICAgICAgICBsZXQgQWxiZWRvID0gdGV4dHVyZVNhbXBsZShiYXNlTWFwLGJhc2VNYXBTYW1wbGVyLGZyYWdVVik7XG4gICAgICAgIGlmKEFsYmVkby53ID4gMC41KXtcbiAgICAgICAgICBmcmFnT3V0ID0gRnJhZ21lbnRPdXRwdXQodmVjNDxmMzI+KDAuMCksZGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAjZWxzZVxuICAgICAgICBmcmFnT3V0ID0gRnJhZ21lbnRPdXRwdXQodmVjNDxmMzI+KDAuMCksZGlzdGFuY2UpO1xuICAgICAgI2VuZGlmXG4gICAgICBcbiAgICAgICAgcmV0dXJuIGZyYWdPdXQgO1xuICAgIH1cbmAsZGM9YFxuICAgICNpZiBVU0VfQUxQSEFDVVRcbiAgICAgIEBncm91cCgxKSBAYmluZGluZygwKVxuICAgICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKDEpXG4gICAgICB2YXIgYmFzZU1hcDogdGV4dHVyZV8yZDxmMzI+O1xuICAgICNlbmRpZlxuXG4gICAgc3RydWN0IEZyYWdtZW50T3V0cHV0IHtcbiAgICAgIEBsb2NhdGlvbigwKSBvX1RhcmdldDogdmVjNDxmMzI+LFxuICAgICAgQGJ1aWx0aW4oZnJhZ19kZXB0aCkgb3V0X2RlcHRoOiBmMzJcbiAgICB9O1xuXG4gICAgc3RydWN0IE1hdGVyaWFsVW5pZm9ybSB7XG4gICAgICBsaWdodFdvcmxkUG9zOiB2ZWMzPGYzMj4sXG4gICAgICBjYW1lcmFGYXI6IGYzMixcbiAgICB9O1xuXG4gICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApXG4gICAgdmFyPHVuaWZvcm0+IG1hdGVyaWFsVW5pZm9ybTogTWF0ZXJpYWxVbmlmb3JtO1xuXG4gICAgQGZyYWdtZW50XG4gICAgZm4gbWFpbihAbG9jYXRpb24oMCkgZnJhZ1VWOiB2ZWMyPGYzMj4gLCBAbG9jYXRpb24oMSkgY2xpcFBvczp2ZWMzPGYzMj4gKSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIC8vIHZhciBkaXN0YW5jZSA9IGxlbmd0aCh3b3JsZFBvcy54eXogLSBtYXRlcmlhbFVuaWZvcm0ubGlnaHRXb3JsZFBvcyApIDtcbiAgICAgICAgLy8gZGlzdGFuY2UgPSBkaXN0YW5jZSAvIG1hdGVyaWFsVW5pZm9ybS5jYW1lcmFGYXIgO1xuICAgICAgICB2YXIgZnJhZ091dDpGcmFnbWVudE91dHB1dDsgXG5cbiAgICAgIC8vICNpZiBVU0VfQUxQSEFDVVRcbiAgICAgIC8vICAgbGV0IEFsYmVkbyA9IHRleHR1cmVTYW1wbGUoYmFzZU1hcCxiYXNlTWFwU2FtcGxlcixmcmFnVVYpO1xuICAgICAgLy8gICBpZihBbGJlZG8udyA+IDAuNSl7XG4gICAgICAvLyAgICAgZnJhZ091dCA9IEZyYWdtZW50T3V0cHV0KHZlYzQ8ZjMyPigwLjApLGRpc3RhbmNlKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gI2Vsc2VcbiAgICAgIC8vICAgZnJhZ091dCA9IEZyYWdtZW50T3V0cHV0KHZlYzQ8ZjMyPigwLjApLGRpc3RhbmNlKTtcbiAgICAgIC8vICNlbmRpZlxuICAgICAgXG4gICAgICAgIHJldHVybiBmcmFnT3V0IDtcbiAgICB9XG5gLFdnPWBcbiNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG5cbnN0cnVjdCBSZW5kZXJCb3VuZHtcbiAgICBpbmRleDpmMzIsXG59XG5cbnN0cnVjdCBVbmlmb3JtcyB7XG4gICAgbWF0cml4IDogYXJyYXk8bWF0NHg0PGYzMj4+XG59O1xuXG4vL0Bncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2xvYmFsVW5pZm9ybTogR2xvYmFsVW5pZm9ybTtcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gbW9kZWxzIDogVW5pZm9ybXM7XG5AZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IHBsYW5lczogYXJyYXk8dmVjNDxmMzI+LDc+O1xuQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLCByZWFkPiBjdWxsaW5nTGlzdDogYXJyYXk8UmVuZGVyQm91bmQ+O1xuQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhcjxzdG9yYWdlLHJlYWRfd3JpdGU+IG91dEJ1ZmZlcjogYXJyYXk8ZjMyPjtcblxuXG52YXI8cHJpdmF0ZT4gYm91bmRQb2ludHMgOiBhcnJheTx2ZWM0PGYzMj4sOD4gOyAgIFxuXG5mbiBJc0luQ2xpcFNwYWNlKCBjb29yZCA6IHZlYzQ8ZjMyPiApIC0+IGJvb2wge1xuICAgIHJldHVybiAtY29vcmQudyA8PSBjb29yZC54ICYmIGNvb3JkLnggPD0gY29vcmQud1xuICAgICAgICAmJiAtY29vcmQudyA8PSBjb29yZC55ICYmIGNvb3JkLnkgPD0gY29vcmQud1xuICAgICAgICAmJiAtY29vcmQudyA8PSBjb29yZC56ICYmIGNvb3JkLnogPD0gY29vcmQudztcbn1cblxuZm4gSXNPdXRzaWRlVGhlUGxhbmUoIHBsYW5lOiB2ZWM0PGYzMj4sIHBvaW50UG9zaXRpb24gOiB2ZWMzPGYzMj4gKSAtPiBib29se1xuICAgIGlmKGRvdChwbGFuZS54eXosIHBvaW50UG9zaXRpb24pICsgcGxhbmUudyA+IDAuMCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZuIGNvbnRhaW5zQm94KCBzaXplOnZlYzM8ZjMyPiAsIGNlbnRlcjp2ZWMzPGYzMj4gKSAtPiBmMzIge1xuICAgIHZhciBjID0gMC4wIDtcbiAgICB2YXIgZCA9IDAuMCA7XG5cbiAgICB2YXIgciA9IG1heChzaXplLngsIHNpemUueSk7XG4gICAgdmFyIHNyID0gbWF4KHIgLCBzaXplLnopO1xuICAgIHZhciBzY3ggPSBjZW50ZXIueDtcbiAgICB2YXIgc2N5ID0gY2VudGVyLnk7XG4gICAgdmFyIHNjeiA9IGNlbnRlci56O1xuXG4gICAgZm9yKHZhciBwOmkzMiA9IDA7IHAgPCA2IDsgcCA9IHAgKyAxICl7XG4gICAgICAgIHZhciBwbGFuZSA9IHBsYW5lc1twXTtcbiAgICAgICAgZCA9IHBsYW5lLnggKiBzY3ggKyBwbGFuZS55ICogc2N5ICsgcGxhbmUueiAqIHNjeiArIHBsYW5lLnc7XG4gICAgICAgIGlmIChkIDw9IC1zcikge1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID4gc3IpIHtcbiAgICAgICAgYys9MS4wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGMgPj0gNi4wICl7XG4gICAgICAgIHJldHVybiAyLjAgO1xuICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gMS4wIDtcbiAgICB9XG59XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSggMTI4IClcbmZuIENzTWFpbiggQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4gLCBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSW52b2NhdGlvbl9pZCA6IHZlYzM8dTMyPilcbntcbiAgICBsZXQgaWQgPSBnbG9iYWxJbnZvY2F0aW9uX2lkLnggO1xuICAgIGlmKGlkICsgMXUgPiB1MzIocGxhbmVzWzZdLngpICl7XG4gICAgICAgIG91dEJ1ZmZlcltpZF0gPSBmMzIoMC4wKTsgXG4gICAgICAgIHJldHVybiA7XG4gICAgfVxuXG4gICAgbGV0IHJlbmRlckJvdW5kID0gY3VsbGluZ0xpc3RbaWRdO1xuICAgIGxldCBib3VuZElEID0gaTMyKHJlbmRlckJvdW5kLmluZGV4KSA7XG4gICAgdmFyIHBsYW5lID0gcGxhbmVzWzBdO1xuXG4gICAgbGV0IHdvcmxkTWF0cml4ID0gbW9kZWxzLm1hdHJpeFtib3VuZElEXTtcbiAgICBsZXQgcHJvak1hdCA9IGdsb2JhbFVuaWZvcm0ucHJvak1hdCA7XG5cbiAgICBsZXQgY29uc3RfYm91bmRNaW4gOiB2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oLTAuNSwtMC41LC0wLjUpIDsgICBcbiAgICBsZXQgY29uc3RfYm91bmRNYXggOiB2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oMC41LDAuNSwwLjUpIDsgICBcblxuICAgIGxldCBib3VuZE1pbiA9IHdvcmxkTWF0cml4ICogdmVjNDxmMzI+KGNvbnN0X2JvdW5kTWluLCAxLjApO1xuICAgIGxldCBib3VuZE1heCA9IHdvcmxkTWF0cml4ICogdmVjNDxmMzI+KGNvbnN0X2JvdW5kTWF4LCAxLjApO1xuXG4gICAgbGV0IHNpemUgPSBhYnMoIGJvdW5kTWF4Lnh5eiAtIGJvdW5kTWluLnh5eiApICogMC42NSA7XG4gICAgbGV0IGNlbnRlciA9IHdvcmxkTWF0cml4WzNdLnh5eiA7XG5cbiAgICB2YXIgaXNJbiA6ZjMyID0gMC4wIDtcblxuICAgIGlzSW4gPSBjb250YWluc0JveChzaXplLGNlbnRlcik7XG5cbiAgICBvdXRCdWZmZXJbaWRdID0gZjMyKGlzSW4pOyBcbn1cbmAsJG89YFxuI2luY2x1ZGUgXCJDb21tb25fdmVydFwiXG4jaW5jbHVkZSBcIkZyYWdtZW50VmFyeWluZ1wiXG4jaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuXG5zdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgIEBsb2NhdGlvbigwKSBvX1Bvc2l0aW9uOiB2ZWM0PGYzMj4sXG4gICAgQGxvY2F0aW9uKDEpIG9fTm9ybWFsOiB2ZWM0PGYzMj4sXG4gICAgQGxvY2F0aW9uKDIpIG9fQ29sb3I6IHZlYzQ8ZjMyPlxufTtcblxuc3RydWN0IE1hdGVyaWFsVW5pZm9ybSB7XG4gICAgYmFzZUNvbG9yOiB2ZWM0PGYzMj4sXG4gICAgZW1pc3NpdmVDb2xvcjogdmVjNDxmMzI+LFxuICAgIGVtaXNzaXZlSW50ZW5zaXR5OiBmMzIsXG4gICAgbm9ybWFsU2NhbGU6IGYzMixcbiAgICBhbHBoYUN1dG9mZjogZjMyXG59O1xuXG5AZ3JvdXAoMikgQGJpbmRpbmcoMClcbnZhcjx1bmlmb3JtPiBtYXRlcmlhbFVuaWZvcm06IE1hdGVyaWFsVW5pZm9ybTtcblxuQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG52YXIgYmFzZU1hcFNhbXBsZXI6IHNhbXBsZXI7XG5AZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbnZhciBiYXNlTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5cbkBncm91cCgxKSBAYmluZGluZyhhdXRvKVxudmFyIG5vcm1hbE1hcFNhbXBsZXI6IHNhbXBsZXI7XG5AZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbnZhciBub3JtYWxNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG52YXIgZW1pc3NpdmVNYXBTYW1wbGVyOiBzYW1wbGVyO1xuQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG52YXIgZW1pc3NpdmVNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuZm4gdmVydChpbnB1dERhdGE6VmVydGV4QXR0cmlidXRlcykgLT4gVmVydGV4T3V0cHV0IHtcbiAgICBPUklfVmVydChpbnB1dERhdGEpIDtcbiAgICByZXR1cm4gT1JJX1ZlcnRleE91dCA7XG59XG5cbnZhcjxwcml2YXRlPiBPUklfRnJhZ21lbnRPdXRwdXQ6IEZyYWdtZW50T3V0cHV0O1xudmFyPHByaXZhdGU+IE9SSV9WZXJ0ZXhWYXJ5aW5nOiBGcmFnbWVudFZhcnlpbmc7XG5cbkBmcmFnbWVudFxuZm4gRnJhZ01haW4odmVydGV4X3Zhcnlpbmc6RnJhZ21lbnRWYXJ5aW5nKSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgT1JJX1ZlcnRleFZhcnlpbmcgPSB2ZXJ0ZXhfdmFyeWluZztcbiAgICB2YXIgdGV4Q29sb3IgPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCBPUklfVmVydGV4VmFyeWluZy5mcmFnVVYwLnh5ICk7XG5cbiAgICB2YXIgZW1pc3NpdmUgPSB0ZXh0dXJlU2FtcGxlKGVtaXNzaXZlTWFwLCBlbWlzc2l2ZU1hcFNhbXBsZXIsIE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdVVjAueHkgKS5yZ2IgO1xuICAgIGxldCBpbnRlbnNpdHkgPSBtYXRlcmlhbFVuaWZvcm0uZW1pc3NpdmVJbnRlbnNpdHkgKiBtYXRlcmlhbFVuaWZvcm0uZW1pc3NpdmVDb2xvci5hIDtcbiAgICBlbWlzc2l2ZSA9IGVtaXNzaXZlLnJnYiAqIG1hdGVyaWFsVW5pZm9ybS5lbWlzc2l2ZUNvbG9yLnJnYiA7XG4gICAgZW1pc3NpdmUgPSBjb252ZXJ0VG9IRFJSR0IoZW1pc3NpdmUsaW50ZW5zaXR5KTtcblxuICAgIGlmIChtYXRlcmlhbFVuaWZvcm0uYWxwaGFDdXRvZmYtdGV4Q29sb3IudyA+IDAuMCkge1xuICAgICAgICBkaXNjYXJkIDtcbiAgICB9XG5cbiAgICB2YXIgb19Qb3NpdGlvbiA9IHZlYzQ8ZjMyPihPUklfVmVydGV4VmFyeWluZy52V29ybGRQb3MueHl6LGVtaXNzaXZlLnIpIDtcbiAgICB2YXIgb19Ob3JtYWwgPSB2ZWM0PGYzMj4oKE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZE5vcm1hbC54eXogKiAwLjUgKyAwLjUgKSxlbWlzc2l2ZS5nKSA7XG4gICAgdmFyIG9fQ29sb3IgPSB2ZWM0PGYzMj4oKHRleENvbG9yICogbWF0ZXJpYWxVbmlmb3JtLmJhc2VDb2xvcikucmdiICwgZW1pc3NpdmUuYiApICA7XG4gICAgcmV0dXJuIEZyYWdtZW50T3V0cHV0KG9fUG9zaXRpb24sb19Ob3JtYWwsdmVjNDxmMzI+KG9fQ29sb3IpKTtcbn1cblxuZm4gY29udmVydFRvSERSUkdCKCBjb2xvciA6IHZlYzM8ZjMyPiAsIGluczpmMzIgKSAtPiB2ZWMzPGYzMj4ge1xuICAgIHZhciBoZHJDb2xvciA9IHZlYzM8ZjMyPigwLjAsMC4wLDAuMCk7XG4gICAgaGRyQ29sb3IuciA9IGNvbG9yLnIgKiBwb3coMi40LCBpbnMpO1xuICAgIGhkckNvbG9yLmcgPSBjb2xvci5nICogcG93KDIuNCwgaW5zKTtcbiAgICBoZHJDb2xvci5iID0gY29sb3IuYiAqIHBvdygyLjQsIGlucyk7XG4gICAgcmV0dXJuIGhkckNvbG9yO1xufVxuYCxnYz1gXG4jaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuXG5zdHJ1Y3QgdW5pZm9ybURhdGEge1xuICAgIGV4cG9zdXJlOiBmMzIsXG4gICAgcm91Z2huZXNzOiBmMzJcbn07XG5cbnN0cnVjdCBGcmFnbWVudE91dHB1dCB7XG4gICAgQGxvY2F0aW9uKDApIG9fUG9zaXRpb246IHZlYzQ8ZjMyPixcbiAgICBAbG9jYXRpb24oMSkgb19Ob3JtYWw6IHZlYzQ8ZjMyPixcbiAgICBAbG9jYXRpb24oMikgb19Db2xvcjogdmVjNDxmMzI+XG59O1xuXG5AZ3JvdXAoMSkgQGJpbmRpbmcoNClcbnZhciBiYXNlTWFwU2FtcGxlcjogc2FtcGxlcjtcbkBncm91cCgxKSBAYmluZGluZyg1KVxudmFyIGJhc2VNYXA6IHRleHR1cmVfY3ViZTxmMzI+O1xuXG5AZ3JvdXAoMikgQGJpbmRpbmcoMClcbnZhcjx1bmlmb3JtPiBnbG9iYWw6IHVuaWZvcm1EYXRhO1xuXG5mbiBMaW5lYXJUb0dhbW1hU3BhY2UobGluUkdCOiB2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPiB7XG4gICAgdmFyIGxpblJHQjE6IHZlYzM8ZjMyPjtcbiAgICBsaW5SR0IxID0gbGluUkdCO1xuICAgIGxpblJHQjEgPSBtYXgobGluUkdCMSwgdmVjMzxmMzI+KDAuMCwgMC4wLCAwLjApKTtcbiAgICBsaW5SR0IxLnggPSBwb3cobGluUkdCMS54LCAwLjQxNjY2NjY1NjczMjU1OTIpO1xuICAgIGxpblJHQjEueSA9IHBvdyhsaW5SR0IxLnksIDAuNDE2NjY2NjU2NzMyNTU5Mik7XG4gICAgbGluUkdCMS56ID0gcG93KGxpblJHQjEueiwgMC40MTY2NjY2NTY3MzI1NTkyKTtcbiAgICByZXR1cm4gbWF4KCgoMS4wNTQ5OTk5NDc1NDc5MTI2ICogbGluUkdCMSkgLSB2ZWMzPGYzMj4oMC4wNTQ5OTk5OTk3MDE5NzY3NzYpKSwgdmVjMzxmMzI+KDAuMCkpO1xufVxuXG5AZnJhZ21lbnRcbmZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+LCBAbG9jYXRpb24oMSkgdldvcmxkUG9zOiB2ZWM0PGYzMj4sIEBsb2NhdGlvbigyKSB2V29ybGROb3JtYWw6IHZlYzM8ZjMyPikgLT4gRnJhZ21lbnRPdXRwdXQge1xuICAgIGxldCBtYXhMZXZlbDogdTMyID0gdGV4dHVyZU51bUxldmVscyhiYXNlTWFwKTtcbiAgICBsZXQgdGV4dHVyZUNvbG9yOnZlYzM8ZjMyPiA9IHRleHR1cmVTYW1wbGVMZXZlbChiYXNlTWFwLCBiYXNlTWFwU2FtcGxlciwgbm9ybWFsaXplKHZXb3JsZFBvcy54eXopLCBnbG9iYWwucm91Z2huZXNzICogZjMyKG1heExldmVsKSApLnh5ejtcbiAgICBsZXQgb19Db2xvciA9IDAuNjE4ICogdmVjNDxmMzI+KExpbmVhclRvR2FtbWFTcGFjZSh0ZXh0dXJlQ29sb3IpICogZ2xvYmFsVW5pZm9ybS5za3lFeHBvc3VyZSAsIDEuMCk7XG4gICAgbGV0IG9fTm9ybWFsID0gdmVjNCh2V29ybGROb3JtYWwsMS4wKSA7XG4gICAgbGV0IG9fUG9zaXRpb24gPSB2ZWM0PGYzMj4odldvcmxkUG9zLnh5eiwxMDAwMDAuMCkgO1xuICAgIHJldHVybiBGcmFnbWVudE91dHB1dChvX1Bvc2l0aW9uLG9fTm9ybWFsLG9fQ29sb3IpO1xufVxuYCxwYz1gXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLHJlYWRfd3JpdGU+IHZpc2libGVCdWZmZXI6IGFycmF5PGYzMj47XG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciB6QnVmZmVyVGV4dHVyZSA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSg4LCA4LCAxKVxuICAgIGZuIENzTWFpbiggQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbEludm9jYXRpb25faWQgOiB2ZWMzPHUzMj4gKSB7XG4gICAgICAgIHZhciBmcmFnQ29vcmQgPSB2ZWMyPGkzMj4oIGdsb2JhbEludm9jYXRpb25faWQueHkgKTtcbiAgICAgICAgbGV0IG1kID0gdGV4dHVyZUxvYWQoekJ1ZmZlclRleHR1cmUsZnJhZ0Nvb3JkLDApO1xuXG4gICAgICAgIGxldCBtZXNoSUQgPSBpMzIoZmxvb3IoIG1kLncgKyAwLjEgKSk7XG4gICAgICAgIGlmIChtZXNoSUQgPj0gMCkge1xuICAgICAgICAgICAgdmlzaWJsZUJ1ZmZlclttZXNoSURdID0gMS4wIDtcbiAgICAgICAgfVxuICAgIH1cbmAsbWM9YFxuICAgICNpbmNsdWRlIFwiR2xvYmFsVW5pZm9ybVwiXG4gICAgI2luY2x1ZGUgXCJNYXRoU2hhZGVyXCJcbiAgICBzdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICBAbG9jYXRpb24oMCkgb19UYXJnZXQ6IHZlYzQ8ZjMyPixcbiAgICAgICAgQGJ1aWx0aW4oZnJhZ19kZXB0aCkgb3V0X2RlcHRoOiBmMzJcbiAgICB9O1xuICAgXG5cbiAgICBAZnJhZ21lbnRcbiAgICBmbiBtYWluKEBsb2NhdGlvbigwKSB2SUQ6IGYzMiwgQGxvY2F0aW9uKDEpIHZQb3M6dmVjMzxmMzI+ICwgIEBsb2NhdGlvbigyKSB2Q2xpcFBvczogdmVjNDxmMzI+ICwgIEBidWlsdGluKHBvc2l0aW9uKSBmcmFnQ29vcmQgOiB2ZWM0PGYzMj4pIC0+IEZyYWdtZW50T3V0cHV0IHtcbiAgICAgICAgdmFyIG9wID0gdmVjNDxmMzI+KCB2UG9zLCB2SUQpO1xuICAgICAgICBsZXQgZCA9IGxvZzJEZXB0aChmcmFnQ29vcmQueiswLjAwMDAxLGdsb2JhbFVuaWZvcm0ubmVhcixnbG9iYWxVbmlmb3JtLmZhcik7XG4gICAgICAgIHJldHVybiBGcmFnbWVudE91dHB1dChvcCxkKTtcbiAgICB9XG5gLEFjPWBcbiAgICAjaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuICAgICNpbmNsdWRlIFwiTWF0aFNoYWRlclwiXG4gICAgc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgICAgIEBsb2NhdGlvbigwKSB2SUQ6IGYzMiAsXG4gICAgICAgIEBsb2NhdGlvbigxKSB2UG9zOiB2ZWMzPGYzMj4gLFxuICAgICAgICBAbG9jYXRpb24oMikgdkNsaXBQb3M6IHZlYzQ8ZjMyPiAsXG4gICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBtZW1iZXI6IHZlYzQ8ZjMyPlxuICAgIH07XG5cbiAgICBzdHJ1Y3QgVW5pZm9ybXMge1xuICAgICAgICBtYXRyaXggOiBhcnJheTxtYXQ0eDQ8ZjMyPj5cbiAgICB9O1xuXG4gICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpXG4gICAgdmFyPHN0b3JhZ2UsIHJlYWQ+IG1vZGVscyA6IFVuaWZvcm1zO1xuXG4gICAgdmFyPHByaXZhdGU+IHdvcmxkTWF0cml4OiBtYXQ0eDQ8ZjMyPjtcblxuICAgICNpZiBVU0VfTU9SUEhUQVJHRVRTXG4gICAgICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRTaGFkZXJCaW5kaW5nKDEsMCl9XG4gICAgI2VuZGlmXG5cbiAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgICR7T3IuZ3JvdXBCaW5kaW5nQW5kRnVuY3Rpb25zKDEsMCl9XG4gICAgI2VuZGlmXG5cbiAgICBAdmVydGV4XG4gICAgZm4gbWFpbihcbiAgICAgICAgQGJ1aWx0aW4oaW5zdGFuY2VfaW5kZXgpIGluZGV4IDogdTMyLFxuICAgICAgICBAbG9jYXRpb24oMCkgcG9zaXRpb246IHZlYzM8ZjMyPixcbiAgICAgICAgQGxvY2F0aW9uKDEpIG5vcm1hbDogdmVjMzxmMzI+LFxuICAgICAgICBAbG9jYXRpb24oMikgdXY6IHZlYzI8ZjMyPixcbiAgICAgICAgQGxvY2F0aW9uKDMpIFRFWENPT1JEXzE6IHZlYzI8ZjMyPixcblxuICAgICNpZiBVU0VfVEFOR0VOVFxuICAgICAgICBAbG9jYXRpb24oNCkgVEFOR0VOVDogdmVjNDxmMzI+LFxuICAgICAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgICAgICBAbG9jYXRpb24oNSkgam9pbnRzMDogdmVjNDxmMzI+LFxuICAgICAgICAgICAgQGxvY2F0aW9uKDYpIHdlaWdodHMwOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICAjaWYgVVNFX0pPSU5UX1ZFQzhcbiAgICAgICAgICAgICAgICBAbG9jYXRpb24oNykgam9pbnRzMTogdmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIEBsb2NhdGlvbig4KSB3ZWlnaHRzMTogdmVjNDxmMzI+LFxuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICNlbHNlaWYgVVNFX01PUlBIVEFSR0VUU1xuICAgICAgICAgICAgJHtMZS5nZXRNb3JwaFRhcmdldEF0dHIoNSl9XG4gICAgICAgICNlbmRpZlxuICAgICNlbHNlaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgIEBsb2NhdGlvbig0KSBqb2ludHMwOiB2ZWM0PGYzMj4sXG4gICAgICAgIEBsb2NhdGlvbig1KSB3ZWlnaHRzMDogdmVjNDxmMzI+LFxuICAgICAgICAjaWYgVVNFX0pPSU5UX1ZFQzhcbiAgICAgICAgICAgIEBsb2NhdGlvbig2KSBqb2ludHMxOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICBAbG9jYXRpb24oNykgd2VpZ2h0czE6IHZlYzQ8ZjMyPixcbiAgICAgICAgI2VuZGlmXG4gICAgI2Vsc2VpZiBVU0VfTU9SUEhUQVJHRVRTXG4gICAgICAgICR7TGUuZ2V0TW9ycGhUYXJnZXRBdHRyKDQpfVxuICAgICNlbmRpZlxuICAgICkgLT4gVmVydGV4T3V0cHV0IHtcbiAgICB3b3JsZE1hdHJpeCA9IG1vZGVscy5tYXRyaXhbaW5kZXhdO1xuXG4gICAgdmFyIHZlcnRleFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdmFyIHZlcnRleE5vcm1hbCA9IG5vcm1hbDtcbiAgICAjaWYgVVNFX01PUlBIVEFSR0VUU1xuICAgICAgICAke0xlLmdldE1vcnBoVGFyZ2V0Q2FsY1ZlcnRleCgpfVxuICAgICNlbmRpZlxuXG4gICAgI2lmIFVTRV9TS0VMRVRPTlxuICAgICAgICAjaWYgVVNFX0pPSU5UX1ZFQzhcbiAgICAgICAgICAgIHdvcmxkTWF0cml4ICo9IGdldFNrZWxldG9uV29ybGRNYXRyaXhfOChqb2ludHMwLCB3ZWlnaHRzMCwgam9pbnRzMSwgd2VpZ2h0czEpO1xuICAgICAgICAjZWxzZVxuICAgICAgICAgICAgd29ybGRNYXRyaXggKj0gZ2V0U2tlbGV0b25Xb3JsZE1hdHJpeF80KGpvaW50czAsIHdlaWdodHMwKTtcbiAgICAgICAgI2VuZGlmXG4gICAgI2VuZGlmXG5cbiAgICAgICAgXG4gICAgICAgIGxldCB3UG9zID0gd29ybGRNYXRyaXggKiB2ZWM0PGYzMj4odmVydGV4UG9zaXRpb24ueHl6LCAxLjApO1xuICAgICAgICB2YXIgZml4UHJvak1hdCA9IGdsb2JhbFVuaWZvcm0ucHJvak1hdCA7XG4gICAgICAgIHZhciByek1hdHJpeCA6IG1hdDR4NDxmMzI+IDtcbiAgICAgICAgcnpNYXRyaXhbMF0gPSB2ZWM0PGYzMj4oMS4wLDAuMCwwLjAsMC4wKSA7IFxuICAgICAgICByek1hdHJpeFsxXSA9IHZlYzQ8ZjMyPigwLjAsMS4wLDAuMCwwLjApIDsgXG4gICAgICAgIHJ6TWF0cml4WzJdID0gdmVjNDxmMzI+KDAuMCwwLjAsMS4wLDAuMCkgOyBcbiAgICAgICAgcnpNYXRyaXhbM10gPSB2ZWM0PGYzMj4oMC4wLDAuMCwwLjAsMS4wKSA7IFxuICAgICAgICB2YXIgY2xpcFBvczp2ZWM0PGYzMj4gPSBmaXhQcm9qTWF0ICogZ2xvYmFsVW5pZm9ybS52aWV3TWF0ICogKHdQb3MpIDtcblxuICAgICAgICAvLyBsZXQgZCA9IGxvZzJEZXB0aChjbGlwUG9zLnogKiAoZ2xvYmFsVW5pZm9ybS5mYXIgLSBnbG9iYWxVbmlmb3JtLm5lYXIpLGdsb2JhbFVuaWZvcm0ubmVhcixnbG9iYWxVbmlmb3JtLmZhcikgO1xuICAgICAgICByZXR1cm4gVmVydGV4T3V0cHV0KGYzMihpbmRleCkgLCB3UG9zLnh5eixjbGlwUG9zLCBjbGlwUG9zKTtcbiAgICB9XG5cbiAgICBmbiBkZXB0aFRvTGluZWFyMDEoZGVwdGg6ZjMyKSAtPiBmMzIge1xuICAgICAgICBsZXQgYSA9IDEuMCAvIChnbG9iYWxVbmlmb3JtLm5lYXIgLSBnbG9iYWxVbmlmb3JtLmZhcik7XG4gICAgICAgIHJldHVybiAoZ2xvYmFsVW5pZm9ybS5uZWFyKmdsb2JhbFVuaWZvcm0uZmFyKmEpIC8gKGRlcHRoICsgZ2xvYmFsVW5pZm9ybS5mYXIgKiBhKSA7XG4gICAgfVxuYCxfYz1gXG4gICAgc3RydWN0IExpZ2h0RGF0YSB7XG4gICAgICAgIGluZGV4OmYzMixcbiAgICAgICAgbGlnaHRUeXBlOmkzMixcbiAgICAgICAgcmFkaXVzOmYzMixcbiAgICAgICAgbGluZWFyOmYzMixcbiAgICAgICAgXG4gICAgICAgIHBvc2l0aW9uOnZlYzM8ZjMyPixcbiAgICAgICAgbGlnaHRNYXRyaXhJbmRleDpmMzIsXG5cbiAgICAgICAgZGlyZWN0aW9uOnZlYzM8ZjMyPixcbiAgICAgICAgcXVhZHJhdGljOmYzMixcblxuICAgICAgICBsaWdodENvbG9yOnZlYzM8ZjMyPixcbiAgICAgICAgaW50ZW5zaXR5OmYzMixcblxuICAgICAgICBpbm5lckN1dE9mZiA6ZjMyLFxuICAgICAgICBvdXRlckN1dE9mZjpmMzIsXG4gICAgICAgIHJhbmdlIDpmMzIsXG4gICAgICAgIGNhc3RTaGFkb3c6aTMyLFxuXG4gICAgICAgIGxpZ2h0VGFuZ2VudDp2ZWMzPGYzMj4sXG4gICAgICAgIGllczpmMzIsXG4gICAgfTtcblxuICAgIGNvbnN0IFBvaW50TGlnaHRUeXBlID0gMTtcbiAgICBjb25zdCBEaXJlY3RMaWdodFR5cGUgPSAyO1xuICAgIGNvbnN0IFNwb3RMaWdodFR5cGUgPSAzO1xuXG4gICAgc3RydWN0IENsdXN0ZXJCb3gge1xuICAgICAgICBtaW5Qb2ludDp2ZWM0PGYzMj4sXG4gICAgICAgIG1heFBvaW50OnZlYzQ8ZjMyPlxuICAgIH07XG5cbiAgICBzdHJ1Y3QgTGlnaHRJbmRleCB7XG4gICAgICAgICAgICBjb3VudDpmMzIsXG4gICAgICAgICAgICBzdGFydDpmMzIsXG4gICAgICAgICAgICBlbXB0eTA6ZjMyLFxuICAgICAgICAgICAgZW1wdHkxOmYzMixcbiAgICB9O1xuXG4gICAgc3RydWN0IENsdXN0ZXJzVW5pZm9ybSB7XG4gICAgICAgIGNsdXN0ZXJUaWxlWDpmMzIsXG4gICAgICAgIGNsdXN0ZXJUaWxlWTpmMzIsXG4gICAgICAgIGNsdXN0ZXJUaWxlWjpmMzIsXG4gICAgICAgIG51bUxpZ2h0czpmMzIsXG4gICAgICAgIG1heE51bUxpZ2h0c1BlckNsdXN0ZXI6ZjMyLFxuICAgICAgICBuZWFyOmYzMixcbiAgICAgICAgZmFyOmYzMixcbiAgICAgICAgc2NyZWVuV2lkdGg6ZjMyLFxuICAgICAgICBzY3JlZW5IZWlnaHQ6ZjMyLFxuICAgICAgICBjbHVzdGVyUGl4OmYzMiwgXG4gICAgfTtcblxuICAgIEBncm91cCgyKSBAYmluZGluZygxKVxuICAgIHZhcjxzdG9yYWdlLHJlYWQ+IGxpZ2h0QnVmZmVyOiBhcnJheTxMaWdodERhdGE+O1xuICAgIEBncm91cCgyKSBAYmluZGluZygyKVxuICAgIHZhcjx1bmlmb3JtPiBjbHVzdGVyc1VuaWZvcm0gOiBDbHVzdGVyc1VuaWZvcm07XG4gICAgQGdyb3VwKDIpIEBiaW5kaW5nKDMpXG4gICAgdmFyPHN0b3JhZ2UscmVhZD4gbGlnaHRBc3NpZ25CdWZmZXIgOiBhcnJheTxmMzI+O1xuICAgIEBncm91cCgyKSBAYmluZGluZyg0KVxuICAgIHZhcjxzdG9yYWdlLHJlYWQ+IGFzc2lnblRhYmxlIDogYXJyYXk8TGlnaHRJbmRleD47XG4gICAgI2lmIERFQlVHX0NMVVNURVJcbiAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDUpXG4gICAgICAgIHZhcjxzdG9yYWdlLHJlYWQ+IGNsdXN0ZXJCdWZmZXIgOiBhcnJheTxDbHVzdGVyQm94PjtcbiAgICAjZW5kaWZcblxuICAgIGZuIGdldExpZ2h0KCBpbmRleDppMzIgKSAtPiBMaWdodERhdGEge1xuICAgICAgICBsZXQgbGlnaHRJZCA9IGkzMihsaWdodEFzc2lnbkJ1ZmZlcltpbmRleF0pO1xuICAgICAgICB2YXIgbGlnaHREYXRhID0gbGlnaHRCdWZmZXJbbGlnaHRJZF07XG4gICAgICAgIHJldHVybiBsaWdodERhdGEgO1xuICAgIH1cblxuICAgIGZuIGxpbmVhclRvMDFEZXB0aChkZXB0aCA6IGYzMikgLT4gZjMyIHtcbiAgICAgICAgcmV0dXJuIChnbG9iYWxVbmlmb3JtLmZhciApICogZ2xvYmFsVW5pZm9ybS5uZWFyIC8gZm1hKGRlcHRoLCBnbG9iYWxVbmlmb3JtLm5lYXItZ2xvYmFsVW5pZm9ybS5mYXIsIGdsb2JhbFVuaWZvcm0uZmFyKTtcbiAgICB9XG5cbiAgICBmbiBnZXRDbHVzdGVySWQzKCkgLT4gdmVjMzx1MzI+IHtcbiAgICAgICAgbGV0IHogPSBsaW5lYXJUbzAxRGVwdGgoT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ0Nvb3JkLnopIDsgXG5cbiAgICAgICAgbGV0IHNsaWNlU2NhbGUgPSBmMzIoY2x1c3RlcnNVbmlmb3JtLmNsdXN0ZXJUaWxlWikgLyBsb2cyKGdsb2JhbFVuaWZvcm0uZmFyIC8gZ2xvYmFsVW5pZm9ybS5uZWFyKTtcbiAgICAgICAgbGV0IHNsaWNlQmlhcyA9IC0oZjMyKGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVopICogbG9nMihnbG9iYWxVbmlmb3JtLm5lYXIpIC8gbG9nMihnbG9iYWxVbmlmb3JtLmZhciAvIGdsb2JhbFVuaWZvcm0ubmVhcikpO1xuICAgICAgICBsZXQgelRpbGUgPSB1MzIobWF4KGxvZzIoeikgKiBzbGljZVNjYWxlICsgc2xpY2VCaWFzLCAwLjApKTtcblxuICAgICAgICB2YXIgc2NyZWVuVVYgPSBPUklfVmVydGV4VmFyeWluZy5mcmFnQ29vcmQueHkgLyB2ZWMyPGYzMj4oIGdsb2JhbFVuaWZvcm0ud2luZG93V2lkdGggLCBnbG9iYWxVbmlmb3JtLndpbmRvd0hlaWdodCApO1xuICAgICAgICBsZXQgaSA9IHUzMihmbG9vcihzY3JlZW5VVi54ICogY2x1c3RlcnNVbmlmb3JtLmNsdXN0ZXJUaWxlWCkpIDtcbiAgICAgICAgbGV0IGogPSB1MzIoZmxvb3Ioc2NyZWVuVVYueSAqIGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVkpICk7XG5cbiAgICAgICAgcmV0dXJuIHZlYzM8dTMyPihpLGoselRpbGUpO1xuICAgIH1cblxuICAgIGZuIGdldENsdXN0ZXIoKSAtPiBMaWdodEluZGV4IHtcbiAgICAgICAgbGV0IHRpbGUgPSBnZXRDbHVzdGVySWQzKCk7XG4gICAgICAgIGxldCBpZCA9IHRpbGUueCArXG4gICAgICAgICAgICB0aWxlLnkgKiB1MzIoY2x1c3RlcnNVbmlmb3JtLmNsdXN0ZXJUaWxlWCkgK1xuICAgICAgICAgICAgdGlsZS56ICogdTMyKGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVgpICogdTMyKGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVkpO1xuICAgICAgICByZXR1cm4gYXNzaWduVGFibGVbaWRdO1xuICAgIH1cblxuICAgIGZuIGdldENsdXN0ZXJJbmRleCgpIC0+IHUzMiB7XG4gICAgICAgIGxldCB0aWxlID0gZ2V0Q2x1c3RlcklkMygpO1xuICAgICAgICBsZXQgaWQgPSB0aWxlLnggK1xuICAgICAgICAgICAgdGlsZS55ICogdTMyKGNsdXN0ZXJzVW5pZm9ybS5jbHVzdGVyVGlsZVgpICtcbiAgICAgICAgICAgIHRpbGUueiAqIHUzMihjbHVzdGVyc1VuaWZvcm0uY2x1c3RlclRpbGVYKSAqIHUzMihjbHVzdGVyc1VuaWZvcm0uY2x1c3RlclRpbGVZKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbmAseGM9YFxuICAgICNpbmNsdWRlIFwiV29ybGRNYXRyaXhVbmlmb3JtXCJcbiAgICAjaW5jbHVkZSBcIkdsb2JhbFVuaWZvcm1cIlxuXG4gICAgc3RydWN0IFZlcnRleE91dHB1dCB7XG4gICAgICAgIEBsb2NhdGlvbigwKSBmcmFnVVY6IHZlYzI8ZjMyPixcbiAgICAgICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBtZW1iZXI6IHZlYzQ8ZjMyPlxuICAgIH07XG5cbiAgICBAdmVydGV4XG4gICAgZm4gbWFpbihAYnVpbHRpbihpbnN0YW5jZV9pbmRleCkgaW5kZXggOiB1MzIsIEBsb2NhdGlvbigwKSBwb3NpdGlvbjogdmVjMzxmMzI+LCBAbG9jYXRpb24oMSkgVEVYQ09PUkRfMTogdmVjMjxmMzI+KSAtPiBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICBsZXQgaWQgPSB1MzIoaW5kZXgpO1xuICAgICAgICBsZXQgd29ybGRNYXRyaXggPSBtb2RlbHMubWF0cml4W2lkXTtcblxuICAgICAgICBsZXQgc2NyZWVuUG9zID0gdmVjMigoKFRFWENPT1JEXzEgKiAyLjApIC0gdmVjMjxmMzI+KDEuMCkpKSAqIDAuNSA7IFxuICAgICAgICByZXR1cm4gVmVydGV4T3V0cHV0KFRFWENPT1JEXzEsIHZlYzQ8ZjMyPihzY3JlZW5Qb3MsIDAuMCwgMS4wKSk7XG4gICAgfVxuYCx2Yz1gXG4jdmVyc2lvbiA0NTBcblxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMiBmcmFnVVY7XG5cbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IG9fVGFyZ2V0O1xuXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIHVuaWZvcm0gQ29uc3RVbmlmb3JtIHtcbiAgICBtYXQ0IHByb2pNYXQ7XG4gICAgbWF0NCB2aWV3TWF0O1xuICAgIG1hdDQgc2hhZG93TWF0cml4O1xuICAgIG1hdDQgY2FtZXJhV29ybGRNYXRyaXg7XG4gICAgbWF0NCBwdk1hdHJpeEludjtcbiAgICBmbG9hdCBmcmFtZTtcbiAgICBmbG9hdCB0aW1lO1xuICAgIGZsb2F0IGRlbHRhO1xuICAgIGZsb2F0IHNoYWRvd0JpYXM7XG4gICAgZmxvYXQgc2t5RXhwb3N1cmU7XG4gICAgZmxvYXQgcmVuZGVyUGFzc1N0YXRlO1xuICAgIGZsb2F0IHF1YWRTY2FsZTtcblxufTtcblxubGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIHNhbXBsZXIgYmFzZU1hcFNhbXBsZXI7XG5sYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDEpIHVuaWZvcm0gdGV4dHVyZTJEIGJhc2VNYXA7XG5sYXlvdXQoc2V0ID0gMywgYmluZGluZyA9IDApIHVuaWZvcm0gTWF0ZXJpYWxEYXRhVW5pZm9ybSB7XG4gICAgdmVjNCBjb2xvcjtcbn07XG5cbnZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiB1diA9IGZyYWdVVi54eTtcbiAgICB1di55ID0gMS4wIC0gdXYueTtcbiAgICAgICAgdmVjNCBjb2xvclRleHR1cmUgPSB0ZXh0dXJlKHNhbXBsZXIyRChiYXNlTWFwLCBiYXNlTWFwU2FtcGxlciksIHV2ICogcXVhZFNjYWxlKSAqIGNvbG9yO1xuICAgIG9fVGFyZ2V0ID0gdmVjNChjb2xvclRleHR1cmUucmdiLCBjb2xvclRleHR1cmUuYSk7XG5cbiAgICBpZiAob19UYXJnZXQuciA8PSAwLjUgJiYgb19UYXJnZXQuZyA8PSAwLjUgJiYgb19UYXJnZXQuYiA8PSAwLjUpIHtcbiAgICAgICAgZGlzY2FyZDtcbiAgICB9XG4gICAgLy8gZmxvYXQgZ2FtbWEgICAgID0gMi4yO1xuICAgIC8vIGZsb2F0IGV4cG9zdXJlICA9IDEuMDtcbiAgICAvLyBmbG9hdCBwdXJlV2hpdGUgPSAxLjA7XG5cbiAgICAvLyBmbG9hdCBsdW1pbmFuY2UgPSBkb3QoY29sb3JUZXh0dXJlLnJnYiwgdmVjMygwLjIxMjYsIDAuNzE1MiwgMC4wNzIyKSk7XG4gICAgLy8gZmxvYXQgbWFwcGVkTHVtaW5hbmNlID0gKGx1bWluYW5jZSAqICgxLjAgKyBsdW1pbmFuY2UvKHB1cmVXaGl0ZSpwdXJlV2hpdGUpKSkgLyAoMS4wICsgbHVtaW5hbmNlKTtcblxuICAgIC8vIC8vIFNjYWxlIGNvbG9yIGJ5IHJhdGlvIG9mIGF2ZXJhZ2UgbHVtaW5hbmNlcy5cbiAgICAvLyB2ZWMzIG1hcHBlZENvbG9yID0gKG1hcHBlZEx1bWluYW5jZSAvIGx1bWluYW5jZSkgKiBjb2xvclRleHR1cmUucmdiO1xuXG4gICAgLy8gLy8gR2FtbWEgY29ycmVjdGlvbi5cbiAgICAvLyBvX1RhcmdldCA9IHZlYzQocG93KG9fVGFyZ2V0LnJnYiwgdmVjMygxLjAvZ2FtbWEpKSwgMS4wKTtcbn07XG5gLGpnPWBcbiN2ZXJzaW9uIDQ1MFxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMyBwb3NpdGlvbjtcbmxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzMgbm9ybWFsO1xubGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMiB1djtcblxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzIgZnJhZ1VWO1xubGF5b3V0KGxvY2F0aW9uID0gMSkgb3V0IHZlYzQgdldvcmxkUG9zO1xubGF5b3V0KGxvY2F0aW9uID0gMikgb3V0IHZlYzMgdldvcmxkTm9ybWFsO1xuXG5sYXlvdXQoc2V0ID0gMCwgYmluZGluZyA9IDApIFxudW5pZm9ybSBDb25zdFVuaWZvcm0ge1xuICAgIG1hdDQgcHJvak1hdDtcbiAgICBtYXQ0IHZpZXdNYXQ7XG4gICAgbWF0NCBzaGFkb3dNYXRyaXg7XG59O1xuXG5sYXlvdXQoc2V0ID0gMSwgYmluZGluZyA9IDApIFxuYnVmZmVyIFVuaWZvcm1zIHtcbiAgICBtYXQ0W10gbW9kZU1hdDtcbn07XG5cbiBtYXQ0IGludmVyc2UoIGluIG1hdDQgbSApe1xuICAgIHJldHVybiBtYXQ0KFxuICAgICAgICBtWzBdWzBdLCBtWzFdWzBdLCBtWzJdWzBdLCAwLjAsXG4gICAgICAgIG1bMF1bMV0sIG1bMV1bMV0sIG1bMl1bMV0sIDAuMCxcbiAgICAgICAgbVswXVsyXSwgbVsxXVsyXSwgbVsyXVsyXSwgMC4wLFxuICAgICAgICAtZG90KG1bMF0ueHl6LG1bM10ueHl6KSxcbiAgICAgICAgLWRvdChtWzFdLnh5eixtWzNdLnh5eiksXG4gICAgICAgIC1kb3QobVsyXS54eXosbVszXS54eXopLFxuICAgICAgICAxLjAgKTtcbn1cblxudm9pZCBtYWluKCl7XG4gICAgZnJhZ1VWID0gdXY7XG4gICAgbWF0NCBtb2RlbE1hdCA9IG1vZGVNYXRbZ2xfSW5zdGFuY2VJRF07IFxuICAgIG1hdDQgdm0gPSB2aWV3TWF0ICogbW9kZWxNYXQ7XG5cdG1hdDMgbm9ybWFsTWF0cml4ID0gbWF0Myh2bVswXS54eXosdm1bMV0ueHl6LHZtWzJdLnh5eik7XG5cdHZlYzMgZU5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XG4gICAgXG4gICAgdldvcmxkUG9zID0gbW9kZWxNYXQgKiB2ZWM0KHBvc2l0aW9uLnh5eiwxLjApIDtcblxuICAgIG1hdDQgZml4ZWRWaWV3TWF0ID0gdmlld01hdCA7XG4gICAgZml4ZWRWaWV3TWF0WzNdID0gdmVjNCgwLjAsMC4wLC04LjAsMS4wKTtcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbE1hdCAqIHZlYzQoIHBvc2l0aW9uLnh5eiwgMS4wICk7XG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0ICogZml4ZWRWaWV3TWF0ICogbXZQb3NpdGlvbjtcbn1cblxuYCxxZz1gXG4jdmVyc2lvbiA0NTBcblxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMiBmcmFnVVY7XG5sYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWM0IHZXb3JsZFBvcztcbmxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzMgdldvcmxkTm9ybWFsO1xuXG5sYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBvX1RhcmdldDtcblxubGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSBcbnVuaWZvcm0gc2FtcGxlciBiYXNlTWFwU2FtcGxlcjtcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMSkgXG51bmlmb3JtIHRleHR1cmUyRCBiYXNlTWFwO1xuXG5sYXlvdXQoc2V0ID0gMywgYmluZGluZyA9IDApIHVuaWZvcm0gdW5pZm9ybURhdGEge1xuICAgIHZlYzMgZXllc1BvcztcbiAgICBmbG9hdCBleHBvc3VyZTtcbiAgICBmbG9hdCByb3VnaG5lc3M7XG59O1xuXG52ZWMzIExpbmVhclRvR2FtbWFTcGFjZShpbiB2ZWMzIGxpblJHQilcbntcbiAgICB2ZWMzIF9saW5SR0IgPSB2ZWMzKGxpblJHQikgO1xuICAgIF9saW5SR0IgPSBtYXgobGluUkdCLCB2ZWMzKDAuMCwgMC4wLCAwLjApKTtcbiAgICBfbGluUkdCLnIgPSBwb3cobGluUkdCLnIsMC40MTY2NjY2NjcpO1xuICAgIF9saW5SR0IuZyA9IHBvdyhsaW5SR0IuZywwLjQxNjY2NjY2Nyk7XG4gICAgX2xpblJHQi5iID0gcG93KGxpblJHQi5iLDAuNDE2NjY2NjY3KTtcbiAgICByZXR1cm4gbWF4KDEuMDU1ICogX2xpblJHQiAtIDAuMDU1LCB2ZWMzKDAuMCkpO1xufVxuXG52b2lkIG1haW4oKXtcbiAgICBpbnQgbWF4TWlwTGV2ZWwgPSB0ZXh0dXJlUXVlcnlMZXZlbHMoYmFzZU1hcCwgZnJhZ1VWKS54IDtcbiAgICB2ZWM0IHRleHR1cmVDb2xvciA9IHRleHR1cmVDdWJlTG9kKCBzYW1wbGVyMkQoYmFzZU1hcCwgYmFzZU1hcFNhbXBsZXIpLCBub3JtYWxpemUodldvcmxkUG9zLnh5eiksIHJvdWdobmVzcyAqIGZsb2F0KG1heE1pcExldmVsKSApIDtcbiAgICBvX1RhcmdldCA9IHZlYzQoTGluZWFyVG9HYW1tYVNwYWNlKHRleHR1cmVDb2xvci5yZ2IpLDEuMCkgKiBleHBvc3VyZSA7XG59XG5cbmAsS2c9YFxuI3ZlcnNpb24gNDUwXG5cbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzIgZnJhZ1VWO1xuXG5sYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBvX1RhcmdldDtcblxubGF5b3V0KHNldCA9IDAsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIENvbnN0VW5pZm9ybSB7XG4gICAgbWF0NCBwcm9qTWF0O1xuICAgIG1hdDQgdmlld01hdDtcbiAgICBtYXQ0IHNoYWRvd01hdHJpeDtcbiAgICBtYXQ0IGNhbWVyYVdvcmxkTWF0cml4IDtcbiAgICBtYXQ0IHB2TWF0cml4SW52IDtcbiAgICBmbG9hdCBmcmFtZTtcbiAgICBmbG9hdCB0aW1lO1xuICAgIGZsb2F0IGRldGFpbDtcbiAgICBmbG9hdCBzaGFkb3dCaWFzO1xuICAgIGZsb2F0IHNreUV4cG9zdXJlO1xuICAgIGZsb2F0IHJlbmRlclBhc3NTdGF0ZTtcbiAgICBmbG9hdCBxdWFkU2NhbGU7XG4gICAgZmxvYXQgaW50ZW5zaXR5O1xufTtcblxubGF5b3V0KHNldCA9IDIsIGJpbmRpbmcgPSAwKSB1bmlmb3JtIHNhbXBsZXIgYmFzZU1hcFNhbXBsZXI7XG5sYXlvdXQoc2V0ID0gMiwgYmluZGluZyA9IDEpIHVuaWZvcm0gdGV4dHVyZTJEIGJhc2VNYXA7XG5cbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMikgdW5pZm9ybSBzYW1wbGVyIGx1dE1hcFNhbXBsZTtcbmxheW91dChzZXQgPSAyLCBiaW5kaW5nID0gMykgdW5pZm9ybSB0ZXh0dXJlMkQgbHV0TWFwO1xuXG5sYXlvdXQoc2V0ID0gMywgYmluZGluZyA9IDApIHVuaWZvcm0gVW5pZm9ybURhdGF7XG4gICAgZmxvYXQgaW50ZW5zaXR5IDtcbn07XG5cbnZvaWQgbWFpbigpIHtcbiAgICB2ZWMyIHV2ID0gZnJhZ1VWLnh5O1xuICAgIHV2LnkgPSAxLjAgLSB1di55O1xuICAgIHZlYzQgY29sID0gdGV4dHVyZShzYW1wbGVyMkQoYmFzZU1hcCwgYmFzZU1hcFNhbXBsZXIpLCB1diAqIHF1YWRTY2FsZSk7XG4gICAgLy8gdmVjMyBjb2wgPSB2ZWMzKHBvdyhiYXNlLnh5eix2ZWMzKDEuMC8yLjIpKSk7XG5cbiAgICBmbG9hdCBCY29sb3IgPSBjb2wuYiAqIDYzLjA7XG5cdHZlYzIgcXVhZDE7XG4gICAgcXVhZDEueSA9IGZsb29yKGZsb29yKEJjb2xvcikgLyA4LjApO1xuICAgIHF1YWQxLnggPSBmbG9vcihCY29sb3IpIC0gKHF1YWQxLnkgKiA4LjApO1xuXG4gICAgdmVjMiBxdWFkMjtcbiAgICBxdWFkMi55ID0gZmxvb3IoY2VpbChCY29sb3IpIC8gOC4wKTtcbiAgICBxdWFkMi54ID0gY2VpbChCY29sb3IpIC0gKHF1YWQyLnkgKiA4LjApO1xuXG4gICAgY29uc3QgZmxvYXQgdG1wID0gKDAuMTI1LSgwLjUvNTEyLjApKSA7XG4gICAgY29uc3QgZmxvYXQgdG1wMiA9IDAuNS81MTIuMCA7XG5cbiAgICB2ZWMyIHV2MTtcbiAgICB2ZWMyIHV2Mjtcblx0dXYxLnggPSAoKHF1YWQxLngpKjAuMTI1KSsgdG1wMiArICh0bXAqIGNvbC5yKTtcblx0dXYxLnkgPSAoKChxdWFkMS55KSowLjEyNSkgKyB0bXAyICsgKHRtcCogY29sLmcpKTtcblxuXHR1djIueCA9ICgocXVhZDIueCkqMC4xMjUpKyB0bXAyICsgKHRtcCogY29sLnIpO1xuXHR1djIueSA9ICgoKHF1YWQyLnkpKjAuMTI1KSsgdG1wMiArICh0bXAqIGNvbC5nKSk7XG5cbiAgICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUoc2FtcGxlcjJEKGx1dE1hcCwgbHV0TWFwU2FtcGxlKSwgdXYxKTtcbiAgICB2ZWM0IGNvbG9yMiA9IHRleHR1cmUoc2FtcGxlcjJEKGx1dE1hcCwgbHV0TWFwU2FtcGxlKSwgdXYyKTtcblxuICAgIHZlYzQgbmV3Q29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIGZyYWN0KEJjb2xvcikpO1xuICAgIC8vIHZlYzMgb3V0QyA9IHBvdyhuZXdDb2xvci54eXosdmVjMygyLjIpKTtcblxuICAgIG9fVGFyZ2V0ID0gdmVjNChuZXdDb2xvci5yZ2IsIGNvbC5hICk7XG4gICAgLy8gb19UYXJnZXQgPSB2ZWM0KDEuMCk7XG59XG5gO2NsYXNzIGVue31vKGVuLFwiT3JpX0FsbFNoYWRlclwiLGBcbiAgICAgICAgI2luY2x1ZGUgXCJDb21tb25fdmVydFwiXG4gICAgICAgICNpbmNsdWRlIFwiQ29tbW9uX2ZyYWdcIlxuICAgICAgICAjaW5jbHVkZSBcIkJ4REZfZnJhZ1wiXG5cbiAgICAgICAgZm4gdmVydChpbnB1dERhdGE6VmVydGV4QXR0cmlidXRlcykgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICAgIE9SSV9WZXJ0KGlucHV0RGF0YSkgO1xuICAgICAgICAgICAgcmV0dXJuIE9SSV9WZXJ0ZXhPdXQgO1xuICAgICAgICB9XG5cbiAgICAgICAgZm4gZnJhZygpe1xuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSBtYXRlcmlhbFVuaWZvcm0uYmFzZUNvbG9yIDtcbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuUm91Z2huZXNzID0gbWF0ZXJpYWxVbmlmb3JtLnJvdWdobmVzcyAgO1xuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5NZXRhbGxpYyA9IG1hdGVyaWFsVW5pZm9ybS5tZXRhbGxpYyA7XG4gICAgICAgICAgICBPUklfU2hhZGluZ0lucHV0LlNwZWN1bGFyID0gMC41IDtcbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuQW1iaWVudE9jY2x1c2lvbiA9IG1hdGVyaWFsVW5pZm9ybS5hbyA7XG4gICAgICAgICAgICBPUklfU2hhZGluZ0lucHV0LkVtaXNzaXZlQ29sb3IgPSB2ZWM0PGYzMj4oMC4wKTtcblxuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5Ob3JtYWwgPSBPUklfVmVydGV4VmFyeWluZy52V29ybGROb3JtYWwucmdiIDtcblxuICAgICAgICAgICAgI2lmIFVTRV9TSEFET1dNQVBJTkdcbiAgICAgICAgICAgICAgICB1c2VTaGFkb3coKTtcbiAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICBCeERGU2hhZGluZygpO1xuICAgICAgICB9XG4gICAgYCk7bGV0IHljPWBcbiAgICAjaW5jbHVkZSBcIkNvbW1vbl92ZXJ0XCJcbiAgICAjaW5jbHVkZSBcIkNvbW1vbl9mcmFnXCJcbiAgICAjaW5jbHVkZSBcIlVuTGl0X2ZyYWdcIlxuICAgICNpbmNsdWRlIFwiSXJyYWRpYW5jZV9mcmFnXCJcbiAgICAjaW5jbHVkZSBcIk1hdGhTaGFkZXJcIlxuICAgIFxuICAgIHN0cnVjdCBNYXRlcmlhbFVuaWZvcm0ge1xuICAgICAgcHJvYmVVbmlmb3JtOnZlYzQ8ZjMyPixcbiAgICB9O1xuXG4gICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApXG4gICAgdmFyPHVuaWZvcm0+IG1hdGVyaWFsVW5pZm9ybTogTWF0ZXJpYWxVbmlmb3JtO1xuXG4gICAgdmFyPHByaXZhdGU+IHByb2JlSUQ6IGkzMiA7XG4gICAgdmFyPHByaXZhdGU+IGRlYnVnVHlwZTogaTMyIDtcbiAgICBcbiAgICBmbiB2ZXJ0KGlucHV0RGF0YTpWZXJ0ZXhBdHRyaWJ1dGVzKSAtPiBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICBPUklfVmVydChpbnB1dERhdGEpIDtcbiAgICAgICAgcmV0dXJuIE9SSV9WZXJ0ZXhPdXQgO1xuICAgIH1cblxuICAgIGZuIGZyYWcoKXtcbiAgICAgICAgcHJvYmVJRCA9IGkzMihtYXRlcmlhbFVuaWZvcm0ucHJvYmVVbmlmb3JtLngpO1xuICAgICAgICBkZWJ1Z1R5cGUgPSBpMzIobWF0ZXJpYWxVbmlmb3JtLnByb2JlVW5pZm9ybS55KTtcbiAgICAgICAgaWYoZGVidWdUeXBlID09IDApe1xuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSBkZWJ1Z1Byb2JlKHByb2JlSUQpO1xuICAgICAgICB9ZWxzZSBpZihkZWJ1Z1R5cGUgPT0gMSl7XG4gICAgICAgICAgICBPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvciA9IGdldElycmFkaWFuY2UoKTtcbiAgICAgICAgfWVsc2UgaWYoZGVidWdUeXBlID09IDIpe1xuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSBkZWJ1Z1Byb2JlRGVwdGgocHJvYmVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgVW5MaXQoKTtcbiAgICB9XG4gICAgYCxDYz1gXG4gICAgI2luY2x1ZGUgXCJDb21tb25fdmVydFwiXG4gICAgI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiXG4gICAgI2luY2x1ZGUgXCJVbkxpdF9mcmFnXCJcbiAgICAjaW5jbHVkZSBcIlVuTGl0TWF0ZXJpYWxVbmlmb3JtX2ZyYWdcIlxuXG4gICAgLy8gQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgLy8gdmFyIG5vZXNfTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICAvLyBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAvLyB2YXIgbm9lc19NYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKVxuICAgIHZhciBzcGxpdFRleHR1cmVfTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICB2YXIgc3BsaXRUZXh0dXJlX01hcDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgZm4gdmVydChpbnB1dERhdGE6VmVydGV4QXR0cmlidXRlcykgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgT1JJX1ZlcnQoaW5wdXREYXRhKSA7XG4gICAgICAgIHJldHVybiBPUklfVmVydGV4T3V0IDtcbiAgICB9XG5cbiAgICBmbiBmcmFnKCl7XG4gICAgICAgIHZhciBzY3JlZW5VViA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdQb3NpdGlvbi54eSAvIE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdQb3NpdGlvbi53O1xuICAgICAgICBzY3JlZW5VViA9IChzY3JlZW5VVi54eSArIDEuMCkgKiAwLjU7XG4gICAgICAgIHNjcmVlblVWLnkgPSAxLjAgLSBzY3JlZW5VVi55O1xuXG4gICAgICAgIHNjcmVlblVWLnggPSBjbGFtcChzaW4oc2NyZWVuVVYueCAqIDEuMCksMC4wLDEuMCkgO1xuICAgICAgICBzY3JlZW5VVi55ID0gY2xhbXAoc2luKHNjcmVlblVWLnkgKiAxLjApLDAuMCwxLjApIDtcbiAgICAgICAgLy8gc2NyZWVuVVYueSA9IGNvcyhPUklfVmVydGV4VmFyeWluZy5mcmFnUG9zaXRpb24ueS83LjE1KTtcblxuICAgICAgICBsZXQgZnJhbWVNYXAgPSB0ZXh0dXJlU2FtcGxlKHNwbGl0VGV4dHVyZV9NYXAsc3BsaXRUZXh0dXJlX01hcFNhbXBsZXIsc2NyZWVuVVYpO1xuICAgICAgICAvLyBsZXQgbm9lc01hcCA9IHRleHR1cmVTYW1wbGUobm9lc19NYXAsbm9lc19NYXBTYW1wbGVyLHNjcmVlblVWKTtcblxuICAgICAgICBPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvciA9IHZlYzQ8ZjMyPiggZnJhbWVNYXAucmdiICwgMS4wKSA7XG4gICAgICAgIFVuTGl0KCk7XG4gICAgfVxuYCx3Yz1gXG4gICAgI2luY2x1ZGUgXCJDb21tb25fdmVydFwiXG4gICAgI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiXG4gICAgI2luY2x1ZGUgXCJDbHVzdGVyTGlnaHRcIlxuICAgICNpbmNsdWRlIFwiVW5MaXRfZnJhZ1wiXG4gICAgI2luY2x1ZGUgXCJVbkxpdE1hdGVyaWFsVW5pZm9ybV9mcmFnXCJcblxuICAgIEBncm91cCgxKSBAYmluZGluZygwKVxuICAgIHZhciBiYXNlTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMSlcbiAgICB2YXIgYmFzZU1hcDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgZm4gdmVydChpbnB1dERhdGE6VmVydGV4QXR0cmlidXRlcykgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgT1JJX1ZlcnQoaW5wdXREYXRhKSA7XG4gICAgICAgIHJldHVybiBPUklfVmVydGV4T3V0IDtcbiAgICB9XG5cbiAgICBmbiBmcmFnKCl7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1VVjEgPSBtYXRlcmlhbFVuaWZvcm0udHJhbnNmb3JtVVYxO1xuICAgICAgICB2YXIgdHJhbnNmb3JtVVYyID0gbWF0ZXJpYWxVbmlmb3JtLnRyYW5zZm9ybVVWMjtcblxuICAgICAgICB2YXIgdXYgPSB0cmFuc2Zvcm1VVjEuencgKiBPUklfVmVydGV4VmFyeWluZy5mcmFnVVYwICsgdHJhbnNmb3JtVVYxLnh5OyBcbiAgICAgICAgbGV0IGJhc2VDb2xvciA9IHRleHR1cmVTYW1wbGUoYmFzZU1hcCxiYXNlTWFwU2FtcGxlcix1dikgO1xuICAgICAgICBpZihiYXNlQ29sb3IudyA8IDAuNSl7XG4gICAgICAgICAgICBkaXNjYXJkIDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaWdodENvbG9yID0gdmVjNDxmMzI+KDAuMCk7XG4gICAgICAgIGxldCBsaWdodEluZGV4ID0gZ2V0Q2x1c3RlcigpO1xuICAgICAgICBsZXQgc3RhcnQgPSBtYXgobGlnaHRJbmRleC5zdGFydCwgMC4wKTtcbiAgICAgICAgbGV0IGNvdW50ID0gbWF4KGxpZ2h0SW5kZXguY291bnQsIDAuMCk7XG4gICAgICAgIGxldCBlbmQgPSBtYXgoc3RhcnQgKyBjb3VudCAsIDAuMCk7XG4gICAgICAgIGZvcih2YXIgaTppMzIgPSBpMzIoc3RhcnQpIDsgaSA8IGkzMihlbmQpOyBpICs9IDEgKVxuICAgICAgICB7XG4gICAgICAgICAgbGV0IGxpZ2h0ID0gZ2V0TGlnaHQoaTMyKGkpKTtcbiAgXG4gICAgICAgICAgc3dpdGNoIChsaWdodC5saWdodFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUG9pbnRMaWdodFR5cGU6IHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRGlyZWN0TGlnaHRUeXBlOiB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZE5vcm1hbCA7XG4gICAgICAgICAgICAgICAgbGV0IGludGVuc2l0eSA9IChsaWdodC5pbnRlbnNpdHkvMTAuMCk7XG4gICAgICAgICAgICAgICAgbGV0IGF0dCA9IG1heChkb3Qobm9ybWFsLC1saWdodC5kaXJlY3Rpb24pLDAuMCkgKiBpbnRlbnNpdHkgO1xuICAgICAgICAgICAgICAgIGxpZ2h0Q29sb3IgKz0gYmFzZUNvbG9yICogYXR0ICogMC41ICsgYmFzZUNvbG9yICogMC41IDsgXG4gICAgICAgICAgICAgICAgLy8gbGlnaHRDb2xvciA9IGJhc2VDb2xvciAqIDAuNTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNwb3RMaWdodFR5cGU6IHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuQmFzZUNvbG9yID0gbGlnaHRDb2xvciAqIG1hdGVyaWFsVW5pZm9ybS5iYXNlQ29sb3IgO1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvci53ID0gMS4wIDtcbiAgICAgICAgVW5MaXQoKTtcblxuICAgICAgICAvLyBsZXQgbiA9IGdsb2JhbFVuaWZvcm0ubmVhciA7XG4gICAgICAgIC8vIGxldCBmID0gZ2xvYmFsVW5pZm9ybS5mYXIgO1xuICAgICAgICAvLyBsZXQgeiA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdDb29yZC56IDtcbiAgICAgICAgLy8gT1JJX0ZyYWdtZW50T3V0cHV0Lm91dF9kZXB0aCA9IHogKiAobi8oZi1uKSkgO1xuICAgIH1cbmAsSmc9YFxuICAgICNpbmNsdWRlIFwiQ29tbW9uX3ZlcnRcIlxuICAgICNpbmNsdWRlIFwiQ29tbW9uX2ZyYWdcIlxuICAgICNpbmNsdWRlIFwiVW5MaXRfZnJhZ1wiXG5cbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMClcbiAgICB2YXIgYmFzZU1hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKDEpXG4gICAgdmFyIGJhc2VNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuXG4gICAgc3RydWN0IE1hdGVyaWFsVW5pZm9ybSB7XG4gICAgICAgIGJhc2VDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgIGxpbmVXZWlnaHQ6ZjMyXG4gICAgfTtcblxuICAgIEBncm91cCgyKSBAYmluZGluZygwKVxuICAgIHZhcjx1bmlmb3JtPiBtYXRlcmlhbFVuaWZvcm06IE1hdGVyaWFsVW5pZm9ybTtcblxuICAgIGZuIHZlcnQodmVydGV4OlZlcnRleEF0dHJpYnV0ZXMpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgIHZhciB2ZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHZlcnRleE5vcm1hbCA9IHZlcnRleC5ub3JtYWw7XG5cbiAgICAgICAgICAgICAgICAjaWYgVVNFX01PUlBIVEFSR0VUU1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleFBvc2l0aW9uICogbW9ycGhUYXJnZXREYXRhLm1vcnBoQmFzZUluZmx1ZW5jZSArIHZlcnRleC5hX21vcnBoUG9zaXRpb25zXzAgKiBtb3JwaFRhcmdldERhdGEubW9ycGhJbmZsdWVuY2UwO1xuICAgICAgICAgICAgICAgICAgICAjaWYgVVNFX01PUlBITk9STUFMU1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsID0gdmVydGV4Tm9ybWFsICogbW9ycGhUYXJnZXREYXRhLm1vcnBoQmFzZUluZmx1ZW5jZSArIHZlcnRleC5hX21vcnBoTm9ybWFsc18wICogbW9ycGhUYXJnZXREYXRhLm1vcnBoSW5mbHVlbmNlMDtcbiAgICAgICAgICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICAjaWYgVVNFX1NLRUxFVE9OXG4gICAgICAgICAgICAgICAgICAgICNpZiBVU0VfSk9JTlRfVkVDOFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNrZWxldG9uTm9ybWFsID0gZ2V0U2tlbGV0b25Xb3JsZE1hdHJpeF84KHZlcnRleC5qb2ludHMwLCB2ZXJ0ZXgud2VpZ2h0czAsIHZlcnRleC5qb2ludHMxLCB2ZXJ0ZXgud2VpZ2h0czEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgT1JJX01BVFJJWF9NICo9IHNrZWxldG9uTm9ybWFsIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlcnRleE5vcm1hbCA9IHZlYzQ8ZjMyPih2ZWM0PGYzMj4odmVydGV4Tm9ybWFsLDAuMCkgKiBza2VsZXRvbk5vcm1hbCkueHl6OyBcbiAgICAgICAgICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBza2VsZXRvbk5vcm1hbCA9IGdldFNrZWxldG9uV29ybGRNYXRyaXhfNCh2ZXJ0ZXguam9pbnRzMCwgdmVydGV4LndlaWdodHMwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9SSV9NQVRSSVhfTSAqPSBza2VsZXRvbk5vcm1hbCA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZXJ0ZXhOb3JtYWwgPSB2ZWM0PGYzMj4odmVjNDxmMzI+KHZlcnRleE5vcm1hbCwwLjApICogc2tlbGV0b25Ob3JtYWwpLnh5ejsgXG4gICAgICAgICAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgICAgICNlbmRpZlxuXG5cbiAgICAgICAgICAgICAgICAjaWYgVVNFX1RBTkdFTlRcbiAgICAgICAgICAgICAgICAgICAgT1JJX1ZlcnRleE91dC52YXJ5aW5nX1RhbmdlbnQgPSB2ZXJ0ZXguVEFOR0VOVCA7XG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICBPUklfTk9STUFMTUFUUklYID0gdHJhbnNwb3NlKGludmVyc2UoIG1hdDN4MzxmMzI+KE9SSV9NQVRSSVhfTVswXS54eXosT1JJX01BVFJJWF9NWzFdLnh5eixPUklfTUFUUklYX01bMl0ueHl6KSApKTtcblxuICAgICAgICAgICAgICAgIGxldCB3b3JsZE5vcm1hbCA9IG5vcm1hbGl6ZShPUklfTk9STUFMTUFUUklYICogdmVydGV4Tm9ybWFsLnh5eikgO1xuXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb24gPSB2ZXJ0ZXhQb3NpdGlvbiArIHdvcmxkTm9ybWFsICogbWF0ZXJpYWxVbmlmb3JtLmxpbmVXZWlnaHQgO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkUG9zID0gKE9SSV9NQVRSSVhfTSAqIHZlYzQ8ZjMyPih2ZXJ0ZXhQb3NpdGlvbi54eXosIDEuMCkpO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3UG9zaXRpb24gPSBPUklfTUFUUklYX1YgKiB3b3JsZFBvcztcbiAgICAgICAgICAgICAgICB2YXIgY2xpcFBvc2l0aW9uID0gT1JJX01BVFJJWF9QICogdmlld1Bvc2l0aW9uIDtcblxuICAgICAgICAgICAgICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19VVjAgPSB2ZXJ0ZXgudXYueHkgO1xuICAgICAgICAgICAgICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19VVjEgPSB2ZXJ0ZXguVEVYQ09PUkRfMS54eTtcbiAgICAgICAgICAgICAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfVmlld1BvcyA9IHZpZXdQb3NpdGlvbiAvIHZpZXdQb3NpdGlvbi53O1xuICAgICAgICAgICAgICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19DbGlwID0gY2xpcFBvc2l0aW9uIDtcbiAgICAgICAgICAgICAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfV1BvcyA9IHdvcmxkUG9zIDtcbiAgICAgICAgICAgICAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfV1Bvcy53ID0gZjMyKHZlcnRleC5pbmRleCk7XG4gICAgICAgICAgICAgICAgT1JJX1ZlcnRleE91dC52YXJ5aW5nX1dOb3JtYWwgPSB3b3JsZE5vcm1hbCA7XG4gICAgICAgICAgICAgICAgT1JJX1ZlcnRleE91dC5tZW1iZXIgPSBjbGlwUG9zaXRpb24gO1xuXG5cbiAgICAgICAgcmV0dXJuIE9SSV9WZXJ0ZXhPdXQgO1xuICAgIH1cblxuICAgIGZuIGZyYWcoKXtcbiAgICAgICAgbGV0IGNvbG9yID0gdGV4dHVyZVNhbXBsZShiYXNlTWFwLGJhc2VNYXBTYW1wbGVyLE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdVVjApIDtcbiAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSBjb2xvciAqIG1hdGVyaWFsVW5pZm9ybS5iYXNlQ29sb3IgO1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0LlJvdWdobmVzcyA9IDAuNSAgO1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0Lk1ldGFsbGljID0gMC41IDtcbiAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5TcGVjdWxhciA9IDAuNSA7XG4gICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuQW1iaWVudE9jY2x1c2lvbiA9IDEuMCA7XG4gICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuRW1pc3NpdmVDb2xvciA9IHZlYzQ8ZjMyPigwLjApO1xuICAgICAgICBPUklfU2hhZGluZ0lucHV0Lk5vcm1hbCA9IE9SSV9WZXJ0ZXhWYXJ5aW5nLnZXb3JsZE5vcm1hbC5yZ2IgO1xuICAgICAgICBVbkxpdCgpO1xuICAgIH1cbmAsWmc9YFxuICAgICAgICAjaW5jbHVkZSBcIkNvbW1vbl92ZXJ0XCJcbiAgICAgICAgI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiXG4gICAgICAgICNpbmNsdWRlIFwiQnhERl9mcmFnXCJcblxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIHJ0Q29sb3JUZXg6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIGJhc2VNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIG5vcm1hbE1hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKVxuICAgICAgICB2YXIgbm9ybWFsTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgICAgIHZhciBkaXNwbGFjZU1hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKVxuICAgICAgICB2YXIgZGlzcGxhY2VNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIGFvTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4gICAgICAgIHZhciBhb01hcDogdGV4dHVyZV8yZDxmMzI+O1xuIFxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIHJlZmxlY3RNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIHJlZmxlY3RNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcblxuICAgICAgICBmbiB2ZXJ0KGlucHV0RGF0YTpWZXJ0ZXhBdHRyaWJ1dGVzKSAtPiBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICAgICAgT1JJX1ZlcnQoaW5wdXREYXRhKSA7XG4gICAgICAgICAgICAvLyBsZXQgZGlzcGxhY2VEaW1lbnNpb25zID0gdGV4dHVyZURpbWVuc2lvbnMoZGlzcGxhY2VNYXApIDtcbiAgICAgICAgICAgIC8vIGxldCBkaXNwbGFjZSA9IHRleHR1cmVHYXRoZXIoMCxkaXNwbGFjZU1hcCxkaXNwbGFjZU1hcFNhbXBsZXIsaW5wdXREYXRhLnV2KSA7XG4gICAgICAgICAgICAvLyBPUklfVmVydGV4T3V0Lm1lbWJlci55ICs9IGRpc3BsYWNlLnIgKiAxMC4wO1xuICAgICAgICAgICAgcmV0dXJuIE9SSV9WZXJ0ZXhPdXQgO1xuICAgICAgICB9XG5cbiAgICAgICAgZm4gZnJhZygpe1xuICAgICAgICAgICAgdmFyIHNjcmVlblVWID0gT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ1Bvc2l0aW9uLnh5IC8gT1JJX1ZlcnRleFZhcnlpbmcuZnJhZ1Bvc2l0aW9uLnc7XG4gICAgICAgICAgICBzY3JlZW5VViA9IChzY3JlZW5VVi54eSArIDEuMCkgKiAwLjU7XG4gICAgICAgICAgICBzY3JlZW5VVi55ID0gMS4wIC0gc2NyZWVuVVYueTtcblxuICAgICAgICAgICAgbGV0IEZyYW1lTWFwID0gdGV4dHVyZVNhbXBsZShydENvbG9yVGV4LGJhc2VNYXBTYW1wbGVyLHNjcmVlblVWKTtcblxuICAgICAgICAgICAgbGV0IEFsYmVkbyA9IHRleHR1cmVTYW1wbGUoYmFzZU1hcCxiYXNlTWFwU2FtcGxlcixPUklfVmVydGV4VmFyeWluZy5mcmFnVVYwKTtcbiAgICAgICAgICAgIHZhciBOb3JtYWwgPSB0ZXh0dXJlU2FtcGxlKG5vcm1hbE1hcCxub3JtYWxNYXBTYW1wbGVyLE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdVVjApLnJnYiA7XG4gICAgICAgICAgICBOb3JtYWwueSA9IDEuMCAtIE5vcm1hbC55IDtcbiAgICAgICAgICAgIGxldCBEaXNwbGFjZSA9IHRleHR1cmVTYW1wbGUoZGlzcGxhY2VNYXAsZGlzcGxhY2VNYXBTYW1wbGVyLE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdVVjApLnJnYiA7XG4gICAgICAgICAgICBsZXQgQW8gPSB0ZXh0dXJlU2FtcGxlKGFvTWFwLGFvTWFwU2FtcGxlcixPUklfVmVydGV4VmFyeWluZy5mcmFnVVYwKS5yIDtcbiAgICAgICAgICAgIGxldCBSZWZsZWN0TWFwID0gMS4wIC0gdGV4dHVyZVNhbXBsZShyZWZsZWN0TWFwLHJlZmxlY3RNYXBTYW1wbGVyLE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdVVjApLnIgO1xuXG4gICAgICAgICAgICBPUklfU2hhZGluZ0lucHV0LkJhc2VDb2xvciA9IEZyYW1lTWFwICogbWF0ZXJpYWxVbmlmb3JtLmJhc2VDb2xvciAqIHZlYzQ8ZjMyPihMaW5lYXJUb0dhbW1hU3BhY2UoQWxiZWRvLnJnYiksMS4wKTtcbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuUm91Z2huZXNzID0gUmVmbGVjdE1hcCAqIG1hdGVyaWFsVW5pZm9ybS5yb3VnaG5lc3MgIDtcbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuTWV0YWxsaWMgPSBtYXRlcmlhbFVuaWZvcm0ubWV0YWxsaWMgO1xuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5TcGVjdWxhciA9IDAuNSA7XG4gICAgICAgICAgICBPUklfU2hhZGluZ0lucHV0LkFtYmllbnRPY2NsdXNpb24gPSBBbyAqIG1hdGVyaWFsVW5pZm9ybS5hbyA7XG4gICAgICAgICAgICBPUklfU2hhZGluZ0lucHV0LkVtaXNzaXZlQ29sb3IgPSB2ZWM0PGYzMj4oMC4wKTtcblxuICAgICAgICAgICAgbGV0IG5vcm1hbCA9IHVuUGFja1JHTm9ybWFsKE5vcm1hbCxEaXNwbGFjZS5yKm1hdGVyaWFsVW5pZm9ybS5ub3JtYWxTY2FsZSwxLjApIDtcbiAgICAgICAgICAgIE9SSV9TaGFkaW5nSW5wdXQuTm9ybWFsID0gbm9ybWFsIDtcblxuICAgICAgICAgICAgQnhERlNoYWRpbmcoKTtcbiAgICAgICAgfVxuICAgIGAsYmM9YFxuICAgICAgICAjaW5jbHVkZSBcIkNvbW1vbl92ZXJ0XCJcbiAgICAgICAgI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiXG4gICAgICAgICNpbmNsdWRlIFwiVW5MaXRfZnJhZ1wiXG5cbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pIHZhciBwb2ludFNoYWRvd01hcFNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgIEBncm91cCgxKSBAYmluZGluZyhhdXRvKSB2YXIgcG9pbnRTaGFkb3dNYXA6IHRleHR1cmVfZGVwdGhfY3ViZSA7XG5cbiAgICAgICAgc3RydWN0IE1hdGVyaWFsVW5pZm9ybSB7XG4gICAgICAgICAgICBjZW50ZXI6IHZlYzM8ZjMyPixcbiAgICAgICAgfTtcbiAgICAgIFxuICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMClcbiAgICAgICAgdmFyPHVuaWZvcm0+IG1hdGVyaWFsVW5pZm9ybTogTWF0ZXJpYWxVbmlmb3JtO1xuXG4gICAgICAgIGZuIHZlcnQoaW5wdXREYXRhOlZlcnRleEF0dHJpYnV0ZXMpIC0+IFZlcnRleE91dHB1dCB7XG4gICAgICAgICAgICBPUklfVmVydChpbnB1dERhdGEpIDtcbiAgICAgICAgICAgIHJldHVybiBPUklfVmVydGV4T3V0IDtcbiAgICAgICAgfVxuIFxuICAgICAgICBmbiBmcmFnKCl7XG5cbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBtYXRlcmlhbFVuaWZvcm0uY2VudGVyIDsgXG5cbiAgICAgICAgICAgIHZhciBkaXIgPSBub3JtYWxpemUoT1JJX1ZlcnRleFZhcnlpbmcudldvcmxkUG9zLnh5eiAtIGNlbnRlcikgO1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gdGV4dHVyZVNhbXBsZShwb2ludFNoYWRvd01hcCxwb2ludFNoYWRvd01hcFNhbXBsZXIsZGlyLnh5eikgO1xuICAgICAgICAgICAgZGVwdGggPSBkZXB0aCAqIGdsb2JhbFVuaWZvcm0uZmFyIDtcblxuICAgICAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSB2ZWM0PGYzMj4oZGVwdGgqMjU1LjAsMC4wLDAuMCwxLjApICA7XG4gICAgICAgICAgICBVbkxpdCgpO1xuICAgICAgICB9XG4gICAgYCx0bj1gXG4gICAgI2luY2x1ZGUgXCJDb21tb25fdmVydFwiXG4gICAgI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiXG4gICAgI2luY2x1ZGUgXCJVbkxpdF9mcmFnXCJcbiAgICAjaW5jbHVkZSBcIlVuTGl0TWF0ZXJpYWxVbmlmb3JtX2ZyYWdcIlxuXG4gICAgQGdyb3VwKDEpIEBiaW5kaW5nKDApXG4gICAgdmFyIGJhc2VNYXBTYW1wbGVyOiBzYW1wbGVyO1xuICAgIEBncm91cCgxKSBAYmluZGluZygxKVxuICAgIHZhciBiYXNlTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgICBmbiB2ZXJ0KGlucHV0RGF0YTpWZXJ0ZXhBdHRyaWJ1dGVzKSAtPiBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICBPUklfVmVydChpbnB1dERhdGEpIDtcbiAgICAgICAgcmV0dXJuIE9SSV9WZXJ0ZXhPdXQgO1xuICAgIH1cblxuICAgIGZuIGZyYWcoKXtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVVWMSA9IG1hdGVyaWFsVW5pZm9ybS50cmFuc2Zvcm1VVjE7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1VVjIgPSBtYXRlcmlhbFVuaWZvcm0udHJhbnNmb3JtVVYyO1xuXG4gICAgICAgIHZhciB1diA9IHRyYW5zZm9ybVVWMS56dyAqIE9SSV9WZXJ0ZXhWYXJ5aW5nLmZyYWdVVjAgKyB0cmFuc2Zvcm1VVjEueHk7IFxuICAgICAgICBsZXQgY29sb3IgPSB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsYmFzZU1hcFNhbXBsZXIsdXYpIDtcbiAgICAgICAgaWYoY29sb3IudyA8IDAuNSl7XG4gICAgICAgICAgICBkaXNjYXJkIDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgT1JJX1NoYWRpbmdJbnB1dC5CYXNlQ29sb3IgPSBjb2xvciAqIG1hdGVyaWFsVW5pZm9ybS5iYXNlQ29sb3IgO1xuICAgICAgICBVbkxpdCgpO1xuICAgIH1cbmAsJGc9YFxuICAgIHN0cnVjdCBNYXRlcmlhbFVuaWZvcm17XG4gICAgICAgI2lmIFVTRV9CUkRGXG4gICAgICAgICNpbmNsdWRlIFwiUGh5c2ljTWF0ZXJpYWxVbmlmb3JtX2ZyYWdcIlxuICAgICAgICNlbmRpZlxuXG4gICAgICAgI2lmIFVTRV9Db2xvckxpdFxuICAgICAgICNlbmRpZlxuXG4gICAgICAgI2lmIFVTRV9VbkxpdFxuICAgICAgICNlbmRpZlxuICAgIH1cblxuICAgIEBncm91cCgyKSBAYmluZGluZygwKVxuICAgIHZhcjx1bmlmb3JtPiBtYXRlcmlhbFVuaWZvcm06IE1hdGVyaWFsVW5pZm9ybTtcbmAsU2M9YFxuICAgICNpbmNsdWRlIFwiTWF0aFNoYWRlclwiXG5cbiAgICBmbiBidWlsZE1hdHJpeDN4MygpIC0+IG1hdDN4MzxmMzI+e1xuICAgICAgICB2YXIgbWF0MyA9IG1hdDN4MzxmMzI+KFxuICAgICAgICAgICAgMS4wLDAuMCwwLjAsXG4gICAgICAgICAgICAwLjAsMS4wLDAuMCxcbiAgICAgICAgICAgIDAuMCwwLjAsMS4wLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWF0MyA7XG4gICAgfVxuXG4gICAgZm4gYnVpbGRNYXRyaXg0eDQoKSAtPiBtYXQ0eDQ8ZjMyPntcbiAgICAgICAgdmFyIG1hdDQgPSBtYXQ0eDQ8ZjMyPihcbiAgICAgICAgICAgIDEuMCwwLjAsMC4wLDAuMCxcbiAgICAgICAgICAgIDAuMCwxLjAsMC4wLDAuMCxcbiAgICAgICAgICAgIDAuMCwwLjAsMS4wLDAuMCxcbiAgICAgICAgICAgIDAuMCwwLjAsMC4wLDEuMCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1hdDQgO1xuICAgIH1cblxuICAgIGZuIGJ1aWxkUm90YXRlWE1hdDMocmFkOmYzMikgLT4gbWF0M3gzPGYzMj57XG4gICAgICAgIHZhciB4cm90ID0gbWF0M3gzPGYzMj4oXG4gICAgICAgICAgICAxLjAsMC4wLDAuMCxcbiAgICAgICAgICAgIDAuMCxjb3MocmFkKSwtc2luKHJhZCksXG4gICAgICAgICAgICAwLjAsc2luKHJhZCksY29zKHJhZClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHhyb3Q7XG4gICAgfVxuXG4gICAgZm4gYnVpbGRSb3RhdGVYTWF0NChyYWQ6ZjMyLHg6ZjMyLHk6ZjMyLHo6ZjMyKSAtPiBtYXQ0eDQ8ZjMyPntcbiAgICAgICAgdmFyIHhyb3QgPSBtYXQ0eDQ8ZjMyPihcbiAgICAgICAgICAgIDEuMCwwLjAsMC4wLDAuMCxcbiAgICAgICAgICAgIDAuMCxjb3MocmFkKSwtc2luKHJhZCksMC4wLFxuICAgICAgICAgICAgMC4wLHNpbihyYWQpLGNvcyhyYWQpLDAuMCxcbiAgICAgICAgICAgIHgseSx6LDEuMCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHhyb3Q7XG4gICAgfVxuXG4gICAgZm4gYnVpbGRSb3RhdGVYWVpNYXQ0KHJhZFg6ZjMyLHJhZFk6ZjMyLHJhZFo6ZjMyLHg6ZjMyLHk6ZjMyLHo6ZjMyKSAtPiBtYXQ0eDQ8ZjMyPntcbiAgICAgICAgdmFyIHhSb3QgPSBtYXQ0eDQ8ZjMyPihcbiAgICAgICAgICAgIDEuMCwwLjAsMC4wLDAuMCxcbiAgICAgICAgICAgIDAuMCxjb3MocmFkWCksLXNpbihyYWRYKSwwLjAsXG4gICAgICAgICAgICAwLjAsc2luKHJhZFgpLGNvcyhyYWRYKSwwLjAsXG4gICAgICAgICAgICAwLjAsMC4wLDAuMCwxLjAsXG4gICAgICAgICk7XG4gICAgICAgIHZhciB5Um90ID0gbWF0NHg0PGYzMj4oXG4gICAgICAgICAgICBjb3MocmFkWSksMC4wLHNpbihyYWRZKSwwLjAsXG4gICAgICAgICAgICAwLjAsMS4wLDAuMCwwLjAsXG4gICAgICAgICAgICAtc2luKHJhZFkpLDAuMCxjb3MocmFkWSksMC4wLFxuICAgICAgICAgICAgMC4wLDAuMCwwLjAsMS4wLFxuICAgICAgICApO1xuICAgICAgICB2YXIgelJvdCA9IG1hdDR4NDxmMzI+KFxuICAgICAgICAgICAgY29zKHJhZFopLC1zaW4ocmFkWiksMC4wLDAuMCxcbiAgICAgICAgICAgIHNpbihyYWRaKSwgY29zKHJhZFopLDAuMCwwLjAsXG4gICAgICAgICAgICAwLjAsMC4wLDEuMCwwLjAsXG4gICAgICAgICAgICAwLjAsMC4wLDAuMCwxLjAsXG4gICAgICAgICk7XG4gICAgICAgIHZhciBmTWF0ID0geFJvdCAqIHlSb3QgKiB6Um90IDtcbiAgICAgICAgZk1hdFszXS54ID0geDtcbiAgICAgICAgZk1hdFszXS55ID0geTtcbiAgICAgICAgZk1hdFszXS56ID0gejtcbiAgICAgICAgcmV0dXJuIGZNYXQ7XG4gICAgfVxuXG4gICAgZm4gYnVpbGRSb3RhdGVZTWF0MyhyYWQ6ZjMyKSAtPiBtYXQzeDM8ZjMyPntcbiAgICAgICAgdmFyIHlyb3QgPSBtYXQzeDM8ZjMyPihcbiAgICAgICAgICAgIGNvcyhyYWQpLDAuMCxzaW4ocmFkKSxcbiAgICAgICAgICAgIDAuMCwxLjAsMC4wLFxuICAgICAgICAgICAgLXNpbihyYWQpLDAuMCxjb3MocmFkKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4geXJvdCA7XG4gICAgfVxuXG4gICAgZm4gYnVpbGRSb3RhdGVaKHJhZDpmMzIpIC0+IG1hdDN4MzxmMzI+e1xuICAgICAgICB2YXIgenJvdCA9IG1hdDN4MzxmMzI+KFxuICAgICAgICAgICAgY29zKHJhZCksLXNpbihyYWQpLDAuMCxcbiAgICAgICAgICAgIHNpbihyYWQpLCBjb3MocmFkKSwwLjAsXG4gICAgICAgICAgICAwLjAsMC4wLDEuMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4genJvdDtcbiAgICB9XG5cbiAgICAvLyBmbiBidWlsZFJvdGF0ZVhNYXQ0KHJhZDpmMzIpIC0+IG1hdDR4NDxmMzI+e1xuICAgIC8vICAgICB2YXIgeHJvdCA9IG1hdDR4NDxmMzI+KFxuICAgIC8vICAgICAgICAgMS4wLDAuMCwwLjAsMC4wLFxuICAgIC8vICAgICAgICAgMC4wLGNvcyhyYWQpLC1zaW4ocmFkKSwwLjAsXG4gICAgLy8gICAgICAgICAwLjAsc2luKHJhZCksY29zKHJhZCksMC4wLFxuICAgIC8vICAgICAgICAgMC4wLDAuMCwwLjAsMS4wKTtcbiAgICAvLyAgICAgcmV0dXJuIHhyb3Q7XG4gICAgLy8gfVxuXG4gICAgZm4gYnVsaWRUcmFuc2xhdGVNYXQ0KHg6ZjMyLHk6ZjMyLHo6ZjMyKSAtPiBtYXQ0eDQ8ZjMyPntcbiAgICAgICAgdmFyIHRyYW5zID0gbWF0NHg0PGYzMj4oXG4gICAgICAgICAgICAxLjAsMC4wLDAuMCwwLjAsXG4gICAgICAgICAgICAwLjAsMS4wLDAuMCwwLjAsXG4gICAgICAgICAgICAwLjAsMC4wLDEuMCwwLjAsXG4gICAgICAgICAgICB4LHkseiwxLjApO1xuICAgICAgICByZXR1cm4gdHJhbnM7XG4gICAgfVxuXG5gLEljPWBcbiAgICBzdHJ1Y3QgRnJhZ21lbnRPdXRwdXQge1xuICAgICAgICBAbG9jYXRpb24oMCkgb19UYXJnZXQ6IHZlYzQ8ZjMyPlxuICAgIH07XG5cbiAgICB2YXI8cHJpdmF0ZT4gdmFyeWluZ191djogdmVjMjxmMzI+O1xuICAgIEBncm91cCgxKSBAYmluZGluZygwKVxuICAgIHZhciBiYXNlTWFwU2FtcGxlcjogc2FtcGxlcjtcbiAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoMSlcbiAgICB2YXIgYmFzZU1hcDogdGV4dHVyZV8yZDxmMzI+O1xuXG4gICAgc3RydWN0IE1hdGVyaWFsVW5pZm9ybXtcbiAgICAgICAgdV90ZXhlbDogdmVjMjxmMzI+LFxuICAgICAgICB1X3N0cmVuZ3RoOiBmMzIsXG4gICAgfVxuXG4gICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApXG4gICAgdmFyPHVuaWZvcm0+IG1hdGVyaWFsVW5pZm9ybTogTWF0ZXJpYWxVbmlmb3JtO1xuXG5cbiAgICBmbiBMaW5lYXJUb0dhbW1hU3BhY2UobGluUkdCMDogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj4ge1xuICAgICAgICB2YXIgbGluUkdCID0gbWF4KGxpblJHQjAsIHZlYzMoMC4wLCAwLjAsIDAuMCkpO1xuICAgICAgICBsaW5SR0IuciA9IHBvdyhsaW5SR0IuciwwLjQxNjY2NjY2Nyk7XG4gICAgICAgIGxpblJHQi5nID0gcG93KGxpblJHQi5nLDAuNDE2NjY2NjY3KTtcbiAgICAgICAgbGluUkdCLmIgPSBwb3cobGluUkdCLmIsMC40MTY2NjY2NjcpO1xuICAgICAgICByZXR1cm4gbWF4KDEuMDU1ICogbGluUkdCIC0gMC4wNTUsIHZlYzMoMC4wLCAwLjAsIDAuMCkpO1xuICAgIH1cblxuICAgIGZuIHRleHR1cmUyRCggdXY6dmVjMjxmMzI+ICwgb2Zmc2V0OnZlYzI8ZjMyPiApIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlU2FtcGxlKGJhc2VNYXAsIGJhc2VNYXBTYW1wbGVyLCB1di54eSArIG9mZnNldCApLnJnYmEgO1xuICAgIH1cblxuICAgIEBmcmFnbWVudFxuICAgIGZuIG1haW4oQGxvY2F0aW9uKDApIGZyYWdVVjogdmVjMjxmMzI+KSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgICAgIHZhciB2X3ZUZXhjb29yZCA9IGZyYWdVViA7XG4gICAgICAgIC8vIHZfdlRleGNvb3JkLnggPSAxLjAgLSB2X3ZUZXhjb29yZC54IDtcbiAgICAgICAgdl92VGV4Y29vcmQueSA9IDEuMCAtIHZfdlRleGNvb3JkLnkgO1xuXG4gICAgICAgIHZhciByZWR1Y2VtdWwgPSAxLjAgLyA4LjA7XG4gICAgICAgIHZhciByZWR1Y2VtaW4gPSAxLjAgLyAxMjguMDtcblxuICAgICAgICB2YXIgYmFzZWNvbCA9IHRleHR1cmUyRCh2X3ZUZXhjb29yZCAsIHZlYzI8ZjMyPigwLjApKS5yZ2JhO1xuICAgICAgICB2YXIgYmFzZU5XID0gdGV4dHVyZTJEKHZfdlRleGNvb3JkICwgLW1hdGVyaWFsVW5pZm9ybS51X3RleGVsKS5yZ2I7XG4gICAgICAgIHZhciBiYXNlTkUgPSB0ZXh0dXJlMkQodl92VGV4Y29vcmQgLCB2ZWMyPGYzMj4obWF0ZXJpYWxVbmlmb3JtLnVfdGV4ZWwueCwgLW1hdGVyaWFsVW5pZm9ybS51X3RleGVsLnkpKS5yZ2I7XG4gICAgICAgIHZhciBiYXNlU1cgPSB0ZXh0dXJlMkQodl92VGV4Y29vcmQgLCB2ZWMyPGYzMj4oLW1hdGVyaWFsVW5pZm9ybS51X3RleGVsLngsIG1hdGVyaWFsVW5pZm9ybS51X3RleGVsLnkpKS5yZ2I7XG4gICAgICAgIHZhciBiYXNlU0UgPSB0ZXh0dXJlMkQodl92VGV4Y29vcmQgLCBtYXRlcmlhbFVuaWZvcm0udV90ZXhlbCApLnJnYjtcblxuICAgICAgICAvLyB2YXIgZ3JheSA9IHZlYzM8ZjMyPigwLjI5OSwgMC41ODcsIDAuMTE0KTtcbiAgICAgICAgdmFyIGdyYXkgPSB2ZWMzPGYzMj4oMC4yMTMsIDAuNzE1LCAwLjA3Mik7XG4gICAgICAgIHZhciBtb25vY29sID0gZG90KGJhc2Vjb2wucmdiLCBncmF5KTtcbiAgICAgICAgdmFyIG1vbm9OVyA9IGRvdChiYXNlTlcsIGdyYXkpO1xuICAgICAgICB2YXIgbW9ub05FID0gZG90KGJhc2VORSwgZ3JheSk7XG4gICAgICAgIHZhciBtb25vU1cgPSBkb3QoYmFzZVNXLCBncmF5KTtcbiAgICAgICAgdmFyIG1vbm9TRSA9IGRvdChiYXNlU0UsIGdyYXkpO1xuXG4gICAgICAgIHZhciBtb25vbWluID0gbWluKG1vbm9jb2wsIG1pbihtaW4obW9ub05XLCBtb25vTkUpLCBtaW4obW9ub1NXLCBtb25vU0UpKSk7XG4gICAgICAgIHZhciBtb25vbWF4ID0gbWF4KG1vbm9jb2wsIG1heChtYXgobW9ub05XLCBtb25vTkUpLCBtYXgobW9ub1NXLCBtb25vU0UpKSk7XG5cbiAgICAgICAgdmFyIGRpciA9IHZlYzI8ZjMyPigtKChtb25vTlcgKyBtb25vTkUpIC0gKG1vbm9TVyArIG1vbm9TRSkpLCAoKG1vbm9OVyArIG1vbm9TVykgLSAobW9ub05FICsgbW9ub1NFKSkpO1xuICAgICAgICB2YXIgZGlycmVkdWNlID0gbWF4KChtb25vTlcgKyBtb25vTkUgKyBtb25vU1cgKyBtb25vU0UpICogcmVkdWNlbXVsICogMC4yNSwgcmVkdWNlbWluKTtcbiAgICAgICAgdmFyIGRpcm1pbiA9IDEuMCAvIChtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJyZWR1Y2UpO1xuICAgICAgICBkaXIgPSBtaW4odmVjMjxmMzI+KG1hdGVyaWFsVW5pZm9ybS51X3N0cmVuZ3RoKSwgbWF4KHZlYzI8ZjMyPigtbWF0ZXJpYWxVbmlmb3JtLnVfc3RyZW5ndGgpLCBkaXIgKiBkaXJtaW4pKSAqIG1hdGVyaWFsVW5pZm9ybS51X3RleGVsO1xuXG4gICAgICAgIHZhciByZXN1bHRBID0gMC41ICogKHRleHR1cmUyRCh2X3ZUZXhjb29yZCAsIGRpciAqIC0wLjE2NjY2NykucmdiICArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHZfdlRleGNvb3JkICwgZGlyICogMC4xNjY2NjcpLnJnYik7XG4gICAgICAgIHZhciByZXN1bHRCID0gcmVzdWx0QSAqIDAuNSArIDAuMjUgKiAodGV4dHVyZTJEKCB2X3ZUZXhjb29yZCAsIGRpciAqIC0wLjUpLnJnYiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCggdl92VGV4Y29vcmQgLCBkaXIgKiAwLjUpLnJnYik7XG4gICAgICAgIHZhciBtb25vQiA9IGRvdChyZXN1bHRCLnJnYiwgZ3JheSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgY29sb3I6dmVjMzxmMzI+IDtcbiAgICAgICAgaWYobW9ub0IgPCBtb25vbWluIHx8IG1vbm9CID4gbW9ub21heCkge1xuICAgICAgICAgICAgY29sb3IgPSByZXN1bHRBIDsvLyogdl92Q29sb3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3IgPSByZXN1bHRCIDsvLyogdl92Q29sb3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGcmFnbWVudE91dHB1dCh2ZWM0PGYzMj4oY29sb3IucmdiLGJhc2Vjb2wuYSkpO1xuICAgIH1cbmAsRWM9YFxuc3RydWN0IEZyYWdtZW50T3V0cHV0IHtcbiAgICBAbG9jYXRpb24oMCkgb19UYXJnZXQ6IHZlYzQ8ZjMyPlxufTtcblxuJHtUc31cblxuI2luY2x1ZGUgXCJGYXN0TWF0aFNoYWRlclwiIFxuIFxuc3RydWN0IExpZ2h0RGF0YSB7XG4gICAgaW5kZXg6ZjMyLFxuICAgIGxpZ2h0VHlwZTppMzIsXG4gICAgcmFkaXVzOmYzMixcbiAgICBsaW5lYXI6ZjMyLFxuICAgIFxuICAgIHBvc2l0aW9uOnZlYzM8ZjMyPixcbiAgICBsaWdodE1hdHJpeEluZGV4OmYzMixcblxuICAgIGRpcmVjdGlvbjp2ZWMzPGYzMj4sXG4gICAgcXVhZHJhdGljOmYzMixcblxuICAgIGxpZ2h0Q29sb3I6dmVjMzxmMzI+LFxuICAgIGludGVuc2l0eTpmMzIsXG5cbiAgICBpbm5lckN1dE9mZiA6ZjMyLFxuICAgIG91dGVyQ3V0T2ZmOmYzMixcbiAgICByYW5nZSA6ZjMyLFxuICAgIGNhc3RTaGFkb3c6aTMyLFxuXG4gICAgbGlnaHRUYW5nZW50OnZlYzM8ZjMyPixcbiAgICBpZXM6ZjMyLFxufTtcblxuc3RydWN0IFVuaWZvcm1EYXRhIHtcbiAgICBmb2dDb2xvciA6IHZlYzQ8ZjMyPixcbiAgICBmb2dUeXBlIDogZjMyICxcbiAgICBmb2dIZWlnaHRTY2FsZSA6IGYzMiAsIFxuICAgIHN0YXJ0OiBmMzIsXG4gICAgZW5kOiBmMzIsXG4gICAgZGVuc2l0eSA6IGYzMiAsXG4gICAgaW5zIDogZjMyICxcbiAgICBmYWxsb2ZmIDogZjMyICxcbiAgICByYXlMZW5ndGggOiBmMzIgLFxuICAgIHNjYXR0ZXJpbmdFeHBvbmVudCA6IGYzMiAsXG4gICAgZGlySGVpZ2h0TGluZSA6IGYzMiAsXG4gICAgc2t5RmFjdG9yOiBmMzIsXG4gICAgc2t5Um91Z2huZXNzOiBmMzIsXG4gICAgb3ZlcnJpZGVTa3lGYWN0b3I6IGYzMixcbiAgICBpc1NreUhEUjogZjMyXG59O1xuXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMClcbnZhciBwb3NpdGlvbk1hcFNhbXBsZXI6IHNhbXBsZXI7XG5AZ3JvdXAoMSkgQGJpbmRpbmcoMSlcbnZhciBwb3NpdGlvbk1hcDogdGV4dHVyZV8yZDxmMzI+O1xuXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMilcbnZhciBjb2xvck1hcFNhbXBsZXI6IHNhbXBsZXI7XG5AZ3JvdXAoMSkgQGJpbmRpbmcoMylcbnZhciBjb2xvck1hcDogdGV4dHVyZV8yZDxmMzI+O1xuXG5AZ3JvdXAoMSkgQGJpbmRpbmcoNClcbnZhciBub3JtYWxNYXBTYW1wbGVyOiBzYW1wbGVyO1xuQGdyb3VwKDEpIEBiaW5kaW5nKDUpXG52YXIgbm9ybWFsTWFwOiB0ZXh0dXJlXzJkPGYzMj47XG5cbkBncm91cCgxKSBAYmluZGluZyg2KVxudmFyIHByZWZpbHRlck1hcFNhbXBsZXI6IHNhbXBsZXI7XG5AZ3JvdXAoMSkgQGJpbmRpbmcoNylcbnZhciBwcmVmaWx0ZXJNYXA6IHRleHR1cmVfY3ViZTxmMzI+O1xuXG5cbkBncm91cCgyKSBAYmluZGluZygwKVxudmFyPHVuaWZvcm0+IGdsb2JhbCA6IFVuaWZvcm1EYXRhO1xudmFyPHByaXZhdGU+IHZhcnlpbmdfdXY6IHZlYzI8ZjMyPjtcblxuQGdyb3VwKDIpIEBiaW5kaW5nKDEpXG52YXI8c3RvcmFnZSxyZWFkPiBsaWdodEJ1ZmZlcjogYXJyYXk8TGlnaHREYXRhPjtcblxudmFyPHByaXZhdGU+IHRleFBvc2l0aW9uOiB2ZWM0PGYzMj47XG52YXI8cHJpdmF0ZT4gdGV4Tm9ybWFsOiB2ZWM0PGYzMj47XG52YXI8cHJpdmF0ZT4gdGV4Q29sb3I6IHZlYzQ8ZjMyPjtcblxuZm4gTGluZWFyVG9HYW1tYVNwYWNlKGxpblJHQjogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj5cbntcbiAgICB2YXIgbGluUkdCMSA9IG1heChsaW5SR0IsIHZlYzM8ZjMyPigwLjApKTtcbiAgICBsaW5SR0IxID0gcG93KGxpblJHQjEsIHZlYzM8ZjMyPigwLjQxNjY2NjY1NjczMjU1OTIpKTtcbiAgICByZXR1cm4gbWF4KCgoMS4wNTQ5OTk5NDc1NDc5MTI2ICogbGluUkdCMSkgLSB2ZWMzPGYzMj4oMC4wNTQ5OTk5OTk3MDE5NzY3NzYpKSwgdmVjMzxmMzI+KDAuMCkpO1xufVxuXG5mbiBnZXRTa3lDb2xvcih3b3JsZFBvc2l0aW9uOnZlYzM8ZjMyPiwgc2t5Um91Z2huZXNzOmYzMiwgaXNIRFJUZXh0dXJlOmJvb2wpIC0+IHZlYzM8ZjMyPlxue1xuICAgIGxldCBjYW1lcmFQb3NpdGlvbiA9IHZlYzM8ZjMyPihnbG9iYWxVbmlmb3JtLmNhbWVyYVdvcmxkTWF0cml4WzNdLnh5eik7XG4gICAgbGV0IHJheURpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2ZWMzPGYzMj4od29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbikpO1xuICAgIGxldCBjYWxjUm91Z2huZXNzID0gY2xhbXAoc2t5Um91Z2huZXNzLCAwLjAsIDEuMCk7XG4gICAgbGV0IE1BWF9SRUZMRUNUSU9OX0xPRCAgPSBmMzIodGV4dHVyZU51bUxldmVscyhwcmVmaWx0ZXJNYXApKSA7XG4gICAgdmFyIHByZWZpbHRlckNvbG9yID0gdGV4dHVyZVNhbXBsZUxldmVsKHByZWZpbHRlck1hcCwgcHJlZmlsdGVyTWFwU2FtcGxlciwgcmF5RGlyZWN0aW9uLCBjYWxjUm91Z2huZXNzICogTUFYX1JFRkxFQ1RJT05fTE9EKTtcbiAgICBpZihpc0hEUlRleHR1cmUpe1xuICAgICAgICBwcmVmaWx0ZXJDb2xvciA9IHZlYzQ8ZjMyPihMaW5lYXJUb0dhbW1hU3BhY2UodmVjMzxmMzI+KHByZWZpbHRlckNvbG9yLnh5eikpLCBwcmVmaWx0ZXJDb2xvci53KTtcbiAgICB9XG4gICAgcmV0dXJuIHByZWZpbHRlckNvbG9yLnh5eiAqIGdsb2JhbFVuaWZvcm0uc2t5RXhwb3N1cmU7XG59XG5cbkBmcmFnbWVudFxuZm4gbWFpbihAbG9jYXRpb24oMCkgZnJhZ1VWOiB2ZWMyPGYzMj4sIEBidWlsdGluKHBvc2l0aW9uKSBjb29yZDogdmVjNDxmMzI+KSAtPiBGcmFnbWVudE91dHB1dCB7XG4gICAgdmFyIHRleENvb3JkID0gdmVjMjxmMzI+KGZyYWdVVi54LCAxLjAgLSBmcmFnVVYueSk7XG4gICAgdGV4UG9zaXRpb24gPSB0ZXh0dXJlU2FtcGxlKHBvc2l0aW9uTWFwLCBwb3NpdGlvbk1hcFNhbXBsZXIsIHRleENvb3JkKSA7XG4gICAgdGV4Tm9ybWFsID0gdGV4dHVyZVNhbXBsZShub3JtYWxNYXAsIG5vcm1hbE1hcFNhbXBsZXIsIHRleENvb3JkKSA7XG4gICAgdGV4Q29sb3IgPSB0ZXh0dXJlU2FtcGxlKGNvbG9yTWFwLCBjb2xvck1hcFNhbXBsZXIsIHRleENvb3JkKSA7XG4gIFxuICAgIHZhciBvcENvbG9yID0gdmVjMzxmMzI+KDAuMCk7XG4gICAgaWYodGV4Tm9ybWFsLncgPD0gMC41KXtcbiAgICAgICAgLy9mb3Igc2t5XG4gICAgICAgIGlmKGdsb2JhbC5vdmVycmlkZVNreUZhY3RvciA+IDAuMDEpe1xuICAgICAgICAgICAgb3BDb2xvciA9IGJsZW5kU2t5Q29sb3IoKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvcENvbG9yID0gdGV4Q29sb3IueHl6O1xuICAgICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAgIC8vZm9yIGdyb3VuZFxuICAgICAgICB2YXIgZm9nRmFjdG9yID0gY2FsY0ZvZ0ZhY3RvcigpO1xuICAgICAgICBpZihnbG9iYWwuc2t5RmFjdG9yID4gMC4wMSB8fCBnbG9iYWwub3ZlcnJpZGVTa3lGYWN0b3IgPiAwLjAxKXtcbiAgICAgICAgICAgIG9wQ29sb3IgPSBibGVuZEdyb3VuZENvbG9yKGZvZ0ZhY3Rvcik7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgb3BDb2xvciA9IG1peCh0ZXhDb2xvci5yZ2IsIGdsb2JhbC5mb2dDb2xvci54eXosIGZvZ0ZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VuTGlnaHQgPSBsaWdodEJ1ZmZlclswXSA7XG4gICAgICAgIHZhciBpblNjYXR0ZXJpbmdWYWx1ZSA9IGluU2NhdHRlckluZyhzdW5MaWdodC5kaXJlY3Rpb24sIHRleFBvc2l0aW9uLnh5eiwgc3VuTGlnaHQubGlnaHRDb2xvcik7XG4gICAgICAgIG9wQ29sb3IgKz0gaW5TY2F0dGVyaW5nVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudE91dHB1dCh2ZWM0PGYzMj4ob3BDb2xvci54eXosIHRleENvbG9yLmEpKTtcbn1cblxuZm4gY2FsY0ZvZ0ZhY3RvcigpIC0+IGYzMiBcbntcbiAgICB2YXIgY2FtZXJhUG9zID0gZ2xvYmFsVW5pZm9ybS5jYW1lcmFXb3JsZE1hdHJpeFszXS54eXogIDtcbiAgICBsZXQgZGlzID0gZGlzdGFuY2UoY2FtZXJhUG9zLCB0ZXhQb3NpdGlvbi54eXopO1xuICAgIHZhciBoZWlnaHRGYWN0b3IgPSBjb21wdXRlRm9nKGRpcykgKyBjRm9nKC10ZXhQb3NpdGlvbi55KTtcbiAgICByZXR1cm4gY2xhbXAoZ2xvYmFsLmlucyAqIGhlaWdodEZhY3RvciwwLjAsMS4wKTtcbn1cblxuICAgIFxuZm4gYmxlbmRHcm91bmRDb2xvcihmb2dGYWN0b3I6ZjMyKSAtPiB2ZWMzPGYzMj5cbntcbiAgICB2YXIgc2t5Q29sb3JCbHVyID0gZ2V0U2t5Q29sb3IodGV4UG9zaXRpb24ueHl6LCBnbG9iYWwuc2t5Um91Z2huZXNzLCBnbG9iYWwuaXNTa3lIRFIgPiAwLjUpO1xuICAgIGxldCBza3lGYWN0b3IgPSBjbGFtcChnbG9iYWwuc2t5RmFjdG9yIC0gZ2xvYmFsLm92ZXJyaWRlU2t5RmFjdG9yICogMC41LCAwLjAsIDEuMCk7XG4gICAgdmFyIGZvZ0NvbG9yID0gbWl4KGdsb2JhbC5mb2dDb2xvci54eXosIHNreUNvbG9yQmx1ciwgc2t5RmFjdG9yKTtcbiAgICByZXR1cm4gbWl4KHRleENvbG9yLnJnYiwgZm9nQ29sb3IucmdiLCBmb2dGYWN0b3IpO1xufVxuXG5mbiBibGVuZFNreUNvbG9yKCkgLT4gdmVjMzxmMzI+XG57XG4gICAgbGV0IG92ZXJyaWRlU2t5RmFjdG9yID0gc3FydChnbG9iYWwub3ZlcnJpZGVTa3lGYWN0b3IpO1xuICAgIHZhciBza3lDb2xvckJsdXIgPSBnZXRTa3lDb2xvcih0ZXhQb3NpdGlvbi54eXosIG92ZXJyaWRlU2t5RmFjdG9yICogMC4zLCBnbG9iYWwuaXNTa3lIRFIgPiAwLjUpO1xuICAgIHJldHVybiBtaXgoZ2xvYmFsLmZvZ0NvbG9yLnh5eiwgc2t5Q29sb3JCbHVyLCAxLjAgLSBvdmVycmlkZVNreUZhY3Rvcik7XG59XG5cblxuZm4gY29tcHV0ZUZvZyh6OmYzMikgLT4gZjMyIFxue1xuICAgIHZhciBmb2cgPSAwLjA7XG4gICAgaWYoIGdsb2JhbC5mb2dUeXBlIDwgMC41ICl7XG4gICAgICAgIGZvZyA9IChnbG9iYWwuZW5kIC0geikgLyAoZ2xvYmFsLmVuZCAtIGdsb2JhbC5zdGFydCk7XG4gICAgfWVsc2UgaWYoZ2xvYmFsLmZvZ1R5cGUgPCAxLjUgKXtcbiAgICAgICAgZm9nID0gZXhwMigtZ2xvYmFsLmRlbnNpdHkgKiB6KTtcbiAgICB9ZWxzZSBpZihnbG9iYWwuZm9nVHlwZSA9PSAyLjUgKXtcbiAgICAgICAgZm9nID0gZ2xvYmFsLmRlbnNpdHkgKiB6O1xuICAgICAgICBmb2cgPSBleHAyKC1mb2cgKiBmb2cpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4KGZvZywwLjApO1xufVxuXG4gIGZuIGNGb2coeTpmMzIpIC0+IGYzMiBcbiAge1xuICAgICBsZXQgZm9nRGVuc2l0eSA9IGdsb2JhbC5kZW5zaXR5ICogZXhwKGdsb2JhbC5mb2dIZWlnaHRTY2FsZSAqIHkpO1xuICAgICBsZXQgZm9nRmFjdG9yID0gKDEuMCAtIGV4cDIoLWdsb2JhbC5mYWxsb2ZmKSkgLyBnbG9iYWwuZmFsbG9mZiA7XG4gICAgIGxldCBmb2cgPSBmb2dEZW5zaXR5ICogZm9nRmFjdG9yICogbWF4KGdsb2JhbC5yYXlMZW5ndGggLSBnbG9iYWwuc3RhcnQsIDAuMCk7IFxuICAgICByZXR1cm4gbWF4KGZvZywwLjApO1xuICB9XG5cbiAgZm4gaW5TY2F0dGVySW5nKHN1bkRpcjp2ZWMzPGYzMj4sIHdvcmxkUG9zOnZlYzM8ZjMyPiwgc3VuQ29sb3I6dmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj4gXG4gIHtcbiAgICBsZXQgdmlld0RpciA9IG5vcm1hbGl6ZShnbG9iYWxVbmlmb3JtLkNhbWVyYVBvcy54eXogLSB3b3JsZFBvcy54eXopIDtcbiAgICBsZXQgVm9MID0gc2F0dXJhdGUoZG90KHZpZXdEaXIsc3VuRGlyKSkgO1xuICAgIHZhciBzY2F0dGVyID0gcG93KFZvTCxnbG9iYWwuc2NhdHRlcmluZ0V4cG9uZW50KTtcbiAgICBzY2F0dGVyICo9ICgxLjAtc2F0dXJhdGUoZXhwMigtZ2xvYmFsLmRpckhlaWdodExpbmUpKSk7XG4gICAgcmV0dXJuIHZlYzM8ZjMyPihzY2F0dGVyKnN1bkNvbG9yKTtcbiAgfVxuXG5gO2NsYXNzIHJue31vKHJuLFwiY3NcIixgXG4gICAgI2luY2x1ZGUgJ0NvbG9yVXRpbCdcbiAgICBzdHJ1Y3QgVW5pZm9ybURhdGEge1xuICAgICAgICB3aWR0aDogZjMyLFxuICAgICAgICBoZWlnaHQ6IGYzMixcbiAgICAgICAgc3VuVTogZjMyLFxuICAgICAgICBzdW5WOiBmMzIsXG4gICAgICAgIGV5ZVBvczogZjMyLFxuICAgICAgICBzdW5SYWRpdXM6IGYzMiwgICAgICAgICAvLyA9IDUwMC4wO1xuICAgICAgICBzdW5SYWRpYW5jZTogZjMyLCAgICAgICAvLyA9IDIwLjA7XG4gICAgICAgIG1pZUc6IGYzMiwgICAgICAgICAgICAgIC8vID0gMC43NjtcbiAgICAgICAgbWllSGVpZ2h0OiBmMzIsICAgICAgICAgLy8gPSAxMjAwO1xuICAgICAgICBzdW5CcmlnaHRuZXNzOiBmMzIsICAgICAvLyA9IDEuMDtcbiAgICAgICAgZGlzcGxheVN1bjogZjMyLCAgICAgICAgLy8gPiAwLjU6IHRydWVcbiAgICAgICAgc2t5Q29sb3I6IHZlYzQ8ZjMyPiwgICAgICAgIC8vIHNreSBjb2xvclxuICAgICAgfTtcblxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiB1bmlmb3JtQnVmZmVyOiBVbmlmb3JtRGF0YTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXIgb3V0VGV4dHVyZSA6IHRleHR1cmVfc3RvcmFnZV8yZDxyZ2JhMTZmbG9hdCwgd3JpdGU+O1xuXG4gICAgICB2YXI8cHJpdmF0ZT4gdXYwMTogdmVjMjxmMzI+O1xuICAgICAgdmFyPHByaXZhdGU+IGZyYWdDb29yZDogdmVjMjxpMzI+O1xuICAgICAgdmFyPHByaXZhdGU+IHRleFNpemVGMzI6IHZlYzI8ZjMyPjtcblxuICAgICAgdmFyPHByaXZhdGU+IFBJOmYzMiA9IDMuMTQxNTkyNjUzNTtcbiAgICAgIHZhcjxwcml2YXRlPiBQSV8yOmYzMiA9IDAuMDtcbiAgICAgIHZhcjxwcml2YXRlPiBFUFNJTE9OOmYzMiA9IDAuMDAwMDAwMTtcbiAgICAgIHZhcjxwcml2YXRlPiBTQU1QTEVTX05VTVM6aTMyID0gMTY7XG5cbiAgICAgIHZhcjxwcml2YXRlPiB0cmFuc21pdHRhbmNlOnZlYzM8ZjMyPjtcbiAgICAgIHZhcjxwcml2YXRlPiBpbnNjdHJNaWU6dmVjMzxmMzI+O1xuICAgICAgdmFyPHByaXZhdGU+IGluc2N0clJheWxlaWdoOnZlYzM8ZjMyPjtcblxuICAgICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCA4ICwgOCAsIDEgKVxuICAgICAgZm4gQ3NNYWluKCBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPiAsIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJbnZvY2F0aW9uX2lkIDogdmVjMzx1MzI+KVxuICAgICAge1xuICAgICAgICBmcmFnQ29vcmQgPSB2ZWMyPGkzMj4oZ2xvYmFsSW52b2NhdGlvbl9pZC54eSk7XG4gICAgICAgIHRleFNpemVGMzIgPSB2ZWMyPGYzMj4oIHVuaWZvcm1CdWZmZXIud2lkdGgsIHVuaWZvcm1CdWZmZXIuaGVpZ2h0KTtcbiAgICAgICAgdXYwMSA9IHZlYzI8ZjMyPihnbG9iYWxJbnZvY2F0aW9uX2lkLnh5KSAvIHRleFNpemVGMzI7XG4gICAgICAgIHV2MDEueSA9IDEuMCAtIHV2MDEueSAtIEVQU0lMT047XG4gICAgICAgIFBJXzIgPSBQSSAqIDIuMDtcbiAgICAgICAgdGV4dHVyZVN0b3JlKG91dFRleHR1cmUsIGZyYWdDb29yZCAsIG1haW5JbWFnZSh1djAxKSk7Ly92ZWM0KHV2MDEsIDAuMCwgMS4wKSk7XG4gICAgICB9XG5cbiAgICAgIHN0cnVjdCBTY2F0dGVyaW5nUGFyYW1zXG4gICAgICB7XG4gICAgICAgIHN1blJhZGl1czpmMzIsXG4gICAgICAgIHN1blJhZGlhbmNlOmYzMixcblxuICAgICAgICBtaWVHOmYzMixcbiAgICAgICAgbWllSGVpZ2h0OmYzMixcblxuICAgICAgICByYXlsZWlnaEhlaWdodDpmMzIsXG5cbiAgICAgICAgd2F2ZUxhbWJkYU1pZTp2ZWMzPGYzMj4sXG4gICAgICAgIHdhdmVMYW1iZGFPem9uZTp2ZWMzPGYzMj4sXG4gICAgICAgIHdhdmVMYW1iZGFSYXlsZWlnaDp2ZWMzPGYzMj4sXG5cbiAgICAgICAgZWFydGhSYWRpdXM6ZjMyLFxuICAgICAgICBlYXJ0aEF0bVRvcFJhZGl1czpmMzIsXG4gICAgICAgIGVhcnRoQ2VudGVyOnZlYzM8ZjMyPixcbiAgICAgIH1cblxuICAgICAgZm4gQ29tcHV0ZVNwaGVyZU5vcm1hbChjb29yZDp2ZWMyPGYzMj4sIHBoaVN0YXJ0OmYzMiwgcGhpTGVuZ3RoOmYzMiwgdGhldGFTdGFydDpmMzIsIHRoZXRhTGVuZ3RoOmYzMikgLT4gdmVjMzxmMzI+XG4gICAgICB7XG4gICAgICAgIHZhciBub3JtYWw6dmVjMzxmMzI+O1xuICAgICAgICBub3JtYWwueCA9IC1zaW4odGhldGFTdGFydCArIGNvb3JkLnkgKiB0aGV0YUxlbmd0aCkgKiBzaW4ocGhpU3RhcnQgKyBjb29yZC54ICogcGhpTGVuZ3RoKTtcbiAgICAgICAgbm9ybWFsLnkgPSAtY29zKHRoZXRhU3RhcnQgKyBjb29yZC55ICogdGhldGFMZW5ndGgpO1xuICAgICAgICBub3JtYWwueiA9IC1zaW4odGhldGFTdGFydCArIGNvb3JkLnkgKiB0aGV0YUxlbmd0aCkgKiBjb3MocGhpU3RhcnQgKyBjb29yZC54ICogcGhpTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShub3JtYWwpO1xuICAgICAgfVxuXG4gICAgICBmbiBDb21wdXRlUmF5U3BoZXJlSW50ZXJzZWN0aW9uKHBvc2l0aW9uOnZlYzM8ZjMyPiwgZGlyOnZlYzM8ZjMyPiwgY2VudGVyOnZlYzM8ZjMyPiwgcmFkaXVzOmYzMikgLT4gdmVjMjxmMzI+XG4gICAgICB7XG4gICAgICAgIHZhciBvcmlnaW46dmVjMzxmMzI+ID0gcG9zaXRpb24gLSBjZW50ZXI7XG4gICAgICAgIHZhciBCID0gZG90KG9yaWdpbiwgZGlyKTtcbiAgICAgICAgdmFyIEMgPSBkb3Qob3JpZ2luLCBvcmlnaW4pIC0gcmFkaXVzICogcmFkaXVzO1xuICAgICAgICB2YXIgRCA9IEIgKiBCIC0gQztcblxuICAgICAgICB2YXIgbWluaW1heEludGVyc2VjdGlvbnM6dmVjMjxmMzI+O1xuICAgICAgICBpZiAoRCA8IDAuMClcbiAgICAgICAge1xuICAgICAgICAgIG1pbmltYXhJbnRlcnNlY3Rpb25zID0gdmVjMjxmMzI+KC0xLjAsIC0xLjApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIEQgPSBzcXJ0KEQpO1xuICAgICAgICAgIG1pbmltYXhJbnRlcnNlY3Rpb25zID0gdmVjMjxmMzI+KC1CIC0gRCwgLUIgKyBEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW5pbWF4SW50ZXJzZWN0aW9ucztcbiAgICAgIH1cblxuICAgICAgZm4gQ29tcHV0ZVdhdmVMYW1iZGFSYXlsZWlnaChsYW1iZGE6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAgICB7XG4gICAgICAgIHZhciBuOmYzMiA9IDEuMDAwMztcbiAgICAgICAgdmFyIE46ZjMyID0gMi41NDVFMjU7XG4gICAgICAgIHZhciBwbjpmMzIgPSAwLjAzNTtcbiAgICAgICAgdmFyIG4yOmYzMiA9IG4gKiBuO1xuICAgICAgICB2YXIgcGkzOmYzMiA9IFBJICogUEkgKiBQSTtcbiAgICAgICAgdmFyIHJheWxlaWdoQ29uc3Q6ZjMyID0gKDguMCAqIHBpMyAqIHBvdyhuMiAtIDEuMCwyLjApKSAvICgzLjAgKiBOKSAqICgoNi4wICsgMy4wICogcG4pIC8gKDYuMCAtIDcuMCAqIHBuKSk7XG4gICAgICAgIHJldHVybiB2ZWMzPGYzMj4ocmF5bGVpZ2hDb25zdCkgLyAobGFtYmRhICogbGFtYmRhICogbGFtYmRhICogbGFtYmRhKTtcbiAgICAgIH1cblxuICAgICAgZm4gQ29tcHV0ZVBoYXNlTWllKHRoZXRhOiBmMzIsIGc6ZjMyKSAtPiBmMzJcbiAgICAgIHtcbiAgICAgICAgdmFyIGcyID0gZyAqIGc7XG4gICAgICAgIHJldHVybiAoMS4wIC0gZzIpIC8gcG93KDEuMCArIGcyIC0gMi4wICogZyAqIHNhdHVyYXRlKHRoZXRhKSwgMS41KSAvICg0LjAgKiBQSSk7XG4gICAgICB9XG5cbiAgICAgIGZuIENvbXB1dGVQaGFzZVJheWxlaWdoKHRoZXRhOiBmMzIpIC0+IGYzMlxuICAgICAge1xuICAgICAgICB2YXIgdGhldGEyID0gdGhldGEgKiB0aGV0YTtcbiAgICAgICAgcmV0dXJuICh0aGV0YTIgKiAwLjc1ICsgMC43NSkgLyAoNC4wICogUEkpO1xuICAgICAgfVxuXG4gICAgICBmbiBDaGFwbWFuQXBwcm94aW1hdGlvbihYOiBmMzIsIGg6IGYzMiwgY29zWmVuaXRoOiBmMzIpIC0+IGYzMlxuICAgICAge1xuICAgICAgICB2YXIgYyA9IHNxcnQoWCArIGgpO1xuICAgICAgICB2YXIgY19leHBfaCA9IGMgKiBleHAoLWgpO1xuXG4gICAgICAgIGlmIChjb3NaZW5pdGggPj0gMC4wKVxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNfZXhwX2ggLyAoYyAqIGNvc1plbml0aCArIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHgwID0gc3FydCgxLjAgLSBjb3NaZW5pdGggKiBjb3NaZW5pdGgpICogKFggKyBoKTtcbiAgICAgICAgICB2YXIgYzAgPSBzcXJ0KHgwKTtcblxuICAgICAgICAgIHJldHVybiAyLjAgKiBjMCAqIGV4cChYIC0geDApIC0gY19leHBfaCAvICgxLjAgLSBjICogY29zWmVuaXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmbiBHZXRPcHRpY2FsRGVwdGhTY2h1ZWxlcihoOiBmMzIsIEg6IGYzMiwgZWFydGhSYWRpdXM6IGYzMiwgY29zWmVuaXRoOiBmMzIpIC0+IGYzMlxuICAgICAge1xuICAgICAgICByZXR1cm4gSCAqIENoYXBtYW5BcHByb3hpbWF0aW9uKGVhcnRoUmFkaXVzIC8gSCwgaCAvIEgsIGNvc1plbml0aCk7XG4gICAgICB9XG5cbiAgICAgIGZuIEdldFRyYW5zbWl0dGFuY2Uoc2V0dGluZzogU2NhdHRlcmluZ1BhcmFtcywgTDp2ZWMzPGYzMj4sIFY6IHZlYzM8ZjMyPikgLT4gdmVjMzxmMzI+XG4gICAgICB7XG4gICAgICAgIHZhciBjaCA9IEdldE9wdGljYWxEZXB0aFNjaHVlbGVyKEwueSwgc2V0dGluZy5yYXlsZWlnaEhlaWdodCwgc2V0dGluZy5lYXJ0aFJhZGl1cywgVi55KTtcbiAgICAgICAgcmV0dXJuIGV4cCgtKHNldHRpbmcud2F2ZUxhbWJkYU1pZSArIHNldHRpbmcud2F2ZUxhbWJkYVJheWxlaWdoKSAqIGNoKTtcbiAgICAgIH1cblxuICAgICAgZm4gQ29tcHV0ZU9wdGljYWxEZXB0aChzZXR0aW5nOiBTY2F0dGVyaW5nUGFyYW1zLCBzYW1wbGVQb2ludDogdmVjMzxmMzI+LCBWOiB2ZWMzPGYzMj4sIEw6IHZlYzM8ZjMyPiwgbmVnOiBmMzIpIC0+IHZlYzI8ZjMyPlxuICAgICAge1xuICAgICAgICB2YXIgcmwgPSBsZW5ndGgoc2FtcGxlUG9pbnQpO1xuICAgICAgICB2YXIgaCA9IHJsIC0gc2V0dGluZy5lYXJ0aFJhZGl1cztcbiAgICAgICAgdmFyIHI6IHZlYzM8ZjMyPiA9IHNhbXBsZVBvaW50IC8gcmw7XG5cbiAgICAgICAgdmFyIGNvc19jaGlfc3VuID0gZG90KHIsIEwpO1xuICAgICAgICB2YXIgY29zX2NoaV9yYXkgPSBkb3QociwgViAqIG5lZyk7XG5cbiAgICAgICAgdmFyIG9wdGljYWxEZXB0aFN1biA9IEdldE9wdGljYWxEZXB0aFNjaHVlbGVyKGgsIHNldHRpbmcucmF5bGVpZ2hIZWlnaHQsIHNldHRpbmcuZWFydGhSYWRpdXMsIGNvc19jaGlfc3VuKTtcbiAgICAgICAgdmFyIG9wdGljYWxEZXB0aENhbWVyYSA9IEdldE9wdGljYWxEZXB0aFNjaHVlbGVyKGgsIHNldHRpbmcucmF5bGVpZ2hIZWlnaHQsIHNldHRpbmcuZWFydGhSYWRpdXMsIGNvc19jaGlfcmF5KSAqIG5lZztcblxuICAgICAgICByZXR1cm4gdmVjMjxmMzI+KG9wdGljYWxEZXB0aFN1biwgb3B0aWNhbERlcHRoQ2FtZXJhKTtcbiAgICAgIH1cblxuICAgICAgZm4gQWVyaWFsUGVyc3BlY3RpdmUoc2V0dGluZzpTY2F0dGVyaW5nUGFyYW1zLCBzdGFydDogdmVjMzxmMzI+LCBlbmQ6IHZlYzM8ZjMyPiwgVjogdmVjMzxmMzI+LCBMOiB2ZWMzPGYzMj4sIGluZmluaXRlOmkzMilcbiAgICAgIHtcbiAgICAgICAgdmFyIGluZl9uZWc6ZjMyID0gMS4wO1xuICAgICAgICBpZiggaW5maW5pdGUgPT0gMCl7XG4gICAgICAgICAgaW5mX25lZyA9IC0xLjA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FtcGxlU3RlcDogdmVjMzxmMzI+ID0gKGVuZCAtIHN0YXJ0KSAvIGYzMihTQU1QTEVTX05VTVMpO1xuICAgICAgICB2YXIgc2FtcGxlUG9pbnQ6IHZlYzM8ZjMyPiA9IGVuZCAtIHNhbXBsZVN0ZXA7XG4gICAgICAgIHZhciBzYW1wbGVMYW1iZGE6IHZlYzM8ZjMyPiA9IHNldHRpbmcud2F2ZUxhbWJkYU1pZSArIHNldHRpbmcud2F2ZUxhbWJkYVJheWxlaWdoICsgc2V0dGluZy53YXZlTGFtYmRhT3pvbmU7XG5cbiAgICAgICAgdmFyIHNhbXBsZUxlbmd0aDpmMzIgPSBsZW5ndGgoc2FtcGxlU3RlcCk7XG5cbiAgICAgICAgdmFyIHNjYXR0ZXJpbmc6dmVjMzxmMzI+ID0gdmVjMzxmMzI+KDAuMCk7XG4gICAgICAgIHZhciBsYXN0T3B0aWNhbERlcHRoOnZlYzI8ZjMyPiA9IENvbXB1dGVPcHRpY2FsRGVwdGgoc2V0dGluZywgZW5kLCBWLCBMLCBpbmZfbmVnKTtcblxuICAgICAgICBmb3IgKHZhciBpOmkzMiA9IDE7IGkgPCBTQU1QTEVTX05VTVM7IGkgPSBpICsgMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBvcHRpY2FsRGVwdGg6IHZlYzI8ZjMyPiA9IENvbXB1dGVPcHRpY2FsRGVwdGgoc2V0dGluZywgc2FtcGxlUG9pbnQsIFYsIEwsIGluZl9uZWcpO1xuXG4gICAgICAgICAgdmFyIHNlZ21lbnRfczogdmVjMzxmMzI+ID0gZXhwKC1zYW1wbGVMYW1iZGEgKiAob3B0aWNhbERlcHRoLnggKyBsYXN0T3B0aWNhbERlcHRoLngpKTtcbiAgICAgICAgICB2YXIgc2VnbWVudF90OiB2ZWMzPGYzMj4gPSBleHAoLXNhbXBsZUxhbWJkYSAqIChvcHRpY2FsRGVwdGgueSAtIGxhc3RPcHRpY2FsRGVwdGgueSkpO1xuXG4gICAgICAgICAgdHJhbnNtaXR0YW5jZSAqPSBzZWdtZW50X3Q7XG5cbiAgICAgICAgICBzY2F0dGVyaW5nID0gc2NhdHRlcmluZyAqIHNlZ21lbnRfdDtcbiAgICAgICAgICBzY2F0dGVyaW5nICs9IGV4cCgtKGxlbmd0aChzYW1wbGVQb2ludCkgLSBzZXR0aW5nLmVhcnRoUmFkaXVzKSAvIHNldHRpbmcucmF5bGVpZ2hIZWlnaHQpICogc2VnbWVudF9zO1xuXG4gICAgICAgICAgbGFzdE9wdGljYWxEZXB0aCA9IG9wdGljYWxEZXB0aDtcbiAgICAgICAgICBzYW1wbGVQb2ludCA9IHNhbXBsZVBvaW50IC0gc2FtcGxlU3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc2N0ck1pZSA9IHNjYXR0ZXJpbmcgKiBzZXR0aW5nLndhdmVMYW1iZGFNaWUgKiBzYW1wbGVMZW5ndGg7XG4gICAgICAgIGluc2N0clJheWxlaWdoID0gc2NhdHRlcmluZyAqIHNldHRpbmcud2F2ZUxhbWJkYVJheWxlaWdoICogc2FtcGxlTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBmbiBDb21wdXRlU2t5Ym94Q2hhcG1hbihzZXR0aW5nOiBTY2F0dGVyaW5nUGFyYW1zLCBleWU6dmVjMzxmMzI+LCBWOnZlYzM8ZjMyPiwgTDp2ZWMzPGYzMj4pIC0+IGYzMlxuICAgICAge1xuICAgICAgICB2YXIgbmVnOmkzMiA9IDE7XG4gICAgICAgIHZhciBvdXRlckludGVyc2VjdGlvbnM6IHZlYzI8ZjMyPiA9IENvbXB1dGVSYXlTcGhlcmVJbnRlcnNlY3Rpb24oZXllLCBWLCBzZXR0aW5nLmVhcnRoQ2VudGVyLCBzZXR0aW5nLmVhcnRoQXRtVG9wUmFkaXVzKTtcbiAgICAgICAgaWYgKG91dGVySW50ZXJzZWN0aW9ucy55IDwgMC4wKXtcbiAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbm5lckludGVyc2VjdGlvbnM6IHZlYzI8ZjMyPiA9IENvbXB1dGVSYXlTcGhlcmVJbnRlcnNlY3Rpb24oZXllLCBWLCBzZXR0aW5nLmVhcnRoQ2VudGVyLCBzZXR0aW5nLmVhcnRoUmFkaXVzKTtcbiAgICAgICAgaWYgKGlubmVySW50ZXJzZWN0aW9ucy54ID4gMC4wKVxuICAgICAgICB7XG4gICAgICAgICAgbmVnID0gMDtcbiAgICAgICAgICBvdXRlckludGVyc2VjdGlvbnMueSA9IGlubmVySW50ZXJzZWN0aW9ucy54O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGV5ZTAgPSBleWUgLSBzZXR0aW5nLmVhcnRoQ2VudGVyO1xuXG4gICAgICAgIHZhciBzdGFydCA6IHZlYzM8ZjMyPiA9IGV5ZTAgKyBWICogbWF4KDAuMCwgb3V0ZXJJbnRlcnNlY3Rpb25zLngpO1xuICAgICAgICB2YXIgZW5kIDogdmVjMzxmMzI+PSBleWUwICsgViAqIG91dGVySW50ZXJzZWN0aW9ucy55O1xuXG4gICAgICAgIEFlcmlhbFBlcnNwZWN0aXZlKHNldHRpbmcsIHN0YXJ0LCBlbmQsIFYsIEwsIG5lZyk7XG5cbiAgICAgICAgLy9ib29sIGludGVyc2VjdGlvblRlc3QgPSBpbm5lckludGVyc2VjdGlvbnMueCA8IDAuMCAmJiBpbm5lckludGVyc2VjdGlvbnMueSA8IDAuMDtcbiAgICAgICAgLy9yZXR1cm4gaW50ZXJzZWN0aW9uVGVzdCA/IDEuMCA6IDAuMDtcblxuICAgICAgICBpZihpbm5lckludGVyc2VjdGlvbnMueCA8IDAuMCAmJiBpbm5lckludGVyc2VjdGlvbnMueSA8IDAuMCl7XG4gICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgfVxuXG4gICAgICBmbiBDb21wdXRlU2t5SW5zY2F0dGVyaW5nKHNldHRpbmc6IFNjYXR0ZXJpbmdQYXJhbXMsIGV5ZTogdmVjMzxmMzI+LCBWOiB2ZWMzPGYzMj4sIEw6IHZlYzM8ZjMyPikgLT4gdmVjNDxmMzI+XG4gICAgICB7XG4gICAgICAgIHRyYW5zbWl0dGFuY2UgPSB2ZWMzPGYzMj4oMS4wKTtcbiAgICAgICAgaW5zY3RyTWllID0gdmVjMzxmMzI+KDAuMCk7XG4gICAgICAgIGluc2N0clJheWxlaWdoID0gdmVjMzxmMzI+KDAuMCk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25UZXN0OmYzMiA9IENvbXB1dGVTa3lib3hDaGFwbWFuKHNldHRpbmcsIGV5ZSwgViwgTCk7XG5cbiAgICAgICAgdmFyIHBoYXNlVGhldGEgPSBkb3QoViwgTCk7XG4gICAgICAgIHZhciBwaGFzZU1pZSA9IENvbXB1dGVQaGFzZU1pZShwaGFzZVRoZXRhLCBzZXR0aW5nLm1pZUcpO1xuICAgICAgICB2YXIgcGhhc2VSYXlsZWlnaCA9IENvbXB1dGVQaGFzZVJheWxlaWdoKHBoYXNlVGhldGEpO1xuICAgICAgICB2YXIgcGhhc2VOaWdodCA9IDEuMCAtIHNhdHVyYXRlKHRyYW5zbWl0dGFuY2UueCAqIEVQU0lMT04pO1xuXG4gICAgICAgIHZhciBpbnNjdHJUb3RhbE1pZTogdmVjMzxmMzI+ID0gaW5zY3RyTWllICogcGhhc2VNaWU7XG4gICAgICAgIHZhciBpbnNjdHJUb3RhbFJheWxlaWdoOiB2ZWMzPGYzMj4gPSBpbnNjdHJSYXlsZWlnaCAqIHBoYXNlUmF5bGVpZ2g7XG5cbiAgICAgICAgdmFyIHNreTogdmVjMzxmMzI+ID0gKGluc2N0clRvdGFsTWllICsgaW5zY3RyVG90YWxSYXlsZWlnaCkgKiBzZXR0aW5nLnN1blJhZGlhbmNlO1xuICAgICAgICBpZih1bmlmb3JtQnVmZmVyLmRpc3BsYXlTdW4gPiAwLjUpe1xuICAgICAgICAgIHZhciBhbmdsZTpmMzIgPSBzYXR1cmF0ZSgoMS4wIC0gcGhhc2VUaGV0YSkgKiBzZXR0aW5nLnN1blJhZGl1cyk7XG4gICAgICAgICAgdmFyIGNvc0FuZ2xlOmYzMiA9IGNvcyhhbmdsZSAqIFBJICogMC41KTtcbiAgICAgICAgICB2YXIgZWRnZTpmMzIgPSAwLjA7XG4gICAgICAgICAgaWYoYW5nbGUgPj0gMC45KXtcbiAgICAgICAgICAgIGVkZ2UgPSBzbW9vdGhzdGVwKDAuOSwgMS4wLCBhbmdsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxpbWJEYXJrZW5pbmc6IHZlYzM8ZjMyPiA9IEdldFRyYW5zbWl0dGFuY2Uoc2V0dGluZywgLUwsIFYpO1xuICAgICAgICAgIGxpbWJEYXJrZW5pbmcgKj0gcG93KHZlYzM8ZjMyPihjb3NBbmdsZSksIHZlYzM8ZjMyPigwLjQyMCwgMC41MDMsIDAuNjUyKSkgKiBtaXgodmVjMzxmMzI+KDEuMCksIHZlYzM8ZjMyPigxLjIsMC45LDAuNSksIGVkZ2UpICogaW50ZXJzZWN0aW9uVGVzdDtcbiAgICAgICAgICBza3kgKz0gbGltYkRhcmtlbmluZyAqIHVuaWZvcm1CdWZmZXIuc3VuQnJpZ2h0bmVzczsgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPihza3ksIHBoYXNlTmlnaHQgKiBpbnRlcnNlY3Rpb25UZXN0KTtcbiAgICAgIH1cblxuICAgICAgZm4gVG9uZW1hcEFDRVMoeDogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj5cbiAgICAgIHtcbiAgICAgICAgdmFyIEE6ZjMyID0gMi41MWY7XG4gICAgICAgIHZhciBCOmYzMiA9IDAuMDNmO1xuICAgICAgICB2YXIgQzpmMzIgPSAyLjQzZjtcbiAgICAgICAgdmFyIEQ6ZjMyID0gMC41OWY7XG4gICAgICAgIHZhciBFOmYzMiA9IDAuMTRmO1xuICAgICAgICByZXR1cm4gKHggKiAoQSAqIHggKyBCKSkgLyAoeCAqIChDICogeCArIEQpICsgRSk7XG4gICAgICB9XG5cbiAgICAgIGZuIG5vaXNlKHV2OnZlYzI8ZjMyPikgLT4gZjMyXG4gICAgICB7XG4gICAgICAgIHJldHVybiBmcmFjdChkb3Qoc2luKHZlYzM8ZjMyPih1di54eXgpICogdmVjMzxmMzI+KHV2Lnh5eSkgKiAxMDI0LjApLCB2ZWMzPGYzMj4oMzQxODk2LjQ4MywgODkxNjE4LjYzNywgNjAyNjQ5LjcwMzEpKSk7XG4gICAgICB9XG5cbiAgICAgIGZuIG1haW5JbWFnZSggdXY6dmVjMjxmMzI+ICkgLT4gdmVjNDxmMzI+XG4gICAgICB7XG4gICAgICAgIGxldCBleWVQb3NpdGlvbiA9IHVuaWZvcm1CdWZmZXIuZXllUG9zO1xuICAgICAgICB2YXIgc3VuID0gdmVjMjxmMzI+KHVuaWZvcm1CdWZmZXIuc3VuVSwgdW5pZm9ybUJ1ZmZlci5zdW5WKTtcbiAgICAgICAgdmFyIFY6IHZlYzM8ZjMyPiA9IENvbXB1dGVTcGhlcmVOb3JtYWwodXYsIDAuMCwgUElfMiwgMC4wLCBQSSk7XG4gICAgICAgIHZhciBMOiB2ZWMzPGYzMj4gPSBDb21wdXRlU3BoZXJlTm9ybWFsKHZlYzI8ZjMyPihzdW4ueCwgc3VuLnkpLCAwLjAsIFBJXzIsIDAuMCwgUEkpO1xuXG4gICAgICAgIHZhciBzZXR0aW5nOiBTY2F0dGVyaW5nUGFyYW1zO1xuICAgICAgICBzZXR0aW5nLnN1blJhZGl1cyA9IHVuaWZvcm1CdWZmZXIuc3VuUmFkaXVzOy8vNTAwLjA7XG4gICAgICAgIHNldHRpbmcuc3VuUmFkaWFuY2UgPSB1bmlmb3JtQnVmZmVyLnN1blJhZGlhbmNlOy8vMjAuMDtcbiAgICAgICAgc2V0dGluZy5taWVHID0gdW5pZm9ybUJ1ZmZlci5taWVHOy8vMC43NjtcbiAgICAgICAgc2V0dGluZy5taWVIZWlnaHQgPSB1bmlmb3JtQnVmZmVyLm1pZUhlaWdodDsvLyAxMjAwLjA7XG4gICAgICAgIHNldHRpbmcucmF5bGVpZ2hIZWlnaHQgPSA4MDAwLjA7XG4gICAgICAgIHNldHRpbmcuZWFydGhSYWRpdXMgPSA2MzYwMDAwLjA7XG4gICAgICAgIHNldHRpbmcuZWFydGhBdG1Ub3BSYWRpdXMgPSA2NDIwMDAwLjA7XG4gICAgICAgIHNldHRpbmcuZWFydGhDZW50ZXIgPSB2ZWMzPGYzMj4oMCwgLXNldHRpbmcuZWFydGhSYWRpdXMsIDApO1xuICAgICAgICBzZXR0aW5nLndhdmVMYW1iZGFNaWUgPSB2ZWMzPGYzMj4oMC4wMDAwMDAyKTtcblxuICAgICAgICAvLyB3YXZlbGVuZ3RoIHdpdGggNjgwbm0sIDU1MG5tLCA0NTBubVxuICAgICAgICBzZXR0aW5nLndhdmVMYW1iZGFSYXlsZWlnaCA9IENvbXB1dGVXYXZlTGFtYmRhUmF5bGVpZ2godmVjMzxmMzI+KDAuMDAwMDAwNjgwLCAwLjAwMDAwMDU1MCwgMC4wMDAwMDA0NTApKTtcblxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L01sbEJSMlxuICAgICAgICBzZXR0aW5nLndhdmVMYW1iZGFPem9uZSA9IHZlYzM8ZjMyPigxLjM2ODIwODk5Njc5MTQ3LCAzLjMxNDA1MzMwNDAwMTI0LCAwLjEzNjAxNzI4MjUyNTM4KSogMC4wMDAwMDA2ICogMi41MDQ7XG5cbiAgICAgICAgdmFyIGV5ZTp2ZWMzPGYzMj4gPSB2ZWMzPGYzMj4oMCxleWVQb3NpdGlvbiwwKTtcbiAgICAgICAgdmFyIHNreTA6dmVjNDxmMzI+ID0gQ29tcHV0ZVNreUluc2NhdHRlcmluZyhzZXR0aW5nLCBleWUsIFYsIEwpO1xuICAgICAgICB2YXIgc2t5ID0gdmVjMzxmMzI+KHNreTAucmdiKTtcblxuICAgICAgICBza3kgPSBUb25lbWFwQUNFUyhza3kucmdiICogMi4wKTtcbiAgICAgICAgc2t5ID0gcG93KHNreS5yZ2IsIHZlYzM8ZjMyPigxLjAvMS4yKSk7IC8vIGdhbW1hXG5cbiAgICAgICAgdmFyIGZyYWdDb2xvcjp2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oKHNreS5yZ2IpLCAxLjApO1xuICAgICAgICByZXR1cm4gZnJhZ0NvbG9yO1xuICAgICAgfVxuICAgIGApO2NsYXNzIEJje2NvbnN0cnVjdG9yKCl7byh0aGlzLFwic3VuUmFkaXVzXCIsNTAwKSxvKHRoaXMsXCJzdW5SYWRpYW5jZVwiLDExKSxvKHRoaXMsXCJtaWVHXCIsLjc2KSxvKHRoaXMsXCJtaWVIZWlnaHRcIiwxMjAwKSxvKHRoaXMsXCJleWVQb3NcIiwxNTAwKSxvKHRoaXMsXCJzdW5YXCIsLjcxKSxvKHRoaXMsXCJzdW5ZXCIsLjU2KSxvKHRoaXMsXCJzdW5CcmlnaHRuZXNzXCIsMSksbyh0aGlzLFwiZGlzcGxheVN1blwiLCEwKSxvKHRoaXMsXCJkZWZhdWx0VGV4dHVyZUN1YmVTaXplXCIsNTEyKSxvKHRoaXMsXCJkZWZhdWx0VGV4dHVyZTJEU2l6ZVwiLDEwMjQpLG8odGhpcyxcInNreUNvbG9yXCIsbmV3IHooMSwxLDEsMSkpfX1jbGFzcyBUYyBleHRlbmRzIHJhe2NvbnN0cnVjdG9yKGUpe3JldHVybiBzdXBlcigpLG8odGhpcyxcIl9pbnRlcm5hbFRleHR1cmVcIiksbyh0aGlzLFwiX2N1YmVTaXplXCIpLG8odGhpcyxcInNldHRpbmdcIiksdGhpcy5zZXR0aW5nPWUsdGhpcy5fY3ViZVNpemU9ZS5kZWZhdWx0VGV4dHVyZUN1YmVTaXplLHRoaXMuX2ludGVybmFsVGV4dHVyZT1uZXcgZXAoZS5kZWZhdWx0VGV4dHVyZTJEU2l6ZSxlLmRlZmF1bHRUZXh0dXJlMkRTaXplKi41KSx0aGlzLl9pbnRlcm5hbFRleHR1cmUudXBkYXRlKHRoaXMuc2V0dGluZyksdGhpcy5jcmVhdGVGcm9tVGV4dHVyZSh0aGlzLl9jdWJlU2l6ZSx0aGlzLl9pbnRlcm5hbFRleHR1cmUpLHRoaXN9Z2V0IHRleHR1cmUyRCgpe3JldHVybiB0aGlzLl9pbnRlcm5hbFRleHR1cmV9YXBwbHkoKXtyZXR1cm4gdGhpcy5faW50ZXJuYWxUZXh0dXJlLnVwZGF0ZSh0aGlzLnNldHRpbmcpLHRoaXMuX2ZhY2VEYXRhLnVwbG9hZEVycFRleHR1cmUodGhpcy5faW50ZXJuYWxUZXh0dXJlKSx0aGlzfX1jbGFzcyBlcCBleHRlbmRzIG9le2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0LEcucmdiYTE2ZmxvYXQsITEsR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HKSxvKHRoaXMsXCJfY29tcHV0ZVNoYWRlclwiKSxvKHRoaXMsXCJfdW5pZm9ybUJ1ZmZlclwiKSx0aGlzLmluaXRDb21wdXRlKGUsdCl9aW5pdENvbXB1dGUoZSx0KXt0aGlzLl91bmlmb3JtQnVmZmVyPW5ldyBEdCgxNio0KSx0aGlzLl91bmlmb3JtQnVmZmVyLmFwcGx5KCksdGhpcy5fY29tcHV0ZVNoYWRlcj1uZXcgYmUocm4uY3MpLHRoaXMuX2NvbXB1dGVTaGFkZXIuc2V0VW5pZm9ybUJ1ZmZlcihcInVuaWZvcm1CdWZmZXJcIix0aGlzLl91bmlmb3JtQnVmZmVyKSx0aGlzLl9jb21wdXRlU2hhZGVyLnNldFN0b3JhZ2VUZXh0dXJlKFwib3V0VGV4dHVyZVwiLHRoaXMpLHRoaXMuX2NvbXB1dGVTaGFkZXIud29ya2VyU2l6ZVg9ZS84LHRoaXMuX2NvbXB1dGVTaGFkZXIud29ya2VyU2l6ZVk9dC84fXVwZGF0ZShlKXt0aGlzLl91bmlmb3JtQnVmZmVyLnNldEZsb2F0KFwid2lkdGhcIix0aGlzLndpZHRoKSx0aGlzLl91bmlmb3JtQnVmZmVyLnNldEZsb2F0KFwiaGVpZ2h0XCIsdGhpcy5oZWlnaHQpLHRoaXMuX3VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJzdW5VXCIsZS5zdW5YKSx0aGlzLl91bmlmb3JtQnVmZmVyLnNldEZsb2F0KFwic3VuVlwiLGUuc3VuWSksdGhpcy5fdW5pZm9ybUJ1ZmZlci5zZXRGbG9hdChcImV5ZVBvc1wiLGUuZXllUG9zKSx0aGlzLl91bmlmb3JtQnVmZmVyLnNldEZsb2F0KFwic3VuUmFkaXVzXCIsZS5zdW5SYWRpdXMpLHRoaXMuX3VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJzdW5SYWRpYW5jZVwiLGUuc3VuUmFkaWFuY2UpLHRoaXMuX3VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJtaWVHXCIsZS5taWVHKSx0aGlzLl91bmlmb3JtQnVmZmVyLnNldEZsb2F0KFwibWllSGVpZ2h0XCIsZS5taWVIZWlnaHQpLHRoaXMuX3VuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJzdW5CcmlnaHRuZXNzXCIsZS5zdW5CcmlnaHRuZXNzKSx0aGlzLl91bmlmb3JtQnVmZmVyLnNldEZsb2F0KFwiZGlzcGxheVN1blwiLGUuZGlzcGxheVN1bj8xOjApLHRoaXMuX3VuaWZvcm1CdWZmZXIuc2V0Q29sb3IoXCJza3lDb2xvclwiLGUuc2t5Q29sb3IpLHRoaXMuX3VuaWZvcm1CdWZmZXIuYXBwbHkoKTtsZXQgdD13LmJlZ2luQ29tbWFuZEVuY29kZXIoKTtyZXR1cm4gdy5jb21wdXRlQ29tbWFuZCh0LFt0aGlzLl9jb21wdXRlU2hhZGVyXSksdy5lbmRDb21tYW5kRW5jb2Rlcih0KSx0aGlzfX1jbGFzcyBNYyBleHRlbmRzIF9pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtsZXQgZT1uZXcgV2UoXCJza3lfdnNfZnJhZ193Z3NsXCIsXCJza3lfZnNfZnJhZ193Z3NsXCIpO3RoaXMuZGVmYXVsdFBhc3M9ZSxlLnNldFVuaWZvcm1WZWN0b3IzKFwiZXllc1Bvc1wiLG5ldyBnKSxlLnNldFVuaWZvcm1GbG9hdChcImV4cG9zdXJlXCIsMSksZS5zZXRVbmlmb3JtRmxvYXQoXCJyb3VnaG5lc3NcIiwwKTtsZXQgdD1lLnNoYWRlclN0YXRlO3QuZnJvbnRGYWNlPVwiY3dcIix0LmN1bGxNb2RlPXVpLmJhY2ssdC5kZXB0aFdyaXRlRW5hYmxlZD0hMSx0LmRlcHRoQ29tcGFyZT12dC5sZXNzfXNldCBiYXNlTWFwKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VGV4dHVyZShcImJhc2VNYXBcIixlKTtjb25zdCB0PVwiSVNfSERSX1NLWVwiO3RoaXMuZGVmYXVsdFBhc3MuZGVmaW5lVmFsdWVbdF0hPWU/LmlzSERSVGV4dHVyZSYmdGhpcy5kZWZhdWx0UGFzcy5zZXREZWZpbmUodCwhIWU/LmlzSERSVGV4dHVyZSl9Z2V0IGJhc2VNYXAoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy5nZXRUZXh0dXJlKFwiYmFzZU1hcFwiKX1zZXQgZW52TWFwKGUpe31zZXQgc2hhZG93TWFwKGUpe31nZXQgZXhwb3N1cmUoKXtyZXR1cm4gQS5zZXR0aW5nLnNreS5za3lFeHBvc3VyZX1zZXQgZXhwb3N1cmUoZSl7QS5zZXR0aW5nLnNreS5za3lFeHBvc3VyZT1lfWdldCByb3VnaG5lc3MoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWV9c2V0IHJvdWdobmVzcyhlKXtcInJvdWdobmVzc1wiaW4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3JtcyYmKHRoaXMuZGVmYXVsdFBhc3MudW5pZm9ybXMucm91Z2huZXNzLnZhbHVlPWUpfX1jbGFzcyBscyBleHRlbmRzIHR0e2NvbnN0cnVjdG9yKGUsdCxyLHMsYSxuLGwpe3N1cGVyKCksbyh0aGlzLFwic2hhcGVfdmVydGljZXNcIixbXSksbyh0aGlzLFwic2hhcGVfaW5kaWNlc1wiLFtdKSxvKHRoaXMsXCJyYWRpdXNcIiksbyh0aGlzLFwid2lkdGhTZWdtZW50c1wiKSxvKHRoaXMsXCJoZWlnaHRTZWdtZW50c1wiKSxvKHRoaXMsXCJwaGlTdGFydFwiKSxvKHRoaXMsXCJwaGlMZW5ndGhcIiksbyh0aGlzLFwidGhldGFTdGFydFwiKSxvKHRoaXMsXCJ0aGV0YUxlbmd0aFwiKSx0aGlzLnJhZGl1cz1lLHRoaXMud2lkdGhTZWdtZW50cz10LHRoaXMuaGVpZ2h0U2VnbWVudHM9cix0aGlzLnBoaVN0YXJ0PXMsdGhpcy5waGlMZW5ndGg9YSx0aGlzLnRoZXRhU3RhcnQ9bix0aGlzLnRoZXRhTGVuZ3RoPWwsdGhpcy5idWlsZEdlb21ldHJ5KCl9YnVpbGRHZW9tZXRyeSgpe3ZhciBlLHQscj0wO2xldCBzPXRoaXMuaGVpZ2h0U2VnbWVudHMsYT10aGlzLndpZHRoU2VnbWVudHMsbj10aGlzLnJhZGl1czt2YXIgbD0ocysxKSooYSsxKTtsZXQgaD1uZXcgRmxvYXQzMkFycmF5KGwqMyksdT1uZXcgRmxvYXQzMkFycmF5KGwqMyksYz1uZXcgRmxvYXQzMkFycmF5KGwqMiksZj1uZXcgVWludDE2QXJyYXkoYSpzKjIqMyksZD0wLHA9MCxtPTA7Zm9yKHQ9MDt0PD1zOysrdCl7dmFyIF89TWF0aC5QSSp0L3Msdj0tbipNYXRoLmNvcyhfKSx5PW4qTWF0aC5zaW4oXyk7Zm9yKGU9MDtlPD1hOysrZSl7dmFyIEM9MipNYXRoLlBJKmUvYSxCPXkqTWF0aC5jb3MoQyksVD15Kk1hdGguc2luKEMpLE09MS9NYXRoLnNxcnQoQipCK1QqVCt2KnYpO2lmKGhbZCsrXT1CLGhbZCsrXT1ULGhbZCsrXT12LHVbcCsrXT1CKk0sdVtwKytdPVQqTSx1W3ArK109dipNLGNbbSsrXT1lL2EsY1ttKytdPXQvcyxlPjAmJnQ+MCl7dmFyIEQ9KGErMSkqdCtlLFA9KGErMSkqdCtlLTEsTD0oYSsxKSoodC0xKStlLTEsST0oYSsxKSoodC0xKStlO3Q9PXM/KGZbcisrXT1ELGZbcisrXT1MLGZbcisrXT1JKTp0PT0xPyhmW3IrK109RCxmW3IrK109UCxmW3IrK109TCk6KGZbcisrXT1ELGZbcisrXT1QLGZbcisrXT1MLGZbcisrXT1ELGZbcisrXT1MLGZbcisrXT1JKX19fXRoaXMuc2V0SW5kaWNlcyhmKSx0aGlzLnNldEF0dHJpYnV0ZShZLnBvc2l0aW9uLGgpLHRoaXMuc2V0QXR0cmlidXRlKFkubm9ybWFsLHUpLHRoaXMuc2V0QXR0cmlidXRlKFkudXYsYyksdGhpcy5zZXRBdHRyaWJ1dGUoWS5URVhDT09SRF8xLGMpLHRoaXMuYWRkU3ViR2VvbWV0cnkoe2luZGV4U3RhcnQ6MCxpbmRleENvdW50OmYubGVuZ3RoLHZlcnRleFN0YXJ0OjAsaW5kZXg6MH0pLHRoaXMuYm91bmRzPW5ldyBCZShnLlpFUk8sbmV3IGcodGhpcy5yYWRpdXMqMix0aGlzLnJhZGl1cyoyLHRoaXMucmFkaXVzKjIpKX19Y2xhc3Mgc2EgZXh0ZW5kcyBjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwic2t5TWF0ZXJpYWxcIil9aW5pdCgpe3N1cGVyLmluaXQoKSx0aGlzLmNhc3RTaGFkb3c9ITEsdGhpcy5jYXN0R0k9ITAsdGhpcy5hZGRSZW5kZXJlck1hc2soVWUuU2t5KSx0aGlzLmFsd2F5c1JlbmRlcj0hMCx0aGlzLm9iamVjdDNELmJvdW5kPW5ldyBCZShnLlpFUk8uY2xvbmUoKSxnLk1BWCksdGhpcy5nZW9tZXRyeT1uZXcgbHMoQS5zZXR0aW5nLnNreS5kZWZhdWx0RmFyLDIwLDIwKSx0aGlzLnNreU1hdGVyaWFsfHwodGhpcy5za3lNYXRlcmlhbD1uZXcgTWMpfW9uRW5hYmxlKCl7dGhpcy5fcmVhZHlQaXBlbGluZT8odGhpcy5jYXN0TmVlZFBhc3MoKSwhdGhpcy5faW5SZW5kZXJlciYmdGhpcy50cmFuc2Zvcm0uc2NlbmUzRCYmKFEuaW5zdGFuY2Uuc2t5PXRoaXMsdGhpcy5faW5SZW5kZXJlcj0hMCkpOnRoaXMuaW5pdFBpcGVsaW5lKCl9b25EaXNhYmxlKCl7dGhpcy5faW5SZW5kZXJlciYmdGhpcy50cmFuc2Zvcm0uc2NlbmUzRCYmKHRoaXMuX2luUmVuZGVyZXI9ITEsUS5pbnN0YW5jZS5za3k9bnVsbCl9cmVuZGVyUGFzczIoZSx0LHIscyxhLG49ITEpe3N1cGVyLnJlbmRlclBhc3MyKGUsdCxyLHMsYSxuKX1zZXQgbWFwKGUpe3RoaXMuc2t5TWF0ZXJpYWwuYmFzZU1hcD1lLHRoaXMuc2t5TWF0ZXJpYWwubmFtZT09bnVsbCYmKHRoaXMuc2t5TWF0ZXJpYWwubmFtZT1cInNreU1hdGVyaWFsXCIpLHRoaXMubWF0ZXJpYWw9dGhpcy5za3lNYXRlcmlhbH1nZXQgbWFwKCl7cmV0dXJuIHRoaXMuc2t5TWF0ZXJpYWwuYmFzZU1hcH1nZXQgZXhwb3N1cmUoKXtyZXR1cm4gdGhpcy5za3lNYXRlcmlhbC5leHBvc3VyZX1zZXQgZXhwb3N1cmUoZSl7dGhpcy5za3lNYXRlcmlhbCYmKHRoaXMuc2t5TWF0ZXJpYWwuZXhwb3N1cmU9ZSl9Z2V0IHJvdWdobmVzcygpe3JldHVybiB0aGlzLnNreU1hdGVyaWFsLnJvdWdobmVzc31zZXQgcm91Z2huZXNzKGUpe3RoaXMuc2t5TWF0ZXJpYWwmJih0aGlzLnNreU1hdGVyaWFsLnJvdWdobmVzcz1lKX19Y2xhc3MgdHB7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJyb3RhdGVYXCIpLG8odGhpcyxcInJvdGF0ZVlcIiksbyh0aGlzLFwic3VuWFwiKSxvKHRoaXMsXCJzdW5ZXCIpLHRoaXMucmVzZXQoKX1yZXNldCgpe3JldHVybiB0aGlzLnJvdGF0ZVg9dGhpcy5yb3RhdGVZPXRoaXMuc3VuWD10aGlzLnN1blk9TnVtYmVyLk1BWF9WQUxVRSx0aGlzfWlzUm90YXRlQ2hhbmdlKGUsdCl7cmV0dXJuIE1hdGguYWJzKHRoaXMucm90YXRlWC1lKT49LjAwMXx8TWF0aC5hYnModGhpcy5yb3RhdGVZLXQpPj0uMDAxfWlzU2t5Q2hhbmdlKGUsdCl7cmV0dXJuIE1hdGguYWJzKHRoaXMuc3VuWC1lKT49LjAwMXx8TWF0aC5hYnModGhpcy5zdW5ZLXQpPj0uMDAxfXNhdmUoZSx0LHIscyl7cmV0dXJuIHRoaXMuc3VuWD1lLHRoaXMuc3VuWT10LHRoaXMucm90YXRlWD1yLHRoaXMucm90YXRlWT1zLHRoaXN9fWNsYXNzIGlwIGV4dGVuZHMgc2F7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcIl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3lcIiksbyh0aGlzLFwiX29uQ2hhbmdlXCIsITApLG8odGhpcyxcIl9yZWxhdGVkVHJhbnNmb3JtXCIpLG8odGhpcyxcIl9oaXN0b3J5RGF0YVwiKX1nZXQgc3VuWCgpe3JldHVybiB0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5zdW5YfXNldCBzdW5YKGUpe3RoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreS5zZXR0aW5nLnN1blghPWUmJih0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5zdW5YPWUsdGhpcy5fb25DaGFuZ2U9ITApfWdldCBzdW5ZKCl7cmV0dXJuIHRoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreS5zZXR0aW5nLnN1bll9c2V0IHN1blkoZSl7dGhpcy5fYXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LnNldHRpbmcuc3VuWSE9ZSYmKHRoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreS5zZXR0aW5nLnN1blk9ZSx0aGlzLl9vbkNoYW5nZT0hMCl9Z2V0IGV5ZVBvcygpe3JldHVybiB0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5leWVQb3N9c2V0IGV5ZVBvcyhlKXt0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5leWVQb3MhPWUmJih0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5leWVQb3M9ZSx0aGlzLl9vbkNoYW5nZT0hMCl9Z2V0IHN1blJhZGl1cygpe3JldHVybiB0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5zdW5SYWRpdXN9c2V0IHN1blJhZGl1cyhlKXt0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5zdW5SYWRpdXMhPWUmJih0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5zdW5SYWRpdXM9ZSx0aGlzLl9vbkNoYW5nZT0hMCl9Z2V0IHN1blJhZGlhbmNlKCl7cmV0dXJuIHRoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreS5zZXR0aW5nLnN1blJhZGlhbmNlfXNldCBzdW5SYWRpYW5jZShlKXt0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5zdW5SYWRpYW5jZSE9ZSYmKHRoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreS5zZXR0aW5nLnN1blJhZGlhbmNlPWUsdGhpcy5fb25DaGFuZ2U9ITApfWdldCBzdW5CcmlnaHRuZXNzKCl7cmV0dXJuIHRoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreS5zZXR0aW5nLnN1bkJyaWdodG5lc3N9c2V0IHN1bkJyaWdodG5lc3MoZSl7dGhpcy5fYXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LnNldHRpbmcuc3VuQnJpZ2h0bmVzcyE9ZSYmKHRoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreS5zZXR0aW5nLnN1bkJyaWdodG5lc3M9ZSx0aGlzLl9vbkNoYW5nZT0hMCl9Z2V0IGRpc3BsYXlTdW4oKXtyZXR1cm4gdGhpcy5fYXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LnNldHRpbmcuZGlzcGxheVN1bn1zZXQgZGlzcGxheVN1bihlKXt0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuc2V0dGluZy5kaXNwbGF5U3VuIT1lJiYodGhpcy5fYXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LnNldHRpbmcuZGlzcGxheVN1bj1lLHRoaXMuX29uQ2hhbmdlPSEwKX1pbml0KCl7c3VwZXIuaW5pdCgpLHRoaXMuX2hpc3RvcnlEYXRhPW5ldyB0cCx0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3k9bmV3IFRjKG5ldyBCYyk7bGV0IGU9dGhpcy50cmFuc2Zvcm0udmlldzNELHQ9dGhpcy50cmFuc2Zvcm0uc2NlbmUzRDt0aGlzLm1hcD10aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3ksdC5lbnZNYXA9dGhpcy5fYXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LHRoaXMub25VcGRhdGUoZSl9c3RhcnQoZSl7bGV0IHQ9dGhpcy50cmFuc2Zvcm0uc2NlbmUzRDt0aGlzLm1hcD10aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3ksdC5lbnZNYXA9dGhpcy5fYXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LHN1cGVyLnN0YXJ0KCl9Z2V0IHJlbGF0aXZlVHJhbnNmb3JtKCl7cmV0dXJuIHRoaXMuX3JlbGF0ZWRUcmFuc2Zvcm19c2V0IHJlbGF0aXZlVHJhbnNmb3JtKGUpe3RoaXMuX3JlbGF0ZWRUcmFuc2Zvcm09ZSx0aGlzLl9oaXN0b3J5RGF0YS5yZXNldCgpfW9uVXBkYXRlKGUpe3RoaXMuX3JlbGF0ZWRUcmFuc2Zvcm0mJih0aGlzLl9yZWxhdGVkVHJhbnNmb3JtLnJvdGF0aW9uWj0wLHRoaXMuX2hpc3RvcnlEYXRhLmlzUm90YXRlQ2hhbmdlKHRoaXMuX3JlbGF0ZWRUcmFuc2Zvcm0ucm90YXRpb25YLHRoaXMuX3JlbGF0ZWRUcmFuc2Zvcm0ucm90YXRpb25ZKT8odGhpcy5zdW5YPSh0aGlzLl9yZWxhdGVkVHJhbnNmb3JtLnJvdGF0aW9uWSs5MCkvMzYwLHRoaXMuc3VuWT10aGlzLl9yZWxhdGVkVHJhbnNmb3JtLnJvdGF0aW9uWC8xODArLjUpOnRoaXMuX2hpc3RvcnlEYXRhLmlzU2t5Q2hhbmdlKHRoaXMuc3VuWCx0aGlzLnN1blkpJiYodGhpcy5fcmVsYXRlZFRyYW5zZm9ybS5yb3RhdGlvblk9dGhpcy5zdW5YKjM2MC05MCx0aGlzLl9yZWxhdGVkVHJhbnNmb3JtLnJvdGF0aW9uWD0odGhpcy5zdW5ZLS41KSoxODApLHRoaXMuX2hpc3RvcnlEYXRhLnNhdmUodGhpcy5zdW5YLHRoaXMuc3VuWSx0aGlzLl9yZWxhdGVkVHJhbnNmb3JtLnJvdGF0aW9uWCx0aGlzLl9yZWxhdGVkVHJhbnNmb3JtLnJvdGF0aW9uWSkpLHRoaXMuX29uQ2hhbmdlJiYodGhpcy5fb25DaGFuZ2U9ITEsdGhpcy5fYXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LmFwcGx5KCkpfWRlc3Ryb3koZSl7c3VwZXIuZGVzdHJveShlKSx0aGlzLl9hdG1vc3BoZXJpY1NjYXR0ZXJpbmdTa3kuZGVzdHJveSgpLHRoaXMuX2F0bW9zcGhlcmljU2NhdHRlcmluZ1NreT1udWxsLHRoaXMuX29uQ2hhbmdlPW51bGx9fWNsYXNzIHlzIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcInR5cGVcIiksbyh0aGlzLFwiY2FtZXJhXCIpLG8odGhpcyxcIl9jYW1lcmFQb3NpdGlvblwiKSx0aGlzLl9jYW1lcmFQb3NpdGlvbj1uZXcgZ31vblVwZGF0ZSgpe3RoaXMuZW5hYmxlJiZ0aGlzLnRyYW5zZm9ybS52aWV3M0QuY2FtZXJhJiZ0aGlzLnVwZGF0ZUJpbGxib2FyZE1hdHJpeCgpfXVwZGF0ZUJpbGxib2FyZE1hdHJpeCgpe2xldCBlPXRoaXMudHJhbnNmb3JtLnZpZXczRC5jYW1lcmE7dGhpcy5fY2FtZXJhUG9zaXRpb24uY29weUZyb20oZS50cmFuc2Zvcm0uYmFjayksdGhpcy50eXBlPT14aS5CaWxsYm9hcmRYWVp8fHRoaXMudHlwZT09eGkuQmlsbGJvYXJkWSYmKHRoaXMuX2NhbWVyYVBvc2l0aW9uLnk9MCksdGhpcy5fY2FtZXJhUG9zaXRpb24ubm9ybWFsaXplKCksdGhpcy5fY2FtZXJhUG9zaXRpb24uYWRkKHRoaXMub2JqZWN0M0QubG9jYWxQb3NpdGlvbix0aGlzLl9jYW1lcmFQb3NpdGlvbiksdGhpcy50cmFuc2Zvcm0ubG9va0F0KHRoaXMub2JqZWN0M0QubG9jYWxQb3NpdGlvbix0aGlzLl9jYW1lcmFQb3NpdGlvbixlLnRyYW5zZm9ybS51cCl9Y2xvbmVUbyhlKXtsZXQgdD1lLmFkZENvbXBvbmVudCh5cyk7dC50eXBlPXRoaXMudHlwZX19dmFyIG1yPShpPT4oaVtpLk5vbmU9MF09XCJOb25lXCIsaVtpLkJveD0xXT1cIkJveFwiLGlbaS5DYXBzdWxlPTJdPVwiQ2Fwc3VsZVwiLGlbaS5TcGhlcmU9M109XCJTcGhlcmVcIixpW2kuTWVzaD00XT1cIk1lc2hcIixpKSkobXJ8fHt9KTtjb25zdCBMaT1jbGFzc3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcIl9jZW50ZXJcIiksbyh0aGlzLFwiX3NpemVcIiksbyh0aGlzLFwiX2hhbGZTaXplXCIpLG8odGhpcyxcIl9zaGFwZVR5cGVcIiwwKSxMaS52M19oZWxwXzB8fChMaS52M19oZWxwXzA9bmV3IGcpLExpLmhlbHBNYXRyaXh8fChMaS5oZWxwTWF0cml4PW5ldyBWKSxMaS5oZWxwUmF5fHwoTGkuaGVscFJheT1uZXcgY2kpLHRoaXMuX2NlbnRlcj1uZXcgZyx0aGlzLl9zaXplPW5ldyBnLHRoaXMuX2hhbGZTaXplPW5ldyBnfWdldCBzaGFwZVR5cGUoKXtyZXR1cm4gdGhpcy5fc2hhcGVUeXBlfXNldEZyb21DZW50ZXJBbmRTaXplKGksZSl7cmV0dXJuIGkmJnRoaXMuX2NlbnRlci5jb3B5KGkpLGUmJnRoaXMuX3NpemUuY29weShlKSx0aGlzfWdldCBjZW50ZXIoKXtyZXR1cm4gdGhpcy5fY2VudGVyfXNldCBjZW50ZXIoaSl7dGhpcy5fY2VudGVyLmNvcHkoaSl9Z2V0IHNpemUoKXtyZXR1cm4gdGhpcy5fc2l6ZX1zZXQgc2l6ZShpKXt0aGlzLl9zaXplLmNvcHkoaSksdGhpcy5faGFsZlNpemUuY29weShpKS5tdWx0aXBseVNjYWxhciguNSl9Z2V0IGhhbGZTaXplKCl7cmV0dXJuIHRoaXMuX2hhbGZTaXplfXJheVBpY2soaSxlKXtyZXR1cm4gbnVsbH19O2xldCBYZT1MaTtvKFhlLFwidjNfaGVscF8wXCIpLG8oWGUsXCJoZWxwTWF0cml4XCIpLG8oWGUsXCJoZWxwUmF5XCIpO2NsYXNzIERjIGV4dGVuZHMgWGV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcIl9waWNrUmV0XCIpLG8odGhpcyxcImJveFwiKSx0aGlzLl9zaGFwZVR5cGU9bXIuQm94LHRoaXMuYm94PW5ldyBCZShuZXcgZyxuZXcgZyl9cmF5UGljayhlLHQpe3RoaXMuYm94LnNldEZyb21DZW50ZXJBbmRTaXplKHRoaXMuY2VudGVyLHRoaXMuc2l6ZSk7bGV0IHM9WGUuaGVscE1hdHJpeDtzLmNvcHlGcm9tKHQpLmludmVydCgpO2xldCBhPVhlLmhlbHBSYXkuY29weShlKTthLmFwcGx5TWF0cml4KHMpO2xldCBuPWEuaW50ZXJzZWN0Qm94KHRoaXMuYm94LFhlLnYzX2hlbHBfMCk7cmV0dXJuIG4/KHRoaXMuX3BpY2tSZXR8fCh0aGlzLl9waWNrUmV0PXtpbnRlcnNlY3RQb2ludDpuZXcgZyxkaXN0YW5jZTowfSksdGhpcy5fcGlja1JldC5pbnRlcnNlY3RQb2ludD1uLHRoaXMuX3BpY2tSZXQuZGlzdGFuY2U9Zy5kaXN0YW5jZShhLm9yaWdpbixYZS52M19oZWxwXzApLHRoaXMuX3BpY2tSZXQpOm51bGx9fWNsYXNzIHJwIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcIl9zaGFwZVwiKSx0aGlzLl9zaGFwZT1uZXcgRGN9c3RhcnQoKXtBLnNldHRpbmcucGljay5tb2RlPT1cInBpeGVsXCImJnRoaXMudHJhbnNmb3JtLnNjZW5lM0Qudmlldy5waWNrRmlyZS5tb3VzZUVuYWJsZU1hcC5zZXQodGhpcy50cmFuc2Zvcm0ud29ybGRNYXRyaXguaW5kZXgsdGhpcyl9b25FbmFibGUoZSl7YWUuYmluZEVuYWJsZVBpY2soZSx0aGlzLG51bGwpfW9uRGlzYWJsZShlKXthZS51bkJpbmRFbmFibGVQaWNrKGUsdGhpcyl9Z2V0IHNoYXBlKCl7cmV0dXJuIHRoaXMuX3NoYXBlfXNldCBzaGFwZShlKXt0aGlzLl9zaGFwZT1lfXJheVBpY2soZSl7cmV0dXJuIHRoaXMuX2VuYWJsZT90aGlzLl9zaGFwZS5yYXlQaWNrKGUsdGhpcy50cmFuc2Zvcm0ud29ybGRNYXRyaXgpOm51bGx9YmVmb3JlRGVzdHJveShlKXtBLnNldHRpbmcucGljay5tb2RlPT1cInBpeGVsXCImJnRoaXMudHJhbnNmb3JtLnNjZW5lM0Qudmlldy5waWNrRmlyZS5tb3VzZUVuYWJsZU1hcC5kZWxldGUodGhpcy50cmFuc2Zvcm0ud29ybGRNYXRyaXguaW5kZXgpLHN1cGVyLmJlZm9yZURlc3Ryb3koZSl9fXZhciBQYz0oaT0+KGlbaS5QaW5nUG9uZz0wXT1cIlBpbmdQb25nXCIsaVtpLlJlcGVhdD0xXT1cIlJlcGVhdFwiLGlbaS5DbGFtcD0yXT1cIkNsYW1wXCIsaSkpKFBjfHx7fSk7Y2xhc3Mgc257Y29uc3RydWN0b3IoZT0wLHQ9MCl7byh0aGlzLFwic2VyaWFsaXplZFZlcnNpb25cIixcIjJcIiksbyh0aGlzLFwidGltZVwiKSxvKHRoaXMsXCJ2YWx1ZVwiKSxvKHRoaXMsXCJpblNsb3BlXCIsMCksbyh0aGlzLFwib3V0U2xvcGVcIiwwKSxvKHRoaXMsXCJ0YW5nZW50TW9kZVwiLDApLHRoaXMudGltZT1lLHRoaXMudmFsdWU9dH11blNlcmlhbGl6ZWQoZSl7dGhpcy5zZXJpYWxpemVkVmVyc2lvbj1lLnNlcmlhbGl6ZWRWZXJzaW9uLHRoaXMudGltZT1lLnRpbWUsdGhpcy52YWx1ZT1lLnZhbHVlLHRoaXMudGFuZ2VudE1vZGU9ZS50YW5nZW50TW9kZSx0aGlzLmluU2xvcGU9ZS5pblNsb3BlPT1cIkluZmluaXR5XCI/TmFOOmUuaW5TbG9wZSx0aGlzLm91dFNsb3BlPWUub3V0U2xvcGU9PVwiSW5maW5pdHlcIj9OYU46ZS5vdXRTbG9wZX11blNlcmlhbGl6ZWQyKGUpe3RoaXMuc2VyaWFsaXplZFZlcnNpb249ZS5zZXJpYWxpemVkVmVyc2lvbix0aGlzLnRpbWU9ZS50aW1lLHRoaXMudmFsdWU9ZS52YWx1ZSx0aGlzLnRhbmdlbnRNb2RlPWUudGFuZ2VudE1vZGUsdGhpcy5pblNsb3BlPWUuaW5UYW5nZW50PT1cIkluZmluaXR5XCI/TmFOOmUuaW5UYW5nZW50LHRoaXMub3V0U2xvcGU9ZS5vdXRUYW5nZW50PT1cIkluZmluaXR5XCI/TmFOOmUub3V0VGFuZ2VudH19Y2xhc3MgYW57Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJpbmRleFwiKSxvKHRoaXMsXCJ0aW1lXCIpLG8odGhpcyxcInRpbWVFbmRcIiksbyh0aGlzLFwiY29lZmZcIixbXSl9fWNsYXNzIGFhe2NvbnN0cnVjdG9yKGUsdD0xLHI9MSl7aWYobyh0aGlzLFwiX3RvdGFsVGltZVwiLDEpLG8odGhpcyxcIl9jYWNoZVwiLG5ldyBhbiksbyh0aGlzLFwiX2NhY2hlT3V0XCIse2xoc0luZGV4OjAscmhzSW5kZXg6MH0pLG8odGhpcyxcIl9JbnZhbGlkYXRlQ2FjaGVcIiwhMSksbyh0aGlzLFwiY3VydmVcIixbXSksbyh0aGlzLFwic2VyaWFsaXplZFZlcnNpb25cIiksbyh0aGlzLFwicHJlV2FycE1vZGVcIiksbyh0aGlzLFwicG9zdFdhcnBNb2RlXCIpLG8odGhpcyxcInJvdGF0aW9uT3JkZXJcIiksZSlmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl7Y29uc3QgYT1lW3NdO3RoaXMuYWRkS2V5RnJhbWUoYSl9dGhpcy5wcmVXYXJwTW9kZT10LHRoaXMucG9zdFdhcnBNb2RlPXJ9Z2V0IHRvdGFsVGltZSgpe3JldHVybiB0aGlzLl90b3RhbFRpbWV9Z2V0IGZpcnN0KCl7cmV0dXJuIHRoaXMuY3VydmVbMF19Z2V0IGxhc3QoKXtyZXR1cm4gdGhpcy5jdXJ2ZVt0aGlzLmN1cnZlLmxlbmd0aC0xXX1hZGRLZXlGcmFtZShlKXt0aGlzLmN1cnZlLmluZGV4T2YoZSk9PS0xJiZ0aGlzLmN1cnZlLnB1c2goZSksdGhpcy5jYWxjVG90YWxUaW1lKCl9cmVtb3ZlS2V5RnJhbWUoZSl7bGV0IHQ9dGhpcy5jdXJ2ZS5pbmRleE9mKGUpO3QhPS0xJiZ0aGlzLmN1cnZlLnNwbGljZSh0LDEpLHRoaXMuY2FsY1RvdGFsVGltZSgpfWNhbGN1bGF0ZUNhY2hlRGF0YShlLHQscixzPTApe2xldCBhPXRoaXMuY3VydmUsbj1hW3RdLGw9YVtyXTtlLmluZGV4PXQsZS50aW1lPW4udGltZStzLGUudGltZUVuZD1sLnRpbWUrcyxlLmluZGV4PXQ7bGV0IGgsdSxjLGYsZCxwLG07aD1sLnRpbWUtbi50aW1lLGg9TWF0aC5tYXgoaCwxZS00KSxjPWwudmFsdWUtbi52YWx1ZSx1PTEvKGgqaCksZj1uLm91dFNsb3BlLGQ9bC5pblNsb3BlLHA9ZipoLG09ZCpoLGUuY29lZmZbMF09KHArbS1jLWMpKnUvaCxlLmNvZWZmWzFdPShjK2MrYy1wLXAtbSkqdSxlLmNvZWZmWzJdPWYsZS5jb2VmZlszXT1uLnZhbHVlLHRoaXMuc2V0dXBTdGVwcGVkKGUuY29lZmYsbixsKX1nZXRWYWx1ZShlKXtyZXR1cm4gZT10aGlzLndyYXBUaW1lKGUpLHRoaXMuZmluZEN1cnZlKGUsdGhpcy5fY2FjaGVPdXQpLHRoaXMuY2FsY3VsYXRlQ2FjaGVEYXRhKHRoaXMuX2NhY2hlLHRoaXMuX2NhY2hlT3V0Lmxoc0luZGV4LHRoaXMuX2NhY2hlT3V0LnJoc0luZGV4LDApLHRoaXMuZXZhbHVhdGVDYWNoZSh0aGlzLl9jYWNoZSxlKX1nZXRLZXlDb3VudCgpe3JldHVybiB0aGlzLmN1cnZlLmxlbmd0aH1nZXRLZXkoZSl7cmV0dXJuIHRoaXMuY3VydmVbZV19dW5TZXJpYWxpemVkKGUpe3RoaXMucHJlV2FycE1vZGU9ZS5tX1ByZUluZmluaXR5LHRoaXMucG9zdFdhcnBNb2RlPWUubV9Qb3N0SW5maW5pdHksdGhpcy5yb3RhdGlvbk9yZGVyPWUubV9Sb3RhdGlvbk9yZGVyO2xldCB0PWUubV9DdXJ2ZS5sZW5ndGg7Zm9yKGxldCByPTA7cjx0O3IrKyl0aGlzLmN1cnZlW3JdPW5ldyBzbix0aGlzLmN1cnZlW3JdLnVuU2VyaWFsaXplZChlLm1fQ3VydmVbci50b1N0cmluZygpXSk7cmV0dXJuIHRoaXMuY2FsY1RvdGFsVGltZSgpLHRoaXN9dW5TZXJpYWxpemVkMihlKXt0aGlzLnByZVdhcnBNb2RlPWUucHJlV3JhcE1vZGUsdGhpcy5wb3N0V2FycE1vZGU9ZS5wb3N0V3JhcE1vZGU7bGV0IHQ9ZS5rZXlGcmFtZXN8fGUua2V5cyxyPXQubGVuZ3RoO2ZvcihsZXQgcz0wO3M8cjtzKyspdGhpcy5jdXJ2ZVtzXT1uZXcgc24sdGhpcy5jdXJ2ZVtzXS51blNlcmlhbGl6ZWQyKHRbcy50b1N0cmluZygpXSk7cmV0dXJuIHRoaXMuY2FsY1RvdGFsVGltZSgpLHRoaXN9d3JhcFRpbWUoZSl7bGV0IHQ9dGhpcy5jdXJ2ZSxyPXRbMF0udGltZSxzPXRbdC5sZW5ndGgtMV0udGltZTtyZXR1cm4gZTxyP3RoaXMucHJlV2FycE1vZGU9PTI/ZT1yOnRoaXMucHJlV2FycE1vZGU9PTA/ZT1KYShlLHIscyk6ZT1aYShlLHIscyk6ZT5zJiYodGhpcy5wb3N0V2FycE1vZGU9PTI/ZT1zOnRoaXMucG9zdFdhcnBNb2RlPT0wP2U9SmEoZSxyLHMpOmU9WmEoZSxyLHMpKSxlfWV2YWx1YXRlQ2FjaGUoZSx0KXtsZXQgcj10LWUudGltZTtyZXR1cm4gcioocioociplLmNvZWZmWzBdK2UuY29lZmZbMV0pK2UuY29lZmZbMl0pK2UuY29lZmZbM119ZmluZEN1cnZlKGUsdCl7bGV0IHI9dGhpcy5jdXJ2ZTtmb3IobGV0IHM9MTtzPHIubGVuZ3RoO3MrKyl7bGV0IGE9cltzLTFdLG49cltzXTthLnRpbWU8PWUmJm4udGltZT5lJiYodC5saHNJbmRleD1zLTEsdC5yaHNJbmRleD1zKX19c2V0dXBTdGVwcGVkKGUsdCxyKXsoaXNOYU4odC5vdXRTbG9wZSl8fGlzTmFOKHIuaW5TbG9wZSkpJiYoZVswXT0wLGVbMV09MCxlWzJdPTAsZVszXT10LnZhbHVlKX1pbnZhbGlkYXRlQ2FjaGUoKXt0aGlzLl9JbnZhbGlkYXRlQ2FjaGU9ITB9Y2FsY1RvdGFsVGltZSgpe2xldCBlPTA7Zm9yKGxldCB0IG9mIHRoaXMuY3VydmUpZT1NYXRoLm1heChlLHQudGltZSk7dGhpcy5fdG90YWxUaW1lPWV9c3RhdGljIHNjYWxlQ3VydmVWYWx1ZShlLHQpe2lmKCFlLl9JbnZhbGlkYXRlQ2FjaGUpZm9yKGxldCByPTA7cjxlLmN1cnZlLmxlbmd0aDtyKyspe2xldCBzPWUuY3VydmVbcl07cy52YWx1ZSo9dCxzLmluU2xvcGUqPXQscy5vdXRTbG9wZSo9dH1lLmludmFsaWRhdGVDYWNoZSgpfX1jbGFzcyBSYyBleHRlbmRzIGFhe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJhdHRyaWJ1dGVcIixcIlwiKSxvKHRoaXMsXCJwcm9wZXJ0eUxpc3RcIiksbyh0aGlzLFwicGF0aFwiKX11blNlcmlhbGl6ZWQoZSl7bGV0e2F0dHJpYnV0ZTp0LHBhdGg6cn09ZTtyZXR1cm4gdGhpcy5hdHRyaWJ1dGU9dCx0aGlzLnBhdGg9cix0aGlzLnByb3BlcnR5TGlzdD10LnNwbGl0KFwiLlwiKSxzdXBlci51blNlcmlhbGl6ZWQoZS5jdXJ2ZSksdGhpc319Y2xhc3MgTGN7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJjdXJ2ZVwiLHt9KX19dmFyIEFyPShpPT4oaVtpLkRlZmF1bHQ9MF09XCJEZWZhdWx0XCIsaVtpLkNsYW1wPTFdPVwiQ2xhbXBcIixpW2kuT25jZT0xXT1cIk9uY2VcIixpW2kuTG9vcD0yXT1cIkxvb3BcIixpW2kuUGluZ1Bvbmc9NF09XCJQaW5nUG9uZ1wiLGlbaS5DbGFtcEZvcmV2ZXI9OF09XCJDbGFtcEZvcmV2ZXJcIixpKSkoQXJ8fHt9KTtjbGFzcyBzcHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcIm5hbWVcIiksbyh0aGlzLFwib2JqQW5pbUNsaXBcIiksbyh0aGlzLFwidG90YWxUaW1lXCIsMCksbyh0aGlzLFwidGltZVwiLDApLG8odGhpcyxcIl9zdG9wVGltZVwiLDApLG8odGhpcyxcIl9sb29wVGltZVwiKSxvKHRoaXMsXCJfd3JhcE1vZGVcIiksbyh0aGlzLFwiX3NhbXBsZVJhdGVcIil9Z2V0IHdyYXBNb2RlKCl7cmV0dXJuIHRoaXMuX3dyYXBNb2RlfHwodGhpcy5fd3JhcE1vZGU9MCksdGhpcy5fd3JhcE1vZGV9c2V0IHdyYXBNb2RlKGUpe3RoaXMuX3dyYXBNb2RlPWV9cGFyc2UoZSl7dGhpcy5vYmpBbmltQ2xpcD17fTtsZXQgdD1lLkFuaW1hdGlvbkNsaXAse21fTmFtZTpyLG1fQW5pbWF0aW9uQ2xpcFNldHRpbmdzOnMsbV9XcmFwTW9kZTphLG1fU2FtcGxlUmF0ZTpufT10O3RoaXMubmFtZT1yLHRoaXMuX3dyYXBNb2RlPWEsdGhpcy5fc2FtcGxlUmF0ZT1uLHRoaXMuX2xvb3BUaW1lPXMubV9Mb29wVGltZTtmb3IoY29uc3QgbCBpbiB0Lm1fRWRpdG9yQ3VydmVzKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0Lm1fRWRpdG9yQ3VydmVzLGwpKXtjb25zdCBoPXQubV9FZGl0b3JDdXJ2ZXNbbF07bGV0IHU9aC5hdHRyaWJ1dGUsYz1uZXcgUmM7Yy51blNlcmlhbGl6ZWQoaCksdGhpcy50b3RhbFRpbWU9TWF0aC5tYXgodGhpcy50b3RhbFRpbWUsYy50b3RhbFRpbWUpO2xldCBmPXRoaXMub2JqQW5pbUNsaXBbaC5wYXRoXTtmfHwoZj1uZXcgTGMsdGhpcy5vYmpBbmltQ2xpcFtoLnBhdGhdPWYpLGYuY3VydmVbdV09Y319fWNsYXNzIFVje2NvbnN0cnVjdG9yKCl7byh0aGlzLFwidHJhbnNmb3JtXCIpLG8odGhpcyxcInF1YXRlcm5pb25cIiksbyh0aGlzLFwibWF0ZXJpYWxDb2xvclwiKX19Y2xhc3MgV3R7c3RhdGljIHVwZGF0ZVByb3BlcnR5VGFnKGUsdCl7ZS5xdWF0ZXJuaW9ufHwoZS5xdWF0ZXJuaW9uPXRoaXMudGFnX3F1YXRlcm5pb25bdF0pLGUudHJhbnNmb3JtfHwoZS50cmFuc2Zvcm09dGhpcy50YWdfdHJhbnNmb3JtW3RdKSxlLm1hdGVyaWFsQ29sb3J8fChlLm1hdGVyaWFsQ29sb3I9dGhpcy50YWdfbWF0ZXJpYWxDb2xvclt0XSl9fW8oV3QsXCJQcm9wZXJ0eVwiLHtcIm1fTG9jYWxQb3NpdGlvbi54XCI6XCJsb2NhbFBvc2l0aW9uLnhcIixcIm1fTG9jYWxQb3NpdGlvbi55XCI6XCJsb2NhbFBvc2l0aW9uLnlcIixcIm1fTG9jYWxQb3NpdGlvbi56XCI6XCJsb2NhbFBvc2l0aW9uLnpcIixcIm1fTG9jYWxSb3RhdGlvbi54XCI6XCJsb2NhbFF1YXRlcm5pb24ueFwiLFwibV9Mb2NhbFJvdGF0aW9uLnlcIjpcImxvY2FsUXVhdGVybmlvbi55XCIsXCJtX0xvY2FsUm90YXRpb24uelwiOlwibG9jYWxRdWF0ZXJuaW9uLnpcIixcIm1fTG9jYWxSb3RhdGlvbi53XCI6XCJsb2NhbFF1YXRlcm5pb24ud1wiLFwibG9jYWxFdWxlckFuZ2xlc1Jhdy54XCI6XCJsb2NhbFJvdGF0aW9uLnhcIixcImxvY2FsRXVsZXJBbmdsZXNSYXcueVwiOlwibG9jYWxSb3RhdGlvbi55XCIsXCJsb2NhbEV1bGVyQW5nbGVzUmF3LnpcIjpcImxvY2FsUm90YXRpb24uelwiLFwibV9Mb2NhbEV1bGVyQW5nbGVzLnhcIjpcImxvY2FsUm90YXRpb24ueFwiLFwibV9Mb2NhbEV1bGVyQW5nbGVzLnlcIjpcImxvY2FsUm90YXRpb24ueVwiLFwibV9Mb2NhbEV1bGVyQW5nbGVzLnpcIjpcImxvY2FsUm90YXRpb24uelwiLFwibV9Mb2NhbFNjYWxlLnhcIjpcImxvY2FsU2NhbGUueFwiLFwibV9Mb2NhbFNjYWxlLnlcIjpcImxvY2FsU2NhbGUueVwiLFwibV9Mb2NhbFNjYWxlLnpcIjpcImxvY2FsU2NhbGUuelwiLFwibV9Db2xvci5yXCI6XCJtYXRlcmlhbENvbG9yLnJcIixcIm1fQ29sb3IuZ1wiOlwibWF0ZXJpYWxDb2xvci5nXCIsXCJtX0NvbG9yLmJcIjpcIm1hdGVyaWFsQ29sb3IuYlwiLFwibV9Db2xvci5hXCI6XCJtYXRlcmlhbENvbG9yLmFcIixcIm1hdGVyaWFsLl9Db2xvci5yXCI6XCJtYXRlcmlhbENvbG9yLnJcIixcIm1hdGVyaWFsLl9Db2xvci5nXCI6XCJtYXRlcmlhbENvbG9yLmdcIixcIm1hdGVyaWFsLl9Db2xvci5iXCI6XCJtYXRlcmlhbENvbG9yLmJcIixcIm1hdGVyaWFsLl9Db2xvci5hXCI6XCJtYXRlcmlhbENvbG9yLmFcIixcIm1hdGVyaWFsLl9VbmxpdENvbG9yLnJcIjpcIm1hdGVyaWFsQ29sb3IuclwiLFwibWF0ZXJpYWwuX1VubGl0Q29sb3IuZ1wiOlwibWF0ZXJpYWxDb2xvci5nXCIsXCJtYXRlcmlhbC5fVW5saXRDb2xvci5iXCI6XCJtYXRlcmlhbENvbG9yLmJcIixcIm1hdGVyaWFsLl9VbmxpdENvbG9yLmFcIjpcIm1hdGVyaWFsQ29sb3IuYVwiLFwiZmllbGQgb2Ygdmlld1wiOlwiY2FtZXJhM0QuZm92XCIsbV9Jc0FjdGl2ZTpcImFjdGl2ZVwiLG1fU3ByaXRlOlwic3ByaXRlXCIsbV9GbGlwWDpcImZsaXBYXCIsbV9GbGlwWTpcImZsaXBZXCJ9KSxvKFd0LFwiU2NhbGVcIix7XCJtX0xvY2FsUG9zaXRpb24ueFwiOjEsXCJtX0xvY2FsUG9zaXRpb24ueVwiOjEsXCJtX0xvY2FsUG9zaXRpb24uelwiOi0xLFwibG9jYWxFdWxlckFuZ2xlc1Jhdy54XCI6LTEsXCJsb2NhbEV1bGVyQW5nbGVzUmF3LnlcIjoxLFwibG9jYWxFdWxlckFuZ2xlc1Jhdy56XCI6MSxcIm1fTG9jYWxFdWxlckFuZ2xlcy54XCI6LTEsXCJtX0xvY2FsRXVsZXJBbmdsZXMueVwiOjEsXCJtX0xvY2FsRXVsZXJBbmdsZXMuelwiOjEsXCJtX0xvY2FsUm90YXRpb24ueFwiOjEsXCJtX0xvY2FsUm90YXRpb24ueVwiOjEsXCJtX0xvY2FsUm90YXRpb24uelwiOi0xLFwibV9Mb2NhbFJvdGF0aW9uLndcIjotMSxcImZpZWxkIG9mIHZpZXdcIjoxLG1fSXNBY3RpdmU6MSxtX1Nwcml0ZToxfSksbyhXdCxcInRhZ19xdWF0ZXJuaW9uXCIse1wibV9Mb2NhbFJvdGF0aW9uLnhcIjohMCxcIm1fTG9jYWxSb3RhdGlvbi55XCI6ITAsXCJtX0xvY2FsUm90YXRpb24uelwiOiEwLFwibV9Mb2NhbFJvdGF0aW9uLndcIjohMH0pLG8oV3QsXCJ0YWdfbWF0ZXJpYWxDb2xvclwiLHtcIm1hdGVyaWFsLl9Db2xvci5yXCI6ITAsXCJtYXRlcmlhbC5fQ29sb3IuZ1wiOiEwLFwibWF0ZXJpYWwuX0NvbG9yLmJcIjohMCxcIm1hdGVyaWFsLl9Db2xvci5hXCI6ITAsXCJtYXRlcmlhbC5fVW5saXRDb2xvci5yXCI6ITAsXCJtYXRlcmlhbC5fVW5saXRDb2xvci5nXCI6ITAsXCJtYXRlcmlhbC5fVW5saXRDb2xvci5iXCI6ITAsXCJtYXRlcmlhbC5fVW5saXRDb2xvci5hXCI6ITB9KSxvKFd0LFwidGFnX3RyYW5zZm9ybVwiLHtcIm1fTG9jYWxQb3NpdGlvbi54XCI6ITAsXCJtX0xvY2FsUG9zaXRpb24ueVwiOiEwLFwibV9Mb2NhbFBvc2l0aW9uLnpcIjohMCxcIm1fTG9jYWxSb3RhdGlvbi54XCI6ITAsXCJtX0xvY2FsUm90YXRpb24ueVwiOiEwLFwibV9Mb2NhbFJvdGF0aW9uLnpcIjohMCxcIm1fTG9jYWxSb3RhdGlvbi53XCI6ITAsXCJsb2NhbEV1bGVyQW5nbGVzUmF3LnhcIjohMCxcImxvY2FsRXVsZXJBbmdsZXNSYXcueVwiOiEwLFwibG9jYWxFdWxlckFuZ2xlc1Jhdy56XCI6ITAsXCJtX0xvY2FsRXVsZXJBbmdsZXMueFwiOiEwLFwibV9Mb2NhbEV1bGVyQW5nbGVzLnlcIjohMCxcIm1fTG9jYWxFdWxlckFuZ2xlcy56XCI6ITAsXCJtX0xvY2FsU2NhbGUueFwiOiEwLFwibV9Mb2NhbFNjYWxlLnlcIjohMCxcIm1fTG9jYWxTY2FsZS56XCI6ITB9KTtjb25zdCBvbj1jbGFzc3tjb25zdHJ1Y3RvcihpKXtvKHRoaXMsXCJfcm9vdE9iamVjdDNEXCIpLG8odGhpcyxcIl9hbmltYXRpb25cIiksbyh0aGlzLFwiX3Byb3BlcnR5Q2FjaGVcIiksbyh0aGlzLFwiX2N1cnJlbnRDbGlwXCIpLG8odGhpcyxcIl9mcmFtZVwiLDApLG8odGhpcyxcIl90aW1lXCIsMCksbyh0aGlzLFwiX2lzUGxheWluZ1wiLCEwKSxvKHRoaXMsXCJzcGVlZFwiLDEpLG8odGhpcyxcIl9wcm9wZXJ0eVRhZ0RpY1wiKSx0aGlzLl9yb290T2JqZWN0M0Q9aS5vYmplY3QzRCx0aGlzLl9hbmltYXRpb249aSx0aGlzLl9wcm9wZXJ0eVRhZ0RpYz1uZXcgTWFwLHRoaXMucmVzZXQoKX1yZXNldCgpe3RoaXMuX3Byb3BlcnR5Q2FjaGU9e30sdGhpcy5fcHJvcGVydHlUYWdEaWMuY2xlYXIoKX1nZXQgdGltZSgpe3JldHVybiB0aGlzLl90aW1lfWdldCBjdXJyZW50Q2xpcCgpe3JldHVybiB0aGlzLl9jdXJyZW50Q2xpcH1wbGF5KGksZT0hMCl7dGhpcy5faXNQbGF5aW5nPSEwLGUmJih0aGlzLl90aW1lPTApLGkhPXRoaXMuX2N1cnJlbnRDbGlwJiZpJiZ0aGlzLnBhcnNlQW5pbUNsaXAoaSksdGhpcy5fY3VycmVudENsaXA9aSx0aGlzLnZhbGlkUHJvcGVydHkoKX1wYXJzZUFuaW1DbGlwKGkpe3ZhciBlO3RoaXMucmVzZXQoKTtmb3IoY29uc3QgdCBpbiBpLm9iakFuaW1DbGlwKXtsZXQgcj1pLm9iakFuaW1DbGlwW3RdLHM9dGhpcy5fcm9vdE9iamVjdDNELGE9e307aWYodD09XCJcIj9zPXRoaXMuX3Jvb3RPYmplY3QzRDpzPXRoaXMuX3Jvb3RPYmplY3QzRC5nZXRPYmplY3RCeU5hbWUodCksIXMpY29udGludWU7bGV0IG49bmV3IFVjO3RoaXMuX3Byb3BlcnR5VGFnRGljLnNldChzLG4pO2xldCBsPXIuY3VydmU7Zm9yKGNvbnN0IGggaW4gbCl7V3QudXBkYXRlUHJvcGVydHlUYWcobixoKTtsZXQgdT0oZT10aGlzLl9wcm9wZXJ0eUNhY2hlKVt0XXx8KGVbdF09e30pLGM9V3QuUHJvcGVydHlbaF0uc3BsaXQoXCIuXCIpLGY9Y1swXTtpZihjLmxlbmd0aD4xKXtsZXQgZD1hW2ZdO2R8fChkPWFbZl09c1tmXSksdVtoXT17dmFsdWU6ZCxwcm9wZXJ0eTpjWzFdfX1lbHNlIHVbaF09e3ZhbHVlOnMscHJvcGVydHk6Y1swXX19fXJldHVybiB0aGlzfXN0b3AoKXtyZXR1cm4gdGhpcy5faXNQbGF5aW5nPSExLHRoaXN9dG9nZ2xlKCl7cmV0dXJuIHRoaXMuX2lzUGxheWluZz0hdGhpcy5faXNQbGF5aW5nLHRoaXN9Z2V0IGlzUGxheWluZygpe3JldHVybiB0aGlzLl9pc1BsYXlpbmd9dXBkYXRlKGksZSl7aWYoaT1pKi4wMDEsZT1lKi4wMDEsIXRoaXMuX2N1cnJlbnRDbGlwfHx0aGlzLl9mcmFtZT09aXx8IXRoaXMuX2lzUGxheWluZylyZXR1cm47dGhpcy5fZnJhbWU9aTtsZXQgdD10aGlzLl90aW1lO3RoaXMuX3RpbWU9dGhpcy5jYWxjVGltZSh0K2UqdGhpcy5zcGVlZCksdGhpcy52YWxpZFByb3BlcnR5KCksdGhpcy5fY3VycmVudENsaXAud3JhcE1vZGUhPUFyLkxvb3AmJnRoaXMuX2N1cnJlbnRDbGlwLndyYXBNb2RlIT1Bci5EZWZhdWx0JiYodGhpcy5zcGVlZD4wP3RoaXMuX3RpbWU+PXRoaXMuX2N1cnJlbnRDbGlwLnRvdGFsVGltZTp0aGlzLl90aW1lPD0wKSYmKHRoaXMuX2lzUGxheWluZz0hMSx0aGlzLl9hbmltYXRpb24uc3RhdHVzQ2FsbChvbi5Db21wbGV0ZSx0LHRoaXMuX3RpbWUpKSx0aGlzLl9hbmltYXRpb24uc3RhdHVzQ2FsbChvbi5TZWVrLHQsdGhpcy5fdGltZSl9c2VlayhpKXtyZXR1cm4gdGhpcy5fdGltZT10aGlzLmNhbGNUaW1lKGkpLHRoaXMuX3Jvb3RPYmplY3QzRCYmdGhpcy52YWxpZFByb3BlcnR5KCksdGhpc31jYWxjVGltZShpKXtyZXR1cm4gdGhpcy5fY3VycmVudENsaXAud3JhcE1vZGU9PUFyLkxvb3B8fHRoaXMuX2N1cnJlbnRDbGlwLndyYXBNb2RlPT1Bci5EZWZhdWx0P2k9cm8oaSx0aGlzLl9jdXJyZW50Q2xpcC50b3RhbFRpbWUpOmk9SyhpLDAsdGhpcy5fY3VycmVudENsaXAudG90YWxUaW1lKSxpfXZhbGlkUHJvcGVydHkoKXtmb3IoY29uc3QgaSBpbiB0aGlzLl9jdXJyZW50Q2xpcC5vYmpBbmltQ2xpcCl7bGV0IHQ9dGhpcy5fY3VycmVudENsaXAub2JqQW5pbUNsaXBbaV0uY3VydmU7Zm9yKGNvbnN0IHIgaW4gdCl7Y29uc3Qgcz10W3JdO2xldCBhPXRoaXMuX3Byb3BlcnR5Q2FjaGVbaV1bcl0sbj1zLmdldFZhbHVlKHRoaXMuX3RpbWUpO3IgaW4gV3QuU2NhbGUmJihuKj1XdC5TY2FsZVtyXSksYS52YWx1ZVthLnByb3BlcnR5XT1ufX10aGlzLl9wcm9wZXJ0eVRhZ0RpYy5mb3JFYWNoKChpLGUpPT57dGhpcy5hcHBseVByb3BlcnR5KGksZSl9KX1hcHBseVByb3BlcnR5KGksZSl7aS5xdWF0ZXJuaW9uJiZWLmdldEV1bGVyKGUudHJhbnNmb3JtLmxvY2FsUm90YXRpb24sZS50cmFuc2Zvcm0ubG9jYWxSb3RRdWF0LCEwLFwiWllYXCIpLGkudHJhbnNmb3JtJiYoZS50cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbj1lLnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLGUudHJhbnNmb3JtLmxvY2FsUm90YXRpb249ZS50cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbixlLnRyYW5zZm9ybS5sb2NhbFNjYWxlPWUudHJhbnNmb3JtLmxvY2FsU2NhbGUpO2xldCB0PWU7aS5tYXRlcmlhbENvbG9yJiZ0Lm5vdGlmeU1hdGVyaWFsQ29sb3JDaGFuZ2UoMCxcImJhc2VDb2xvclwiKX19O2xldCBfcj1vbjtvKF9yLFwiQ29tcGxldGVcIiwwKSxvKF9yLFwiU2Vla1wiLDEpO2NsYXNzIGFwe2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiY2xpcE5hbWVcIiksbyh0aGlzLFwiZGF0YVwiKSxvKHRoaXMsXCJ0aW1lXCIpfX1jbGFzcyBVaSBleHRlbmRzIGple2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIodCksbyh0aGlzLFwiYW5pbWF0aW9uXCIpLG8odGhpcyxcImZyYW1lXCIpLHRoaXMuYW5pbWF0aW9uPWV9fW8oVWksXCJTRUVLXCIsXCJTRUVLXCIpLG8oVWksXCJDT01QTEVURVwiLFwiQ09NUExFVEVcIik7Y2xhc3MgQW4gZXh0ZW5kcyBFZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiX2FuaW1hdG9yXCIpLG8odGhpcyxcIl9jbGlwc1wiLFtdKSxvKHRoaXMsXCJkZWZhdWx0Q2xpcFwiKSxvKHRoaXMsXCJhdXRvUGxheVwiKSxvKHRoaXMsXCJfc2Vla0V2ZW50XCIpLG8odGhpcyxcIl9jb21wbGV0ZUV2ZW50XCIpLG8odGhpcyxcIl9rZXlGcmFtZUxpc3RcIiksdGhpcy5fc2Vla0V2ZW50PW5ldyBVaSh0aGlzLFVpLlNFRUspLHRoaXMuX2NvbXBsZXRlRXZlbnQ9bmV3IFVpKHRoaXMsVWkuQ09NUExFVEUpLHRoaXMuX2tleUZyYW1lTGlzdD17fX1yZWdpc3RlckV2ZW50S2V5RnJhbWUoZSl7bGV0IHQ9dGhpcy5fa2V5RnJhbWVMaXN0W2UuY2xpcE5hbWVdO3Q9PW51bGwmJih0aGlzLl9rZXlGcmFtZUxpc3RbZS5jbGlwTmFtZV09dD1bXSksdC5wdXNoKGUpfWluaXQoKXt0aGlzLl9hbmltYXRvcj1uZXcgX3IodGhpcyl9b25VcGRhdGUoKXt0aGlzLmVuYWJsZSYmdGhpcy5fYW5pbWF0b3IudXBkYXRlKGhlLnRpbWUsaGUuZGVsdGEpfWFwcGVuZENsaXAoZSl7dGhpcy5fY2xpcHMucHVzaChlKSx0aGlzLnBsYXkoZS5uYW1lKX1zdGF0dXNDYWxsKGUsdCxyKXtpZihlPT1fci5Db21wbGV0ZSl0aGlzLmV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KHRoaXMuX2NvbXBsZXRlRXZlbnQpO2Vsc2UgaWYoZT09X3IuU2VlayYmdCE9cil7bGV0IHM9dGhpcy5fa2V5RnJhbWVMaXN0W3RoaXMuY3VycmVudENsaXAubmFtZV07aWYocylmb3IobGV0IGEgb2YgcylhLnRpbWU+dCYmYS50aW1lPD1yJiYodGhpcy5fc2Vla0V2ZW50LmRhdGE9dGhpcy5fc2Vla0V2ZW50LmZyYW1lPWEsdGhpcy5ldmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCh0aGlzLl9zZWVrRXZlbnQpKX19c2V0IHNwZWVkKGUpe3RoaXMuX2FuaW1hdG9yLnNwZWVkPWV9Z2V0IHNwZWVkKCl7cmV0dXJuIHRoaXMuX2FuaW1hdG9yLnNwZWVkfXN0b3AoKXt0aGlzLl9hbmltYXRvci5zdG9wKCl9dG9nZ2xlKCl7dGhpcy5fYW5pbWF0b3IudG9nZ2xlKCl9Z2V0Q2xpcChlKXtsZXQgdDtmb3IobGV0IHIgb2YgdGhpcy5fY2xpcHMpaWYoci5uYW1lPT1lKXt0PXI7YnJlYWt9cmV0dXJuIHR9Z2V0IGN1cnJlbnRDbGlwKCl7cmV0dXJuIHRoaXMuX2FuaW1hdG9yLmN1cnJlbnRDbGlwfWdldCB0aW1lKCl7cmV0dXJuIHRoaXMuX2FuaW1hdG9yLnRpbWV9c2VlayhlKXt0aGlzLl9hbmltYXRvci5zZWVrKGUpfXBsYXkoZSx0PSEwKXtsZXQgcj10aGlzLmdldENsaXAoZSk7cmV0dXJuIHI/KHRoaXMuX2FuaW1hdG9yLnBsYXkocix0KSxyKTpudWxsfXN0YXJ0KCl7dGhpcy5hdXRvUGxheSYmdGhpcy5wbGF5KHRoaXMuZGVmYXVsdENsaXApfWNvcHlDb21wb25lbnQoZSl7dGhpcy5hdXRvUGxheT1lLmF1dG9QbGF5LHRoaXMuZGVmYXVsdENsaXA9ZS5kZWZhdWx0Q2xpcDtsZXQgdD1lLl9jbGlwcztmb3IobGV0IHI9MCxzPXQubGVuZ3RoO3I8cztyKyspdGhpcy5hcHBlbmRDbGlwKHRbcl0pO3JldHVybiB0aGlzfWNsb25lVG8oZSl7ZS5hZGRDb21wb25lbnQoQW4pLmNvcHlDb21wb25lbnQodGhpcyl9fWNsYXNzIG9wIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcIl90YXJnZXRSZW5kZXJlcnNcIix7fSksbyh0aGlzLFwiX3ZlYzNcIixuZXcgZyksbyh0aGlzLFwiX21hdHJpeDRcIixuZXcgViksbyh0aGlzLFwiX3F1YXRlcm5pb25cIixuZXcgcSl9aW5pdChlKXtsZXQgdD10aGlzLmZldGNoTW9ycGhSZW5kZXJlcnModGhpcy5vYmplY3QzRCk7Zm9yKGNvbnN0IHIgb2YgdCl7VHQuaGFzTWFzayhyLnJlbmRlcmVyTWFzayxVZS5Nb3JwaFRhcmdldCkmJnIuc2VsZkNsb25lTWF0ZXJpYWxzKFwiTU9SUEhfVEFSR0VUX1VVSURcIik7Zm9yKGNvbnN0IGEgaW4gci5nZW9tZXRyeS5tb3JwaFRhcmdldERpY3Rpb25hcnkpe2xldCBuPXRoaXMuX3RhcmdldFJlbmRlcmVyc1thXXx8W107bi5wdXNoKHIpLHRoaXMuX3RhcmdldFJlbmRlcmVyc1thXT1ufX19Z2V0TW9ycGhSZW5kZXJlcnNCeUtleShlKXtyZXR1cm4gdGhpcy5fdGFyZ2V0UmVuZGVyZXJzW2VdfWNsb25lTW9ycGhSZW5kZXJlcnMoKXtsZXQgZT17fTtmb3IobGV0IHQgaW4gdGhpcy5fdGFyZ2V0UmVuZGVyZXJzKWVbdF09dGhpcy5fdGFyZ2V0UmVuZGVyZXJzW3RdO3JldHVybiBlfWFwcGx5QmxlbmRTaGFwZShlLHQscj0xKXtpZighZSl7Y29uc29sZS53YXJuKFwiYmxlbmRTaGFwZSBpcyBudWxsXCIpO3JldHVybn10aGlzLl92ZWMzLnNldEZyb21BcnJheShlLnRyYW5zZm9ybS50cmFuc2Zvcm1bM10pLHRoaXMuX3ZlYzMubXVsdGlwbHlTY2FsYXIociksdGhpcy5vYmplY3QzRC50cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbj10aGlzLl92ZWMzLHRoaXMuX3ZlYzMuc2V0RnJvbUFycmF5KGUudHJhbnNmb3JtLnRyYW5zZm9ybVsyXSksdGhpcy5fbWF0cml4NC5jb3B5Q29sRnJvbSgyLHRoaXMuX3ZlYzMpLHRoaXMuX3ZlYzMuc2V0RnJvbUFycmF5KGUudHJhbnNmb3JtLnRyYW5zZm9ybVsxXSksdGhpcy5fbWF0cml4NC5jb3B5Q29sRnJvbSgxLHRoaXMuX3ZlYzMpLHRoaXMuX3ZlYzMuc2V0RnJvbUFycmF5KGUudHJhbnNmb3JtLnRyYW5zZm9ybVswXSksdGhpcy5fbWF0cml4NC5jb3B5Q29sRnJvbSgwLHRoaXMuX3ZlYzMpLHRoaXMuX21hdHJpeDQudHJhbnNwb3NlKCksdGhpcy5fcXVhdGVybmlvbi5mcm9tTWF0cml4KHRoaXMuX21hdHJpeDQpLHRoaXMub2JqZWN0M0QubG9jYWxRdWF0ZXJuaW9uPXRoaXMuX3F1YXRlcm5pb247Zm9yKGxldCBzIGluIHQpe2xldCBhPXRoaXMuX3RhcmdldFJlbmRlcmVyc1tzXSxuPXRbc10sbD1lLnRleHR1cmVbbl07dGhpcy5hcHBseU1vcnBoVGFyZ2V0SW5mbHVlbmNlKHMsbCxhKX19YXBwbHlNb3JwaFRhcmdldEluZmx1ZW5jZShlLHQscil7Zm9yKGxldCBzIG9mIHIpcy5zZXRNb3JwaEluZmx1ZW5jZShlLHQpfWZldGNoTW9ycGhSZW5kZXJlcnMoZSl7bGV0IHQ9ZS5nZXRDb21wb25lbnRzSW5DaGlsZChjZSkscj1bXTtmb3IobGV0IHMgb2YgdClzLmhhc01hc2soVWUuTW9ycGhUYXJnZXQpJiZyLnB1c2gocyk7cmV0dXJuIHJ9fWNsYXNzIG5we2NvbnN0cnVjdG9yKCl7byh0aGlzLFwidGV4dHVyZVwiKSxvKHRoaXMsXCJ0cmFuc2Zvcm1cIil9fWNsYXNzIGxwe2NvbnN0cnVjdG9yKGUsdCl7byh0aGlzLFwiX2NvbXB1dGVQaXBlbGluZVwiKSxvKHRoaXMsXCJfY29tcHV0ZUJpbmRHcm91cFwiKTtsZXQgcj1TLmRldmljZTt0aGlzLl9jb21wdXRlUGlwZWxpbmU9ci5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2xheW91dDpcImF1dG9cIixjb21wdXRlOnttb2R1bGU6ci5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6ZX0pLGVudHJ5UG9pbnQ6XCJDc01haW5cIn19KSx0aGlzLl9jb21wdXRlQmluZEdyb3VwPXIuY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6dGhpcy5fY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOnR9KX1jb21wdXRlKGUsdCxyLHMpe2xldCBhPWUuYmVnaW5Db21wdXRlUGFzcygpO3JldHVybiBhLnNldFBpcGVsaW5lKHRoaXMuX2NvbXB1dGVQaXBlbGluZSksYS5zZXRCaW5kR3JvdXAoMCx0aGlzLl9jb21wdXRlQmluZEdyb3VwKSxhLmRpc3BhdGNoV29ya2dyb3Vwcyh0LHIscyksYS5lbmQoKSx0aGlzfX1jbGFzcyBocCBleHRlbmRzIHpye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJudW1Kb2ludFwiKSxvKHRoaXMsXCJudW1TdGF0ZVwiKSxvKHRoaXMsXCJ0aW1lXCIpLG8odGhpcyxcIndlaWdodFwiKSxvKHRoaXMsXCJhcmd1bWVudHNEYXRhXCIpLG8odGhpcyxcIl9pc0RpcnR5XCIsITEpLG8odGhpcyxcIl9hcmd1bWVudHNCdWZmZXJcIiksbyh0aGlzLFwiX2FyZ3VtZW50c0J1ZmZlckVudHJpZXNcIiksdGhpcy5hbGxvY2F0aW9uTWVtb3J5U2V0KFt7bmFtZTpcIm51bUpvaW50XCIsZGF0YTpbMF19LHtuYW1lOlwibnVtU3RhdGVcIixkYXRhOlswXX0se25hbWU6XCJyZXRhaW4xXCIsZGF0YTpbMF19LHtuYW1lOlwicmV0YWluMlwiLGRhdGE6WzBdfSx7bmFtZTpcInRpbWVcIixkYXRhOlswLDBdfSx7bmFtZTpcIndlaWdodFwiLGRhdGE6WzAsMF19XSksdGhpcy5nZW5lcmF0ZUdQVUJ1ZmZlcigpfWdldEdQVUJ1ZmZlcigpe3JldHVybiB0aGlzLl9hcmd1bWVudHNCdWZmZXJ9Z2V0R1BVQmluZEdyb3VwRW50cnkoKXtyZXR1cm4gdGhpcy5fYXJndW1lbnRzQnVmZmVyRW50cmllc311cGRhdGVHUFVCdWZmZXIoKXtyZXR1cm4gdGhpcy5faXNEaXJ0eSYmKHRoaXMuX2lzRGlydHk9ITEsUy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodGhpcy5fYXJndW1lbnRzQnVmZmVyLDAsdGhpcy5zaGFyZURhdGFCdWZmZXIpKSx0aGlzfWFsbG9jYXRpb25NZW1vcnlTZXQoZSl7dGhpcy5hcmd1bWVudHNEYXRhPXt9O2xldCB0PTA7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspe2NvbnN0IGE9ZVtzXTt0Kz1hLmRhdGEubGVuZ3RofXRoaXMuYWxsb2NhdGlvbih0KjQpO2xldCByPXRoaXM7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspe2NvbnN0IGE9ZVtzXSxuPWEubmFtZTt0aGlzLmFyZ3VtZW50c0RhdGFbbl09dGhpcy5hbGxvY2F0aW9uX25vZGUoYS5kYXRhLmxlbmd0aCo0KSxyW25dPXRoaXMuYXJndW1lbnRzRGF0YVtuXX19Z2VuZXJhdGVHUFVCdWZmZXIoKXtsZXQgZT1TLmRldmljZTt0aGlzLl9hcmd1bWVudHNCdWZmZXI9ZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5zaGFyZURhdGFCdWZmZXIuYnl0ZUxlbmd0aCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULG1hcHBlZEF0Q3JlYXRpb246ITF9KSx0aGlzLl9hcmd1bWVudHNCdWZmZXJFbnRyaWVzPXtiaW5kaW5nOjAscmVzb3VyY2U6e2J1ZmZlcjp0aGlzLl9hcmd1bWVudHNCdWZmZXIsb2Zmc2V0OjAsc2l6ZTp0aGlzLnNoYXJlRGF0YUJ1ZmZlci5ieXRlTGVuZ3RofX19fWNsYXNzIHVwIGV4dGVuZHMgenJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcIm51bUpvaW50XCIpLG8odGhpcyxcIm51bUZyYW1lXCIpLG8odGhpcyxcInJldGFpbjBcIiksbyh0aGlzLFwicmV0YWluMVwiKSxvKHRoaXMsXCJhcmd1bWVudHNEYXRhXCIpLG8odGhpcyxcIl9pc0RpcnR5XCIsITEpLG8odGhpcyxcIl9hcmd1bWVudHNCdWZmZXJcIiksbyh0aGlzLFwiX2FyZ3VtZW50c0J1ZmZlckVudHJpZXNcIiksdGhpcy5hbGxvY2F0aW9uTWVtb3J5U2V0KFt7bmFtZTpcIm51bUpvaW50XCIsZGF0YTpbMF19LHtuYW1lOlwibnVtRnJhbWVcIixkYXRhOlswXX0se25hbWU6XCJyZXRhaW4wXCIsZGF0YTpbMF19LHtuYW1lOlwicmV0YWluMVwiLGRhdGE6WzBdfV0pLHRoaXMuZ2VuZXJhdGVHUFVCdWZmZXIoKX1nZXRHUFVCdWZmZXIoKXtyZXR1cm4gdGhpcy5fYXJndW1lbnRzQnVmZmVyfWdldEdQVUJpbmRHcm91cEVudHJ5KCl7cmV0dXJuIHRoaXMuX2FyZ3VtZW50c0J1ZmZlckVudHJpZXN9dXBkYXRlR1BVQnVmZmVyKCl7dGhpcy5faXNEaXJ0eSYmKHRoaXMuX2lzRGlydHk9ITEsUy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodGhpcy5fYXJndW1lbnRzQnVmZmVyLDAsdGhpcy5zaGFyZURhdGFCdWZmZXIpKX1hbGxvY2F0aW9uTWVtb3J5U2V0KGUpe3RoaXMuYXJndW1lbnRzRGF0YT17fTtsZXQgdD0wO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cysrKXtjb25zdCBhPWVbc107dCs9YS5kYXRhLmxlbmd0aH10aGlzLmFsbG9jYXRpb24odCo0KTtsZXQgcj10aGlzO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cysrKXtjb25zdCBhPWVbc10sbj1hLm5hbWU7dGhpcy5hcmd1bWVudHNEYXRhW25dPXRoaXMuYWxsb2NhdGlvbl9ub2RlKGEuZGF0YS5sZW5ndGgqNCkscltuXT10aGlzLmFyZ3VtZW50c0RhdGFbbl19fWdlbmVyYXRlR1BVQnVmZmVyKCl7bGV0IGU9Uy5kZXZpY2U7dGhpcy5fYXJndW1lbnRzQnVmZmVyPWUuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMuc2hhcmVEYXRhQnVmZmVyLmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCxtYXBwZWRBdENyZWF0aW9uOiExfSksdGhpcy5fYXJndW1lbnRzQnVmZmVyRW50cmllcz17YmluZGluZzowLHJlc291cmNlOntidWZmZXI6dGhpcy5fYXJndW1lbnRzQnVmZmVyLG9mZnNldDowLHNpemU6dGhpcy5zaGFyZURhdGFCdWZmZXIuYnl0ZUxlbmd0aH19fX1sZXQgY3A9YFxuICAke0JzfVxuXG4gIHN0cnVjdCBBcmd1bWVudHMge1xuICAgIG51bUpvaW50OiBmMzIsXG4gICAgbnVtU3RhdGU6IGYzMixcbiAgICByZXRhaW4xOiBmMzIsXG4gICAgcmV0YWluMjogZjMyLFxuICAgIHRpbWU6IHZlYzI8ZjMyPixcbiAgICB3ZWlnaHQ6IHZlYzI8ZjMyPixcbiAgfTtcblxuICBzdHJ1Y3QgSm9pbnREYXRhIHtcbiAgICBzY2FsZTogdmVjNDxmMzI+LFxuICAgIHJvdGF0aW9uOiB2ZWM0PGYzMj4sXG4gICAgdHJhbnNsYXRpb246IHZlYzQ8ZjMyPixcbiAgfTtcblxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IGFyZ3M6IEFyZ3VtZW50cztcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBqb2ludHNGaW5hbE1hdHJpeDogYXJyYXk8bWF0NHg0PGYzMj4+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IGpvaW50c1dvcmxkTWF0cml4OiBhcnJheTxtYXQ0eDQ8ZjMyPj47XG5cbiAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDEpXG4gIGZuIENzTWFpbihAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZDogdmVjMzx1MzI+LCBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pbmRleDogdTMyKSB7XG4gICAgbGV0IG51bUpvaW50ID0gaTMyKGFyZ3MubnVtSm9pbnQpO1xuICAgIGxldCBudW1TdGF0ZSA9IGkzMihhcmdzLm51bVN0YXRlKTtcbiAgICBsZXQgbkpvaW50SW5kZXggPSBpMzIod29ya2dyb3VwX2lkLngpO1xuXG4gICAgam9pbnRzRmluYWxNYXRyaXhbbkpvaW50SW5kZXhdID0gbWl4TWF0cml4NHg0KGpvaW50c1dvcmxkTWF0cml4WzAgKiBudW1Kb2ludCArIG5Kb2ludEluZGV4XSwgam9pbnRzV29ybGRNYXRyaXhbMSAqIG51bUpvaW50ICsgbkpvaW50SW5kZXhdLCBhcmdzLnRpbWVbMF0pICogYXJncy53ZWlnaHRbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bVN0YXRlOyBpKyspIHtcbiAgICAgIGpvaW50c0ZpbmFsTWF0cml4W25Kb2ludEluZGV4XSArPSBtaXhNYXRyaXg0eDQoam9pbnRzV29ybGRNYXRyaXhbKGkgKiAyICsgMCkgKiBudW1Kb2ludCArIG5Kb2ludEluZGV4XSwgam9pbnRzV29ybGRNYXRyaXhbKGkgKiAyICsgMSkgKiBudW1Kb2ludCArIG5Kb2ludEluZGV4XSwgYXJncy50aW1lW2ldKSAqIGFyZ3Mud2VpZ2h0W2ldO1xuICAgIH1cbiAgfVxuYCxmcD1gXG4gICR7QnN9XG5cbiAgc3RydWN0IEFyZ3VtZW50cyB7XG4gICAgbnVtSm9pbnQ6IGYzMixcbiAgICBudW1GcmFtZTogZjMyLFxuICAgIHJldGFpbjA6IGYzMixcbiAgICByZXRhaW4xOiBmMzIsXG4gIH07XG5cbiAgc3RydWN0IEpvaW50RGF0YSB7XG4gICAgc2NhbGU6IHZlYzQ8ZjMyPixcbiAgICByb3RhdGlvbjogdmVjNDxmMzI+LFxuICAgIHRyYW5zbGF0aW9uOiB2ZWM0PGYzMj4sXG4gIH07XG5cbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBhcmdzOiBBcmd1bWVudHM7XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gam9pbnRzS2V5ZnJhbWU6IGFycmF5PEpvaW50RGF0YT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gam9pbnRzV29ybGRNYXRyaXg6IGFycmF5PG1hdDR4NDxmMzI+PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBqb2ludHNQYXJlbnRJbmRleDogYXJyYXk8ZjMyPjtcblxuICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoMSlcbiAgZm4gQ3NNYWluKEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkOiB2ZWMzPHUzMj4sIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2luZGV4OiB1MzIpIHtcbiAgICBsZXQgbnVtSm9pbnQgPSBpMzIoYXJncy5udW1Kb2ludCk7XG4gICAgbGV0IG5GcmFtZUluZGV4ID0gaTMyKHdvcmtncm91cF9pZC54KTtcbiAgICBmb3IgKHZhciBuSm9pbnRJbmRleCA9IDA7IG5Kb2ludEluZGV4IDwgbnVtSm9pbnQ7IG5Kb2ludEluZGV4KyspIHtcbiAgICAgIGxldCBkYXRhSW5kZXggPSBuRnJhbWVJbmRleCAqIG51bUpvaW50ICsgbkpvaW50SW5kZXg7XG4gICAgICBsZXQgam9pbnQgPSBqb2ludHNLZXlmcmFtZVtkYXRhSW5kZXhdO1xuICAgICAgbGV0IGpvaW50TG9jYWxNYXRyaXggPSBNYWtlTWF0cml4NHg0KGpvaW50LnNjYWxlLnh5eiwgam9pbnQucm90YXRpb24sIGpvaW50LnRyYW5zbGF0aW9uLnh5eik7XG5cbiAgICAgIGxldCBuUGFyZW50SW5kZXggPSBpMzIoam9pbnRzUGFyZW50SW5kZXhbbkpvaW50SW5kZXhdKTtcbiAgICAgIGlmIChuUGFyZW50SW5kZXggPCAwKSB7XG4gICAgICAgIGpvaW50c1dvcmxkTWF0cml4W2RhdGFJbmRleF0gPSBqb2ludExvY2FsTWF0cml4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pbnRzV29ybGRNYXRyaXhbZGF0YUluZGV4XSA9IGpvaW50c1dvcmxkTWF0cml4W25GcmFtZUluZGV4ICogbnVtSm9pbnQgKyBuUGFyZW50SW5kZXhdICogam9pbnRMb2NhbE1hdHJpeDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbmA7Y2xhc3MgZHAgZXh0ZW5kcyBFZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiY29udGV4dFwiKSxvKHRoaXMsXCJnYWluXCIpLHRoaXMuY29udGV4dD1uZXcgQXVkaW9Db250ZXh0LHRoaXMuZ2Fpbj10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpLHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbil9c3RhcnQoKXt9b25VcGRhdGUoKXtpZighdGhpcy5jb250ZXh0KXJldHVybjtjb25zdCBlPXRoaXMuY29udGV4dC5saXN0ZW5lcix0PXRoaXMub2JqZWN0M0QudHJhbnNmb3JtLndvcmxkUG9zaXRpb24scj10aGlzLm9iamVjdDNELnRyYW5zZm9ybS5mb3J3YXJkLHM9dGhpcy5vYmplY3QzRC50cmFuc2Zvcm0udXA7aWYoIWlzTmFOKHIueCkpaWYoZS5wb3NpdGlvblgpe2NvbnN0IGE9dGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO2UucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHQueCxhKSxlLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0LnksYSksZS5wb3NpdGlvbloubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodC56LGEpLGUuZm9yd2FyZFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoci54LGEpLGUuZm9yd2FyZFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoci55LGEpLGUuZm9yd2FyZFoubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoci56LGEpLGUudXBYLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHMueCxhKSxlLnVwWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShzLnksYSksZS51cFoubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUocy56LGEpfWVsc2UgZS5zZXRQb3NpdGlvbih0LngsdC55LHQueiksZS5zZXRPcmllbnRhdGlvbihyLngsci55LHIueixzLngscy55LHMueil9ZGVzdHJveSgpe3RoaXMuZ2Fpbi5kaXNjb25uZWN0KCksdGhpcy5jb250ZXh0LmNsb3NlKCksc3VwZXIuZGVzdHJveSgpfX1jbGFzcyBocyBleHRlbmRzIF9pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtsZXQgZT1uZXcgV2UoXCJVbkxpdFwiLFwiVW5MaXRcIik7dGhpcy5kZWZhdWx0UGFzcz1lLGUuc2V0U2hhZGVyRW50cnkoXCJWZXJ0TWFpblwiLFwiRnJhZ01haW5cIiksZS5zZXRVbmlmb3JtVmVjdG9yNChcInRyYW5zZm9ybVVWMVwiLG5ldyBqKDAsMCwxLDEpKSxlLnNldFVuaWZvcm1WZWN0b3I0KFwidHJhbnNmb3JtVVYyXCIsbmV3IGooMCwwLDEsMSkpLGUuc2V0VW5pZm9ybUNvbG9yKFwiYmFzZUNvbG9yXCIsbmV3IHooMSwxLDEsMSkpLGUuc2V0VW5pZm9ybUZsb2F0KFwiYWxwaGFDdXRvZmZcIiwuNSk7bGV0IHQ9ZS5zaGFkZXJTdGF0ZTt0LmFjY2VwdFNoYWRvdz0hMSx0LmNhc3RTaGFkb3c9ITEsdC5yZWNlaXZlRW52PSExLHQuYWNjZXB0R0k9ITEsdC51c2VMaWdodD0hMSx0aGlzLmRlZmF1bHRQYXNzPWUsdGhpcy5iYXNlTWFwPUEucmVzLndoaXRlVGV4dHVyZX1zZXQgYmFzZU1hcChlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFRleHR1cmUoXCJiYXNlTWFwXCIsZSl9Z2V0IGJhc2VNYXAoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy5nZXRUZXh0dXJlKFwiYmFzZU1hcFwiKX1zZXQgYmFzZUNvbG9yKGUpe3RoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybUNvbG9yKFwiYmFzZUNvbG9yXCIsZSl9Z2V0IGJhc2VDb2xvcigpe3JldHVybiB0aGlzLmRlZmF1bHRQYXNzLnVuaWZvcm1zLmJhc2VDb2xvci5jb2xvcn1zZXQgZW52TWFwKGUpe31zZXQgc2hhZG93TWFwKGUpe319Y2xhc3MgdXMgZXh0ZW5kcyB0dHtjb25zdHJ1Y3RvcihlPTEsdD0xLHI9MSl7c3VwZXIoKSxvKHRoaXMsXCJ3aWR0aFwiKSxvKHRoaXMsXCJoZWlnaHRcIiksbyh0aGlzLFwiZGVwdGhcIiksdGhpcy53aWR0aD1lLHRoaXMuaGVpZ2h0PXQsdGhpcy5kZXB0aD1yLHRoaXMuaW5pdFZlcnRleCgpfWluaXRWZXJ0ZXgoKXtsZXQgZT10aGlzLndpZHRoLzIsdD10aGlzLmhlaWdodC8yLHI9dGhpcy5kZXB0aC8yO3RoaXMuYm91bmRzPW5ldyBCZShnLlpFUk8uY2xvbmUoKSxuZXcgZyh0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHRoaXMuZGVwdGgpKTtsZXQgcz1uZXcgRmxvYXQzMkFycmF5KFstZSx0LHIsZSx0LHIsZSx0LC1yLC1lLHQsLXIsLWUsdCxyLGUsdCwtcixlLC10LHIsLWUsLXQsciwtZSwtdCwtcixlLC10LC1yLGUsLXQsciwtZSwtdCwtciwtZSwtdCxyLC1lLHQsciwtZSx0LC1yLC1lLC10LC1yLC1lLC10LHIsLWUsdCwtcixlLHQscixlLC10LHIsZSwtdCwtcixlLHQsLXIsZSx0LHIsZSwtdCwtcixlLHQsciwtZSx0LHIsLWUsLXQsciwtZSwtdCxyLGUsLXQscixlLHQscixlLC10LC1yLC1lLC10LC1yLC1lLHQsLXIsZSx0LC1yLGUsLXQsLXIsLWUsdCwtcl0pLGE9bmV3IEZsb2F0MzJBcnJheShbMCwxLDAsMCwxLDAsMCwxLDAsMCwxLDAsMCwxLDAsMCwxLDAsMCwtMSwwLDAsLTEsMCwwLC0xLDAsMCwtMSwwLDAsLTEsMCwwLC0xLDAsLTEsMCwwLC0xLDAsMCwtMSwwLDAsLTEsMCwwLC0xLDAsMCwtMSwwLDAsMSwwLDAsMSwwLDAsMSwwLDAsMSwwLDAsMSwwLDAsMSwwLDAsMCwwLDEsMCwwLDEsMCwwLDEsMCwwLDEsMCwwLDEsMCwwLDEsMCwwLC0xLDAsMCwtMSwwLDAsLTEsMCwwLC0xLDAsMCwtMSwwLDAsLTFdKSxuPW5ldyBGbG9hdDMyQXJyYXkoWzEsMSwwLDEsMCwwLDEsMCwxLDEsMCwwLDEsMSwwLDEsMCwwLDEsMCwxLDEsMCwwLDEsMSwwLDEsMCwwLDEsMCwxLDEsMCwwLDEsMSwwLDEsMCwwLDEsMCwxLDEsMCwwLDEsMSwwLDEsMCwwLDAsMCwxLDAsMSwxLDEsMSwwLDEsMCwwLDEsMCwxLDEsMCwwXSksbD1bMCwyLDEsMyw1LDQsNiw4LDcsOSwxMSwxMCwxMiwxNCwxMywxNSwxNywxNiwxOCwyMCwxOSwyMSwyMywyMiwyNCwyNiwyNSwyNywyOSwyOCwzMCwzMiwzMSwzMywzNSwzNF0saD1uZXcgVWludDE2QXJyYXkobC5yZXZlcnNlKCkpO3RoaXMuc2V0SW5kaWNlcyhoKSx0aGlzLnNldEF0dHJpYnV0ZShZLnBvc2l0aW9uLHMpLHRoaXMuc2V0QXR0cmlidXRlKFkubm9ybWFsLGEpLHRoaXMuc2V0QXR0cmlidXRlKFkudXYsbiksdGhpcy5zZXRBdHRyaWJ1dGUoWS5URVhDT09SRF8xLG4pLHRoaXMuYWRkU3ViR2VvbWV0cnkoe2luZGV4U3RhcnQ6MCxpbmRleENvdW50OmwubGVuZ3RoLHZlcnRleFN0YXJ0OjAsaW5kZXg6MH0pfX1jbGFzcyBPYyBleHRlbmRzIEVle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJsaXN0ZW5lclwiLG51bGwpLG8odGhpcyxcImNvbnRleHRcIixudWxsKSxvKHRoaXMsXCJnYWluTm9kZVwiLG51bGwpLG8odGhpcyxcInNvdXJjZVwiLG51bGwpLG8odGhpcyxcIl9vcHRpb25zXCIse2xvb3A6ITAsdm9sdW1lOjF9KSxvKHRoaXMsXCJwbGF5aW5nXCIsITEpLG8odGhpcyxcIl9jdXJyZW50VGltZVwiLDApLG8odGhpcyxcIl9idWZmZXJcIixudWxsKX1zZXRMaXN0ZXIoZSl7cmV0dXJuIHRoaXMubGlzdGVuZXI9ZSx0aGlzLmNvbnRleHQ9ZS5jb250ZXh0LHRoaXMuZ2Fpbk5vZGU9dGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKSx0aGlzLmdhaW5Ob2RlLmNvbm5lY3QodGhpcy5saXN0ZW5lci5nYWluKSx0aGlzLmNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlY2hhbmdlXCIsKCk9Pnt2YXIgdCxyOygodD10aGlzLmNvbnRleHQpPT1udWxsP3ZvaWQgMDp0LnN0YXRlKT09PVwiY2xvc2VkXCImJihjb25zb2xlLndhcm4oXCJBdWRpb0xpc3RlbmVyIHJlbW92ZWRcIiksdGhpcy5zdG9wKCksKHI9dGhpcy5nYWluTm9kZSk9PW51bGx8fHIuZGlzY29ubmVjdCgpLHRoaXMubGlzdGVuZXI9bnVsbCx0aGlzLmNvbnRleHQ9bnVsbCx0aGlzLmdhaW5Ob2RlPW51bGwpfSksdGhpc31hc3luYyBsb2FkKGUsdD17fSl7dmFyIHI7T2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLHQpO2xldCBhPWF3YWl0KGF3YWl0IGZldGNoKGUpKS5hcnJheUJ1ZmZlcigpO3RoaXMuX2J1ZmZlcj1hd2FpdCgocj10aGlzLmNvbnRleHQpPT1udWxsP3ZvaWQgMDpyLmRlY29kZUF1ZGlvRGF0YShhKSl9YXN5bmMgbG9hZEJ1ZmZlcihlLHQ9e30pe3ZhciByO09iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucyx0KSx0aGlzLl9idWZmZXI9YXdhaXQoKHI9dGhpcy5jb250ZXh0KT09bnVsbD92b2lkIDA6ci5kZWNvZGVBdWRpb0RhdGEoZSkpfXBsYXkoKXtpZighdGhpcy5jb250ZXh0KXJldHVybiBjb25zb2xlLndhcm4oXCJubyBhdWRpbyBzb3VyY2UgeWV0XCIpLHRoaXM7aWYodGhpcy5wbGF5aW5nKXJldHVybiBjb25zb2xlLndhcm4oXCJBdWRpbyBpcyBhbHJlZHkgcGxheWluZ1wiKSx0aGlzO2lmKCF0aGlzLl9idWZmZXIpcmV0dXJuIGNvbnNvbGUud2FybihcIkF1ZGlvIGlzIG5vdCByZWFkeVwiKSx0aGlzO2NvbnN0IGU9dGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO3JldHVybiBlLmJ1ZmZlcj10aGlzLl9idWZmZXIsZS5sb29wPXRoaXMuX29wdGlvbnMubG9vcCx0aGlzLnNvdXJjZT1lLHRoaXMuY29ubmVjdCgpLHRoaXMuc291cmNlLnN0YXJ0KDAsdGhpcy5fY3VycmVudFRpbWUpLHRoaXMuc2V0Vm9sdW1lKHRoaXMuX29wdGlvbnMudm9sdW1lKSx0aGlzLnBsYXlpbmc9ITAsdGhpc31wYXVzZSgpe3ZhciBlLHQscjtyZXR1cm4gdGhpcy5wbGF5aW5nPyh0aGlzLl9jdXJyZW50VGltZT0oKGU9dGhpcy5jb250ZXh0KT09bnVsbD92b2lkIDA6ZS5jdXJyZW50VGltZSl8fDAsKHQ9dGhpcy5zb3VyY2UpPT1udWxsfHx0LnN0b3AoKSwocj10aGlzLnNvdXJjZSk9PW51bGx8fHIuZGlzY29ubmVjdCgpLHRoaXMucGxheWluZz0hMSx0aGlzKTooY29uc29sZS53YXJuKFwiQXVkaW8gaXMgbm90IHBsYXlpbmdcIiksdGhpcyl9c3RvcCgpe3JldHVybiB0aGlzLnBhdXNlKCksdGhpcy5fY3VycmVudFRpbWU9MCx0aGlzfXNldFZvbHVtZShlKXt2YXIgdDtyZXR1cm4gdGhpcy5jb250ZXh0PygodD10aGlzLmdhaW5Ob2RlKT09bnVsbHx8dC5nYWluLnNldFRhcmdldEF0VGltZShlLHRoaXMuY29udGV4dD90aGlzLmNvbnRleHQuY3VycmVudFRpbWU6MCwuMDEpLHRoaXMpOihjb25zb2xlLndhcm4oXCJubyBhdWRpbyBzb3VyY2UgeWV0XCIpLHRoaXMpfWNvbm5lY3QoKXt2YXIgZTsoZT10aGlzLnNvdXJjZSk9PW51bGx8fGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKX1vblVwZGF0ZSgpe3N1cGVyLm9uVXBkYXRlKCl9ZGVzdHJveShlKXt2YXIgdDt0aGlzLnN0b3AoKSwodD10aGlzLmdhaW5Ob2RlKT09bnVsbHx8dC5kaXNjb25uZWN0KCksc3VwZXIuZGVzdHJveShlKX19Y2xhc3MgZ3AgZXh0ZW5kcyBPY3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwicGFubmVyXCIpLG8odGhpcyxcIl9oZWxwZXJcIiwhMSksbyh0aGlzLFwiX3RoaWNrbmVzc1wiLC4xKSxvKHRoaXMsXCJfc3RlcFwiLDE2KSxvKHRoaXMsXCJfbGluZXNcIixbXSl9c2V0TGlzdGVyKGUpe3ZhciB0O3JldHVybiBzdXBlci5zZXRMaXN0ZXIoZSksdGhpcy5wYW5uZXI9KHQ9dGhpcy5jb250ZXh0KT09bnVsbD92b2lkIDA6dC5jcmVhdGVQYW5uZXIoKSx0aGlzLnBhbm5lci5wYW5uaW5nTW9kZWw9XCJIUlRGXCIsdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKSx0aGlzfXNob3dIZWxwZXIoZSx0KXt0aGlzLl9oZWxwZXI9ITAsZSYmKHRoaXMuX3RoaWNrbmVzcz1lKSx0JiYodGhpcy5fc3RlcD10KTtjb25zdCByPXRoaXMucGFubmVyLmNvbmVJbm5lckFuZ2xlLHM9dGhpcy5wYW5uZXIuY29uZU91dGVyQW5nbGUsYT0ocy1yKS8yO2xldCBuPXRoaXMucGFubmVyLnJlZkRpc3RhbmNlLGw9dGhpcy5wYW5uZXIubWF4RGlzdGFuY2UsaD1uZXcgdXMoMSwxLDEpLHU9bmV3IGhzO3UuYmFzZUNvbG9yPW5ldyB6KDEsMCwwKTtsZXQgYz1uZXcgaHM7Yy5iYXNlQ29sb3I9bmV3IHooMCwwLDEpO2xldCBmPW5ldyBocztmLmJhc2VDb2xvcj1uZXcgeigwLDEsMCk7bGV0IGQ9bmV3IGhzO2QuYmFzZUNvbG9yPW5ldyB6KDEsMSwwKTtmb3IobGV0IHA9MDtwPHRoaXMuX3N0ZXA7cCsrKXtsZXQgbT1uZXcgdGUsXz1wKnMvKHRoaXMuX3N0ZXAtMSksdj1fPGF8fF8+cithO3tsZXQgeT1uZXcgdGUsQz15LmFkZENvbXBvbmVudChjZSk7Qy5nZW9tZXRyeT1oLEMubWF0ZXJpYWw9dj9jOnUsQy5jYXN0U2hhZG93PSExLEMuY2FzdEdJPSExLHkubG9jYWxTY2FsZT1uZXcgZyhuLHRoaXMuX3RoaWNrbmVzcyx0aGlzLl90aGlja25lc3MpLHkueD1uLzIsbS5hZGRDaGlsZCh5KX17bGV0IHk9bmV3IHRlLEM9eS5hZGRDb21wb25lbnQoY2UpO0MuZ2VvbWV0cnk9aCxDLm1hdGVyaWFsPXY/ZDpmLEMuY2FzdFNoYWRvdz0hMSxDLmNhc3RHST0hMSx5LmxvY2FsU2NhbGU9bmV3IGcobCx0aGlzLl90aGlja25lc3MvMix0aGlzLl90aGlja25lc3MvMikseS54PWwvMixtLmFkZENoaWxkKHkpfW0ucm90YXRpb25ZPS05MCtzLzItXyx0aGlzLm9iamVjdDNELmFkZENoaWxkKG0pLHRoaXMuX2xpbmVzLnB1c2gobSl9fWhpZGVIZWxwZXIoKXt0aGlzLl9oZWxwZXI9ITE7Zm9yKGxldCBlIG9mIHRoaXMuX2xpbmVzKWUucmVtb3ZlQWxsQ2hpbGQoKSxlLnJlbW92ZUZyb21QYXJlbnQoKSxlLmRlc3Ryb3koKTt0aGlzLl9saW5lcy5sZW5ndGg9MH10b2dnbGVIZWxwZXIoKXt0aGlzLl9oZWxwZXI/dGhpcy5oaWRlSGVscGVyKCk6dGhpcy5zaG93SGVscGVyKCl9dXBkYXRlSGVsZXIoKXt0aGlzLmhpZGVIZWxwZXIoKSx0aGlzLnNob3dIZWxwZXIoKX1nZXQgcmVmRGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2V9c2V0IHJlZkRpc3RhbmNlKGUpe3RoaXMucGFubmVyLnJlZkRpc3RhbmNlPWUsdGhpcy5faGVscGVyJiZ0aGlzLnVwZGF0ZUhlbGVyKCl9Z2V0IHJvbGxvZmZGYWN0b3IoKXtyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3Rvcn1zZXQgcm9sbG9mZkZhY3RvcihlKXt0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yPWV9Z2V0IGRpc3RhbmNlTW9kZWwoKXtyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbH1zZXQgZGlzdGFuY2VNb2RlbChlKXt0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsPWV9Z2V0IG1heERpc3RhbmNlKCl7cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlfXNldCBtYXhEaXN0YW5jZShlKXt0aGlzLnBhbm5lci5tYXhEaXN0YW5jZT1lLHRoaXMuX2hlbHBlciYmdGhpcy51cGRhdGVIZWxlcigpfXNldERpcmVjdGlvbmFsQ29uZShlLHQscil7cmV0dXJuIHRoaXMucGFubmVyLmNvbmVJbm5lckFuZ2xlPWUsdGhpcy5wYW5uZXIuY29uZU91dGVyQW5nbGU9dCx0aGlzLnBhbm5lci5jb25lT3V0ZXJHYWluPXIsdGhpcy5faGVscGVyJiZ0aGlzLnVwZGF0ZUhlbGVyKCksdGhpc31jb25uZWN0KCl7dmFyIGU7KGU9dGhpcy5zb3VyY2UpPT1udWxsfHxlLmNvbm5lY3QodGhpcy5wYW5uZXIpfXN0YXJ0KCl7fXN0b3AoKXtyZXR1cm4gc3VwZXIuc3RvcCgpfW9uVXBkYXRlKCl7aWYoIXRoaXMucGxheWluZylyZXR1cm47Y29uc3QgZT10aGlzLnBhbm5lcix0PXRoaXMub2JqZWN0M0QudHJhbnNmb3JtLndvcmxkUG9zaXRpb24scj10aGlzLm9iamVjdDNELnRyYW5zZm9ybS5mb3J3YXJkO2lmKCFpc05hTihyLngpKWlmKGUucG9zaXRpb25YJiZ0aGlzLmNvbnRleHQpe2NvbnN0IHM9dGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO2UucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHQueCxzKSxlLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0LnkscyksZS5wb3NpdGlvbloubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodC56LHMpLGUub3JpZW50YXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHIueCxzKSxlLm9yaWVudGF0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShyLnkscyksZS5vcmllbnRhdGlvbloubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoci56LHMpfWVsc2UgZS5zZXRQb3NpdGlvbih0LngsdC55LHQueiksZS5zZXRPcmllbnRhdGlvbihyLngsci55LHIueil9ZGVzdHJveShlKXt0aGlzLnBhbm5lci5kaXNjb25uZWN0KCksdGhpcy5oaWRlSGVscGVyKCksc3VwZXIuZGVzdHJveShlKX19Y2xhc3MgcHB7Y29uc3RydWN0b3IoZT1udWxsLHQ9bnVsbCl7byh0aGlzLFwiX2F1dG9VcGRhdGVcIiwhMCksbyh0aGlzLFwiX3RhcmdldFwiKSxvKHRoaXMsXCJfbG9va0F0T2JqZWN0XCIpLG8odGhpcyxcIl9vcmlnaW5cIixuZXcgZygwLDAsMCkpLG8odGhpcyxcIl9zcGVlZFwiLDMwMCksdGhpcy5fdGFyZ2V0PWUsdGhpcy5fbG9va0F0T2JqZWN0PXR9Z2V0IHRhcmdldCgpe3JldHVybiB0aGlzLl90YXJnZXR9c2V0IHRhcmdldChlKXt0aGlzLl90YXJnZXQhPWUmJih0aGlzLl90YXJnZXQ9ZSl9Z2V0IGxvb2tBdE9iamVjdCgpe3JldHVybiB0aGlzLl9sb29rQXRPYmplY3R9c2V0IGxvb2tBdE9iamVjdChlKXt0aGlzLl9sb29rQXRPYmplY3QhPWUmJih0aGlzLl9sb29rQXRPYmplY3Q9ZSl9Z2V0IHNwZWVkKCl7cmV0dXJuIHRoaXMuX3NwZWVkfXNldCBzcGVlZChlKXt0aGlzLl9zcGVlZD1lfXVwZGF0ZSgpe319Y2xhc3MgbXAgZXh0ZW5kcyBFZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiZm9jdXNcIiksbyh0aGlzLFwiZGlzdGFuY2VcIiw1KSxvKHRoaXMsXCJfY2FtZXJhXCIpfXN0YXJ0KCl7aWYodGhpcy5fY2FtZXJhPXRoaXMub2JqZWN0M0QuZ2V0T3JBZGRDb21wb25lbnQoWmkpLCF0aGlzLl9jYW1lcmEpe2NvbnNvbGUuZXJyb3IoXCJGaXJzdFBlcnNvbkNhbWVyYUNvbnRyb2xsZXIgbmVlZCBjYW1lcmFcIik7cmV0dXJufWlmKCF0aGlzLmZvY3VzKXtjb25zb2xlLmVycm9yKFwiRmlyc3RQZXJzb25DYW1lcmFDb250cm9sbGVyIG5lZWQgdGFyZ2V0XCIpO3JldHVybn1BLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1dIRUVMLHRoaXMubW91c2VXaGVlbCx0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1VQLHRoaXMubW91c2VVcCx0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX0RPV04sdGhpcy5tb3VzZURvd24sdGhpcyl9bW91c2VEb3duKGUpe0EuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfTU9WRSx0aGlzLm1vdXNlTW92ZSx0aGlzKX1tb3VzZVVwKGUpe0EuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfTU9WRSx0aGlzLm1vdXNlTW92ZSx0aGlzKX1tb3VzZU1vdmUoZSl7bGV0IHQ9dGhpcy50cmFuc2Zvcm0ubG9jYWxSb3RhdGlvbjt0LnkrPWUubW92ZW1lbnRYKi4wMSx0LngrPWUubW92ZW1lbnRZKi4wMSx0aGlzLnRyYW5zZm9ybS5sb2NhbFJvdGF0aW9uPXR9bW91c2VXaGVlbChlKXt0aGlzLmRpc3RhbmNlKz1BLmlucHV0U3lzdGVtLndoZWVsRGVsdGEqLjF9b25VcGRhdGUoKXtsZXQgZT1uZXcgZzt0aGlzLl9jYW1lcmEudHJhbnNmb3JtLmZvcndhcmQuc2NhbGVUb1JlZih0aGlzLmRpc3RhbmNlLGUpO3ZhciB0PXRoaXMuZm9jdXMudHJhbnNmb3JtLndvcmxkUG9zaXRpb247dGhpcy5fY2FtZXJhLnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uPXR9ZGVzdHJveShlKXtBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1dIRUVMLHRoaXMubW91c2VXaGVlbCx0aGlzKSxBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1VQLHRoaXMubW91c2VVcCx0aGlzKSxBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX0RPV04sdGhpcy5tb3VzZURvd24sdGhpcyksc3VwZXIuZGVzdHJveShlKX19dmFyIEplPShpPT4oaVtpLktleV9CYWNrU3BhY2U9OF09XCJLZXlfQmFja1NwYWNlXCIsaVtpLktleV9UYWI9OV09XCJLZXlfVGFiXCIsaVtpLktleV9DbGVhcj0xMl09XCJLZXlfQ2xlYXJcIixpW2kuS2V5X0VudGVyPTEzXT1cIktleV9FbnRlclwiLGlbaS5LZXlfU2hpZnRfTD0xNl09XCJLZXlfU2hpZnRfTFwiLGlbaS5LZXlfQ29udHJvbF9MPTE3XT1cIktleV9Db250cm9sX0xcIixpW2kuS2V5X0FsdF9MPTE4XT1cIktleV9BbHRfTFwiLGlbaS5LZXlfUGF1c2U9MTldPVwiS2V5X1BhdXNlXCIsaVtpLktleV9DYXBzTG9jaz0yMF09XCJLZXlfQ2Fwc0xvY2tcIixpW2kuS2V5X0VzY2FwZT0yMV09XCJLZXlfRXNjYXBlXCIsaVtpLktleV9Fc2M9MjddPVwiS2V5X0VzY1wiLGlbaS5LZXlfU3BhY2U9MzJdPVwiS2V5X1NwYWNlXCIsaVtpLktleV9Qcmlvcj0zM109XCJLZXlfUHJpb3JcIixpW2kuS2V5X05leHQ9MzRdPVwiS2V5X05leHRcIixpW2kuS2V5X0VuZD0zNV09XCJLZXlfRW5kXCIsaVtpLktleV9Ib21lPTM2XT1cIktleV9Ib21lXCIsaVtpLktleV9MZWZ0PTM3XT1cIktleV9MZWZ0XCIsaVtpLktleV9VcD0zOF09XCJLZXlfVXBcIixpW2kuS2V5X1JpZ2h0PTM5XT1cIktleV9SaWdodFwiLGlbaS5LZXlfRG93bj00MF09XCJLZXlfRG93blwiLGlbaS5LZXlfU2VsZWN0PTQxXT1cIktleV9TZWxlY3RcIixpW2kuS2V5X1ByaW50PTQyXT1cIktleV9QcmludFwiLGlbaS5LZXlfRXhlY3V0ZT00M109XCJLZXlfRXhlY3V0ZVwiLGlbaS5LZXlfSW5zZXJ0PTQ1XT1cIktleV9JbnNlcnRcIixpW2kuS2V5X0RlbGV0ZT00Nl09XCJLZXlfRGVsZXRlXCIsaVtpLktleV9IZWxwPTQ3XT1cIktleV9IZWxwXCIsaVtpLktleV8wPTQ4XT1cIktleV8wXCIsaVtpLktleV8xPTQ5XT1cIktleV8xXCIsaVtpLktleV8yPTUwXT1cIktleV8yXCIsaVtpLktleV8zPTUxXT1cIktleV8zXCIsaVtpLktleV80PTUyXT1cIktleV80XCIsaVtpLktleV81PTUzXT1cIktleV81XCIsaVtpLktleV82PTU0XT1cIktleV82XCIsaVtpLktleV83PTU1XT1cIktleV83XCIsaVtpLktleV84PTU2XT1cIktleV84XCIsaVtpLktleV85PTU3XT1cIktleV85XCIsaVtpLktleV9BPTY1XT1cIktleV9BXCIsaVtpLktleV9CPTY2XT1cIktleV9CXCIsaVtpLktleV9DPTY3XT1cIktleV9DXCIsaVtpLktleV9EPTY4XT1cIktleV9EXCIsaVtpLktleV9FPTY5XT1cIktleV9FXCIsaVtpLktleV9GPTcwXT1cIktleV9GXCIsaVtpLktleV9HPTcxXT1cIktleV9HXCIsaVtpLktleV9IPTcyXT1cIktleV9IXCIsaVtpLktleV9JPTczXT1cIktleV9JXCIsaVtpLktleV9KPTc0XT1cIktleV9KXCIsaVtpLktleV9LPTc1XT1cIktleV9LXCIsaVtpLktleV9MPTc2XT1cIktleV9MXCIsaVtpLktleV9NPTc3XT1cIktleV9NXCIsaVtpLktleV9OPTc4XT1cIktleV9OXCIsaVtpLktleV9PPTc5XT1cIktleV9PXCIsaVtpLktleV9QPTgwXT1cIktleV9QXCIsaVtpLktleV9RPTgxXT1cIktleV9RXCIsaVtpLktleV9SPTgyXT1cIktleV9SXCIsaVtpLktleV9TPTgzXT1cIktleV9TXCIsaVtpLktleV9UPTg0XT1cIktleV9UXCIsaVtpLktleV9VPTg1XT1cIktleV9VXCIsaVtpLktleV9WPTg2XT1cIktleV9WXCIsaVtpLktleV9XPTg3XT1cIktleV9XXCIsaVtpLktleV9YPTg4XT1cIktleV9YXCIsaVtpLktleV9ZPTg5XT1cIktleV9ZXCIsaVtpLktleV9aPTkwXT1cIktleV9aXCIsaVtpLktleV9LUF8wPTk2XT1cIktleV9LUF8wXCIsaVtpLktleV9LUF8xPTk3XT1cIktleV9LUF8xXCIsaVtpLktleV9LUF8yPTk4XT1cIktleV9LUF8yXCIsaVtpLktleV9LUF8zPTk5XT1cIktleV9LUF8zXCIsaVtpLktleV9LUF80PTEwMF09XCJLZXlfS1BfNFwiLGlbaS5LZXlfS1BfNT0xMDFdPVwiS2V5X0tQXzVcIixpW2kuS2V5X0tQXzY9MTAyXT1cIktleV9LUF82XCIsaVtpLktleV9LUF83PTEwM109XCJLZXlfS1BfN1wiLGlbaS5LZXlfS1BfOD0xMDRdPVwiS2V5X0tQXzhcIixpW2kuS2V5X0tQXzk9MTA1XT1cIktleV9LUF85XCIsaVtpLktleV9NdWx0aXBseT0xMDZdPVwiS2V5X011bHRpcGx5XCIsaVtpLktleV9BZGQ9MTA3XT1cIktleV9BZGRcIixpW2kuS2V5X1NlcGFyYXRvcj0xMDhdPVwiS2V5X1NlcGFyYXRvclwiLGlbaS5LZXlfU3VidHJhY3Q9MTA5XT1cIktleV9TdWJ0cmFjdFwiLGlbaS5LZXlfRGVjaW1hbD0xMTBdPVwiS2V5X0RlY2ltYWxcIixpW2kuS2V5X0RpdmlkZT0xMTFdPVwiS2V5X0RpdmlkZVwiLGlbaS5LZXlfRjE9MTEyXT1cIktleV9GMVwiLGlbaS5LZXlfRjI9MTEzXT1cIktleV9GMlwiLGlbaS5LZXlfRjM9MTE0XT1cIktleV9GM1wiLGlbaS5LZXlfRjQ9MTE1XT1cIktleV9GNFwiLGlbaS5LZXlfRjU9MTE2XT1cIktleV9GNVwiLGlbaS5LZXlfRjY9MTE3XT1cIktleV9GNlwiLGlbaS5LZXlfRjc9MTE4XT1cIktleV9GN1wiLGlbaS5LZXlfRjg9MTE5XT1cIktleV9GOFwiLGlbaS5LZXlfRjk9MTIwXT1cIktleV9GOVwiLGlbaS5LZXlfRjEwPTEyMV09XCJLZXlfRjEwXCIsaVtpLktleV9GMTE9MTIyXT1cIktleV9GMTFcIixpW2kuS2V5X0YxMj0xMjNdPVwiS2V5X0YxMlwiLGlbaS5LZXlfRjEzPTEyNF09XCJLZXlfRjEzXCIsaVtpLktleV9GMTQ9MTI1XT1cIktleV9GMTRcIixpW2kuS2V5X0YxNT0xMjZdPVwiS2V5X0YxNVwiLGlbaS5LZXlfRjE2PTEyN109XCJLZXlfRjE2XCIsaVtpLktleV9GMTc9MTI4XT1cIktleV9GMTdcIixpW2kuS2V5X0YxOD0xMjldPVwiS2V5X0YxOFwiLGlbaS5LZXlfRjE5PTEzMF09XCJLZXlfRjE5XCIsaVtpLktleV9GMjA9MTMxXT1cIktleV9GMjBcIixpW2kuS2V5X0YyMT0xMzJdPVwiS2V5X0YyMVwiLGlbaS5LZXlfRjIyPTEzM109XCJLZXlfRjIyXCIsaVtpLktleV9GMjM9MTM0XT1cIktleV9GMjNcIixpW2kuS2V5X0YyND0xMzVdPVwiS2V5X0YyNFwiLGlbaS5LZXlfTnVtX0xvY2s9MTM2XT1cIktleV9OdW1fTG9ja1wiLGlbaS5LZXlfU2Nyb2xsX0xvY2s9MTM3XT1cIktleV9TY3JvbGxfTG9ja1wiLGkpKShKZXx8e30pO2NsYXNzIEFwIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcIm1vdmVTcGVlZFwiLDIpLG8odGhpcyxcInRhcmdldFBvc1wiLG5ldyBnKDAsMCwxMCkpLG8odGhpcyxcImxvb2tBdFBvc1wiLG5ldyBnKDAsMCwwKSksbyh0aGlzLFwiY29uZmlnXCIse3NoaWZ0TW92ZVNjYWxlOjIwfSksbyh0aGlzLFwiX21vdmVTY2FsZVwiLDEpLG8odGhpcyxcIl9kaXJcIiksbyh0aGlzLFwiX21vdXNlRmFjdG9yeVwiLDI1KSxvKHRoaXMsXCJfZmFjdG9yeVwiLDEuNSksbyh0aGlzLFwiX21vdXNlRG93blwiLCExKSxvKHRoaXMsXCJfbGFzdFBvc1wiKSxvKHRoaXMsXCJfa2V5U3RhdGVcIiksdGhpcy5fbGFzdFBvcz1uZXcgZyx0aGlzLl9rZXlTdGF0ZT17ZnJvbnQ6ITEsYmFjazohMSxsZWZ0OiExLHJpZ2h0OiExLHE6ITEsZTohMX0sdGhpcy5zZXRDYW1lcmEobmV3IGcoMCwwLDEwMCksbmV3IGcoMCwwLDApKX1zZXRDYW1lcmEoZSx0KXt0aGlzLnRhcmdldFBvcy5jb3B5RnJvbShlKSx0aGlzLmxvb2tBdFBvcy5jb3B5RnJvbSh0KSx0aGlzLlJlc2V0KCl9c3RhcnQoKXtBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1dIRUVMLHRoaXMubW91c2VXaGVlbCx0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1VQLHRoaXMubW91c2VVcCx0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX0RPV04sdGhpcy5tb3VzZURvd24sdGhpcyksQS5pbnB1dFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFF0LktFWV9VUCx0aGlzLmtleVVwLHRoaXMpLEEuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihRdC5LRVlfRE9XTix0aGlzLmtleURvd24sdGhpcyksdGhpcy50cmFuc2Zvcm0ubG9va0F0KHRoaXMudGFyZ2V0UG9zLHRoaXMubG9va0F0UG9zKX1tb3VzZVdoZWVsKGUpe31rZXlVcChlKXtzd2l0Y2goZS5rZXlDb2RlKXtjYXNlIEplLktleV9XOnRoaXMuX2tleVN0YXRlLmZyb250PSExO2JyZWFrO2Nhc2UgSmUuS2V5X1M6dGhpcy5fa2V5U3RhdGUuYmFjaz0hMTticmVhaztjYXNlIEplLktleV9BOnRoaXMuX2tleVN0YXRlLmxlZnQ9ITE7YnJlYWs7Y2FzZSBKZS5LZXlfRDp0aGlzLl9rZXlTdGF0ZS5yaWdodD0hMTticmVhaztjYXNlIEplLktleV9TaGlmdF9MOnRoaXMuX21vdmVTY2FsZT0xO2JyZWFrO2Nhc2UgSmUuS2V5X1E6dGhpcy5fa2V5U3RhdGUucT0hMTticmVhaztjYXNlIEplLktleV9FOnRoaXMuX2tleVN0YXRlLmU9ITE7YnJlYWs7Y2FzZSBKZS5LZXlfRjp0aGlzLnRyYW5zZm9ybS5sb29rQXQodGhpcy50YXJnZXRQb3MsdGhpcy5sb29rQXRQb3MpO2JyZWFrfX1rZXlEb3duKGUpe3N3aXRjaChlLmtleUNvZGUpe2Nhc2UgSmUuS2V5X1c6dGhpcy5fa2V5U3RhdGUuZnJvbnQ9ITA7YnJlYWs7Y2FzZSBKZS5LZXlfUzp0aGlzLl9rZXlTdGF0ZS5iYWNrPSEwO2JyZWFrO2Nhc2UgSmUuS2V5X0E6dGhpcy5fa2V5U3RhdGUubGVmdD0hMDticmVhaztjYXNlIEplLktleV9EOnRoaXMuX2tleVN0YXRlLnJpZ2h0PSEwO2JyZWFrO2Nhc2UgSmUuS2V5X1E6dGhpcy5fa2V5U3RhdGUucT0hMDticmVhaztjYXNlIEplLktleV9FOnRoaXMuX2tleVN0YXRlLmU9ITA7YnJlYWs7Y2FzZSBKZS5LZXlfU2hpZnRfTDp0aGlzLl9tb3ZlU2NhbGU9dGhpcy5jb25maWcuc2hpZnRNb3ZlU2NhbGV9fVJlc2V0KCl7dGhpcy5fbGFzdFBvcy54PUEuaW5wdXRTeXN0ZW0ubW91c2VMYXN0WCx0aGlzLl9sYXN0UG9zLnk9QS5pbnB1dFN5c3RlbS5tb3VzZUxhc3RZfW1vdXNlRG93bihlKXt0aGlzLlJlc2V0KCksdGhpcy5fbW91c2VEb3duPSEwfW1vdXNlVXAoZSl7dGhpcy5SZXNldCgpLHRoaXMuX21vdXNlRG93bj0hMX1nZXQgZmFjdG9yeSgpe3JldHVybiB0aGlzLl9mYWN0b3J5fXNldCBmYWN0b3J5KGUpe3RoaXMuX2ZhY3Rvcnk9ZX1nZXQgbW91c2VGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX21vdXNlRmFjdG9yeX1zZXQgbW91c2VGYWN0b3J5KGUpe3RoaXMuX21vdXNlRmFjdG9yeT1lfWludGVybmFsKGUsdCxyKXtyZXR1cm4odC1lKSpyfW9uVXBkYXRlKCl7bGV0IGU9dGhpcy50cmFuc2Zvcm0sdD1LKGhlLmRlbHRhLDAsLjAxNik7aWYodGhpcy5fbW91c2VEb3duJiYoZS5yb3RhdGlvblktPXRoaXMuaW50ZXJuYWwoZS5yb3RhdGlvblkrKEEuaW5wdXRTeXN0ZW0ubW91c2VMYXN0WC10aGlzLl9sYXN0UG9zLngpKi4yNSxlLnJvdGF0aW9uWSx0KnRoaXMuX21vdXNlRmFjdG9yeSksZS5yb3RhdGlvblgtPXRoaXMuaW50ZXJuYWwoZS5yb3RhdGlvblgrKEEuaW5wdXRTeXN0ZW0ubW91c2VMYXN0WS10aGlzLl9sYXN0UG9zLnkpKi4yNSxlLnJvdGF0aW9uWCx0KnRoaXMuX21vdXNlRmFjdG9yeSksdGhpcy5SZXNldCgpKSx0aGlzLl9rZXlTdGF0ZS5mcm9udCl7bGV0IHI9ZS5mb3J3YXJkO2UueC09dGhpcy5pbnRlcm5hbChlLngrci54KnRoaXMubW92ZVNwZWVkKnRoaXMuX21vdmVTY2FsZSxlLngsdCp0aGlzLl9mYWN0b3J5KSxlLnktPXRoaXMuaW50ZXJuYWwoZS55K3IueSp0aGlzLm1vdmVTcGVlZCp0aGlzLl9tb3ZlU2NhbGUsZS55LHQqdGhpcy5fZmFjdG9yeSksZS56LT10aGlzLmludGVybmFsKGUueityLnoqdGhpcy5tb3ZlU3BlZWQqdGhpcy5fbW92ZVNjYWxlLGUueix0KnRoaXMuX2ZhY3RvcnkpfWlmKHRoaXMuX2tleVN0YXRlLmJhY2spe2xldCByPWUuZm9yd2FyZDtlLngrPXRoaXMuaW50ZXJuYWwoZS54K3IueCp0aGlzLm1vdmVTcGVlZCp0aGlzLl9tb3ZlU2NhbGUsZS54LHQqdGhpcy5fZmFjdG9yeSksZS55Kz10aGlzLmludGVybmFsKGUueStyLnkqdGhpcy5tb3ZlU3BlZWQqdGhpcy5fbW92ZVNjYWxlLGUueSx0KnRoaXMuX2ZhY3RvcnkpLGUueis9dGhpcy5pbnRlcm5hbChlLnorci56KnRoaXMubW92ZVNwZWVkKnRoaXMuX21vdmVTY2FsZSxlLnosdCp0aGlzLl9mYWN0b3J5KX1pZih0aGlzLl9rZXlTdGF0ZS5sZWZ0KXtsZXQgcj1lLmxlZnQ7ZS54Kz10aGlzLmludGVybmFsKGUueCtyLngqdGhpcy5tb3ZlU3BlZWQqdGhpcy5fbW92ZVNjYWxlLGUueCx0KnRoaXMuX2ZhY3RvcnkpLGUueSs9dGhpcy5pbnRlcm5hbChlLnkrci55KnRoaXMubW92ZVNwZWVkKnRoaXMuX21vdmVTY2FsZSxlLnksdCp0aGlzLl9mYWN0b3J5KSxlLnorPXRoaXMuaW50ZXJuYWwoZS56K3Iueip0aGlzLm1vdmVTcGVlZCp0aGlzLl9tb3ZlU2NhbGUsZS56LHQqdGhpcy5fZmFjdG9yeSl9aWYodGhpcy5fa2V5U3RhdGUucmlnaHQpe2xldCByPWUubGVmdDtlLngtPXRoaXMuaW50ZXJuYWwoZS54K3IueCp0aGlzLm1vdmVTcGVlZCp0aGlzLl9tb3ZlU2NhbGUsZS54LHQqdGhpcy5fZmFjdG9yeSksZS55LT10aGlzLmludGVybmFsKGUueStyLnkqdGhpcy5tb3ZlU3BlZWQqdGhpcy5fbW92ZVNjYWxlLGUueSx0KnRoaXMuX2ZhY3RvcnkpLGUuei09dGhpcy5pbnRlcm5hbChlLnorci56KnRoaXMubW92ZVNwZWVkKnRoaXMuX21vdmVTY2FsZSxlLnosdCp0aGlzLl9mYWN0b3J5KX10aGlzLl9rZXlTdGF0ZS5xJiYoZS55PUlpKGUueSxlLnktdGhpcy5tb3ZlU3BlZWQqdGhpcy5fbW92ZVNjYWxlLHQqdGhpcy5fZmFjdG9yeSkpLHRoaXMuX2tleVN0YXRlLmUmJihlLnk9SWkoZS55LGUueSt0aGlzLm1vdmVTcGVlZCp0aGlzLl9tb3ZlU2NhbGUsdCp0aGlzLl9mYWN0b3J5KSl9ZGVzdHJveShlKXtBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1dIRUVMLHRoaXMubW91c2VXaGVlbCx0aGlzKSxBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1VQLHRoaXMubW91c2VVcCx0aGlzKSxBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX0RPV04sdGhpcy5tb3VzZURvd24sdGhpcyksQS5pbnB1dFN5c3RlbS5yZW1vdmVFdmVudExpc3RlbmVyKFF0LktFWV9VUCx0aGlzLmtleVVwLHRoaXMpLEEuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihRdC5LRVlfRE9XTix0aGlzLmtleURvd24sdGhpcyksc3VwZXIuZGVzdHJveShlKX19Y2xhc3MgT2l7c3RhdGljIGFkZChlLHQscil7cmV0dXJuIHJ8fChyPW5ldyBnKSxyLng9ZS54K3QueCxyLnk9ZS55K3QueSxyLno9ZS56K3QueixyfXN0YXRpYyBzdWIoZSx0LHIpe3JldHVybiByfHwocj1uZXcgZyksci54PWUueC10Lngsci55PWUueS10Lnksci56PWUuei10Lnoscn1zdGF0aWMgbXVsKGUsdCxyKXtyZXR1cm4gcnx8KHI9bmV3IGcpLHIueD1lLngqdC54LHIueT1lLnkqdC55LHIuej1lLnoqdC56LHJ9c3RhdGljIG11bFNjYWxlKGUsdCxyKXtyZXR1cm4gcnx8KHI9bmV3IGcpLHIueD1lLngqdCxyLnk9ZS55KnQsci56PWUueip0LHJ9c3RhdGljIGRpdihlLHQscil7cmV0dXJuIHJ8fChyPW5ldyBnKSxyLng9ZS54L3QueCxyLnk9ZS55L3QueSxyLno9ZS56L3QueixyfXN0YXRpYyBub3JtYWxpemUoZSl7cmV0dXJuIGUuY2xvbmUoKS5ub3JtYWxpemUoKX1zdGF0aWMgZG90KGUsdCl7bGV0IHI9Zy5IRUxQXzA7cmV0dXJuIHIuY29weUZyb20oZSksci5kb3RQcm9kdWN0KHQpfXN0YXRpYyBjYWxjdWxhdGVWZWN0b3JBbmdsZV94eihlLHQpe3JldHVybiBNYXRoLmFjb3MoKGUueCp0LngrZS55KnQueSkvTWF0aC5zcXJ0KChlLngqZS54K2UueSplLnkpKih0LngqdC54K3QueSp0LnkpKSl9c3RhdGljIGRpc3RhbmNlKGUsdCl7cmV0dXJuIGcuZGlzdGFuY2UoZSx0KX1zdGF0aWMgZ2V0UmFuZG9tWFlaKGU9LTEwMCx0PTEwMCl7cmV0dXJuIG5ldyBnKE1hdGgucmFuZG9tKCkqKHQtZSkrZSxNYXRoLnJhbmRvbSgpKih0LWUpK2UsTWF0aC5yYW5kb20oKSoodC1lKStlKX1zdGF0aWMgZ2V0UmFuZG9tVjMoZT0tMTAwLHQ9MTAwLHIscyl7cmV0dXJuIG5ldyBnKE1hdGgucmFuZG9tKCkqdCtlLE1hdGgucmFuZG9tKCkqcytyLE1hdGgucmFuZG9tKCkqdCtlKX1zdGF0aWMgc3BoZXJlKGUpe2xldCB0PWUqTWF0aC5yYW5kb20oKSxyPW5ldyBnKE1hdGgucmFuZG9tKCkqMS0uNSxNYXRoLnJhbmRvbSgpKjEtLjUsTWF0aC5yYW5kb20oKSoxLS41KTtyZXR1cm4gci5ub3JtYWxpemUoKSxyLnNjYWxlQnkodCkscn1zdGF0aWMgc3BoZXJlWFlaKGUsdCxyPTEscz0xLGE9MSl7bGV0IG49ZSsodC1lKSpNYXRoLnJhbmRvbSgpLGw9bmV3IGcoTWF0aC5yYW5kb20oKSpyLXIqLjUsTWF0aC5yYW5kb20oKSpzLXMqLjUsTWF0aC5yYW5kb20oKSphLWEqLjUpO3JldHVybiBsLm5vcm1hbGl6ZSgpLGwuc2NhbGVCeShuKSxsfX1jbGFzcyBfcCBleHRlbmRzIEVle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJjYW1lcmFcIiksbyh0aGlzLFwibWluRGlzdGFuY2VcIiwuMSksbyh0aGlzLFwibWF4RGlzdGFuY2VcIiw1MDApLG8odGhpcyxcInJvbGxTbW9vdGhcIiwxNSksbyh0aGlzLFwiZHJhZ1Ntb290aFwiLDIwKSxvKHRoaXMsXCJ3aGVlbFNtb290aFwiLDEwKSxvKHRoaXMsXCJ3aGVlbFN0ZXBcIiwuMDAyKSxvKHRoaXMsXCJtb3VzZVJpZ2h0RmFjdG9yXCIsLjUpLG8odGhpcyxcIm1vdXNlTGVmdEZhY3RvclwiLDIwKSxvKHRoaXMsXCJzbW9vdGhcIiwhMCksbyh0aGlzLFwiX3doZWVsU3RlcFwiLC4wMDIpLG8odGhpcyxcIl9kaXN0YW5jZVwiLDApLG8odGhpcyxcImRpc3RhbmNlXCIsMTApLG8odGhpcyxcIl9yb2xsXCIsMCksbyh0aGlzLFwicm9sbFwiLDApLG8odGhpcyxcIl9waXRjaFwiLDApLG8odGhpcyxcInBpdGNoXCIsMCksbyh0aGlzLFwiX2N1cnJlbnRQb3NcIiksbyh0aGlzLFwiX3RhcmdldFBvc1wiKSxvKHRoaXMsXCJfbW91c2VMZWZ0RG93blwiLCExKSxvKHRoaXMsXCJfbW91c2VSaWdodERvd25cIiwhMSksbyh0aGlzLFwiX2JvdHRvbUNsYW1wXCIsODkuOTkpLG8odGhpcyxcIl90b3BDbGFtcFwiLC04OS45OSksbyh0aGlzLFwiX3RlbXBEaXJcIixuZXcgZyksbyh0aGlzLFwiX3RlbXBQb3NcIixuZXcgZyksdGhpcy5fY3VycmVudFBvcz1uZXcgdGUsdGhpcy5fdGFyZ2V0UG9zPW5ldyB0ZX1zdGFydCgpe3RoaXMuY2FtZXJhPXRoaXMub2JqZWN0M0QuZ2V0T3JBZGRDb21wb25lbnQoWmkpLEEuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfRE9XTix0aGlzLm9uTW91c2VEb3duLHRoaXMpLEEuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfTU9WRSx0aGlzLm9uTW91c2VNb3ZlLHRoaXMpLEEuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfVVAsdGhpcy5vbk1vdXNlVXAsdGhpcyksQS5pbnB1dFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9XSEVFTCx0aGlzLm9uTW91c2VXaGVlbCx0aGlzKX1zZXRDYW1lcmEoZSx0LHIscyl7dGhpcy5yb2xsPWUsdGhpcy5waXRjaD10LHRoaXMuZGlzdGFuY2U9cix0aGlzLm1heERpc3RhbmNlPHIqMS41JiYodGhpcy5tYXhEaXN0YW5jZT1yKjEuNSkscyYmdGhpcy5fdGFyZ2V0UG9zLnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLmNvcHkocyl9Zm9jdXNCeUJvdW5kcyhlKXtsZXQgdD1adC5nZW5NZXNoQm91bmRzKGUpO3RoaXMudGFyZ2V0PXQuY2VudGVyfXNldCB0YXJnZXQoZSl7dGhpcy5fdGFyZ2V0UG9zLnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLmNvcHkoZSl9Z2V0IHRhcmdldCgpe3JldHVybiB0aGlzLl90YXJnZXRQb3MudHJhbnNmb3JtLmxvY2FsUG9zaXRpb259b25Nb3VzZVdoZWVsKGUpe3RoaXMuZW5hYmxlJiYodGhpcy5fd2hlZWxTdGVwPXRoaXMud2hlZWxTdGVwKk9pLmRpc3RhbmNlKHRoaXMuX2N1cnJlbnRQb3MudHJhbnNmb3JtLndvcmxkUG9zaXRpb24sdGhpcy5jYW1lcmEudHJhbnNmb3JtLndvcmxkUG9zaXRpb24pLzEwLHRoaXMuZGlzdGFuY2UtPUEuaW5wdXRTeXN0ZW0ud2hlZWxEZWx0YSp0aGlzLl93aGVlbFN0ZXAsdGhpcy5kaXN0YW5jZT1LKHRoaXMuZGlzdGFuY2UsdGhpcy5taW5EaXN0YW5jZSx0aGlzLm1heERpc3RhbmNlKSl9b25Nb3VzZURvd24oZSl7aWYodGhpcy5lbmFibGUpc3dpdGNoKGUubW91c2VDb2RlKXtjYXNlIDA6dGhpcy5fbW91c2VMZWZ0RG93bj0hMDticmVhaztjYXNlIDE6YnJlYWs7Y2FzZSAyOnRoaXMuX21vdXNlUmlnaHREb3duPSEwO2JyZWFrfX1vbk1vdXNlVXAoZSl7dGhpcy5fbW91c2VMZWZ0RG93bj0hMSx0aGlzLl9tb3VzZVJpZ2h0RG93bj0hMX1vbk1vdXNlTW92ZShlKXtpZih0aGlzLmVuYWJsZSl7aWYodGhpcy5fbW91c2VSaWdodERvd24pe2xldCB0PS4yNSxyPXRoaXMuY2FtZXJhLnRyYW5zZm9ybS5mb3J3YXJkO09pLm11bFNjYWxlKHIsZS5tb3ZlbWVudFkqdCp0aGlzLmNhbWVyYS5hc3BlY3QsZy5IRUxQXzEpLHRoaXMuX3RhcmdldFBvcy54Kz1nLkhFTFBfMS54KnRoaXMubW91c2VSaWdodEZhY3Rvcix0aGlzLl90YXJnZXRQb3Mueis9Zy5IRUxQXzEueip0aGlzLm1vdXNlUmlnaHRGYWN0b3I7bGV0IHM9dGhpcy5jYW1lcmEudHJhbnNmb3JtLnJpZ2h0O09pLm11bFNjYWxlKHMsLWUubW92ZW1lbnRYKnQsZy5IRUxQXzEpLHRoaXMuX3RhcmdldFBvcy54LT1nLkhFTFBfMS54KnRoaXMubW91c2VSaWdodEZhY3Rvcix0aGlzLl90YXJnZXRQb3Muei09Zy5IRUxQXzEueip0aGlzLm1vdXNlUmlnaHRGYWN0b3J9dGhpcy5fbW91c2VMZWZ0RG93biYmKHRoaXMucm9sbC09ZS5tb3ZlbWVudFgqaGUuZGVsdGEqLjAwMSp0aGlzLm1vdXNlTGVmdEZhY3Rvcix0aGlzLnBpdGNoLT1lLm1vdmVtZW50WSpoZS5kZWx0YSouMDAxKnRoaXMubW91c2VMZWZ0RmFjdG9yLHRoaXMucGl0Y2g9Syh0aGlzLnBpdGNoLHRoaXMuX3RvcENsYW1wLHRoaXMuX2JvdHRvbUNsYW1wKSl9fW9uQmVmb3JlVXBkYXRlKGUpe2lmKCF0aGlzLmVuYWJsZSlyZXR1cm47bGV0IHQ9SyhoZS5kZWx0YSwwLC4wMTYpO3RoaXMuc21vb3RoPyh0aGlzLl9jdXJyZW50UG9zLngrPSh0aGlzLl90YXJnZXRQb3MueC10aGlzLl9jdXJyZW50UG9zLngpKnQqdGhpcy5kcmFnU21vb3RoLHRoaXMuX2N1cnJlbnRQb3MueSs9KHRoaXMuX3RhcmdldFBvcy55LXRoaXMuX2N1cnJlbnRQb3MueSkqdCp0aGlzLmRyYWdTbW9vdGgsdGhpcy5fY3VycmVudFBvcy56Kz0odGhpcy5fdGFyZ2V0UG9zLnotdGhpcy5fY3VycmVudFBvcy56KSp0KnRoaXMuZHJhZ1Ntb290aCx0aGlzLl9kaXN0YW5jZSs9KHRoaXMuZGlzdGFuY2UtdGhpcy5fZGlzdGFuY2UpKnQqdGhpcy53aGVlbFNtb290aCx0aGlzLl9yb2xsKz0odGhpcy5yb2xsLXRoaXMuX3JvbGwpKnQqdGhpcy5yb2xsU21vb3RoLHRoaXMuX3BpdGNoKz0odGhpcy5waXRjaC10aGlzLl9waXRjaCkqdCp0aGlzLnJvbGxTbW9vdGgpOih0aGlzLl9jdXJyZW50UG9zLng9dGhpcy5fdGFyZ2V0UG9zLngsdGhpcy5fY3VycmVudFBvcy55PXRoaXMuX3RhcmdldFBvcy55LHRoaXMuX2N1cnJlbnRQb3Muej10aGlzLl90YXJnZXRQb3Mueix0aGlzLl9kaXN0YW5jZT10aGlzLmRpc3RhbmNlLHRoaXMuX3JvbGw9dGhpcy5yb2xsLHRoaXMuX3BpdGNoPXRoaXMucGl0Y2gpLHRoaXMuX3RlbXBEaXIuc2V0KDAsMCwxKTtsZXQgcj1xLkhFTFBfMDtyLmZyb21FdWxlckFuZ2xlcyh0aGlzLl9waXRjaCx0aGlzLl9yb2xsLDApLHRoaXMuX3RlbXBEaXIuYXBwbHlRdWF0ZXJuaW9uKHIpLHRoaXMuX3RlbXBQb3M9T2kubXVsU2NhbGUodGhpcy5fdGVtcERpcix0aGlzLl9kaXN0YW5jZSx0aGlzLl90ZW1wUG9zKSx0aGlzLl90ZW1wUG9zLmFkZCh0aGlzLl9jdXJyZW50UG9zLnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLHRoaXMuX3RlbXBQb3MpLHRoaXMudHJhbnNmb3JtLmxvb2tBdCh0aGlzLl90ZW1wUG9zLHRoaXMuX2N1cnJlbnRQb3MudHJhbnNmb3JtLmxvY2FsUG9zaXRpb24sZy5VUCksdGhpcy5jYW1lcmEubG9va1RhcmdldC5jb3B5KHRoaXMuX2N1cnJlbnRQb3MudHJhbnNmb3JtLmxvY2FsUG9zaXRpb24pfWRlc3Ryb3koZSl7QS5pbnB1dFN5c3RlbS5yZW1vdmVFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9ET1dOLHRoaXMub25Nb3VzZURvd24sdGhpcyksQS5pbnB1dFN5c3RlbS5yZW1vdmVFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9NT1ZFLHRoaXMub25Nb3VzZU1vdmUsdGhpcyksQS5pbnB1dFN5c3RlbS5yZW1vdmVFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9VUCx0aGlzLm9uTW91c2VVcCx0aGlzKSxBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1dIRUVMLHRoaXMub25Nb3VzZVdoZWVsLHRoaXMpLHN1cGVyLmRlc3Ryb3koZSksdGhpcy5jYW1lcmE9bnVsbH19Y2xhc3MgeHAgZXh0ZW5kcyBFZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiX2NhbWVyYVwiKSxvKHRoaXMsXCJhdXRvUm90YXRlXCIsITEpLG8odGhpcyxcImF1dG9Sb3RhdGVTcGVlZFwiLC4xKSxvKHRoaXMsXCJyb3RhdGVGYWN0b3JcIiwuNSksbyh0aGlzLFwiem9vbUZhY3RvclwiLC4xKSxvKHRoaXMsXCJwYW5GYWN0b3JcIiwuMjUpLG8odGhpcyxcIl9zbW9vdGhcIiw1KSxvKHRoaXMsXCJfbWluRGlzdGFuY2VcIiwxKSxvKHRoaXMsXCJfbWF4RGlzdGFuY2VcIiwxZTUpLG8odGhpcyxcIl9tYXhQb2xhckFuZ2xlXCIsOTApLG8odGhpcyxcIl9taW5Qb2xhckFuZ2xlXCIsLTkwKSxvKHRoaXMsXCJfdGFyZ2V0XCIsbmV3IGcoMCwwLDApKSxvKHRoaXMsXCJfY1RhcmdldFwiLG5ldyBnKDAsMCwwKSksbyh0aGlzLFwiX3Bvc2l0aW9uXCIsbmV3IGcoMCwwLDApKSxvKHRoaXMsXCJfY1Bvc2l0aW9uXCIsbmV3IGcoMCwwLDApKSxvKHRoaXMsXCJfc3BoZXJpY2FsXCIsbmV3IHZwKSxvKHRoaXMsXCJfaXNNb3VzZURvd25cIiwhMSksbyh0aGlzLFwiX2xhc3RNb3VzZVhcIiwtMSksbyh0aGlzLFwiX2xhc3RNb3VzZVlcIiwtMSksbyh0aGlzLFwiX2lzUGFubmluZ1wiLCExKX1nZXQgdGFyZ2V0KCl7cmV0dXJuIHRoaXMuX3RhcmdldH1zZXQgdGFyZ2V0KGUpe3RoaXMuX3RhcmdldD1lfWdldCBzbW9vdGgoKXtyZXR1cm4gdGhpcy5fc21vb3RofXNldCBzbW9vdGgoZSl7dGhpcy5fc21vb3RoPU1hdGgubWF4KGUsMSl9Z2V0IG1pbkRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlfXNldCBtaW5EaXN0YW5jZShlKXt0aGlzLl9taW5EaXN0YW5jZT1LKGUsMmUtNix0aGlzLl9tYXhEaXN0YW5jZSl9Z2V0IG1heERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX21heERpc3RhbmNlfXNldCBtYXhEaXN0YW5jZShlKXt0aGlzLl9tYXhEaXN0YW5jZT1LKGUsdGhpcy5fbWluRGlzdGFuY2UsMS8wKX1nZXQgbWluUG9sYXJBbmdsZSgpe3JldHVybiB0aGlzLl9taW5Qb2xhckFuZ2xlfXNldCBtaW5Qb2xhckFuZ2xlKGUpe3RoaXMuX21pblBvbGFyQW5nbGU9SyhlLC05MCx0aGlzLl9tYXhQb2xhckFuZ2xlKX1nZXQgbWF4UG9sYXJBbmdsZSgpe3JldHVybiB0aGlzLl9tYXhQb2xhckFuZ2xlfXNldCBtYXhQb2xhckFuZ2xlKGUpe3RoaXMuX21heFBvbGFyQW5nbGU9SyhlLHRoaXMuX21pblBvbGFyQW5nbGUsOTApfXN0YXJ0KCl7dGhpcy5fY2FtZXJhPXRoaXMub2JqZWN0M0QuZ2V0Q29tcG9uZW50KFppKSx0aGlzLl9wb3NpdGlvbj10aGlzLm9iamVjdDNELnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uLmNsb25lKCksdGhpcy5fY1Bvc2l0aW9uPXRoaXMuX3Bvc2l0aW9uLmNsb25lKCksdGhpcy5fdGFyZ2V0PXRoaXMuX2NhbWVyYS5sb29rVGFyZ2V0LmNsb25lKCksdGhpcy5fY1RhcmdldD10aGlzLl90YXJnZXQuY2xvbmUoKSx0aGlzLl9zcGhlcmljYWwuc2V0Q29vcmRzKHRoaXMuX3Bvc2l0aW9uLngtdGhpcy5fdGFyZ2V0LngsdGhpcy5fcG9zaXRpb24ueS10aGlzLl90YXJnZXQueSx0aGlzLl9wb3NpdGlvbi56LXRoaXMuX3RhcmdldC56KSx0aGlzLl9jYW1lcmEubG9va0F0KHRoaXMuX2NQb3NpdGlvbix0aGlzLl9jVGFyZ2V0LGcuVVApLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigpfW9uRW5hYmxlKCl7dGhpcy5hZGRFdmVudExpc3RlbmVyKCl9b25EaXNhYmxlKCl7dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCl9b25VcGRhdGUoKXtsZXQgZT10aGlzLl9pc1Bhbm5pbmc/MTp0aGlzLnNtb290aCx0PSExO3RoaXMuX2NQb3NpdGlvbi5lcXVhbHModGhpcy5vYmplY3QzRC50cmFuc2Zvcm0ubG9jYWxQb3NpdGlvbil8fCh0aGlzLl9wb3NpdGlvbi5jb3B5RnJvbSh0aGlzLm9iamVjdDNELnRyYW5zZm9ybS5sb2NhbFBvc2l0aW9uKSxlPTEsdD0hMCksdGhpcy5fY1RhcmdldC5lcXVhbHModGhpcy5fdGFyZ2V0KXx8KHRoaXMuX2NUYXJnZXQuY29weUZyb20odGhpcy5fdGFyZ2V0KSxlPTEsdD0hMCksdD90aGlzLl9zcGhlcmljYWwuc2V0Q29vcmRzKHRoaXMuX3Bvc2l0aW9uLngtdGhpcy5fdGFyZ2V0LngsdGhpcy5fcG9zaXRpb24ueS10aGlzLl90YXJnZXQueSx0aGlzLl9wb3NpdGlvbi56LXRoaXMuX3RhcmdldC56KTohdGhpcy5faXNNb3VzZURvd24mJnRoaXMuYXV0b1JvdGF0ZSYmKHRoaXMuX3NwaGVyaWNhbC50aGV0YS09dGhpcy5hdXRvUm90YXRlU3BlZWQqTWF0aC5QSS8xODAsdGhpcy51cGRhdGVDYW1lcmEoKSk7bGV0IHI9KHRoaXMuX3Bvc2l0aW9uLngtdGhpcy5fY1Bvc2l0aW9uLngpL2Uscz0odGhpcy5fcG9zaXRpb24ueS10aGlzLl9jUG9zaXRpb24ueSkvZSxhPSh0aGlzLl9wb3NpdGlvbi56LXRoaXMuX2NQb3NpdGlvbi56KS9lO3RoaXMuX2NQb3NpdGlvbi54PU1hdGguYWJzKHIpPjFlLTEwP3RoaXMuX2NQb3NpdGlvbi54K3I6dGhpcy5fcG9zaXRpb24ueCx0aGlzLl9jUG9zaXRpb24ueT1NYXRoLmFicyhzKT4xZS0xMD90aGlzLl9jUG9zaXRpb24ueStzOnRoaXMuX3Bvc2l0aW9uLnksdGhpcy5fY1Bvc2l0aW9uLno9TWF0aC5hYnMoYSk+MWUtMTA/dGhpcy5fY1Bvc2l0aW9uLnorYTp0aGlzLl9wb3NpdGlvbi56LHRoaXMuX2NhbWVyYS5sb29rQXQodGhpcy5fY1Bvc2l0aW9uLHRoaXMuX2NUYXJnZXQsZy5VUCl9b25XaGVlbChlKXtlLmRlbHRhWT1LKGUuZGVsdGFZLC10aGlzLl9zcGhlcmljYWwucmFkaXVzLHRoaXMuX3NwaGVyaWNhbC5yYWRpdXMpLHRoaXMuX3NwaGVyaWNhbC5yYWRpdXMrPWUuZGVsdGFZKnRoaXMuem9vbUZhY3Rvcix0aGlzLl9zcGhlcmljYWwucmFkaXVzPUsodGhpcy5fc3BoZXJpY2FsLnJhZGl1cyx0aGlzLm1pbkRpc3RhbmNlLHRoaXMubWF4RGlzdGFuY2UpLHRoaXMudXBkYXRlQ2FtZXJhKCl9b25Qb2ludGVyRG93bihlKXt0aGlzLl9pc01vdXNlRG93bj0hMCx0aGlzLl9sYXN0TW91c2VYPWUubW91c2VYLHRoaXMuX2xhc3RNb3VzZVk9ZS5tb3VzZVksZS5tb3VzZUNvZGU9PT0yJiYodGhpcy5faXNQYW5uaW5nPSEwKX1vblBvaW50ZXJNb3ZlKGUpe2lmKCF0aGlzLl9pc01vdXNlRG93bnx8IXRoaXMuZW5hYmxlKXJldHVybjtsZXQgdD1lLm1vdXNlWCxyPWUubW91c2VZO2lmKGUubW91c2VDb2RlPT09MCYmdGhpcy5fbGFzdE1vdXNlWD4wJiZ0aGlzLl9sYXN0TW91c2VZPjApe2NvbnN0IHM9LSh0LXRoaXMuX2xhc3RNb3VzZVgpKnRoaXMucm90YXRlRmFjdG9yLGE9KHItdGhpcy5fbGFzdE1vdXNlWSkqdGhpcy5yb3RhdGVGYWN0b3I7dGhpcy5fc3BoZXJpY2FsLnRoZXRhKz1zKk1hdGguUEkvMTgwLHRoaXMuX3NwaGVyaWNhbC5waGktPWEqTWF0aC5QSS8xODAsdGhpcy5fc3BoZXJpY2FsLnBoaT1LKHRoaXMuX3NwaGVyaWNhbC5waGksdGhpcy5taW5Qb2xhckFuZ2xlLHRoaXMubWF4UG9sYXJBbmdsZSksdGhpcy51cGRhdGVDYW1lcmEoKX1lbHNlIGUubW91c2VDb2RlPT09MiYmKE9pLm11bFNjYWxlKHRoaXMub2JqZWN0M0QudHJhbnNmb3JtLnVwLGUubW92ZW1lbnRZKnRoaXMucGFuRmFjdG9yKnRoaXMuX2NhbWVyYS5hc3BlY3QsZy5IRUxQXzEpLHRoaXMuX3RhcmdldC55Kz1nLkhFTFBfMS55LE9pLm11bFNjYWxlKHRoaXMub2JqZWN0M0QudHJhbnNmb3JtLnJpZ2h0LC1lLm1vdmVtZW50WCp0aGlzLnBhbkZhY3RvcixnLkhFTFBfMSksdGhpcy5fdGFyZ2V0LngtPWcuSEVMUF8xLngsdGhpcy5fdGFyZ2V0LnotPWcuSEVMUF8xLnosdGhpcy5fY1RhcmdldC5jb3B5RnJvbSh0aGlzLl90YXJnZXQpLHRoaXMudXBkYXRlQ2FtZXJhKCkpO3RoaXMuX2xhc3RNb3VzZVg9dCx0aGlzLl9sYXN0TW91c2VZPXJ9b25Qb2ludGVyVXAoZSl7dGhpcy5faXNNb3VzZURvd249ITEsZS5tb3VzZUNvZGU9PT0yJiYodGhpcy5faXNQYW5uaW5nPSExKX1vblBvaW50ZXJMZWF2ZSgpe3RoaXMuX2lzTW91c2VEb3duPSExLHRoaXMuX2lzUGFubmluZz0hMX11cGRhdGVDYW1lcmEoKXt0aGlzLl9zcGhlcmljYWwubWFrZVNhZmUoKTtsZXQgZT10aGlzLl9zcGhlcmljYWwuZ2V0Q29vcmRzKCk7dGhpcy5fcG9zaXRpb24uc2V0KGUueCt0aGlzLl90YXJnZXQueCxlLnkrdGhpcy5fdGFyZ2V0LnksZS56K3RoaXMuX3RhcmdldC56KX1hZGRFdmVudExpc3RlbmVyKCl7QS5pbnB1dFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9XSEVFTCx0aGlzLm9uV2hlZWwsdGhpcyksQS5pbnB1dFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9ET1dOLHRoaXMub25Qb2ludGVyRG93bix0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX01PVkUsdGhpcy5vblBvaW50ZXJNb3ZlLHRoaXMpLEEuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfVVAsdGhpcy5vblBvaW50ZXJVcCx0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX09VVCx0aGlzLm9uUG9pbnRlckxlYXZlLHRoaXMpfXJlbW92ZUV2ZW50TGlzdGVuZXIoKXtBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1dIRUVMLHRoaXMub25XaGVlbCx0aGlzKSxBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX0RPV04sdGhpcy5vblBvaW50ZXJEb3duLHRoaXMpLEEuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfTU9WRSx0aGlzLm9uUG9pbnRlck1vdmUsdGhpcyksQS5pbnB1dFN5c3RlbS5yZW1vdmVFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9VUCx0aGlzLm9uUG9pbnRlclVwLHRoaXMpLEEuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfT1VULHRoaXMub25Qb2ludGVyTGVhdmUsdGhpcyl9fWNsYXNzIHZwe2NvbnN0cnVjdG9yKGU9MSx0PTAscj0wKXtyZXR1cm4gbyh0aGlzLFwicmFkaXVzXCIpLG8odGhpcyxcInBoaVwiKSxvKHRoaXMsXCJ0aGV0YVwiKSxvKHRoaXMsXCJjb29yZHNcIiksdGhpcy5yYWRpdXM9ZSx0aGlzLnBoaT10LHRoaXMudGhldGE9cix0aGlzLmNvb3Jkcz1uZXcgZyx0aGlzfXNldChlLHQscil7cmV0dXJuIHRoaXMucmFkaXVzPWUsdGhpcy5waGk9dCx0aGlzLnRoZXRhPXIsdGhpc31tYWtlU2FmZSgpe3JldHVybiB0aGlzLnBoaT1NYXRoLm1heCgyZS00LE1hdGgubWluKE1hdGguUEktMmUtNCx0aGlzLnBoaSkpLHRoaXN9c2V0RnJvbVZlY3RvcjMoZSl7cmV0dXJuIHRoaXMuc2V0Q29vcmRzKGUueCxlLnksZS56KX1zZXRDb29yZHMoZSx0LHIpe3JldHVybiB0aGlzLnJhZGl1cz1NYXRoLnNxcnQoZSplK3QqdCtyKnIpLHRoaXMucmFkaXVzPT09MD8odGhpcy50aGV0YT0wLHRoaXMucGhpPTApOih0aGlzLnRoZXRhPU1hdGguYXRhbjIoZSxyKSx0aGlzLnBoaT1NYXRoLmFjb3MoSyh0L3RoaXMucmFkaXVzLC0xLDEpKSksdGhpc31nZXRDb29yZHMoKXtjb25zdCBlPU1hdGguc2luKHRoaXMucGhpKSp0aGlzLnJhZGl1cztyZXR1cm4gdGhpcy5jb29yZHMueD1lKk1hdGguc2luKHRoaXMudGhldGEpLHRoaXMuY29vcmRzLnk9TWF0aC5jb3ModGhpcy5waGkpKnRoaXMucmFkaXVzLHRoaXMuY29vcmRzLno9ZSpNYXRoLmNvcyh0aGlzLnRoZXRhKSx0aGlzLmNvb3Jkc319Y2xhc3MgeXAgZXh0ZW5kcyBFZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiZm9jdXNcIiksbyh0aGlzLFwiX3JvdGF0aW9uXCIsbmV3IGcoNDUsMCwwKSksbyh0aGlzLFwiZGlzdGFuY2VcIiw1KSxvKHRoaXMsXCJfY2FtZXJhXCIpfXN0YXJ0KCl7aWYodGhpcy5fY2FtZXJhPXRoaXMub2JqZWN0M0QuZ2V0T3JBZGRDb21wb25lbnQoWmkpLCF0aGlzLl9jYW1lcmEpe2NvbnNvbGUuZXJyb3IoXCJUaGlyZFBlcnNvbkNhbWVyYUNvbnRyb2xsZXIgbmVlZCBjYW1lcmFcIik7cmV0dXJufWlmKCF0aGlzLmZvY3VzKXtjb25zb2xlLmVycm9yKFwiVGhpcmRQZXJzb25DYW1lcmFDb250cm9sbGVyIG5lZWQgdGFyZ2V0XCIpO3JldHVybn1BLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1dIRUVMLHRoaXMubW91c2VXaGVlbCx0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1VQLHRoaXMubW91c2VVcCx0aGlzKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX0RPV04sdGhpcy5tb3VzZURvd24sdGhpcyl9bW91c2VEb3duKGUpe0EuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfTU9WRSx0aGlzLm1vdXNlTW92ZSx0aGlzKX1tb3VzZVVwKGUpe0EuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfTU9WRSx0aGlzLm1vdXNlTW92ZSx0aGlzKX1tb3VzZU1vdmUoZSl7dGhpcy5fcm90YXRpb24ueSs9ZS5tb3ZlbWVudFgqLjAxLHRoaXMuX3JvdGF0aW9uLngrPWUubW92ZW1lbnRZKi4wMX1tb3VzZVdoZWVsKGUpe3RoaXMuZGlzdGFuY2UrPUEuaW5wdXRTeXN0ZW0ud2hlZWxEZWx0YSouMX1vblVwZGF0ZSgpe2xldCBlPW5ldyBnO3RoaXMuX2NhbWVyYS50cmFuc2Zvcm0uZm9yd2FyZC5zY2FsZVRvUmVmKHRoaXMuZGlzdGFuY2UsZSk7dmFyIHQ9dGhpcy5mb2N1cy50cmFuc2Zvcm0ud29ybGRQb3NpdGlvbjt0aGlzLl9jYW1lcmEudHJhbnNmb3JtLmxvY2FsUG9zaXRpb249dC5zdWJ0cmFjdChlKX1kZXN0cm95KGUpe0EuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfV0hFRUwsdGhpcy5tb3VzZVdoZWVsLHRoaXMpLEEuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfVVAsdGhpcy5tb3VzZVVwLHRoaXMpLEEuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfRE9XTix0aGlzLm1vdXNlRG93bix0aGlzKSxzdXBlci5kZXN0cm95KGUpfX12YXIgRGU9KGk9PihpW2kuTk9STUFMPTBdPVwiTk9STUFMXCIsaVtpLkRPV049MV09XCJET1dOXCIsaVtpLk9WRVI9Ml09XCJPVkVSXCIsaVtpLkRJU0FCTEU9M109XCJESVNBQkxFXCIsaSkpKERlfHx7fSk7bGV0IENwPU1hdGguUEksTmM9Q3AqMjtjbGFzcyBRaXtjb25zdHJ1Y3RvcihlPTEsdD0wLHI9MCxzPTEsYT0wLG49MCl7byh0aGlzLFwiYVwiKSxvKHRoaXMsXCJiXCIpLG8odGhpcyxcImNcIiksbyh0aGlzLFwiZFwiKSxvKHRoaXMsXCJ0eFwiKSxvKHRoaXMsXCJ0eVwiKSx0aGlzLmE9ZSx0aGlzLmI9dCx0aGlzLmM9cix0aGlzLmQ9cyx0aGlzLnR4PWEsdGhpcy50eT1ufWNsb25lKCl7cmV0dXJuIG5ldyBRaSh0aGlzLmEsdGhpcy5iLHRoaXMuYyx0aGlzLmQsdGhpcy50eCx0aGlzLnR5KX1jb25jYXQoZSl7bGV0IHQ9dGhpcy5hLHI9dGhpcy5jLHM9dGhpcy50eDt0aGlzLmE9dCplLmErdGhpcy5iKmUuYyx0aGlzLmI9dCplLmIrdGhpcy5iKmUuZCx0aGlzLmM9ciplLmErdGhpcy5kKmUuYyx0aGlzLmQ9ciplLmIrdGhpcy5kKmUuZCx0aGlzLnR4PXMqZS5hK3RoaXMudHkqZS5jK2UudHgsdGhpcy50eT1zKmUuYit0aGlzLnR5KmUuZCtlLnR5fWNvcHlGcm9tKGUpe3JldHVybiB0aGlzLmE9ZS5hLHRoaXMuYj1lLmIsdGhpcy5jPWUuYyx0aGlzLmQ9ZS5kLHRoaXMudHg9ZS50eCx0aGlzLnR5PWUudHksdGhpc31pZGVudGl0eSgpe3JldHVybiB0aGlzLmE9dGhpcy5kPTEsdGhpcy5iPXRoaXMuYz10aGlzLnR4PXRoaXMudHk9MCx0aGlzfWludmVydCgpe3RoaXMuX2ludmVydEludG8odGhpcyl9cm90YXRlKGUpe2lmKGU9K2UsZSE9PTApe2U9ZSpfZTtsZXQgdD1NYXRoLmNvcyhlKSxyPU1hdGguc2luKGUpLHM9dGhpcy5hLGE9dGhpcy5iLG49dGhpcy5jLGw9dGhpcy5kLGg9dGhpcy50eCx1PXRoaXMudHk7dGhpcy5hPXMqdC1hKnIsdGhpcy5iPXMqcithKnQsdGhpcy5jPW4qdC1sKnIsdGhpcy5kPW4qcitsKnQsdGhpcy50eD1oKnQtdSpyLHRoaXMudHk9aCpyK3UqdH19c2NhbGUoZSx0KXtlIT09MSYmKHRoaXMuYSo9ZSx0aGlzLmMqPWUsdGhpcy50eCo9ZSksdCE9PTEmJih0aGlzLmIqPXQsdGhpcy5kKj10LHRoaXMudHkqPXQpfXNldFRvKGUsdCxyLHMsYSxuKXtyZXR1cm4gdGhpcy5hPWUsdGhpcy5iPXQsdGhpcy5jPXIsdGhpcy5kPXMsdGhpcy50eD1hLHRoaXMudHk9bix0aGlzfXRyYW5zZm9ybVBvaW50KGUsdCxyKXtsZXQgcz10aGlzLmEqZSt0aGlzLmMqdCt0aGlzLnR4LGE9dGhpcy5iKmUrdGhpcy5kKnQrdGhpcy50eTtyZXR1cm4gcj8oci5zZXRUbyhzLGEsMCwxKSxyKTpuZXcgZyhzLGEsMCwxKX1zZXRUcmFuc2xhdGUoZSx0KXt0aGlzLnR4PWUsdGhpcy50eT10fXRyYW5zbGF0ZShlLHQpe3RoaXMudHgrPWUsdGhpcy50eSs9dH1tdWwoZSl7bGV0IHQ9dGhpcyxyPWUscz10LmEsYT10LmIsbj10LmMsbD10LmQsaD10LnR4LHU9dC50eSxjPXIuYSxmPXIuYixkPXIuYyxwPXIuZCxtPXIudHgsXz1yLnR5O2YhPT0wfHxkIT09MD8odGhpcy5hPXMqYythKmQsdGhpcy5iPXMqZithKnAsdGhpcy5jPW4qYytsKmQsdGhpcy5kPW4qZitsKnAsdGhpcy50eD1jKmgrZCp1K20sdGhpcy50eT1mKmgrcCp1K18pOih0aGlzLmE9cypjLHRoaXMuYj1hKnAsdGhpcy5jPW4qYyx0aGlzLmQ9bCpwLHRoaXMudHg9YypoK20sdGhpcy50eT1wKnUrXyl9ZXF1YWxzKGUpe3JldHVybiB0aGlzLmE9PWUuYSYmdGhpcy5iPT1lLmImJnRoaXMuYz09ZS5jJiZ0aGlzLmQ9PWUuZCYmdGhpcy50eD09ZS50eCYmdGhpcy50eT09ZS50eX1wcmVwZW5kKGUsdCxyLHMsYSxuKXtsZXQgbD10aGlzLnR4O2lmKGUhPTF8fHQhPTB8fHIhPTB8fHMhPTEpe2xldCBoPXRoaXMuYSx1PXRoaXMuYzt0aGlzLmE9aCplK3RoaXMuYipyLHRoaXMuYj1oKnQrdGhpcy5iKnMsdGhpcy5jPXUqZSt0aGlzLmQqcix0aGlzLmQ9dSp0K3RoaXMuZCpzfXJldHVybiB0aGlzLnR4PWwqZSt0aGlzLnR5KnIrYSx0aGlzLnR5PWwqdCt0aGlzLnR5KnMrbix0aGlzfWFwcGVuZChlKXtsZXQgdD10aGlzLmEscj10aGlzLmIscz10aGlzLmMsYT10aGlzLmQ7cmV0dXJuKGUuYSE9MXx8ZS5iIT0wfHxlLmMhPTB8fGUuZCE9MSkmJih0aGlzLmE9ZS5hKnQrZS5iKnMsdGhpcy5iPWUuYSpyK2UuYiphLHRoaXMuYz1lLmMqdCtlLmQqcyx0aGlzLmQ9ZS5jKnIrZS5kKmEpLHRoaXMudHg9ZS50eCp0K2UudHkqcyt0aGlzLnR4LHRoaXMudHk9ZS50eCpyK2UudHkqYSt0aGlzLnR5LHRoaXN9ZGVsdGFUcmFuc2Zvcm1Qb2ludChlKXtsZXQgdD10aGlzLHI9dC5hKmUueCt0LmMqZS55LHM9dC5iKmUueCt0LmQqZS55O3JldHVybiBuZXcgZyhyLHMpfXRvU3RyaW5nKCl7cmV0dXJuXCIoYT1cIit0aGlzLmErXCIsIGI9XCIrdGhpcy5iK1wiLCBjPVwiK3RoaXMuYytcIiwgZD1cIit0aGlzLmQrXCIsIHR4PVwiK3RoaXMudHgrXCIsIHR5PVwiK3RoaXMudHkrXCIpXCJ9Y3JlYXRlQm94KGUsdCxyPTAscz0wLGE9MCl7bGV0IG49dGhpcztpZihyIT09MCl7cj1yKl9lO2xldCBsPU1hdGguY29zKHIpLGg9TWF0aC5zaW4ocik7bi5hPWwqZSxuLmI9aCp0LG4uYz0taCplLG4uZD1sKnR9ZWxzZSBuLmE9ZSxuLmI9MCxuLmM9MCxuLmQ9dDtuLnR4PXMsbi50eT1hfWNyZWF0ZUdyYWRpZW50Qm94KGUsdCxyPTAscz0wLGE9MCl7dGhpcy5jcmVhdGVCb3goZS8xNjM4LjQsdC8xNjM4LjQscixzK2UvMixhK3QvMil9X2ludmVydEludG8oZSl7bGV0IHQ9dGhpcy5hLHI9dGhpcy5iLHM9dGhpcy5jLGE9dGhpcy5kLG49dGhpcy50eCxsPXRoaXMudHk7aWYocj09MCYmcz09MCl7ZS5iPWUuYz0wLHQ9PTB8fGE9PTA/ZS5hPWUuZD1lLnR4PWUudHk9MDoodD1lLmE9MS90LGE9ZS5kPTEvYSxlLnR4PS10Km4sZS50eT0tYSpsKTtyZXR1cm59bGV0IGg9dCphLXIqcztpZihoPT0wKXtlLmlkZW50aXR5KCk7cmV0dXJufWg9MS9oO2xldCB1PWUuYT1hKmg7cj1lLmI9LXIqaCxzPWUuYz0tcypoLGE9ZS5kPXQqaCxlLnR4PS0odSpuK3MqbCksZS50eT0tKHIqbithKmwpfWdldFNjYWxlWCgpe2xldCBlPXRoaXM7aWYoZS5hPT0xJiZlLmI9PTApcmV0dXJuIDE7bGV0IHQ9TWF0aC5zcXJ0KGUuYSplLmErZS5iKmUuYik7cmV0dXJuIHRoaXMuZ2V0RGV0ZXJtaW5hbnQoKTwwPy10OnR9Z2V0U2NhbGVZKCl7bGV0IGU9dGhpcztpZihlLmM9PTAmJmUuZD09MSlyZXR1cm4gMTtsZXQgdD1NYXRoLnNxcnQoZS5jKmUuYytlLmQqZS5kKTtyZXR1cm4gdGhpcy5nZXREZXRlcm1pbmFudCgpPDA/LXQ6dH1nZXRTa2V3WCgpe3JldHVybiBNYXRoLmF0YW4yKHRoaXMuZCx0aGlzLmMpLU1hdGguUEkvMn1nZXRTa2V3WSgpe3JldHVybiBNYXRoLmF0YW4yKHRoaXMuYix0aGlzLmEpfXVwZGF0ZVNjYWxlQW5kUm90YXRpb24oZSx0LHIscyl7aWYoKHI9PTB8fHI9PU5jKSYmKHM9PTB8fHM9PU5jKSl7dGhpcy5hPWUsdGhpcy5iPXRoaXMuYz0wLHRoaXMuZD10O3JldHVybn1yPXIqX2Uscz1zKl9lO2xldCBhPU1hdGguY29zKHIpLG49TWF0aC5zaW4ocik7cj09cz8odGhpcy5hPWEqZSx0aGlzLmI9biplKToodGhpcy5hPU1hdGguY29zKHMpKmUsdGhpcy5iPU1hdGguc2luKHMpKmUpLHRoaXMuYz0tbip0LHRoaXMuZD1hKnR9cHJlTXVsdGlwbHlJbnRvKGUsdCl7bGV0IHI9ZS5hKnRoaXMuYSxzPTAsYT0wLG49ZS5kKnRoaXMuZCxsPWUudHgqdGhpcy5hK3RoaXMudHgsaD1lLnR5KnRoaXMuZCt0aGlzLnR5OyhlLmIhPT0wfHxlLmMhPT0wfHx0aGlzLmIhPT0wfHx0aGlzLmMhPT0wKSYmKHIrPWUuYip0aGlzLmMsbis9ZS5jKnRoaXMuYixzKz1lLmEqdGhpcy5iK2UuYip0aGlzLmQsYSs9ZS5jKnRoaXMuYStlLmQqdGhpcy5jLGwrPWUudHkqdGhpcy5jLGgrPWUudHgqdGhpcy5iKSx0LmE9cix0LmI9cyx0LmM9YSx0LmQ9bix0LnR4PWwsdC50eT1ofSR0cmFuc2Zvcm1Cb3VuZHMoZSl7bGV0IHQ9dGhpcy5hLHI9dGhpcy5iLHM9dGhpcy5jLGE9dGhpcy5kLG49dGhpcy50eCxsPXRoaXMudHksaD1lLngsdT1lLnksYz1oK2Uud2lkdGgsZj11K2UuaGVpZ2h0LGQ9dCpoK3MqdStuLHA9cipoK2EqdStsLG09dCpjK3MqdStuLF89cipjK2EqdStsLHY9dCpjK3MqZituLHk9cipjK2EqZitsLEM9dCpoK3MqZituLEI9cipoK2EqZitsLFQ9MDtkPm0mJihUPWQsZD1tLG09VCksdj5DJiYoVD12LHY9QyxDPVQpLGUueD1NYXRoLmZsb29yKGQ8dj9kOnYpLGUud2lkdGg9TWF0aC5jZWlsKChtPkM/bTpDKS1lLngpLHA+XyYmKFQ9cCxwPV8sXz1UKSx5PkImJihUPXkseT1CLEI9VCksZS55PU1hdGguZmxvb3IocDx5P3A6eSksZS5oZWlnaHQ9TWF0aC5jZWlsKChfPkI/XzpCKS1lLnkpfWdldERldGVybWluYW50KCl7cmV0dXJuIHRoaXMuYSp0aGlzLmQtdGhpcy5iKnRoaXMuY319Y2xhc3MgQ3MgZXh0ZW5kcyBFZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwiaXNHVUlDYW52YXNcIiwhMCksbyh0aGlzLFwiaW5kZXhcIiwwKX1hZGRDaGlsZChlKXtyZXR1cm4gdGhpcy5vYmplY3QzRC5hZGRDaGlsZChlKSx0aGlzfXJlbW92ZUNoaWxkKGUpe3JldHVybiB0aGlzLm9iamVjdDNELnJlbW92ZUNoaWxkKGUpLHRoaXN9Y2xvbmVUbyhlKXtlLmdldE9yQWRkQ29tcG9uZW50KENzKS5jb3B5Q29tcG9uZW50KHRoaXMpfWNvcHlDb21wb25lbnQoZSl7cmV0dXJuIGUuaW5kZXg9ZS5pbmRleCx0aGlzfX12YXIgUGU9KGk9PihpW2kuTk9ORT0wXT1cIk5PTkVcIixpW2kuUE9TSVRJT049MV09XCJQT1NJVElPTlwiLGlbaS5TUFJJVEU9Ml09XCJTUFJJVEVcIixpW2kuQ09MT1I9NF09XCJDT0xPUlwiLGlbaS5NQVg9N109XCJNQVhcIixpKSkoUGV8fHt9KTtjbGFzcyBubntjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJhcnJheVwiKSxvKHRoaXMsXCJidWZmZXJcIiksdGhpcy5idWZmZXI9bmV3IGdlKGUsMCksdGhpcy5hcnJheT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuYnVmZmVyLm1lbW9yeS5zaGFyZURhdGFCdWZmZXIpfX1jbGFzcyBGYyBleHRlbmRzIHR0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksbyh0aGlzLFwiX2F0dHJpYnV0ZVVWXCIpLG8odGhpcyxcIl9hdHRyaWJ1dGVWSW5kZXhcIiksbyh0aGlzLFwiX2ZhY2VJbmRleGVzXCIpLG8odGhpcyxcIl91dlNpemVcIiwyKSxvKHRoaXMsXCJfdkluZGV4U2l6ZVwiLDEpLG8odGhpcyxcIl9wb3NBdHRyaWJ1dGVcIiksbyh0aGlzLFwiX3Nwcml0ZUF0dHJpYnV0ZVwiKSxvKHRoaXMsXCJfY29sb3JBdHRyaWJ1dGVcIiksbyh0aGlzLFwiX29uUG9zaXRpb25DaGFuZ2VcIiwhMCksbyh0aGlzLFwiX29uU3ByaXRlQ2hhbmdlXCIsITApLG8odGhpcyxcIl9vbkNvbG9yQ2hhbmdlXCIsITApLG8odGhpcyxcIm1heFF1YWRDb3VudFwiKSx0aGlzLm1heFF1YWRDb3VudD1lfXVwZGF0ZUJvdW5kcyhlLHQpe2xldCByPU51bWJlci5NQVhfVkFMVUUqLjE7cmV0dXJuIGU9bmV3IGcoLXIsLXIsLXIpLHQ9bmV3IGcocixyLHIpLHRoaXMuYm91bmRzLnNldEZyb21NaW5NYXgoZSx0KSx0aGlzfWdldCB2UG9zaXRpb25CdWZmZXIoKXtyZXR1cm4gdGhpcy5fb25Qb3NpdGlvbkNoYW5nZSYmKHRoaXMuX3Bvc0F0dHJpYnV0ZS5idWZmZXIuYXBwbHkoKSx0aGlzLl9vblBvc2l0aW9uQ2hhbmdlPSExKSx0aGlzLl9wb3NBdHRyaWJ1dGUuYnVmZmVyfWdldCB2U3ByaXRlQnVmZmVyKCl7cmV0dXJuIHRoaXMuX29uU3ByaXRlQ2hhbmdlJiYodGhpcy5fc3ByaXRlQXR0cmlidXRlLmJ1ZmZlci5hcHBseSgpLHRoaXMuX29uU3ByaXRlQ2hhbmdlPSExKSx0aGlzLl9zcHJpdGVBdHRyaWJ1dGUuYnVmZmVyfWdldCB2Q29sb3JCdWZmZXIoKXtyZXR1cm4gdGhpcy5fb25Db2xvckNoYW5nZSYmKHRoaXMuX2NvbG9yQXR0cmlidXRlLmJ1ZmZlci5hcHBseSgpLHRoaXMuX29uQ29sb3JDaGFuZ2U9ITEpLHRoaXMuX2NvbG9yQXR0cmlidXRlLmJ1ZmZlcn1jcmVhdGUoKXt0aGlzLmNyZWF0ZUJ1ZmZlcigpLHRoaXMudXBkYXRlQm91bmRzKCk7bGV0IGU9dGhpcy5tYXhRdWFkQ291bnQsdD1bXSxyPVtdO2ZvcihsZXQgYT0wO2E8ZTthKyspdC5wdXNoKC4uLmFpLmF0dFVWKTtmb3IobGV0IGE9MCxuPXRoaXMubWF4UXVhZENvdW50KmFpLnZlcnRleENvdW50O2E8bjthKyspclthXT1hO3RoaXMuX2F0dHJpYnV0ZVVWPW5ldyBGbG9hdDMyQXJyYXkoYWkudmVydGV4Q291bnQqZSp0aGlzLl91dlNpemUpLHRoaXMuX2F0dHJpYnV0ZVZJbmRleD1uZXcgRmxvYXQzMkFycmF5KGFpLnZlcnRleENvdW50KmUqdGhpcy5fdkluZGV4U2l6ZSksdGhpcy5fYXR0cmlidXRlVVYuc2V0KHQsMCksdGhpcy5fYXR0cmlidXRlVkluZGV4LnNldChyLDApO2xldCBzPVtdO2ZvcihsZXQgYT0wO2E8ZTthKyspZm9yKGxldCBuPTA7bjxhaS5pbmRlY2llcy5sZW5ndGg7bisrKXtjb25zdCBsPWFpLmluZGVjaWVzW25dK2EqNDtzLnB1c2gobCl9cmV0dXJuIHRoaXMuX2ZhY2VJbmRleGVzPW5ldyBVaW50MzJBcnJheShlKjYpLHRoaXMuX2ZhY2VJbmRleGVzLnNldChzLDApLHRoaXMuc2V0SW5kaWNlcyh0aGlzLl9mYWNlSW5kZXhlcyksdGhpcy5zZXRBdHRyaWJ1dGUoWS51dix0aGlzLl9hdHRyaWJ1dGVVViksdGhpcy5zZXRBdHRyaWJ1dGUoWS52SW5kZXgsdGhpcy5fYXR0cmlidXRlVkluZGV4KSx0aGlzLmFkZFN1Ykdlb21ldHJ5KHtpbmRleFN0YXJ0OjAsaW5kZXhDb3VudDp0aGlzLl9mYWNlSW5kZXhlcy5sZW5ndGgsdmVydGV4U3RhcnQ6MCxpbmRleDowfSksdGhpc31jcmVhdGVCdWZmZXIoKXtsZXQgZT10aGlzLm1heFF1YWRDb3VudDt0aGlzLl9wb3NBdHRyaWJ1dGU9bmV3IG5uKGUqNCksdGhpcy5fc3ByaXRlQXR0cmlidXRlPW5ldyBubihlKig0KzQrMisyKSksdGhpcy5fY29sb3JBdHRyaWJ1dGU9bmV3IG5uKGUqNCl9ZmlsbFF1YWQoZSx0KXtlLmRpcnR5QXR0cmlidXRlcyZQZS5QT1NJVElPTiYmdGhpcy5maWxsUXVhZFBvc2l0aW9uKGUsdCksZS5kaXJ0eUF0dHJpYnV0ZXMmUGUuQ09MT1ImJnRoaXMuZmlsbFF1YWRDb2xvcihlLHQpLGUuZGlydHlBdHRyaWJ1dGVzJlBlLlNQUklURSYmdGhpcy5maWxsUXVhZFNwcml0ZShlLHQpfWZpbGxRdWFkUG9zaXRpb24oZSx0KXtrYy5zZXRYWVpXKHRoaXMuX3Bvc0F0dHJpYnV0ZS5hcnJheSxlLnosZS5sZWZ0LGUuYm90dG9tLGUucmlnaHQsZS50b3ApLHRoaXMuX29uUG9zaXRpb25DaGFuZ2U9ITB9ZmlsbFF1YWRDb2xvcihlLHQpe2xldCByPWUuY29sb3Iscz10aGlzLl9jb2xvckF0dHJpYnV0ZS5hcnJheTtrYy5zZXRYWVpXKHMsZS56LHIucixyLmcsci5iLHIuYSksdGhpcy5fb25Db2xvckNoYW5nZT0hMH1maWxsUXVhZFNwcml0ZShlLHQpe2xldCByPWUuc3ByaXRlLHM9MCxhPTA7ci5pc1NsaWNlZCYmZS5pbWFnZVR5cGU9PXByLlNsaWNlZCYmKHM9ci50cmltU2l6ZS54LHM9KHQud2lkdGgtKHIub2Zmc2V0U2l6ZS56LXIudHJpbVNpemUueCkpL3MsYT1yLnRyaW1TaXplLnksYT0odC5oZWlnaHQtKHIub2Zmc2V0U2l6ZS53LXIudHJpbVNpemUueSkpL2EpO2xldCBuPXIuZ3VpVGV4dHVyZS5keW5hbWljSWQsbD1yLnV2UmVjLGg9ci51dkJvcmRlcix1PXRoaXMuX3Nwcml0ZUF0dHJpYnV0ZS5hcnJheSxjPSg0KzQrMisyKSplLno7dVtjKzBdPWwueCx1W2MrMV09bC55LHVbYysyXT1sLnosdVtjKzNdPWwudyx1W2MrNF09aC54LHVbYys1XT1oLnksdVtjKzZdPWgueix1W2MrN109aC53LHVbYys4XT1zLHVbYys5XT1hLHVbYysxMF09bix1W2MrMTFdPWUudmlzaWJsZT8xOjAsdGhpcy5fb25TcHJpdGVDaGFuZ2U9ITB9fWNsYXNzIHdwe3N0YXRpYyBzZXQoZSx0LHIscywuLi5hKXtsZXQgbj10KnMrcjtmb3IobGV0IGw9MCxoPWEubGVuZ3RoO2w8aDtsKyspZVtuK2xdPWFbbF19fWNsYXNzIGtjIGV4dGVuZHMgd3B7c3RhdGljIHNldFhZWlcoZSx0LHIscyxhLG4pe3RoaXMuc2V0KGUsdCwwLDQscixzLGEsbil9c3RhdGljIHNldFhZWihlLHQscixzLGEpe3RoaXMuc2V0KGUsdCwwLDQscixzLGEpfXN0YXRpYyBzZXRaKGUsdCxyKXt0aGlzLnNldChlLHQsMyw0LHIpfX1jbGFzcyBhaXt9byhhaSxcInZlcnRleENvdW50XCIsNCksbyhhaSxcImF0dFVWXCIsWzAsMCwxLDAsMSwxLDAsMV0pLG8oYWksXCJpbmRlY2llc1wiLFswLDEsMiwwLDIsM10pO2NsYXNzIHpje2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX3RleHR1cmVNYXBcIixuZXcgTWFwKSxvKHRoaXMsXCJfdGV4dHVyZUxpc3RcIixbXSl9YnVpbGQoZSx0LHIpe2xldCBzPS0xLGE9LTE7dGhpcy5fdGV4dHVyZU1hcC5jbGVhcigpLHRoaXMuX3RleHR1cmVMaXN0Lmxlbmd0aD0wO2xldCBuPVtdLGw9dC5xdWFkTWF4Q291bnQtMSxoO2ZvcihsZXQgdSBvZiBlKXtsZXQgYz11Lm5lZWRVcGRhdGVRdWFkcztuLmxlbmd0aD0wO2NvbnN0IGY9dGhpcy5jb2xsZWN0UXVhZHModS5vYmplY3QzRCxuKTtmb3IobGV0IGQgb2YgZil7ZC56PSsrcztsZXQgcD1kLnNwcml0ZS5ndWlUZXh0dXJlO2lmKCF0aGlzLl90ZXh0dXJlTWFwLmhhcyhwLnN0YXRpY0lkKSYmKCsrYSx0aGlzLl90ZXh0dXJlTWFwLnNldChwLnN0YXRpY0lkLHApLHAuZHluYW1pY0lkPWEsdGhpcy5fdGV4dHVyZUxpc3RbYV09cC50ZXh0dXJlLGE+Nykpe2NvbnNvbGUud2FybihcInRleHR1cmUgQ291bnQgRXhjZWVkZWQgdGhlIG1heGltdW0gbGltaXQgb2YgN1wiKTticmVha31pZihkLmNhY2hlVGV4dHVyZUlkIT1wLmR5bmFtaWNJZCYmKGQuZGlydHlBdHRyaWJ1dGVzPVBlLk1BWCxkLmNhY2hlVGV4dHVyZUlkPXAuZHluYW1pY0lkKSwoY3x8cikmJihkLmRpcnR5QXR0cmlidXRlcz1QZS5NQVgpLGQuZGlydHlBdHRyaWJ1dGVzJlBlLlBPU0lUSU9OJiZkLmFwcGx5VHJhbnNmb3JtKHUpLGQuZGlydHlBdHRyaWJ1dGVzJiZkLndyaXRlVG9HZW9tZXRyeSh0Ll9nZW9tZXRyeSx1KSxzPT1sKXtoPSEwO2JyZWFrfX1pZihoKWJyZWFrfXJldHVybiB0Ll91aU1hdGVyaWFsLnNldFRleHR1cmVzKHRoaXMuX3RleHR1cmVMaXN0KSx0Ll9saW1pdFZlcnRleENvdW50PShzKzEpKjQsIWh9Y29sbGVjdFF1YWRzKGUsdCl7dHx8KHQ9W10pO2xldCByPWUuY29tcG9uZW50cy52YWx1ZXMoKTtmb3IobGV0IHMgb2Ygcil7bGV0IGE9cztpZihhLmlzVUlTaGFkb3d8fCFhLm1haW5RdWFkcyljb250aW51ZTtsZXQgbj1hLmdldFNoYWRvd1JlbmRlcigpO24mJnRoaXMucHVzaChuLm1haW5RdWFkcyx0KSx0aGlzLnB1c2goYS5tYWluUXVhZHMsdCl9cmV0dXJuIHR9cHVzaChlLHQpe2UmJmUubGVuZ3RoPjAmJnQucHVzaCguLi5lKX19Y29uc3QgZ3Q9Y2xhc3N7c3RhdGljIGJpbmRUZXh0dXJlQXJyYXkoKXtsZXQgaT1cIlwiO2ZvcihsZXQgZT0wO2U8NztlKyspaSs9YFxuICAgICAgICBAZ3JvdXAoMSkgQGJpbmRpbmcoYXV0bylcbiAgICAgICAgdmFyIHRleF8ke2V9U2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgQGdyb3VwKDEpIEBiaW5kaW5nKGF1dG8pXG4jaWYgVmlkZW9UZXh0dXJlJHtlfVxuICAgICAgICB2YXIgdGV4XyR7ZX06IHRleHR1cmVfZXh0ZXJuYWw7XG4jZWxzZVxuICAgICAgICB2YXIgdGV4XyR7ZX06IHRleHR1cmVfMmQ8ZjMyPjtcbiNlbmRpZlxuYDtyZXR1cm4gaX1zdGF0aWMgc2FtcGxlVGV4dHVyZShpKXtyZXR1cm5gXG4jaWYgVmlkZW9UZXh0dXJlJHtpfVxuICAgICAgICAgICAgbGV0IHNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyh0ZXhfJHtpfSkueHkgLSAxO1xuICAgICAgICAgICAgdXYueSA9IDEuMCAtIHV2Lnk7XG4gICAgICAgICAgICBsZXQgaXV2ID0gdmVjMjxpMzI+KHV2ICogdmVjMjxmMzI+KHNpemUpKTtcbiAgICAgICAgICAgIGNvbG9yID0gdGV4dHVyZUxvYWQodGV4XyR7aX0sIGl1dikgO1xuI2Vsc2VcbiAgICAgICAgICAgIGNvbG9yID0gdGV4dHVyZVNhbXBsZUxldmVsKHRleF8ke2l9LCB0ZXhfJHtpfVNhbXBsZXIsIHV2LCAwLjApO1xuI2VuZGlmICAgICAgICBgfX07bGV0IE5pPWd0O28oTmksXCJmc1wiLGBcbiAgICAgICAgJHtXYX1cbiAgICAgICAgJHtndC5iaW5kVGV4dHVyZUFycmF5KCl9XG5cbiAgICAgICAgdmFyPHByaXZhdGU+IGZyYWdtZW50T3V0cHV0OiBGcmFnbWVudE91dHB1dDtcbiAgICAgICAgdmFyPHByaXZhdGU+IHV2U2xpY2U6IHZlYzI8ZjMyPjtcbiAgICAgICAgdmFyPHByaXZhdGU+IEVQU0lMT046IGYzMiA9IDAuMDAxO1xuICAgICAgICBcbiAgICAgICAgZm4gc2xpY2VCb3JkZXIodXY6ZjMyLCBzY2FsZTpmMzIsIGJvcmRlcjp2ZWMyPGYzMj4pIC0+IGYzMiBcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHMgPSB1diAqIHNjYWxlO1xuICAgICAgICAgICAgaWYocyA+IGJvcmRlci54KXtcbiAgICAgICAgICAgICAgICBzIC09IGJvcmRlci54O1xuICAgICAgICAgICAgICAgIGxldCBjZW50ZXJQYXJ0TWF4ID0gc2NhbGUgLSBib3JkZXIueCAtIGJvcmRlci55O1xuICAgICAgICAgICAgICAgIGxldCBjZW50ZXJQYXJ0TWluID0gMS4wIC0gYm9yZGVyLnggLSBib3JkZXIueTtcbiAgICAgICAgICAgICAgICBpZihzIDwgY2VudGVyUGFydE1heCl7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBib3JkZXIueCArIChzIC8gY2VudGVyUGFydE1heCkgKiBjZW50ZXJQYXJ0TWluO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBzID0gcyAtIGNlbnRlclBhcnRNYXggKyBib3JkZXIueCArIGNlbnRlclBhcnRNaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cblxuICAgICAgICBmbiBpc0luc2lkZUFscGhhKGNvb3JkOnZlYzI8ZjMyPiwgcmVjdDp2ZWM0PGYzMj4sIGNvcm5lclJhZGl1czA6ZjMyLCBmYWRlT3V0U2l6ZTA6ZjMyKSAtPiBmMzJcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG1pblggPSBtaW4ocmVjdC54LCByZWN0LnopO1xuICAgICAgICAgICAgdmFyIG1heFggPSBtYXgocmVjdC54LCByZWN0LnopO1xuICAgICAgICAgICAgdmFyIG1pblkgPSBtaW4ocmVjdC55LCByZWN0LncpO1xuICAgICAgICAgICAgdmFyIG1heFkgPSBtYXgocmVjdC55LCByZWN0LncpO1xuXG4gICAgICAgICAgICB2YXIgY29ybmVyUmFkaXVzID0gbWF4KEVQU0lMT04sIGNvcm5lclJhZGl1czApO1xuXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdmVjMjxmMzI+KG1pblggKyBtYXhYLCBtaW5ZICsgbWF4WSkgKiAwLjU7XG4gICAgICAgICAgICB2YXIgZXh0ZW50cyA9IHZlYzI8ZjMyPihtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpICogMC41O1xuXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXMgPSBtaW4oZXh0ZW50cy54LCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gbWluKGV4dGVudHMueSwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGV4dGVuZHNNaW4gPSBtYXgodmVjMjxmMzI+KDAuMCksIGV4dGVudHMgLSBjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdG9DZW50ZXIgPSBhYnMoY29vcmQgLSBjZW50ZXIpO1xuICAgICAgICAgICAgdmFyIG91dGVyRGlzdCA9IHRvQ2VudGVyIC0gZXh0ZW50cztcbiAgICAgICAgICAgIHZhciBpbm5lckRpc3QgPSB0b0NlbnRlciAtIGV4dGVuZHNNaW47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGlubmVyRGlzdC54IDw9IDAgJiYgaW5uZXJEaXN0LnkgPD0gMCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgICAgIH1lbHNlIGlmKG91dGVyRGlzdC54IDw9IDAgJiYgb3V0ZXJEaXN0LnkgPD0gMCl7XG4gICAgICAgICAgICAgICAgdmFyIGZhZGVPdXRQZXJjZW50ID0gY2xhbXAoZmFkZU91dFNpemUwLCBFUFNJTE9OLCBjb3JuZXJSYWRpdXMpIC8gY29ybmVyUmFkaXVzO1xuICAgICAgICAgICAgICAgIGlubmVyRGlzdCA9IG1heCh2ZWMyKEVQU0lMT04pLCBpbm5lckRpc3QpO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IG1pbihjb3JuZXJSYWRpdXMsIGxlbmd0aChpbm5lckRpc3QpKTtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSAxLjAgLSBkaXN0YW5jZSAvIGNvcm5lclJhZGl1cztcbiAgICAgICAgICAgICAgICBhbHBoYSAvPSBmYWRlT3V0UGVyY2VudDtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNsYW1wKGFscGhhLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgQGZyYWdtZW50XG4gICAgICAgIGZuIEZyYWdNYWluKCBcbiAgICAgICAgICAgIEBsb2NhdGlvbigwKSB2VVY6IHZlYzI8ZjMyPixcbiAgICAgICAgICAgIEBsb2NhdGlvbigxKSB2Q29sb3I0OiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICBAbG9jYXRpb24oMikgdkxvY2FsUG9zOiB2ZWMyPGYzMj4sXG4gICAgICAgICAgICBAbG9jYXRpb24oMykgdlV2UmVjOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICBAbG9jYXRpb24oNCkgdlV2Qm9yZGVyOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICBAbG9jYXRpb24oNSkgdlV2U2xpY2U6IHZlYzI8ZjMyPixcbiAgICAgICAgICAgIEBsb2NhdGlvbig2KSB2VGV4dHVyZUlEOiBmMzIsXG4gICAgICAgICAgICBAYnVpbHRpbihmcm9udF9mYWNpbmcpIGZhY2U6IGJvb2wsXG4gICAgICAgICAgICBAYnVpbHRpbihwb3NpdGlvbikgZnJhZ0Nvb3JkIDogdmVjNDxmMzI+IFxuICAgICAgICApIC0+IEZyYWdtZW50T3V0cHV0IHtcblxuICAgICAgICAgICAgdmFyIHNjaXNzb3JBbHBoYSA9IDEuMDtcbiNpZiBTQ0lTU09SX0VOQUJMRVxuICAgICAgICAgICAgc2Npc3NvckFscGhhID0gaXNJbnNpZGVBbHBoYShcbiAgICAgICAgICAgICAgICB2TG9jYWxQb3MueHksXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxVbmlmb3JtLnNjaXNzb3JSZWN0LFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsVW5pZm9ybS5zY2lzc29yQ29ybmVyUmFkaXVzLFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsVW5pZm9ybS5zY2lzc29yRmFkZU91dFNpemUpO1xuXG4gICAgICAgICAgICBpZihzY2lzc29yQWxwaGEgPCBFUFNJTE9OKXtcbiAgICAgICAgICAgICAgICBkaXNjYXJkO1xuICAgICAgICAgICAgfVxuI2VuZGlmXG5cbiAgICAgICAgICAgIHV2U2xpY2UgPSB2VXZTbGljZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHV2OnZlYzI8ZjMyPiA9IHZVVjtcbiAgICAgICAgICAgIGlmKHV2U2xpY2UueCA+IDEuMCl7IHV2LnggPSBzbGljZUJvcmRlcih1di54LCB1dlNsaWNlLngsIHZVdkJvcmRlci54eik7fVxuICAgICAgICAgICAgaWYodXZTbGljZS55ID4gMS4wKXsgdXYueSA9IHNsaWNlQm9yZGVyKHV2LnksIHV2U2xpY2UueSwgdlV2Qm9yZGVyLnl3KTt9XG4gICAgICAgICAgICB1diA9IHV2ICogdlV2UmVjLnp3ICsgdlV2UmVjLnh5O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY29sb3IgPSB2ZWM0PGYzMj4oMC4wLDAuMCwwLjAsMS4wKTtcbiAgICAgICAgICAgIGxldCB0ZXhJZCA9IGkzMih2VGV4dHVyZUlEICsgMC41KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHRleFNpemUgPSB2ZWMyPGkzMj4oMCk7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSB2ZWMyPGkzMj4oMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRleElkID09IDApe1xuICAgICAgICAgICAgICAgICR7Z3Quc2FtcGxlVGV4dHVyZSgwKX1cbiAgICAgICAgICAgIH1lbHNlIGlmKHRleElkID09IDEpe1xuICAgICAgICAgICAgICAgICR7Z3Quc2FtcGxlVGV4dHVyZSgxKX1cbiAgICAgICAgICAgIH1lbHNlIGlmKHRleElkID09IDIpe1xuICAgICAgICAgICAgICAgICR7Z3Quc2FtcGxlVGV4dHVyZSgyKX1cbiAgICAgICAgICAgIH1lbHNlIGlmKHRleElkID09IDMpeyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR7Z3Quc2FtcGxlVGV4dHVyZSgzKX1cbiAgICAgICAgICAgIH1lbHNlIGlmKHRleElkID09IDQpeyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR7Z3Quc2FtcGxlVGV4dHVyZSg0KX1cbiAgICAgICAgICAgIH1lbHNlIGlmKHRleElkID09IDUpeyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR7Z3Quc2FtcGxlVGV4dHVyZSg1KX1cbiAgICAgICAgICAgIH1lbHNlIGlmKHRleElkID09IDYpeyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR7Z3Quc2FtcGxlVGV4dHVyZSg2KX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbG9yICo9IHZDb2xvcjQ7XG4gICAgICAgICAgICBjb2xvci5hICo9IHNjaXNzb3JBbHBoYTtcbiAgICAgICAgICAgIGlmKGNvbG9yLmEgPCBFUFNJTE9OKVxuICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgICBkaXNjYXJkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudE91dHB1dC5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50T3V0cHV0IDtcbiAgICAgICAgfWApLG8oTmksXCJHVUlfY29tbW9uX3ZzXCIsYFxuICAgICAgICAke1hhfVxuICAgICAgICAke1RzfVxuXG4gICAgICAgIHN0cnVjdCBWZXJ0ZXhTcHJpdGVCdWZmZXIge1xuICAgICAgICAgICAgdlV2UmVjOiB2ZWM0PGYzMj4sXG4gICAgICAgICAgICB2VXZCb3JkZXI6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAgIHZVdlNsaWNlOiB2ZWMyPGYzMj4sXG4gICAgICAgICAgICB2VGV4dHVyZUlEOiBmMzIsXG4gICAgICAgICAgICB2VmlzaWJsZTogZjMyXG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgc3RydWN0IE1hdGVyaWFsVW5pZm9ybXtcbiAgICAgICAgICAgIHNjaXNzb3JSZWN0OnZlYzQ8ZjMyPixcblxuICAgICAgICAgICAgc2NyZWVuU2l6ZTp2ZWMyPGYzMj4sXG4gICAgICAgICAgICBndWlTb2x1dGlvbjp2ZWMyPGYzMj4sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNjaXNzb3JDb3JuZXJSYWRpdXM6ZjMyLFxuICAgICAgICAgICAgc2Npc3NvckZhZGVPdXRTaXplOmYzMixcblxuICAgICAgICAgICAgbGltaXRWZXJ0ZXg6ZjMyLFxuICAgICAgICAgICAgcGl4ZWxSYXRpbzpmMzIsXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN0cnVjdCBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICAgICAgQGxvY2F0aW9uKDApIHZVVjogdmVjMjxmMzI+LFxuICAgICAgICAgICAgQGxvY2F0aW9uKDEpIHZDb2xvcjQ6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAgIEBsb2NhdGlvbigyKSB2TG9jYWxQb3M6IHZlYzI8ZjMyPixcbiAgICAgICAgICAgIEBsb2NhdGlvbigzKSB2VXZSZWM6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAgIEBsb2NhdGlvbig0KSB2VXZCb3JkZXI6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAgIEBsb2NhdGlvbig1KSB2VXZTbGljZTogdmVjMjxmMzI+LFxuICAgICAgICAgICAgQGxvY2F0aW9uKDYpIHZUZXh0dXJlSUQ6IGYzMixcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIG1lbWJlcjogdmVjNDxmMzI+XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAgc3RydWN0IFZlcnRleElucHV0e1xuICAgICAgICAgICAgQGJ1aWx0aW4oaW5zdGFuY2VfaW5kZXgpIGluZGV4IDogdTMyLFxuICAgICAgICAgICAgQGxvY2F0aW9uKDApIHV2OiB2ZWMyPGYzMj4sXG4gICAgICAgICAgICBAbG9jYXRpb24oMSkgdkluZGV4OiBmMzIsXG4gICAgICAgIH1cblxuICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMClcbiAgICAgICAgdmFyPHVuaWZvcm0+IG1hdGVyaWFsVW5pZm9ybSA6IE1hdGVyaWFsVW5pZm9ybTtcbiAgICAgICAgQGdyb3VwKDMpIEBiaW5kaW5nKDEpXG4gICAgICAgIHZhcjxzdG9yYWdlLCByZWFkPiB2UG9zaXRpb25CdWZmZXI6IGFycmF5PHZlYzQ8ZjMyPj47XG4gICAgICAgIEBncm91cCgzKSBAYmluZGluZygyKVxuICAgICAgICB2YXI8c3RvcmFnZSwgcmVhZD4gdlNwcml0ZUJ1ZmZlcjogYXJyYXk8VmVydGV4U3ByaXRlQnVmZmVyPjtcbiAgICAgICAgQGdyb3VwKDMpIEBiaW5kaW5nKDMpXG4gICAgICAgIHZhcjxzdG9yYWdlLCByZWFkPiB2Q29sb3JCdWZmZXI6IGFycmF5PHZlYzQ8ZjMyPj47XG5cbiAgICAgICAgdmFyPHByaXZhdGU+IHZlcnRleE91dDogVmVydGV4T3V0cHV0IDtcblxuICAgICAgICAvL3F1YWQ6IChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXG4gICAgICAgIC8vaW5kZXg6IDB+M1xuICAgICAgICBmbiBnZXRWZXJ0ZXhYWShxdWFkOnZlYzQ8ZjMyPiwgaW5kZXg6dTMyKSAtPiB2ZWMyPGYzMj5cbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJldCA9IHZlYzI8ZjMyPigwLjApO1xuICAgICAgICAgICAgaWYoaW5kZXggPT0gMCB8fCBpbmRleCA9PSAzKXtcbiAgICAgICAgICAgICAgICByZXQueCA9IHF1YWQueDtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJldC54ID0gcXVhZC56O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaW5kZXggPT0gMCB8fCBpbmRleCA9PSAxKXtcbiAgICAgICAgICAgICAgICByZXQueSA9IHF1YWQudztcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJldC55ID0gcXVhZC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIGApLG8oTmksXCJHVUlfc2hhZGVyX3ZpZXdcIixgXG4gICAgICAgICR7Z3QuR1VJX2NvbW1vbl92c31cblxuICAgICAgICBAdmVydGV4XG4gICAgICAgIGZuIFZlcnRNYWluKCB2ZXJ0ZXg6VmVydGV4SW5wdXQgKSAtPiBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICAgICAgdmFyIF9tID0gbW9kZWxzLm1hdHJpeFswXTtcbiAgICAgICAgICAgIHZhciBfbiA9IGdsb2JhbFVuaWZvcm0uZnJhbWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB2ZXJ0ZXhJbmRleCA9IHZlcnRleC52SW5kZXg7XG4gICAgICAgICAgICBsZXQgcXVhZEluZGV4ID0gdTMyKHZlcnRleC52SW5kZXggKiAwLjI1KTtcbiAgICAgICAgICAgIGxldCB2ZXJ0ZXhQb3NpdGlvbiA9IGdldFZlcnRleFhZKHZQb3NpdGlvbkJ1ZmZlcltxdWFkSW5kZXhdLCB1MzIodmVydGV4SW5kZXgpICUgNHUpO1xuICAgICAgICAgICAgdmFyIHZTcHJpdGVEYXRhID0gdlNwcml0ZUJ1ZmZlcltxdWFkSW5kZXhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgb3AgPSB2ZWMyPGYzMj4oMC4wMDAxKTtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkVmVydGV4ID0gdlNwcml0ZURhdGEudlZpc2libGUgPiAwLjUgJiYgdmVydGV4SW5kZXggPCBtYXRlcmlhbFVuaWZvcm0ubGltaXRWZXJ0ZXg7XG4gICAgICAgICAgICBpZihpc1ZhbGlkVmVydGV4KXtcbiAgICAgICAgICAgICAgICBvcCA9IDIuMCAqIHZlcnRleFBvc2l0aW9uICogbWF0ZXJpYWxVbmlmb3JtLnBpeGVsUmF0aW8gIC8gbWF0ZXJpYWxVbmlmb3JtLnNjcmVlblNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlcnRleE91dC52TG9jYWxQb3MgPSB2ZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIHZlcnRleE91dC5tZW1iZXIgPSB2ZWM0PGYzMj4ob3AueCwgb3AueSwgdmVydGV4SW5kZXggKiAwLjAwMDEsIDEuMCk7XG5cbiAgICAgICAgICAgIHZlcnRleE91dC52VVYgPSB2ZWMyPGYzMj4odmVydGV4LnV2KTtcbiAgICAgICAgICAgIHZlcnRleE91dC52VXZSZWMgPSB2U3ByaXRlRGF0YS52VXZSZWM7XG4gICAgICAgICAgICB2ZXJ0ZXhPdXQudlV2Qm9yZGVyID0gdlNwcml0ZURhdGEudlV2Qm9yZGVyO1xuICAgICAgICAgICAgdmVydGV4T3V0LnZVdlNsaWNlID0gdlNwcml0ZURhdGEudlV2U2xpY2U7XG4gICAgICAgICAgICB2ZXJ0ZXhPdXQudlRleHR1cmVJRCA9IHZTcHJpdGVEYXRhLnZUZXh0dXJlSUQ7XG4gICAgICAgICAgICB2ZXJ0ZXhPdXQudkNvbG9yNCA9IHZDb2xvckJ1ZmZlcltxdWFkSW5kZXhdO1xuXG4gICAgICAgICAgICByZXR1cm4gdmVydGV4T3V0O1xuICAgICAgICAgfVxuICAgICAgICAgXG4gICAgICAgICAke2d0LmZzfVxuICAgICAgICBgKSxvKE5pLFwiR1VJX3NoYWRlcl93b3JsZFwiLGBcbiAgICAgICAgJHtndC5HVUlfY29tbW9uX3ZzfVxuICAgICAgICBAdmVydGV4XG4gICAgICAgIGZuIFZlcnRNYWluKCB2ZXJ0ZXg6VmVydGV4SW5wdXQgKSAtPiBWZXJ0ZXhPdXRwdXQge1xuICAgICAgICAgICAgdmFyIG1vZGVsTWF0cml4ID0gbW9kZWxzLm1hdHJpeFt2ZXJ0ZXguaW5kZXhdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgdmVydGV4SW5kZXggPSB2ZXJ0ZXgudkluZGV4O1xuICAgICAgICAgICAgbGV0IHF1YWRJbmRleCA9IHUzMih2ZXJ0ZXgudkluZGV4ICogMC4yNSk7XG4gICAgICAgICAgICBsZXQgdmVydGV4UG9zaXRpb24gPSBnZXRWZXJ0ZXhYWSh2UG9zaXRpb25CdWZmZXJbcXVhZEluZGV4XSwgdTMyKHZlcnRleEluZGV4KSAlIDR1KTtcbiAgICAgICAgICAgIHZhciBsb2NhbFBvcyA9IHZlYzQ8ZjMyPih2ZXJ0ZXhQb3NpdGlvbi54eSwgdmVydGV4SW5kZXggKiAwLjAwMDEsIDEuMCkgO1xuICAgICAgICAgICAgdmFyIG9wID0gdmVjNDxmMzI+KDAuMDAwMSk7XG4gICAgICAgICAgICB2YXIgdlNwcml0ZURhdGEgPSB2U3ByaXRlQnVmZmVyW3F1YWRJbmRleF07XG5cbiAgICAgICAgICAgIGxldCBpc1ZhbGlkVmVydGV4ID0gdlNwcml0ZURhdGEudlZpc2libGUgPiAwLjUgJiYgdmVydGV4SW5kZXggPCBtYXRlcmlhbFVuaWZvcm0ubGltaXRWZXJ0ZXg7XG4gICAgICAgICAgICBpZihpc1ZhbGlkVmVydGV4KXtcbiAgICAgICAgICAgICAgICBvcCA9IGdsb2JhbFVuaWZvcm0ucHJvak1hdCAqIGdsb2JhbFVuaWZvcm0udmlld01hdCAqIG1vZGVsTWF0cml4ICogbG9jYWxQb3MgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZXJ0ZXhPdXQudkxvY2FsUG9zID0gdmVydGV4UG9zaXRpb247XG4gICAgICAgICAgICB2ZXJ0ZXhPdXQubWVtYmVyID0gb3A7XG5cbiAgICAgICAgICAgIHZlcnRleE91dC52VVYgPSB2ZWMyPGYzMj4odmVydGV4LnV2KTtcbiAgICAgICAgICAgIHZlcnRleE91dC52VXZSZWMgPSB2U3ByaXRlRGF0YS52VXZSZWM7XG4gICAgICAgICAgICB2ZXJ0ZXhPdXQudlV2Qm9yZGVyID0gdlNwcml0ZURhdGEudlV2Qm9yZGVyO1xuICAgICAgICAgICAgdmVydGV4T3V0LnZVdlNsaWNlID0gdlNwcml0ZURhdGEudlV2U2xpY2U7XG4gICAgICAgICAgICB2ZXJ0ZXhPdXQudlRleHR1cmVJRCA9IHZTcHJpdGVEYXRhLnZUZXh0dXJlSUQ7XG4gICAgICAgICAgICB2ZXJ0ZXhPdXQudkNvbG9yNCA9IHZDb2xvckJ1ZmZlcltxdWFkSW5kZXhdO1xuXG4gICAgICAgICAgICByZXR1cm4gdmVydGV4T3V0O1xuICAgICAgICAgfVxuICAgICAgICAgXG4gICAgICAgICAke2d0LmZzfVxuXG4gICAgICAgIGApO2NsYXNzIEdjIGV4dGVuZHMgX2l7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSxvKHRoaXMsXCJfc2Npc3NvclJlY3RcIiksbyh0aGlzLFwiX3NjcmVlblNpemVcIixuZXcgWigxMDI0LDc2OCkpLG8odGhpcyxcIl9zY2lzc29yRW5hYmxlXCIsITEpLG8odGhpcyxcIl92aWRlb1RleHR1cmVGbGFnc1wiLHt9KSxOLnJlZ2lzdGVyKFwiR1VJX3NoYWRlcl92aWV3XCIsTmkuR1VJX3NoYWRlcl92aWV3KSxOLnJlZ2lzdGVyKFwiR1VJX3NoYWRlcl93b3JsZFwiLE5pLkdVSV9zaGFkZXJfd29ybGQpO2xldCB0PWU9PU50LlZpZXc/XCJHVUlfc2hhZGVyX3ZpZXdcIjpcIkdVSV9zaGFkZXJfd29ybGRcIixyPW5ldyBXZSh0LHQpO3Iuc2V0U2hhZGVyRW50cnkoXCJWZXJ0TWFpblwiLFwiRnJhZ01haW5cIiksci5zZXRVbmlmb3JtVmVjdG9yMihcInNjcmVlblNpemVcIix0aGlzLl9zY3JlZW5TaXplKSxyLnNldFVuaWZvcm1WZWN0b3IyKFwiZ3VpU29sdXRpb25cIix0aGlzLl9zY3JlZW5TaXplKSxyLnNldFVuaWZvcm1WZWN0b3I0KFwic2Npc3NvclJlY3RcIixuZXcgaiksci5zZXRVbmlmb3JtRmxvYXQoXCJzY2lzc29yQ29ybmVyUmFkaXVzXCIsMCksci5zZXRVbmlmb3JtRmxvYXQoXCJzY2lzc29yRmFkZU91dFNpemVcIiwwKSxyLnNldFVuaWZvcm1GbG9hdChcImxpbWl0VmVydGV4XCIsMCksci5zZXRVbmlmb3JtRmxvYXQoXCJwaXhlbFJhdGlvXCIsMSk7bGV0IHM9ci5zaGFkZXJTdGF0ZTtzLmRlcHRoV3JpdGVFbmFibGVkPSExLHIuYmxlbmRNb2RlPXhlLkFMUEhBLHIuZGVwdGhDb21wYXJlPWU9PU50LlZpZXc/dnQuYWx3YXlzOnZ0Lmxlc3NfZXF1YWwsci5jdWxsTW9kZT11aS5iYWNrLHRoaXMuZGVmYXVsdFBhc3M9cn1zZXRMaW1pdFZlcnRleChlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcImxpbWl0VmVydGV4XCIsZSl9c2V0R1VJU29sdXRpb24oZSx0KXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1WZWN0b3IyKFwiZ3VpU29sdXRpb25cIixlKSx0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcInBpeGVsUmF0aW9cIix0KX1zZXRTY2lzc29yUmVjdChlLHQscixzKXt0aGlzLl9zY2lzc29yUmVjdHx8KHRoaXMuX3NjaXNzb3JSZWN0PW5ldyBqKSx0aGlzLl9zY2lzc29yUmVjdC5zZXQoZSx0LHIscyksdGhpcy5kZWZhdWx0UGFzcy5zZXRVbmlmb3JtVmVjdG9yNChcInNjaXNzb3JSZWN0XCIsdGhpcy5fc2Npc3NvclJlY3QpfXNldFNjaXNzb3JFbmFibGUoZSl7dGhpcy5fc2Npc3NvckVuYWJsZSE9ZSYmKHRoaXMuX3NjaXNzb3JFbmFibGU9ZSxlP3RoaXMuZGVmYXVsdFBhc3Muc2V0RGVmaW5lKFwiU0NJU1NPUl9FTkFCTEVcIiwhMCk6dGhpcy5kZWZhdWx0UGFzcy5kZWxldGVEZWZpbmUoXCJTQ0lTU09SX0VOQUJMRVwiKSx0aGlzLmRlZmF1bHRQYXNzLm5vdGljZVZhbHVlQ2hhbmdlKCkpfXNldFNjaXNzb3JDb3JuZXIoZSx0KXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcInNjaXNzb3JDb3JuZXJSYWRpdXNcIixlKSx0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1GbG9hdChcInNjaXNzb3JGYWRlT3V0U2l6ZVwiLHQpfXNldFNjcmVlblNpemUoZSx0KXtyZXR1cm4gdGhpcy5fc2NyZWVuU2l6ZS5zZXQoZSx0KSx0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1WZWN0b3IyKFwic2NyZWVuU2l6ZVwiLHRoaXMuX3NjcmVlblNpemUpLHRoaXN9c2V0VGV4dHVyZXMoZSl7Zm9yKGxldCB0PTA7dDw3O3QrKyl7bGV0IHI9ZVt0XXx8QS5yZXMud2hpdGVUZXh0dXJlO3RoaXMuZGVmYXVsdFBhc3Muc2V0VGV4dHVyZShgdGV4XyR7dH1gLHIpLHRoaXMuc2V0VmlkZW9UZXh0dXJlRGVmaW5lKHQsci5pc1ZpZGVvVGV4dHVyZSl9fXNldFZpZGVvVGV4dHVyZURlZmluZShlLHQpe2xldCByPSExO3QhPXRoaXMuX3ZpZGVvVGV4dHVyZUZsYWdzW2VdJiYodD90aGlzLmRlZmF1bHRQYXNzLnNldERlZmluZShgVmlkZW9UZXh0dXJlJHtlfWAsITApOnRoaXMuZGVmYXVsdFBhc3MuZGVsZXRlRGVmaW5lKGBWaWRlb1RleHR1cmUke2V9YCksdGhpcy5fdmlkZW9UZXh0dXJlRmxhZ3NbZV09dCxyPSEwKSxyJiZ0aGlzLmRlZmF1bHRQYXNzLm5vdGljZVZhbHVlQ2hhbmdlKCl9c2V0IGVudk1hcChlKXt9c2V0IHNoYWRvd01hcChlKXt9c2V0IGJhc2VNYXAoZSl7fXNldCBub3JtYWxNYXAoZSl7fXNldCBlbWlzc2l2ZU1hcChlKXt9c2V0IGlycmFkaWFuY2VNYXAoZSl7fXNldCBpcnJhZGlhbmNlRGVwdGhNYXAoZSl7fX1jbGFzcyBRYyBleHRlbmRzIGNle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxvKHRoaXMsXCJfZ3VpR2VvbWV0cnlcIil9aW5pdChlKXtzdXBlci5pbml0KCksdGhpcy5hZGRSZW5kZXJlck1hc2soVWUuVUkpLHRoaXMucmVtb3ZlUmVuZGVyZXJNYXNrKFVlLkRlZmF1bHQpLHRoaXMuY2FzdEdJPSExLHRoaXMuY2FzdFNoYWRvdz0hMSx0aGlzLmFsd2F5c1JlbmRlcj0hMCx0aGlzLl9pZ25vcmVFbnZNYXA9dGhpcy5faWdub3JlUHJlZmlsdGVyTWFwPSEwfWdldCBnZW9tZXRyeSgpe3JldHVybiBzdXBlci5nZW9tZXRyeX1zZXQgZ2VvbWV0cnkoZSl7c3VwZXIuZ2VvbWV0cnk9ZSx0aGlzLl9ndWlHZW9tZXRyeT1lfW5vZGVVcGRhdGUoZSx0LHIscyl7Zm9yKGxldCBhPTA7YTx0aGlzLm1hdGVyaWFscy5sZW5ndGg7YSsrKXtsZXQgbD10aGlzLm1hdGVyaWFsc1thXS5nZXRQYXNzKHQpLGg9dGhpcy5fZ3VpR2VvbWV0cnkudlBvc2l0aW9uQnVmZmVyLHU9dGhpcy5fZ3VpR2VvbWV0cnkudlNwcml0ZUJ1ZmZlcixjPXRoaXMuX2d1aUdlb21ldHJ5LnZDb2xvckJ1ZmZlcjtpZihsKWZvcihsZXQgZj0wO2Y8bC5sZW5ndGg7ZisrKXtjb25zdCBkPWxbZl07ZC5waXBlbGluZXx8KGQuc2V0U3RvcmFnZUJ1ZmZlcihcInZQb3NpdGlvbkJ1ZmZlclwiLGgpLGQuc2V0U3RvcmFnZUJ1ZmZlcihcInZTcHJpdGVCdWZmZXJcIix1KSxkLnNldFN0b3JhZ2VCdWZmZXIoXCJ2Q29sb3JCdWZmZXJcIixjKSl9fXN1cGVyLm5vZGVVcGRhdGUoZSx0LHIscyl9b25VcGRhdGUoZSl7fX1jbGFzcyBWY3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcIl91c2VcIiksbyh0aGlzLFwiX3VuVXNlXCIpLHRoaXMuX3VzZT1bXSx0aGlzLl91blVzZT1bXX1wdXNoQmFjayhlKXtsZXQgdD10aGlzLl91c2UuaW5kZXhPZihlKTt0IT0tMSYmKHRoaXMuX3VzZS5zcGxpY2UodCwxKSx0aGlzLl91blVzZS5wdXNoKGUpKX1nZXRVc2VMaXN0KCl7cmV0dXJuIHRoaXMuX3VzZX1nZXRPbmUoZSx0KXtsZXQgcjtyZXR1cm4gdGhpcy5fdW5Vc2UubGVuZ3RoPjA/KHI9dGhpcy5fdW5Vc2VbMF0sdGhpcy5fdW5Vc2Uuc3BsaWNlKDAsMSksdGhpcy5fdXNlLnB1c2gocikscik6KHI9bmV3IGUodCksdGhpcy5fdXNlLnB1c2gocikscil9aGFzRnJlZSgpe3JldHVybiB0aGlzLl91blVzZS5sZW5ndGg+MH19bGV0IHhyO2NvbnN0IG9hPWNsYXNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwieFwiLDApLG8odGhpcyxcInlcIiwwKSxvKHRoaXMsXCJ6XCIsMCksbyh0aGlzLFwid2lkdGhcIiwxKSxvKHRoaXMsXCJoZWlnaHRcIiwxKSxvKHRoaXMsXCJfZ2xvYmFsWFwiLDApLG8odGhpcyxcIl9nbG9iYWxZXCIsMCksbyh0aGlzLFwiX2dsb2JhbFdpZHRoXCIsMCksbyh0aGlzLFwiX2dsb2JhbEhlaWdodFwiLDApLG8odGhpcyxcIl92aXNpYmxlXCIsITApLG8odGhpcyxcIl9vZmZzZXRYXCIsMCksbyh0aGlzLFwiX29mZnNldFlcIiwwKSxvKHRoaXMsXCJfc3ByaXRlXCIsQS5yZXMuZGVmYXVsdEdVSVNwcml0ZSksbyh0aGlzLFwiX2NvbG9yXCIsbmV3IHooMSwxLDEsMSkpLG8odGhpcyxcIl9pbWFnZVR5cGVcIixwci5TaW1wbGUpLG8odGhpcyxcImRpcnR5QXR0cmlidXRlc1wiLFBlLk1BWCksbyh0aGlzLFwiY2FjaGVUZXh0dXJlSWRcIiwtMSl9c3RhdGljIGdldCBxdWFkUG9vbCgpe3JldHVybiB0aGlzLnRleHRQb29sfHwodGhpcy50ZXh0UG9vbD1uZXcgVmMpLHRoaXMudGV4dFBvb2x9c3RhdGljIHJlY3ljbGVRdWFkKGkpe2kuc3ByaXRlPW51bGwsaS5kaXJ0eUF0dHJpYnV0ZXM9UGUuTUFYLGkueD0wLGkueT0wLGkuej0tMSxpLmNhY2hlVGV4dHVyZUlkPS0xLG9hLnF1YWRQb29sLnB1c2hCYWNrKGkpfXN0YXRpYyBzcGF3blF1YWQoKXtyZXR1cm4gb2EucXVhZFBvb2wuZ2V0T25lKG9hKX1nZXQgaW1hZ2VUeXBlKCl7cmV0dXJuIHRoaXMuX2ltYWdlVHlwZX1zZXQgaW1hZ2VUeXBlKGkpe3RoaXMuX2ltYWdlVHlwZT1pLHRoaXMuc2V0QXR0ckNoYW5nZShQZS5TUFJJVEV8UGUuUE9TSVRJT04pfWdldCBjb2xvcigpe3JldHVybiB0aGlzLl9jb2xvcn1zZXQgY29sb3IoaSl7dGhpcy5fY29sb3IuY29weUZyb20oaSksdGhpcy5zZXRBdHRyQ2hhbmdlKFBlLkNPTE9SKX1nZXQgdmlzaWJsZSgpe3JldHVybiB0aGlzLl92aXNpYmxlfXNldCB2aXNpYmxlKGkpe2khPXRoaXMuX3Zpc2libGUmJih0aGlzLl92aXNpYmxlPWksdGhpcy5zZXRBdHRyQ2hhbmdlKFBlLlNQUklURSkpfWdldCBzcHJpdGUoKXtyZXR1cm4gdGhpcy5fc3ByaXRlfXNldCBzcHJpdGUoaSl7dGhpcy5fc3ByaXRlIT1pJiYodGhpcy5fc3ByaXRlPWksdGhpcy5zZXRBdHRyQ2hhbmdlKFBlLlNQUklURXxQZS5QT1NJVElPTikpfWdldCBsZWZ0KCl7cmV0dXJuIHRoaXMuX2dsb2JhbFgtdGhpcy5fb2Zmc2V0WH1nZXQgcmlnaHQoKXtyZXR1cm4gdGhpcy5sZWZ0K3RoaXMuX2dsb2JhbFdpZHRofWdldCB0b3AoKXtyZXR1cm4gdGhpcy5fZ2xvYmFsWS10aGlzLl9vZmZzZXRZfWdldCBib3R0b20oKXtyZXR1cm4gdGhpcy50b3ArdGhpcy5fZ2xvYmFsSGVpZ2h0fXNldFNpemUoaSxlKXt0aGlzLndpZHRoPWksdGhpcy5oZWlnaHQ9ZSx0aGlzLnNldEF0dHJDaGFuZ2UoUGUuUE9TSVRJT04pfXNldFhZKGksZSl7dGhpcy54PWksdGhpcy55PWUsdGhpcy5zZXRBdHRyQ2hhbmdlKFBlLlBPU0lUSU9OKX1zZXRBdHRyQ2hhbmdlKGkpe3RoaXMuZGlydHlBdHRyaWJ1dGVzPXRoaXMuZGlydHlBdHRyaWJ1dGVzfGl9YXBwbHlUcmFuc2Zvcm0oaSl7dGhpcy5zZXRBdHRyQ2hhbmdlKFBlLlBPU0lUSU9OKTtsZXQgZT10aGlzLl9zcHJpdGUsdD1pLmdldFdvcmxkTWF0cml4KCk7KHRoaXMueCE9MHx8dGhpcy55IT0wKSYmKHQ9dGhpcy5nZXRRdWFkTWF0cml4KHQpKTtsZXQgcj10LmdldFNjYWxlWCgpLHM9dC5nZXRTY2FsZVkoKSxhPWUuaXNTbGljZWQmJnRoaXMuX2ltYWdlVHlwZT09cHIuU2xpY2VkO2lmKHRoaXMuX29mZnNldFg9aS53aWR0aCouNSpyLHRoaXMuX29mZnNldFk9aS5oZWlnaHQqLjUqcyxhKXRoaXMuX2dsb2JhbFdpZHRoPXIqKGkud2lkdGgtKGUub2Zmc2V0U2l6ZS56LWUudHJpbVNpemUueCkpLHRoaXMuX2dsb2JhbEhlaWdodD1zKihpLmhlaWdodC0oZS5vZmZzZXRTaXplLnctZS50cmltU2l6ZS55KSksdGhpcy5fZ2xvYmFsWD10LnR4K2Uub2Zmc2V0U2l6ZS54KnIsdGhpcy5fZ2xvYmFsWT10LnR5K2Uub2Zmc2V0U2l6ZS55KnM7ZWxzZXtsZXQgbj10aGlzLndpZHRoL2Uub2Zmc2V0U2l6ZS56LGw9dGhpcy5oZWlnaHQvZS5vZmZzZXRTaXplLnc7dGhpcy5fZ2xvYmFsV2lkdGg9ciplLnRyaW1TaXplLngqbix0aGlzLl9nbG9iYWxIZWlnaHQ9cyplLnRyaW1TaXplLnkqbCx0aGlzLl9nbG9iYWxYPXQudHgrZS5vZmZzZXRTaXplLngqbipyLHRoaXMuX2dsb2JhbFk9dC50eStlLm9mZnNldFNpemUueSpsKnN9cmV0dXJuIHRoaXN9Z2V0UXVhZE1hdHJpeChpKXtyZXR1cm4geHJ8fCh4cj1uZXcgUWkpLHhyLmlkZW50aXR5KCkseHIuc2V0VHJhbnNsYXRlKHRoaXMueCx0aGlzLnkpLHhyLm11bChpKSx4cn13cml0ZVRvR2VvbWV0cnkoaSxlKXtyZXR1cm4gaS5maWxsUXVhZCh0aGlzLGUpLHRoaXMuZGlydHlBdHRyaWJ1dGVzPVBlLk5PTkUsdGhpc319O2xldCBGaT1vYTtvKEZpLFwidGV4dFBvb2xcIik7Y2xhc3MgbG4gZXh0ZW5kcyBFZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwiX3VpVHJhbnNmb3JtXCIpLG8odGhpcyxcIl92aXNpYmxlXCIsITApfWRlc3Ryb3koKXt0aGlzLl91aVRyYW5zZm9ybS5zZXROZWVkVXBkYXRlVUlQYW5lbCgpLHN1cGVyLmRlc3Ryb3koKX1nZXQgdWlUcmFuc2Zvcm0oKXtyZXR1cm4gdGhpcy5fdWlUcmFuc2Zvcm19Z2V0IHZpc2libGUoKXtyZXR1cm4gdGhpcy5fdmlzaWJsZX1zZXQgdmlzaWJsZShlKXt2YXIgdDt0aGlzLl92aXNpYmxlIT1lJiYodGhpcy5fdmlzaWJsZT1lLCh0PXRoaXMub25VSUNvbXBvbmVudFZpc2libGUpPT1udWxsfHx0LmNhbGwodGhpcyx0aGlzLl92aXNpYmxlKSl9aW5pdChlKXt2YXIgdDsodD1zdXBlci5pbml0KT09bnVsbHx8dC5jYWxsKHRoaXMsZSksdGhpcy5fdWlUcmFuc2Zvcm09dGhpcy5vYmplY3QzRC5nZXRPckFkZENvbXBvbmVudChsaSksdGhpcy5fdWlUcmFuc2Zvcm0uc2V0TmVlZFVwZGF0ZVVJUGFuZWwoKX1jb3B5Q29tcG9uZW50KGUpe3JldHVybiB0aGlzLnZpc2libGU9ZS52aXNpYmxlLHRoaXN9fWNsYXNzIGNzIGV4dGVuZHMgbG57Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcIl9tYWluUXVhZHNcIiksbyh0aGlzLFwiX3NoYWRvd1JlbmRlclwiKSxvKHRoaXMsXCJfc2hhZG93U291cmNlXCIpLG8odGhpcyxcImlzVUlTaGFkb3dcIiksbyh0aGlzLFwiaXNTaGFkb3dsZXNzXCIpLG8odGhpcyxcIm5lZWRVcGRhdGVTaGFkb3dcIil9aW5pdChlKXt2YXIgdDsodD1zdXBlci5pbml0KT09bnVsbHx8dC5jYWxsKHRoaXMsZSksdGhpcy5fbWFpblF1YWRzPVtdfWRlc3Ryb3koKXt2YXIgZSx0O3RoaXMuZGV0YWNoUXVhZHMoKSwoZT10aGlzLl9zaGFkb3dSZW5kZXIpPT1udWxsfHxlLnNldFNoYWRvd1NvdXJjZShudWxsKSwodD10aGlzLl9zaGFkb3dTb3VyY2UpPT1udWxsfHx0LnNldFNoYWRvd1JlbmRlcmVyKG51bGwpLHN1cGVyLmRlc3Ryb3koKSx0aGlzLl9zaGFkb3dSZW5kZXI9bnVsbCx0aGlzLl9zaGFkb3dTb3VyY2U9bnVsbH1zdGFydCgpe3ZhciBlOyhlPXN1cGVyLnN0YXJ0KT09bnVsbHx8ZS5jYWxsKHRoaXMpLHRoaXMuaXNVSVNoYWRvdz90aGlzLmF1dG9CaW5kU2hhZG93KG51bGwsdGhpcyk6dGhpcy5pc1NoYWRvd2xlc3N8fHRoaXMuYXV0b0JpbmRTaGFkb3codGhpcyxudWxsKSx0aGlzLnNldFNoYWRvd0RpcnR5KCl9c2V0U2hhZG93RGlydHkoKXt0aGlzLl9zaGFkb3dSZW5kZXImJih0aGlzLl9zaGFkb3dSZW5kZXIubmVlZFVwZGF0ZVNoYWRvdz0hMCl9Z2V0IG1haW5RdWFkcygpe3JldHVybiB0aGlzLl9tYWluUXVhZHN9c2V0U2hhZG93UmVuZGVyZXIoZSl7dGhpcy5fc2hhZG93UmVuZGVyPWV9c2V0U2hhZG93U291cmNlKGUpe3RoaXMuX3NoYWRvd1NvdXJjZT1lfWdldFNoYWRvd1JlbmRlcigpe3JldHVybiB0aGlzLl9zaGFkb3dSZW5kZXJ9YXV0b0JpbmRTaGFkb3coZSx0KXtsZXQgcj10aGlzLm9iamVjdDNELmNvbXBvbmVudHMudmFsdWVzKCk7aWYoIWUpZm9yKGxldCBzIG9mIHIpe2xldCBhPXM7aWYoIShhLmlzU2hhZG93bGVzc3x8YS5pc1VJU2hhZG93KSYmYS5tYWluUXVhZHMpe2U9YTticmVha319aWYoIXQpZm9yKGxldCBzIG9mIHIpe2xldCBhPXM7aWYoYS5pc1VJU2hhZG93JiZhLm1haW5RdWFkcyl7dD1hO2JyZWFrfX1yZXR1cm4gZSYmdD8oZS5zZXRTaGFkb3dSZW5kZXJlcih0KSx0LnNldFNoYWRvd1NvdXJjZShlKSwhMCk6ITF9cmVjeWNsZVF1YWQoZSl7aWYoZSYmdGhpcy5fbWFpblF1YWRzKXtsZXQgdD10aGlzLl9tYWluUXVhZHMuaW5kZXhPZihlKTt0Pj0wPyh0aGlzLl9tYWluUXVhZHMuc3BsaWNlKHQsMSksRmkucmVjeWNsZVF1YWQoZSkpOmU9bnVsbH1yZXR1cm4gZX1hdHRhY2hRdWFkKGUpe3JldHVybiB0aGlzLl9tYWluUXVhZHMmJnRoaXMuX21haW5RdWFkcy5wdXNoKGUpLHRoaXN9ZGV0YWNoUXVhZHMoKXtpZih0aGlzLl9tYWluUXVhZHMpZm9yKDt0aGlzLl9tYWluUXVhZHMubGVuZ3RoPjA7KXtsZXQgZT10aGlzLl9tYWluUXVhZHMuc2hpZnQoKTt0aGlzLnJlY3ljbGVRdWFkKGUpfXJldHVybiB0aGlzfWNvcHlDb21wb25lbnQoZSl7cmV0dXJuIHN1cGVyLmNvcHlDb21wb25lbnQoZSksdGhpcy5pc1VJU2hhZG93PWUuaXNVSVNoYWRvdyx0aGlzLmlzU2hhZG93bGVzcz1lLmlzU2hhZG93bGVzcyx0aGlzfX1jbGFzcyBWaSBleHRlbmRzIGNze2luaXQoZSl7dmFyIHQ7KHQ9c3VwZXIuaW5pdCk9PW51bGx8fHQuY2FsbCh0aGlzLGUpLHRoaXMuYXR0YWNoUXVhZChGaS5zcGF3blF1YWQoKSksdGhpcy5zcHJpdGU9QS5yZXMuZGVmYXVsdEdVSVNwcml0ZX1jbG9uZVRvKGUpe2UuZ2V0T3JBZGRDb21wb25lbnQoVmkpLmNvcHlDb21wb25lbnQodGhpcyl9Y29weUNvbXBvbmVudChlKXtyZXR1cm4gc3VwZXIuY29weUNvbXBvbmVudChlKSx0aGlzLnNwcml0ZT1lLnNwcml0ZSx0aGlzLmNvbG9yPWUuY29sb3IsdGhpcy5pbWFnZVR5cGU9ZS5pbWFnZVR5cGUsdGhpc31zZXQgc3ByaXRlKGUpe2V8fChlPUEucmVzLmRlZmF1bHRHVUlTcHJpdGUpO2ZvcihsZXQgdCBvZiB0aGlzLl9tYWluUXVhZHMpdC5zcHJpdGU9ZSx0LnNldFNpemUodGhpcy5fdWlUcmFuc2Zvcm0ud2lkdGgsdGhpcy5fdWlUcmFuc2Zvcm0uaGVpZ2h0KTt0aGlzLnNldFNoYWRvd0RpcnR5KCl9b25UcmFuc2Zvcm1SZXNpemUoKXt0aGlzLmFwcGx5VHJhbnNmb3JtU2l6ZSgpfWFwcGx5VHJhbnNmb3JtU2l6ZSgpe2ZvcihsZXQgZSBvZiB0aGlzLl9tYWluUXVhZHMpZS5zZXRTaXplKHRoaXMuX3VpVHJhbnNmb3JtLndpZHRoLHRoaXMuX3VpVHJhbnNmb3JtLmhlaWdodCk7dGhpcy5zZXRTaGFkb3dEaXJ0eSgpfWdldCBzcHJpdGUoKXtyZXR1cm4gdGhpcy5fbWFpblF1YWRzWzBdLnNwcml0ZX1vblVJQ29tcG9uZW50VmlzaWJsZShlKXt0aGlzLmFwcGx5Q29tcG9uZW50VmlzaWJsZSgpfW9uVUlUcmFuc2Zvcm1WaXNpYmxlKGUpe3RoaXMuYXBwbHlDb21wb25lbnRWaXNpYmxlKCl9YXBwbHlDb21wb25lbnRWaXNpYmxlKCl7bGV0IGU9IXRoaXMuX3Zpc2libGV8fCF0aGlzLl91aVRyYW5zZm9ybS5nbG9iYWxWaXNpYmxlO2ZvcihsZXQgdCBvZiB0aGlzLl9tYWluUXVhZHMpdC52aXNpYmxlPSFlO3RoaXMuc2V0U2hhZG93RGlydHkoKX1nZXQgY29sb3IoKXtyZXR1cm4gdGhpcy5fbWFpblF1YWRzWzBdLmNvbG9yfXNldCBjb2xvcihlKXtmb3IobGV0IHQgb2YgdGhpcy5fbWFpblF1YWRzKXQuY29sb3I9ZTt0aGlzLnNldFNoYWRvd0RpcnR5KCl9Z2V0IGltYWdlVHlwZSgpe3JldHVybiB0aGlzLl9tYWluUXVhZHNbMF0uaW1hZ2VUeXBlfXNldCBpbWFnZVR5cGUoZSl7Zm9yKGxldCB0IG9mIHRoaXMuX21haW5RdWFkcyl0LmltYWdlVHlwZT1lO3RoaXMuc2V0U2hhZG93RGlydHkoKX19Y2xhc3Mgd3MgZXh0ZW5kcyBWaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwic3BhY2VcIixOdC5Xb3JsZCksbyh0aGlzLFwibmVlZFVwZGF0ZUdlb21ldHJ5XCIsITApLG8odGhpcyxcInBhbmVsT3JkZXJcIiwwKSxvKHRoaXMsXCJuZWVkU29ydE9uQ2FtZXJhWlwiKSxvKHRoaXMsXCJfYmlsbGJvYXJkXCIpLG8odGhpcyxcIl9yZWJ1aWxkXCIpLG8odGhpcyxcInNjaXNzb3JFbmFibGVcIiwhMSksbyh0aGlzLFwic2Npc3NvckNvcm5lclJhZGl1c1wiLDApLG8odGhpcyxcInNjaXNzb3JGYWRlT3V0U2l6ZVwiLDApLG8odGhpcyxcIl91aVJlbmRlcmVyXCIpLG8odGhpcyxcIl91aU1hdGVyaWFsXCIpLG8odGhpcyxcIl9nZW9tZXRyeVwiKSxvKHRoaXMsXCJfbGltaXRWZXJ0ZXhDb3VudFwiLDApLG8odGhpcyxcIl9tYXhDb3VudFwiLDEyOCksbyh0aGlzLFwiaXNVSVBhbmVsXCIsITApLG8odGhpcyxcIl9jb2xsZWN0VHJhbnNmb3JtXCIsW10pfWNsb25lVG8oZSl7ZS5nZXRPckFkZENvbXBvbmVudCh3cykuY29weUNvbXBvbmVudCh0aGlzKX1jb3B5Q29tcG9uZW50KGUpe3JldHVybiBzdXBlci5jb3B5Q29tcG9uZW50KGUpLHRoaXMucGFuZWxPcmRlcj1lLnBhbmVsT3JkZXIsdGhpcy5uZWVkU29ydE9uQ2FtZXJhWj1lLm5lZWRTb3J0T25DYW1lcmFaLHRoaXMuY3VsbE1vZGU9ZS5jdWxsTW9kZSx0aGlzLmJpbGxib2FyZD1lLmJpbGxib2FyZCx0aGlzLnNjaXNzb3JFbmFibGU9ZS5zY2lzc29yRW5hYmxlLHRoaXMuc2Npc3NvckNvcm5lclJhZGl1cz1lLnNjaXNzb3JDb3JuZXJSYWRpdXMsdGhpcy5zY2lzc29yRmFkZU91dFNpemU9ZS5zY2lzc29yRmFkZU91dFNpemUsdGhpc31pbml0KGUpe3N1cGVyLmluaXQoZSksdGhpcy5jcmVhdGUodGhpcy5zcGFjZSksdGhpcy52aXNpYmxlPSExfWNyZWF0ZShlKXt0aGlzLl9tYXhDb3VudD10aGlzLnNwYWNlPT1OdC5Xb3JsZD95ZS5xdWFkTWF4Q291bnRGb3JXb3JsZDp5ZS5xdWFkTWF4Q291bnRGb3JWaWV3LHRoaXMuX3VpUmVuZGVyZXI9dGhpcy5vYmplY3QzRC5hZGRDb21wb25lbnQoUWMpLHRoaXMuX2dlb21ldHJ5PXRoaXMuX3VpUmVuZGVyZXIuZ2VvbWV0cnk9bmV3IEZjKHRoaXMuX21heENvdW50KS5jcmVhdGUoKSx0aGlzLl91aU1hdGVyaWFsPXRoaXMuX3VpUmVuZGVyZXIubWF0ZXJpYWw9bmV3IEdjKGUpLHRoaXMuX3VpUmVuZGVyZXIucmVuZGVyT3JkZXI9eWUuU29ydE9yZGVyU3RhcnRXb3JsZCx0aGlzLl9yZWJ1aWxkPW5ldyB6Yyx0aGlzLm9iamVjdDNELmJvdW5kPW5ldyBCZShuZXcgZyxuZXcgZygxLDEsMSkubXVsdGlwbHlTY2FsYXIoTnVtYmVyLk1BWF9WQUxVRSouMSkpfWdldCBxdWFkTWF4Q291bnQoKXtyZXR1cm4gdGhpcy5fbWF4Q291bnR9c2V0IGJpbGxib2FyZChlKXt0aGlzLnNwYWNlPT1OdC5WaWV3P2U9eGkuTm9uZTpjb25zb2xlLndhcm4oXCJDYW5ub3QgZW5hYmxlIGJpbGxib2FyZCBpbiB2aWV3IHNwYWNlXCIpLGU9PXhpLkJpbGxib2FyZFhZWnx8ZT09eGkuQmlsbGJvYXJkWT8odGhpcy5fYmlsbGJvYXJkPXRoaXMub2JqZWN0M0QuZ2V0T3JBZGRDb21wb25lbnQoeXMpLHRoaXMuX2JpbGxib2FyZC50eXBlPWUpOih0aGlzLm9iamVjdDNELnJlbW92ZUNvbXBvbmVudCh5cyksdGhpcy5fYmlsbGJvYXJkPW51bGwpfWdldCBiaWxsYm9hcmQoKXtyZXR1cm4gdGhpcy5fYmlsbGJvYXJkP3RoaXMuX2JpbGxib2FyZC50eXBlOnhpLk5vbmV9c2V0IGN1bGxNb2RlKGUpe3RoaXMuc3BhY2U9PU50LldvcmxkP3RoaXMuX3VpUmVuZGVyZXIubWF0ZXJpYWwuY3VsbE1vZGU9ZTpjb25zb2xlLndhcm4oXCJDYW5ub3QgY2hhbmdlIGN1bGxNb2RlIGluIHZpZXcgc3BhY2VcIil9Z2V0IGN1bGxNb2RlKCl7cmV0dXJuIHRoaXMuX3VpUmVuZGVyZXIubWF0ZXJpYWwuY3VsbE1vZGV9b25VcGRhdGUoZSl7dmFyIHQ7KHQ9c3VwZXIub25VcGRhdGUpPT1udWxsfHx0LmNhbGwodGhpcyxlKSx0aGlzLnJlYnVpbGRHVUlNZXNoKGUpfXJlYnVpbGRHVUlNZXNoKGUpe2xldCB0PXRoaXMscj10Ll9jb2xsZWN0VHJhbnNmb3JtO2lmKHIubGVuZ3RoPTAsdC5vYmplY3QzRC5nZXRDb21wb25lbnRzKGxpLHIpLHIubGVuZ3RoPjApe3QuX3JlYnVpbGQuYnVpbGQocix0LHQubmVlZFVwZGF0ZUdlb21ldHJ5KTtmb3IoY29uc3QgaCBvZiByKWgubmVlZFVwZGF0ZVF1YWRzPSExfWxldCBzPXQub2JqZWN0M0QuZ2V0Q29tcG9uZW50RnJvbVBhcmVudChDcyksYT1zP3MuaW5kZXg6MDt0Ll91aVJlbmRlcmVyLmVuYWJsZT1yLmxlbmd0aD4wO2xldCBuPXQuaXNWaWV3UGFuZWw/eWUuU29ydE9yZGVyU3RhcnRWaWV3OnllLlNvcnRPcmRlclN0YXJ0V29ybGQ7dC5fdWlSZW5kZXJlci5yZW5kZXJPcmRlcj1hKnllLlNvcnRPcmRlckNhbnZhc1NwYW4rbit0LnBhbmVsT3JkZXIsdC5fdWlSZW5kZXJlci5uZWVkU29ydE9uQ2FtZXJhWj10Lm5lZWRTb3J0T25DYW1lcmFaO2xldCBsPXQuX3VpTWF0ZXJpYWw7aWYobC5zZXRHVUlTb2x1dGlvbih5ZS5zb2x1dGlvbix5ZS5waXhlbFJhdGlvKSxsLnNldFNjcmVlblNpemUoUy5jYW52YXMuY2xpZW50V2lkdGgsUy5jYW52YXMuY2xpZW50SGVpZ2h0KSxsLnNldExpbWl0VmVydGV4KHQuX2xpbWl0VmVydGV4Q291bnQpLGwuc2V0U2Npc3NvckVuYWJsZSh0LnNjaXNzb3JFbmFibGUpLHQuc2Npc3NvckVuYWJsZSl7bGV0IGg9dC5tYWluUXVhZHNbMF07bC5zZXRTY2lzc29yUmVjdChoLmxlZnQsaC5ib3R0b20saC5yaWdodCxoLnRvcCksbC5zZXRTY2lzc29yQ29ybmVyKHQuc2Npc3NvckNvcm5lclJhZGl1cyx0LnNjaXNzb3JGYWRlT3V0U2l6ZSl9dC5uZWVkVXBkYXRlR2VvbWV0cnk9ITF9fWNsYXNzIENhIGV4dGVuZHMgd3N7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcImlzVmlld1BhbmVsXCIsITApLG8odGhpcyxcInNwYWNlXCIsTnQuVmlldyl9Y2xvbmVUbyhlKXtlLmdldE9yQWRkQ29tcG9uZW50KENhKS5jb3B5Q29tcG9uZW50KHRoaXMpfX1jbGFzcyB3YSBleHRlbmRzIHdze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJpc1dvcmxkUGFuZWxcIiwhMCksbyh0aGlzLFwic3BhY2VcIixOdC5Xb3JsZCksbyh0aGlzLFwiX2RlcHRoVGVzdFwiLCEwKX1jbG9uZVRvKGUpe2UuZ2V0T3JBZGRDb21wb25lbnQod2EpLmNvcHlDb21wb25lbnQodGhpcyl9Y29weUNvbXBvbmVudChlKXtyZXR1cm4gc3VwZXIuY29weUNvbXBvbmVudChlKSx0aGlzLmRlcHRoVGVzdD1lLmRlcHRoVGVzdCx0aGlzfWdldCBkZXB0aFRlc3QoKXtyZXR1cm4gdGhpcy5fZGVwdGhUZXN0fXNldCBkZXB0aFRlc3QoZSl7aWYodGhpcy5fZGVwdGhUZXN0IT1lKXt0aGlzLl9kZXB0aFRlc3Q9ZTtsZXQgdD10aGlzLmRlcHRoVGVzdD92dC5sZXNzX2VxdWFsOnZ0LmFsd2F5czt0aGlzLl91aVJlbmRlcmVyLm1hdGVyaWFsLmRlcHRoQ29tcGFyZT10fX19bGV0IGhuO2NsYXNzIGxpIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcInVzZVBhcmVudFBpdm90XCIsITEpLG8odGhpcyxcInBhcmVudFwiKSxvKHRoaXMsXCJwaXZvdFhcIiwuNSksbyh0aGlzLFwicGl2b3RZXCIsLjUpLG8odGhpcyxcIl93aWR0aFwiLDEwMCksbyh0aGlzLFwiX2hlaWdodFwiLDEwMCksbyh0aGlzLFwiX2xvY2FsVmlzaWJsZVwiLCEwKSxvKHRoaXMsXCJfZ2xvYmFsVmlzaWJsZVwiLCEwKSxvKHRoaXMsXCJfdWlJbnRlcmFjdGl2ZUxpc3RcIiksbyh0aGlzLFwiX2xvY2FsTWF0cml4XCIpLG8odGhpcyxcIl93b3JsZE1hdHJpeFwiKSxvKHRoaXMsXCJfb25DaGFuZ2VcIiwhMCksbyh0aGlzLFwibmVlZFVwZGF0ZVF1YWRzXCIsITApLG8odGhpcyxcIl90ZW1wVHJhbnNmb3Jtc1wiLFtdKSx0aGlzLl9sb2NhbE1hdHJpeD1uZXcgUWksdGhpcy5fd29ybGRNYXRyaXg9bmV3IFFpfWdldCB1aUludGVyYWN0aXZlTGlzdCgpe3JldHVybiB0aGlzLl91aUludGVyYWN0aXZlTGlzdH1pbml0KGUpe3ZhciB0O3N1cGVyLmluaXQoZSksdGhpcy50cmFuc2Zvcm0uZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy50cmFuc2Zvcm0uZXZlbnRMb2NhbENoYW5nZS50eXBlLHRoaXMub25UcmFuc2Zvcm1DaGFuZ2UsdGhpcyksdGhpcy5vblBhcmVudENoYW5nZShudWxsLCh0PXRoaXMub2JqZWN0M0QucGFyZW50KT09bnVsbD92b2lkIDA6dC5vYmplY3QzRCl9b25UcmFuc2Zvcm1DaGFuZ2UoZSl7dGhpcy5vbkNoYW5nZT0hMH1hZGRVSUludGVyYWN0aXZlKGUpe3JldHVybiB0aGlzLl91aUludGVyYWN0aXZlTGlzdHx8KHRoaXMuX3VpSW50ZXJhY3RpdmVMaXN0PVtdKSx0aGlzLl91aUludGVyYWN0aXZlTGlzdC5wdXNoKGUpLHRoaXN9cmVtb3ZlVUlJbnRlcmFjdGl2ZShlKXtpZih0aGlzLl91aUludGVyYWN0aXZlTGlzdCl7bGV0IHQ9dGhpcy5fdWlJbnRlcmFjdGl2ZUxpc3QuaW5kZXhPZihlKTtpZih0Pj0wKXJldHVybiB0aGlzLl91aUludGVyYWN0aXZlTGlzdC5zbGljZSh0LDEpLGV9cmV0dXJuIG51bGx9Z2V0IGdsb2JhbFZpc2libGUoKXtyZXR1cm4gdGhpcy5fZ2xvYmFsVmlzaWJsZX1zZXQgdmlzaWJsZShlKXtpZih0aGlzLl9sb2NhbFZpc2libGUhPWUpe3RoaXMuX2xvY2FsVmlzaWJsZT1lO2xldCB0PXRoaXMucGFyZW50P3RoaXMucGFyZW50Ll9nbG9iYWxWaXNpYmxlOiEwO3RoaXMub25VSVRyYW5zZm9ybVZpc2libGUodGhpcy5fbG9jYWxWaXNpYmxlJiZ0KX19Z2V0IHZpc2libGUoKXtyZXR1cm4gdGhpcy5fbG9jYWxWaXNpYmxlfW9uVUlUcmFuc2Zvcm1WaXNpYmxlKGUpe2xldCB0PXRoaXMuX2xvY2FsVmlzaWJsZSYmZTt0IT10aGlzLl9nbG9iYWxWaXNpYmxlJiYodGhpcy5fZ2xvYmFsVmlzaWJsZT10LHRoaXMub2JqZWN0M0QuY29tcG9uZW50cy5mb3JFYWNoKChyLHMpPT57bGV0IGE9cjtpZihhLm9uVUlUcmFuc2Zvcm1WaXNpYmxlKWlmKGE9PXRoaXMpZm9yKGxldCBuIG9mIHRoaXMub2JqZWN0M0QuZW50aXR5Q2hpbGRyZW4pe2xldCBsPW4uZ2V0Q29tcG9uZW50KGxpKTtsJiZsLm9uVUlUcmFuc2Zvcm1WaXNpYmxlKHRoaXMuX2dsb2JhbFZpc2libGUpfWVsc2UgYS5vblVJVHJhbnNmb3JtVmlzaWJsZSh0aGlzLl9nbG9iYWxWaXNpYmxlKX0pKX1vblBhcmVudENoYW5nZShlLHQpe3ZhciByLHM7KHI9dGhpcy5wYXJlbnQpPT1udWxsfHxyLnNldE5lZWRVcGRhdGVVSVBhbmVsKCksdGhpcy5wYXJlbnQ9dD8uZ2V0Q29tcG9uZW50KGxpKSwocz10aGlzLnBhcmVudCk9PW51bGx8fHMuc2V0TmVlZFVwZGF0ZVVJUGFuZWwoKX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5fd2lkdGh9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLl9oZWlnaHR9cmVzaXplKGUsdCl7dmFyIHI7aWYodGhpcy5fd2lkdGghPWV8fHRoaXMuX2hlaWdodCE9dCl7dGhpcy5fd2lkdGg9ZSx0aGlzLl9oZWlnaHQ9dCx0aGlzLm9uQ2hhbmdlPSEwO2ZvcihsZXQgcyBvZiB0aGlzLm9iamVjdDNELmNvbXBvbmVudHMudmFsdWVzKCkpKHI9cy5vblRyYW5zZm9ybVJlc2l6ZSk9PW51bGx8fHIuY2FsbChzKTtyZXR1cm4hMH1yZXR1cm4hMX1nZXQgeCgpe3JldHVybiB0aGlzLm9iamVjdDNELnh9c2V0IHgoZSl7ZSE9dGhpcy5vYmplY3QzRC54JiYodGhpcy5vYmplY3QzRC54PWUsdGhpcy5vbkNoYW5nZT0hMCl9Z2V0IHkoKXtyZXR1cm4gdGhpcy5vYmplY3QzRC55fXNldCB5KGUpe2UhPXRoaXMub2JqZWN0M0QueSYmKHRoaXMub2JqZWN0M0QueT1lLHRoaXMub25DaGFuZ2U9ITApfXNldFhZKGUsdCl7bGV0IHI9dGhpcy5vYmplY3QzRC5sb2NhbFBvc2l0aW9uO3Iuc2V0KGUsdCxyLnopLHRoaXMub2JqZWN0M0QubG9jYWxQb3NpdGlvbj1yLHRoaXMub25DaGFuZ2U9ITB9Z2V0IHooKXtyZXR1cm4gdGhpcy5vYmplY3QzRC56fXNldCB6KGUpe2UhPXRoaXMub2JqZWN0M0QueiYmKHRoaXMub2JqZWN0M0Quej1lLHRoaXMub25DaGFuZ2U9ITApfWdldCBzY2FsZVgoKXtyZXR1cm4gdGhpcy5vYmplY3QzRC5zY2FsZVh9c2V0IHNjYWxlWChlKXt0aGlzLm9uQ2hhbmdlPSEwLHRoaXMub2JqZWN0M0Quc2NhbGVYPWV9Z2V0IHNjYWxlWSgpe3JldHVybiB0aGlzLm9iamVjdDNELnNjYWxlWX1zZXQgc2NhbGVZKGUpe3RoaXMub25DaGFuZ2U9ITAsdGhpcy5vYmplY3QzRC5zY2FsZVk9ZX1nZXQgc2NhbGVaKCl7cmV0dXJuIHRoaXMub2JqZWN0M0Quc2NhbGVafXNldCBzY2FsZVooZSl7dGhpcy5vbkNoYW5nZT0hMCx0aGlzLm9iamVjdDNELnNjYWxlWj1lfWdldCBvbkNoYW5nZSgpe3JldHVybiB0aGlzLl9vbkNoYW5nZX1zZXQgb25DaGFuZ2UoZSl7aWYodGhpcy5fb25DaGFuZ2UhPWUmJih0aGlzLl9vbkNoYW5nZT1lLGUpKXt0aGlzLl90ZW1wVHJhbnNmb3Jtcy5sZW5ndGg9MDtsZXQgdD10aGlzLm9iamVjdDNELmdldENvbXBvbmVudHMobGksdGhpcy5fdGVtcFRyYW5zZm9ybXMsITApO2ZvcihsZXQgciBvZiB0KXIuX29uQ2hhbmdlPSEwLHIubmVlZFVwZGF0ZVF1YWRzPSEwfX1vbkVuYWJsZSgpe3RoaXMuc2V0TmVlZFVwZGF0ZVVJUGFuZWwoKSx0aGlzLm9uQ2hhbmdlPSEwfW9uRGlzYWJsZSgpe3RoaXMuc2V0TmVlZFVwZGF0ZVVJUGFuZWwoKSx0aGlzLm9uQ2hhbmdlPSEwfXNldE5lZWRVcGRhdGVVSVBhbmVsKCl7bGV0IGU7ZT10aGlzLm9iamVjdDNELmdldENvbXBvbmVudEZyb21QYXJlbnQod2EpLGV8fChlPXRoaXMub2JqZWN0M0QuZ2V0Q29tcG9uZW50RnJvbVBhcmVudChDYSkpLGUmJihlLm5lZWRVcGRhdGVHZW9tZXRyeT0hMCl9Y2xvbmVUbyhlKXtsZXQgdD1lLmdldE9yQWRkQ29tcG9uZW50KGxpKTt0LnZpc2libGU9dGhpcy52aXNpYmxlLHQueD10aGlzLngsdC55PXRoaXMueSx0Lno9dGhpcy56LHQucmVzaXplKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHQucGl2b3RYPXRoaXMucGl2b3RYLHQucGl2b3RZPXRoaXMucGl2b3RZLHQuc2NhbGVYPXRoaXMuc2NhbGVYLHQuc2NhbGVZPXRoaXMuc2NhbGVZfW1hdHJpeCgpe2xldCBlPXRoaXMuX2xvY2FsTWF0cml4LHQ9dGhpcy5vYmplY3QzRC5yb3RhdGlvblo7cmV0dXJuIHRoaXMucGFyZW50PyhlLnVwZGF0ZVNjYWxlQW5kUm90YXRpb24odGhpcy5vYmplY3QzRC5zY2FsZVgsdGhpcy5vYmplY3QzRC5zY2FsZVksdCx0KSxlLnR4PXRoaXMub2JqZWN0M0QueCxlLnR5PXRoaXMub2JqZWN0M0QueSk6ZS51cGRhdGVTY2FsZUFuZFJvdGF0aW9uKDEsMSwwLDApLCh0aGlzLnBpdm90WCE9LjV8fHRoaXMucGl2b3RZIT0uNSkmJihobnx8KGhuPW5ldyBRaSgpLmlkZW50aXR5KCkpLGUubXVsKGhuLnNldFRvKDEsMCwwLDEsLSh0aGlzLnBpdm90WC0uNSkqdGhpcy53aWR0aCwtKHRoaXMucGl2b3RZLS41KSp0aGlzLmhlaWdodCkpKSxlfWdldFdvcmxkTWF0cml4KCl7bGV0IGU9dGhpcyx0PWUuX3dvcmxkTWF0cml4O3JldHVybiB0aGlzLl9vbkNoYW5nZSYmKHQuY29weUZyb20oZS5tYXRyaXgoKSksZS5wYXJlbnQmJnQubXVsKGUucGFyZW50LmdldFdvcmxkTWF0cml4KCkpLGUuX29uQ2hhbmdlPSExKSx0fWJlZm9yZURlc3Ryb3koZSl7dmFyIHQ7dGhpcy50cmFuc2Zvcm0uZXZlbnREaXNwYXRjaGVyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy50cmFuc2Zvcm0uZXZlbnRMb2NhbENoYW5nZS50eXBlLHRoaXMub25UcmFuc2Zvcm1DaGFuZ2UsdGhpcyksKHQ9c3VwZXIuYmVmb3JlRGVzdHJveSk9PW51bGx8fHQuY2FsbCh0aGlzLGUpfX1jbGFzcyBIY3tjb25zdHJ1Y3Rvcigpe28odGhpcyxcIl9yYXlcIiksbyh0aGlzLFwiX21vdXNlQ29kZVwiKSxvKHRoaXMsXCJfY2xpY2tFdmVudFwiKSxvKHRoaXMsXCJfb3V0RXZlbnRcIiksbyh0aGlzLFwiX292ZXJFdmVudFwiKSxvKHRoaXMsXCJfdXBFdmVudFwiKSxvKHRoaXMsXCJfZG93bkV2ZW50XCIpLG8odGhpcyxcIl92aWV3XCIpLG8odGhpcyxcIl9sYXN0RG93blRhcmdldFwiKSxvKHRoaXMsXCJfbGFzdE92ZXJUYXJnZXRcIiksbyh0aGlzLFwiX2xhc3REb3duUG9zaXRpb25cIixuZXcgWiksbyh0aGlzLFwiX2NhbGNEaXN0YW5jZVZlYzJcIixuZXcgWiksbyh0aGlzLFwiX2xhc3REb3duVGltZVwiLDApLG8odGhpcyxcIl9jbGlja1RpbWVTcGFuXCIsMjAwKSxvKHRoaXMsXCJfY2xpY2tEaXN0YW5jZVNwYW5cIiwxMCksbyh0aGlzLFwiX2NvbGxpZGVyT3V0XCIsW10pLG8odGhpcyxcIl90cmFuc2Zvcm1MaXN0XCIsW10pLG8odGhpcyxcIl9zb3J0V29ybGRQYW5lbExpc3RcIixbXSksbyh0aGlzLFwiX2l0ZXJhY3RpdmUyUGFuZWxEaWN0XCIsbmV3IE1hcCl9aW5pdChlKXt0aGlzLl92aWV3PWUsdGhpcy5fcmF5PW5ldyBjaSx0aGlzLl9jbGlja0V2ZW50PW5ldyBSKFIuUElDS19DTElDS19HVUkpLHRoaXMuX291dEV2ZW50PW5ldyBSKFIuUElDS19PVVRfR1VJKSx0aGlzLl9vdmVyRXZlbnQ9bmV3IFIoUi5QSUNLX09WRVJfR1VJKSx0aGlzLl91cEV2ZW50PW5ldyBSKFIuUElDS19VUF9HVUkpLHRoaXMuX2Rvd25FdmVudD1uZXcgUihSLlBJQ0tfRE9XTl9HVUkpLEEuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfRE9XTix0aGlzLm9uVG91Y2hEb3duLHRoaXMsbnVsbCwxKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX1VQLHRoaXMub25Ub3VjaFVwLHRoaXMsbnVsbCwxKSxBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX01PVkUsdGhpcy5vblRvdWNoTW92ZSx0aGlzLG51bGwsMSksQS5pbnB1dFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9DTElDSyx0aGlzLm9uVG91Y2hDbGljayx0aGlzLG51bGwsMSl9b25Ub3VjaENsaWNrKGUpe3RoaXMuX2xhc3RPdmVyVGFyZ2V0JiZlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfW9uVG91Y2hNb3ZlKGUpe3RoaXMuX21vdXNlQ29kZT1lLm1vdXNlQ29kZSx0aGlzLmNvbGxlY3RFbnRpdGllcygpO2xldCB0PXRoaXMucGljayh0aGlzLl9jb2xsaWRlck91dCk7dCYmZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtsZXQgcj10P3QuY29sbGlkZXI6bnVsbDtyIT10aGlzLl9sYXN0T3ZlclRhcmdldCYmKHRoaXMuX2xhc3RPdmVyVGFyZ2V0JiZ0aGlzLl9sYXN0T3ZlclRhcmdldC5lbmFibGUmJih0aGlzLl9sYXN0T3ZlclRhcmdldC5tb3VzZVN0eWxlPURlLk5PUk1BTCx0aGlzLl9vdXRFdmVudC5kYXRhPXRoaXMuX2xhc3RPdmVyVGFyZ2V0LHRoaXMuX2xhc3RPdmVyVGFyZ2V0Lm9iamVjdDNELmRpc3BhdGNoRXZlbnQodGhpcy5fb3V0RXZlbnQpKSxyJiYoci5tb3VzZVN0eWxlPURlLk9WRVIsdGhpcy5fb3ZlckV2ZW50LmRhdGE9cixyLm9iamVjdDNELmRpc3BhdGNoRXZlbnQodGhpcy5fb3ZlckV2ZW50KSksdGhpcy5fbGFzdE92ZXJUYXJnZXQ9cil9b25Ub3VjaERvd24oZSl7dGhpcy5fbGFzdERvd25UaW1lPWhlLnRpbWUsdGhpcy5fbGFzdERvd25Qb3NpdGlvbi5zZXQoZS5tb3VzZVgsZS5tb3VzZVkpLHRoaXMuX21vdXNlQ29kZT1lLm1vdXNlQ29kZSx0aGlzLmNvbGxlY3RFbnRpdGllcygpO2xldCB0PXRoaXMucGljayh0aGlzLl9jb2xsaWRlck91dCk7dCYmZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtsZXQgcj10P3QuY29sbGlkZXI6bnVsbDtyJiYoci5tb3VzZVN0eWxlPURlLkRPV04sdGhpcy5fb3ZlckV2ZW50LmRhdGE9cixyLm9iamVjdDNELmRpc3BhdGNoRXZlbnQodGhpcy5fb3ZlckV2ZW50KSksdGhpcy5fbGFzdERvd25UYXJnZXQ9cn1vblRvdWNoVXAoZSl7dGhpcy5fY2FsY0Rpc3RhbmNlVmVjMi5zZXQoZS5tb3VzZVgsZS5tb3VzZVkpLHRoaXMuX21vdXNlQ29kZT1lLm1vdXNlQ29kZSx0aGlzLmNvbGxlY3RFbnRpdGllcygpO2xldCB0PXRoaXMucGljayh0aGlzLl9jb2xsaWRlck91dCk7dCYmZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtsZXQgcj10P3QuY29sbGlkZXI6bnVsbDt0aGlzLl9sYXN0RG93blRhcmdldCYmdGhpcy5fbGFzdERvd25UYXJnZXQuZW5hYmxlJiYodGhpcy5fbGFzdERvd25UYXJnZXQubW91c2VTdHlsZT1EZS5OT1JNQUwpLHImJnI9PXRoaXMuX2xhc3REb3duVGFyZ2V0JiZoZS50aW1lLXRoaXMuX2xhc3REb3duVGltZTw9dGhpcy5fY2xpY2tUaW1lU3BhbiYmKHRoaXMuX2NhbGNEaXN0YW5jZVZlYzIuc2V0KGUubW91c2VYLGUubW91c2VZKSx0aGlzLl9jYWxjRGlzdGFuY2VWZWMyLmRpc3RhbmNlKHRoaXMuX2xhc3REb3duUG9zaXRpb24pPD10aGlzLl9jbGlja0Rpc3RhbmNlU3BhbiYmKHRoaXMuX2NsaWNrRXZlbnQuZGF0YT17cGljazpyLHBpY2tJbmZvOnQsbW91c2VDb2RlOnRoaXMuX21vdXNlQ29kZX0sci5vYmplY3QzRC5kaXNwYXRjaEV2ZW50KHRoaXMuX2NsaWNrRXZlbnQpKSksdGhpcy5fbGFzdERvd25UYXJnZXQ9bnVsbH1jb2xsZWN0RW50aXRpZXMoKXtyZXR1cm4gdGhpcy5fY29sbGlkZXJPdXQubGVuZ3RoPTAsdGhpcy5fc29ydFdvcmxkUGFuZWxMaXN0Lmxlbmd0aD0wLHRoaXMuX2l0ZXJhY3RpdmUyUGFuZWxEaWN0LmNsZWFyKCksdGhpcy5fdmlldy5jYW52YXNMaXN0LnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2godD0+e2lmKHQmJnQudHJhbnNmb3JtJiZ0LnRyYW5zZm9ybS5wYXJlbnQpe2xldCByPXQub2JqZWN0M0QuZ2V0Q29tcG9uZW50c0J5UHJvcGVydHkoXCJpc1VJUGFuZWxcIiwhMCwhMCk7ci5zb3J0KChzLGEpPT57bGV0IG49cy5fdWlSZW5kZXJlci5fX3JlbmRlck9yZGVyLGw9YS5fdWlSZW5kZXJlci5fX3JlbmRlck9yZGVyO3JldHVybiBuPmw/LTE6MX0pO2ZvcihsZXQgcyBvZiByKXt0aGlzLl90cmFuc2Zvcm1MaXN0Lmxlbmd0aD0wLHMub2JqZWN0M0QuZ2V0Q29tcG9uZW50cyhsaSx0aGlzLl90cmFuc2Zvcm1MaXN0KSx0aGlzLl90cmFuc2Zvcm1MaXN0LnJldmVyc2UoKTtmb3IoY29uc3QgYSBvZiB0aGlzLl90cmFuc2Zvcm1MaXN0KXtsZXQgbj1hLnVpSW50ZXJhY3RpdmVMaXN0O2lmKG4mJm4ubGVuZ3RoPjApZm9yKGxldCBsIG9mIG4pdGhpcy5fY29sbGlkZXJPdXQucHVzaChsKSx0aGlzLl9pdGVyYWN0aXZlMlBhbmVsRGljdC5zZXQobCxzKX19fX0pLHRoaXMuX2NvbGxpZGVyT3V0fXBpY2soZSl7dGhpcy5fcmF5PXRoaXMuX3ZpZXcuY2FtZXJhLnNjcmVlblBvaW50VG9SYXkoQS5pbnB1dFN5c3RlbS5tb3VzZVgsQS5pbnB1dFN5c3RlbS5tb3VzZVkpO2xldCB0PW5ldyBaKEEuaW5wdXRTeXN0ZW0ubW91c2VYLEEuaW5wdXRTeXN0ZW0ubW91c2VZKSxyPW5ldyBaKFMuY2FudmFzLmNsaWVudFdpZHRoLFMuY2FudmFzLmNsaWVudEhlaWdodCkscztmb3IoY29uc3QgYSBvZiBlKWlmKGEuaW50ZXJhY3RpdmUmJmEuZW5hYmxlJiZhLmludGVyYWN0aXZlVmlzaWJsZSl7bGV0IG49dGhpcy5faXRlcmFjdGl2ZTJQYW5lbERpY3QuZ2V0KGEpO2lmKHM9YS5yYXlQaWNrKHRoaXMuX3JheSxuLHQscikscylyZXR1cm4gcy5jb2xsaWRlcj1hLHN9cmV0dXJuIG51bGx9fXZhciBZYz0oaT0+KGlbaS5DT0xMSU5FQVI9MF09XCJDT0xMSU5FQVJcIixpW2kuTElORVNfSU5URVJTRUNUPTFdPVwiTElORVNfSU5URVJTRUNUXCIsaVtpLlNFR01FTlRTX0lOVEVSU0VDVD0yXT1cIlNFR01FTlRTX0lOVEVSU0VDVFwiLGlbaS5BX0JJU0VDVFNfQj0zXT1cIkFfQklTRUNUU19CXCIsaVtpLkJfQklTRUNUU19BPTRdPVwiQl9CSVNFQ1RTX0FcIixpW2kuUEFSQUxFTEw9NV09XCJQQVJBTEVMTFwiLGkpKShZY3x8e30pLFhjPShpPT4oaVtpLk9OX0xJTkU9MF09XCJPTl9MSU5FXCIsaVtpLkxFRlRfU0lERT0xXT1cIkxFRlRfU0lERVwiLGlbaS5SSUdIVF9TSURFPTJdPVwiUklHSFRfU0lERVwiLGkpKShYY3x8e30pO2NvbnN0IHB0PWNsYXNze2NvbnN0cnVjdG9yKGksZSl7byh0aGlzLFwic3RhcnRcIiksbyh0aGlzLFwiZW5kXCIpLG8odGhpcyxcImNvbG9yXCIsbmV3IHooMSwxLDEsMSkpLG8odGhpcyxcIl9ub3JtYWxcIiksbyh0aGlzLFwiX25vcm1hbENhbGN1bGF0ZWRcIiwhMSksdGhpcy5zdGFydD1pLHRoaXMuZW5kPWV9c2V0KGksZSl7dGhpcy5zdGFydD1pLHRoaXMuZW5kPWV9Z2V0Q2VudGVyKCl7bGV0IGk9Zy5IRUxQXzA7cmV0dXJuIHRoaXMuc3RhcnQuc3VidHJhY3QodGhpcy5lbmQsaSksaS5zY2FsZUJ5KC41KSxpLmFkZCh0aGlzLmVuZCksaX1pbnZlcnNlKCl7bGV0IGk9dGhpcy5zdGFydDt0aGlzLnN0YXJ0PXRoaXMuZW5kLHRoaXMuZW5kPWl9ZXF1YWxzKGkpe3JldHVybiB0aGlzLnN0YXJ0PT1pLnN0YXJ0JiZ0aGlzLmVuZD09aS5lbmR8fHRoaXMuc3RhcnQ9PWkuZW5kJiZ0aGlzLmVuZD09aS5zdGFydH10b0FycmF5KCl7cmV0dXJuW3RoaXMuc3RhcnQueCx0aGlzLnN0YXJ0LnksdGhpcy5zdGFydC56LHRoaXMuZW5kLngsdGhpcy5lbmQueSx0aGlzLmVuZC56XX1zdGF0aWMgZ2V0TGluZXMoaSl7bGV0IGU9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2xldCByPXQscz1ybyh0KzEsaS5sZW5ndGgpLGE9aVtyXSxuPWlbc107ZS5wdXNoKG5ldyBwdChhLG4pKX1yZXR1cm4gZX1pbnRlcnNlY3Rpb24oaSxlPW51bGwpe3ZhciB0PShpLmVuZC56LWkuc3RhcnQueikqKHRoaXMuZW5kLngtdGhpcy5zdGFydC54KS0oaS5lbmQueC1pLnN0YXJ0LngpKih0aGlzLmVuZC56LXRoaXMuc3RhcnQueikscj0oaS5lbmQueC1pLnN0YXJ0LngpKih0aGlzLnN0YXJ0LnotaS5zdGFydC56KS0oaS5lbmQuei1pLnN0YXJ0LnopKih0aGlzLnN0YXJ0LngtaS5zdGFydC54KSxzPShpLnN0YXJ0LngtdGhpcy5zdGFydC54KSoodGhpcy5lbmQuei10aGlzLnN0YXJ0LnopLShpLnN0YXJ0LnotdGhpcy5zdGFydC56KSoodGhpcy5lbmQueC10aGlzLnN0YXJ0LngpO2lmKHQ9PTApcmV0dXJuIHI9PTAmJnM9PTA/MDo1O3I9ci90LHM9cy90O3ZhciBhPXRoaXMuc3RhcnQueCtyKih0aGlzLmVuZC54LXRoaXMuc3RhcnQueCksbj10aGlzLnN0YXJ0LnorcioodGhpcy5lbmQuei10aGlzLnN0YXJ0LnopO3JldHVybiBlIT1udWxsJiYoZS54PWEsZS55PTAsZS56PW4pLHI+PTAmJnI8PTEmJnM+PTAmJnM8PTE/MjpzPj0wJiZzPD0xPzM6cj49MCYmcjw9MT80OjF9Z2V0RGlyZWN0aW9uKCl7dmFyIGk9dGhpcy5lbmQuc3VidHJhY3QodGhpcy5zdGFydCksZT1uZXcgZyhpLngsaS55KTtyZXR1cm4gZS5ub3JtYWxpemUoKX1jb3B5RnJvbShpKXt0aGlzLnN0YXJ0fHwodGhpcy5zdGFydD1uZXcgZyksdGhpcy5lbmR8fCh0aGlzLmVuZD1uZXcgZyksdGhpcy5zdGFydC5jb3B5RnJvbShpLnN0YXJ0KSx0aGlzLmVuZC5jb3B5RnJvbShpLmVuZCl9c3RhdGljIElzRXF1YWwoaSxlKXtyZXR1cm4gTWF0aC5hYnMoaS1lKTwxZS03fXN0YXRpYyBzcXVyZURpc3RhbmNlU2VnbWVudFRvU2VnbWVudChpLGUsdCl7bGV0IHI9aS5zdGFydCxzPWkuZW5kLGE9ZS5zdGFydCxuPWUuZW5kLGw9ci54LGg9ci55LHU9ci56LGM9cy54LGY9cy55LGQ9cy56LHA9YS54LG09YS55LF89YS56LHY9bi54LHk9bi55LEM9bi56LEI9Yy1sLFQ9Zi1oLE09ZC11LEQ9di1wLFA9eS1tLEw9Qy1fLEk9bC1wLE89aC1tLGs9dS1fLEg9QipCK1QqVCtNKk0sVz1CKkQrVCpQK00qTCxuZT1EKkQrUCpQK0wqTCxmZT1CKkkrVCpPK00qayx3ZT1EKkkrUCpPK0wqayx6ZT1IKm5lLVcqVyxSZT16ZSx1ZT16ZSxkZT0wLEdlPTA7dGhpcy5Jc0VxdWFsKHplLDApPyhkZT0wLFJlPTEsR2U9d2UsdWU9bmUpOihkZT1XKndlLW5lKmZlLEdlPUgqd2UtVypmZSxkZTwwPyhkZT0wLEdlPXdlLHVlPW5lKTpkZT5SZSYmKGRlPVJlLEdlPXdlK1csdWU9bmUpKSxHZTwwPyhHZT0wLC1mZTwwP2RlPTA6LWZlPkg/ZGU9UmU6KGRlPS1mZSxSZT1IKSk6R2U+dWUmJihHZT11ZSwtZmUrVzwwP2RlPTA6LWZlK1c+SD9kZT1SZTooZGU9LWZlK1csUmU9SCkpO2xldCBvdD0wLG50PTA7dGhpcy5Jc0VxdWFsKGRlLDApP290PTA6b3Q9ZGUvUmUsdGhpcy5Jc0VxdWFsKEdlLDApP250PTA6bnQ9R2UvdWU7bGV0IEV0PUkrb3QqQi1udCpELF90PU8rb3QqVC1udCpQLHh0PWsrb3QqTS1udCpMO3JldHVybiBFdCpFdCtfdCpfdCt4dCp4dH1pc05lYXIoaSxlPTAsdCl7bGV0IHI9Zy5IRUxQXzAscz1nLkhFTFBfMTtyLmNvcHlGcm9tKGkub3JpZ2luKSxzLmNvcHlGcm9tKGkuZGlyZWN0aW9uKSxzLnNjYWxlQnkoOTk5OSkscy5hZGQocixzKSxwdC5jYWNsdXRlTGluZTAuc2V0KHIscykscHQuY2FjbHV0ZUxpbmUxLmNvcHlGcm9tKHRoaXMpLHQmJih0LnBlcnNwZWN0aXZlTXVsdGlwbHlQb2ludDMocHQuY2FjbHV0ZUxpbmUxLnN0YXJ0LHB0LmNhY2x1dGVMaW5lMS5zdGFydCksdC5wZXJzcGVjdGl2ZU11bHRpcGx5UG9pbnQzKHB0LmNhY2x1dGVMaW5lMS5lbmQscHQuY2FjbHV0ZUxpbmUxLmVuZCkpO2xldCBhPXB0LnNxdXJlRGlzdGFuY2VTZWdtZW50VG9TZWdtZW50KHB0LmNhY2x1dGVMaW5lMCxwdC5jYWNsdXRlTGluZTEsdCk7cmV0dXJuIGErMWUtNDw9ZT8oaS5sZW5ndGg9YSwhMCk6KGkubGVuZ3RoPS05OTk5OTksITEpfX07bGV0IHZyPXB0O28odnIsXCJjYWNsdXRlTGluZTBcIixuZXcgcHQobnVsbCxudWxsKSksbyh2cixcImNhY2x1dGVMaW5lMVwiLG5ldyBwdChudWxsLG51bGwpKTtjb25zdCBXYz1jbGFzc3tjb25zdHJ1Y3RvcihpLGUsdCl7byh0aGlzLFwidjFcIiksbyh0aGlzLFwidjJcIiksbyh0aGlzLFwidjNcIiksbyh0aGlzLFwidTFcIiksbyh0aGlzLFwidTJcIiksbyh0aGlzLFwidTNcIiksbyh0aGlzLFwibjFcIiksbyh0aGlzLFwibjJcIiksbyh0aGlzLFwibjNcIiksbyh0aGlzLFwidDBcIiksbyh0aGlzLFwidFwiKSxvKHRoaXMsXCJ1XCIpLG8odGhpcyxcInZcIiksbyh0aGlzLFwibWluXCIsbmV3IGcpLG8odGhpcyxcIm1heFwiLG5ldyBnKSxvKHRoaXMsXCJpZFwiLDApLHRoaXMuaWQ9V2MuSUQrKysyMDAsaSYmZSYmdCYmdGhpcy5zZXQoaSxlLHQpfXNldChpLGUsdCl7dGhpcy52MT1pLHRoaXMudjI9ZSx0aGlzLnYzPXQ7bGV0IHI9dGhpcy5taW4scz10aGlzLm1heDtyZXR1cm4gci54PU1hdGgubWluKHRoaXMudjEueCx0aGlzLnYyLngsdGhpcy52My54KSxyLnk9TWF0aC5taW4odGhpcy52MS55LHRoaXMudjIueSx0aGlzLnYzLnkpLHIuej1NYXRoLm1pbih0aGlzLnYxLnosdGhpcy52Mi56LHRoaXMudjMueikscy54PU1hdGgubWF4KHRoaXMudjEueCx0aGlzLnYyLngsdGhpcy52My54KSxzLnk9TWF0aC5tYXgodGhpcy52MS55LHRoaXMudjIueSx0aGlzLnYzLnkpLHMuej1NYXRoLm1heCh0aGlzLnYxLnosdGhpcy52Mi56LHRoaXMudjMueiksdGhpc31nZXROb3JtYWwoKXtsZXQgaT10aGlzLnYxLGU9dGhpcy52Mix0PXRoaXMudjMscj1uZXcgZyhlLngtaS54LGUueS1pLnksZS56LWkueiksYT1uZXcgZyh0LngtaS54LHQueS1pLnksdC56LWkueikuY3Jvc3NQcm9kdWN0KHIpO3JldHVybiBhLm5vcm1hbGl6ZSgpLGF9dHVybkJhY2soKXtsZXQgaT10aGlzLnYzO3RoaXMudjM9dGhpcy52MSx0aGlzLnYxPWl9Z2V0TGluZXMoKXtsZXQgaT10aGlzLnYxLGU9dGhpcy52Mix0PXRoaXMudjM7cmV0dXJuW25ldyB2cihpLGUpLG5ldyB2cihlLHQpLG5ldyB2cih0LGkpXX1lcXVhbHMoaSl7bGV0IGU9dGhpcy5nZXRMaW5lcygpLHQ9aS5nZXRMaW5lcygpLHI9MDtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKylmb3IobGV0IGE9MDthPHQubGVuZ3RoO2ErKyllW3NdLmVxdWFscyh0W2FdKSYmcisrO3JldHVybiByPT0zfWdldENlbnRlcigpe2xldCBpPXRoaXMubWluLGU9dGhpcy5tYXgsdD1uZXcgZztyZXR1cm4gdC54PShpLngrZS54KSouNSx0Lnk9KGkueStlLnkpKi41LHQuej0oaS56K2UueikqLjUsdH1pbnRlcnNlY3RzKGkpe3ZhciBlPXRoaXMubWF4LHQ9dGhpcy5taW4scj1pLm1heCxzPWkubWluO3JldHVybiB0Lng8PXIueCYmZS54Pj1zLngmJnQueTw9ci55JiZlLnk+PXMueSYmdC56PD1yLnomJmUuej49cy56fXNpZ24yRChpLGUsdCl7cmV0dXJuKGkueC10LngpKihlLnotdC56KS0oZS54LXQueCkqKGkuei10LnopfXBvaW50SW5UcmlhbmdsZTJEKGkpe2xldCBlPXRoaXMudjEsdD10aGlzLnYyLHI9dGhpcy52MyxzLGEsbixsLGg7cmV0dXJuIHM9dGhpcy5zaWduMkQoaSxlLHQpLGE9dGhpcy5zaWduMkQoaSx0LHIpLG49dGhpcy5zaWduMkQoaSxyLGUpLGw9czwwfHxhPDB8fG48MCxoPXM+MHx8YT4wfHxuPjAsIShsJiZoKX10b0FycmF5KCl7cmV0dXJuW3RoaXMudjEueCx0aGlzLnYxLnksdGhpcy52MS56LHRoaXMudjIueCx0aGlzLnYyLnksdGhpcy52Mi56LHRoaXMudjMueCx0aGlzLnYzLnksdGhpcy52My56XX19O2xldCBuYT1XYztvKG5hLFwiSURcIiwtMSk7Y2xhc3MgRnR7c3RhdGljIGluaXQoKXt0aGlzLl9wdDA9bmV3IGcsdGhpcy5fcHQxPW5ldyBnLHRoaXMuX3B0Mj1uZXcgZyx0aGlzLl9wdDM9bmV3IGcsdGhpcy5fcmF5PW5ldyBjaSx0aGlzLl90cmlhbmdsZT1uZXcgbmEsdGhpcy5faGl0UG9pbnQ9bmV3IGcsdGhpcy5fd29ybGRNYXRyaXg9bmV3IFZ9c3RhdGljIHJheVBpY2soZSx0LHIscyxhLG4pe3RoaXMuX2lzSW5pdHx8KHRoaXMuaW5pdCgpLHRoaXMuX2lzSW5pdD0hMCk7bGV0IGw9dGhpcy5fd29ybGRNYXRyaXg7aWYocz09TnQuV29ybGQpe2xldCBoO3RoaXMuY2FsY3VsYXRlSG90QXJlYV9Xb3JsZChhLHRoaXMuX3B0MCx0aGlzLl9wdDEsdGhpcy5fcHQyLHRoaXMuX3B0MyksbC5jb3B5RnJvbShuKS5pbnZlcnQoKTtsZXQgdT10aGlzLl9yYXk7aWYodS5jb3B5KGUpLmFwcGx5TWF0cml4KGwpLHRoaXMuX3RyaWFuZ2xlLnNldCh0aGlzLl9wdDAsdGhpcy5fcHQxLHRoaXMuX3B0MiksaD11LmludGVyc2VjdFRyaWFuZ2xlKHUub3JpZ2luLHUuZGlyZWN0aW9uLHRoaXMuX3RyaWFuZ2xlKSxofHwodGhpcy5fdHJpYW5nbGUuc2V0KHRoaXMuX3B0MSx0aGlzLl9wdDIsdGhpcy5fcHQzKSxoPXUuaW50ZXJzZWN0VHJpYW5nbGUodS5vcmlnaW4sdS5kaXJlY3Rpb24sdGhpcy5fdHJpYW5nbGUpKSxoKXJldHVybntkaXN0YW5jZTowLGludGVyc2VjdFBvaW50Omh9fWVsc2V7dGhpcy5jYWxjdWxhdGVIb3RBcmVhX1ZpZXcoYSx0aGlzLl9wdDAsdGhpcy5fcHQxLHRoaXMuX3B0Mix0aGlzLl9wdDMpO2xldCBoPXIueCx1PXIueSxjPU1hdGgubWluKHRoaXMuX3B0MC54LHRoaXMuX3B0MS54LHRoaXMuX3B0Mi54LHRoaXMuX3B0My54KStoKi41LGY9TWF0aC5taW4odGhpcy5fcHQwLnksdGhpcy5fcHQxLnksdGhpcy5fcHQyLnksdGhpcy5fcHQzLnkpK3UqLjUsZD1NYXRoLm1heCh0aGlzLl9wdDAueCx0aGlzLl9wdDEueCx0aGlzLl9wdDIueCx0aGlzLl9wdDMueCkraCouNSxwPU1hdGgubWF4KHRoaXMuX3B0MC55LHRoaXMuX3B0MS55LHRoaXMuX3B0Mi55LHRoaXMuX3B0My55KSt1Ki41O3JldHVybiB0Lng8PWQmJnQueD49YyYmdC55PD1wJiZ0Lnk+PWY/KHRoaXMuX2hpdFBvaW50LnNldCh0LngsdC55LDApLHtkaXN0YW5jZTowLGludGVyc2VjdFBvaW50OnRoaXMuX2hpdFBvaW50fSk6bnVsbH1yZXR1cm4gbnVsbH1zdGF0aWMgY2FsY3VsYXRlSG90QXJlYV9WaWV3KGUsdCxyLHMsYSl7bGV0IG49ZS5nZXRXb3JsZE1hdHJpeCgpLGw9bi5nZXRTY2FsZVgoKSxoPW4uZ2V0U2NhbGVZKCksdT1lLndpZHRoKi41KmwsYz1lLmhlaWdodCouNSpoO3Quc2V0KC11LC1jLDApLHIuc2V0KHUsLWMsMCkscy5zZXQoLXUsYywwKSxhLnNldCh1LGMsMCk7bGV0IGY9bi50eDt0LngrPWYsci54Kz1mLHMueCs9ZixhLngrPWYsZj1uLnR5LHQueS09ZixyLnktPWYscy55LT1mLGEueS09Zix0Lm11bHRpcGx5U2NhbGFyKHllLnBpeGVsUmF0aW8pLHIubXVsdGlwbHlTY2FsYXIoeWUucGl4ZWxSYXRpbykscy5tdWx0aXBseVNjYWxhcih5ZS5waXhlbFJhdGlvKSxhLm11bHRpcGx5U2NhbGFyKHllLnBpeGVsUmF0aW8pfXN0YXRpYyBjYWxjdWxhdGVIb3RBcmVhX1dvcmxkKGUsdCxyLHMsYSl7bGV0IG49ZS5nZXRXb3JsZE1hdHJpeCgpLGw9bi5nZXRTY2FsZVgoKSxoPW4uZ2V0U2NhbGVZKCksdT1lLndpZHRoKi41KmwsYz1lLmhlaWdodCouNSpoO3Quc2V0KC11LGMsMCksci5zZXQodSxjLDApLHMuc2V0KC11LC1jLDApLGEuc2V0KHUsLWMsMCk7bGV0IGY9bi50eDt0LngrPWYsci54Kz1mLHMueCs9ZixhLngrPWYsZj1uLnR5LHQueSs9ZixyLnkrPWYscy55Kz1mLGEueSs9Zn19byhGdCxcIl9wdDBcIiksbyhGdCxcIl9wdDFcIiksbyhGdCxcIl9wdDJcIiksbyhGdCxcIl9wdDNcIiksbyhGdCxcIl9oaXRQb2ludFwiKSxvKEZ0LFwiX3dvcmxkTWF0cml4XCIpLG8oRnQsXCJfcmF5XCIpLG8oRnQsXCJfdHJpYW5nbGVcIiksbyhGdCxcIl9pc0luaXRcIik7dmFyIGpjPShpPT4oaVtpLlVwcGVyTGVmdD0wXT1cIlVwcGVyTGVmdFwiLGlbaS5VcHBlckNlbnRlcj0xXT1cIlVwcGVyQ2VudGVyXCIsaVtpLlVwcGVyUmlnaHQ9Ml09XCJVcHBlclJpZ2h0XCIsaVtpLk1pZGRsZUxlZnQ9M109XCJNaWRkbGVMZWZ0XCIsaVtpLk1pZGRsZUNlbnRlcj00XT1cIk1pZGRsZUNlbnRlclwiLGlbaS5NaWRkbGVSaWdodD01XT1cIk1pZGRsZVJpZ2h0XCIsaVtpLkxvd2VyTGVmdD02XT1cIkxvd2VyTGVmdFwiLGlbaS5Mb3dlckNlbnRlcj03XT1cIkxvd2VyQ2VudGVyXCIsaVtpLkxvd2VyUmlnaHQ9OF09XCJMb3dlclJpZ2h0XCIsaSkpKGpjfHx7fSkscWM9KGk9PihpW2kuVXBwZXI9MF09XCJVcHBlclwiLGlbaS5NaWRkbGU9MV09XCJNaWRkbGVcIixpW2kuTG93ZXI9Ml09XCJMb3dlclwiLGkpKShxY3x8e30pLEtjPShpPT4oaVtpLkxlZnQ9MF09XCJMZWZ0XCIsaVtpLkNlbnRlcj0xXT1cIkNlbnRlclwiLGlbaS5SaWdodD0yXT1cIlJpZ2h0XCIsaSkpKEtjfHx7fSk7Y2xhc3MgSmN7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJjaGFyTGlzdFwiLFtdKSxvKHRoaXMsXCJxdWFkTGlzdFwiLFtdKSxvKHRoaXMsXCJ3aWR0aFwiLDApLG8odGhpcyxcImluZGV4XCIsMCl9fWNsYXNzIFpje2xheW91dChlKXtsZXQgdD1bXSxyPWUub3JpZ2luU2l6ZSxzPWdyLmdldEZvbnREYXRhKGUuZm9udCxyKSxhPWUuZm9udFNpemUvcjtyZXR1cm4gdGhpcy5tYWtlVGV4dExpbmUoZS51aVRyYW5zZm9ybSxlLmFsaWdubWVudCx0LGUuZm9udCxzLGUudGV4dCxhLHIsZS5saW5lU3BhY2luZyksdH1tYWtlVGV4dExpbmUoZSx0LHIscyxhLG4sbCxoLHUpe2xldCBjPS0xLGY9MCxkPWgqbCxwPWQqLjUsbT1lLndpZHRoL2wsXz1lLmhlaWdodC9sLHY9MCx5PWUuaGVpZ2h0LEM9KCk9PntmPTAsYysrO2xldCBEPW5ldyBKYztyZXR1cm4gRC5pbmRleD1jLHIucHVzaChEKSxEfSxCPShELFApPT57Y29uc3QgTD1ELmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoKTtsZXQgST1nci5nZXRGbnQocyxoLEwpLE89bnVsbDtyZXR1cm4gST8oTz1GaS5zcGF3blF1YWQoKSxPLnNwcml0ZT1JLE8ueD0oZitJLnhvZmZzZXQpKmwtdixPLnk9KGEuYmFzZS1JLmhlaWdodC1JLnlvZmZzZXQtYS5iYXNlKSpsK3ksTy53aWR0aD1JLm9mZnNldFNpemUud2lkdGgqbCxPLmhlaWdodD1JLm9mZnNldFNpemUuaGVpZ2h0KmwsZis9SS54YWR2YW5jZSk6RD09YFxuYHx8KEQ9PVwiXHRcIj9mKz1kOmYrPXApLFAud2lkdGg9ZixQLnF1YWRMaXN0LnB1c2goTyksUC5jaGFyTGlzdC5wdXNoKEQpLE99LFQ9KCk9PntsZXQgRD10aGlzLmdldEFsaWdubWVudCh0KTtzd2l0Y2goRC52KXtjYXNlIDA6Zm9yKGxldCBQPTAsTD1yLmxlbmd0aDtQPEw7UCsrKXtsZXQgST1yW1BdO2lmKFA+MCl7bGV0IE89UCpkKnU7Zm9yKGxldCBrPTAsSD1JLnF1YWRMaXN0Lmxlbmd0aDtrPEg7aysrKXtsZXQgVz1JLnF1YWRMaXN0W2tdO1cmJihXLnktPU8pfX19YnJlYWs7Y2FzZSAxOmZvcihsZXQgUD0wLEw9ci5sZW5ndGg7UDxMO1ArKyl7bGV0IEk9cltQXSxPPShfLUwqaCp1KSouNSpsK1AqZCp1O2ZvcihsZXQgaz0wLEg9SS5xdWFkTGlzdC5sZW5ndGg7azxIO2srKyl7bGV0IFc9SS5xdWFkTGlzdFtrXTtXJiYoVy55LT1PKX19YnJlYWs7Y2FzZSAyOmZvcihsZXQgUD0wLEw9ci5sZW5ndGg7UDxMO1ArKyl7bGV0IEk9cltQXSxPPShfLUwqaCp1KSpsK1AqZCp1O2ZvcihsZXQgaz0wLEg9SS5xdWFkTGlzdC5sZW5ndGg7azxIO2srKyl7bGV0IFc9SS5xdWFkTGlzdFtrXTtXJiYoVy55LT1PKX19YnJlYWt9c3dpdGNoKEQuaCl7Y2FzZSAwOmJyZWFrO2Nhc2UgMTpmb3IobGV0IFA9MCxMPXIubGVuZ3RoO1A8TDtQKyspe2xldCBJPXJbUF0sTz0obS1JLndpZHRoKSouNSpsO2ZvcihsZXQgaz0wLEg9SS5xdWFkTGlzdC5sZW5ndGg7azxIO2srKyl7bGV0IFc9SS5xdWFkTGlzdFtrXTtXJiYoVy54Kz1PKX19YnJlYWs7Y2FzZSAyOmZvcihsZXQgUD0wLEw9ci5sZW5ndGg7UDxMO1ArKyl7bGV0IEk9cltQXSxPPShtLUkud2lkdGgpKmw7Zm9yKGxldCBrPTAsSD1JLnF1YWRMaXN0Lmxlbmd0aDtrPEg7aysrKXtsZXQgVz1JLnF1YWRMaXN0W2tdO1cmJihXLngrPU8pfX1icmVha319OygoKT0+e2xldCBEPW51bGwsUD1uLmxlbmd0aCxMPSExO2ZvcihsZXQgST0wO0k8UDtJKyspe0Q9PW51bGwmJihEPUMoKSk7bGV0IE89bi5jaGFyQXQoSSk7Tz09YFxuYHx8TD8oRD1udWxsLEw9ITEpOihCKE8sRCksTD1ELndpZHRoK2Q+PW0pfX0pKCksVCgpfWdldEFsaWdubWVudChlKXtsZXQgdD17djowLGg6MH07c3dpdGNoKGUpe2Nhc2UgMTp0LnY9MCx0Lmg9MTticmVhaztjYXNlIDA6dC52PTAsdC5oPTA7YnJlYWs7Y2FzZSAyOnQudj0wLHQuaD0yO2JyZWFrO2Nhc2UgNDp0LnY9MSx0Lmg9MTticmVhaztjYXNlIDM6dC52PTEsdC5oPTA7YnJlYWs7Y2FzZSA1OnQudj0xLHQuaD0yO2JyZWFrO2Nhc2UgNzp0LnY9Mix0Lmg9MTticmVhaztjYXNlIDY6dC52PTIsdC5oPTA7YnJlYWs7Y2FzZSA4OnQudj0yLHQuaD0yO2JyZWFrfXJldHVybiB0fX1jbGFzcyBiYSBleHRlbmRzIGxue2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxvKHRoaXMsXCJfc3R5bGVcIixEZS5OT1JNQUwpLG8odGhpcyxcIl9pbnRlcmFjdGl2ZVwiLCExKX1zZXQgaW50ZXJhY3RpdmUoZSl7dGhpcy5faW50ZXJhY3RpdmU9ZX1nZXQgaW50ZXJhY3RpdmUoKXtyZXR1cm4gdGhpcy5faW50ZXJhY3RpdmV9c2V0IG1vdXNlU3R5bGUoZSl7dGhpcy5fc3R5bGU9ZX1nZXQgaW50ZXJhY3RpdmVWaXNpYmxlKCl7cmV0dXJuIHRoaXMuX3VpVHJhbnNmb3JtLmdsb2JhbFZpc2libGUmJnRoaXMuX3Zpc2libGV9aW5pdChlKXtzdXBlci5pbml0KGUpLHRoaXMuX3VpVHJhbnNmb3JtLmFkZFVJSW50ZXJhY3RpdmUodGhpcyl9ZGVzdHJveSgpe3RoaXMuX3VpVHJhbnNmb3JtLnJlbW92ZVVJSW50ZXJhY3RpdmUodGhpcyksc3VwZXIuZGVzdHJveSgpfXJheVBpY2soZSx0LHIscyl7cmV0dXJuIEZ0LnJheVBpY2soZSxyLHMsdC5zcGFjZSx0aGlzLl91aVRyYW5zZm9ybSx0LnRyYW5zZm9ybS53b3JsZE1hdHJpeCl9Y2xvbmVUbyhlKXtlLmdldE9yQWRkQ29tcG9uZW50KGJhKS5jb3B5Q29tcG9uZW50KHRoaXMpfWNvcHlDb21wb25lbnQoZSl7cmV0dXJuIHN1cGVyLmNvcHlDb21wb25lbnQoZSksdGhpcy5lbmFibGU9ZS5fZW5hYmxlLHRoaXMuaW50ZXJhY3RpdmU9ZS5faW50ZXJhY3RpdmUsdGhpcy5tb3VzZVN0eWxlPWUuX3N0eWxlLHRoaXN9fXZhciAkYz0oaT0+KGlbaS5OT05FPTBdPVwiTk9ORVwiLGlbaS5DT0xPUj0xXT1cIkNPTE9SXCIsaVtpLlNQUklURT0yXT1cIlNQUklURVwiLGkpKSgkY3x8e30pO2NsYXNzIF9uIGV4dGVuZHMgYmF7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcIl9zcHJpdGVNYXBcIiksbyh0aGlzLFwiX2NvbG9yTWFwXCIpLG8odGhpcyxcIl9pbWFnZVwiKSxvKHRoaXMsXCJfaXNDcmVhdGVJbWFnZVwiKSxvKHRoaXMsXCJfdHJhbnNpdGlvblwiLDIpfWluaXQoZSl7c3VwZXIuaW5pdChlKSx0aGlzLl9pbnRlcmFjdGl2ZT0hMCx0aGlzLl9zcHJpdGVNYXA9bmV3IE1hcCx0aGlzLl9jb2xvck1hcD1uZXcgTWFwLHRoaXMuX2ltYWdlPXRoaXMub2JqZWN0M0QuZ2V0Q29tcG9uZW50KFZpKSx0aGlzLl9pc0NyZWF0ZUltYWdlPXRoaXMuX2ltYWdlPT1udWxsLHRoaXMuX2ltYWdlfHwodGhpcy5faW1hZ2U9dGhpcy5vYmplY3QzRC5hZGRDb21wb25lbnQoVmkpKSx0aGlzLmltYWdlVHlwZT1wci5TbGljZWR9b25FbmFibGUoKXt0aGlzLm1vdXNlU3R5bGU9RGUuTk9STUFMfW9uRGlzYWJsZSgpe3RoaXMubW91c2VTdHlsZT1EZS5ESVNBQkxFfXNldCB0cmFuc2l0aW9uKGUpe3RoaXMuX3RyYW5zaXRpb24hPWUmJih0aGlzLl90cmFuc2l0aW9uPWUsdGhpcy52YWxpZGF0ZVN0eWxlKHRoaXMuX3N0eWxlLCEwKSl9Z2V0IHRyYW5zaXRpb24oKXtyZXR1cm4gdGhpcy5fdHJhbnNpdGlvbn1nZXQgaW1hZ2VUeXBlKCl7cmV0dXJuIHRoaXMuX2ltYWdlLmltYWdlVHlwZX1zZXQgaW1hZ2VUeXBlKGUpe3RoaXMuX2ltYWdlLmltYWdlVHlwZT1lfXNldFN0eWxlQ29sb3IoZSx0KXtyZXR1cm4gdGhpcy5fY29sb3JNYXAuc2V0KGUsdCksdGhpcy5fc3R5bGU9PWUmJnRoaXMudmFsaWRhdGVTdHlsZSh0aGlzLl9zdHlsZSwhMCksdGhpc31nZXRTdHlsZUNvbG9yKGUpe3JldHVybiB0aGlzLl9jb2xvck1hcC5nZXQoZSl9c2V0IG1vdXNlU3R5bGUoZSl7c3VwZXIubW91c2VTdHlsZT1lLHRoaXMudmFsaWRhdGVTdHlsZShlLCEwKX1nZXQgbm9ybWFsU3ByaXRlKCl7cmV0dXJuIHRoaXMuX3Nwcml0ZU1hcC5nZXQoRGUuTk9STUFMKX1zZXQgbm9ybWFsU3ByaXRlKGUpe3RoaXMuX3Nwcml0ZU1hcC5zZXQoRGUuTk9STUFMLGUpLHRoaXMuX3N0eWxlPT1EZS5OT1JNQUwmJnRoaXMudmFsaWRhdGVTdHlsZSh0aGlzLl9zdHlsZSwhMCl9Z2V0IG92ZXJTcHJpdGUoKXtyZXR1cm4gdGhpcy5fc3ByaXRlTWFwLmdldChEZS5PVkVSKX1zZXQgb3ZlclNwcml0ZShlKXt0aGlzLl9zcHJpdGVNYXAuc2V0KERlLk9WRVIsZSksdGhpcy5fc3R5bGU9PURlLk9WRVImJnRoaXMudmFsaWRhdGVTdHlsZSh0aGlzLl9zdHlsZSwhMCl9c2V0IGRvd25TcHJpdGUoZSl7dGhpcy5fc3ByaXRlTWFwLnNldChEZS5ET1dOLGUpLHRoaXMuX3N0eWxlPT1EZS5ET1dOJiZ0aGlzLnZhbGlkYXRlU3R5bGUodGhpcy5fc3R5bGUsITApfWdldCBkb3duU3ByaXRlKCl7cmV0dXJuIHRoaXMuX3Nwcml0ZU1hcC5nZXQoRGUuRE9XTil9c2V0IGRpc2FibGVTcHJpdGUoZSl7dGhpcy5fc3ByaXRlTWFwLnNldChEZS5ESVNBQkxFLGUpLHRoaXMuX3N0eWxlPT1EZS5ESVNBQkxFJiZ0aGlzLnZhbGlkYXRlU3R5bGUodGhpcy5fc3R5bGUsITApfWdldCBkaXNhYmxlU3ByaXRlKCl7cmV0dXJuIHRoaXMuX3Nwcml0ZU1hcC5nZXQoRGUuRElTQUJMRSl9dmFsaWRhdGVTdHlsZShlLHQpe2lmKHRoaXMuX3RyYW5zaXRpb24mMil7bGV0IHI9dGhpcy5fc3ByaXRlTWFwLmdldChlKTt0aGlzLl9pbWFnZS5zcHJpdGU9cn1pZih0aGlzLl90cmFuc2l0aW9uJjEpe2xldCByPXRoaXMuX2NvbG9yTWFwLmdldChlKTtyJiYodGhpcy5faW1hZ2UuY29sb3I9cil9fWNsb25lVG8oZSl7ZS5nZXRPckFkZENvbXBvbmVudChfbikuY29weUNvbXBvbmVudCh0aGlzKX1jb3B5Q29tcG9uZW50KGUpe3JldHVybiBzdXBlci5jb3B5Q29tcG9uZW50KGUpLHRoaXMuaW1hZ2VUeXBlPWUuaW1hZ2VUeXBlLHRoaXMudHJhbnNpdGlvbj1lLnRyYW5zaXRpb24sZS5fc3ByaXRlTWFwLmZvckVhY2goKHQscik9Pnt0JiZ0aGlzLl9zcHJpdGVNYXAuc2V0KHIsdCl9KSxlLl9jb2xvck1hcC5mb3JFYWNoKCh0LHIpPT57dCYmdGhpcy5fY29sb3JNYXAuc2V0KHIsdC5jbG9uZSgpKX0pLHRoaXMubW91c2VTdHlsZT1lLm1vdXNlU3R5bGUsdGhpc31kZXN0cm95KCl7dGhpcy5faXNDcmVhdGVJbWFnZSYmdGhpcy5faW1hZ2UmJih0aGlzLm9iamVjdDNELnJlbW92ZUNvbXBvbmVudChWaSksdGhpcy5faW1hZ2U9bnVsbCksc3VwZXIuZGVzdHJveSgpfX1jbGFzcyB4biBleHRlbmRzIGNze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJfY291bnRcIiwwKX1pbml0KGUpe3ZhciB0Oyh0PXN1cGVyLmluaXQpPT1udWxsfHx0LmNhbGwodGhpcyxlKSx0aGlzLl9jb3VudD1lP2UuY291bnQ6MTtmb3IobGV0IHI9MDtyPHRoaXMuX2NvdW50O3IrKyl0aGlzLmF0dGFjaFF1YWQoRmkuc3Bhd25RdWFkKCkpO3RoaXMuX3VpVHJhbnNmb3JtLnJlc2l6ZSgwLDApfWdldFF1YWQoZSl7cmV0dXJuIHRoaXMuX21haW5RdWFkc1tlXX1jbG9uZVRvKGUpe2UuYWRkQ29tcG9uZW50KHhuLHtjb3VudDp0aGlzLl9jb3VudH0pLmNvcHlDb21wb25lbnQodGhpcyl9Y29weUNvbXBvbmVudChlKXtzdXBlci5jb3B5Q29tcG9uZW50KGUpO2ZvcihsZXQgdD0wO3Q8ZS5fY291bnQ7dCsrKXRoaXMuc2V0U3ByaXRlKHQsZS5nZXRTcHJpdGUodCkpLHRoaXMuc2V0Q29sb3IodCxlLmdldENvbG9yKHQpKSx0aGlzLnNldEltYWdlVHlwZSh0LGUuZ2V0SW1hZ2VUeXBlKHQpKTtyZXR1cm4gdGhpc31zZXRTcHJpdGUoZSx0KXt0aGlzLl9tYWluUXVhZHNbZV0uc3ByaXRlPXR8fEEucmVzLmRlZmF1bHRHVUlTcHJpdGUsdGhpcy5zZXRTaGFkb3dEaXJ0eSgpfWdldFNwcml0ZShlKXtyZXR1cm4gdGhpcy5fbWFpblF1YWRzW2VdLnNwcml0ZX1vblVJQ29tcG9uZW50VmlzaWJsZShlKXt0aGlzLmFwcGx5Q29tcG9uZW50VmlzaWJsZSgpfW9uVUlUcmFuc2Zvcm1WaXNpYmxlKGUpe3RoaXMuYXBwbHlDb21wb25lbnRWaXNpYmxlKCl9YXBwbHlDb21wb25lbnRWaXNpYmxlKCl7bGV0IGU9IXRoaXMuX3Zpc2libGV8fCF0aGlzLl91aVRyYW5zZm9ybS5nbG9iYWxWaXNpYmxlO2ZvcihsZXQgdCBvZiB0aGlzLl9tYWluUXVhZHMpdC52aXNpYmxlPSFlO3RoaXMuc2V0U2hhZG93RGlydHkoKX1nZXRDb2xvcihlKXtyZXR1cm4gdGhpcy5fbWFpblF1YWRzW2VdLmNvbG9yfXNldENvbG9yKGUsdCl7dGhpcy5fbWFpblF1YWRzW2VdLmNvbG9yPXQsdGhpcy5zZXRTaGFkb3dEaXJ0eSgpfWdldEltYWdlVHlwZShlKXtyZXR1cm4gdGhpcy5fbWFpblF1YWRzW2VdLmltYWdlVHlwZX1zZXRJbWFnZVR5cGUoZSx0KXt0aGlzLl9tYWluUXVhZHNbZV0uaW1hZ2VUeXBlPXQsdGhpcy5zZXRTaGFkb3dEaXJ0eSgpfXNldFNpemUoZSx0LHIpe3RoaXMuX21haW5RdWFkc1tlXS5zZXRTaXplKHQsciksdGhpcy5zZXRTaGFkb3dEaXJ0eSgpfXNldFhZKGUsdCxyKXt0aGlzLl9tYWluUXVhZHNbZV0uc2V0WFkodCxyKSx0aGlzLnNldFNoYWRvd0RpcnR5KCl9Z2V0WFkoZSx0KXt0fHwodD1uZXcgWik7bGV0IHI9dGhpcy5fbWFpblF1YWRzW2VdO3JldHVybiB0Lng9ci54LHQueT1yLnksdH19Y2xhc3Mgdm4gZXh0ZW5kcyBjc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwiX3NoYWRvd1F1YWxpdHlcIiwxKSxvKHRoaXMsXCJfc2hhZG93T2Zmc2V0XCIpLG8odGhpcyxcIl9zaGFkb3dSYWRpdXNcIiksbyh0aGlzLFwiX3NoYWRvd0NvbG9yXCIpLG8odGhpcyxcIl9zdWJTaGFkb3dDb2xvclwiKSxvKHRoaXMsXCJuZWVkVXBkYXRlU2hhZG93XCIsITEpfWluaXQoZSl7dmFyIHQ7KHQ9c3VwZXIuaW5pdCk9PW51bGx8fHQuY2FsbCh0aGlzLGUpLHRoaXMuX3NoYWRvd1JhZGl1cz0yLHRoaXMuX3NoYWRvd1F1YWxpdHk9MSx0aGlzLl9zaGFkb3dPZmZzZXQ9bmV3IFooNCwtNCksdGhpcy5fc2hhZG93Q29sb3I9bmV3IHooLjEsLjEsLjEsLjgpLHRoaXMuX3N1YlNoYWRvd0NvbG9yPXRoaXMuX3NoYWRvd0NvbG9yLmNsb25lKCksdGhpcy5pc1VJU2hhZG93PSEwfWNsb25lVG8oZSl7ZS5nZXRPckFkZENvbXBvbmVudCh2bikuY29weUNvbXBvbmVudCh0aGlzKX1jb3B5Q29tcG9uZW50KGUpe3JldHVybiBzdXBlci5jb3B5Q29tcG9uZW50KHRoaXMpLHRoaXMuX3NoYWRvd0NvbG9yPWUuX3NoYWRvd0NvbG9yLHRoaXMuX3NoYWRvd09mZnNldD1lLl9zaGFkb3dPZmZzZXQsdGhpcy5fc2hhZG93UmFkaXVzPWUuX3NoYWRvd1JhZGl1cyx0aGlzLl9zaGFkb3dRdWFsaXR5PWUuc2hhZG93UXVhbGl0eSx0aGlzfWdldCBzaGFkb3dDb2xvcigpe3JldHVybiB0aGlzLl9zaGFkb3dDb2xvcn1zZXQgc2hhZG93Q29sb3IoZSl7dGhpcy5fc2hhZG93Q29sb3IuY29weUZyb20oZSksdGhpcy5uZWVkVXBkYXRlU2hhZG93PSEwfXNldCBzaGFkb3dRdWFsaXR5KGUpe2U9SyhlLDAsNCksdGhpcy5fc2hhZG93UXVhbGl0eSE9ZSYmKHRoaXMuX3NoYWRvd1F1YWxpdHk9ZSx0aGlzLm5lZWRVcGRhdGVTaGFkb3c9ITApfWdldCBzaGFkb3dRdWFsaXR5KCl7cmV0dXJuIHRoaXMuX3NoYWRvd1F1YWxpdHl9c2V0IHNoYWRvd09mZnNldChlKXt0aGlzLl9zaGFkb3dPZmZzZXQ9ZSx0aGlzLm5lZWRVcGRhdGVTaGFkb3c9ITB9Z2V0IHNoYWRvd09mZnNldCgpe3JldHVybiB0aGlzLl9zaGFkb3dPZmZzZXR8fCh0aGlzLl9zaGFkb3dPZmZzZXQ9bmV3IFooNCwtNCkpLHRoaXMuX3NoYWRvd09mZnNldH1zZXQgc2hhZG93UmFkaXVzKGUpe3RoaXMuX3NoYWRvd1JhZGl1cyE9ZSYmKHRoaXMuX3NoYWRvd1JhZGl1cz1lLHRoaXMuYXBwbHlTaGFkb3coKSl9Z2V0IHNoYWRvd1JhZGl1cygpe3JldHVybiB0aGlzLl9zaGFkb3dSYWRpdXN9b25VcGRhdGUoZSl7dGhpcy5uZWVkVXBkYXRlU2hhZG93JiYodGhpcy5hcHBseVNoYWRvdygpLHRoaXMubmVlZFVwZGF0ZVNoYWRvdz0hMSl9YXBwbHlTaGFkb3coKXtpZih0aGlzLmRldGFjaFF1YWRzKCksdGhpcy5fc2hhZG93U291cmNlJiZ0aGlzLl9zaGFkb3dRdWFsaXR5PjApe2xldCBlPXRoaXMuX3NoYWRvd1NvdXJjZS5tYWluUXVhZHM7aWYoZS5sZW5ndGg+MClmb3IobGV0IHQgb2YgZSl0aGlzLmNyZWF0ZVF1YWRTaGFkb3codCl9dGhpcy5fdWlUcmFuc2Zvcm0uc2V0TmVlZFVwZGF0ZVVJUGFuZWwoKX1jcmVhdGVRdWFkU2hhZG93KGUpe2xldCB0PXRoaXMuX3NoYWRvd1F1YWxpdHkscj1NYXRoLlBJKjI7dGhpcy5fc3ViU2hhZG93Q29sb3IuY29weUZyb20odGhpcy5fc2hhZG93Q29sb3IpLHRoaXMuX3N1YlNoYWRvd0NvbG9yLmE9MS9NYXRoLm1heCgxLHQpO2ZvcihsZXQgcz0wO3M8dDtzKyspe2xldCBhPUZpLnNwYXduUXVhZCgpLG49MCxsPTA7aWYocz09MClhLmNvbG9yPXRoaXMuX3NoYWRvd0NvbG9yO2Vsc2V7bGV0IGg9cioocy0xKS8odC0xKTtuPU1hdGguc2luKGgpKnRoaXMuX3NoYWRvd1JhZGl1cyxsPU1hdGguY29zKGgpKnRoaXMuX3NoYWRvd1JhZGl1cyxhLmNvbG9yPXRoaXMuX3N1YlNoYWRvd0NvbG9yfWEuc2V0WFkobit0aGlzLl9zaGFkb3dPZmZzZXQueCtlLngsbCt0aGlzLl9zaGFkb3dPZmZzZXQueStlLnkpLGEuc2V0U2l6ZShlLndpZHRoLGUuaGVpZ2h0KSxhLnNwcml0ZT1lLnNwcml0ZSxhLnZpc2libGU9ZS52aXNpYmxlLGEuaW1hZ2VUeXBlPWUuaW1hZ2VUeXBlLHRoaXMuYXR0YWNoUXVhZChhKX19fWNsYXNzIHluIGV4dGVuZHMgY3N7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcIl9mb250XCIsXCJcXHU1RkFFXFx1OEY2RlxcdTk2QzVcXHU5RUQxXCIpLG8odGhpcyxcIl9mb250U2l6ZVwiLDE0KSxvKHRoaXMsXCJfb3JpZ2luU2l6ZVwiLDQyKSxvKHRoaXMsXCJfYWxpZ25tZW50XCIsMCksbyh0aGlzLFwiX2xpbmVTcGFjaW5nXCIsMSksbyh0aGlzLFwiX3RleHRcIixcIlwiKSxvKHRoaXMsXCJfY29sb3JcIixuZXcgeigxLDEsMSwxKSksbyh0aGlzLFwidGV4dExpbmVcIixudWxsKSxvKHRoaXMsXCJsYXlvdXRQcm94eVwiLG5ldyBaYyl9Y2xvbmVUbyhlKXtlLmdldE9yQWRkQ29tcG9uZW50KHluKS5jb3B5Q29tcG9uZW50KHRoaXMpfWNvcHlDb21wb25lbnQoZSl7cmV0dXJuIHN1cGVyLmNvcHlDb21wb25lbnQoZSksdGhpcy5fZm9udD1lLl9mb250LHRoaXMuX2ZvbnRTaXplPWUuX2ZvbnRTaXplLHRoaXMuX29yaWdpblNpemU9ZS5fb3JpZ2luU2l6ZSx0aGlzLl9hbGlnbm1lbnQ9ZS5fYWxpZ25tZW50LHRoaXMuX2xpbmVTcGFjaW5nPWUuX2xpbmVTcGFjaW5nLHRoaXMuX2NvbG9yLmNvcHlGcm9tKGUuX2NvbG9yKSx0aGlzLnRleHQ9ZS50ZXh0LHRoaXN9Z2V0IG9yaWdpblNpemUoKXtyZXR1cm4gdGhpcy5fb3JpZ2luU2l6ZX1nZXQgZm9udCgpe3JldHVybiB0aGlzLl9mb250fXNldCBmb250KGUpe3RoaXMuX2ZvbnQ9ZX1nZXQgZm9udFNpemUoKXtyZXR1cm4gdGhpcy5fZm9udFNpemV9c2V0IGZvbnRTaXplKGUpe3RoaXMuX2ZvbnRTaXplIT1lJiYodGhpcy5fZm9udFNpemU9ZSx0aGlzLmxheW91dFRleHQoKSl9Z2V0IHRleHQoKXtyZXR1cm4gdGhpcy5fdGV4dH1zZXQgdGV4dChlKXt0aGlzLl90ZXh0IT1lJiYoZXx8KGU9XCJcIiksdGhpcy5fdGV4dD1lLHRoaXMubGF5b3V0VGV4dCgpKX1sYXlvdXRUZXh0KCl7dGhpcy5kZXRhY2hRdWFkcygpLHRoaXMudGV4dExpbmU9dGhpcy5sYXlvdXRQcm94eS5sYXlvdXQodGhpcyk7Zm9yKGxldCBlPTAsdD10aGlzLnRleHRMaW5lLmxlbmd0aDtlPHQ7ZSsrKXtsZXQgcj10aGlzLnRleHRMaW5lW2VdO2ZvcihsZXQgcz0wLGE9ci5xdWFkTGlzdC5sZW5ndGg7czxhO3MrKyl7bGV0IG49ci5xdWFkTGlzdFtzXTtuJiZ0aGlzLmF0dGFjaFF1YWQobil9fXRoaXMuY29sb3I9dGhpcy5fY29sb3IsdGhpcy5fdWlUcmFuc2Zvcm0uc2V0TmVlZFVwZGF0ZVVJUGFuZWwoKSx0aGlzLm9uVUlDb21wb25lbnRWaXNpYmxlKHRoaXMuX3Zpc2libGUpLHRoaXMuc2V0U2hhZG93RGlydHkoKX1vblVJQ29tcG9uZW50VmlzaWJsZShlKXt0aGlzLmFwcGx5Q29tcG9uZW50VmlzaWJsZSgpfW9uVUlUcmFuc2Zvcm1WaXNpYmxlKGUpe3RoaXMuYXBwbHlDb21wb25lbnRWaXNpYmxlKCl9YXBwbHlDb21wb25lbnRWaXNpYmxlKCl7bGV0IGU9IXRoaXMuX3Zpc2libGV8fCF0aGlzLl91aVRyYW5zZm9ybS5nbG9iYWxWaXNpYmxlO2ZvcihsZXQgdCBvZiB0aGlzLl9tYWluUXVhZHMpdCYmKHQudmlzaWJsZT0hZSk7dGhpcy5zZXRTaGFkb3dEaXJ0eSgpfW9uVHJhbnNmb3JtUmVzaXplKCl7dGhpcy5sYXlvdXRUZXh0KCl9Z2V0IGNvbG9yKCl7cmV0dXJuIHRoaXMuX2NvbG9yfXNldCBjb2xvcihlKXt0aGlzLl9jb2xvci5jb3B5RnJvbShlKTtmb3IobGV0IHQgb2YgdGhpcy5fbWFpblF1YWRzKXQuY29sb3I9ZTt0aGlzLnNldFNoYWRvd0RpcnR5KCl9Z2V0IGFsaWdubWVudCgpe3JldHVybiB0aGlzLl9hbGlnbm1lbnR9c2V0IGFsaWdubWVudChlKXt0aGlzLl9hbGlnbm1lbnQhPWUmJih0aGlzLl9hbGlnbm1lbnQ9ZSx0aGlzLmxheW91dFRleHQoKSl9Z2V0IGxpbmVTcGFjaW5nKCl7cmV0dXJuIHRoaXMuX2xpbmVTcGFjaW5nfXNldCBsaW5lU3BhY2luZyhlKXt0aGlzLl9saW5lU3BhY2luZyE9ZSYmKHRoaXMuX2xpbmVTcGFjaW5nPWUsdGhpcy5sYXlvdXRUZXh0KCkpfX1jbGFzcyBicCBleHRlbmRzIEVle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxvKHRoaXMsXCJfcG9zdExpc3RcIil9aW5pdChlKXt0aGlzLl9wb3N0TGlzdD1uZXcgTWFwfXN0YXJ0KCl7fXN0b3AoKXt9b25FbmFibGUoKXt0aGlzLmFjdGl2ZVBvc3QoKX1vbkRpc2FibGUoKXt0aGlzLnVuQWN0aXZlUG9zdCgpfWFjdGl2ZVBvc3QoKXtsZXQgZT10aGlzLnRyYW5zZm9ybS52aWV3M0QsdD1BLmdldFJlbmRlckpvYihlKTt0aGlzLl9wb3N0TGlzdC5mb3JFYWNoKHI9Pnt0LmFkZFBvc3Qocil9KX11bkFjdGl2ZVBvc3QoKXtsZXQgZT10aGlzLnRyYW5zZm9ybS52aWV3M0QsdD1BLmdldFJlbmRlckpvYihlKTt0aGlzLl9wb3N0TGlzdC5mb3JFYWNoKHI9Pnt0LnJlbW92ZVBvc3Qocil9KX1hZGRQb3N0KGUpe2lmKHRoaXMuX3Bvc3RMaXN0LmhhcyhlLnByb3RvdHlwZSkpcmV0dXJuO2xldCB0PW5ldyBlO3JldHVybiB0aGlzLl9wb3N0TGlzdC5zZXQoZS5wcm90b3R5cGUsdCksdGhpcy5fZW5hYmxlJiZ0aGlzLmFjdGl2ZVBvc3QoKSx0fXJlbW92ZVBvc3QoZSl7aWYoIXRoaXMuX3Bvc3RMaXN0LmhhcyhlLnByb3RvdHlwZSkpcmV0dXJuO2xldCB0PXRoaXMuX3Bvc3RMaXN0LmdldChlLnByb3RvdHlwZSk7dGhpcy5fcG9zdExpc3QuZGVsZXRlKGUucHJvdG90eXBlKTtsZXQgcj10aGlzLnRyYW5zZm9ybS52aWV3M0Q7QS5nZXRSZW5kZXJKb2IocikucmVtb3ZlUG9zdCh0KX1nZXRQb3N0KGUpe3JldHVybiB0aGlzLl9wb3N0TGlzdC5oYXMoZS5wcm90b3R5cGUpP3RoaXMuX3Bvc3RMaXN0LmdldChlLnByb3RvdHlwZSk6bnVsbH19Y2xhc3MgZWYgZXh0ZW5kcyB0ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiaW5kZXhcIiwwKSxvKHRoaXMsXCJkcmF3Q2FsbEZyYW1lXCIsLTEpfX12YXIgdW49KGk9PihpW2kuQ2FzdEdJPTBdPVwiQ2FzdEdJXCIsaVtpLlJlY2VpdmVHST0xXT1cIlJlY2VpdmVHSVwiLGlbaS5DYXN0RGVwdGg9Ml09XCJDYXN0RGVwdGhcIixpW2kuT3RoZXI9M109XCJPdGhlclwiLGkpKSh1bnx8e30pO2NsYXNzIGNuIGV4dGVuZHMgb3N7Y29uc3RydWN0b3IoZT0wLHQ9MCl7c3VwZXIoKSxOLnJlZ2lzdGVyKFwiR0lQcm9iZVNoYWRlclwiLHljKSx0aGlzLmRlZmF1bHRQYXNzPW5ldyBXZShcIkdJUHJvYmVTaGFkZXJcIixcIkdJUHJvYmVTaGFkZXJcIiksdGhpcy5kZWZhdWx0UGFzcy5zZXREZWZpbmUoXCJVU0VfQlJERlwiLCEwKSx0aGlzLmRlZmF1bHRQYXNzLnNldFNoYWRlckVudHJ5KFwiVmVydE1haW5cIixcIkZyYWdNYWluXCIpLHRoaXMuZGVmYXVsdFBhc3Muc2V0VW5pZm9ybVZlY3RvcjQoXCJwcm9iZVVuaWZvcm1cIixuZXcgaih0LGUsMCwwKSk7bGV0IHI9dGhpcy5kZWZhdWx0UGFzcy5zaGFkZXJTdGF0ZTtyLmFjY2VwdFNoYWRvdz0hMSxyLmNhc3RTaGFkb3c9ITEsci5yZWNlaXZlRW52PSExLHIuYWNjZXB0R0k9ITEsci51c2VMaWdodD0hMTtsZXQgcz1BLnJlcy5nZXRUZXh0dXJlKFwiQlJERkxVVFwiKTt0aGlzLmJyZGZMVVQ9cyx0aGlzLmJhc2VNYXA9QS5yZXMud2hpdGVUZXh0dXJlLHRoaXMubm9ybWFsTWFwPUEucmVzLm5vcm1hbFRleHR1cmUsdGhpcy5lbWlzc2l2ZU1hcD1BLnJlcy5ibGFja1RleHR1cmV9ZGVidWcoKXt9fW8oY24sXCJjb3VudFwiLDApO2NsYXNzIFNwIGV4dGVuZHMgRWV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLG8odGhpcyxcIl9wcm9iZXNcIiksbyh0aGlzLFwiX3ZvbHVtZVwiKSxvKHRoaXMsXCJfZGVidWdNclwiLFtdKX1pbml0KCl7QS5zZXR0aW5nLmdpLmVuYWJsZT0hMH1zdGFydCgpe3RoaXMuX3ZvbHVtZT1wZS5nZXRMaWdodEVudHJpZXModGhpcy50cmFuc2Zvcm0uc2NlbmUzRCkuaXJyYWRpYW5jZVZvbHVtZSx0aGlzLmluaXRQcm9iZSgpfWluaXRQcm9iZSgpe2xldCBlPXRoaXMuX3ZvbHVtZS5zZXR0aW5nLnByb2JlWENvdW50LHQ9dGhpcy5fdm9sdW1lLnNldHRpbmcucHJvYmVZQ291bnQscj10aGlzLl92b2x1bWUuc2V0dGluZy5wcm9iZVpDb3VudCxzPW5ldyBscyg0LDE2LDE2KSxhPW5ldyBnO3RoaXMuX3Byb2Jlcz1bXTtmb3IobGV0IG49MDtuPGU7bisrKWZvcihsZXQgbD0wO2w8dDtsKyspZm9yKGxldCBoPTA7aDxyO2grKyl7bGV0IHU9bitoKmUrbCooZSpyKSxjPW5ldyBlZjtjLmluZGV4PXUsYy5uYW1lPWAke259XyR7bH1fJHtofWA7bGV0IGY9Yy5hZGRDb21wb25lbnQoY2UpO2YubWF0ZXJpYWw9bmV3IGNuKHVuLkNhc3RHSSx1KSxmLmdlb21ldHJ5PXMsZi5jYXN0R0k9ITEsZi5jYXN0U2hhZG93PSExLHRoaXMuX2RlYnVnTXIucHVzaChmKSx0aGlzLm9iamVjdDNELmFkZENoaWxkKGMpLHRoaXMuX3ZvbHVtZS5jYWxjUG9zaXRpb24obixsLGgsYSksYy54PWEueCxjLnk9YS55LGMuej1hLnosdGhpcy5fcHJvYmVzW3VdPWMsdGhpcy5fZGVidWdNci5wdXNoKGYpfWZvcihsZXQgbj0wO248dGhpcy5fcHJvYmVzLmxlbmd0aDtuKyspUS5pbnN0YW5jZS5hZGRHSVByb2JlKHRoaXMudHJhbnNmb3JtLnNjZW5lM0QsdGhpcy5fcHJvYmVzW25dKTt0aGlzLm9iamVjdDNELnRyYW5zZm9ybS5lbmFibGU9ITEsdGhpcy5fdm9sdW1lLnNldHRpbmcuZGVidWcmJnRoaXMuZGVidWcoKX1kZWJ1Zygpe31kZWJ1Z1Byb2JlUmF5KGUsdCl7Y29uc3Qgcj1BLnNldHRpbmcuZ2kucmF5TnVtYmVyO2xldCBzPW5ldyBxKDAsLS43MDcxMDY3ODExODY1NDc1LC43MDcxMDY3ODExODY1NDc1LDApO2ZvcihsZXQgYT0wO2E8cjthKyspe2xldCBuPWUqcithLGw9bmV3IGcoLXRbbio0KzBdLC10W24qNCsxXSwtdFtuKjQrMl0sMCk7cy50cmFuc2Zvcm1WZWN0b3IobCxsKTtsZXQgaD10W24qNCszXSx1PXRoaXMuX3Byb2Jlc1tlXS50cmFuc2Zvcm0ud29ybGRQb3NpdGlvbi5jbG9uZSgpLGM9bC5zY2FsZUJ5KGgpO2MuYWRkKHUsYyl9fWNoYW5nZVByb2Jlc1ZvbHVtZURhdGEoKXt0aGlzLl92b2x1bWUuc2V0Vm9sdW1lRGF0YUNoYW5nZSgpfWNoYW5nZVByb2Jlc1Bvc2l0aW9uKCl7dGhpcy5fdm9sdW1lLnNldFZvbHVtZURhdGFDaGFuZ2UoKTtsZXQgZT10aGlzLl92b2x1bWUuc2V0dGluZy5wcm9iZVhDb3VudCx0PXRoaXMuX3ZvbHVtZS5zZXR0aW5nLnByb2JlWUNvdW50LHI9dGhpcy5fdm9sdW1lLnNldHRpbmcucHJvYmVaQ291bnQscz1uZXcgZztmb3IobGV0IGE9MDthPGU7YSsrKWZvcihsZXQgbj0wO248dDtuKyspZm9yKGxldCBsPTA7bDxyO2wrKyl7bGV0IGg9YStsKmUrbiooZSpyKSx1PXRoaXMuX3Byb2Jlc1toXTt0aGlzLl92b2x1bWUuY2FsY1Bvc2l0aW9uKGEsbixsLHMpLHUueD1zLngsdS55PXMueSx1Lno9cy56fX1vblVwZGF0ZSgpe0Euc2V0dGluZy5naS5tYXhEaXN0YW5jZT1BLnNldHRpbmcuZ2kucHJvYmVTcGFjZSoxLjU7bGV0IGU9dGhpcy50cmFuc2Zvcm0uc2NlbmUzRC52aWV3LmNhbWVyYSx0PWcuZGlzdGFuY2UoZS50cmFuc2Zvcm0ud29ybGRQb3NpdGlvbixlLnRyYW5zZm9ybS50YXJnZXRQb3MpLzMwMDtpZih0aGlzLl9kZWJ1Z01yJiZ0aGlzLl9kZWJ1Z01yLmxlbmd0aD4wKWZvcihsZXQgcj0wO3I8dGhpcy5fZGVidWdNci5sZW5ndGg7cisrKXtjb25zdCBzPXRoaXMuX2RlYnVnTXJbcl0udHJhbnNmb3JtO3Muc2NhbGVYPXQscy5zY2FsZVk9dCxzLnNjYWxlWj10fX19Y2xhc3MgSXAgZXh0ZW5kcyAkdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwiX2tleVJlbmRlckdyb3VwXCIpLG8odGhpcyxcIl9rZXlCdWZmZXJHcm91cFwiKSxvKHRoaXMsXCJfa2V5SWRzR3JvdXBcIil9aW5pdChlKXt0aGlzLl9rZXlSZW5kZXJHcm91cD1uZXcgTWFwLHRoaXMuX2tleUJ1ZmZlckdyb3VwPW5ldyBNYXAsdGhpcy5fa2V5SWRzR3JvdXA9bmV3IE1hcH1zdGFydCgpe2xldCBlPVtdO3RoaXMub2JqZWN0M0QuZ2V0Q29tcG9uZW50cyhjZSxlLCEwKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgcj1lW3RdO3IudHJhbnNmb3JtLnVwZGF0ZVdvcmxkTWF0cml4KCEwKSxyLmVuYWJsZT0hMTtsZXQgcz1yLmdlb21ldHJ5Lmluc3RhbmNlSUQ7Zm9yKGxldCBhPTA7YTxyLm1hdGVyaWFscy5sZW5ndGg7YSsrKXtjb25zdCBuPXIubWF0ZXJpYWxzW2FdO3MrPW4uaW5zdGFuY2VJRH1pZih0aGlzLl9rZXlSZW5kZXJHcm91cC5oYXMocykpdGhpcy5fa2V5UmVuZGVyR3JvdXAuZ2V0KHMpLnB1c2gociksdGhpcy5fa2V5SWRzR3JvdXAuZ2V0KHMpLnB1c2goci50cmFuc2Zvcm0ud29ybGRNYXRyaXguaW5kZXgpO2Vsc2V7bGV0IGE9bmV3IGdlKGUubGVuZ3RoKTthLnZpc2liaWxpdHk9R1BVU2hhZGVyU3RhZ2UuVkVSVEVYLHRoaXMuX2tleVJlbmRlckdyb3VwLnNldChzLFtyXSksdGhpcy5fa2V5QnVmZmVyR3JvdXAuc2V0KHMsYSksdGhpcy5fa2V5SWRzR3JvdXAuc2V0KHMsW3IudHJhbnNmb3JtLndvcmxkTWF0cml4LmluZGV4XSl9fXRoaXMuX2tleUJ1ZmZlckdyb3VwLmZvckVhY2goKHQscik9PntsZXQgcz10aGlzLl9rZXlJZHNHcm91cC5nZXQociksYT10aGlzLl9rZXlCdWZmZXJHcm91cC5nZXQocik7YS5zZXRJbnQzMkFycmF5KFwibWF0cml4SURzXCIsbmV3IEludDMyQXJyYXkocykpLGEuYXBwbHkoKX0pfXN0b3AoKXt9bm9kZVVwZGF0ZShlLHQscixzKXt0aGlzLl9rZXlSZW5kZXJHcm91cC5mb3JFYWNoKChhLG4pPT57bGV0IGw9dGhpcy5fa2V5QnVmZmVyR3JvdXAuZ2V0KG4pLGg9YVswXTtmb3IobGV0IHU9MDt1PGgubWF0ZXJpYWxzLmxlbmd0aDt1Kyspe2xldCBmPWgubWF0ZXJpYWxzW3VdLmdldFBhc3ModCk7aWYoZilmb3IobGV0IGQ9MDtkPGYubGVuZ3RoO2QrKyl7Y29uc3QgcD1mW2RdO3Auc2V0RGVmaW5lKFwiVVNFX0lOU1RBTkNFRFJBV1wiLCEwKSxwLnNldFN0b3JhZ2VCdWZmZXIoXCJpbnN0YW5jZURyYXdJRFwiLGwpfX1oLm5vZGVVcGRhdGUoZSx0LHIscyl9KSx0aGlzLnByZUluaXQ9ITF9cmVuZGVyUGFzcyhlLHQscil7dGhpcy5fa2V5UmVuZGVyR3JvdXAuZm9yRWFjaCgocyxhKT0+e2xldCBuPXNbMF07bi5pbnN0YW5jZUNvdW50PXMubGVuZ3RoLHRoaXMucmVuZGVySXRlbShlLHQsbixyKX0pfXJlbmRlckl0ZW0oZSx0LHIscyl7bGV0IGE9ci50cmFuc2Zvcm0uX3dvcmxkTWF0cml4O2ZvcihsZXQgbj0wO248ci5tYXRlcmlhbHMubGVuZ3RoO24rKyl7bGV0IGg9ci5tYXRlcmlhbHNbbl0uZ2V0UGFzcyh0KTtpZighKCFofHxoLmxlbmd0aD09MCkpZm9yKGxldCB1PTA7dTxoLmxlbmd0aDt1Kyspe2lmKCFofHxoLmxlbmd0aD09MCljb250aW51ZTtsZXQgYz1oW3VdO3cuYmluZEdlb21ldHJ5QnVmZmVyKHMuZW5jb2RlcixyLmdlb21ldHJ5KTtjb25zdCBmPWM7Zi5zaGFkZXJTdGF0ZS5zcGxpdFRleHR1cmUmJihzLmVuZFJlbmRlclBhc3MoKSxGZS5Xcml0ZVNwbGl0Q29sb3JUZXh0dXJlKHIuaW5zdGFuY2VJRCkscy5iZWdpblJlbmRlclBhc3MoKSx3LmJpbmRDYW1lcmEocy5lbmNvZGVyLGUuY2FtZXJhKSx3LmJpbmRHZW9tZXRyeUJ1ZmZlcihzLmVuY29kZXIsci5nZW9tZXRyeSkpLHcuYmluZFBpcGVsaW5lKHMuZW5jb2RlcixmKTtsZXQgXz1yLmdlb21ldHJ5LnN1Ykdlb21ldHJpZXNbbl0ubG9kTGV2ZWxzW3IubG9kTGV2ZWxdO3IuaW5zdGFuY2VDb3VudD4wP3cuZHJhd0luZGV4ZWQocy5lbmNvZGVyLF8uaW5kZXhDb3VudCxyLmluc3RhbmNlQ291bnQsXy5pbmRleFN0YXJ0LDAsMCk6dy5kcmF3SW5kZXhlZChzLmVuY29kZXIsXy5pbmRleENvdW50LDEsXy5pbmRleFN0YXJ0LDAsYS5pbmRleCl9fX19Y2xhc3MgRXAgZXh0ZW5kcyBYZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwicmFkaXVzXCIsMi41KSxvKHRoaXMsXCJoZWlnaHRcIiwxMCksdGhpcy5fc2hhcGVUeXBlPW1yLkNhcHN1bGV9fWNvbnN0IGxhPWNsYXNzIGV4dGVuZHMgWGV7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcIm1lc2hcIiksbyh0aGlzLFwiX3BpY2tSZXRcIiksdGhpcy5fc2hhcGVUeXBlPW1yLk1lc2h9cmF5UGljayhpLGUpe2lmKHRoaXMubWVzaCl7bGEudHJpYW5nbGV8fChsYS50cmlhbmdsZT1uZXcgbmEobmV3IGcsbmV3IGcsbmV3IGcpKTtsZXQgdD10aGlzLm1lc2guZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIikscj10aGlzLm1lc2guZ2V0QXR0cmlidXRlKFwiaW5kaWNlc1wiKSxzPVhlLmhlbHBNYXRyaXg7cy5jb3B5RnJvbShlKS5pbnZlcnQoKTtsZXQgYT1YZS5oZWxwUmF5LmNvcHkoaSk7aWYoYS5hcHBseU1hdHJpeChzKSxhLmludGVyc2VjdEJveCh0aGlzLm1lc2guYm91bmRzKSwhYS5pbnRlcnNlY3RCb3godGhpcy5tZXNoLmJvdW5kcyxYZS52M19oZWxwXzApKXJldHVybiBudWxsO2lmKHImJnQmJnIuZGF0YS5sZW5ndGg+MCl7bGV0IGw9dC5kYXRhO2ZvcihsZXQgaD0wLHU9ci5kYXRhLmxlbmd0aC8zO2g8dTtoKyspe2xldCBjPWgqMztjb25zdCBmPXIuZGF0YVtjKzBdKjMsZD1yLmRhdGFbYysxXSozLHA9ci5kYXRhW2MrMl0qMztsZXQgbT1sYS50cmlhbmdsZSxfPW0udjEuc2V0KGxbZiswXSxsW2YrMV0sbFtmKzJdKSx2PW0udjIuc2V0KGxbZCswXSxsW2QrMV0sbFtkKzJdKSx5PW0udjMuc2V0KGxbcCswXSxsW3ArMV0sbFtwKzJdKTttLnNldChfLHYseSk7bGV0IEM9YS5pbnRlcnNlY3RUcmlhbmdsZShhLm9yaWdpbixhLmRpcmVjdGlvbixtKTtpZihDKXJldHVybiB0aGlzLl9waWNrUmV0fHwodGhpcy5fcGlja1JldD17aW50ZXJzZWN0UG9pbnQ6bmV3IGcsZGlzdGFuY2U6MH0pLHRoaXMuX3BpY2tSZXQuaW50ZXJzZWN0UG9pbnQ9Qyx0aGlzLl9waWNrUmV0LmRpc3RhbmNlPWcuZGlzdGFuY2UoYS5vcmlnaW4sQyksdGhpcy5fcGlja1JldH19fXJldHVybiBudWxsfX07bGV0IHRmPWxhO28odGYsXCJ0cmlhbmdsZVwiKTtjbGFzcyBTYXtjb25zdHJ1Y3RvcihlLHQpe28odGhpcyxcImNlbnRlclwiLG5ldyBnKSxvKHRoaXMsXCJleHRlbnRzXCIpLG8odGhpcyxcIm1heFwiKSxvKHRoaXMsXCJtaW5cIiksbyh0aGlzLFwic2l6ZVwiKSxvKHRoaXMsXCJ0bXBWZWNBXCIsbmV3IGcpLG8odGhpcyxcInRtcFZlY0JcIixuZXcgZyksbyh0aGlzLFwidG1wVmVjQ1wiLG5ldyBnKSxvKHRoaXMsXCJ0bXBWZWNEXCIsbmV3IGcpLG8odGhpcyxcInJhZGl1c1wiLDApLG8odGhpcyxcImRpZmZCZXR3ZWVuUG9pbnRzXCIsbmV3IGcpLG8odGhpcyxcIm93bmVyXCIpLG8odGhpcyxcImZvcndhcmRcIixuZXcgZygwLDAsMSkpLG8odGhpcyxcIndvcmxkQ2VudGVyXCIpLG8odGhpcyxcIndvcmxkU2l6ZVwiKSxvKHRoaXMsXCJfY2VudGVyXCIsbmV3IGcpLHRoaXMuY2VudGVyPWV8fG5ldyBnKDAsMCwwKSx0aGlzLnJhZGl1cz10PT09dm9pZCAwPy41OnR9dXBkYXRlQm91bmQoKXt0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKX1jb250YWluc1BvaW50KGUpe3ZhciB0PXRoaXMudG1wVmVjQS5zdWJ0cmFjdChlLHRoaXMuY2VudGVyKS5sZW5ndGhTcXVhcmVkLHI9dGhpcy5yYWRpdXM7cmV0dXJuIHQ8cipyfWludGVyc2VjdHNSYXkoZSx0KXt2YXIgcj10aGlzLnRtcFZlY0EuY29weUZyb20oZS5vcmlnaW4pLnN1YnRyYWN0KHRoaXMuY2VudGVyKSxzPXIuZG90UHJvZHVjdCh0aGlzLnRtcFZlY0IuY29weUZyb20oZS5kaXJlY3Rpb24pLm5vcm1hbGl6ZSgpKSxhPXIuZG90UHJvZHVjdChyKS10aGlzLnJhZGl1cyp0aGlzLnJhZGl1cztpZihhPjAmJnM+MClyZXR1cm4gbnVsbDt2YXIgbj1zKnMtYTtpZihuPDApcmV0dXJuITE7dmFyIGw9TWF0aC5hYnMoLXMtTWF0aC5zcXJ0KG4pKTtyZXR1cm4gdCYmdC5jb3B5RnJvbShlLmRpcmVjdGlvbikuc2NhbGVCeShsKS5hZGQoZS5vcmlnaW4pLCEwfWludGVyc2VjdHNCb3VuZGluZ1NwaGVyZShlKXt0aGlzLnRtcFZlY0Euc3VidHJhY3QoZS5jZW50ZXIsdGhpcy5jZW50ZXIpO3ZhciB0PWUucmFkaXVzK3RoaXMucmFkaXVzO3JldHVybiB0aGlzLnRtcFZlY0EubGVuZ3RoU3F1YXJlZDw9dCp0fWNhbGN1bGF0ZVRyYW5zZm9ybShlKXt0aGlzLnVwZGF0ZShlKX1pbkZydXN0dW0oZSx0KXtyZXR1cm4gdC5jb250YWluc1NwaGVyZShlKX1jbG9uZSgpe3JldHVybiBuZXcgU2EodGhpcy5jZW50ZXIuY2xvbmUoKSx0aGlzLnJhZGl1cyl9dXBkYXRlKGUpe3RoaXMub3duZXI9ZSx0aGlzLl9jZW50ZXIuYWRkKGUudHJhbnNmb3JtLndvcmxkTWF0cml4LnBvc2l0aW9uLHRoaXMuY2VudGVyKSx0aGlzLmZvcndhcmQ9ZS50cmFuc2Zvcm0uZm9yd2FyZH1tZXJnZShlKXt0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZ1NwaGVyZSBtZXJnZSBpcyBub3QgcmVhZHkhXCIpfXNldEZyb21DZW50ZXJBbmRTaXplKGUsdCl7dGhpcy5jZW50ZXIuY29weShlKSx0aGlzLnJhZGl1cz10fX1jbGFzcyBCcCBleHRlbmRzIFhle2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksbyh0aGlzLFwiX3BpY2tSZXRcIiksbyh0aGlzLFwiYm94XCIpLG8odGhpcyxcInJhZGl1c1wiLC41KSx0aGlzLl9zaGFwZVR5cGU9bXIuU3BoZXJlLHRoaXMucmFkaXVzPWUsdGhpcy5ib3g9bmV3IFNhKG5ldyBnLDEpfXJheVBpY2soZSx0KXt0aGlzLmJveC5zZXRGcm9tQ2VudGVyQW5kU2l6ZSh0aGlzLmNlbnRlcix0aGlzLnJhZGl1cyk7bGV0IHM9WGUuaGVscE1hdHJpeDtzLmNvcHlGcm9tKHQpLmludmVydCgpO2xldCBhPVhlLmhlbHBSYXkuY29weShlKTthLmFwcGx5TWF0cml4KHMpO2xldCBuPWEuaW50ZXJzZWN0U3BoZXJlKGEub3JpZ2luLGEuZGlyZWN0aW9uLHRoaXMuYm94LmNlbnRlcix0aGlzLmJveC5yYWRpdXMpO3JldHVybiBuPyh0aGlzLl9waWNrUmV0fHwodGhpcy5fcGlja1JldD17aW50ZXJzZWN0OiExLGludGVyc2VjdFBvaW50Om5ldyBnLGRpc3RhbmNlOjB9KSx0aGlzLl9waWNrUmV0LmludGVyc2VjdD0hMCx0aGlzLl9waWNrUmV0LmludGVyc2VjdFBvaW50PW4sdGhpcy5fcGlja1JldC5kaXN0YW5jZT1nLmRpc3RhbmNlKGEub3JpZ2luLFhlLnYzX2hlbHBfMCksdGhpcy5fcGlja1JldCk6bnVsbH19Y2xhc3MgVHAgZXh0ZW5kcyB0ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiX2Vudk1hcFwiKSxvKHRoaXMsXCJza3lPYmplY3RcIiksbyh0aGlzLFwiZW52TWFwQ2hhbmdlXCIsITApLG8odGhpcyxcInZpZXdcIiksdGhpcy50cmFuc2Zvcm0uc2NlbmUzRD10aGlzLHRoaXMuc2t5T2JqZWN0PW5ldyB0ZSx0aGlzLmFkZENoaWxkKHRoaXMuc2t5T2JqZWN0KSx0aGlzLl9pc1NjZW5lM0Q9ITAsdGhpcy5lbnZNYXB8fCh0aGlzLmVudk1hcD1BLnJlcy5kZWZhdWx0U2t5KX1nZXQgZW52TWFwKCl7cmV0dXJuIHRoaXMuX2Vudk1hcH1zZXQgZW52TWFwKGUpe3RoaXMuX2Vudk1hcCE9ZSYmKHRoaXMuZW52TWFwQ2hhbmdlPSEwKSx0aGlzLl9lbnZNYXA9ZSxRLmluc3RhbmNlLnNreSYmXCJtYXBcImluIFEuaW5zdGFuY2Uuc2t5JiYoUS5pbnN0YW5jZS5za3kubWFwPWUpfWdldCBleHBvc3VyZSgpe3JldHVybiBRLmluc3RhbmNlLnNreSYmXCJleHBvc3VyZVwiaW4gUS5pbnN0YW5jZS5za3k/US5pbnN0YW5jZS5za3kuZXhwb3N1cmU6MH1zZXQgZXhwb3N1cmUoZSl7US5pbnN0YW5jZS5za3kmJlwiZXhwb3N1cmVcImluIFEuaW5zdGFuY2Uuc2t5JiYoUS5pbnN0YW5jZS5za3kuZXhwb3N1cmU9ZSxBLnNldHRpbmcuc2t5LnNreUV4cG9zdXJlPWUpfWdldCByb3VnaG5lc3MoKXtpZihRLmluc3RhbmNlLnNreSYmXCJyb3VnaG5lc3NcImluIFEuaW5zdGFuY2Uuc2t5KXJldHVybiBRLmluc3RhbmNlLnNreS5yb3VnaG5lc3N9c2V0IHJvdWdobmVzcyhlKXtRLmluc3RhbmNlLnNreSYmXCJyb3VnaG5lc3NcImluIFEuaW5zdGFuY2Uuc2t5JiYoUS5pbnN0YW5jZS5za3kucm91Z2huZXNzPWUpfX1jbGFzcyByZiBleHRlbmRzIFVze2NvbnN0cnVjdG9yKCl7c3VwZXIoMyxNcy50cmlhbmdsZV9saXN0KX19Y2xhc3Mgc2YgZXh0ZW5kcyBVc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKDIsTXMubGluZV9saXN0KX19Y2xhc3MgYWYgZXh0ZW5kcyB0ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwibUxpbmVSZW5kZXJcIiksbyh0aGlzLFwibUZpbGxSZW5kZXJcIiksdGhpcy5tTGluZVJlbmRlcj10aGlzLmFkZENvbXBvbmVudChzZiksdGhpcy5tRmlsbFJlbmRlcj10aGlzLmFkZENvbXBvbmVudChyZil9ZHJhd0F4aXMoZSx0PW5ldyBnKDAsMCwwKSxyPTEwKXt0aGlzLmNyZWF0ZUN1c3RvbVNoYXBlKGUpLmJ1aWxkQXhpcyh0LHIpfWRyYXdMaW5lcyhlLHQscj16LkNPTE9SX1dISVRFKXt0aGlzLmNyZWF0ZUN1c3RvbVNoYXBlKGUpLmJ1aWxkTGluZXModCxyKX1kcmF3Q3VydmUoZSx0LHI9MTAscz0uNSxhPXouQ09MT1JfV0hJVEUpe3ZhciBuPVtdO2xldCBsPW5ldyBnLGg9bmV3IGc7Zm9yKGxldCB1PTA7dTx0Lmxlbmd0aC0xOysrdSl7bi5wdXNoKHRbdV0pO2NvbnN0IGM9dFtNYXRoLm1heCh1LTEsMCldLGY9dFt1XSxkPXRbdSsxXSxwPXRbTWF0aC5taW4odSsyLHQubGVuZ3RoLTEpXTtkLnN1YnRyYWN0KGMsbCkubXVsdGlwbHlTY2FsYXIocy8zKS5hZGQoZixsKSxmLnN1YnRyYWN0KHAsaCkubXVsdGlwbHlTY2FsYXIocy8zKS5hZGQoZCxoKSxuLnB1c2goLi4udGhpcy5jYWxjdWxhdGVCZXppZXJDdXJ2ZShmLGwsaCxkLHIpKX1uLnB1c2godFt0Lmxlbmd0aC0xXSksdGhpcy5kcmF3TGluZXMoZSxuLGEpfWNhbGN1bGF0ZUJlemllckN1cnZlKGUsdCxyLHMsYSl7dmFyIG49bmV3IEFycmF5KGEpO2ZvcihsZXQgbD0wO2w8YTsrK2wpe2xldCBoPShsKzEpLyhhKzEpLHU9MS1oLGM9ZS5tdWwodSp1KnUpLGY9dC5tdWwoMypoKnUqdSksZD1yLm11bCgzKmgqaCp1KSxwPXMubXVsKGgqaCpoKTtuW2xdPWMuYWRkKGYpLmFkZChkKS5hZGQocCl9cmV0dXJuIG59ZHJhd1JlY3QoZSx0LHIscyxhPXouQ09MT1JfV0hJVEUpe3RoaXMuZHJhd0xpbmVzKGUsW3QsbmV3IGcodC54K3IsdC55LHQueiksbmV3IGcodC54K3IsdC55K3MsdC56KSxuZXcgZyh0LngsdC55K3MsdC56KSx0XSxhKX1kcmF3Q2lyY2xlKGUsdCxyLHM9MzIsYT1nLllfQVhJUyxuPXouQ09MT1JfV0hJVEUpe3RoaXMuY3JlYXRlQ3VzdG9tU2hhcGUoZSkuYnVpbGRDaXJjbGUodCxyLHMsYSxuKX1kcmF3U2VjdG9yKGUsdCxyLHMsYSxuPTE2LGw9Zy5ZX0FYSVMsaD16LkNPTE9SX1dISVRFKXtjb25zdCB1PShhLXMpKl9lO3MqPV9lO3ZhciBjPVtdO2MucHVzaCh0KTtmb3IobGV0IG09MDttPD1uOysrbSl7bT4wJiZjLnB1c2goY1tjLmxlbmd0aC0xXSk7dmFyIGY9dSoobS9uKStzLGQ9cipNYXRoLmNvcyhmKSxwPXIqTWF0aC5zaW4oZik7c3dpdGNoKGwpe2Nhc2UgZy5YX0FYSVM6Yy5wdXNoKHQuYWRkKG5ldyBnKDAsZCxwKSkpO2JyZWFrO2Nhc2UgZy5ZX0FYSVM6Yy5wdXNoKHQuYWRkKG5ldyBnKGQsMCxwKSkpO2JyZWFrO2Nhc2UgZy5aX0FYSVM6Yy5wdXNoKHQuYWRkKG5ldyBnKGQscCwwKSkpO2JyZWFrO2RlZmF1bHQ6Yy5wdXNoKHQuYWRkKG5ldyBnKGQscCwwKSkpO2JyZWFrfX1jLnB1c2goY1tjLmxlbmd0aC0xXSksYy5wdXNoKHQpLHRoaXMubUxpbmVSZW5kZXIuZmlsbFNoYXBlRGF0YShlLFwibGluZVwiLGgsYyl9ZHJhd0FyY0xpbmUoZSx0LHIscyxhLG49MTYsbD1nLllfQVhJUyxoPXouQ09MT1JfV0hJVEUpe3RoaXMubUxpbmVSZW5kZXIuYWxsb2NHcmFwaGljczNEU2hhcGUoZSx0aGlzLnRyYW5zZm9ybS5fd29ybGRNYXRyaXguaW5kZXgpLmJ1aWxkQXJjTGluZSh0LHIscyxhLG4sbCxoKX1jcmVhdGVDdXN0b21TaGFwZShlLHQ9dGhpcy50cmFuc2Zvcm0pe3JldHVybiB0aGlzLm1MaW5lUmVuZGVyLmFsbG9jR3JhcGhpY3MzRFNoYXBlKGUsdC5fd29ybGRNYXRyaXguaW5kZXgpfWRyYXdCb3goZSx0LHIscz16LkNPTE9SX1dISVRFKXt2YXIgYT1bXTthLnB1c2godCksYS5wdXNoKG5ldyBnKHIueCx0LnksdC56KSksYS5wdXNoKGFbYS5sZW5ndGgtMV0pLGEucHVzaChuZXcgZyhyLngsci55LHQueikpLGEucHVzaChhW2EubGVuZ3RoLTFdKSxhLnB1c2gobmV3IGcodC54LHIueSx0LnopKSxhLnB1c2goYVthLmxlbmd0aC0xXSksYS5wdXNoKHQpLGEucHVzaChhW2EubGVuZ3RoLTFdKSxhLnB1c2gobmV3IGcodC54LHQueSxyLnopKSxhLnB1c2goYVthLmxlbmd0aC0xXSksYS5wdXNoKG5ldyBnKHIueCx0Lnksci56KSksYS5wdXNoKGFbYS5sZW5ndGgtMV0pLGEucHVzaChuZXcgZyhyLngsci55LHIueikpLGEucHVzaChhW2EubGVuZ3RoLTFdKSxhLnB1c2gobmV3IGcodC54LHIueSxyLnopKSxhLnB1c2goYVthLmxlbmd0aC0xXSksYS5wdXNoKG5ldyBnKHQueCx0Lnksci56KSksYS5wdXNoKG5ldyBnKHQueCxyLnksdC56KSksYS5wdXNoKG5ldyBnKHQueCxyLnksci56KSksYS5wdXNoKG5ldyBnKHIueCxyLnksdC56KSksYS5wdXNoKG5ldyBnKHIueCxyLnksci56KSksYS5wdXNoKG5ldyBnKHIueCx0LnksdC56KSksYS5wdXNoKG5ldyBnKHIueCx0Lnksci56KSksdGhpcy5tTGluZVJlbmRlci5maWxsU2hhcGVEYXRhKGUsXCJsaW5lXCIscyxhKX1kcmF3RmlsbFJlY3QoZSx0LHIscyxhPXouQ09MT1JfV0hJVEUpe3RoaXMubUZpbGxSZW5kZXIuZmlsbFNoYXBlRGF0YShlLFwiZmlsbFwiLGEsW3QsbmV3IGcodC54K3IsdC55LHQueiksbmV3IGcodC54K3IsdC55K3MsdC56KSxuZXcgZyh0Lngrcix0Lnkrcyx0LnopLG5ldyBnKHQueCx0Lnkrcyx0LnopLHRdKX1kcmF3RmlsbENpcmNsZShlLHQscixzPTMyLGE9Zy5ZX0FYSVMsbj16LkNPTE9SX1dISVRFKXt2YXIgbD1bXTtsLnB1c2godCk7Zm9yKGxldCBmPTA7Zjw9czsrK2Ype2Y+PTImJihsLnB1c2godCksbC5wdXNoKGxbbC5sZW5ndGgtMl0pKTt2YXIgaD0yKk1hdGguUEkqZi9zLHU9cipNYXRoLmNvcyhoKSxjPXIqTWF0aC5zaW4oaCk7c3dpdGNoKGEpe2Nhc2UgZy5YX0FYSVM6bC5wdXNoKHQuYWRkKG5ldyBnKDAsdSxjKSkpO2JyZWFrO2Nhc2UgZy5ZX0FYSVM6bC5wdXNoKHQuYWRkKG5ldyBnKHUsMCxjKSkpO2JyZWFrO2Nhc2UgZy5aX0FYSVM6bC5wdXNoKHQuYWRkKG5ldyBnKHUsYywwKSkpO2JyZWFrO2RlZmF1bHQ6bC5wdXNoKHQuYWRkKG5ldyBnKHUsYywwKSkpO2JyZWFrfX10aGlzLm1GaWxsUmVuZGVyLmZpbGxTaGFwZURhdGEoZSxcImZpbGxcIixuLGwpfWRyYXdNZXNoV2lyZWZyYW1lKGUsdCxyLHM9ei5DT0xPUl9XSElURSl7dCYmdGhpcy5jcmVhdGVDdXN0b21TaGFwZShlLHJ8fHRoaXMudHJhbnNmb3JtKS5maWxsU2hhcGVEYXRhKHQuZ2VuV2lyZWZyYW1lKCkscyl9ZHJhd0ZpbGxTZWN0b3IoZSx0LHIscyxhLG49MTYsbD1nLllfQVhJUyxoPXouQ09MT1JfV0hJVEUpe2NvbnN0IHU9KGEtcykqX2U7cyo9X2U7dmFyIGM9W107Yy5wdXNoKHQpO2ZvcihsZXQgbT0wO208PW47KyttKXttPj0yJiYoYy5wdXNoKHQpLGMucHVzaChjW2MubGVuZ3RoLTJdKSk7dmFyIGY9dSoobS9uKStzLGQ9cipNYXRoLmNvcyhmKSxwPXIqTWF0aC5zaW4oZik7c3dpdGNoKGwpe2Nhc2UgZy5YX0FYSVM6Yy5wdXNoKHQuYWRkKG5ldyBnKDAsZCxwKSkpO2JyZWFrO2Nhc2UgZy5ZX0FYSVM6Yy5wdXNoKHQuYWRkKG5ldyBnKGQsMCxwKSkpO2JyZWFrO2Nhc2UgZy5aX0FYSVM6Yy5wdXNoKHQuYWRkKG5ldyBnKGQscCwwKSkpO2JyZWFrO2RlZmF1bHQ6Yy5wdXNoKHQuYWRkKG5ldyBnKGQscCwwKSkpO2JyZWFrfX10aGlzLm1GaWxsUmVuZGVyLmZpbGxTaGFwZURhdGEoZSxcImZpbGxcIixoLGMpfWRyYXdCb3VuZGluZ0JveChlLHQscj16LkNPTE9SX1dISVRFKXt0aGlzLmRyYXdCb3goZSx0Lm1pbix0Lm1heCxyKX1kcmF3Q2FtZXJhRnJ1c3R1bShlLHQ9ei5DT0xPUl9XSElURSl7aWYoZS50eXBlPT1JZS5wZXJzcGVjdGl2ZSl7bGV0IHI9TWF0aC50YW4oZS5mb3YvMipfZSkscz1yKmUuYXNwZWN0LGE9ZS50cmFuc2Zvcm0uX3dvcmxkTWF0cml4LG49YS50cmFuc2Zvcm1WZWN0b3IobmV3IGcoLXMsLXIsMSkpLGw9YS50cmFuc2Zvcm1WZWN0b3IobmV3IGcoLXMsciwxKSksaD1hLnRyYW5zZm9ybVZlY3RvcihuZXcgZyhzLC1yLDEpKSx1PWEudHJhbnNmb3JtVmVjdG9yKG5ldyBnKHMsciwxKSksYz1lLmZhcixmPWUubmVhcixkPWUudHJhbnNmb3JtLndvcmxkUG9zaXRpb24scD1uZXcgZygpLmNvcHlGcm9tKG4pLm11bHRpcGx5U2NhbGFyKGMpLmFkZChkKSxtPW5ldyBnKCkuY29weUZyb20obCkubXVsdGlwbHlTY2FsYXIoYykuYWRkKGQpLF89bmV3IGcoKS5jb3B5RnJvbShoKS5tdWx0aXBseVNjYWxhcihjKS5hZGQoZCksdj1uZXcgZygpLmNvcHlGcm9tKHUpLm11bHRpcGx5U2NhbGFyKGMpLmFkZChkKSx5PW5ldyBnKCkuY29weUZyb20obikubXVsdGlwbHlTY2FsYXIoZikuYWRkKGQpLEM9bmV3IGcoKS5jb3B5RnJvbShsKS5tdWx0aXBseVNjYWxhcihmKS5hZGQoZCksQj1uZXcgZygpLmNvcHlGcm9tKGgpLm11bHRpcGx5U2NhbGFyKGYpLmFkZChkKSxUPW5ldyBnKCkuY29weUZyb20odSkubXVsdGlwbHlTY2FsYXIoZikuYWRkKGQpLE09dGhpcy5jcmVhdGVDdXN0b21TaGFwZShgQ2FtZXJhRnJ1c3R1bV8ke2Uub2JqZWN0M0QuaW5zdGFuY2VJRH1gKTtNLmJ1aWxkTGluZXMoW0MsbV0sdCksTS5idWlsZExpbmVzKFt5LHBdLHQpLE0uYnVpbGRMaW5lcyhbVCx2XSx0KSxNLmJ1aWxkTGluZXMoW0IsX10sdCksTS5idWlsZExpbmVzKFttLHYsXyxwLG1dLHQpLE0uYnVpbGRMaW5lcyhbQyxULEIseSxDXSx0KX1lbHNlIGlmKGUudHlwZT09SWUub3J0aG8pe2Uudmlld1BvcnQsZS52aWV3UG9ydC5oZWlnaHQ7bGV0IHI9ZS50cmFuc2Zvcm0ud29ybGRNYXRyaXgscz1yLnRyYW5zZm9ybVZlY3RvcihuZXcgZyhlLnZpZXdQb3J0LndpZHRoKi0uNSxlLnZpZXdQb3J0LmhlaWdodCouNSxlLmZhcikpLGE9ci50cmFuc2Zvcm1WZWN0b3IobmV3IGcoZS52aWV3UG9ydC53aWR0aCotLjUsZS52aWV3UG9ydC5oZWlnaHQqLS41LGUuZmFyKSksbj1yLnRyYW5zZm9ybVZlY3RvcihuZXcgZyhlLnZpZXdQb3J0LndpZHRoKi41LGUudmlld1BvcnQuaGVpZ2h0Ki41LGUuZmFyKSksbD1yLnRyYW5zZm9ybVZlY3RvcihuZXcgZyhlLnZpZXdQb3J0LndpZHRoKi41LGUudmlld1BvcnQuaGVpZ2h0Ki0uNSxlLmZhcikpLGg9ci50cmFuc2Zvcm1WZWN0b3IobmV3IGcoZS52aWV3UG9ydC53aWR0aCotLjUsZS52aWV3UG9ydC5oZWlnaHQqLjUsZS5uZWFyKSksdT1yLnRyYW5zZm9ybVZlY3RvcihuZXcgZyhlLnZpZXdQb3J0LndpZHRoKi0uNSxlLnZpZXdQb3J0LmhlaWdodCotLjUsZS5uZWFyKSksYz1yLnRyYW5zZm9ybVZlY3RvcihuZXcgZyhlLnZpZXdQb3J0LndpZHRoKi41LGUudmlld1BvcnQuaGVpZ2h0Ki41LGUubmVhcikpLGY9ci50cmFuc2Zvcm1WZWN0b3IobmV3IGcoZS52aWV3UG9ydC53aWR0aCouNSxlLnZpZXdQb3J0LmhlaWdodCotLjUsZS5uZWFyKSksZD10aGlzLmNyZWF0ZUN1c3RvbVNoYXBlKGBDYW1lcmFGcnVzdHVtXyR7ZS5vYmplY3QzRC5pbnN0YW5jZUlEfWApO2QuYnVpbGRMaW5lcyhbaCxzXSx0KSxkLmJ1aWxkTGluZXMoW3UsYV0sdCksZC5idWlsZExpbmVzKFtjLG5dLHQpLGQuYnVpbGRMaW5lcyhbZixsXSx0KSxkLmJ1aWxkTGluZXMoW3MsbixsLGEsc10sdCksZC5idWlsZExpbmVzKFtoLGMsZix1LGhdLHQpfX1kcmF3T2JqZWN0Qm91bmRpbmdCb3goZSx0PXouQ09MT1JfV0hJVEUpe2xldCByPVp0Lmdlbk1lc2hCb3VuZHMoZSk7dGhpcy5kcmF3Qm94KGBCb3VuZHNfJHtlLmluc3RhbmNlSUR9YCxyLm1pbixyLm1heCx0KX1DbGVhcihlKXt0aGlzLm1MaW5lUmVuZGVyLnNoYXBlcy5oYXMoZSk/dGhpcy5tTGluZVJlbmRlci5yZW1vdmVTaGFwZShlKTp0aGlzLm1GaWxsUmVuZGVyLnNoYXBlcy5oYXMoZSkmJnRoaXMubUZpbGxSZW5kZXIucmVtb3ZlU2hhcGUoZSl9Q2xlYXJBbGwoKXt0aGlzLm1MaW5lUmVuZGVyLnNoYXBlcy5jbGVhcigpLHRoaXMubUZpbGxSZW5kZXIuc2hhcGVzLmNsZWFyKCl9Q2hhbmdlQ29sb3IoZSx0KXt2YXIgcjtpZih0aGlzLm1MaW5lUmVuZGVyLnNoYXBlcy5oYXMoZSkpcj10aGlzLm1MaW5lUmVuZGVyLnNoYXBlcy5nZXQoZSk7ZWxzZSBpZih0aGlzLm1GaWxsUmVuZGVyLnNoYXBlcy5oYXMoZSkpcj10aGlzLm1GaWxsUmVuZGVyLnNoYXBlcy5nZXQoZSk7ZWxzZSByZXR1cm47Y29uc3Qgcz1yLnNoYXBlRGF0YTtmb3IobGV0IGE9MDthPHMubGVuZ3RoO2ErPWVpLlNoYXBlVmVydGV4U2l6ZSlzW2ErNF09dC5yLHNbYSs1XT10Lmcsc1thKzZdPXQuYixzW2ErN109dC5hfX1jbGFzcyBvZntjb25zdHJ1Y3Rvcigpe28odGhpcyxcIl9jb21wdXRlU2hhZGVyXCIpLG8odGhpcyxcIl9vdXRCdWZmZXJcIil9aW5pdCgpe2xldCBlPXd0LmdldEdCdWZmZXJGcmFtZShcIkNvbG9yUGFzc0dCdWZmZXJcIik7dGhpcy5fY29tcHV0ZVNoYWRlcj1uZXcgYmUocmMpLHRoaXMuX291dEJ1ZmZlcj1uZXcgaXIoMzIpLHRoaXMuX2NvbXB1dGVTaGFkZXIuc2V0U3RvcmFnZUJ1ZmZlcihcIm91dEJ1ZmZlclwiLHRoaXMuX291dEJ1ZmZlciksdGhpcy5fY29tcHV0ZVNoYWRlci5zZXRTYW1wbGVyVGV4dHVyZShcInZpc2libGVNYXBcIixlLmdldFBvc2l0aW9uTWFwKCkpfWNvbXB1dGUoZSl7bGV0IHQ9cGUuZ2V0Q2FtZXJhR3JvdXAoZS5jYW1lcmEpO3RoaXMuX2NvbXB1dGVTaGFkZXIuc2V0U3RvcmFnZUJ1ZmZlcihcImdsb2JhbFVuaWZvcm1cIix0LnVuaWZvcm1HUFVCdWZmZXIpO2xldCByPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO3cuY29tcHV0ZUNvbW1hbmQocixbdGhpcy5fY29tcHV0ZVNoYWRlcl0pLHcuZW5kQ29tbWFuZEVuY29kZXIociksdGhpcy5fb3V0QnVmZmVyLnJlYWRCdWZmZXIoKX1nZXRQaWNrTWVzaElEKCl7dmFyIGU9dGhpcy5fb3V0QnVmZmVyLm91dEZsb2F0MzJBcnJheVswXSsuMTtyZXR1cm4gTWF0aC5mbG9vcihlKX1nZXRQaWNrV29ybGRQb3NpdGlvbihlKXtlfHwoZT1uZXcgZyk7dmFyIHQ9dGhpcy5fb3V0QnVmZmVyLm91dEZsb2F0MzJBcnJheVs0XSxyPXRoaXMuX291dEJ1ZmZlci5vdXRGbG9hdDMyQXJyYXlbNV0scz10aGlzLl9vdXRCdWZmZXIub3V0RmxvYXQzMkFycmF5WzZdO3JldHVybiBlLnNldCh0LHIscyksZX1nZXRQaWNrU2NyZWVuVVYoZSl7ZXx8KGU9bmV3IFopO3ZhciB0PXRoaXMuX291dEJ1ZmZlci5vdXRGbG9hdDMyQXJyYXlbMl0scj10aGlzLl9vdXRCdWZmZXIub3V0RmxvYXQzMkFycmF5WzNdO3JldHVybiBlLnNldCh0LHIpLGV9fWNsYXNzIG5mIGV4dGVuZHMgaGl7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSxvKHRoaXMsXCJyYXlcIiksbyh0aGlzLFwiaXNUb3VjaGluZ1wiLCExKSxvKHRoaXMsXCJfbW91c2VDb2RlXCIpLG8odGhpcyxcIl9waWNrRXZlbnRcIiksbyh0aGlzLFwiX291dEV2ZW50XCIpLG8odGhpcyxcIl9vdmVyRXZlbnRcIiksbyh0aGlzLFwiX3VwRXZlbnRcIiksbyh0aGlzLFwiX2Rvd25FdmVudFwiKSxvKHRoaXMsXCJfbW91c2VNb3ZlXCIpLG8odGhpcyxcIl9waWNrQ29tcHV0ZVwiKSxvKHRoaXMsXCJfbGFzdERvd25UYXJnZXRcIiksbyh0aGlzLFwibW91c2VFbmFibGVNYXBcIiksbyh0aGlzLFwiX3ZpZXdcIiksbyh0aGlzLFwiX2xhc3RGb2N1c1wiKSxvKHRoaXMsXCJfaW50ZXJlc3RMaXN0XCIsW10pLHRoaXMuX3ZpZXc9ZSx0aGlzLmluaXQoKX1pbml0KCl7dGhpcy5yYXk9bmV3IGNpLHRoaXMubW91c2VFbmFibGVNYXA9bmV3IE1hcCx0aGlzLl9waWNrRXZlbnQ9bmV3IFIoUi5QSUNLX0NMSUNLKSx0aGlzLl9vdXRFdmVudD1uZXcgUihSLlBJQ0tfT1VUKSx0aGlzLl9vdmVyRXZlbnQ9bmV3IFIoUi5QSUNLX09WRVIpLHRoaXMuX21vdXNlTW92ZT1uZXcgUihSLlBJQ0tfTU9WRSksdGhpcy5fdXBFdmVudD1uZXcgUihSLlBJQ0tfVVApLHRoaXMuX2Rvd25FdmVudD1uZXcgUihSLlBJQ0tfRE9XTil9c3RhcnQoKXtBLnNldHRpbmcucGljay5lbmFibGUmJihBLmlucHV0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX0RPV04sdGhpcy5vblRvdWNoU3RhcnQsdGhpcyksQS5pbnB1dFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9VUCx0aGlzLm9uVG91Y2hFbmQsdGhpcyksQS5pbnB1dFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9DTElDSyx0aGlzLm9uVG91Y2hPbmNlLHRoaXMpLEEuaW5wdXRTeXN0ZW0uYWRkRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfTU9WRSx0aGlzLm9uVG91Y2hNb3ZlLHRoaXMpKSxBLnNldHRpbmcucGljay5tb2RlPT1cInBpeGVsXCImJih0aGlzLl9waWNrQ29tcHV0ZT1uZXcgb2YsdGhpcy5fcGlja0NvbXB1dGUuaW5pdCgpKX1zdG9wKCl7QS5pbnB1dFN5c3RlbS5yZW1vdmVFdmVudExpc3RlbmVyKFIuUE9JTlRFUl9ET1dOLHRoaXMub25Ub3VjaFN0YXJ0LHRoaXMpLEEuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfVVAsdGhpcy5vblRvdWNoRW5kLHRoaXMpLEEuaW5wdXRTeXN0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSLlBPSU5URVJfQ0xJQ0ssdGhpcy5vblRvdWNoT25jZSx0aGlzKSxBLmlucHV0U3lzdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoUi5QT0lOVEVSX01PVkUsdGhpcy5vblRvdWNoTW92ZSx0aGlzKX1vblRvdWNoU3RhcnQoZSl7dGhpcy5pc1RvdWNoaW5nPSEwLHRoaXMuX21vdXNlQ29kZT1lLm1vdXNlQ29kZSx0aGlzLnBpY2sodGhpcy5fdmlldy5jYW1lcmEpO2xldCB0PXRoaXMuZmluZE5lYXJlc3RPYmoodGhpcy5faW50ZXJlc3RMaXN0LHRoaXMuX3ZpZXcuY2FtZXJhKTt0aGlzLl9sYXN0RG93blRhcmdldD10LHQmJih0aGlzLl9kb3duRXZlbnQudGFyZ2V0PXQub2JqZWN0M0QsdGhpcy5fZG93bkV2ZW50LmN0cmxLZXk9ZS5jdHJsS2V5LHRoaXMuX2Rvd25FdmVudC5kYXRhPXtwaWNrOnQscGlja0luZm86dGhpcy5nZXRQaWNrSW5mbygpLG1vdXNlQ29kZTp0aGlzLl9tb3VzZUNvZGV9LHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9kb3duRXZlbnQpLHQub2JqZWN0M0QuY29udGFpbkV2ZW50TGlzdGVuZXIoUi5QSUNLX0RPV04pJiZ0Lm9iamVjdDNELmRpc3BhdGNoRXZlbnQodGhpcy5fZG93bkV2ZW50KSl9b25Ub3VjaEVuZChlKXt0aGlzLmlzVG91Y2hpbmc9ITEsdGhpcy5fbW91c2VDb2RlPWUubW91c2VDb2RlLHRoaXMucGljayh0aGlzLl92aWV3LmNhbWVyYSk7bGV0IHQ9dGhpcy5maW5kTmVhcmVzdE9iaih0aGlzLl9pbnRlcmVzdExpc3QsdGhpcy5fdmlldy5jYW1lcmEpO3QmJih0aGlzLl91cEV2ZW50LnRhcmdldD10Lm9iamVjdDNELHRoaXMuX3VwRXZlbnQuY3RybEtleT1lLmN0cmxLZXksdGhpcy5fdXBFdmVudC5kYXRhPXtwaWNrOnQscGlja0luZm86dGhpcy5nZXRQaWNrSW5mbygpLG1vdXNlQ29kZTp0aGlzLl9tb3VzZUNvZGV9LHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl91cEV2ZW50KSx0Lm9iamVjdDNELmNvbnRhaW5FdmVudExpc3RlbmVyKFIuUElDS19VUCkmJnQub2JqZWN0M0QuZGlzcGF0Y2hFdmVudCh0aGlzLl91cEV2ZW50KSl9Z2V0UGlja0luZm8oKXtyZXR1cm57d29ybGRQb3M6dGhpcy5fcGlja0NvbXB1dGUuZ2V0UGlja1dvcmxkUG9zaXRpb24oKSxzY3JlZW5Vdjp0aGlzLl9waWNrQ29tcHV0ZS5nZXRQaWNrU2NyZWVuVVYoKSxtZXNoSUQ6dGhpcy5fcGlja0NvbXB1dGUuZ2V0UGlja01lc2hJRCgpfX1vblRvdWNoTW92ZShlKXt0aGlzLmlzVG91Y2hpbmc9ITAsdGhpcy5fbW91c2VDb2RlPWUubW91c2VDb2RlLHRoaXMucGljayh0aGlzLl92aWV3LmNhbWVyYSk7bGV0IHQ9dGhpcy5maW5kTmVhcmVzdE9iaih0aGlzLl9pbnRlcmVzdExpc3QsdGhpcy5fdmlldy5jYW1lcmEpO3QmJih0aGlzLl9tb3VzZU1vdmUudGFyZ2V0PXQub2JqZWN0M0QsdGhpcy5fbW91c2VNb3ZlLmN0cmxLZXk9ZS5jdHJsS2V5LHRoaXMuX21vdXNlTW92ZS5kYXRhPXtwaWNrOnQscGlja0luZm86dGhpcy5nZXRQaWNrSW5mbygpLG1vdXNlQ29kZTp0aGlzLl9tb3VzZUNvZGV9LHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9tb3VzZU1vdmUpLHQub2JqZWN0M0QuY29udGFpbkV2ZW50TGlzdGVuZXIoUi5QSUNLX01PVkUpJiZ0Lm9iamVjdDNELmRpc3BhdGNoRXZlbnQodGhpcy5fbW91c2VNb3ZlKSksdCE9dGhpcy5fbGFzdEZvY3VzJiYodGhpcy5fbGFzdEZvY3VzJiZ0aGlzLl9sYXN0Rm9jdXMub2JqZWN0M0QmJih0aGlzLl9vdXRFdmVudC50YXJnZXQ9dGhpcy5fbGFzdEZvY3VzLm9iamVjdDNELHRoaXMuX291dEV2ZW50LmRhdGE9e3BpY2s6dGhpcy5fbGFzdEZvY3VzLHBpY2tJbmZvOnRoaXMuZ2V0UGlja0luZm8oKSxtb3VzZUNvZGU6dGhpcy5fbW91c2VDb2RlfSx0aGlzLl9vdXRFdmVudC5jdHJsS2V5PWUuY3RybEtleSx0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fb3V0RXZlbnQpLHRoaXMuX2xhc3RGb2N1cy5vYmplY3QzRC5jb250YWluRXZlbnRMaXN0ZW5lcihSLlBJQ0tfT1VUKSYmdGhpcy5fbGFzdEZvY3VzLm9iamVjdDNELmRpc3BhdGNoRXZlbnQodGhpcy5fb3V0RXZlbnQpKSx0JiYodGhpcy5fb3ZlckV2ZW50LnRhcmdldD10Lm9iamVjdDNELHRoaXMuX292ZXJFdmVudC5jdHJsS2V5PWUuY3RybEtleSx0aGlzLl9vdmVyRXZlbnQuZGF0YT17cGljazp0LHBpY2tJbmZvOnRoaXMuZ2V0UGlja0luZm8oKSxtb3VzZUNvZGU6dGhpcy5fbW91c2VDb2RlfSx0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fb3ZlckV2ZW50KSx0Lm9iamVjdDNELmNvbnRhaW5FdmVudExpc3RlbmVyKFIuUElDS19PVkVSKSYmdC5vYmplY3QzRC5kaXNwYXRjaEV2ZW50KHRoaXMuX292ZXJFdmVudCkpKSx0aGlzLl9sYXN0Rm9jdXM9dH1vblRvdWNoT25jZShlKXt0aGlzLmlzVG91Y2hpbmc9ITAsdGhpcy5fbW91c2VDb2RlPWUubW91c2VDb2RlLHRoaXMucGljayh0aGlzLl92aWV3LmNhbWVyYSk7bGV0IHQ9dGhpcy5maW5kTmVhcmVzdE9iaih0aGlzLl9pbnRlcmVzdExpc3QsdGhpcy5fdmlldy5jYW1lcmEpO2lmKHQpe2xldCByPUEuc2V0dGluZy5waWNrLm1vZGU9PVwicGl4ZWxcIj90aGlzLmdldFBpY2tJbmZvKCk6bnVsbDt0aGlzLl9waWNrRXZlbnQudGFyZ2V0PXQub2JqZWN0M0QsdGhpcy5fcGlja0V2ZW50LmN0cmxLZXk9ZS5jdHJsS2V5LHRoaXMuX3BpY2tFdmVudC5kYXRhPXtwaWNrOnQscGlja0luZm86cixtb3VzZUNvZGU6dGhpcy5fbW91c2VDb2RlfSx0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fcGlja0V2ZW50KSx0PT09dGhpcy5fbGFzdERvd25UYXJnZXQmJnQub2JqZWN0M0QuY29udGFpbkV2ZW50TGlzdGVuZXIoUi5QSUNLX0NMSUNLKSYmdC5vYmplY3QzRC5kaXNwYXRjaEV2ZW50KHRoaXMuX3BpY2tFdmVudCl9dGhpcy5fbGFzdERvd25UYXJnZXQ9bnVsbH1maW5kTmVhcmVzdE9iaihlLHQpe3ZhciByO3JldHVybiBlLnNvcnQoKHMsYSk9PnMuZGlzdGFuY2U+YS5kaXN0YW5jZT8xOi0xKSwocj1lWzBdKT09bnVsbD92b2lkIDA6ci5jb2xsaWRlcn1waWNrKGUpe2lmKHRoaXMuX2ludGVyZXN0TGlzdC5sZW5ndGg9MCxBLnNldHRpbmcucGljay5tb2RlPT1cInBpeGVsXCIpe3RoaXMuX3BpY2tDb21wdXRlLmNvbXB1dGUodGhpcy5fdmlldyk7bGV0IHQ9dGhpcy5fcGlja0NvbXB1dGUuZ2V0UGlja01lc2hJRCgpLHI9dGhpcy5tb3VzZUVuYWJsZU1hcC5nZXQodCk7aWYocil7bGV0IHM9dGhpcy5fcGlja0NvbXB1dGUuZ2V0UGlja1dvcmxkUG9zaXRpb24oKSxhPWcuZGlzdGFuY2Uocyx0aGlzLnJheS5vcmlnaW4pO3RoaXMuX2ludGVyZXN0TGlzdC5wdXNoKHtkaXN0YW5jZTphLGNvbGxpZGVyOnIsaW50ZXJzZWN0UG9pbnQ6c30pfX1lbHNlIGlmKEEuc2V0dGluZy5waWNrLm1vZGU9PVwiYm91bmRcIil7dGhpcy5yYXk9ZS5zY3JlZW5Qb2ludFRvUmF5KEEuaW5wdXRTeXN0ZW0ubW91c2VYLEEuaW5wdXRTeXN0ZW0ubW91c2VZKTtsZXQgdCxyPWFlLmNvbXBvbmVudHNFbmFibGVQaWNrZXJMaXN0LmdldCh0aGlzLl92aWV3KTtpZihyKWZvcihjb25zdCBzIG9mIHIpe2xldCBhPXNbMF07YS5lbmFibGUmJih0PWEucmF5UGljayh0aGlzLnJheSksdCYmKHQuY29sbGlkZXI9YSx0aGlzLl9pbnRlcmVzdExpc3QucHVzaCh0KSkpfX19fWNsYXNzIE1wIGV4dGVuZHMgTHJ7Y29uc3RydWN0b3IoZT0wLHQ9MCxyPTAscz0wKXtzdXBlcigpLG8odGhpcyxcIl9jYW1lcmFcIiksbyh0aGlzLFwiX3NjZW5lXCIpLG8odGhpcyxcIl92aWV3UG9ydFwiKSxvKHRoaXMsXCJfZW5hYmxlUGlja1wiLCExKSxvKHRoaXMsXCJfZW5hYmxlXCIsITApLG8odGhpcyxcInBpY2tGaXJlXCIpLG8odGhpcyxcImd1aVBpY2tcIiksbyh0aGlzLFwiY2FudmFzTGlzdFwiKSxvKHRoaXMsXCJncmFwaGljM0RcIiksdGhpcy5jYW52YXNMaXN0PVtdLHRoaXMuX3ZpZXdQb3J0PW5ldyBqKGUsdCxyLHMpLHRoaXMuZW5hYmxlUGljaz0hMCx0aGlzLmdyYXBoaWMzRD1uZXcgYWZ9Z2V0IGVuYWJsZSgpe3JldHVybiB0aGlzLl9lbmFibGV9c2V0IGVuYWJsZShlKXt0aGlzLl9lbmFibGU9ZX1nZXQgZW5hYmxlUGljaygpe3JldHVybiB0aGlzLl9lbmFibGVQaWNrfXNldCBlbmFibGVQaWNrKGUpe3RoaXMuX2VuYWJsZVBpY2shPWUmJih0aGlzLnBpY2tGaXJlPW5ldyBuZih0aGlzKSx0aGlzLnBpY2tGaXJlLnN0YXJ0KCkpLHRoaXMuX2VuYWJsZVBpY2s9ZX1nZXQgc2NlbmUoKXtyZXR1cm4gdGhpcy5fc2NlbmV9c2V0IHNjZW5lKGUpe3RoaXMuX3NjZW5lPWUsZS52aWV3PXRoaXMsVmUuY3JlYXRlQnVmZmVyKGUpLHRoaXMuZ3JhcGhpYzNEJiZlLmFkZENoaWxkKHRoaXMuZ3JhcGhpYzNEKSxlJiZ0aGlzLmNhbnZhc0xpc3QuZm9yRWFjaCh0PT57dCYmZS5hZGRDaGlsZCh0Lm9iamVjdDNEKX0pfWdldCBjYW1lcmEoKXtyZXR1cm4gdGhpcy5fY2FtZXJhfXNldCBjYW1lcmEoZSl7dGhpcy5fY2FtZXJhPWV9Z2V0IHZpZXdQb3J0KCl7cmV0dXJuIHRoaXMuX3ZpZXdQb3J0fXNldCB2aWV3UG9ydChlKXt0aGlzLl92aWV3UG9ydD1lfWVuYWJsZVVJQ2FudmFzKGU9MCl7bGV0IHQ9dGhpcy5jYW52YXNMaXN0W2VdO2lmKCF0KXtsZXQgcj1uZXcgdGU7ci5uYW1lPVwiQ2FudmFzIFwiK2UsdD1yLmFkZENvbXBvbmVudChDcyksdC5pbmRleD1lLHRoaXMuY2FudmFzTGlzdFtlXT10fXJldHVybiB0aGlzLnNjZW5lLmFkZENoaWxkKHQub2JqZWN0M0QpLHRoaXMuZ3VpUGlja3x8KHRoaXMuZ3VpUGljaz1uZXcgSGMsdGhpcy5ndWlQaWNrLmluaXQodGhpcykpLHR9ZGlzYWJsZVVJQ2FudmFzKGU9MCl7bGV0IHQ9dGhpcy5jYW52YXNMaXN0W2VdO3QmJnQub2JqZWN0M0QmJnQub2JqZWN0M0QucmVtb3ZlRnJvbVBhcmVudCgpfX1jbGFzcyBEcHtjb25zdHJ1Y3RvcihlKXtvKHRoaXMsXCJub3JtYWxcIiksbyh0aGlzLFwiZml4Tm9ybWFsXCIpLG8odGhpcyxcImNlbnRlclwiKSxvKHRoaXMsXCJyb3RhdGVTaGFwZVwiKSxvKHRoaXMsXCJkaXN0YW5jZVwiLDApLG8odGhpcyxcImluZGV4XCIpLHRoaXMuaW5kZXg9ZSx0aGlzLnJvdGF0ZVNoYXBlPVtdfX1jbGFzcyBQcCBleHRlbmRzIHR0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxvKHRoaXMsXCJ2U2NhbGVcIiksbyh0aGlzLFwidU5lZ2F0ZVwiKSxvKHRoaXMsXCJzZWN0aW9uc1wiKX1idWlsZChlLHQscixzPTEsYT0hMCl7aWYoci5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJwYXRoIGxlbmd0aCBpcyBub3QgZW5vdWdoXCIpO3JldHVybiB0aGlzLnZTY2FsZT1zLHRoaXMudU5lZ2F0ZT1hLGU9ZS5zbGljZSgpLHQmJmUucHVzaChlWzBdKSx0aGlzLnNlY3Rpb25zPXRoaXMuYnVpbGRTZWN0aW9ucyhlLHIpLHRoaXMuYnVpbGRHZW9tZXRyeShlLHRoaXMuc2VjdGlvbnMpLHRoaXMuYm91bmRzPW5ldyBCZShnLlpFUk8uY2xvbmUoKSxuZXcgZygxMDAsMTAwLDEwMCkpLHRoaXN9YnVpbGRTZWN0aW9ucyhlLHQpe2xldCByLHMsYSxuPVtdLGw9dC5sZW5ndGg7Zm9yKGxldCB1PTA7dTxsO3UrKyl7bGV0IGM9bmV3IERwKHUpO3I9dFt1XSxzPXRbdSsxXSxjLmNlbnRlcj1yLmNsb25lKCkscz09bnVsbD8oYy5ub3JtYWw9YS5jbG9uZSgpLGMuZGlzdGFuY2U9MCk6KGE9cy5zdWJ0cmFjdChyKSxjLmRpc3RhbmNlPWEubGVuZ3RoLGMubm9ybWFsPWEubm9ybWFsaXplKCkpLG4ucHVzaChjKX1uWzBdLmZpeE5vcm1hbD1uWzBdLm5vcm1hbC5jbG9uZSgpO2ZvcihsZXQgdT0xO3U8bDt1Kyspe2xldCBjPW5bdS0xXSxmPW5bdV07Zi5maXhOb3JtYWw9Zi5ub3JtYWwuYWRkKGMubm9ybWFsKS5ub3JtYWxpemUoKX1sZXQgaD1uZXcgVigpLmlkZW50aXR5KCk7Zm9yKGxldCB1PTA7dTxsO3UrKyl7bGV0IGM9blt1XSxmLGQ7aWYodT09MClmPWcuVVAsZD1lO2Vsc2V7bGV0IHA9blt1LTFdO2Y9cC5maXhOb3JtYWwsZD1wLnJvdGF0ZVNoYXBlfVYuZnJvbVRvUm90YXRpb24oZixjLmZpeE5vcm1hbCxoKTtmb3IobGV0IHA9MCxtPWUubGVuZ3RoO3A8bTtwKyspe2xldCBfPWgubXVsdGlwbHlQb2ludDMoZFtwXSk7Yy5yb3RhdGVTaGFwZS5wdXNoKF8pfX1yZXR1cm4gbn1idWlsZEdlb21ldHJ5KGUsdCl7bGV0IHI9dC5sZW5ndGgscz1lLmxlbmd0aCxhPXIqcyxuPXItMSxsPW5ldyBGbG9hdDMyQXJyYXkoYSozKSxoPW5ldyBGbG9hdDMyQXJyYXkoYSozKSx1PW5ldyBGbG9hdDMyQXJyYXkoYSoyKSxjPW5ldyBVaW50MzJBcnJheShuKihzLTEpKjYpLGY9cy0xLGQ9MCxwPTAsbT1bMF07Zm9yKGxldCB2PTE7djxzO3YrKylwKz1lW3YtMV0uc3VidHJhY3QoZVt2XSkubGVuZ3RoLG0ucHVzaChwKTtmb3IobGV0IHY9MDt2PHI7disrKXtsZXQgeT10W3ZdO2ZvcihsZXQgQz0wO0M8cztDKyspe2xldCBCPSh2KnMrQykqMyxUPXkucm90YXRlU2hhcGVbQ10uYWRkKHkuY2VudGVyKTtsW0JdPVQueCxsW0IrMV09VC55LGxbQisyXT1ULnosaFtCKzFdPTE7bGV0IE09KHYqcytDKSoyLEQ9bVtDXS9wO3VbTV09dGhpcy51TmVnYXRlPzEtRDpELHVbTSsxXT1kKnRoaXMudlNjYWxlfWQrPXkuZGlzdGFuY2V9bGV0IF89MDtmb3IobGV0IHY9MDt2PG47disrKXtsZXQgeT12KnM7Zm9yKGxldCBDPTA7QzxmO0MrKyl7bGV0IEI9QyxUPUMrMSxNPUIrcyxEPVQrcztjW18rK109Qit5LGNbXysrXT1UK3ksY1tfKytdPU0reSxjW18rK109VCt5LGNbXysrXT1EK3ksY1tfKytdPU0reX19cmV0dXJuIHRoaXMuc2V0SW5kaWNlcyhjKSx0aGlzLnNldEF0dHJpYnV0ZShZLnBvc2l0aW9uLGwpLHRoaXMuc2V0QXR0cmlidXRlKFkubm9ybWFsLGgpLHRoaXMuc2V0QXR0cmlidXRlKFkudXYsdSksdGhpcy5zZXRBdHRyaWJ1dGUoWS5URVhDT09SRF8xLHUpLHRoaXMuYWRkU3ViR2VvbWV0cnkoe2luZGV4U3RhcnQ6MCxpbmRleENvdW50OmMubGVuZ3RoLHZlcnRleFN0YXJ0OjAsaW5kZXg6MH0pLHRoaXMuY29tcHV0ZU5vcm1hbHMoKSx0aGlzfX1jbGFzcyBScHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcIm5hbWVcIiksbyh0aGlzLFwib2Zmc2V0XCIpLG8odGhpcyxcInNpemVcIiksbyh0aGlzLFwiYXJyYXlTdHJpZGVcIiksbyh0aGlzLFwic3RlcE1vZGVcIiksbyh0aGlzLFwiYXR0cmlidXRlc1wiKX19Y2xhc3MgTHB7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJuYW1lXCIpLG8odGhpcyxcImZvcm1hdFwiKSxvKHRoaXMsXCJvZmZzZXRcIiksbyh0aGlzLFwic2hhZGVyTG9jYXRpb25cIiksbyh0aGlzLFwic3RyaWRlXCIpfX12YXIgbGY9KGk9PihpW2kucG9zaXRpb249M109XCJwb3NpdGlvblwiLGlbaS5ub3JtYWw9M109XCJub3JtYWxcIixpW2kuVEFOR0VOVD00XT1cIlRBTkdFTlRcIixpW2kudXY9Ml09XCJ1dlwiLGlbaS5URVhDT09SRF8xPTJdPVwiVEVYQ09PUkRfMVwiLGlbaS5jb2xvcj00XT1cImNvbG9yXCIsaVtpLmpvaW50czA9NF09XCJqb2ludHMwXCIsaVtpLndlaWdodHMwPTRdPVwid2VpZ2h0czBcIixpW2kuam9pbnRzMT00XT1cImpvaW50czFcIixpW2kud2VpZ2h0czE9NF09XCJ3ZWlnaHRzMVwiLGlbaS52SW5kZXg9MV09XCJ2SW5kZXhcIixpW2kud2VpZ2h0PTFdPVwid2VpZ2h0XCIsaVtpLmFfbW9ycGhQb3NpdGlvbnNfMD0zXT1cImFfbW9ycGhQb3NpdGlvbnNfMFwiLGkpKShsZnx8e30pO2NsYXNzIFVwe2NvbnN0cnVjdG9yKCl7fX1jbGFzcyBPcHtjb25zdHJ1Y3Rvcigpe28odGhpcyxcImVudGl0eVwiKX1nZXQgZGF0YSgpe3JldHVybiBudWxsfX1jbGFzcyBoZntjb25zdHJ1Y3Rvcigpe28odGhpcyxcIm1pblwiLDApLG8odGhpcyxcIm1heFwiLDApfXNldChlLHQpe3JldHVybiB0aGlzLm1heD10LHRoaXMubWluPWUsdGhpc31jb3B5KGUpe3JldHVybiB0aGlzLm1heD1lLm1heCx0aGlzLm1pbj1lLm1pbix0aGlzfWlzSW50ZXJlc3RSYW5nZShlKXtyZXR1cm4hKHRoaXMubWF4PmUubWlufHxlLm1heDx0aGlzLm1pbil9fWNsYXNzIHVme2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX3NwYWNlRGVzY1wiKX1nZXRSYW5nZShlKXtyZXR1cm4gdGhpcy5fc3BhY2VEZXNjW2VdfWluaXRTcGFjZShlKXt0aGlzLl9zcGFjZURlc2M9e307Zm9yKGxldCB0IG9mIGUpKHRoaXMuX3NwYWNlRGVzY1t0XT1uZXcgaGYpLnNldCgtTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKTtyZXR1cm4gdGhpc31pc0NvbnRhaW4oZSx0KXtsZXQgcj10aGlzLl9zcGFjZURlc2NbZV07cmV0dXJuIHQ+PXIubWluJiZ0PHIubWF4fWlzSW50ZXJlc3RSYW5nZShlLHQpe2xldCByPXRoaXMuX3NwYWNlRGVzY1tlXTtyZXR1cm4gcj90LmlzSW50ZXJlc3RSYW5nZShyKTohMX1zcGxpdFNwYWNlKGUsdCxyKXtsZXQgcz10aGlzLl9zcGFjZURlc2NbZV07cmV0dXJuIHQ/cy5tYXg9cjpzLm1pbj1yLHRoaXN9Y29weVNwYWNlKGUpe2ZvcihsZXQgdCBpbiBlLl9zcGFjZURlc2Mpe2xldCByPWUuX3NwYWNlRGVzY1t0XTt0aGlzLl9zcGFjZURlc2NbdF0uY29weShyKX1yZXR1cm4gdGhpc319Y29uc3QgY2Y9Y2xhc3N7fTtsZXQgeXI9Y2Y7byh5cixcIk1heEVudGl0eUNvdW50SW5MZWFmXCIsNCksbyh5cixcIk1heExheWVyXCIsMTApLG8oeXIsXCJDbGVhckxlYWZMYXllclwiLGNmLk1heExheWVyLTQpO2NvbnN0IGZmPWNsYXNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwidXVpZFwiLFwiMFwiKSx0aGlzLnV1aWQ9KGZmLlVVSUQrKykudG9TdHJpbmcoKX19O2xldCBoYT1mZjtvKGhhLFwiVVVJRFwiLDApO2NsYXNzIE5we2NvbnN0cnVjdG9yKCl7byh0aGlzLFwibWFwXCIse30pLG8odGhpcyxcIl9jb3VudFwiLDApfWdldCBjb3VudCgpe3JldHVybiB0aGlzLl9jb3VudH1wdXNoKGUpe3JldHVybiB0aGlzLm1hcFtlLnV1aWRdPyExOih0aGlzLm1hcFtlLnV1aWRdPWUsdGhpcy5fY291bnQrKywhMCl9cmVtb3ZlKGUpe3JldHVybiB0aGlzLm1hcFtlXT8oZGVsZXRlIHRoaXMubWFwW2VdLHRoaXMuX2NvdW50LS0sITApOiExfX1jb25zdCBraT1jbGFzcyBleHRlbmRzIGhhe2NvbnN0cnVjdG9yKGk9MCl7c3VwZXIoKSxvKHRoaXMsXCJfZGltZW5zaW9uSW5kZXhcIiwwKSxvKHRoaXMsXCJfZGltZW5zaW9uc1wiKSxvKHRoaXMsXCJfZGltZW5zaW9uXCIpLG8odGhpcyxcIl9sZWZ0XCIpLG8odGhpcyxcIl9yaWdodFwiKSxvKHRoaXMsXCJfc3BhY2VcIiksbyh0aGlzLFwiX3BhcmVudFwiKSxvKHRoaXMsXCJfZW50aXRpZXNcIiksbyh0aGlzLFwibGF5ZXJcIiksbyh0aGlzLFwiX3NwbGl0RW50aXR5TGlzdFwiLFtdKSxvKHRoaXMsXCJwb2ludEludGVyc2VjdFwiLG5ldyBnKSx0aGlzLmxheWVyPWksa2kubm9kZUNvdW50Kyt9Z2V0IGRpbWVuc2lvbigpe3JldHVybiB0aGlzLl9kaW1lbnNpb259aW5pdE5vZGUoaSxlLHQpe3JldHVybiB0aGlzLl9kaW1lbnNpb25zPWUsdGhpcy5fZGltZW5zaW9uSW5kZXg9dCx0aGlzLl9kaW1lbnNpb249ZVt0XSx0aGlzLl9zcGFjZT1uZXcgdWYoKS5pbml0U3BhY2UoZSksaSYmdGhpcy5fc3BhY2UuY29weVNwYWNlKGkuX3NwYWNlKSx0aGlzLl9wYXJlbnQ9aSx0aGlzLl9lbnRpdGllcz1uZXcgTnAsdGhpc311cGRhdGVFbnRpdHkoaSl7aWYoaS5pc0luTm9kZSh0aGlzLHRoaXMuX2RpbWVuc2lvbikmJihpLmF0dGFjaFRyZWVOb2RlKHRoaXMpLHRoaXMuYXV0b1NwbGl0KCksdGhpcy5fbGVmdCYmdGhpcy5fcmlnaHQpKXtsZXQgZT0odGhpcy5fZGltZW5zaW9uSW5kZXgrMSkldGhpcy5fZGltZW5zaW9ucy5sZW5ndGgsdD10aGlzLl9kaW1lbnNpb25zW2VdO2kuaXNJbk5vZGUodGhpcy5fcmlnaHQsdCk/dGhpcy5fcmlnaHQudXBkYXRlRW50aXR5KGkpOmkuaXNJbk5vZGUodGhpcy5fbGVmdCx0KSYmdGhpcy5fbGVmdC51cGRhdGVFbnRpdHkoaSl9fWJ1aWxkUm9vdChpKXtmb3IoY29uc3QgZSBvZiBpKWUuZW50aXR5LmF0dGFjaFRyZWVOb2RlKHRoaXMpO3RoaXMuYXV0b1NwbGl0KCl9YXV0b1NwbGl0KCl7aWYodGhpcy5fZW50aXRpZXMuY291bnQ+eXIuTWF4RW50aXR5Q291bnRJbkxlYWYmJiF0aGlzLl9yaWdodCYmIXRoaXMuX2xlZnQmJnRoaXMubGF5ZXI8eXIuTWF4TGF5ZXIpe2xldCBpPXRoaXMuX3NwbGl0RW50aXR5TGlzdCxlPSh0aGlzLl9kaW1lbnNpb25JbmRleCsxKSV0aGlzLl9kaW1lbnNpb25zLmxlbmd0aCx0PXRoaXMuX2RpbWVuc2lvbnNbZV0scj0wO2Zvcihjb25zdCBzIGluIHRoaXMuX2VudGl0aWVzLm1hcCl7bGV0IGE9dGhpcy5fZW50aXRpZXMubWFwW3NdO3IrPWEuY2VudGVyVmFsdWUodCksaS5wdXNoKGEpfXIvPXRoaXMuX2VudGl0aWVzLmNvdW50LHRoaXMuX2xlZnQ9bmV3IGtpKHRoaXMubGF5ZXIrMSksdGhpcy5fcmlnaHQ9bmV3IGtpKHRoaXMubGF5ZXIrMSksdGhpcy5fbGVmdC5pbml0Tm9kZSh0aGlzLHRoaXMuX2RpbWVuc2lvbnMsZSksdGhpcy5fcmlnaHQuaW5pdE5vZGUodGhpcyx0aGlzLl9kaW1lbnNpb25zLGUpLHRoaXMuX2xlZnQuc2V0U3BhY2UoITAsciksdGhpcy5fcmlnaHQuc2V0U3BhY2UoITEscik7Zm9yKGxldCBzIG9mIGkpcy5pc0luTm9kZSh0aGlzLl9yaWdodCx0KT9zLmF0dGFjaFRyZWVOb2RlKHRoaXMuX3JpZ2h0KTpzLmlzSW5Ob2RlKHRoaXMuX2xlZnQsdCkmJnMuYXR0YWNoVHJlZU5vZGUodGhpcy5fbGVmdCl9dGhpcy5fbGVmdCYmdGhpcy5fbGVmdC5hdXRvU3BsaXQoKSx0aGlzLl9yaWdodCYmdGhpcy5fcmlnaHQuYXV0b1NwbGl0KCl9c2V0U3BhY2UoaSxlKXtyZXR1cm4gdGhpcy5fcGFyZW50JiZ0aGlzLl9zcGFjZS5zcGxpdFNwYWNlKHRoaXMuX2RpbWVuc2lvbixpLGUpLHRoaXN9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9sZWZ0PT1udWxsJiZ0aGlzLl9yaWdodD09bnVsbCYmdGhpcy5fZW50aXRpZXMuY291bnQ9PTB9cHVzaEVudGl0eShpKXtyZXR1cm4gdGhpcy5fZW50aXRpZXMucHVzaChpKX1yZW1vdmVFbnRpdHkoaSl7cmV0dXJuIHRoaXMuX2VudGl0aWVzLnJlbW92ZShpLnV1aWQpfWF1dG9DbGVhcigpe2xldCBpPXRoaXM7Zm9yKDtpJiZpLmxheWVyPnlyLkNsZWFyTGVhZkxheWVyJiZpLmNsZWFyTGVhZigpOylpPWkuX3BhcmVudH1jbGVhckxlYWYoKXtsZXQgaT0hdGhpcy5fbGVmdCYmIXRoaXMuX3JpZ2h0LGU9IWkmJnRoaXMuX2xlZnQuaXNFbXB0eSgpJiZ0aGlzLl9yaWdodC5pc0VtcHR5KCk7cmV0dXJuIGUmJih0aGlzLl9sZWZ0PXRoaXMuX3JpZ2h0PW51bGwsa2kubm9kZUNvdW50LT0yKSxpfHxlfWlzQ29udGFpbihpKXtyZXR1cm4gdGhpcy5fc3BhY2UuaXNDb250YWluKHRoaXMuX2RpbWVuc2lvbixpKX1ub2RlSW50ZXJzZWN0c0JveChpKXtsZXQgZT10aGlzLl9zcGFjZS5nZXRSYW5nZShcInhcIiksdD10aGlzLl9zcGFjZS5nZXRSYW5nZShcInlcIikscj10aGlzLl9zcGFjZS5nZXRSYW5nZShcInpcIikscz1raS5yYW5nZUJveDtyZXR1cm4gcy5taW4uc2V0KGUubWluLHQubWluLHIubWluKSxzLm1heC5zZXQoZS5tYXgsdC5tYXgsci5tYXgpLHMuaW50ZXJzZWN0c0JveChpKX1ub2RlSW50ZXJzZWN0c1JheShpKXtsZXQgZT10aGlzLl9zcGFjZS5nZXRSYW5nZShcInhcIiksdD10aGlzLl9zcGFjZS5nZXRSYW5nZShcInlcIikscj10aGlzLl9zcGFjZS5nZXRSYW5nZShcInpcIikscz1raS5yYW5nZUJveDtyZXR1cm4gcy5taW4uc2V0KGUubWluLHQubWluLHIubWluKSxzLm1heC5zZXQoZS5tYXgsdC5tYXgsci5tYXgpLCEwfXBvaW50Q2FzdChpLGU9MCx0KXtpZih0PXR8fFtdLHRoaXMuX2VudGl0aWVzLmNvdW50PjApe2xldCByPXRoaXMuX2VudGl0aWVzLm1hcDtmb3IobGV0IHMgaW4gcil7bGV0IGE9cltzXSxuPWEuZW50aXR5Q29udGFpblBvaW50KGkpOyFuJiZlPjAmJihuPWEuc3F1YXJlRGlzdGFuY2VUbyhpLHRoaXMuX2RpbWVuc2lvbnMpPD1lKSxuJiZ0LnB1c2goYSl9fXRoaXMuX2xlZnQmJnRoaXMuX2xlZnQuaXNDb250YWluKGlbdGhpcy5fbGVmdC5kaW1lbnNpb25dKSYmdGhpcy5fbGVmdC5wb2ludENhc3QoaSxlLHQpLHRoaXMuX3JpZ2h0JiZ0aGlzLl9yaWdodC5pc0NvbnRhaW4oaVt0aGlzLl9yaWdodC5kaW1lbnNpb25dKSYmdGhpcy5fcmlnaHQucG9pbnRDYXN0KGksZSx0KX1ib3hDYXN0KGksZSl7aWYoZT1lfHxbXSx0aGlzLl9lbnRpdGllcy5jb3VudD4wKXtsZXQgdD10aGlzLl9lbnRpdGllcy5tYXA7Zm9yKGxldCByIGluIHQpe2xldCBzPXRbcl07cy5lbnRpdHlJbnRlcnNlY3RzQm94KGkpJiZlLnB1c2gocyl9fXRoaXMuX2xlZnQmJnRoaXMuX2xlZnQubm9kZUludGVyc2VjdHNCb3goaSkmJnRoaXMuX2xlZnQuYm94Q2FzdChpLGUpLHRoaXMuX3JpZ2h0JiZ0aGlzLl9yaWdodC5ub2RlSW50ZXJzZWN0c0JveChpKSYmdGhpcy5fcmlnaHQuYm94Q2FzdChpLGUpfXJheUNhc3QoaSxlLHQpe2U9ZXx8W10sdD10fHxbXTtsZXQgcj10aGlzLnBvaW50SW50ZXJzZWN0O2lmKHRoaXMuX2VudGl0aWVzLmNvdW50PjApe2xldCBzPXRoaXMuX2VudGl0aWVzLm1hcDtmb3IobGV0IGEgaW4gcyl7bGV0IG49c1thXTtuLmVudGl0eUludGVyc2VjdHNSYXkoaSxyKSYmKHQucHVzaChuZXcgZygpLmNvcHlGcm9tKHIpKSxlLnB1c2gobikpfX10aGlzLl9sZWZ0JiZ0aGlzLl9sZWZ0Lm5vZGVJbnRlcnNlY3RzUmF5KGkpJiZ0aGlzLl9sZWZ0LnJheUNhc3QoaSxlLHQpLHRoaXMuX3JpZ2h0JiZ0aGlzLl9yaWdodC5ub2RlSW50ZXJzZWN0c1JheShpKSYmdGhpcy5fcmlnaHQucmF5Q2FzdChpLGUsdCl9fTtsZXQgZm49a2k7byhmbixcIm5vZGVDb3VudFwiLDApLG8oZm4sXCJyYW5nZUJveFwiLG5ldyBCZShuZXcgZyhOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSksbmV3IGcoLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUpKSk7Y2xhc3MgRnAgZXh0ZW5kcyBoYXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcInVzZXJEYXRhXCIpLG8odGhpcyxcIm5vZGVcIiksdGhpcy51c2VyRGF0YT1lfWNlbnRlclZhbHVlKGUpe3JldHVybiAwfWlzSW5Ob2RlKGUsdCl7cmV0dXJuITF9ZW50aXR5Q29udGFpblBvaW50KGUpe3JldHVybiExfXNxdWFyZURpc3RhbmNlVG8oZSx0KXtyZXR1cm4gTnVtYmVyLk1BWF9WQUxVRX1lbnRpdHlJbnRlcnNlY3RzQm94KGUpe3JldHVybiExfWVudGl0eUludGVyc2VjdHNSYXkoZSx0KXtyZXR1cm4hMX1hdHRhY2hUcmVlTm9kZShlKXtyZXR1cm4gdGhpcy5ub2RlJiZ0aGlzLmRldGFjaFRyZWVOb2RlKCksdGhpcy5ub2RlPWUsdGhpcy5ub2RlLnB1c2hFbnRpdHkodGhpcyl9ZGV0YWNoVHJlZU5vZGUoKXtsZXQgZT10aGlzLm5vZGUucmVtb3ZlRW50aXR5KHRoaXMpO3JldHVybiB0aGlzLm5vZGU9bnVsbCxlfXVwZGF0ZU5vZGUoZSl7bGV0IHQ9dGhpcy5ub2RlO3QmJnRoaXMuZGV0YWNoVHJlZU5vZGUoKSxlLnVwZGF0ZUVudGl0eSh0aGlzKSx0JiZ0LmF1dG9DbGVhcigpfX1jbGFzcyBkZiBleHRlbmRzIGple31vKGRmLFwiUkVTSVpFXCIsXCJyZXNpemVcIik7dmFyIGdmPShpPT4oaVtpLk1PVVNFX0xFRlQ9MF09XCJNT1VTRV9MRUZUXCIsaVtpLk1PVVNFX01JRD0xXT1cIk1PVVNFX01JRFwiLGlbaS5NT1VTRV9SSUdIVD0yXT1cIk1PVVNFX1JJR0hUXCIsaSkpKGdmfHx7fSk7Y2xhc3MgZG4gZXh0ZW5kcyBqZXt9byhkbixcIkxPQURFUl9QUk9HUkVTU1wiLFwibG9hZGVyUHJvZ3Jlc3NcIiksbyhkbixcIkxPQURFUl9DT01QTEVURVwiLFwibG9hZGVyQ29tcGxldGVcIik7Y2xhc3MgZnMgZXh0ZW5kcyBqZXt9byhmcyxcIkFEREVEXCIsXCJhZGRlZFwiKSxvKGZzLFwiUkVNT1ZFRFwiLFwicmVtb3ZlZFwiKSxvKGZzLFwiQ0hJTERfQUREX0VWRU5UXCIsXCJjaGlsZEFkZEV2ZW50XCIpLG8oZnMsXCJDSElMRF9SRU1PVkVEXCIsXCJjaGlsZFJlbW92ZWRcIik7Y2xhc3MgdWEgZXh0ZW5kcyBqZXt9byh1YSxcIlNIT1dcIixcInNob3dcIiksbyh1YSxcIkhJREVcIixcImhpZGVcIiksbyh1YSxcIlVQREFURVwiLFwidXBkYXRlXCIpO2NsYXNzIGtwe3N0YXRpYyBtZXJnZShlLHQscixzKXtsZXQgYT0wLG49MDthPU1hdGgubWF4KGUud2lkdGgsYSksYT1NYXRoLm1heCh0LndpZHRoLGEpLGE9TWF0aC5tYXgoci53aWR0aCxhKSxhPU1hdGgubWF4KHMud2lkdGgsYSksbj1NYXRoLm1heChlLmhlaWdodCxuKSxuPU1hdGgubWF4KHQuaGVpZ2h0LG4pLG49TWF0aC5tYXgoci5oZWlnaHQsbiksbj1NYXRoLm1heChzLmhlaWdodCxuKTtsZXQgbD1uZXcgb2UoYSxuLEcucmdiYTh1bm9ybSksaD1uZXcgYmUoJHUpO2guc2V0U2FtcGxlclRleHR1cmUoXCJ0ZXh0dXJlUlwiLGUpLGguc2V0U2FtcGxlclRleHR1cmUoXCJ0ZXh0dXJlR1wiLHQpLGguc2V0U2FtcGxlclRleHR1cmUoXCJ0ZXh0dXJlQlwiLHIpLGguc2V0U2FtcGxlclRleHR1cmUoXCJ0ZXh0dXJlQVwiLHMpLGguc2V0U3RvcmFnZVRleHR1cmUoXCJvdXRUZXhcIixsKSxoLndvcmtlclNpemVYPU1hdGguY2VpbChhLzgpLGgud29ya2VyU2l6ZVk9TWF0aC5jZWlsKG4vOCk7bGV0IHU9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCk7cmV0dXJuIHcuY29tcHV0ZUNvbW1hbmQodSxbaF0pLHcuZW5kQ29tbWFuZEVuY29kZXIodSksbH19Y2xhc3MgenAgZXh0ZW5kcyBKdHtjb25zdHJ1Y3RvcihlLHQscj0wKXtzdXBlcigpLHRoaXMuYnVmZmVyVHlwZT1NdC5TdHJ1Y3RTdG9yYWdlR1BVQnVmZmVyLHRoaXMuY3JlYXRlQnVmZmVyQnlTdHJ1Y3QoR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxyLGUsdCl9fWNsYXNzIGRze3N0YXRpYyBjcmVhdGVNaXBtYXAoZSx0KXtjb25zdCByPVMuZGV2aWNlO3RoaXMuX3BpcGVsaW5lTWF4fHwodGhpcy5fcGlwZWxpbmVNYXg9ci5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2xheW91dDpcImF1dG9cIixjb21wdXRlOnttb2R1bGU6ci5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6dGhpcy5jb2RlTWF4fSksZW50cnlQb2ludDpcIm1haW5cIn19KSksdGhpcy5fcGlwZWxpbmVNaW58fCh0aGlzLl9waXBlbGluZU1pbj1yLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7bGF5b3V0OlwiYXV0b1wiLGNvbXB1dGU6e21vZHVsZTpyLmNyZWF0ZVNoYWRlck1vZHVsZSh7Y29kZTp0aGlzLmNvZGVNaW59KSxlbnRyeVBvaW50OlwibWFpblwifX0pKTtsZXQgcz1NYXRoLmNlaWwoZS53aWR0aCouNSksYT1NYXRoLmNlaWwoZS5oZWlnaHQqLjUpLG49e21pcG1hcENvdW50OnQsdGV4dHVyZTplLHNyY1ZpZXc6bnVsbCxtaXBMZXZlbDoxLGRzdEhlaWdodDphLGRzdFdpZHRoOnN9O24uc3JjVmlldz1lLmdldEdQVVRleHR1cmUoKS5jcmVhdGVWaWV3KHtmb3JtYXQ6ZS5mb3JtYXQsZGltZW5zaW9uOlwiMmRcIixiYXNlTWlwTGV2ZWw6MCxtaXBMZXZlbENvdW50OjF9KSxlLndpZHRoPjEwMjQmJmUuaGVpZ2h0PjEwMjQ/dGhpcy5taXBtYXAodGhpcy5fcGlwZWxpbmVNYXgsbik6dGhpcy5taXBtYXAodGhpcy5fcGlwZWxpbmVNaW4sbil9c3RhdGljIG1pcG1hcChlLHQpe2NvbnN0IHI9Uy5kZXZpY2Uscz13LmJlZ2luQ29tbWFuZEVuY29kZXIoKTtsZXQgYT1lPT10aGlzLl9waXBlbGluZU1heCxuLGw7Zm9yKGxldCBoPXQubWlwTGV2ZWw7aDx0Lm1pcG1hcENvdW50O2grKyl7bGV0IHU9W10sYz0wO3UucHVzaCh7YmluZGluZzpjKysscmVzb3VyY2U6dC5zcmNWaWV3fSksdS5wdXNoKHtiaW5kaW5nOmMrKyxyZXNvdXJjZTp0LnRleHR1cmUuZ3B1U2FtcGxlcn0pLG49dC50ZXh0dXJlLmdldEdQVVRleHR1cmUoKS5jcmVhdGVWaWV3KHtmb3JtYXQ6dC50ZXh0dXJlLmZvcm1hdCxkaW1lbnNpb246XCIyZFwiLGJhc2VNaXBMZXZlbDpoLG1pcExldmVsQ291bnQ6MX0pLHUucHVzaCh7YmluZGluZzpjKysscmVzb3VyY2U6bn0pO2NvbnN0IGY9ci5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDplLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOnV9KSxkPXMuYmVnaW5Db21wdXRlUGFzcygpO2Quc2V0UGlwZWxpbmUoZSksZC5zZXRCaW5kR3JvdXAoMCxmKTtsZXQgcD10LmRzdFdpZHRoLG09dC5kc3RIZWlnaHQ7aWYoYSYmKHA9TWF0aC5tYXgoMSxNYXRoLmZsb29yKHQuZHN0V2lkdGgvOCkpLG09TWF0aC5tYXgoMSxNYXRoLmZsb29yKHQuZHN0SGVpZ2h0LzgpKSksZC5kaXNwYXRjaFdvcmtncm91cHMocCxtKSx0LmRzdEhlaWdodCo9LjUsdC5kc3RXaWR0aCo9LjUsdC5zcmNWaWV3PW4sdC5taXBMZXZlbD1oKzEsbD1hJiYodC5kc3RXaWR0aDw4fHx0LmRzdEhlaWdodDw4KSxkLmVuZCgpLGwpYnJlYWt9dy5lbmRDb21tYW5kRW5jb2RlcihzKSxsJiZ0aGlzLm1pcG1hcCh0aGlzLl9waXBlbGluZU1pbix0KX19byhkcyxcImNvZGVNYXhcIixgXG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXIgaW5wdXRUZXh0dXJlIDogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIGlucHV0VGV4dHVyZVNhbXBsZXIgOiBzYW1wbGVyO1xuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyIG91dHB1dFRleHR1cmUgOiB0ZXh0dXJlX3N0b3JhZ2VfMmQ8cmdiYTh1bm9ybSwgd3JpdGU+O1xuICAgICAgICBcbiAgICAgICAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKDgsIDgpXG4gICAgICAgIGZuIG1haW4oQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIEdsb2JhbEludm9jYXRpb25JRCA6IHZlYzM8dTMyPikge1xuICAgICAgICAgICAgbGV0IGRzdFNpemUgPSB0ZXh0dXJlRGltZW5zaW9ucyhvdXRwdXRUZXh0dXJlKS54eTtcbiAgICAgICAgICAgIGxldCB1djAxID0gdmVjMjxmMzI+KGYzMihHbG9iYWxJbnZvY2F0aW9uSUQueCkgLyBmMzIoZHN0U2l6ZS54IC0gMSksIGYzMihHbG9iYWxJbnZvY2F0aW9uSUQueSkgLyBmMzIoZHN0U2l6ZS55IC0gMSkpO1xuICAgICAgICAgICAgdmFyIGZyb21Db2xvciA9IHRleHR1cmVTYW1wbGVMZXZlbChpbnB1dFRleHR1cmUsIGlucHV0VGV4dHVyZVNhbXBsZXIsIHV2MDEsIDAuMCk7XG4gICAgICAgICAgICBsZXQgZHN0Q29vcmQgPSB2ZWMyPGkzMj4oaTMyKEdsb2JhbEludm9jYXRpb25JRC54KSwgaTMyKEdsb2JhbEludm9jYXRpb25JRC55KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZnJvbUNvbG9yID0gdmVjNDxmMzI+KDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICAvL2lmKGRzdFNpemUueCA9PSA1MTIpe1xuICAgICAgICAgICAgLy8gICAgZnJvbUNvbG9yLnggPSAxLjA7XG4gICAgICAgICAgICAvL31lbHNlICBpZihkc3RTaXplLnggPT0gMjU2KXtcbiAgICAgICAgICAgIC8vICAgIGZyb21Db2xvci55ID0gMS4wO1xuICAgICAgICAgICAgLy99ZWxzZSBpZihkc3RTaXplLnggPT0gMTI4KXtcbiAgICAgICAgICAgIC8vICAgIGZyb21Db2xvci56ID0gMS4wO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRleHR1cmVTdG9yZShvdXRwdXRUZXh0dXJlLCBkc3RDb29yZCwgZnJvbUNvbG9yKTtcbiAgICAgICAgfVxuICAgIGApLG8oZHMsXCJjb2RlTWluXCIsYFxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyIGlucHV0VGV4dHVyZSA6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBpbnB1dFRleHR1cmVTYW1wbGVyIDogc2FtcGxlcjtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciBvdXRwdXRUZXh0dXJlIDogdGV4dHVyZV9zdG9yYWdlXzJkPHJnYmE4dW5vcm0sIHdyaXRlPjtcbiAgICAgICAgXG4gICAgICAgIEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgxLCAxKVxuICAgICAgICBmbiBtYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJbnZvY2F0aW9uSUQgOiB2ZWMzPHUzMj4pIHtcbiAgICAgICAgICAgIGxldCBkc3RTaXplID0gdGV4dHVyZURpbWVuc2lvbnMob3V0cHV0VGV4dHVyZSkueHk7XG4gICAgICAgICAgICBsZXQgdXYwMSA9IHZlYzI8ZjMyPihmMzIoR2xvYmFsSW52b2NhdGlvbklELngpIC8gZjMyKGRzdFNpemUueCAtIDEpLCBmMzIoR2xvYmFsSW52b2NhdGlvbklELnkpIC8gZjMyKGRzdFNpemUueSAtIDEpKTtcbiAgICAgICAgICAgIHZhciBmcm9tQ29sb3IgPSB0ZXh0dXJlU2FtcGxlTGV2ZWwoaW5wdXRUZXh0dXJlLCBpbnB1dFRleHR1cmVTYW1wbGVyLCB1djAxLCAwLjApO1xuICAgICAgICAgICAgbGV0IGRzdENvb3JkID0gdmVjMjxpMzI+KGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueCksIGkzMihHbG9iYWxJbnZvY2F0aW9uSUQueSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0ZXh0dXJlU3RvcmUob3V0cHV0VGV4dHVyZSwgZHN0Q29vcmQsIGZyb21Db2xvcik7XG4gICAgICAgIH1cbiAgICBgKSxvKGRzLFwiX3BpcGVsaW5lTWF4XCIpLG8oZHMsXCJfcGlwZWxpbmVNaW5cIik7Y2xhc3MgcGZ7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJuYW1lXCIsXCJcIiksbyh0aGlzLFwicGFzc01hcFwiLG5ldyBNYXApfX1jbGFzcyBtZntjb25zdHJ1Y3Rvcigpe28odGhpcyxcInBhc3NUeXBlXCIsXCJcIiksbyh0aGlzLFwic2hhZGVyU3RhdGVcIixuZXcgTWFwKSxvKHRoaXMsXCJ2ZXJ0ZXhTaGFkZXJcIixcIlwiKSxvKHRoaXMsXCJmcmFnbWVudFNoYWRlclwiLFwiXCIpfX1jbGFzcyBDcntzdGF0aWMgcGFyc2VyKGUsdCl7ZT11dC5maWx0ZXJDb21tZW50KGUpO2xldCByPW5ldyBwZixzPWUuaW5kZXhPZih0aGlzLnNoYWRlcktleXdvcmQpLGE9ZS5pbmRleE9mKFwie1wiLHMpLG49ZS5zdWJzdHJpbmcocyt0aGlzLnNoYWRlcktleXdvcmQubGVuZ3RoLGEpLnRyaW0oKTtyLm5hbWU9bi5zdWJzdHJpbmcoMSxuLmxlbmd0aC0xKSxuPWUuc3Vic3RyaW5nKGUuaW5kZXhPZihcIntcIikrMSxlLmxhc3RJbmRleE9mKFwifVwiKSk7bGV0IGw9dGhpcy5zcGxpdFBhc3NCbG9jayhuKTtmb3IobGV0IGggb2YgbCl7bGV0IHU9dGhpcy5wYXJzZXJQYXNzQmxvY2soaCksYztyLnBhc3NNYXAuaGFzKHUucGFzc1R5cGUpP2M9ci5wYXNzTWFwLmdldCh1LnBhc3NUeXBlKTooYz1bXSxyLnBhc3NNYXAuc2V0KHUucGFzc1R5cGUsYykpLGMucHVzaCh1KSx1LnZlcnRleFNoYWRlci5sZW5ndGg+MCYmKHUudmVydGV4U2hhZGVyPXV0LnBhcnNlKHUudmVydGV4U2hhZGVyLHQpKSx1LmZyYWdtZW50U2hhZGVyLmxlbmd0aD4wJiYodS5mcmFnbWVudFNoYWRlcj11dC5wYXJzZSh1LmZyYWdtZW50U2hhZGVyLHQpKX1yZXR1cm4gcn1zdGF0aWMgc3BsaXRQYXNzQmxvY2soZSl7bGV0IHQ9MCxyPVtdO2Zvcig7dDxlLmxlbmd0aDspe2xldCBzPWUuaW5kZXhPZih0aGlzLnBhc3NLZXl3b3JkLHQpO2lmKHM9PS0xKXtyLnB1c2goZS5zdWJzdHJpbmcodCkpO2JyZWFrfXQhPTAmJnIucHVzaChlLnN1YnN0cmluZyh0LHMpKSx0PXMrdGhpcy5wYXNzS2V5d29yZC5sZW5ndGh9cmV0dXJuIHJ9c3RhdGljIHBhcnNlclBhc3NCbG9jayhlKXtsZXQgdD1uZXcgbWYscj1lLmluZGV4T2YodGhpcy5wYXNzVHlwZUtleXdvcmQpLHM9ZS5pbmRleE9mKCdcIicscik7cmV0dXJuIHI9ZS5pbmRleE9mKCdcIicscysxKSx0LnBhc3NUeXBlPWUuc3Vic3RyaW5nKHIrMSxzKS50cmltKCksdGhpcy5wYXJzZXJTaGFkZXJTdGF0ZSh0LGUpLHI9ZS5pbmRleE9mKHRoaXMudmVydGV4S2V5d29yZCksciE9LTEmJih0LnZlcnRleFNoYWRlcj10aGlzLmV4dHJhY3RCbG9jayhlLnN1YnN0cmluZyhyK3RoaXMudmVydGV4S2V5d29yZC5sZW5ndGgpLFwie1wiLFwifVwiKSkscj1lLmluZGV4T2YodGhpcy5mcmFnbWVudEtleXdvcmQpLHIhPS0xJiYodC5mcmFnbWVudFNoYWRlcj10aGlzLmV4dHJhY3RCbG9jayhlLnN1YnN0cmluZyhyK3RoaXMuZnJhZ21lbnRLZXl3b3JkLmxlbmd0aCksXCJ7XCIsXCJ9XCIpKSx0fXN0YXRpYyBwYXJzZXJTaGFkZXJTdGF0ZShlLHQpe2xldCByPXQuaW5kZXhPZihcIlNoYWRlclN0YXRlXCIpO2lmKHI9PS0xKXJldHVybiExO3I9dC5pbmRleE9mKFwie1wiLHIpO2xldCBzPXQuaW5kZXhPZihcIn1cIixyKSxuPXQuc3Vic3RyaW5nKHIrMSxzKS5zcGxpdChcIixcIik7Zm9yKGxldCBsIG9mIG4pe2xldCBoPWwuc3BsaXQoXCI6XCIpLHU9aFswXS50cmltKCksYz10aGlzLmNvbnZlcnRWYWx1ZShoWzFdLnRyaW0oKSk7ZS5zaGFkZXJTdGF0ZS5zZXQodSxjKX1yZXR1cm4hMH1zdGF0aWMgY29udmVydFZhbHVlKGUpe3JldHVybiBlLmxlbmd0aD09NCYmZS50b0xvd2VyQ2FzZSgpPT1cInRydWVcIj8hMDplLmxlbmd0aD09NSYmZS50b0xvd2VyQ2FzZSgpPT1cImZhbHNlXCI/ITE6ZVswXT09J1wiJz9lLnN1YnN0cmluZygxLGUubGVuZ3RoLTEpOk51bWJlci5wYXJzZUludChlKX1zdGF0aWMgZXh0cmFjdEJsb2NrKGUsdCxyKXtsZXQgcz1lLmluZGV4T2YodCk7aWYocz09LTEpcmV0dXJuXCJcIjtsZXQgYT0wLG49MDtlPWUuc3Vic3RyaW5nKHMpO2ZvcihsZXQgaCBvZiBlKXtpZihoPT10P2ErKzpoPT1yJiZhLS0sYTw9MClicmVhaztuKyt9cmV0dXJuIGUuc3Vic3RyaW5nKDEsbikudHJpbSgpfX1vKENyLFwicGFzc0tleXdvcmRcIixcInBhc3NcIiksbyhDcixcInNoYWRlcktleXdvcmRcIixcIlNoYWRlclwiKSxvKENyLFwidmVydGV4S2V5d29yZFwiLFwidmVydGV4XCIpLG8oQ3IsXCJmcmFnbWVudEtleXdvcmRcIixcImZyYWdtZW50XCIpLG8oQ3IsXCJwYXNzVHlwZUtleXdvcmRcIixcIlBhc3NUeXBlXCIpO2xldCBBZj1uZXcgamUoXCJJcnJhZGlhbmNlRGF0YVJlYWRlckNvbXBsZXRlRXZlbnRcIik7Y2xhc3MgRXMgZXh0ZW5kcyBoaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwicmVhZEZsYWdcIiwhMSksbyh0aGlzLFwicHJvYmVSZW5kZXJlclwiKSxvKHRoaXMsXCJvcENvbG9yQnVmZmVyXCIpLG8odGhpcyxcIm9wRGVwdGhCdWZmZXJcIiksbyh0aGlzLFwic3JjQ29sb3JNYXBcIiksbyh0aGlzLFwic3JjRGVwdGhNYXBcIiksbyh0aGlzLFwib3BEZXB0aEFycmF5XCIpLG8odGhpcyxcIm9wQ29sb3JBcnJheVwiKX1pbml0UmVhZGVyKGUsdCxyKXt0aGlzLnByb2JlUmVuZGVyZXI9ZSx0aGlzLnNyY0NvbG9yTWFwPXQsdGhpcy5zcmNEZXB0aE1hcD1yO2xldCBzPUEuc2V0dGluZy5naSxhPXMub2N0UlRNYXhTaXplKnMub2N0UlRNYXhTaXplO3RoaXMub3BDb2xvckJ1ZmZlcj1TLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6YSo0KjQsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQsbWFwcGVkQXRDcmVhdGlvbjohMX0pLHRoaXMub3BDb2xvckFycmF5PW5ldyBGbG9hdDMyQXJyYXkoYSo0KSx0aGlzLm9wRGVwdGhCdWZmZXI9Uy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOmEqNCo0LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFELG1hcHBlZEF0Q3JlYXRpb246ITF9KSx0aGlzLm9wRGVwdGhBcnJheT1uZXcgRmxvYXQzMkFycmF5KGEqNCksdGhpcy5wcm9iZVJlbmRlcmVyLmFkZEV2ZW50TGlzdGVuZXIoQ28udHlwZSwoKT0+e3RoaXMub25Qcm9iZVJlbmRlckNvbXBsZXRlKCl9LHRoaXMpLHRoaXMucHJvYmVSZW5kZXJlci5hZGRFdmVudExpc3RlbmVyKEhzLnR5cGUsKCk9Pntjb25zb2xlLmxvZyhcIkdJUmVuZGVyU3RhcnRFdmVudFwiKX0sdGhpcyl9YXN5bmMgb25Qcm9iZVJlbmRlckNvbXBsZXRlKCl7aWYoY29uc29sZS5sb2coXCJHSVJlbmRlckNvbXBsZXRlRXZlbnRcIiksdGhpcy5yZWFkRmxhZyljb25zb2xlLmxvZyhcImlycmFkaWFuY2VEYXRhUmVhZGVyIGlzIHJlYWRpbmcgeWV0ISEhXCIpO2Vsc2V7dGhpcy5yZWFkRmxhZz0hMDtsZXQgZT1EYXRlLm5vdygpO2NvbnNvbGUubG9nKFwiaXJyYWRpYW5jZURhdGFSZWFkZXIgc3RhcnQgcmVhZGluZyBcIiksYXdhaXQgRXMucmVhZCh0aGlzLnNyY0NvbG9yTWFwLmdldEdQVVRleHR1cmUoKSx0aGlzLm9wQ29sb3JCdWZmZXIsdGhpcy5vcENvbG9yQXJyYXkpLGF3YWl0IEVzLnJlYWQodGhpcy5zcmNEZXB0aE1hcC5nZXRHUFVUZXh0dXJlKCksdGhpcy5vcERlcHRoQnVmZmVyLHRoaXMub3BEZXB0aEFycmF5KSx0aGlzLnJlYWRGbGFnPSExLGNvbnNvbGUubG9nKFwicHJvY2VzcyB0aW1lIDpcIixEYXRlLm5vdygpLWUpLGNvbnNvbGUubG9nKFwiaXJyYWRpYW5jZURhdGFSZWFkZXIgcmVhZCBjb21wbGV0ZVwiKSx0aGlzLmRpc3BhdGNoRXZlbnQoQWYpfX1zdGF0aWMgYXN5bmMgcmVhZChlLHQscil7bGV0IHM9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCk7cy5jb3B5VGV4dHVyZVRvQnVmZmVyKHt0ZXh0dXJlOmV9LHtidWZmZXI6dCxieXRlc1BlclJvdzplLndpZHRoKjE2fSxbZS53aWR0aCxlLmhlaWdodF0pLHcuZW5kQ29tbWFuZEVuY29kZXIocyksYXdhaXQgdC5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2NvbnN0IGE9dC5nZXRNYXBwZWRSYW5nZSgpO3Iuc2V0KG5ldyBGbG9hdDMyQXJyYXkoYSksMCksdC51bm1hcCgpfX1sZXQgR3A9bmV3IEVzO2NsYXNzIFFwe2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiY29tcHV0ZVNoYWRlclwiKSxvKHRoaXMsXCJ2aXNpYmxlQnVmZmVyXCIpLG8odGhpcyxcInRleHR1cmVcIiksdGhpcy5jb21wdXRlU2hhZGVyPW5ldyBiZShwYyksdGhpcy52aXNpYmxlQnVmZmVyPW5ldyBpcig4MTkyKjIpLHRoaXMuY29tcHV0ZVNoYWRlci5zZXRTdG9yYWdlQnVmZmVyKFwidmlzaWJsZUJ1ZmZlclwiLHRoaXMudmlzaWJsZUJ1ZmZlciksdGhpcy50ZXh0dXJlPUZlLmdldFRleHR1cmUoQWUuekJ1ZmZlclRleHR1cmVfTkFNRSksdGhpcy5jb21wdXRlU2hhZGVyLnNldFNhbXBsZXJUZXh0dXJlKFwiekJ1ZmZlclRleHR1cmVcIix0aGlzLnRleHR1cmUpLHRoaXMuY29tcHV0ZVNoYWRlci53b3JrZXJTaXplWD1NYXRoLmNlaWwodGhpcy50ZXh0dXJlLndpZHRoLzgpLHRoaXMuY29tcHV0ZVNoYWRlci53b3JrZXJTaXplWT1NYXRoLmNlaWwodGhpcy50ZXh0dXJlLmhlaWdodC84KSx0aGlzLmNvbXB1dGVTaGFkZXIud29ya2VyU2l6ZVo9MX1jb21wdXRlKGUsdCl7dGhpcy52aXNpYmxlQnVmZmVyLnJlc2V0KCEwLDApLHRoaXMudmlzaWJsZUJ1ZmZlci5hcHBseSgpO2xldCByPXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO3cuY29tcHV0ZUNvbW1hbmQocixbdGhpcy5jb21wdXRlU2hhZGVyXSksdGhpcy52aXNpYmxlQnVmZmVyLnJlYWRCdWZmZXIoKSx0LnpWaXNpYmxlTGlzdD10aGlzLnZpc2libGVCdWZmZXIub3V0RmxvYXQzMkFycmF5fX1jbGFzcyBWcCBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJibHVyVGV4dHVyZTFcIiksbyh0aGlzLFwiYmx1clRleHR1cmUyXCIpLG8odGhpcyxcInJlbmRlcmVyUGFzc1N0YXRlXCIpLG8odGhpcyxcImJsdXJDb21wdXRlc1wiKSxvKHRoaXMsXCJibHVyU2V0dGluZ3NcIiksbyh0aGlzLFwib3V0VGV4dHVyZVwiKSxvKHRoaXMsXCJydEZyYW1lXCIpfW9uQXR0YWNoKGUpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXcuZW5hYmxlPSEwfW9uRGV0YWNoKGUpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXcuZW5hYmxlPSExfWNyZWF0ZUdVSSgpe31nZXQgcGl4ZWxPZmZzZXQoKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5kZXB0aE9mVmlldy5waXhlbE9mZnNldH1zZXQgcGl4ZWxPZmZzZXQoZSl7ZT1NYXRoLm1heCgwLGUpO2xldCB0PUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXc7dC5waXhlbE9mZnNldD1lfWdldCBuZWFyKCl7cmV0dXJuIEEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXcubmVhcn1zZXQgbmVhcihlKXtlPU1hdGgubWF4KDAsZSk7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5kZXB0aE9mVmlldzt0Lm5lYXI9ZX1nZXQgZmFyKCl7cmV0dXJuIEEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXcuZmFyfXNldCBmYXIoZSl7ZT1NYXRoLm1heCgwLGUpO2xldCB0PUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXc7dC5mYXI9ZX1jcmVhdGVCbHVyQ29tcHV0ZSgpe3RoaXMuYmx1clNldHRpbmdzPVtdLHRoaXMuYmx1ckNvbXB1dGVzPVtdO2xldCBlPUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXc7Zm9yKGxldCB0PTA7dDxlLml0ZXJhdGlvbkNvdW50O3QrKyl7bGV0IHI9bmV3IER0KDQpLHM9bmV3IGJlKEt1KTt0aGlzLmJsdXJDb21wdXRlcy5wdXNoKHMpLHRoaXMuYmx1clNldHRpbmdzLnB1c2gocikscy5zZXRVbmlmb3JtQnVmZmVyKFwiYmx1clNldHRpbmdcIixyKTtsZXQgYT13dC5nZXRHQnVmZmVyRnJhbWUoXCJDb2xvclBhc3NHQnVmZmVyXCIpO3Muc2V0U2FtcGxlclRleHR1cmUoQWUucG9zaXRpb25CdWZmZXJUZXhfTkFNRSxhLmF0dGFjaG1lbnRzWzFdKSxzLnNldFNhbXBsZXJUZXh0dXJlKEFlLm5vcm1hbEJ1ZmZlclRleF9OQU1FLGEuYXR0YWNobWVudHNbMl0pO2xldCBuPXQlMj09MD90aGlzLmJsdXJUZXh0dXJlMTp0aGlzLmJsdXJUZXh0dXJlMixsPXQlMj09MT90aGlzLmJsdXJUZXh0dXJlMTp0aGlzLmJsdXJUZXh0dXJlMjtzLnNldFNhbXBsZXJUZXh0dXJlKFwiaW5UZXhcIixuKSxzLnNldFN0b3JhZ2VUZXh0dXJlKFwib3V0VGV4XCIsbCkscy53b3JrZXJTaXplWD1NYXRoLmNlaWwodGhpcy5ibHVyVGV4dHVyZTEud2lkdGgvOCkscy53b3JrZXJTaXplWT1NYXRoLmNlaWwodGhpcy5ibHVyVGV4dHVyZTEuaGVpZ2h0LzgpLHMud29ya2VyU2l6ZVo9MSx0aGlzLm91dFRleHR1cmU9bH19Y3JlYXRlUmVzb3VyY2UoKXtsZXQgZT1TLnByZXNlbnRhdGlvblNpemUsdD1lWzBdLHI9ZVsxXTt0aGlzLmJsdXJUZXh0dXJlMT1uZXcgb2UodCxyLEcucmdiYTE2ZmxvYXQsITEsR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDfEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcpLHRoaXMuYmx1clRleHR1cmUxLm5hbWU9XCJkb2YxXCI7bGV0IHM9bmV3IENlO3MuY2xlYXJWYWx1ZT1bMCwwLDAsMV0scy5sb2FkT3A9XCJjbGVhclwiLHRoaXMuYmx1clRleHR1cmUyPW5ldyBvZSh0LHIsRy5yZ2JhMTZmbG9hdCwhMSxHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HfEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVHxHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkN8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyksdGhpcy5ibHVyVGV4dHVyZTIubmFtZT1cImRvZjJcIjtsZXQgYT1uZXcgQ2U7YS5jbGVhclZhbHVlPVswLDAsMCwxXSxhLmxvYWRPcD1cImNsZWFyXCIsdGhpcy5ydEZyYW1lPW5ldyBaZShbdGhpcy5ibHVyVGV4dHVyZTEsdGhpcy5ibHVyVGV4dHVyZTJdLFtzLGFdKX1yZW5kZXIoZSx0KXtpZighdGhpcy5ibHVyQ29tcHV0ZXMpe3RoaXMuY3JlYXRlUmVzb3VyY2UoKSx0aGlzLmNyZWF0ZUJsdXJDb21wdXRlKCksdGhpcy5jcmVhdGVHVUkoKTtsZXQgcz1wZS5nZXRDYW1lcmFHcm91cChlLmNhbWVyYSk7Zm9yKGxldCBhPTA7YTx0aGlzLmJsdXJDb21wdXRlcy5sZW5ndGg7YSsrKXRoaXMuYmx1ckNvbXB1dGVzW2FdLnNldFVuaWZvcm1CdWZmZXIoXCJzdGFuZFVuaWZvcm1cIixzLnVuaWZvcm1HUFVCdWZmZXIpO3RoaXMucmVuZGVyZXJQYXNzU3RhdGU9SGUuY3JlYXRlUmVuZGVyZXJQYXNzU3RhdGUodGhpcy5ydEZyYW1lLG51bGwpfXRoaXMuYXV0b1NldENvbG9yVGV4dHVyZShcImluVGV4XCIsdGhpcy5ibHVyQ29tcHV0ZXNbMF0pO2xldCByPUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZGVwdGhPZlZpZXc7ci5mYXI9TWF0aC5tYXgoci5uZWFyLHIuZmFyKSsxZS00O2ZvcihsZXQgcz0wO3M8ci5pdGVyYXRpb25Db3VudDtzKyspe2xldCBhPXRoaXMuYmx1ckNvbXB1dGVzW3NdLG49dGhpcy5ibHVyU2V0dGluZ3Nbc107bi5zZXRGbG9hdChcIm5lYXJcIixyLm5lYXIpLG4uc2V0RmxvYXQoXCJmYXJcIixyLmZhciksbi5zZXRGbG9hdChcInBpeGVsT2Zmc2V0XCIsKHMrMSkqci5waXhlbE9mZnNldCksbi5hcHBseSgpLGEuc2V0U3RvcmFnZUJ1ZmZlcihcImJsdXJTZXR0aW5nXCIsbil9dy5jb21wdXRlQ29tbWFuZCh0LHRoaXMuYmx1ckNvbXB1dGVzKSx3Lmxhc3RSZW5kZXJQYXNzU3RhdGU9dGhpcy5yZW5kZXJlclBhc3NTdGF0ZX19Y2xhc3MgSHAgZXh0ZW5kcyBDdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiZ3Rhb1RleHR1cmVcIiksbyh0aGlzLFwicmVuZGVyZXJQYXNzU3RhdGVcIiksbyh0aGlzLFwiZ3Rhb0NvbXB1dGVcIiksbyh0aGlzLFwiZ3Rhb1NldHRpbmdcIiksbyh0aGlzLFwiYW9CdWZmZXJcIiksbyh0aGlzLFwiZGlyZWN0aW9uc0J1ZmZlclwiKSxvKHRoaXMsXCJkaXJlY3Rpb25zQXJyYXlcIiksbyh0aGlzLFwicnRGcmFtZVwiKSxvKHRoaXMsXCJSZW5kZXJcIiksbyh0aGlzLFwicmFuZG9tQ291bnRcIiwwKX1vbkF0dGFjaChlKXtBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW8uZW5hYmxlPSEwLHRoaXMuY3JlYXRlR1VJKCl9b25EZXRhY2goZSl7QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5ndGFvLmVuYWJsZT0hMSx0aGlzLnJlbW92ZUdVSSgpfWdldCBtYXhEaXN0YW5jZSgpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW8ubWF4RGlzdGFuY2V9c2V0IG1heERpc3RhbmNlKGUpe2U9SyhlLC4xLDUwKTtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW87dC5tYXhEaXN0YW5jZT1lfWdldCBtYXhQaXhlbCgpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW8ubWF4UGl4ZWx9c2V0IG1heFBpeGVsKGUpe2U9SyhlLDUsMTAwKTtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW87dC5tYXhQaXhlbD1lfWdldCBkYXJrRmFjdG9yKCl7cmV0dXJuIEEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ3Rhby5kYXJrRmFjdG9yfXNldCBkYXJrRmFjdG9yKGUpe2U9SyhlLC4wMSwxKTtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW87dC5kYXJrRmFjdG9yPWV9Z2V0IHJheU1hcmNoU2VnbWVudCgpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW8ucmF5TWFyY2hTZWdtZW50fXNldCByYXlNYXJjaFNlZ21lbnQoZSl7ZT1LKGUsNCwxMCk7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5ndGFvO3QucmF5TWFyY2hTZWdtZW50PWV9Z2V0IG11bHRpQm91bmNlKCl7cmV0dXJuIEEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ3Rhby5tdWx0aUJvdW5jZX1zZXQgbXVsdGlCb3VuY2UoZSl7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5ndGFvO3QubXVsdGlCb3VuY2U9ZX1nZXQgYmxlbmRDb2xvcigpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW8uYmxlbmRDb2xvcn1zZXQgYmxlbmRDb2xvcihlKXtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmd0YW87dC5ibGVuZENvbG9yPWV9Z2V0IHVzZVBvc0Zsb2F0MzIoKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5ndGFvLnVzZVBvc0Zsb2F0MzJ9c2V0IHVzZVBvc0Zsb2F0MzIoZSl7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5ndGFvO3QudXNlUG9zRmxvYXQzMj1lfWNyZWF0ZUdVSSgpe31yZW1vdmVHVUkoKXt9Y3JlYXRlQ29tcHV0ZSgpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ3Rhbyx0aGlzLmd0YW9Db21wdXRlPW5ldyBiZShKdSk7bGV0IGU9bmV3IER0KDQqMik7dGhpcy5ndGFvQ29tcHV0ZS5zZXRVbmlmb3JtQnVmZmVyKFwiZ3Rhb0RhdGFcIixlKSx0aGlzLmRpcmVjdGlvbnNBcnJheT1uZXcgRmxvYXQzMkFycmF5KDgqMiksdGhpcy5kaXJlY3Rpb25zQnVmZmVyPW5ldyBnZSg4KjIpLHRoaXMuZGlyZWN0aW9uc0J1ZmZlci5zZXRGbG9hdDMyQXJyYXkoXCJhcnJheVwiLHRoaXMucmFuZG9tRGlyZWN0aW9uKCkpLHRoaXMuZGlyZWN0aW9uc0J1ZmZlci5hcHBseSgpLHRoaXMuZ3Rhb0NvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcImRpcmVjdGlvbnNcIix0aGlzLmRpcmVjdGlvbnNCdWZmZXIpLHRoaXMuYW9CdWZmZXI9bmV3IGdlKHRoaXMuZ3Rhb1RleHR1cmUud2lkdGgqdGhpcy5ndGFvVGV4dHVyZS5oZWlnaHQpLHRoaXMuZ3Rhb0NvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcImFvQnVmZmVyXCIsdGhpcy5hb0J1ZmZlcik7bGV0IHQ9d3QuZ2V0R0J1ZmZlckZyYW1lKFwiQ29sb3JQYXNzR0J1ZmZlclwiKSxyPXQuYXR0YWNobWVudHNbMV07dGhpcy5ndGFvQ29tcHV0ZS5zZXRTYW1wbGVyVGV4dHVyZShcInBvc1RleFwiLHIpLHRoaXMuZ3Rhb0NvbXB1dGUuc2V0U2FtcGxlclRleHR1cmUoXCJub3JtYWxUZXhcIix0LmF0dGFjaG1lbnRzWzJdKSx0aGlzLmF1dG9TZXRDb2xvclRleHR1cmUoXCJpblRleFwiLHRoaXMuZ3Rhb0NvbXB1dGUpLHRoaXMuZ3Rhb0NvbXB1dGUuc2V0U3RvcmFnZVRleHR1cmUoXCJvdXRUZXhcIix0aGlzLmd0YW9UZXh0dXJlKSx0aGlzLmd0YW9Db21wdXRlLndvcmtlclNpemVYPU1hdGguY2VpbCh0aGlzLmd0YW9UZXh0dXJlLndpZHRoLzgpLHRoaXMuZ3Rhb0NvbXB1dGUud29ya2VyU2l6ZVk9TWF0aC5jZWlsKHRoaXMuZ3Rhb1RleHR1cmUuaGVpZ2h0LzgpLHRoaXMuZ3Rhb0NvbXB1dGUud29ya2VyU2l6ZVo9MSx0aGlzLmd0YW9TZXR0aW5nPWV9Y3JlYXRlUmVzb3VyY2UoKXtsZXQgZT1TLnByZXNlbnRhdGlvblNpemUsdD1lWzBdLHI9ZVsxXTt0aGlzLmd0YW9UZXh0dXJlPW5ldyBvZSh0LHIsRy5yZ2JhMTZmbG9hdCwhMSxHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HfEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVHxHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkN8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyksdGhpcy5ndGFvVGV4dHVyZS5uYW1lPVwiZ3Rhb1RleFwiO2xldCBzPW5ldyBDZTtzLmxvYWRPcD1cImxvYWRcIix0aGlzLnJ0RnJhbWU9bmV3IFplKFt0aGlzLmd0YW9UZXh0dXJlXSxbc10pfXJhbmRvbURpcmVjdGlvbigpe3RoaXMucmFuZG9tQ291bnQrKyx0aGlzLnJhbmRvbUNvdW50PjEmJih0aGlzLnJhbmRvbUNvdW50PTApO2xldCBlPU1hdGguUEkqMip0aGlzLnJhbmRvbUNvdW50LzE2LHQ9TWF0aC5QSSoyLzg7Zm9yKGxldCByPTA7cjw4O3IrKyl7bGV0IHM9ZStyKnQ7dGhpcy5kaXJlY3Rpb25zQXJyYXlbcioyXT1NYXRoLnNpbihzKSx0aGlzLmRpcmVjdGlvbnNBcnJheVtyKjIrMV09TWF0aC5jb3Mocyl9cmV0dXJuIHRoaXMuZGlyZWN0aW9uc0FycmF5fXJlbmRlcihlLHQpe2lmKCF0aGlzLmd0YW9Db21wdXRlKXt0aGlzLmNyZWF0ZVJlc291cmNlKCksdGhpcy5jcmVhdGVDb21wdXRlKCksdGhpcy5yZW5kZXJlclBhc3NTdGF0ZT1IZS5jcmVhdGVSZW5kZXJlclBhc3NTdGF0ZSh0aGlzLnJ0RnJhbWUsbnVsbCksdGhpcy5yZW5kZXJlclBhc3NTdGF0ZS5sYWJlbD1cIkdUQU9cIjtsZXQgaD1wZS5nZXRDYW1lcmFHcm91cChlLmNhbWVyYSk7dGhpcy5ndGFvQ29tcHV0ZS5zZXRVbmlmb3JtQnVmZmVyKFwiZ2xvYmFsVW5pZm9ybVwiLGgudW5pZm9ybUdQVUJ1ZmZlcil9bGV0IHI9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5ndGFvO3RoaXMuZGlyZWN0aW9uc0J1ZmZlci5zZXRGbG9hdDMyQXJyYXkoXCJhcnJheVwiLHRoaXMucmFuZG9tRGlyZWN0aW9uKCkpLHRoaXMuZGlyZWN0aW9uc0J1ZmZlci5hcHBseSgpO2xldCBzPTEtLjIqKGhlLmZyYW1lJTIpLGE9ci5tYXhEaXN0YW5jZSpzLG49ci5tYXhQaXhlbCpzO3RoaXMuZ3Rhb1NldHRpbmcuc2V0RmxvYXQoXCJtYXhEaXN0YW5jZVwiLGEpLHRoaXMuZ3Rhb1NldHRpbmcuc2V0RmxvYXQoXCJtYXhQaXhlbFwiLG4pLHRoaXMuZ3Rhb1NldHRpbmcuc2V0RmxvYXQoXCJkYXJrRmFjdG9yXCIsci5kYXJrRmFjdG9yKSx0aGlzLmd0YW9TZXR0aW5nLnNldEZsb2F0KFwicmF5TWFyY2hTZWdtZW50XCIsci5yYXlNYXJjaFNlZ21lbnQpO2xldCBsPWUuY2FtZXJhO3RoaXMuZ3Rhb1NldHRpbmcuc2V0RmxvYXQoXCJjYW1lcmFOZWFyXCIsbC5uZWFyKSx0aGlzLmd0YW9TZXR0aW5nLnNldEZsb2F0KFwiY2FtZXJhRmFyXCIsbC5mYXIpLHRoaXMuZ3Rhb1NldHRpbmcuc2V0RmxvYXQoXCJtdWx0aUJvdW5jZVwiLHIubXVsdGlCb3VuY2U/MTowKSx0aGlzLmd0YW9TZXR0aW5nLnNldEZsb2F0KFwiYmxlbmRDb2xvclwiLHIuYmxlbmRDb2xvcj8xOjApLHRoaXMuZ3Rhb1NldHRpbmcuYXBwbHkoKSx3LmNvbXB1dGVDb21tYW5kKHQsW3RoaXMuZ3Rhb0NvbXB1dGVdKSx3Lmxhc3RSZW5kZXJQYXNzU3RhdGU9dGhpcy5yZW5kZXJlclBhc3NTdGF0ZX19Y2xhc3MgWXAgZXh0ZW5kcyBDdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwidmlld1F1YWRcIiksbyh0aGlzLFwicnRUZXh0dXJlXCIpLG8odGhpcyxcIl9nbG9iYWxGb2dcIiksbyh0aGlzLFwiX2xhc3RTa3lUZXh0dXJlXCIpO2xldCBlPXRoaXMuX2dsb2JhbEZvZz1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmdsb2JhbEZvZyx0PXd0LmdldEdCdWZmZXJGcmFtZShcIkNvbG9yUGFzc0dCdWZmZXJcIikscj1TLnByZXNlbnRhdGlvblNpemU7Ti5yZWdpc3RlcihcIkdsb2JhbEZvZ19zaGFkZXJcIixFYyk7bGV0IHM9e2ZvZ0NvbG9yOm5ldyAkKG5ldyB6KGUuZm9nQ29sb3IucixlLmZvZ0NvbG9yLmcsZS5mb2dDb2xvci5iLGUuZm9nQ29sb3IuYSkpLGZvZ1R5cGU6bmV3ICQoZS5mb2dUeXBlKSxmb2dIZWlnaHRTY2FsZTpuZXcgJChlLmZvZ0hlaWdodFNjYWxlKSxzdGFydDpuZXcgJChlLnN0YXJ0KSxlbmQ6bmV3ICQoZS5lbmQpLGRlbnNpdHk6bmV3ICQoZS5kZW5zaXR5KSxpbnM6bmV3ICQoZS5pbnMpLGZhbGxvZmY6bmV3ICQoZS5mYWxsb2ZmKSxyYXlMZW5ndGg6bmV3ICQoZS5yYXlMZW5ndGgpLHNjYXR0ZXJpbmdFeHBvbmVudDpuZXcgJChlLnNjYXR0ZXJpbmdFeHBvbmVudCksZGlySGVpZ2h0TGluZTpuZXcgJChlLmRpckhlaWdodExpbmUpLHNreUZhY3RvcjpuZXcgJChlLnNreUZhY3Rvciksc2t5Um91Z2huZXNzOm5ldyAkKGUuc2t5Um91Z2huZXNzKSxvdmVycmlkZVNreUZhY3RvcjpuZXcgJChlLm92ZXJyaWRlU2t5RmFjdG9yKSxpc1NreUhEUjpuZXcgJCgwKX07dGhpcy5ydFRleHR1cmU9dGhpcy5jcmVhdGVSVFRleHR1cmUoXCJHbG9iYWxGb2dcIixyWzBdLHJbMV0sRy5yZ2JhMTZmbG9hdCksdGhpcy52aWV3UXVhZD10aGlzLmNyZWF0ZVZpZXdRdWFkKFwiR2xvYmFsRm9nXCIsXCJHbG9iYWxGb2dfc2hhZGVyXCIsdGhpcy5ydFRleHR1cmUscyk7bGV0IGE9dC5nZXRQb3NpdGlvbk1hcCgpLG49dC5nZXROb3JtYWxNYXAoKTt0aGlzLnNldElucHV0VGV4dHVyZShhLG4pfW9uQXR0YWNoKGUpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ2xvYmFsRm9nLmVuYWJsZT0hMH1vbkRldGFjaChlKXtBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmdsb2JhbEZvZy5lbmFibGU9ITF9c2V0IGZvZ1R5cGUoZSl7dGhpcy5fZ2xvYmFsRm9nLmZvZ1R5cGU9ZSx0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLmZvZ1R5cGUudmFsdWU9ZX1nZXQgZm9nVHlwZSgpe3JldHVybiB0aGlzLl9nbG9iYWxGb2cuZm9nVHlwZX1zZXQgZm9nSGVpZ2h0U2NhbGUoZSl7dGhpcy5fZ2xvYmFsRm9nLmZvZ0hlaWdodFNjYWxlPWUsdGhpcy52aWV3UXVhZC51bmlmb3Jtcy5mb2dIZWlnaHRTY2FsZS52YWx1ZT1lfWdldCBmb2dIZWlnaHRTY2FsZSgpe3JldHVybiB0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLmZvZ0hlaWdodFNjYWxlLnZhbHVlfXNldCBzdGFydChlKXt0aGlzLl9nbG9iYWxGb2cuc3RhcnQ9ZSx0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLnN0YXJ0LnZhbHVlPWV9Z2V0IHN0YXJ0KCl7cmV0dXJuIHRoaXMudmlld1F1YWQudW5pZm9ybXMuc3RhcnQudmFsdWV9c2V0IGVuZChlKXt0aGlzLl9nbG9iYWxGb2cuZW5kPWUsdGhpcy52aWV3UXVhZC51bmlmb3Jtcy5lbmQudmFsdWU9ZX1nZXQgZW5kKCl7cmV0dXJuIHRoaXMudmlld1F1YWQudW5pZm9ybXMuZW5kLnZhbHVlfXNldCBpbnMoZSl7dGhpcy5fZ2xvYmFsRm9nLmlucz1lLHRoaXMudmlld1F1YWQudW5pZm9ybXMuaW5zLnZhbHVlPWV9Z2V0IGlucygpe3JldHVybiB0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLmlucy52YWx1ZX1zZXQgZGVuc2l0eShlKXt0aGlzLl9nbG9iYWxGb2cuZGVuc2l0eT1lLHRoaXMudmlld1F1YWQudW5pZm9ybXMuZGVuc2l0eS52YWx1ZT1lfWdldCBkZW5zaXR5KCl7cmV0dXJuIHRoaXMudmlld1F1YWQudW5pZm9ybXMuZGVuc2l0eS52YWx1ZX1zZXQgc2t5Um91Z2huZXNzKGUpe3RoaXMuX2dsb2JhbEZvZy5za3lSb3VnaG5lc3M9ZSx0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLnNreVJvdWdobmVzcy52YWx1ZT1lfWdldCBza3lSb3VnaG5lc3MoKXtyZXR1cm4gdGhpcy5fZ2xvYmFsRm9nLnNreVJvdWdobmVzc31zZXQgc2t5RmFjdG9yKGUpe3RoaXMuX2dsb2JhbEZvZy5za3lGYWN0b3I9ZSx0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLnNreUZhY3Rvci52YWx1ZT1lfWdldCBza3lGYWN0b3IoKXtyZXR1cm4gdGhpcy5fZ2xvYmFsRm9nLnNreUZhY3Rvcn1zZXQgb3ZlcnJpZGVTa3lGYWN0b3IoZSl7dGhpcy5fZ2xvYmFsRm9nLm92ZXJyaWRlU2t5RmFjdG9yPWUsdGhpcy52aWV3UXVhZC51bmlmb3Jtcy5vdmVycmlkZVNreUZhY3Rvci52YWx1ZT1lfWdldCBvdmVycmlkZVNreUZhY3Rvcigpe3JldHVybiB0aGlzLl9nbG9iYWxGb2cub3ZlcnJpZGVTa3lGYWN0b3J9Z2V0IGZvZ0NvbG9yKCl7cmV0dXJuIHRoaXMuX2dsb2JhbEZvZy5mb2dDb2xvcn1zZXQgZm9nQ29sb3IoZSl7dGhpcy5fZ2xvYmFsRm9nLmZvZ0NvbG9yLmNvcHlGcm9tKGUpLHRoaXMudmlld1F1YWQudW5pZm9ybXMuZm9nQ29sb3IuY29sb3I9ZSx0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLmZvZ0NvbG9yLm9uQ2hhbmdlKCl9c2V0IGZhbGxvZmYoZSl7dGhpcy5fZ2xvYmFsRm9nLmZhbGxvZmY9ZSx0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLmZhbGxvZmYudmFsdWU9ZX1nZXQgZmFsbG9mZigpe3JldHVybiB0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLmZhbGxvZmYudmFsdWV9c2V0IHJheUxlbmd0aChlKXt0aGlzLl9nbG9iYWxGb2cucmF5TGVuZ3RoPWUsdGhpcy52aWV3UXVhZC51bmlmb3Jtcy5yYXlMZW5ndGgudmFsdWU9ZX1nZXQgcmF5TGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2dsb2JhbEZvZy5yYXlMZW5ndGh9c2V0IHNjYXR0ZXJpbmdFeHBvbmVudChlKXt0aGlzLl9nbG9iYWxGb2cuc2NhdHRlcmluZ0V4cG9uZW50PWUsdGhpcy52aWV3UXVhZC51bmlmb3Jtcy5zY2F0dGVyaW5nRXhwb25lbnQudmFsdWU9ZX1nZXQgc2NhdHRlcmluZ0V4cG9uZW50KCl7cmV0dXJuIHRoaXMuX2dsb2JhbEZvZy5zY2F0dGVyaW5nRXhwb25lbnR9c2V0IGRpckhlaWdodExpbmUoZSl7dGhpcy5fZ2xvYmFsRm9nLmRpckhlaWdodExpbmU9ZSx0aGlzLnZpZXdRdWFkLnVuaWZvcm1zLmRpckhlaWdodExpbmUudmFsdWU9ZX1nZXQgZGlySGVpZ2h0TGluZSgpe3JldHVybiB0aGlzLl9nbG9iYWxGb2cuZGlySGVpZ2h0TGluZX1zZXRJbnB1dFRleHR1cmUoZSx0KXtjb25zdCByPXRoaXMudmlld1F1YWQucGFzcztyLnNldFRleHR1cmUoXCJwb3NpdGlvbk1hcFwiLGUpLHIuc2V0VGV4dHVyZShcIm5vcm1hbE1hcFwiLHQpLHRoaXMuX2xhc3RTa3lUZXh0dXJlPXRoaXMuZ2V0U2t5VGV4dHVyZSgpLHIuc2V0VGV4dHVyZShcInByZWZpbHRlck1hcFwiLHRoaXMuX2xhc3RTa3lUZXh0dXJlKX1nZXRTa3lUZXh0dXJlKCl7bGV0IGU9QS5yZXMuZGVmYXVsdFNreTtyZXR1cm4gUS5pbnN0YW5jZS5za3kgaW5zdGFuY2VvZiBzYSYmKGU9US5pbnN0YW5jZS5za3kubWFwKSxlfXJlbmRlcihlLHQpe2NvbnN0IHI9dGhpcy52aWV3UXVhZC5wYXNzO2xldCBzPXRoaXMuZ2V0U2t5VGV4dHVyZSgpO3MhPXRoaXMuX2xhc3RTa3lUZXh0dXJlJiYodGhpcy5fbGFzdFNreVRleHR1cmU9cyxyLnNldFRleHR1cmUoXCJwcmVmaWx0ZXJNYXBcIix0aGlzLl9sYXN0U2t5VGV4dHVyZSkpLHIuc2V0VGV4dHVyZShcImNvbG9yTWFwXCIsdGhpcy5nZXRPdXRUZXh0dXJlKCkpLHIuc2V0VW5pZm9ybUZsb2F0KFwiaXNTa3lIRFJcIixzLmlzSERSVGV4dHVyZT8xOjApLHRoaXMudmlld1F1YWQucmVuZGVyVGFyZ2V0KGUsdGhpcy52aWV3UXVhZCx0KX19Y2xhc3MgWHAgZXh0ZW5kcyBDdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbyh0aGlzLFwiZ29kUmF5VGV4dHVyZVwiKSxvKHRoaXMsXCJyZW5kZXJlclBhc3NTdGF0ZVwiKSxvKHRoaXMsXCJnb2RSYXlDb21wdXRlXCIpLG8odGhpcyxcImhpc3RvcnlHb2RSYXlEYXRhXCIpLG8odGhpcyxcImdvZFJheVNldHRpbmdcIiksbyh0aGlzLFwicnRGcmFtZVwiKSxvKHRoaXMsXCJSZW5kZXJcIiksbyh0aGlzLFwiYmxlbmRDb2xvclwiLCEwKSxvKHRoaXMsXCJyYXlNYXJjaENvdW50XCIsMTYpLG8odGhpcyxcInNjYXR0ZXJpbmdFeHBvbmVudFwiLDUpLG8odGhpcyxcImludGVuc2l0eVwiLC41KX1vbkF0dGFjaChlKXt0aGlzLmNyZWF0ZUdVSSgpfW9uRGV0YWNoKGUpe3RoaXMucmVtb3ZlR1VJKCl9Y3JlYXRlR1VJKCl7fXJlbW92ZUdVSSgpe31jcmVhdGVDb21wdXRlKGUpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ3Rhbyx0aGlzLmdvZFJheUNvbXB1dGU9bmV3IGJlKFp1KTtsZXQgdD1uZXcgRHQoNCozKTt0aGlzLmdvZFJheUNvbXB1dGUuc2V0VW5pZm9ybUJ1ZmZlcihcImdvZFJheVVuaWZvcm1cIix0KSx0aGlzLmhpc3RvcnlHb2RSYXlEYXRhPW5ldyBnZSg0KnRoaXMuZ29kUmF5VGV4dHVyZS53aWR0aCp0aGlzLmdvZFJheVRleHR1cmUuaGVpZ2h0KSx0aGlzLmdvZFJheUNvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcImhpc3RvcnlHb2RSYXlEYXRhXCIsdGhpcy5oaXN0b3J5R29kUmF5RGF0YSk7bGV0IHI9d3QuZ2V0R0J1ZmZlckZyYW1lKFwiQ29sb3JQYXNzR0J1ZmZlclwiKTt0aGlzLmdvZFJheUNvbXB1dGUuc2V0U2FtcGxlclRleHR1cmUoXCJwb3NUZXhcIixyLmF0dGFjaG1lbnRzWzFdKSx0aGlzLmdvZFJheUNvbXB1dGUuc2V0U2FtcGxlclRleHR1cmUoXCJub3JtYWxUZXhcIixyLmF0dGFjaG1lbnRzWzJdKSx0aGlzLmF1dG9TZXRDb2xvclRleHR1cmUoXCJpblRleFwiLHRoaXMuZ29kUmF5Q29tcHV0ZSksdGhpcy5nb2RSYXlDb21wdXRlLnNldFN0b3JhZ2VUZXh0dXJlKFwib3V0VGV4XCIsdGhpcy5nb2RSYXlUZXh0dXJlKTtsZXQgcz1BLmdldFJlbmRlckpvYihlKS5zaGFkb3dNYXBQYXNzUmVuZGVyZXI7dGhpcy5nb2RSYXlDb21wdXRlLnNldFNhbXBsZXJUZXh0dXJlKFwic2hhZG93TWFwXCIscy5kZXB0aDJEQXJyYXlUZXh0dXJlKSx0aGlzLmdvZFJheUNvbXB1dGUud29ya2VyU2l6ZVg9TWF0aC5jZWlsKHRoaXMuZ29kUmF5VGV4dHVyZS53aWR0aC84KSx0aGlzLmdvZFJheUNvbXB1dGUud29ya2VyU2l6ZVk9TWF0aC5jZWlsKHRoaXMuZ29kUmF5VGV4dHVyZS5oZWlnaHQvOCksdGhpcy5nb2RSYXlDb21wdXRlLndvcmtlclNpemVaPTEsdGhpcy5nb2RSYXlTZXR0aW5nPXR9Y3JlYXRlUmVzb3VyY2UoKXtsZXQgZT1TLnByZXNlbnRhdGlvblNpemUsdD1lWzBdLHI9ZVsxXTt0aGlzLmdvZFJheVRleHR1cmU9bmV3IG9lKHQscixHLnJnYmExNmZsb2F0LCExLEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUfEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ3xHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HKSx0aGlzLmdvZFJheVRleHR1cmUubmFtZT1cImdvZFJheVRleHR1cmVcIjtsZXQgcz1uZXcgQ2U7cy5sb2FkT3A9XCJsb2FkXCIsdGhpcy5ydEZyYW1lPW5ldyBaZShbdGhpcy5nb2RSYXlUZXh0dXJlXSxbc10pfXJlbmRlcihlLHQpe2lmKCF0aGlzLmdvZFJheUNvbXB1dGUpe3RoaXMuY3JlYXRlUmVzb3VyY2UoKSx0aGlzLmNyZWF0ZUNvbXB1dGUoZSk7bGV0IHM9cGUuZ2V0TGlnaHRFbnRyaWVzKGUuc2NlbmUpO3RoaXMuZ29kUmF5Q29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwibGlnaHRCdWZmZXJcIixzLnN0b3JhZ2VHUFVCdWZmZXIpLHRoaXMuZ29kUmF5Q29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwibW9kZWxzXCIscGUubW9kZWxNYXRyaXhCaW5kR3JvdXAubWF0cml4QnVmZmVyRHN0KSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlPUhlLmNyZWF0ZVJlbmRlcmVyUGFzc1N0YXRlKHRoaXMucnRGcmFtZSxudWxsKSx0aGlzLnJlbmRlcmVyUGFzc1N0YXRlLmxhYmVsPVwiR29kUmF5XCI7bGV0IGE9cGUuZ2V0Q2FtZXJhR3JvdXAoZS5jYW1lcmEpO3RoaXMuZ29kUmF5Q29tcHV0ZS5zZXRVbmlmb3JtQnVmZmVyKFwiZ2xvYmFsVW5pZm9ybVwiLGEudW5pZm9ybUdQVUJ1ZmZlciksYnQuYWRkRm9sZGVyKFwiR29kUmF5XCIpLGJ0LmFkZCh0aGlzLFwiYmxlbmRDb2xvclwiLDAsMSwuMSksYnQuYWRkKHRoaXMsXCJzY2F0dGVyaW5nRXhwb25lbnRcIiwxLDEwLC4xKSxidC5hZGQodGhpcyxcInJheU1hcmNoQ291bnRcIiwxMCwzMCwxKSxidC5hZGQodGhpcyxcImludGVuc2l0eVwiLC4wMSwyLC4wMSksYnQuZW5kRm9sZGVyKCl9dGhpcy5nb2RSYXlTZXR0aW5nLnNldEZsb2F0KFwiaW50ZW5zaXR5XCIsdGhpcy5pbnRlbnNpdHkpLHRoaXMuZ29kUmF5U2V0dGluZy5zZXRGbG9hdChcInJheU1hcmNoQ291bnRcIix0aGlzLnJheU1hcmNoQ291bnQpO2xldCByPWUuY2FtZXJhO3RoaXMuZ29kUmF5U2V0dGluZy5zZXRGbG9hdChcInZpZXdQb3J0V2lkdGhcIixyLnZpZXdQb3J0LndpZHRoKSx0aGlzLmdvZFJheVNldHRpbmcuc2V0RmxvYXQoXCJ2aWV3UG9ydEhlaWdodFwiLHIudmlld1BvcnQuaGVpZ2h0KSx0aGlzLmdvZFJheVNldHRpbmcuc2V0RmxvYXQoXCJibGVuZENvbG9yXCIsdGhpcy5ibGVuZENvbG9yPzE6MCksdGhpcy5nb2RSYXlTZXR0aW5nLnNldEZsb2F0KFwic2NhdHRlcmluZ0V4cG9uZW50XCIsdGhpcy5zY2F0dGVyaW5nRXhwb25lbnQpLHRoaXMuZ29kUmF5U2V0dGluZy5hcHBseSgpLHcuY29tcHV0ZUNvbW1hbmQodCxbdGhpcy5nb2RSYXlDb21wdXRlXSksdy5sYXN0UmVuZGVyUGFzc1N0YXRlPXRoaXMucmVuZGVyZXJQYXNzU3RhdGV9fWNsYXNzIFdwIGV4dGVuZHMgQ3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLG8odGhpcyxcImJyaWdodG5lc3NWaWV3XCIpLG8odGhpcyxcImNvbXBvc2l0ZVZpZXdcIiksbyh0aGlzLFwiYmx1ckxpc3RcIiksbyh0aGlzLFwiYmx1clhcIiwxKSxvKHRoaXMsXCJibHVyWVwiLDEpO2NvbnN0IGU9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5ibG9vbTtlLmVuYWJsZT0hMDtsZXQgdD1TLnByZXNlbnRhdGlvblNpemUscj10aGlzLmNyZWF0ZVJUVGV4dHVyZShcIkhEUkJsb29tUG9zdC1vdXRUZXh0dXJlc1wiLHRbMF0sdFsxXSxHLnJnYmExNmZsb2F0LCExKTtGZS5jcmVhdGVSVFRleHR1cmUoQWUuY29sb3JCdWZmZXJUZXhfTkFNRSx0WzBdLHRbMV0sRy5yZ2JhMTZmbG9hdCwhMSk7e2xldCBsPXRoaXMuY3JlYXRlUlRUZXh0dXJlKFwiYnJpZ2h0bmVzc1RleHR1cmVzXCIsdFswXSx0WzFdLEcucmdiYTE2ZmxvYXQsITEpO3RoaXMuYnJpZ2h0bmVzc1ZpZXc9dGhpcy5jcmVhdGVWaWV3UXVhZChcImJyaWdodG5lc3NWaWV3XCIsXCJCbG9vbV9CcmlnaHRuZXNzX2ZyYWdfd2dzbFwiLGwse2x1bWlub3NpdHlUaHJlc2hvbGQ6bmV3ICQoZS5sdW1pbm9zaXR5VGhyZXNob2xkKX0pfWxldCBzPTUsYT10WzBdLG49dFsxXTt0aGlzLmJsdXJMaXN0PVtdO2ZvcihsZXQgbD0wO2w8cztsKyspe2xldCBoPXRoaXMuY3JlYXRlUlRUZXh0dXJlKGB0ZXhfbCR7bH1gLGEsbixHLnJnYmExNmZsb2F0KSx1PXRoaXMuY3JlYXRlUlRUZXh0dXJlKGB0ZXhfciR7bH1gLGEsbixHLnJnYmExNmZsb2F0KSxjPXRoaXMuY3JlYXRlVmlld1F1YWQoYHFsJHtsfWAsXCJCbG9vbV9ibHVyX2ZyYWdfd2dzbFwiLGgse3RleFNpemU6bmV3ICQobmV3IFooYSoyLG4qMikpLGhTY2FsZTpuZXcgJChsKSx2U2NhbGU6bmV3ICQobCksaG9yaXpvbnRhbDpuZXcgJCguNSl9KSxmPXRoaXMuY3JlYXRlVmlld1F1YWQoYHFyJHtsfWAsXCJCbG9vbV9ibHVyX2ZyYWdfd2dzbFwiLHUse3RleFNpemU6bmV3ICQobmV3IFooYSoyLG4qMikpLGhTY2FsZTpuZXcgJChsKSx2U2NhbGU6bmV3ICQobCksaG9yaXpvbnRhbDpuZXcgJCgxKX0pO3RoaXMuYmx1ckxpc3QucHVzaCh7cWw6YyxxcjpmfSksYS89MixuLz0yfXRoaXMuY29tcG9zaXRlVmlldz10aGlzLmNyZWF0ZVZpZXdRdWFkKFwiY29tcG9zaXRlVmlld1wiLFwiQmxvb21fY29tcG9zaXRlX2ZyYWdfd2dzbFwiLHIse3RpbnRDb2xvcjpuZXcgJChuZXcgeigxLDEsMSkpLGJsb29tU3RyZW5ndGg6bmV3ICQoZS5zdHJlbmd0aCksZXhwb3N1cmU6bmV3ICQoZS5leHBvc3VyZSksYmxvb21SYWRpdXM6bmV3ICQoMSl9KSx0aGlzLmJsdXJYPWUuYmx1clgsdGhpcy5ibHVyWT1lLmJsdXJZLHRoaXMubHVtaW5vc2l0eVRocmVzaG9sZD1lLmx1bWlub3NpdHlUaHJlc2hvbGQsdGhpcy5zdHJlbmd0aD1lLnN0cmVuZ3RoLHRoaXMucmFkaXVzPWUucmFkaXVzfW9uQXR0YWNoKGUpe3RoaXMuZGVidWcoKX1vbkRldGFjaChlKXt9ZGVidWcoKXt9Z2V0IHRpbnRDb2xvcigpe3JldHVybiB0aGlzLmNvbXBvc2l0ZVZpZXcudW5pZm9ybXMudGludENvbG9yLmNvbG9yfXNldCB0aW50Q29sb3IoZSl7dGhpcy5jb21wb3NpdGVWaWV3LnVuaWZvcm1zLnRpbnRDb2xvci5jb2xvcj1lfWdldCBzdHJlbmd0aCgpe3JldHVybiB0aGlzLmNvbXBvc2l0ZVZpZXcudW5pZm9ybXMuYmxvb21TdHJlbmd0aC52YWx1ZX1zZXQgc3RyZW5ndGgoZSl7dGhpcy5jb21wb3NpdGVWaWV3LnVuaWZvcm1zLmJsb29tU3RyZW5ndGgudmFsdWU9ZX1nZXQgZXhwb3N1cmUoKXtyZXR1cm4gdGhpcy5jb21wb3NpdGVWaWV3LnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlfXNldCBleHBvc3VyZShlKXt0aGlzLmNvbXBvc2l0ZVZpZXcudW5pZm9ybXMuZXhwb3N1cmUudmFsdWU9ZX1nZXQgcmFkaXVzKCl7cmV0dXJuIHRoaXMuY29tcG9zaXRlVmlldy51bmlmb3Jtcy5ibG9vbVJhZGl1cy52YWx1ZX1zZXQgcmFkaXVzKGUpe3RoaXMuY29tcG9zaXRlVmlldy51bmlmb3Jtcy5ibG9vbVJhZGl1cy52YWx1ZT1lfWdldCBsdW1pbm9zaXR5VGhyZXNob2xkKCl7cmV0dXJuIHRoaXMuYnJpZ2h0bmVzc1ZpZXcudW5pZm9ybXMubHVtaW5vc2l0eVRocmVzaG9sZC52YWx1ZX1zZXQgbHVtaW5vc2l0eVRocmVzaG9sZChlKXt0aGlzLmJyaWdodG5lc3NWaWV3LnVuaWZvcm1zLmx1bWlub3NpdHlUaHJlc2hvbGQudmFsdWU9ZX1yZW5kZXIoZSx0KXt7bGV0IHI9dGhpcy5nZXRPdXRUZXh0dXJlKCk7dGhpcy5icmlnaHRuZXNzVmlldy5yZW5kZXJUb1ZpZXdRdWFkKGUsdGhpcy5icmlnaHRuZXNzVmlldyx0LHIpO3tsZXQgcz10aGlzLmJyaWdodG5lc3NWaWV3LnJlbmRlcmVyUGFzc1N0YXRlLnJlbmRlclRhcmdldHNbMF07Zm9yKGxldCBhPTA7YTx0aGlzLmJsdXJMaXN0Lmxlbmd0aDthKyspe2xldCBuPXRoaXMuYmx1ckxpc3RbYV0ucWwsbD10aGlzLmJsdXJMaXN0W2FdLnFyO24ucGFzcy5zZXRVbmlmb3JtRmxvYXQoXCJob3Jpem9udGFsXCIsLjUpLG4ucGFzcy5zZXRVbmlmb3JtRmxvYXQoXCJ2U2NhbGVcIixhKnRoaXMuYmx1clgpLG4ucmVuZGVyVG9WaWV3UXVhZChlLG4sdCxzKSxzPW4ucmVuZGVyZXJQYXNzU3RhdGUucmVuZGVyVGFyZ2V0c1swXSxsLnBhc3Muc2V0VW5pZm9ybUZsb2F0KFwiaG9yaXpvbnRhbFwiLDIpLGwucGFzcy5zZXRVbmlmb3JtRmxvYXQoXCJoU2NhbGVcIixhKnRoaXMuYmx1clkpLGwucmVuZGVyVG9WaWV3UXVhZChlLGwsdCxzKSxzPWwucmVuZGVyZXJQYXNzU3RhdGUucmVuZGVyVGFyZ2V0c1swXX19e2xldCBzPXRoaXMuY29tcG9zaXRlVmlldy5wYXNzO3Muc2V0VGV4dHVyZShcImJsdXJUZXgxXCIsdGhpcy5ibHVyTGlzdFswXS5xci5yZW5kZXJlclBhc3NTdGF0ZS5yZW5kZXJUYXJnZXRzWzBdKSxzLnNldFRleHR1cmUoXCJibHVyVGV4MlwiLHRoaXMuYmx1ckxpc3RbMV0ucXIucmVuZGVyZXJQYXNzU3RhdGUucmVuZGVyVGFyZ2V0c1swXSkscy5zZXRUZXh0dXJlKFwiYmx1clRleDNcIix0aGlzLmJsdXJMaXN0WzJdLnFyLnJlbmRlcmVyUGFzc1N0YXRlLnJlbmRlclRhcmdldHNbMF0pLHMuc2V0VGV4dHVyZShcImJsdXJUZXg0XCIsdGhpcy5ibHVyTGlzdFszXS5xci5yZW5kZXJlclBhc3NTdGF0ZS5yZW5kZXJUYXJnZXRzWzBdKSxzLnNldFRleHR1cmUoXCJibHVyVGV4NVwiLHRoaXMuYmx1ckxpc3RbNF0ucXIucmVuZGVyZXJQYXNzU3RhdGUucmVuZGVyVGFyZ2V0c1swXSksdGhpcy5jb21wb3NpdGVWaWV3LnJlbmRlclRvVmlld1F1YWQoZSx0aGlzLmNvbXBvc2l0ZVZpZXcsdCxyKX19fX1jbGFzcyBfZntjb25zdHJ1Y3Rvcigpe28odGhpcyxcImluZGV4TGlzdFwiKSxvKHRoaXMsXCJjb2xvclwiKSxvKHRoaXMsXCJjb3VudFwiKX19Y2xhc3MgeGZ7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJTbG90Q291bnRcIiw4KSxvKHRoaXMsXCJNYXhFbnRpdGllc1wiLDE2KSxvKHRoaXMsXCJkZWZhdWx0Q29sb3JcIixuZXcgeiguMiwxLDEsMSkpLG8odGhpcyxcInNsb3RzXCIsW10pLG8odGhpcyxcImRhdGFEaXJ0eVwiLCEwKTtsZXQgZT1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLm91dGxpbmUuZ3JvdXBDb3VudDt0aGlzLlNsb3RDb3VudD1NYXRoLm1heCgxLE1hdGgubWluKGUsdGhpcy5TbG90Q291bnQpKTtmb3IobGV0IHQ9MDt0PHRoaXMuU2xvdENvdW50O3QrKyl7bGV0IHI9dGhpcy5zbG90c1t0XT1uZXcgX2Y7ci5pbmRleExpc3Q9bmV3IEZsb2F0MzJBcnJheSh0aGlzLk1heEVudGl0aWVzKSxyLmNvbG9yPXRoaXMuZGVmYXVsdENvbG9yLmNsb25lKCksci5jb3VudD0wfX1jbGVhcigpe2ZvcihsZXQgZT0wO2U8dGhpcy5TbG90Q291bnQ7ZSsrKXRoaXMuY2xlYXJBdChlKX1jbGVhckF0KGUpe3RoaXMuZGF0YURpcnR5PSEwO2xldCB0PXRoaXMuc2xvdHNbZV07cmV0dXJuIHQuY29sb3IuY29weUZyb20odGhpcy5kZWZhdWx0Q29sb3IpLHQuaW5kZXhMaXN0LmZpbGwoLTEpLHQuY291bnQ9MCx0aGlzfWZpbGxEYXRhQXQoZSx0LHIpe3RoaXMuZGF0YURpcnR5PSEwO2xldCBzPXRoaXMuc2xvdHNbZV07aWYocyl7cy5pbmRleExpc3QuZmlsbCgtMSk7Zm9yKGxldCBhPTAsbj10Lmxlbmd0aDthPG47YSsrKXMuaW5kZXhMaXN0W2FdPXRbYV07cy5jb3VudD10Lmxlbmd0aCxzLmNvbG9yLmNvcHlGcm9tKHIpfXJldHVybiB0aGlzfWZldGNoRGF0YShlKXtyZXR1cm4gZS5kaXJ0eT10aGlzLmRhdGFEaXJ0eSxlLnNsb3RzPXRoaXMuc2xvdHMsdGhpcy5kYXRhRGlydHk9ITEsdGhpc319bGV0IGt0PW5ldyB4ZjtjbGFzcyBqcCBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJvdXRsaW5lVGV4XCIpLG8odGhpcyxcImxvd1RleFwiKSxvKHRoaXMsXCJyZW5kZXJlclBhc3NTdGF0ZVwiKSxvKHRoaXMsXCJjYWxjV2VpZ2h0Q29tcHV0ZVwiKSxvKHRoaXMsXCJvdXRsaW5lQ29tcHV0ZVwiKSxvKHRoaXMsXCJibGVuZENvbXB1dGVcIiksbyh0aGlzLFwib3V0bGluZVNldHRpbmdcIiksbyh0aGlzLFwic2xvdHNCdWZmZXJcIiksbyh0aGlzLFwic2xvdHNBcnJheVwiKSxvKHRoaXMsXCJlbnRpdGllc0FycmF5XCIpLG8odGhpcyxcImVudGl0aWVzQnVmZmVyXCIpLG8odGhpcyxcIndlaWdodEJ1ZmZlclwiKSxvKHRoaXMsXCJsb3dUZXhTaXplXCIpLG8odGhpcyxcIm9sZE91dGxpbmVDb2xvclwiKSxvKHRoaXMsXCJydEZyYW1lXCIpLG8odGhpcyxcImZldGNoRGF0YVwiKSxvKHRoaXMsXCJjb21wdXRlTGlzdFwiKX1vbkF0dGFjaChlKXtBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLm91dGxpbmUuZW5hYmxlPSEwfW9uRGV0YWNoKGUpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3Npbmcub3V0bGluZS5lbmFibGU9ITF9c2V0IG91dGxpbmVQaXhlbChlKXtlPUsoZSwwLDgpO2xldCB0PUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3Npbmcub3V0bGluZTt0Lm91dGxpbmVQaXhlbCE9ZSYmKHQub3V0bGluZVBpeGVsPWUpfWdldCBvdXRsaW5lUGl4ZWwoKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5vdXRsaW5lLm91dGxpbmVQaXhlbH1zZXQgZmFkZU91dGxpbmVQaXhlbChlKXtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLm91dGxpbmU7ZT1LKGUsMCw4KSx0LmZhZGVPdXRsaW5lUGl4ZWwhPWUmJih0LmZhZGVPdXRsaW5lUGl4ZWw9ZSl9Z2V0IGZhZGVPdXRsaW5lUGl4ZWwoKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5vdXRsaW5lLmZhZGVPdXRsaW5lUGl4ZWx9c2V0IHN0cmVuZ3RoKGUpe2U9SyhlLDAsMSk7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5vdXRsaW5lO3Quc3RyZW5ndGghPWUmJih0LnN0cmVuZ3RoPWUpfWdldCBzdHJlbmd0aCgpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLm91dGxpbmUuc3RyZW5ndGh9c2V0IHVzZUFkZE1vZGUoZSl7QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5vdXRsaW5lLnVzZUFkZE1vZGU9ZX1nZXQgdXNlQWRkTW9kZSgpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLm91dGxpbmUudXNlQWRkTW9kZX1jcmVhdGVHVUkoKXt9Y3JlYXRlQ29tcHV0ZSgpe2xldCB0PXd0LmdldEdCdWZmZXJGcmFtZShcIkNvbG9yUGFzc0dCdWZmZXJcIikuZ2V0UG9zaXRpb25NYXAoKTt0aGlzLmNhbGNXZWlnaHRDb21wdXRlPW5ldyBiZSh0YyksdGhpcy5jYWxjV2VpZ2h0Q29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwib3V0bGluZVNldHRpbmdcIix0aGlzLm91dGxpbmVTZXR0aW5nKSx0aGlzLmNhbGNXZWlnaHRDb21wdXRlLnNldFN0b3JhZ2VCdWZmZXIoXCJzbG90c0J1ZmZlclwiLHRoaXMuc2xvdHNCdWZmZXIpLHRoaXMuY2FsY1dlaWdodENvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcIndlaWdodEJ1ZmZlclwiLHRoaXMud2VpZ2h0QnVmZmVyKSx0aGlzLmNhbGNXZWlnaHRDb21wdXRlLnNldFN0b3JhZ2VCdWZmZXIoXCJlbnRpdGllc0J1ZmZlclwiLHRoaXMuZW50aXRpZXNCdWZmZXIpLHRoaXMuY2FsY1dlaWdodENvbXB1dGUuc2V0U2FtcGxlclRleHR1cmUoXCJpbmRleFRleHR1cmVcIix0KSx0aGlzLmNhbGNXZWlnaHRDb21wdXRlLndvcmtlclNpemVYPU1hdGguY2VpbCh0aGlzLmxvd1RleC53aWR0aC84KSx0aGlzLmNhbGNXZWlnaHRDb21wdXRlLndvcmtlclNpemVZPU1hdGguY2VpbCh0aGlzLmxvd1RleC5oZWlnaHQvOCksdGhpcy5jYWxjV2VpZ2h0Q29tcHV0ZS53b3JrZXJTaXplWj0xLHRoaXMub3V0bGluZUNvbXB1dGU9bmV3IGJlKGljKSx0aGlzLm91dGxpbmVDb21wdXRlLnNldFN0b3JhZ2VCdWZmZXIoXCJvdXRsaW5lU2V0dGluZ1wiLHRoaXMub3V0bGluZVNldHRpbmcpLHRoaXMub3V0bGluZUNvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcInNsb3RzQnVmZmVyXCIsdGhpcy5zbG90c0J1ZmZlciksdGhpcy5vdXRsaW5lQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwid2VpZ2h0QnVmZmVyXCIsdGhpcy53ZWlnaHRCdWZmZXIpLHRoaXMub3V0bGluZUNvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcIm9sZE91dGxpbmVDb2xvclwiLHRoaXMub2xkT3V0bGluZUNvbG9yKSx0aGlzLm91dGxpbmVDb21wdXRlLnNldFN0b3JhZ2VUZXh0dXJlKFwibG93VGV4XCIsdGhpcy5sb3dUZXgpLHRoaXMub3V0bGluZUNvbXB1dGUud29ya2VyU2l6ZVg9TWF0aC5jZWlsKHRoaXMubG93VGV4LndpZHRoLzgpLHRoaXMub3V0bGluZUNvbXB1dGUud29ya2VyU2l6ZVk9TWF0aC5jZWlsKHRoaXMubG93VGV4LmhlaWdodC84KSx0aGlzLm91dGxpbmVDb21wdXRlLndvcmtlclNpemVaPTEsdGhpcy5ibGVuZENvbXB1dGU9bmV3IGJlKGVjKSx0aGlzLmJsZW5kQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwib3V0bGluZVNldHRpbmdcIix0aGlzLm91dGxpbmVTZXR0aW5nKSx0aGlzLmF1dG9TZXRDb2xvclRleHR1cmUoXCJpblRleFwiLHRoaXMuYmxlbmRDb21wdXRlKSx0aGlzLmJsZW5kQ29tcHV0ZS5zZXRTYW1wbGVyVGV4dHVyZShcImxvd1RleFwiLHRoaXMubG93VGV4KSx0aGlzLmJsZW5kQ29tcHV0ZS5zZXRTdG9yYWdlVGV4dHVyZShcIm91dGxpbmVUZXhcIix0aGlzLm91dGxpbmVUZXgpLHRoaXMuYmxlbmRDb21wdXRlLndvcmtlclNpemVYPU1hdGguY2VpbCh0aGlzLm91dGxpbmVUZXgud2lkdGgvOCksdGhpcy5ibGVuZENvbXB1dGUud29ya2VyU2l6ZVk9TWF0aC5jZWlsKHRoaXMub3V0bGluZVRleC5oZWlnaHQvOCksdGhpcy5ibGVuZENvbXB1dGUud29ya2VyU2l6ZVo9MX1jcmVhdGVSZXNvdXJjZSgpe2xldCBlPVMucHJlc2VudGF0aW9uU2l6ZSx0PWVbMF0scj1lWzFdLHM9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5vdXRsaW5lLnRleHR1cmVTY2FsZTt0aGlzLmxvd1RleFNpemU9bmV3IFooTWF0aC5jZWlsKHQqcyksTWF0aC5jZWlsKHIqcykpLHRoaXMubG93VGV4PW5ldyBvZSh0aGlzLmxvd1RleFNpemUueCx0aGlzLmxvd1RleFNpemUueSxHLnJnYmExNmZsb2F0LCExLEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUfEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ3xHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HKSx0aGlzLmxvd1RleC5uYW1lPVwibG93VGV4XCI7bGV0IGE9bmV3IENlO2EuY2xlYXJWYWx1ZT1bMCwwLDAsMV0sYS5sb2FkT3A9XCJjbGVhclwiLHRoaXMub3V0bGluZVRleD1uZXcgb2UodCxyLEcucmdiYTE2ZmxvYXQsITEsR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDfEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcpLHRoaXMub3V0bGluZVRleC5uYW1lPVwib3V0bGluZVRleFwiO2xldCBuPW5ldyBDZTtuLmNsZWFyVmFsdWU9WzAsMCwwLDFdLG4ubG9hZE9wPVwiY2xlYXJcIix0aGlzLnJ0RnJhbWU9bmV3IFplKFt0aGlzLm91dGxpbmVUZXhdLFtuXSksdGhpcy5vdXRsaW5lU2V0dGluZz1uZXcgRHQoOCksdGhpcy53ZWlnaHRCdWZmZXI9bmV3IGdlKHRoaXMubG93VGV4U2l6ZS54KnRoaXMubG93VGV4U2l6ZS55KjQsR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMpLHRoaXMub2xkT3V0bGluZUNvbG9yPW5ldyBnZSh0aGlzLmxvd1RleFNpemUueCp0aGlzLmxvd1RleFNpemUueSo0LEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDKSx0aGlzLnNsb3RzQXJyYXk9bmV3IEZsb2F0MzJBcnJheShrdC5TbG90Q291bnQqNCksdGhpcy5zbG90c0J1ZmZlcj1uZXcgZ2UodGhpcy5zbG90c0FycmF5Lmxlbmd0aCksdGhpcy5zbG90c0J1ZmZlci5zZXRGbG9hdDMyQXJyYXkoXCJzbG90c0FycmF5XCIsdGhpcy5zbG90c0FycmF5KSx0aGlzLnNsb3RzQnVmZmVyLmFwcGx5KCksdGhpcy5lbnRpdGllc0FycmF5PW5ldyBGbG9hdDMyQXJyYXkoa3QuU2xvdENvdW50Kmt0Lk1heEVudGl0aWVzKSx0aGlzLmVudGl0aWVzQnVmZmVyPW5ldyBnZSh0aGlzLmVudGl0aWVzQXJyYXkubGVuZ3RoKSx0aGlzLmVudGl0aWVzQnVmZmVyLnNldEZsb2F0MzJBcnJheShcImVudGl0aWVzQXJyYXlcIix0aGlzLmVudGl0aWVzQXJyYXkpLHRoaXMuc2xvdHNCdWZmZXIuYXBwbHkoKSx0aGlzLmZldGNoRGF0YXx8KHRoaXMuZmV0Y2hEYXRhPXt9KX1mZXRjaE91dGxpbmVEYXRhKCl7aWYoa3QuZmV0Y2hEYXRhKHRoaXMuZmV0Y2hEYXRhKSx0aGlzLmZldGNoRGF0YS5kaXJ0eSl7bGV0IGU9a3QuU2xvdENvdW50LHQ9a3QuTWF4RW50aXRpZXM7Zm9yKGxldCByPTA7cjxlO3IrKyl7bGV0IHM9NCpyLGE9dGhpcy5mZXRjaERhdGEuc2xvdHNbcl07dGhpcy5zbG90c0FycmF5W3MrMF09YS5jb2xvci5yLHRoaXMuc2xvdHNBcnJheVtzKzFdPWEuY29sb3IuZyx0aGlzLnNsb3RzQXJyYXlbcysyXT1hLmNvbG9yLmIsdGhpcy5zbG90c0FycmF5W3MrM109YS5jb3VudCxzPXQqcix0aGlzLmVudGl0aWVzQXJyYXkuc2V0KGEuaW5kZXhMaXN0LHMpfXRoaXMuc2xvdHNCdWZmZXIuc2V0RmxvYXQzMkFycmF5KFwic2xvdHNBcnJheVwiLHRoaXMuc2xvdHNBcnJheSksdGhpcy5zbG90c0J1ZmZlci5hcHBseSgpLHRoaXMuZW50aXRpZXNCdWZmZXIuc2V0RmxvYXQzMkFycmF5KFwiZW50aXRpZXNBcnJheVwiLHRoaXMuZW50aXRpZXNBcnJheSksdGhpcy5lbnRpdGllc0J1ZmZlci5hcHBseSgpfX1yZW5kZXIoZSx0KXt0aGlzLmNhbGNXZWlnaHRDb21wdXRlfHwodGhpcy5jcmVhdGVSZXNvdXJjZSgpLHRoaXMuY3JlYXRlQ29tcHV0ZSgpLHRoaXMuY3JlYXRlR1VJKCksdGhpcy5yZW5kZXJlclBhc3NTdGF0ZT1IZS5jcmVhdGVSZW5kZXJlclBhc3NTdGF0ZSh0aGlzLnJ0RnJhbWUsbnVsbCkpLHRoaXMuY29tcHV0ZUxpc3R8fCh0aGlzLmNvbXB1dGVMaXN0PVt0aGlzLmNhbGNXZWlnaHRDb21wdXRlLHRoaXMub3V0bGluZUNvbXB1dGUsdGhpcy5ibGVuZENvbXB1dGVdKTtsZXQgcj1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLm91dGxpbmU7dGhpcy5vdXRsaW5lU2V0dGluZy5zZXRGbG9hdChcInN0cmVuZ3RoXCIsci5zdHJlbmd0aCksdGhpcy5vdXRsaW5lU2V0dGluZy5zZXRGbG9hdChcInVzZUFkZE1vZGVcIixyLnVzZUFkZE1vZGU/MTowKSx0aGlzLm91dGxpbmVTZXR0aW5nLnNldEZsb2F0KFwib3V0bGluZVBpeGVsXCIsci5vdXRsaW5lUGl4ZWwpLHRoaXMub3V0bGluZVNldHRpbmcuc2V0RmxvYXQoXCJmYWRlT3V0bGluZVBpeGVsXCIsci5mYWRlT3V0bGluZVBpeGVsKSx0aGlzLm91dGxpbmVTZXR0aW5nLnNldEZsb2F0KFwibG93VGV4V2lkdGhcIix0aGlzLmxvd1RleFNpemUueCksdGhpcy5vdXRsaW5lU2V0dGluZy5zZXRGbG9hdChcImxvd1RleEhlaWdodFwiLHRoaXMubG93VGV4U2l6ZS55KSx0aGlzLm91dGxpbmVTZXR0aW5nLmFwcGx5KCksdGhpcy5mZXRjaE91dGxpbmVEYXRhKCksdy5jb21wdXRlQ29tbWFuZCh0LHRoaXMuY29tcHV0ZUxpc3QpLHcubGFzdFJlbmRlclBhc3NTdGF0ZT10aGlzLnJlbmRlcmVyUGFzc1N0YXRlfX1jbGFzcyBxcCBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJTU1JfUmF5VHJhY2VDb21wdXRlXCIpLG8odGhpcyxcIlNTUl9JU19Db21wdXRlXCIpLG8odGhpcyxcIlNTUl9CbGVuZF9Db21wdXRlXCIpLG8odGhpcyxcImlzUmV0VGV4dHVyZVwiKSxvKHRoaXMsXCJmaW5hbFRleHR1cmVcIiksbyh0aGlzLFwicmVuZGVyZXJQYXNzU3RhdGVcIiksbyh0aGlzLFwic3NyVW5pZm9ybUJ1ZmZlclwiKSxvKHRoaXMsXCJyYXlUcmFjZURhdGFcIiksbyh0aGlzLFwic3NyQ29sb3JEYXRhXCIpLG8odGhpcyxcImlzS2VybmVsRmxvYXQzMkFycmF5XCIpLG8odGhpcyxcInJ0RnJhbWVcIiksbyh0aGlzLFwiaGlzdG9yeVBvc2l0aW9uXCIpLG8odGhpcyxcInJlZmxlY3Rpb25SYXRpb1wiLC41KX1vbkF0dGFjaChlKXtBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnNzci5lbmFibGU9ITAsdGhpcy5kZWJ1ZygpfW9uRGV0YWNoKGUpe0Euc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3Npbmcuc3NyLmVuYWJsZT0hMX1nZXQgZmFkZUVkZ2VSYXRpbygpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnNzci5mYWRlRWRnZVJhdGlvfXNldCBmYWRlRWRnZVJhdGlvKGUpe2U9SyhlLDAsMSk7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5zc3I7dC5mYWRlRWRnZVJhdGlvPWV9Z2V0IHJheU1hcmNoUmF0aW8oKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5zc3IucmF5TWFyY2hSYXRpb31zZXQgcmF5TWFyY2hSYXRpbyhlKXtlPUsoZSwwLDEpO2xldCB0PUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3Npbmcuc3NyO3QucmF5TWFyY2hSYXRpbz1lfWdldCByb3VnaG5lc3NUaHJlc2hvbGQoKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5zc3Iucm91Z2huZXNzVGhyZXNob2xkfXNldCByb3VnaG5lc3NUaHJlc2hvbGQoZSl7ZT1LKGUsMCwxKTtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnNzcjt0LnJvdWdobmVzc1RocmVzaG9sZD1lfWdldCBmYWRlRGlzdGFuY2VNaW4oKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5zc3IuZmFkZURpc3RhbmNlTWlufXNldCBmYWRlRGlzdGFuY2VNaW4oZSl7ZT1LKGUsMCwxZTQpO2xldCB0PUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3Npbmcuc3NyO3QuZmFkZURpc3RhbmNlTWluPWV9Z2V0IGZhZGVEaXN0YW5jZU1heCgpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnNzci5mYWRlRGlzdGFuY2VNYXh9c2V0IGZhZGVEaXN0YW5jZU1heChlKXtlPUsoZSwwLDFlNCk7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5zc3I7dC5mYWRlRGlzdGFuY2VNYXg9ZX1nZXQgcG93RG90Uk4oKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5zc3IucG93RG90Uk59c2V0IHBvd0RvdFJOKGUpe2U9SyhlLDAsMSk7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy5zc3I7dC5wb3dEb3RSTj1lfWRlYnVnKCl7fWNyZWF0ZVJheVRyYWNlU2hhZGVyKCl7dGhpcy5TU1JfUmF5VHJhY2VDb21wdXRlPW5ldyBiZShvYyksdGhpcy5TU1JfUmF5VHJhY2VDb21wdXRlLnNldFN0b3JhZ2VCdWZmZXIoXCJzc3JVbmlmb3JtXCIsdGhpcy5zc3JVbmlmb3JtQnVmZmVyKSx0aGlzLlNTUl9SYXlUcmFjZUNvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcInJheVRyYWNlQnVmZmVyXCIsdGhpcy5yYXlUcmFjZURhdGEpLHRoaXMuU1NSX1JheVRyYWNlQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwiaGlzdG9yeVBvc2l0aW9uXCIsdGhpcy5oaXN0b3J5UG9zaXRpb24pO2xldCBlPXd0LmdldEdCdWZmZXJGcmFtZShcIkNvbG9yUGFzc0dCdWZmZXJcIik7dGhpcy5TU1JfUmF5VHJhY2VDb21wdXRlLnNldFNhbXBsZXJUZXh0dXJlKFwiekJ1ZmZlclRleHR1cmVcIixlLmdldFBvc2l0aW9uTWFwKCkpLHRoaXMuU1NSX1JheVRyYWNlQ29tcHV0ZS5zZXRTYW1wbGVyVGV4dHVyZShBZS5ub3JtYWxCdWZmZXJUZXhfTkFNRSxlLmF0dGFjaG1lbnRzWzJdKSx0aGlzLlNTUl9SYXlUcmFjZUNvbXB1dGUuc2V0U2FtcGxlclRleHR1cmUoQWUubWF0ZXJpYWxCdWZmZXJUZXhfTkFNRSxlLmF0dGFjaG1lbnRzWzNdKSxRLmluc3RhbmNlLnNreSBpbnN0YW5jZW9mIHNhJiZ0aGlzLlNTUl9SYXlUcmFjZUNvbXB1dGUuc2V0U2FtcGxlclRleHR1cmUoXCJwcmVmaWx0ZXJNYXBcIixRLmluc3RhbmNlLnNreS5tYXApLHRoaXMuU1NSX1JheVRyYWNlQ29tcHV0ZS53b3JrZXJTaXplWD1NYXRoLmNlaWwodGhpcy5pc1JldFRleHR1cmUud2lkdGgvOCksdGhpcy5TU1JfUmF5VHJhY2VDb21wdXRlLndvcmtlclNpemVZPU1hdGguY2VpbCh0aGlzLmlzUmV0VGV4dHVyZS5oZWlnaHQvOCksdGhpcy5TU1JfUmF5VHJhY2VDb21wdXRlLndvcmtlclNpemVaPTF9Y3JlYXRlSVNTaGFkZXIoKXt0aGlzLlNTUl9JU19Db21wdXRlPW5ldyBiZShhYyksdGhpcy5TU1JfSVNfQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwic3NyVW5pZm9ybVwiLHRoaXMuc3NyVW5pZm9ybUJ1ZmZlciksdGhpcy5TU1JfSVNfQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwicmF5VHJhY2VCdWZmZXJcIix0aGlzLnJheVRyYWNlRGF0YSksdGhpcy5TU1JfSVNfQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwic3NyQ29sb3JEYXRhXCIsdGhpcy5zc3JDb2xvckRhdGEpLHRoaXMuU1NSX0lTX0NvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcImhpc3RvcnlQb3NpdGlvblwiLHRoaXMuaGlzdG9yeVBvc2l0aW9uKSx0aGlzLmF1dG9TZXRDb2xvclRleHR1cmUoXCJjb2xvck1hcFwiLHRoaXMuU1NSX0lTX0NvbXB1dGUpLHRoaXMuU1NSX0lTX0NvbXB1dGUuc2V0U3RvcmFnZVRleHR1cmUoXCJvdXRUZXhcIix0aGlzLmlzUmV0VGV4dHVyZSksdGhpcy5TU1JfSVNfQ29tcHV0ZS53b3JrZXJTaXplWD1NYXRoLmNlaWwodGhpcy5pc1JldFRleHR1cmUud2lkdGgvOCksdGhpcy5TU1JfSVNfQ29tcHV0ZS53b3JrZXJTaXplWT1NYXRoLmNlaWwodGhpcy5pc1JldFRleHR1cmUuaGVpZ2h0LzgpLHRoaXMuU1NSX0lTX0NvbXB1dGUud29ya2VyU2l6ZVo9MX1jcmVhdGVCbGVuZFNoYWRlcihlKXt0aGlzLlNTUl9CbGVuZF9Db21wdXRlPW5ldyBiZShzYyksdGhpcy5TU1JfQmxlbmRfQ29tcHV0ZS5zZXRTdG9yYWdlQnVmZmVyKFwicmF5VHJhY2VCdWZmZXJcIix0aGlzLnJheVRyYWNlRGF0YSksdGhpcy5hdXRvU2V0Q29sb3JUZXh0dXJlKFwiY29sb3JNYXBcIix0aGlzLlNTUl9CbGVuZF9Db21wdXRlKSx0aGlzLlNTUl9CbGVuZF9Db21wdXRlLnNldFNhbXBsZXJUZXh0dXJlKFwic3NyTWFwXCIsZSksdGhpcy5TU1JfQmxlbmRfQ29tcHV0ZS5zZXRTdG9yYWdlVGV4dHVyZShcIm91dFRleFwiLHRoaXMuZmluYWxUZXh0dXJlKSx0aGlzLlNTUl9CbGVuZF9Db21wdXRlLndvcmtlclNpemVYPU1hdGguY2VpbCh0aGlzLmZpbmFsVGV4dHVyZS53aWR0aC84KSx0aGlzLlNTUl9CbGVuZF9Db21wdXRlLndvcmtlclNpemVZPU1hdGguY2VpbCh0aGlzLmZpbmFsVGV4dHVyZS5oZWlnaHQvOCksdGhpcy5TU1JfQmxlbmRfQ29tcHV0ZS53b3JrZXJTaXplWj0xfWNyZWF0ZVJlc291cmNlKCl7bGV0IGU9Uy5wcmVzZW50YXRpb25TaXplLHQ9ZVswXSxyPWVbMV07dGhpcy5maW5hbFRleHR1cmU9bmV3IG9lKHQscixHLnJnYmExNmZsb2F0LCExLEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkd8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyksdGhpcy5maW5hbFRleHR1cmUubmFtZT1cInNzck91dFRleFwiO2xldCBzPW5ldyBDZTtzLmNsZWFyVmFsdWU9WzAsMCwwLDBdLHMubG9hZE9wPVwiY2xlYXJcIjtsZXQgYT1NYXRoLmNlaWwodCpBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnNzci5waXhlbFJhdGlvKSxuPU1hdGguY2VpbChyKkEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3Npbmcuc3NyLnBpeGVsUmF0aW8pO3RoaXMuaXNSZXRUZXh0dXJlPW5ldyBvZShhLG4sRy5yZ2JhMTZmbG9hdCwhMSxHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HfEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcpLHRoaXMuaXNSZXRUZXh0dXJlLm5hbWU9XCJzc3JUZXh0dXJlSW5cIjtsZXQgbD1uZXcgQ2U7bC5jbGVhclZhbHVlPVswLDAsMCwwXSxsLmxvYWRPcD1cImNsZWFyXCIsdGhpcy5ydEZyYW1lPW5ldyBaZShbdGhpcy5maW5hbFRleHR1cmUsdGhpcy5pc1JldFRleHR1cmVdLFtzLGxdKSx0aGlzLnJheVRyYWNlRGF0YT1uZXcgZ2UoYSpuKjgsR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMpLHRoaXMuc3NyQ29sb3JEYXRhPW5ldyBnZShhKm4qNCxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyksdGhpcy5oaXN0b3J5UG9zaXRpb249bmV3IGdlKGEqbio0LEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDKSx0aGlzLnNzclVuaWZvcm1CdWZmZXI9bmV3IER0KDQqOCksdGhpcy5zc3JVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwic3NyQnVmZmVyU2l6ZVhcIix0aGlzLmlzUmV0VGV4dHVyZS53aWR0aCksdGhpcy5zc3JVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwic3NyQnVmZmVyU2l6ZVlcIix0aGlzLmlzUmV0VGV4dHVyZS5oZWlnaHQpLHRoaXMuc3NyVW5pZm9ybUJ1ZmZlci5zZXRGbG9hdChcImNvbG9yTWFwU2l6ZVhcIix0aGlzLmZpbmFsVGV4dHVyZS53aWR0aCksdGhpcy5zc3JVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwiY29sb3JNYXBTaXplWVwiLHRoaXMuZmluYWxUZXh0dXJlLmhlaWdodCksdGhpcy5zc3JVbmlmb3JtQnVmZmVyLmFwcGx5KCl9cmVuZGVyKGUsdCl7aWYoIXRoaXMuU1NSX1JheVRyYWNlQ29tcHV0ZSl7dGhpcy5jcmVhdGVSZXNvdXJjZSgpLHRoaXMuY3JlYXRlSVNTaGFkZXIoKSx0aGlzLmNyZWF0ZVJheVRyYWNlU2hhZGVyKCksdGhpcy5jcmVhdGVCbGVuZFNoYWRlcih0aGlzLmlzUmV0VGV4dHVyZSksdGhpcy5maW5hbFRleHR1cmUsdGhpcy5yZW5kZXJlclBhc3NTdGF0ZT1IZS5jcmVhdGVSZW5kZXJlclBhc3NTdGF0ZSh0aGlzLnJ0RnJhbWUsbnVsbCk7bGV0IGE9cGUuZ2V0Q2FtZXJhR3JvdXAoZS5jYW1lcmEpO3RoaXMuU1NSX1JheVRyYWNlQ29tcHV0ZS5zZXRVbmlmb3JtQnVmZmVyKFwic3RhbmRVbmlmb3JtXCIsYS51bmlmb3JtR1BVQnVmZmVyKX1sZXQgcj1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnNzcjt0aGlzLnNzclVuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJmYWRlRWRnZVJhdGlvXCIsci5mYWRlRWRnZVJhdGlvKSx0aGlzLnNzclVuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJyYXlNYXJjaFJhdGlvXCIsci5yYXlNYXJjaFJhdGlvKSx0aGlzLnNzclVuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJmYWRlRGlzdGFuY2VNaW5cIixyLmZhZGVEaXN0YW5jZU1pbiksdGhpcy5zc3JVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwiZmFkZURpc3RhbmNlTWF4XCIsci5mYWRlRGlzdGFuY2VNYXgpLHRoaXMuc3NyVW5pZm9ybUJ1ZmZlci5zZXRGbG9hdChcIm1peFRocmVzaG9sZFwiLHIubWl4VGhyZXNob2xkKSx0aGlzLnNzclVuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJyb3VnaG5lc3NUaHJlc2hvbGRcIixyLnJvdWdobmVzc1RocmVzaG9sZCksdGhpcy5zc3JVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwicmVmbGVjdGlvblJhdGlvXCIsdGhpcy5yZWZsZWN0aW9uUmF0aW8pLHRoaXMuc3NyVW5pZm9ybUJ1ZmZlci5zZXRGbG9hdChcInBvd0RvdFJOXCIsci5wb3dEb3RSTiksdGhpcy5zc3JVbmlmb3JtQnVmZmVyLnNldEZsb2F0KFwicmFuZG9tU2VlZFhcIixNYXRoLnJhbmRvbSgpKSx0aGlzLnNzclVuaWZvcm1CdWZmZXIuc2V0RmxvYXQoXCJyYW5kb21TZWVkWVwiLE1hdGgucmFuZG9tKCkpLHRoaXMuc3NyVW5pZm9ybUJ1ZmZlci5hcHBseSgpO2xldCBzPVt0aGlzLlNTUl9SYXlUcmFjZUNvbXB1dGUsdGhpcy5TU1JfSVNfQ29tcHV0ZSx0aGlzLlNTUl9CbGVuZF9Db21wdXRlXTt3LmNvbXB1dGVDb21tYW5kKHQscyksdy5sYXN0UmVuZGVyUGFzc1N0YXRlPXRoaXMucmVuZGVyZXJQYXNzU3RhdGV9fWNsYXNzIEtwe3N0YXRpYyBjcmVhdGVTZWVkcygpe2xldCBlPTIwLHQ9MzIscj1bbmV3IGcoMCwwLGUpXSxzPTAsYT0uMDI7Zm9yKGxldCBuPTE7bjx0O24rKyl7bGV0IGw9bmV3IGc7ci5wdXNoKGwpLHMrPTEtKDEtLjYxOCkqbi90LGErPW4qLjAxLGwueD1NYXRoLnNpbihzKSphLGwueT1NYXRoLmNvcyhzKSphLGwuej0xLW4vdCxsLm11bHRpcGx5U2NhbGFyKGUpfXJldHVybiByfX1jbGFzcyBKcCBleHRlbmRzIEN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxvKHRoaXMsXCJ0YWFUZXh0dXJlXCIpLG8odGhpcyxcIm91dFRleHR1cmVcIiksbyh0aGlzLFwicmVuZGVyZXJQYXNzU3RhdGVcIiksbyh0aGlzLFwidGFhQ29tcHV0ZVwiKSxvKHRoaXMsXCJjb3B5VGV4Q29tcHV0ZVwiKSxvKHRoaXMsXCJzaGFycENvbXB1dGVcIiksbyh0aGlzLFwidGFhU2V0dGluZ1wiKSxvKHRoaXMsXCJwcmVDb2xvckJ1ZmZlclwiKSxvKHRoaXMsXCJwcmVDb2xvclRleFwiKSxvKHRoaXMsXCJwcmVQcm9qTWF0cml4XCIpLG8odGhpcyxcInByZVZpZXdNYXRyaXhcIiksbyh0aGlzLFwicnRGcmFtZVwiKX1vbkF0dGFjaChlKXtBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYS5lbmFibGU9ITAsZS5jYW1lcmEuZW5hYmxlSml0dGVyUHJvamVjdGlvbighMCksdGhpcy5jcmVhdGVHVUkoKX1vbkRldGFjaChlKXtBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYS5lbmFibGU9ITEsZS5jYW1lcmEuZW5hYmxlSml0dGVyUHJvamVjdGlvbighMSl9Z2V0IGppdHRlclNlZWRDb3VudCgpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYS5qaXR0ZXJTZWVkQ291bnR9c2V0IGppdHRlclNlZWRDb3VudChlKXtlPUsoZSwyLDgpLGU9TWF0aC5yb3VuZChlKTtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYTt0LmppdHRlclNlZWRDb3VudD1lfWdldCBibGVuZEZhY3Rvcigpe3JldHVybiBBLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYS5ibGVuZEZhY3Rvcn1zZXQgYmxlbmRGYWN0b3IoZSl7ZT1LKGUsMCwxKTtsZXQgdD1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYTt0LmJsZW5kRmFjdG9yPWV9Z2V0IHNoYXJwRmFjdG9yKCl7cmV0dXJuIEEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcudGFhLnNoYXJwRmFjdG9yfXNldCBzaGFycEZhY3RvcihlKXtlPUsoZSwuMSwuOSk7bGV0IHQ9QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy50YWE7dC5zaGFycEZhY3Rvcj1lfWdldCBzaGFycFByZUJsdXJGYWN0b3IoKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy50YWEuc2hhcnBQcmVCbHVyRmFjdG9yfXNldCBzaGFycFByZUJsdXJGYWN0b3IoZSl7ZT1LKGUsLjEsLjkpO2xldCB0PUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcudGFhO3Quc2hhcnBQcmVCbHVyRmFjdG9yPWV9Z2V0IHRlbXBvcmFsSml0dGVyU2NhbGUoKXtyZXR1cm4gQS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy50YWEudGVtcG9yYWxKaXR0ZXJTY2FsZX1zZXQgdGVtcG9yYWxKaXR0ZXJTY2FsZShlKXtlPUsoZSwwLDEpO2xldCB0PUEuc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcudGFhO3QudGVtcG9yYWxKaXR0ZXJTY2FsZT1lfWNyZWF0ZUdVSSgpe31jcmVhdGVDb21wdXRlKGUpe2xldCB0PW5ldyBiZShoYyk7QS5zZXR0aW5nLnJlbmRlci5wb3N0UHJvY2Vzc2luZy50YWE7bGV0IHI9bmV3IER0KDE2KjIrNCozKSxzPXBlLmdldENhbWVyYUdyb3VwKGUuY2FtZXJhKTt0LnNldFVuaWZvcm1CdWZmZXIoXCJzdGFuZFVuaWZvcm1cIixzLnVuaWZvcm1HUFVCdWZmZXIpLHQuc2V0VW5pZm9ybUJ1ZmZlcihcInRhYURhdGFcIixyKSx0LnNldFN0b3JhZ2VCdWZmZXIoXCJwcmVDb2xvckJ1ZmZlclwiLHRoaXMucHJlQ29sb3JCdWZmZXIpO2xldCBhPXd0LmdldEdCdWZmZXJGcmFtZShcIkNvbG9yUGFzc0dCdWZmZXJcIik7dC5zZXRTYW1wbGVyVGV4dHVyZShcInByZUNvbG9yVGV4XCIsdGhpcy5wcmVDb2xvclRleCksdC5zZXRTYW1wbGVyVGV4dHVyZShcInBvc1RleFwiLGEuZ2V0UG9zaXRpb25NYXAoKSksdGhpcy5hdXRvU2V0Q29sb3JUZXh0dXJlKFwiaW5UZXhcIix0KSx0LnNldFN0b3JhZ2VUZXh0dXJlKFwib3V0VGV4XCIsdGhpcy50YWFUZXh0dXJlKSx0LndvcmtlclNpemVYPU1hdGguY2VpbCh0aGlzLnRhYVRleHR1cmUud2lkdGgvOCksdC53b3JrZXJTaXplWT1NYXRoLmNlaWwodGhpcy50YWFUZXh0dXJlLmhlaWdodC84KSx0LndvcmtlclNpemVaPTEsdGhpcy50YWFDb21wdXRlPXQsdGhpcy50YWFTZXR0aW5nPXIsdGhpcy5jb3B5VGV4Q29tcHV0ZT1uZXcgYmUobmMpLHRoaXMuY29weVRleENvbXB1dGUuc2V0U3RvcmFnZUJ1ZmZlcihcInByZUNvbG9yXCIsdGhpcy5wcmVDb2xvckJ1ZmZlciksdGhpcy5jb3B5VGV4Q29tcHV0ZS5zZXRTdG9yYWdlVGV4dHVyZShcInByZUNvbG9yVGV4XCIsdGhpcy5wcmVDb2xvclRleCksdGhpcy5jb3B5VGV4Q29tcHV0ZS53b3JrZXJTaXplWD1NYXRoLmNlaWwodGhpcy50YWFUZXh0dXJlLndpZHRoLzgpLHRoaXMuY29weVRleENvbXB1dGUud29ya2VyU2l6ZVk9TWF0aC5jZWlsKHRoaXMudGFhVGV4dHVyZS5oZWlnaHQvOCksdGhpcy5jb3B5VGV4Q29tcHV0ZS53b3JrZXJTaXplWj0xLHRoaXMuc2hhcnBDb21wdXRlPW5ldyBiZShsYyksdGhpcy5zaGFycENvbXB1dGUuc2V0VW5pZm9ybUJ1ZmZlcihcInRhYURhdGFcIixyKSx0aGlzLnNoYXJwQ29tcHV0ZS5zZXRTYW1wbGVyVGV4dHVyZShcImluVGV4XCIsdGhpcy50YWFUZXh0dXJlKSx0aGlzLnNoYXJwQ29tcHV0ZS5zZXRTdG9yYWdlVGV4dHVyZShcIm91dFRleFwiLHRoaXMub3V0VGV4dHVyZSksdGhpcy5zaGFycENvbXB1dGUud29ya2VyU2l6ZVg9TWF0aC5jZWlsKHRoaXMub3V0VGV4dHVyZS53aWR0aC84KSx0aGlzLnNoYXJwQ29tcHV0ZS53b3JrZXJTaXplWT1NYXRoLmNlaWwodGhpcy5vdXRUZXh0dXJlLmhlaWdodC84KSx0aGlzLnNoYXJwQ29tcHV0ZS53b3JrZXJTaXplWj0xfWNyZWF0ZVJlc291cmNlKCl7dGhpcy5wcmVQcm9qTWF0cml4PW5ldyBWKCkuaWRlbnRpdHkoKSx0aGlzLnByZVZpZXdNYXRyaXg9bmV3IFYoKS5pZGVudGl0eSgpO2xldCBlPVMucHJlc2VudGF0aW9uU2l6ZSx0PWVbMF0scj1lWzFdO3RoaXMucHJlQ29sb3JCdWZmZXI9bmV3IGdlKHQqcio0LEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDKSx0aGlzLnByZUNvbG9yVGV4PW5ldyBvZSh0LHIsRy5yZ2JhMTZmbG9hdCwhMSxHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HfEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVHxHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkN8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyksdGhpcy5wcmVDb2xvclRleC5uYW1lPVwidGFhVGV4XCI7bGV0IHM9bmV3IENlO3MuY2xlYXJWYWx1ZT1bMCwwLDAsMV0scy5sb2FkT3A9XCJjbGVhclwiLHRoaXMudGFhVGV4dHVyZT1uZXcgb2UodCxyLEcucmdiYTE2ZmxvYXQsITEsR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDfEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcpLHRoaXMudGFhVGV4dHVyZS5uYW1lPVwidGFhVGV4XCI7bGV0IGE9bmV3IENlO2EuY2xlYXJWYWx1ZT1bMCwwLDAsMV0sYS5sb2FkT3A9XCJjbGVhclwiLHRoaXMub3V0VGV4dHVyZT1uZXcgb2UodCxyLEcucmdiYTE2ZmxvYXQsITEsR1BVVGV4dHVyZVVzYWdlLlNUT1JBR0VfQklORElOR3xHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDfEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcpLHRoaXMub3V0VGV4dHVyZS5uYW1lPVwic2hhcnBUYWFUZXhcIjtsZXQgbj1uZXcgQ2U7bi5jbGVhclZhbHVlPVswLDAsMCwxXSxuLmxvYWRPcD1cImNsZWFyXCIsdGhpcy5ydEZyYW1lPW5ldyBaZShbdGhpcy5wcmVDb2xvclRleCx0aGlzLnRhYVRleHR1cmUsdGhpcy5vdXRUZXh0dXJlXSxbcyxhLG5dKX1yZW5kZXIoZSx0KXt0aGlzLnRhYUNvbXB1dGV8fCh0aGlzLmNyZWF0ZVJlc291cmNlKCksdGhpcy5jcmVhdGVDb21wdXRlKGUpLHRoaXMucmVuZGVyZXJQYXNzU3RhdGU9SGUuY3JlYXRlUmVuZGVyZXJQYXNzU3RhdGUodGhpcy5ydEZyYW1lLG51bGwpKTtsZXQgcj1BLnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLnRhYTt0aGlzLnRhYVNldHRpbmcuc2V0TWF0cml4KFwicHJlUHJvak1hdHJpeFwiLHRoaXMucHJlUHJvak1hdHJpeCksdGhpcy50YWFTZXR0aW5nLnNldE1hdHJpeChcInByZVZpZXdNYXRyaXhcIix0aGlzLnByZVZpZXdNYXRyaXgpLHRoaXMudGFhU2V0dGluZy5zZXRGbG9hdChcImppdHRlckZyYW1lSW5kZXhcIixlLmNhbWVyYS5qaXR0ZXJGcmFtZUluZGV4KSx0aGlzLnRhYVNldHRpbmcuc2V0RmxvYXQoXCJibGVuZEZhY3RvclwiLHIuYmxlbmRGYWN0b3IpLHRoaXMudGFhU2V0dGluZy5zZXRGbG9hdChcInNoYXJwRmFjdG9yXCIsci5zaGFycEZhY3RvciksdGhpcy50YWFTZXR0aW5nLnNldEZsb2F0KFwic2hhcnBQcmVCbHVyRmFjdG9yXCIsci5zaGFycFByZUJsdXJGYWN0b3IpLHRoaXMudGFhU2V0dGluZy5zZXRGbG9hdChcImppdHRlclhcIixlLmNhbWVyYS5qaXR0ZXJYKSx0aGlzLnRhYVNldHRpbmcuc2V0RmxvYXQoXCJqaXR0ZXJZXCIsZS5jYW1lcmEuaml0dGVyWSksdGhpcy50YWFTZXR0aW5nLmFwcGx5KCksdy5jb21wdXRlQ29tbWFuZCh0LFt0aGlzLmNvcHlUZXhDb21wdXRlLHRoaXMudGFhQ29tcHV0ZSx0aGlzLnNoYXJwQ29tcHV0ZV0pLHcubGFzdFJlbmRlclBhc3NTdGF0ZT10aGlzLnJlbmRlcmVyUGFzc1N0YXRlLHRoaXMucHJlUHJvak1hdHJpeC5jb3B5RnJvbShlLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KSx0aGlzLnByZVZpZXdNYXRyaXguY29weUZyb20oZS5jYW1lcmEudmlld01hdHJpeCl9fWNsYXNzIHZme2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiX3RlbXBJbmRleEFycmF5XCIsW10pLG8odGhpcyxcIl9yZW5kZXJlckxpc3RcIixbXSl9c2V0T3V0bGluZShlLHQpe3RoaXMuc2V0T3V0bGluZUxpc3QoW2VdLHQ/W3RdOm51bGwpfXNldE91dGxpbmVMaXN0KGUsdCl7ZXx8KGU9W10pO2xldCByPWt0LmRlZmF1bHRDb2xvcixzPWt0LlNsb3RDb3VudDtmb3IobGV0IGE9MDthPHM7YSsrKXt0aGlzLl90ZW1wSW5kZXhBcnJheS5sZW5ndGg9MDtsZXQgbj1lW2FdLGw9KHQ/dFthXTpudWxsKXx8cjtpZihuKWZvcihjb25zdCBoIG9mIG4pdGhpcy5nZXRFbnRpdHlJZExpc3QoaCx0aGlzLl90ZW1wSW5kZXhBcnJheSk7a3QuZmlsbERhdGFBdChhLHRoaXMuX3RlbXBJbmRleEFycmF5LGwpfX1jbGVhck91dGxpbmUoKXtyZXR1cm4ga3QuY2xlYXIoKSx0aGlzfWdldEVudGl0eUlkTGlzdChlLHQpe3RoaXMuX3JlbmRlcmVyTGlzdC5sZW5ndGg9MDtsZXQgcj1lLmdldENvbXBvbmVudHMoY2UsdGhpcy5fcmVuZGVyZXJMaXN0KTtmb3IoY29uc3QgcyBvZiByKXQucHVzaChzLm9iamVjdDNELnRyYW5zZm9ybS5fd29ybGRNYXRyaXguaW5kZXgpfX1sZXQgWnA9bmV3IHZmO2NsYXNzIHlme2NvbnN0cnVjdG9yKCl7byh0aGlzLFwibG9jYWxQb3NpdGlvblwiLG5ldyBnKSxvKHRoaXMsXCJ3b3JsZFBvc2l0aW9uXCIsbmV3IGcpLG8odGhpcyxcInV2XCIsbmV3IFopLG8odGhpcyxcImZhY2VJbmRleFwiKSxvKHRoaXMsXCJpc0luXCIsITEpLG8odGhpcyxcInRcIiwwKSxvKHRoaXMsXCJ1XCIsMCksbyh0aGlzLFwidlwiLDApLG8odGhpcyxcInRyaWFuZ2xlXCIpLG8odGhpcyxcInYwXCIpLG8odGhpcyxcInYxXCIpLG8odGhpcyxcInYyXCIpLG8odGhpcyxcInBpY2tMaXN0XCIpLG8odGhpcyxcImNvbG9yXCIpfX1jb25zdCBncz1jbGFzc3tzdGF0aWMgZGlzdFB0VHJpKGksZSx0LHIpe2xldCBzPW5ldyBnLGE9bmV3IGcsbj1uZXcgZztyLnN1YnRyYWN0KGUscyksdC5zdWJ0cmFjdChlLGEpLGkuc3VidHJhY3QoZSxuKTtsZXQgbD1ldChzLHMpLGg9ZXQocyxhKSx1PWV0KHMsbiksYz1ldChhLGEpLGY9ZXQoYSxuKSxkPTEvKGwqYy1oKmgpLHA9KGMqdS1oKmYpKmQsbT0obCpmLWgqdSkqZDtpZihwPj0tZ3MuRVBTJiZtPj0tZ3MuRVBTJiZwK208PTErZ3MuRVBTKXtsZXQgXz1lWzFdK3NbMV0qcCthWzFdKm07cmV0dXJuIE1hdGguYWJzKF8taVsxXSl9cmV0dXJuIGdzLkZMVF9NQVh9c3RhdGljIEludGVyc2VjdFRyaWFuZ2xlKGksZSx0KXtsZXQgcj1lLnYxLHM9ZS52MixhPWUudjMsbj1zLnN1YnRyYWN0KHIsZy5IRUxQXzMpLGw9YS5zdWJ0cmFjdChyLGcuSEVMUF80KSxoPWkuZGlyZWN0aW9uLmNyb3NzUHJvZHVjdChsLGcuSEVMUF81KSx1PWV0KG4saCksYztpZih1PjApe2lmKHQpcmV0dXJuIG51bGw7Yz1pLm9yaWdpbi5zdWJ0cmFjdChyLGcuSEVMUF8yKX1lbHNlIGM9ci5zdWJ0cmFjdChpLm9yaWdpbixnLkhFTFBfMiksdT0tdTtpZih1PDFlLTQpcmV0dXJuIHRoaXMuX2luZm8uaXNJbj0hMSx0aGlzLl9pbmZvLnQ9MCx0aGlzLl9pbmZvLnU9MCx0aGlzLl9pbmZvLnY9MCx0aGlzLl9pbmZvO2xldCBmPWV0KGMsaCk7aWYoZjwwfHxmPnUpcmV0dXJuIHRoaXMuX2luZm8uaXNJbj0hMSx0aGlzLl9pbmZvLnQ9MCx0aGlzLl9pbmZvLnU9MCx0aGlzLl9pbmZvLnY9MCx0aGlzLl9pbmZvO2xldCBkPWMuY3Jvc3NQcm9kdWN0KG4sZy5IRUxQXzEpLHA9ZXQoaS5kaXJlY3Rpb24sZCk7aWYocDwwfHxmK3A+dSlyZXR1cm4gdGhpcy5faW5mby5pc0luPSExLHRoaXMuX2luZm8udD0wLHRoaXMuX2luZm8udT0wLHRoaXMuX2luZm8udj0wLHRoaXMuX2luZm87bGV0IG09ZXQobCxkKSxfPTEvdTttKj1fLGYqPV8scCo9Xyx0aGlzLl9pbmZvLmlzSW49ITAsdGhpcy5faW5mby50PW0sdGhpcy5faW5mby51PWYsdGhpcy5faW5mby52PXA7bGV0IHY9MS1mLXA7cmV0dXJuIHRoaXMuX3UwLmNvcHlGcm9tKGUudTEpLHRoaXMuX3UwLnNjYWxlKHYpLHRoaXMuX3UxLmNvcHlGcm9tKGUudTIpLHRoaXMuX3UxLnNjYWxlKGYpLHRoaXMuX3UyLmNvcHlGcm9tKGUudTMpLHRoaXMuX3UyLnNjYWxlKHApLHRoaXMuX2luZm8udXYuY29weUZyb20odGhpcy5fdTApLHRoaXMuX2luZm8udXYuYWRkKHRoaXMuX3UxLHRoaXMuX2luZm8udXYpLHRoaXMuX2luZm8udXYuYWRkKHRoaXMuX3UyLHRoaXMuX2luZm8udXYpLHRoaXMuX2luZm8ubG9jYWxQb3NpdGlvbi5jb3B5RnJvbShpLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIobSksdGhpcy5faW5mby5sb2NhbFBvc2l0aW9uLmFkZChpLm9yaWdpbix0aGlzLl9pbmZvLmxvY2FsUG9zaXRpb24pLHRoaXMuX2luZm99fTtsZXQgemk9Z3M7byh6aSxcIkVQU1wiLDFlLTQpLG8oemksXCJGTFRfTUFYXCIsMzQwMjgyMzQ2NmUyOSksbyh6aSxcIl9pbmZvXCIsbmV3IHlmKSxvKHppLFwiX3UwXCIsbmV3IFopLG8oemksXCJfdTFcIixuZXcgWiksbyh6aSxcIl91MlwiLG5ldyBaKTtjb25zdCBnbj1jbGFzcyBleHRlbmRzIGhpe2NvbnN0cnVjdG9yKCl7aWYoc3VwZXIoKSxvKHRoaXMsXCJfbWF4UmV0cnlcIiwzKSxnbi5faW5zdGFuY2UpdGhyb3cgbmV3IEVycm9yKFwiTG9hZE1hbmFnZXIgaXMgc2luZ2xldG9uIGNsYXNzLi4uXCIpfWxvYWRBbGwoaSxlKXtyZXR1cm4gbmV3IFByb21pc2UoKHQscik9PntsZXQgcz1pLmxlbmd0aCxhPVtdO2kuZm9yRWFjaCgobixsKT0+e2xldCBoPW5ldyBlO3RoaXMubG9hZChuLGUpLnRoZW4odT0+e2gucGFyc2UodSksYS5wdXNoKGgpLHMtLSxzPT09MCYmdChhKX0pfSl9KX1zdGF0aWMgZ2V0SW5zdGFuY2UoKXtyZXR1cm4gdGhpcy5faW5zdGFuY2V8fCh0aGlzLl9pbnN0YW5jZT1uZXcgZ24pfWxvYWRVcmxzKGksZSl7cmV0dXJuIG5ldyBQcm9taXNlKCh0LHIpPT57bGV0IHM9aS5sZW5ndGgsYT1bXTtpLmZvckVhY2goKG4sbCk9Pnt0aGlzLmxvYWQobixlKS50aGVuKGg9PnthLnB1c2goaCkscy0tLHM9PT0wJiZ0KGEpLHM8MCYmY29uc29sZS5lcnJvcihgbG9hZFVybHMgJHtpfSBlcnJvcmApfSl9KX0pfWdldCBtYXhSZXRyeSgpe3JldHVybiB0aGlzLl9tYXhSZXRyeX1zZXQgbWF4UmV0cnkoaSl7dGhpcy5fbWF4UmV0cnk9aX1sb2FkKGksZSl7cmV0dXJuIG5ldyBQcm9taXNlKCh0LHIpPT57c3dpdGNoKGUuZm9ybWF0KXt9fSl9fTtsZXQgQ2Y9Z247byhDZixcIl9pbnN0YW5jZVwiKTtjbGFzcyAkcHt9Y2xhc3MgZW17fWNsYXNzIHRte31jbGFzcyBpbXt9Y2xhc3Mgcm17fWNsYXNzIHNte31jbGFzcyBhbXt9Y2xhc3Mgb217fWNsYXNzIG5te31jbGFzcyBsbXt9Y2xhc3MgaG17Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJhc3NldFwiKSxvKHRoaXMsXCJleHRyYXNcIiksbyh0aGlzLFwiZ2VvbWV0cmljRXJyb3JcIiksbyh0aGlzLFwicHJvcGVydGllc1wiKSxvKHRoaXMsXCJyZWZpbmVcIiksbyh0aGlzLFwicm9vdFwiKX19Y2xhc3MgdW17Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJib3VuZGluZ1ZvbHVtZVwiKSxvKHRoaXMsXCJjaGlsZHJlblwiKSxvKHRoaXMsXCJnZW9tZXRyaWNFcnJvclwiKSxvKHRoaXMsXCJ0cmFuc2Zvcm1cIil9fWNsYXNzIGNte2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiYm91bmRpbmdWb2x1bWVcIiksbyh0aGlzLFwiZ2VvbWV0cmljRXJyb3JcIiksbyh0aGlzLFwicmVmaW5lXCIpLG8odGhpcyxcImNvbnRlbnRcIiksbyh0aGlzLFwiY29udGVudHNcIil9fWNsYXNzIGZte2NvbnN0cnVjdG9yKCl7byh0aGlzLFwidXJpXCIpLG8odGhpcyxcImdyb3VwXCIpLG8odGhpcyxcIm1ldGFkYXRhXCIpfX1jbGFzcyBkbXtjb25zdHJ1Y3Rvcigpe28odGhpcyxcImNsYXNzXCIpLG8odGhpcyxcInByb3BlcnRpZXNcIil9fWNsYXNzIENue2NvbnN0cnVjdG9yKCl7byh0aGlzLFwiZ3JvdXBcIiksbyh0aGlzLFwiX21vZGVsTGlzdFwiKSxvKHRoaXMsXCJfdGlsZVNldFwiKSxvKHRoaXMsXCJfcm9vdFBhdGhcIiksdGhpcy5ncm91cD1uZXcgdGV9YXN5bmMgbG9hZFRpbGVTZXQoZSx0KXt0aGlzLl9tb2RlbExpc3Q9W10sdGhpcy5fcm9vdFBhdGg9ZTtsZXQgcj1lK1wiL1wiK3Q7aWYodGhpcy5fdGlsZVNldD1hd2FpdCBBLnJlcy5sb2FkSlNPTihyKSx0aGlzLl90aWxlU2V0LnJvb3QudHJhbnNmb3JtKXtsZXQgbD1uZXcgVjtmb3IobGV0IGg9MDtoPDE2O2grKylsLnJhd0RhdGFbaF09dGhpcy5fdGlsZVNldC5yb290LnRyYW5zZm9ybVtoXX1sZXQgcz1uZXcgVjtzd2l0Y2goKHRoaXMuX3RpbGVTZXQuYXNzZXQmJnRoaXMuX3RpbGVTZXQuYXNzZXQuZ2x0ZlVwQXhpc3x8XCJ5XCIpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcInhcIjpzLm1ha2VSb3RhdGlvbkF4aXMoZy5ZX0FYSVMsLU1hdGguUEkvMik7YnJlYWs7Y2FzZVwieVwiOnMubWFrZVJvdGF0aW9uQXhpcyhnLlhfQVhJUyxNYXRoLlBJLzIpO2JyZWFrO2Nhc2VcInpcIjpzLmlkZW50aXR5KCk7YnJlYWt9bGV0IG49cy5jbG9uZSgpO24uaW52ZXJ0KCksdGhpcy5hcHBseVRyYW5zZm9ybSh0aGlzLmdyb3VwLnRyYW5zZm9ybSxuKTtmb3IobGV0IGwgb2YgdGhpcy5fdGlsZVNldC5yb290LmNoaWxkcmVuKXtsZXQgaD1bXTtpZihsLmNvbnRlbnQmJmwuY29udGVudC51cmkmJmgucHVzaChsLmNvbnRlbnQudXJpKSxsLmNvbnRlbnRzKWZvcihsZXQgdSBvZiBsLmNvbnRlbnRzKWgucHVzaCh1LnVyaSk7Zm9yKGxldCB1IG9mIGgpe2xldCBjPXRoaXMuX3Jvb3RQYXRoK1wiL1wiK3UsZj17b25Qcm9ncmVzczpwPT50aGlzLm9uTG9hZFByb2dyZXNzKHApLG9uQ29tcGxldGU6cD0+dGhpcy5vbkNvbXBsZXRlKHApfSxkO2lmKGMuZW5kc1dpdGgoXCIuZ2xiXCIpKWQ9YXdhaXQgQS5yZXMubG9hZEdsdGYoYyxmKSx0aGlzLmFwcGx5VHJhbnNmb3JtKGQudHJhbnNmb3JtLHMpO2Vsc2UgaWYoYy5lbmRzV2l0aChcInRpbGVzZXQuanNvblwiKSl7bGV0IHA9Yy5yZXBsYWNlKFwiL3RpbGVzZXQuanNvblwiLFwiXCIpLG09bmV3IENuO2F3YWl0IG0ubG9hZFRpbGVTZXQocCxcInRpbGVzZXQuanNvblwiKSxkPW0uZ3JvdXB9ZWxzZSBjLmVuZHNXaXRoKFwiLmkzZG1cIik/ZD1hd2FpdCBBLnJlcy5sb2FkSTNETShjLGYscyk6Yy5lbmRzV2l0aChcIi5iM2RtXCIpJiYoZD1hd2FpdCBBLnJlcy5sb2FkQjNETShjLGYscykpO2QmJih0aGlzLl9tb2RlbExpc3QucHVzaChkKSx0aGlzLmdyb3VwLmFkZENoaWxkKGQpKX19fW9uTG9hZFByb2dyZXNzKGUpe31vbkNvbXBsZXRlKGUpe31hcHBseVRyYW5zZm9ybShlLHQpe2xldCByPXQuZGVjb21wb3NlKHl0LlFVQVRFUk5JT04pO2UubG9jYWxSb3RRdWF0LmNvcHlGcm9tKHJbMV0pLGUubG9jYWxSb3RRdWF0PWUubG9jYWxSb3RRdWF0LGUubG9jYWxQb3NpdGlvbi5jb3B5RnJvbShyWzBdKSxlLmxvY2FsUG9zaXRpb249ZS5sb2NhbFBvc2l0aW9uLGUubG9jYWxTY2FsZS5jb3B5RnJvbShyWzJdKSxlLmxvY2FsU2NhbGU9ZS5sb2NhbFNjYWxlfX1jbGFzcyB3ZiBleHRlbmRzIG9ze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxOLnJlZ2lzdGVyKFwiQ29sb3JMaXRTaGFkZXJcIixlbi5PcmlfQWxsU2hhZGVyKTtsZXQgZT1uZXcgV2UoXCJDb2xvckxpdFNoYWRlclwiLFwiQ29sb3JMaXRTaGFkZXJcIik7ZS5zZXREZWZpbmUoXCJVU0VfQlJERlwiLCEwKSxlLnNldFNoYWRlckVudHJ5KFwiVmVydE1haW5cIixcIkZyYWdNYWluXCIpLGUuc2V0VW5pZm9ybUNvbG9yKFwiYmFzZUNvbG9yXCIsbmV3IHopLGUuc2V0VW5pZm9ybUNvbG9yKFwiZW1pc3NpdmVDb2xvclwiLG5ldyB6KSxlLnNldFVuaWZvcm1GbG9hdChcImVudkludGVuc2l0eVwiLDEpLGUuc2V0VW5pZm9ybUZsb2F0KFwibm9ybWFsU2NhbGVcIiwxKSxlLnNldFVuaWZvcm1GbG9hdChcInJvdWdobmVzc1wiLDApLGUuc2V0VW5pZm9ybUZsb2F0KFwibWV0YWxsaWNcIiwwKSxlLnNldFVuaWZvcm1GbG9hdChcImFvXCIsMSksZS5zZXRVbmlmb3JtRmxvYXQoXCJhbHBoYUN1dG9mZlwiLDApO2xldCB0PWUuc2hhZGVyU3RhdGU7dC5hY2NlcHRTaGFkb3c9ITAsdC5yZWNlaXZlRW52PSEwLHQuYWNjZXB0R0k9ITAsdC51c2VMaWdodD0hMCxlLnNldFRleHR1cmUoXCJub3JtYWxNYXBcIixBLnJlcy5ub3JtYWxUZXh0dXJlKSxlLnNldFRleHR1cmUoXCJlbWlzc2l2ZU1hcFwiLEEucmVzLmJsYWNrVGV4dHVyZSl9Y2xvbmUoKXtyZXR1cm4gbnVsbH1kZWJ1Zygpe319byh3ZixcImNvdW50XCIsMCk7ZnVuY3Rpb24gZ20oaSxlKXt9Y2xhc3Mgd24gZXh0ZW5kcyBvc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTi5yZWdpc3RlcihcIkdsYXNzU2hhZGVyXCIsQ2MpO2xldCBlPW5ldyBXZShcIkdsYXNzU2hhZGVyXCIsXCJHbGFzc1NoYWRlclwiKTt0aGlzLmRlZmF1bHRQYXNzPWUsZS5zZXREZWZpbmUoXCJVU0VfQlJERlwiLCEwKSxlLnNldFNoYWRlckVudHJ5KFwiVmVydE1haW5cIixcIkZyYWdNYWluXCIpO2xldCB0PWUuc2hhZGVyU3RhdGU7dC5hY2NlcHRTaGFkb3c9ITAsdC5jYXN0U2hhZG93PSEwLHQucmVjZWl2ZUVudj0hMCx0LmFjY2VwdEdJPSEwLHQudXNlTGlnaHQ9ITA7bGV0IHI9QS5yZXMuZ2V0VGV4dHVyZShcIkJSREZMVVRcIik7dGhpcy5icmRmTFVUPXIsdGhpcy5iYXNlTWFwPUEucmVzLndoaXRlVGV4dHVyZSx0aGlzLm5vcm1hbE1hcD1BLnJlcy5ub3JtYWxUZXh0dXJlLHRoaXMuZW1pc3NpdmVNYXA9QS5yZXMuYmxhY2tUZXh0dXJlfWNsb25lKCl7Y29uc29sZS5sb2coYGNsb25lIG1hdGVyaWFsICR7dGhpcy5uYW1lfWApO2xldCBlPW5ldyB3bjtyZXR1cm4gZS5iYXNlTWFwPXRoaXMuYmFzZU1hcCxlLm5vcm1hbE1hcD10aGlzLm5vcm1hbE1hcCxlLmFvTWFwPXRoaXMuYW9NYXAsdGhpcy5tYXNrTWFwJiYoZS5tYXNrTWFwPXRoaXMubWFza01hcCksZS5lbWlzc2l2ZU1hcD10aGlzLmVtaXNzaXZlTWFwLHRoaXMudXZUcmFuc2Zvcm1fMSYmKGUudXZUcmFuc2Zvcm1fMT1uZXcgaigpLmNvcHlGcm9tKHRoaXMudXZUcmFuc2Zvcm1fMSkpLHRoaXMudXZUcmFuc2Zvcm1fMiYmKGUudXZUcmFuc2Zvcm1fMj1uZXcgaigpLmNvcHlGcm9tKHRoaXMudXZUcmFuc2Zvcm1fMikpLGUuYmFzZUNvbG9yPXRoaXMuYmFzZUNvbG9yLmNsb25lKCksZS5lbWlzc2l2ZUNvbG9yPXRoaXMuZW1pc3NpdmVDb2xvci5jbG9uZSgpLHRoaXMubWF0ZXJpYWxGMCYmKGUubWF0ZXJpYWxGMD1uZXcgaigpLmNvcHlGcm9tKHRoaXMubWF0ZXJpYWxGMCkpLGUuZW52SW50ZW5zaXR5PXRoaXMuZW52SW50ZW5zaXR5LGUubm9ybWFsU2NhbGU9dGhpcy5ub3JtYWxTY2FsZSxlLnJvdWdobmVzcz10aGlzLnJvdWdobmVzcyxlLm1ldGFsbGljPXRoaXMubWV0YWxsaWMsZS5hbz10aGlzLmFvLGUucm91Z2huZXNzX21pbj10aGlzLnJvdWdobmVzc19taW4sZS5yb3VnaG5lc3NfbWF4PXRoaXMucm91Z2huZXNzX21heCxlLm1ldGFsbGljX21pbj10aGlzLm1ldGFsbGljX21pbixlLm1ldGFsbGljX21heD10aGlzLm1ldGFsbGljX21heCxlLmVtaXNzaXZlSW50ZW5zaXR5PXRoaXMuZW1pc3NpdmVJbnRlbnNpdHksZS5hbHBoYUN1dG9mZj10aGlzLmFscGhhQ3V0b2ZmLGUuaW9yPXRoaXMuaW9yLGUuY2xlYXJjb2F0RmFjdG9yPXRoaXMuY2xlYXJjb2F0RmFjdG9yLGUuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yPXRoaXMuY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yLGV9fWNsYXNzIHBtIGV4dGVuZHMgX2l7Y29uc3RydWN0b3IoKXtzdXBlcigpO2xldCBlPW5ldyBXZShcIkxhbWJlcnRTaGFkZXJcIixcIkxhbWJlcnRTaGFkZXJcIik7ZS5zZXRTaGFkZXJFbnRyeShcIlZlcnRNYWluXCIsXCJGcmFnTWFpblwiKSxlLnNldFVuaWZvcm1WZWN0b3I0KFwidHJhbnNmb3JtVVYxXCIsbmV3IGooMCwwLDEsMSkpLGUuc2V0VW5pZm9ybVZlY3RvcjQoXCJ0cmFuc2Zvcm1VVjJcIixuZXcgaigwLDAsMSwxKSksZS5zZXRVbmlmb3JtQ29sb3IoXCJiYXNlQ29sb3JcIixuZXcgeigxLDEsMSwxKSksZS5zZXRVbmlmb3JtRmxvYXQoXCJhbHBoYUN1dG9mZlwiLC41KTtsZXQgdD1lLnNoYWRlclN0YXRlO3QuYWNjZXB0U2hhZG93PSExLHQuY2FzdFNoYWRvdz0hMSx0LnJlY2VpdmVFbnY9ITEsdC5hY2NlcHRHST0hMSx0LnVzZUxpZ2h0PSExLHRoaXMuZGVmYXVsdFBhc3M9ZSx0aGlzLmJhc2VNYXA9QS5yZXMuZ3JheVRleHR1cmV9c2V0IGJhc2VNYXAoZSl7dGhpcy5kZWZhdWx0UGFzcy5zZXRUZXh0dXJlKFwiYmFzZU1hcFwiLGUpfWdldCBiYXNlTWFwKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFBhc3MuZ2V0VGV4dHVyZShcImJhc2VNYXBcIil9c2V0IGJhc2VDb2xvcihlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFVuaWZvcm1Db2xvcihcImJhc2VDb2xvclwiLGUpfWdldCBiYXNlQ29sb3IoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UGFzcy51bmlmb3Jtcy5iYXNlQ29sb3IuY29sb3J9c2V0IGVudk1hcChlKXt9c2V0IHNoYWRvd01hcChlKXt9fWNsYXNzIG1tIGV4dGVuZHMgX2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLE4ucmVnaXN0ZXIoXCJVbkxpdFNoYWRlclwiLHRuKSxOLnJlZ2lzdGVyKFwiUG9pbnRTaGFkb3dEZWJ1Z1wiLGJjKTtsZXQgZT1uZXcgV2UoXCJVbkxpdFNoYWRlclwiLFwiUG9pbnRTaGFkb3dEZWJ1Z1wiKTt0aGlzLmRlZmF1bHRQYXNzPWUsZS5zZXRTaGFkZXJFbnRyeShcIlZlcnRNYWluXCIsXCJGcmFnTWFpblwiKSxlLnNldFVuaWZvcm1WZWN0b3I0KFwidHJhbnNmb3JtVVYxXCIsbmV3IGooMCwwLDEsMSkpLGUuc2V0VW5pZm9ybVZlY3RvcjQoXCJ0cmFuc2Zvcm1VVjJcIixuZXcgaigwLDAsMSwxKSksZS5zZXRVbmlmb3JtQ29sb3IoXCJiYXNlQ29sb3JcIixuZXcgeiksZS5zZXRVbmlmb3JtRmxvYXQoXCJhbHBoYUN1dG9mZlwiLC41KTtsZXQgdD1lLnNoYWRlclN0YXRlO3QuYWNjZXB0U2hhZG93PSExLHQucmVjZWl2ZUVudj0hMSx0LmFjY2VwdEdJPSExLHQudXNlTGlnaHQ9ITEsdGhpcy5iYXNlTWFwPUEucmVzLndoaXRlVGV4dHVyZX1zZXQgYmFzZU1hcChlKXt0aGlzLmRlZmF1bHRQYXNzLnNldFRleHR1cmUoXCJiYXNlTWFwXCIsZSl9c2V0IGVudk1hcChlKXt9c2V0IHNoYWRvd01hcChlKXt9ZGVidWcoKXt9fWNsYXNzIGJmIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoKXtzdXBlcihcImNhc3RQb2ludFNoYWRvd01hcF92ZXJ0XCIsXCJzaGFkb3dDYXN0TWFwX2ZyYWdcIiksdGhpcy5zZXRTaGFkZXJFbnRyeShcIm1haW5cIixcIm1haW5cIiksdGhpcy5zZXRVbmlmb3JtRmxvYXQoXCJjYW1lcmFGYXJcIiw1ZTMpLHRoaXMuc2V0VW5pZm9ybVZlY3RvcjMoXCJsaWdodFdvcmxkUG9zXCIsZy5aRVJPKSx0aGlzLnNoYWRlclN0YXRlLnJlY2VpdmVFbnY9ITEsdGhpcy5zaGFkZXJTdGF0ZS5jYXN0U2hhZG93PSExLHRoaXMuc2hhZGVyU3RhdGUuYWNjZXB0U2hhZG93PSExLHRoaXMuc2V0RGVmaW5lKFwiVVNFX0FMUEhBQ1VUXCIsITApfX1jbGFzcyBTZiBleHRlbmRzIFdle2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJzaGFkb3dDYXN0TWFwX3ZlcnRcIixcImRpcmVjdGlvblNoYWRvd0Nhc3RNYXBfZnJhZ1wiKSx0aGlzLnNldFNoYWRlckVudHJ5KFwibWFpblwiKSx0aGlzLnNldFVuaWZvcm1GbG9hdChcImNhbWVyYUZhclwiLDVlMyksdGhpcy5zZXRVbmlmb3JtVmVjdG9yMyhcImxpZ2h0V29ybGRQb3NcIixnLlpFUk8pLHRoaXMuc2hhZGVyU3RhdGUucmVjZWl2ZUVudj0hMSx0aGlzLnNoYWRlclN0YXRlLmNhc3RTaGFkb3c9ITEsdGhpcy5zaGFkZXJTdGF0ZS5hY2NlcHRTaGFkb3c9ITEsdGhpcy5zZXREZWZpbmUoXCJVU0VfQUxQSEFDVVRcIiwhMCl9c2V0VGV4dHVyZShlLHQpe3N1cGVyLnNldFRleHR1cmUoZSx0KX19Y2xhc3MgSWYgZXh0ZW5kcyBXZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiWlBhc3Nfc2hhZGVyX3ZzXCIsXCJaUGFzc19zaGFkZXJfdnNcIiksdGhpcy5zZXRTaGFkZXJFbnRyeShcIm1haW5cIiksdGhpcy51c2VSej0hMTtsZXQgZT10aGlzLnNoYWRlclN0YXRlO2UucmVjZWl2ZUVudj0hMX19Y2xhc3MgRWYgZXh0ZW5kcyBXZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiZ2J1ZmZlcl92c1wiLFwiZ2J1ZmZlcl9mc1wiKSxvKHRoaXMsXCJ0cmFuc3BhcmVuY3lcIiksdGhpcy5zZXRTaGFkZXJFbnRyeShcIlZlcnRNYWluXCIsXCJGcmFnTWFpblwiKSx0aGlzLnNoYWRlclN0YXRlLHRoaXMuc2V0VW5pZm9ybUNvbG9yKFwiYmFzZUNvbG9yXCIsbmV3IHopLHRoaXMuc2V0VW5pZm9ybUNvbG9yKFwiZW1pc3NpdmVDb2xvclwiLG5ldyB6KSx0aGlzLnNldFVuaWZvcm1GbG9hdChcImVtaXNzaXZlSW50ZW5zaXR5XCIsMSksdGhpcy5zZXRVbmlmb3JtRmxvYXQoXCJub3JtYWxTY2FsZVwiLDEpLHRoaXMuc2V0VW5pZm9ybUZsb2F0KFwiYWxwaGFDdXRvZmZcIiwxKSx0aGlzLmJsZW5kTW9kZT14ZS5OT05FLHRoaXMuc2V0VGV4dHVyZShcIm5vcm1hbE1hcFwiLEEucmVzLm5vcm1hbFRleHR1cmUpfX1jbGFzcyBCZiBleHRlbmRzIFdle2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJza3lfdnNfZnJhZ193Z3NsXCIsXCJTa3lHQnVmZmVyX2ZzXCIpLHRoaXMuc2V0VW5pZm9ybUZsb2F0KFwiZXhwb3N1cmVcIiwxKSx0aGlzLnNldFVuaWZvcm1GbG9hdChcInJvdWdobmVzc1wiLDApO2xldCBlPXRoaXMuc2hhZGVyU3RhdGU7ZS5mcm9udEZhY2U9XCJjY3dcIixlLmN1bGxNb2RlPXVpLmZyb250LGUuZGVwdGhXcml0ZUVuYWJsZWQ9ITEsZS5kZXB0aENvbXBhcmU9dnQubGVzc319Y2xhc3MgSWF7Y29uc3RydWN0b3IoZT1bXSl7byh0aGlzLFwiX3BvaW50c1wiKSxvKHRoaXMsXCJfY2FjaGVWYWx1ZVwiKSx0aGlzLnBvaW50cz1lLHRoaXMuX2NhY2hlVmFsdWU9bmV3IFp9Z2V0IHBvaW50cygpe3JldHVybiB0aGlzLl9wb2ludHN9c2V0IHBvaW50cyhlKXt0aGlzLl9wb2ludHM9ZX1nZXRWYWx1ZShlKXtlPDAmJihlPTApLGU+MSYmKGU9MSk7bGV0IHQ9dGhpcy5wb2ludHMubGVuZ3RoLTEscj1NYXRoLmZsb29yKHQqZSkscz1yKzEsYT1zdC5mcmFjdCgodCsxKSplKTtyZXR1cm4gcz49dCYmKHM9cixhPTApLHRoaXMuX2NhY2hlVmFsdWUueD10aGlzLnBvaW50c1tyXS54Kyh0aGlzLnBvaW50c1tzXS54LXRoaXMucG9pbnRzW3JdLngpKmEsdGhpcy5fY2FjaGVWYWx1ZS55PXRoaXMucG9pbnRzW3JdLnkrKHRoaXMucG9pbnRzW3NdLnktdGhpcy5wb2ludHNbcl0ueSkqYSx0aGlzLl9jYWNoZVZhbHVlfXN0YXRpYyBjcmVhdGVCZXppZXJQb2ludHMoZSx0KXtmb3IodmFyIHI9bmV3IElhLHM9MDtzPHQ7cysrKXt2YXIgYT1JYS5tdWx0aVBvaW50QmV6aWVyKGUscy90KTtyLnBvaW50cy5wdXNoKGEpfXJldHVybiByfXN0YXRpYyBtdWx0aVBvaW50QmV6aWVyKGUsdCl7Zm9yKHZhciByPWUubGVuZ3RoLHM9MCxhPTAsbj1mdW5jdGlvbih1LGMpe2Zvcih2YXIgZj0xLGQ9MTtjPjA7KWYqPXUsZCo9Yyx1LS0sYy0tO3JldHVybiBmL2R9LGw9MDtsPHI7bCsrKXt2YXIgaD1lW2xdO3MrPWgueCpNYXRoLnBvdygxLXQsci0xLWwpKk1hdGgucG93KHQsbCkqbihyLTEsbCksYSs9aC55Kk1hdGgucG93KDEtdCxyLTEtbCkqTWF0aC5wb3codCxsKSpuKHItMSxsKX1yZXR1cm4gbmV3IFoocyxhKX19Y2xhc3MgVGZ7c3RhdGljIGNhbGN1bGF0ZUN1YmljQmV6aWVyUG9pbnQoZSx0LHIscyxhKXtlPjEmJihlPTEpLGU8MCYmKGU9MCk7bGV0IG49MS1lLGw9bipuLGg9bipuKm4sdT1lKmUsYz1lKmUqZSxmPXQubXVsKGgpLGQ9ci5tdWwoMyk7ZD1kLm11bChlKSxkPWQubXVsKGwpO2xldCBwPXMubXVsKDMpO3A9cC5tdWwodSkscD1wLm11bChuKTtsZXQgbT1hLm11bChjKTtyZXR1cm4gZj1mLmFkZChkKSxmPWYuYWRkKHApLGY9Zi5hZGQobSksZn1zdGF0aWMgYmV6aWVyUG9pbnQoZSx0LHIscyl7ZT4xJiYoZT0xKSxlPDAmJihlPTApO2xldCBhPTEtZSxuPWEqYSxsPWUqZSxoPXQubXVsKG4pLHU9ci5tdWwoMik7dS5zY2FsZUJ5KGEpLHUuc2NhbGVCeShlKTtsZXQgYz1zLm11bChsKTtyZXR1cm4gaD1oLmFkZCh1KSxoPWguYWRkKGMpLGh9c3RhdGljIGNhbGN1bGF0ZUN1YmljQmV6aWVyUG9pbnRzKGUsdCxyKXtlPjEmJihlPTEpLGU8MCYmKGU9MCk7bGV0IHM9MS1lLGE9cypzLG49cypzKnMsbD1lKmUsaD1lKmUqZSx1PXRbcl0ubXVsKG4pLGM9dFtyKzFdLm11bCgzKTtjPWMubXVsKGUpLGM9Yy5tdWwoYSk7bGV0IGY9dFtyKzJdLm11bCgzKTtmPWYubXVsKGwpLGY9Zi5tdWwocyk7bGV0IGQ9dFtyKzNdLm11bChoKTtyZXR1cm4gdT11LmFkZChjKSx1PXUuYWRkKGYpLHU9dS5hZGQoZCksdX1zdGF0aWMgYmV6aWVyUGF0aFZhbHVlKGUsdCl7ZT4xJiYoZT0xKSxlPDAmJihlPTApO2xldCByPXQubGVuZ3RoLHM9dGhpcy50bXBfcG9pbnRzO3MubGVuZ3RoPTA7Zm9yKGxldCBhPTE7YTxyOysrYSlmb3IobGV0IG49MDtuPHItYTsrK24pe2lmKGE9PTEpe2xldCBoPW5ldyBnO2gueD10W25dLngqKDEtZSkrdFtuKzFdLngqZSxoLnk9dFtuXS55KigxLWUpK3RbbisxXS55KmUsaC56PXRbbl0ueiooMS1lKSt0W24rMV0ueiplLHRoaXMudG1wX3BvaW50cy5wdXNoKGgpO2NvbnRpbnVlfWxldCBsPW5ldyBnO2wueD1zW25dLngqKDEtZSkrc1tuKzFdLngqZSxsLnk9c1tuXS55KigxLWUpK3NbbisxXS55KmUsbC56PXNbbl0ueiooMS1lKStzW24rMV0ueiplLHMucHVzaChsKX1yZXR1cm4gc1swXX19byhUZixcInRtcF9wb2ludHNcIixbXSk7Y2xhc3MgY2F7Y29uc3RydWN0b3IoZSl7byh0aGlzLFwiY29udHJvbFZlcnRpY2VzXCIpLHRoaXMuc2V0Q29udHJvbFZlcnRpY2VzKGUpfXNldENvbnRyb2xWZXJ0aWNlcyhlKXtlLmxlbmd0aD09NCYmKHRoaXMuY29udHJvbFZlcnRpY2VzPWUuY29uY2F0KCkpfWdldFBvaW50KGUpe2lmKCEoZT49MCYmZTw9MSkpcmV0dXJuIGcuWkVSTztsZXQgdD0xLWUscj10KnQqdCxzPTMqZSp0KnQsYT0zKmUqZSp0LG49ZSplKmU7cmV0dXJuIHRoaXMuY29udHJvbFZlcnRpY2VzWzBdLm11bChyKS5hZGQodGhpcy5jb250cm9sVmVydGljZXNbMV0ubXVsKHMpKS5hZGQodGhpcy5jb250cm9sVmVydGljZXNbMl0ubXVsKGEpKS5hZGQodGhpcy5jb250cm9sVmVydGljZXNbM10ubXVsKG4pKX1nZXRUYW5nZW50KGUpe2lmKCEoZT49MCYmZTw9MSkpcmV0dXJuIGcuWkVSTztsZXQgdD10aGlzLmNvbnRyb2xWZXJ0aWNlcyxyPXRbMF0uYWRkKHRbMV0uYWRkKHRbMF0pLm11bChlKSkscz10WzFdLmFkZCh0WzJdLmFkZCh0WzFdKS5tdWwoZSkpLGE9dFsyXS5hZGQodFszXS5hZGQodFsyXSkubXVsKGUpKSxuPXIuYWRkKHMuc3VidHJhY3QocikubXVsKGUpKTtyZXR1cm4gcy5hZGQoYS5zdWJ0cmFjdChzKS5tdWwoZSkpLnN1YnRyYWN0KG4pfWdldENsb3Nlc3RQYXJhbShlLHQ9MWUtNil7cmV0dXJuIHRoaXMuZ2V0Q2xvc2VzdFBhcmFtUmVjKGUsMCwxLHQpfWdldENsb3Nlc3RQYXJhbVJlYyhlLHQscixzKXtsZXQgYT0odCtyKS8yO2lmKHItdDxzKXJldHVybiBhO2xldCBuPSh0K2EpLzIsbD0oYStyKS8yLGg9dGhpcy5nZXRQb2ludChuKSx1PXRoaXMuZ2V0UG9pbnQobCksYz1oLnN1YnRyYWN0KGUpLmxlbmd0aFNxdWFyZWQsZj11LnN1YnRyYWN0KGUpLmxlbmd0aFNxdWFyZWQ7cmV0dXJuIGM8Zj9yPWE6dD1hLHRoaXMuZ2V0Q2xvc2VzdFBhcmFtUmVjKGUsdCxyLHMpfX12YXIgTWY9KGk9PihpW2kuT3Blbj0wXT1cIk9wZW5cIixpW2kuQ2xvc2VkPTFdPVwiQ2xvc2VkXCIsaSkpKE1mfHx7fSk7Y2xhc3MgQW17Y29uc3RydWN0b3IoZSx0PTApe28odGhpcyxcInR5cGVcIiwwKSxvKHRoaXMsXCJudW1DdXJ2ZVNlZ21lbnRzXCIsMCksbyh0aGlzLFwibnVtQ29udHJvbFZlcnRpY2VzXCIsMCksbyh0aGlzLFwiY29udHJvbFZlcnRpY2VzXCIsW10pLHRoaXMuc2V0Q29udHJvbFZlcnRpY2VzKGUsdCl9Z2V0UGF0aFR5cGUoKXtyZXR1cm4gdGhpcy50eXBlfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMudHlwZT09MX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMubnVtQ3VydmVTZWdtZW50cz4wfWNsZWFyKCl7dGhpcy5jb250cm9sVmVydGljZXMubGVuZ3RoPTAsdGhpcy50eXBlPTAsdGhpcy5udW1DdXJ2ZVNlZ21lbnRzPTAsdGhpcy5udW1Db250cm9sVmVydGljZXM9MH1jb21wdXRlQXBwcm94TGVuZ3RoKCl7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiAwO2xldCBlPXRoaXMubnVtQ3VydmVTZWdtZW50cysxO2lmKGU8MilyZXR1cm4gMDtsZXQgdD0wLHI9dGhpcy5jb250cm9sVmVydGljZXM7Zm9yKGxldCBzPTE7czxlO3MrKyl7bGV0IGE9clsocy0xKSozXSxuPXJbcyozXTt0Kz1hLnN1YnRyYWN0KG4pLmxlbmd0aFNxdWFyZWR9cmV0dXJuIHQ9PTA/MDp0fWNvbXB1dGVBcHByb3hQYXJhbVBlclVuaXRMZW5ndGgoKXtsZXQgZT10aGlzLmNvbXB1dGVBcHByb3hMZW5ndGgoKTtyZXR1cm4gdGhpcy5udW1DdXJ2ZVNlZ21lbnRzL2V9Y29tcHV0ZUFwcHJveE5vcm1QYXJhbVBlclVuaXRMZW5ndGgoKXtyZXR1cm4gMS90aGlzLmNvbXB1dGVBcHByb3hMZW5ndGgoKX1pbnRlcnBvbGF0ZVBvaW50cyhlLHQpe2xldCByPWUubGVuZ3RoO3I8MiYmY29uc29sZS5lcnJvcihcInBvaW50IGNvdW50IG11c3QgZ3JlYXQgMVwiKSx0aGlzLmNsZWFyKCksdGhpcy50eXBlPXQ7bGV0IHM9dGhpcy5jb250cm9sVmVydGljZXM7c3dpdGNoKHQpe2Nhc2UgMDp7dGhpcy5udW1DdXJ2ZVNlZ21lbnRzPXItMSx0aGlzLm51bUNvbnRyb2xWZXJ0aWNlcz0zKnItMixzLmxlbmd0aD10aGlzLm51bUNvbnRyb2xWZXJ0aWNlcztmb3IobGV0IGw9MDtsPHI7bCsrKXNbbCozXT1lW2xdO2xldCBhPWVbMV0uc3VidHJhY3QoZVswXSkubXVsKC4yNSk7c1sxXT1lWzBdLmFkZChhKTtsZXQgbj1lW3ItMl0uc3VidHJhY3QoZVtyLTFdKS5tdWwoLjI1KTtzW3RoaXMubnVtQ29udHJvbFZlcnRpY2VzLTJdPWVbci0xXS5hZGQobik7Zm9yKGxldCBsPTE7bDx0aGlzLm51bUN1cnZlU2VnbWVudHM7bCsrKXtsZXQgaD1lW2wtMV0uc3VidHJhY3QoZVtsXSksdT1lW2wrMV0uc3VidHJhY3QoZVtsXSksYz1oLmxlbmd0aFNxdWFyZWQsZj11Lmxlbmd0aFNxdWFyZWQ7aWYoYz4wJiZmPjApe2xldCBkPShjK2YpLzgscD11LmRpdihmKS5zdWJ0cmFjdChoLmRpdihjKSk7cC5ub3JtYWxpemUoKSxwPXAubXVsKGQpLHNbbCozLTFdPWVbbF0uc3VidHJhY3QocCksc1tsKjMrMV09ZVtsXS5hZGQocCl9ZWxzZSBzW2wqMy0xXT1lW2xdLHNbbCozKzFdPWVbbF19YnJlYWt9Y2FzZSAxOnt0aGlzLm51bUN1cnZlU2VnbWVudHM9cix0aGlzLm51bUNvbnRyb2xWZXJ0aWNlcz0zKnIrMSxzLmxlbmd0aD10aGlzLm51bUNvbnRyb2xWZXJ0aWNlcztmb3IobGV0IGE9MDthPHI7YSsrKXNbYSozXT1lW2FdO3NbdGhpcy5udW1Db250cm9sVmVydGljZXMtMV09ZVswXTtmb3IobGV0IGE9MTthPD10aGlzLm51bUN1cnZlU2VnbWVudHM7YSsrKXtsZXQgbj1hLTEsbD0oYSsxKSV0aGlzLm51bUN1cnZlU2VnbWVudHMsaD1hJXRoaXMubnVtQ3VydmVTZWdtZW50cyx1PWVbbl0uc3VidHJhY3QoZVtoXSksYz1lW2xdLnN1YnRyYWN0KGVbaF0pLGY9dS5sZW5ndGhTcXVhcmVkLGQ9Yy5sZW5ndGhTcXVhcmVkLHA9MyphLTEsbT0oMyphKzEpJSh0aGlzLm51bUNvbnRyb2xWZXJ0aWNlcy0xKTtpZihmPjAmJmQ+MCl7bGV0IF89KGYrZCkvOCx2PWMuZGl2KGQpLnN1YnRyYWN0KHUuZGl2KGYpKTt2Lm5vcm1hbGl6ZSgpLHY9di5tdWwoXyksc1twXT1lW2hdLnN1YnRyYWN0KHYpLHNbbV09ZVtoXS5hZGQodil9ZWxzZSBzW3BdPWVbaF0sc1ttXT1lW2hdfWJyZWFrfX19c2V0Q29udHJvbFZlcnRpY2VzKGUsdCl7bGV0IHI9ZS5sZW5ndGg7cjw9MHx8dD09MCYmcjw0fHx0PT0xJiZyPDd8fChyLTEpJTM9PTAmJih0aGlzLmNsZWFyKCksdGhpcy50eXBlPXQsdGhpcy5udW1Db250cm9sVmVydGljZXM9cix0aGlzLm51bUN1cnZlU2VnbWVudHM9KHItMSkvMyx0aGlzLmNvbnRyb2xWZXJ0aWNlcz1lKX1nZXRQb2ludChlKXtpZih0aGlzLnR5cGU9PTEpe2Zvcig7ZTwwOyllKz10aGlzLm51bUN1cnZlU2VnbWVudHM7Zm9yKDtlPnRoaXMubnVtQ3VydmVTZWdtZW50czspZS09dGhpcy5udW1DdXJ2ZVNlZ21lbnRzfWVsc2UgZT1zdC5jbGFtcGYoZSwwLHRoaXMubnVtQ3VydmVTZWdtZW50cyk7aWYoIShlPj0wKSYmZTw9dGhpcy5udW1DdXJ2ZVNlZ21lbnRzKXJldHVybjtsZXQgdD1NYXRoLmZsb29yKGUpO3Q+PXRoaXMubnVtQ3VydmVTZWdtZW50cyYmKHQ9dGhpcy5udW1DdXJ2ZVNlZ21lbnRzLTEpO2xldCByPVtdLHM9dGhpcy5jb250cm9sVmVydGljZXM7cmV0dXJuIHJbMF09c1szKnQrMF0sclsxXT1zWzMqdCsxXSxyWzJdPXNbMyp0KzJdLHJbM109c1szKnQrM10sbmV3IGNhKHIpLmdldFBvaW50KGUtdCl9Z2V0UG9pbnROb3JtKGUpe3JldHVybiB0aGlzLmdldFBvaW50KGUqdGhpcy5udW1DdXJ2ZVNlZ21lbnRzKX1nZXRUYW5nZW50KGUpe2lmKHRoaXMudHlwZT09MSl7Zm9yKDtlPDA7KWUrPXRoaXMubnVtQ3VydmVTZWdtZW50cztmb3IoO2U+dGhpcy5udW1DdXJ2ZVNlZ21lbnRzOyllLT10aGlzLm51bUN1cnZlU2VnbWVudHN9ZWxzZSBlPXN0LmNsYW1wZihlLDAsdGhpcy5udW1DdXJ2ZVNlZ21lbnRzKTtpZighKGU+PTApJiZlPD10aGlzLm51bUN1cnZlU2VnbWVudHMpcmV0dXJuO2xldCB0PU1hdGguZmxvb3IoZSk7dD49dGhpcy5udW1DdXJ2ZVNlZ21lbnRzJiYodD10aGlzLm51bUN1cnZlU2VnbWVudHMtMSk7bGV0IHI9dGhpcy5jb250cm9sVmVydGljZXMscz1bXTtyZXR1cm4gc1swXT1yWzMqdCswXSxzWzFdPXJbMyp0KzFdLHNbMl09clszKnQrMl0sc1szXT1yWzMqdCszXSxuZXcgY2EocykuZ2V0VGFuZ2VudChlLXQpfWdldFRhbmdlbnROb3JtKGUpe3JldHVybiB0aGlzLmdldFRhbmdlbnQoZSp0aGlzLm51bUN1cnZlU2VnbWVudHMpfWNvbXB1dGVDbG9zZXN0UGFyYW0oZSx0KXtsZXQgcj1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixzPTAsYT1bXSxuPW5ldyBjYShhKTtmb3IobGV0IGw9MDtsPHRoaXMuY29udHJvbFZlcnRpY2VzLmxlbmd0aC0xO2wrPTMpe2ZvcihsZXQgZj0wO2Y8NDtmKyspYVtmXT10aGlzLmNvbnRyb2xWZXJ0aWNlc1tsK2ZdO24uc2V0Q29udHJvbFZlcnRpY2VzKGEpO2xldCBoPW4uZ2V0Q2xvc2VzdFBhcmFtKGUsdCksYz1uLmdldFBvaW50KGgpLnN1YnRyYWN0KGUpLmxlbmd0aFNxdWFyZWQ7YzxyJiYocj1jLHM9bC8zK2gpfXJldHVybiBzfWNvbXB1dGVDbG9zZXN0Tm9ybVBhcmFtKGUsdCl7cmV0dXJuIHRoaXMuY29tcHV0ZUNsb3Nlc3RQYXJhbShlLHQqdGhpcy5udW1DdXJ2ZVNlZ21lbnRzKX19dmFyIERmPShpPT4oaVtpLmtQYXJ0aWNsZVN5c3RlbUNsYW1wVmVsb2NpdHlDdXJ2ZUlkPTMyMjM3NjUwM109XCJrUGFydGljbGVTeXN0ZW1DbGFtcFZlbG9jaXR5Q3VydmVJZFwiLGlbaS5rUGFydGljbGVTeXN0ZW1Gb3JjZUN1cnZlSWQ9MzA2NTgxMzA3XT1cImtQYXJ0aWNsZVN5c3RlbUZvcmNlQ3VydmVJZFwiLGlbaS5rUGFydGljbGVTeXN0ZW1Sb3RhdGlvbkN1cnZlSWQ9MTc5MzkzNDYzOF09XCJrUGFydGljbGVTeXN0ZW1Sb3RhdGlvbkN1cnZlSWRcIixpW2kua1BhcnRpY2xlU3lzdGVtUm90YXRpb25CeVNwZWVkQ3VydmVJZD0zNzM3NDMxNzEzXT1cImtQYXJ0aWNsZVN5c3RlbVJvdGF0aW9uQnlTcGVlZEN1cnZlSWRcIixpW2kua1BhcnRpY2xlU3lzdGVtU3RhcnRTcGVlZEN1cnZlSWQ9MjUyNzc0MzQ1OV09XCJrUGFydGljbGVTeXN0ZW1TdGFydFNwZWVkQ3VydmVJZFwiLGlbaS5rUGFydGljbGVTeXN0ZW1TaXplQ3VydmVJZD0yMzY4NTA0ODgxXT1cImtQYXJ0aWNsZVN5c3RlbVNpemVDdXJ2ZUlkXCIsaVtpLmtQYXJ0aWNsZVN5c3RlbVNpemVCeVNwZWVkQ3VydmVJZD00MDg1NjEyMzk5XT1cImtQYXJ0aWNsZVN5c3RlbVNpemVCeVNwZWVkQ3VydmVJZFwiLGlbaS5rUGFydGljbGVTeXN0ZW1WZWxvY2l0eUN1cnZlSWQ9Mzc3NDYwMTI2OF09XCJrUGFydGljbGVTeXN0ZW1WZWxvY2l0eUN1cnZlSWRcIixpW2kua1BhcnRpY2xlU3lzdGVtVVZDdXJ2ZUlkPTMyNjM3MDY5MV09XCJrUGFydGljbGVTeXN0ZW1VVkN1cnZlSWRcIixpW2kua1BhcnRpY2xlU3lzdGVtQ29sb3JHcmFkaWVudElkPTE0OTQ5OTA5NDBdPVwia1BhcnRpY2xlU3lzdGVtQ29sb3JHcmFkaWVudElkXCIsaVtpLmtQYXJ0aWNsZVN5c3RlbUNvbG9yQnlWZWxvY2l0eUdyYWRpZW50SWQ9MTA4OTE4MTE1Nl09XCJrUGFydGljbGVTeXN0ZW1Db2xvckJ5VmVsb2NpdHlHcmFkaWVudElkXCIsaVtpLmtQYXJ0aWNsZVN5c3RlbU1lc2hTZWxlY3Rpb25JZD0zMTU5NTEwNjIzXT1cImtQYXJ0aWNsZVN5c3RlbU1lc2hTZWxlY3Rpb25JZFwiLGlbaS5rUGFydGljbGVTeXN0ZW1VVlJvd1NlbGVjdGlvbklkPTI5NDEyNjM5NDBdPVwia1BhcnRpY2xlU3lzdGVtVVZSb3dTZWxlY3Rpb25JZFwiLGkpKShEZnx8e30pO2NvbnN0IF9tPTMuMTQxNTkyNjUzNTg5NzkzO2NsYXNzIHhte31mdW5jdGlvbiBQZihpLGUsdCl7bGV0IHI9LjMzMzMzMzMzMzMzMzMzMzMscz0uNSxhPWkqcixuPWEqYSxoPW4qYS1hKmUqcyt0KnMsdT0tbitlKnIsYz11KnUqdSxmPWMraCpoO2lmKGY+PTApe2xldCBtPU1hdGguc3FydChmKS1oO3JldHVybiBtPW0+MD9NYXRoLnBvdyhtLHIpOi1NYXRoLnBvdygtbSxyKSwtYS11L20rbX1sZXQgZD1NYXRoLnNxcnQoLWMpLHA9TWF0aC5hY29zKC1oL2QpO3JldHVybiBkPU1hdGgucG93KGQsciksZD1kLXUvZCxwPS1hK2QqTWF0aC5jb3MocCpyKSxwfWZ1bmN0aW9uIGZhKGksZSx0LHIpe2xldCBzPTFlLTU7aWYoTWF0aC5hYnMoaSk8cylyZXR1cm4gTWF0aC5hYnMoZSk+cz8oci5yMD0tdC9lLDEpOjA7bGV0IGE9ZSplLTQqaSp0O2lmKGE8MClyZXR1cm4gMDtsZXQgbj0uNS9pLGw9TWF0aC5zcXJ0KGEpO3JldHVybiByLnIwPShsLWUpKm4sci5yMT0oLWwtZSkqbiwyfWZ1bmN0aW9uIFJmKGksZSx0LHIscyl7bGV0IGE9MDtpZihNYXRoLmFicyhlKT49MWUtNCl7bGV0IG49dC9lLGw9ci9lLGg9cy9lO2lbMF09UGYobixsLGgpLGErKztsZXQgdT1lLGM9dCtlKmlbMF0sZj1yK3QqaVswXStlKmlbMF0qaVswXTthKz1mYSh1LGMsZix7cjA6aVsxXSxyMTppWzJdfSl9ZWxzZSBhKz1mYSh0LHIscyx7cjA6aVsxXSxyMTppWzJdfSk7cmV0dXJuIGF9Y2xhc3MganR7Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJjb2VmZlwiLFtdKX1zdGF0aWMgRXZhbFNlZ21lbnQoZSx0KXtyZXR1cm4gZSooZSooZSp0WzBdK3RbMV0pK3RbMl0pK3RbM119fWNvbnN0IHdyPWNsYXNze2NvbnN0cnVjdG9yKCl7byh0aGlzLFwic2VnbWVudHNcIixbXSksbyh0aGlzLFwiaW50ZWdyYXRpb25DYWNoZVwiLFtdKSxvKHRoaXMsXCJkb3VibGVJbnRlZ3JhdGlvbkNhY2hlXCIsW10pLG8odGhpcyxcInRpbWVzXCIsW10pLG8odGhpcyxcInNlZ21lbnRDb3VudFwiKSx0aGlzLnNlZ21lbnRzW3dyLmtNYXhOdW1TZWdtZW50c109bmV3IGp0LHRoaXMuaW50ZWdyYXRpb25DYWNoZVt3ci5rTWF4TnVtU2VnbWVudHNdPTAsdGhpcy5kb3VibGVJbnRlZ3JhdGlvbkNhY2hlW3dyLmtNYXhOdW1TZWdtZW50c109MCx0aGlzLnRpbWVzW3dyLmtNYXhOdW1TZWdtZW50c109MH1jYWxjdWxhdGVNaW5NYXgoaSxlKXtpLng9TWF0aC5taW4oaS54LGUpLGkueT1NYXRoLm1heChpLnksZSl9ZmluZE1pbk1heERvdWJsZUludGVncmF0ZWQoKXtsZXQgaT1aLlpFUk8uY2xvbmUoKSxlPTIwLHQ9MS9lLHI9dDtmb3IobGV0IHM9MDtzPGU7cysrKXRoaXMuY2FsY3VsYXRlTWluTWF4KGksdGhpcy5ldmFsdWF0ZURvdWJsZUludGVncmF0ZWQocikpLHIrPXQ7cmV0dXJuIGl9ZmluZE1pbk1heEludGVncmF0ZWQoKXtsZXQgaT1aLlpFUk8uY2xvbmUoKSxlPVtdLHQ9W107Zm9yKGxldCByPTA7cjx0aGlzLnNlZ21lbnRDb3VudDtyKyspe2xldCBzPTQqdGhpcy5zZWdtZW50c1tyXS5jb2VmZlswXSxhPTMqdGhpcy5zZWdtZW50c1tyXS5jb2VmZlsxXSxuPTIqdGhpcy5zZWdtZW50c1tyXS5jb2VmZlsyXSxsPTEqdGhpcy5zZWdtZW50c1tyXS5jb2VmZlszXSxoPVtdLHU9UmYoaCxzLGEsbixsKTtmb3IobGV0IGM9MDtjPHU7YysrKXtsZXQgZj1oW2NdK2Vbcl07Zj49ZVtyXSYmZjx0W3JdJiZ0aGlzLmNhbGN1bGF0ZU1pbk1heChpLHRoaXMuZXZhbHVhdGVJbnRlZ3JhdGVkKGYpKX10aGlzLmNhbGN1bGF0ZU1pbk1heChpLHRoaXMuZXZhbHVhdGVJbnRlZ3JhdGVkKHRbcl0pKSx0aGlzLnRpbWVzW3JdfXJldHVybiBpfWdlbmVyYXRlSW50ZWdyYXRpb25DYWNoZShpKXtpLmludGVncmF0aW9uQ2FjaGVbMF09MDtsZXQgZT1pLnRpbWVzWzBdLHQ9MDtmb3IobGV0IHI9MTtyPGkuc2VnbWVudENvdW50O3IrKyl7bGV0IHM9aS5zZWdtZW50c1tyLTFdLmNvZWZmO3BuKHMpO2xldCBhPWUtdDtpLmludGVncmF0aW9uQ2FjaGVbcl09aS5pbnRlZ3JhdGlvbkNhY2hlW3ItMV0ranQuRXZhbFNlZ21lbnQoYSxzKSphLHQ9ZSxlPWkudGltZXNbcl19fWdlbmVyYXRlRG91YmxlSW50ZWdyYXRpb25DYWNoZShpKXtsZXQgZT0wLHQ9MDtmb3IobGV0IHI9MDtyPGkuc2VnbWVudENvdW50O3IrKyl7aS5kb3VibGVJbnRlZ3JhdGlvbkNhY2hlW3JdPWU7bGV0IHM9aS50aW1lc1tyXS10O3M9TWF0aC5tYXgocywwKSxlKz1qdC5FdmFsU2VnbWVudChzLGkuc2VnbWVudHNbcl0uY29lZmYpKnMqcytpLmludGVncmF0aW9uQ2FjaGVbcl0qcyx0PWkudGltZXNbcl19fWludGVncmF0ZSgpe3RoaXMuZ2VuZXJhdGVJbnRlZ3JhdGlvbkNhY2hlKHRoaXMpO2ZvcihsZXQgaT0wO2k8dGhpcy5zZWdtZW50Q291bnQ7aSsrKXBuKHRoaXMuc2VnbWVudHNbaV0uY29lZmYpfWRvdWJsZUludGVncmF0ZSgpe3RoaXMuZ2VuZXJhdGVJbnRlZ3JhdGlvbkNhY2hlKHRoaXMpO2ZvcihsZXQgaT0wO2k8dGhpcy5zZWdtZW50Q291bnQ7aSsrKUxmKHRoaXMuc2VnbWVudHNbaV0uY29lZmYpO3RoaXMuZ2VuZXJhdGVEb3VibGVJbnRlZ3JhdGlvbkNhY2hlKHRoaXMpfXN0YXRpYyBpc1ZhbGlkQ3VydmUoaSl7bGV0IGU9aS5nZXRLZXlDb3VudCgpLHQ9ZS0xO3JldHVybiBpLmdldEtleSgwKS50aW1lIT0wJiZ0KyssaS5nZXRLZXkoZS0xKS50aW1lIT0xJiZ0KyssdDw9d3Iua01heE51bVNlZ21lbnRzfWV2YWx1YXRlRG91YmxlSW50ZWdyYXRlZChpKXtsZXQgZT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5zZWdtZW50Q291bnQ7dCsrKXtpZihpPD10aGlzLnRpbWVzW3RdKXtsZXQgcj1pLWU7cmV0dXJuIHRoaXMuZG91YmxlSW50ZWdyYXRpb25DYWNoZVt0XSt0aGlzLmludGVncmF0aW9uQ2FjaGVbdF0qcitqdC5FdmFsU2VnbWVudChyLHRoaXMuc2VnbWVudHNbdF0uY29lZmYpKnIqcn1lPXRoaXMudGltZXNbdF19cmV0dXJuIDF9ZXZhbHVhdGVJbnRlZ3JhdGVkKGkpe2xldCBlPTA7Zm9yKGxldCB0PTA7dDx0aGlzLnNlZ21lbnRDb3VudDt0Kyspe2lmKGk8PXRoaXMudGltZXNbdF0pe2xldCByPWktZTtyZXR1cm4gdGhpcy5pbnRlZ3JhdGlvbkNhY2hlW3RdK2p0LkV2YWxTZWdtZW50KHIsdGhpcy5zZWdtZW50c1t0XS5jb2VmZikqcn1lPXRoaXMudGltZXNbdF19cmV0dXJuIDF9ZXZhbHVhdGUoaSl7bGV0IGU9MDtmb3IobGV0IHQ9MDt0PHRoaXMuc2VnbWVudENvdW50O3QrKyl7aWYoaTw9dGhpcy50aW1lc1t0XSlyZXR1cm4ganQuRXZhbFNlZ21lbnQoaS1lLHRoaXMuc2VnbWVudHNbdF0uY29lZmYpO2U9dGhpcy50aW1lc1t0XX1yZXR1cm4gMX1idWlsZEN1cnZlKGksZSl7bGV0IHQ9aS5nZXRLZXlDb3VudCgpO3RoaXMuc2VnbWVudENvdW50PTE7bGV0IHI9MS4wMTtpZih0aGlzLnNlZ21lbnRzLmxlbmd0aD0wLHRoaXMuaW50ZWdyYXRpb25DYWNoZS5sZW5ndGg9MCx0aGlzLmRvdWJsZUludGVncmF0aW9uQ2FjaGUubGVuZ3RoPTAsdGhpcy50aW1lcy5sZW5ndGg9MCx0aGlzLnRpbWVzWzBdPXIsdCE9MClpZih0PT0xKXRoaXMuc2VnbWVudHNbMF09bmV3IGp0LHRoaXMuc2VnbWVudHNbMF0uY29lZmZbM109aS5nZXRLZXkoMCkudmFsdWUqZTtlbHNle3RoaXMuc2VnbWVudENvdW50PXQtMTtsZXQgcz0wO2kuZ2V0S2V5KDApLnRpbWUhPTAmJih0aGlzLnNlZ21lbnRzWzBdLmNvZWZmWzNdPWkuZ2V0S2V5KDApLnZhbHVlLHRoaXMudGltZXNbMF09aS5nZXRLZXkoMCkudGltZSxzPTEpO2ZvcihsZXQgYT0wO2E8dGhpcy5zZWdtZW50Q291bnQ7YSsrKXtsZXQgbjtpLmNhbGN1bGF0ZUNhY2hlRGF0YShuLGEsYSsxLDApLHRoaXMuc2VnbWVudHNbYStzXS5jb2VmZj1uLmNvZWZmLmNvbmNhdCgpLHRoaXMudGltZXNbYStzXT1pLmdldEtleShhKzEpLnRpbWV9dGhpcy5zZWdtZW50Q291bnQrPXMsaS5nZXRLZXkodC0xKS50aW1lIT0xJiYodGhpcy5zZWdtZW50c1t0aGlzLnNlZ21lbnRDb3VudF0uY29lZmZbM109aS5nZXRLZXkodC0xKS52YWx1ZSx0aGlzLnNlZ21lbnRDb3VudCsrKSx0aGlzLnRpbWVzW3RoaXMuc2VnbWVudENvdW50LTFdPXI7Zm9yKGxldCBhPTA7YTx0aGlzLnNlZ21lbnRDb3VudDthKyspdGhpcy5zZWdtZW50c1thXS5jb2VmZlswXSo9ZSx0aGlzLnNlZ21lbnRzW2FdLmNvZWZmWzFdKj1lLHRoaXMuc2VnbWVudHNbYV0uY29lZmZbMl0qPWUsdGhpcy5zZWdtZW50c1thXS5jb2VmZlszXSo9ZX1yZXR1cm4hMH19O2xldCBkYT13cjtvKGRhLFwia01heE51bVNlZ21lbnRzXCIsOCk7ZnVuY3Rpb24gTGYoaSl7aVswXS89MjAsaVsxXS89MTIsaVsyXS89NixpWzNdLz0yfWZ1bmN0aW9uIHBuKGkpe2lbMF0vPTQsaVsxXS89MyxpWzJdLz0yLGlbM10vPTF9dmFyIFVmPShpPT4oaVtpLmtFTVNjYWxhcj0wXT1cImtFTVNjYWxhclwiLGlbaS5rRU1PcHRpbWl6ZWQ9MV09XCJrRU1PcHRpbWl6ZWRcIixpW2kua0VNT3B0aW1pemVkTWluTWF4PTJdPVwia0VNT3B0aW1pemVkTWluTWF4XCIsaVtpLmtFTVNsb3c9M109XCJrRU1TbG93XCIsaSkpKFVmfHx7fSksT2Y9KGk9PihpW2kua01NQ1NjYWxhcj0wXT1cImtNTUNTY2FsYXJcIixpW2kua01NQ0N1cnZlPTFdPVwia01NQ0N1cnZlXCIsaVtpLmtNTUNUd29DdXJ2ZXM9Ml09XCJrTU1DVHdvQ3VydmVzXCIsaVtpLmtNTUNUd29Db25zdGFudHM9M109XCJrTU1DVHdvQ29uc3RhbnRzXCIsaSkpKE9mfHx7fSk7Y2xhc3Mgdm17Y29uc3RydWN0b3IoKXtvKHRoaXMsXCJtYXhcIiksbyh0aGlzLFwibWluXCIpfX1jbGFzcyB5bXtjb25zdHJ1Y3Rvcigpe28odGhpcyxcIm1heFwiKSxvKHRoaXMsXCJtaW5cIil9aW50ZWdyYXRlKCl7dGhpcy5tYXguaW50ZWdyYXRlKCksdGhpcy5taW4uaW50ZWdyYXRlKCl9ZG91YmxlSW50ZWdyYXRlKCl7dGhpcy5tYXguZG91YmxlSW50ZWdyYXRlKCksdGhpcy5taW4uZG91YmxlSW50ZWdyYXRlKCl9ZmluZE1pbk1heEludGVncmF0ZWQoKXtyZXR1cm4gbnVsbH1maW5kTWluTWF4RG91YmxlSW50ZWdyYXRlZCgpe3JldHVybiBudWxsfX1jbGFzcyBOZntjb25zdHJ1Y3RvcihlPTEpe28odGhpcyxcIm1pbk1heFN0YXRlXCIpLG8odGhpcyxcIm1pbkN1cnZlXCIpLG8odGhpcyxcIm1heEN1cnZlXCIpLG8odGhpcyxcIl9zY2FsYXJcIiwxKSxvKHRoaXMsXCJfbWluU2NhbGFyXCIpLHRoaXMuX3NjYWxhcj1lLHRoaXMubWluTWF4U3RhdGU9MCx0aGlzLm1pbkN1cnZlPW5ldyBhYSx0aGlzLm1heEN1cnZlPW5ldyBhYX1zZXRTY2FsYXIoZSl7dGhpcy5fc2NhbGFyPWV9Z2V0U2NhbGFyKCl7cmV0dXJuIHRoaXMuX3NjYWxhcn1zdGF0aWMgZXZhbHVhdGVTbG93KGUsdCxyKXtsZXQgcz1lLm1heEN1cnZlLmdldFZhbHVlKHQpKmUuZ2V0U2NhbGFyKCk7cmV0dXJuIGUubWluTWF4U3RhdGU9PTI/SWkoZS5taW5DdXJ2ZS5nZXRWYWx1ZSh0KSplLmdldFNjYWxhcigpLHMscik6c31zdGF0aWMgZXZhbHVhdGUoZSx0LHI9MSl7aWYoZS5taW5NYXhTdGF0ZT09MClyZXR1cm4gZS5nZXRTY2FsYXIoKTtsZXQgcz1lLm1heEN1cnZlLmdldFZhbHVlKHQpKmUuZ2V0U2NhbGFyKCk7cmV0dXJuIGUubWluTWF4U3RhdGU9PTE/SWkoZS5taW5DdXJ2ZS5nZXRWYWx1ZSh0KSplLmdldFNjYWxhcigpLHMscik6ZS5taW5NYXhTdGF0ZT09Mz9JaShlLl9taW5TY2FsYXIsZS5fc2NhbGFyLHIpOmUubWluTWF4U3RhdGU9PTI/SWkoZS5taW5DdXJ2ZS5nZXRWYWx1ZSh0KSplLmdldFNjYWxhcigpLHMsMSpNYXRoLnJhbmRvbSgpKTp0aGlzLmV2YWx1YXRlU2xvdyhlLHQsMSl9dW5TZXJpYWxpemVkKGUpe3RoaXMubWluTWF4U3RhdGU9ZS5taW5NYXhTdGF0ZSx0aGlzLl9zY2FsYXI9ZS5zY2FsYXIsdGhpcy5fbWluU2NhbGFyPWUubWluU2NhbGFyLHRoaXMubWF4Q3VydmUudW5TZXJpYWxpemVkKGUubWF4Q3VydmUpLHRoaXMubWluQ3VydmUudW5TZXJpYWxpemVkKGUubWluQ3VydmUpfX1jbGFzcyBDbXtjb25zdHJ1Y3Rvcigpe28odGhpcyxcInZhbHVlXCIsMCksbyh0aGlzLFwibW9kZVwiLDApLG8odGhpcyxcInNwcmVhZFwiLDApLG8odGhpcyxcInNwZWVkXCIsbmV3IE5mKX11blNlcmlhbGl6ZWQoZSl7dGhpcy52YWx1ZT1lLnZhbHVlLHRoaXMubW9kZT1lLm1vZGUsdGhpcy5zcHJlYWQ9ZS5zcHJlYWQsdGhpcy5zcGVlZC51blNlcmlhbGl6ZWQoZS5zcGVlZCl9fWZ1bmN0aW9uIHdtKGksZSl7bGV0IHQ9ZGEuaXNWYWxpZEN1cnZlKGkubWF4KTtyZXR1cm4gZSE9MiYmZSE9Mz90OnQmJmRhLmlzVmFsaWRDdXJ2ZShpLm1pbil9ZnVuY3Rpb24gYm0oaSxlLHQscil7aS5tYXguYnVpbGRDdXJ2ZShlLm1heCx0KSxyIT0yJiZyIT0zP2kubWluLmJ1aWxkQ3VydmUoZS5tYXgsdCk6aS5taW4uYnVpbGRDdXJ2ZShlLm1pbix0KX1mdW5jdGlvbiBTbShpLGUpe2xldCB0PWUuZ2V0S2V5Q291bnQoKTtpZih0IT0wKWlmKHQ9PTEpcHMoaSxlLmdldEtleSgwKS52YWx1ZSk7ZWxzZXtsZXQgcj10LTE7cHMoaSxlLmdldEtleSgwKS52YWx1ZSk7Zm9yKGxldCBzPTA7czxyO3MrKyl7bGV0IGE9bmV3IGFuO2UuY2FsY3VsYXRlQ2FjaGVEYXRhKGEscyxzKzEsMCk7bGV0IG49MyphLmNvZWZmWzBdLGw9MiphLmNvZWZmWzFdLGg9MSphLmNvZWZmWzJdLHU9ZS5nZXRLZXkocykudGltZSxjPWUuZ2V0S2V5KHMrMSkudGltZSxmPVtdLGQ9ZmEobixsLGgse3IwOmZbMF0scjE6ZlsxXX0pO2ZvcihsZXQgcD0wO3A8ZDtwKyspZltwXT49MCYmZltwXSt1PGMmJnBzKGksanQuRXZhbFNlZ21lbnQoZltwXSxhLmNvZWZmKSk7cHMoaSxqdC5FdmFsU2VnbWVudChjLXUsYS5jb2VmZikpfX19ZnVuY3Rpb24gcHMoaSxlKXtpLng9TWF0aC5taW4oaS54LGUpLGkueT1NYXRoLm1heChpLnksZSl9Y2xhc3MgYm57Y29uc3RydWN0b3IoZSx0KXtvKHRoaXMsXCJwb2ludFwiLG5ldyBnKSxvKHRoaXMsXCJub3JtYWxcIixnLlVQKSxvKHRoaXMsXCJfdG1wVmVjQVwiLG5ldyBnKSx0aGlzLnBvaW50PWUsdGhpcy5ub3JtYWw9dH1jbG9uZSgpe3JldHVybiBuZXcgYm4odGhpcy5wb2ludC5jbG9uZSgpLHRoaXMubm9ybWFsLmNsb25lKCkpfWludGVyc2VjdHNMaW5lKGUsdCxyKXt2YXIgcz0tdGhpcy5ub3JtYWwuZG90UHJvZHVjdCh0aGlzLnBvaW50KSxhPXRoaXMubm9ybWFsLmRvdFByb2R1Y3QoZSkrcyxuPXRoaXMubm9ybWFsLmRvdFByb2R1Y3QodCkrcyxsPWEvKGEtbiksaD1sPj0wJiZsPD0xO3JldHVybiBoJiZyJiZyLmxlcnAoZSx0LGwpLGh9aW50ZXJzZWN0c1JheShlLHQpe3R8fCh0PXRoaXMuX3RtcFZlY0EpLHQuY29weSh0aGlzLnBvaW50KS5zdWJ0cmFjdChlLm9yaWdpbix0KTt2YXIgcj10aGlzLm5vcm1hbC5kb3RQcm9kdWN0KHQpL3RoaXMubm9ybWFsLmRvdFByb2R1Y3QoZS5kaXJlY3Rpb24pLHM9cj49MDtyZXR1cm4gcyYmdC5jb3B5RnJvbShlLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIocikuYWRkKGUub3JpZ2luLHQpLHN9fWZ1bmN0aW9uIEltKGksZSl7cmV0dXJuIE1hdGgucmFuZG9tKCkqZStNYXRoLnJhbmRvbSgpKmkrKGUtaSkqTWF0aC5yYW5kb20oKX1mdW5jdGlvbiBFbShpLGUsdCl7bGV0IHI9dCpNYXRoLnJhbmRvbSgpO3JldHVybiBNYXRoLnJhbmRvbSgpKmUqcitNYXRoLnJhbmRvbSgpKmkqcisoZS1pKSpNYXRoLnJhbmRvbSgpKnJ9ZnVuY3Rpb24gRmYoaSxlLHQpe2xldCByPTAscz0wO2Zvcig7cj09PTA7KXI9TWF0aC5yYW5kb20oKTtmb3IoO3M9PT0wOylzPU1hdGgucmFuZG9tKCk7bGV0IGE9TWF0aC5zcXJ0KC0yKk1hdGgubG9nKHIpKSpNYXRoLmNvcygyKk1hdGguUEkqcyk7cmV0dXJuIGE9YS8xMCsuNSwoYT4xfHxhPDApJiYoYT1GZihpLGUsdCkpLGE9TWF0aC5wb3coYSx0KSxhKj1lLWksYSs9aSxhfWZ1bmN0aW9uIHp0KGkpe3JldHVybiBpPjA/TWF0aC5mbG9vcihpKTpNYXRoLmZsb29yKGkpLTF9bGV0IEo9WzE1MSwxNjAsMTM3LDkxLDkwLDE1LDEzMSwxMywyMDEsOTUsOTYsNTMsMTk0LDIzMyw3LDIyNSwxNDAsMzYsMTAzLDMwLDY5LDE0Miw4LDk5LDM3LDI0MCwyMSwxMCwyMywxOTAsNiwxNDgsMjQ3LDEyMCwyMzQsNzUsMCwyNiwxOTcsNjIsOTQsMjUyLDIxOSwyMDMsMTE3LDM1LDExLDMyLDU3LDE3NywzMyw4OCwyMzcsMTQ5LDU2LDg3LDE3NCwyMCwxMjUsMTM2LDE3MSwxNjgsNjgsMTc1LDc0LDE2NSw3MSwxMzQsMTM5LDQ4LDI3LDE2Niw3NywxNDYsMTU4LDIzMSw4MywxMTEsMjI5LDEyMiw2MCwyMTEsMTMzLDIzMCwyMjAsMTA1LDkyLDQxLDU1LDQ2LDI0NSw0MCwyNDQsMTAyLDE0Myw1NCw2NSwyNSw2MywxNjEsMSwyMTYsODAsNzMsMjA5LDc2LDEzMiwxODcsMjA4LDg5LDE4LDE2OSwyMDAsMTk2LDEzNSwxMzAsMTE2LDE4OCwxNTksODYsMTY0LDEwMCwxMDksMTk4LDE3MywxODYsMyw2NCw1MiwyMTcsMjI2LDI1MCwxMjQsMTIzLDUsMjAyLDM4LDE0NywxMTgsMTI2LDI1NSw4Miw4NSwyMTIsMjA3LDIwNiw1OSwyMjcsNDcsMTYsNTgsMTcsMTgyLDE4OSwyOCw0MiwyMjMsMTgzLDE3MCwyMTMsMTE5LDI0OCwxNTIsMiw0NCwxNTQsMTYzLDcwLDIyMSwxNTMsMTAxLDE1NSwxNjcsNDMsMTcyLDksMTI5LDIyLDM5LDI1MywxOSw5OCwxMDgsMTEwLDc5LDExMywyMjQsMjMyLDE3OCwxODUsMTEyLDEwNCwyMTgsMjQ2LDk3LDIyOCwyNTEsMzQsMjQyLDE5MywyMzgsMjEwLDE0NCwxMiwxOTEsMTc5LDE2MiwyNDEsODEsNTEsMTQ1LDIzNSwyNDksMTQsMjM5LDEwNyw0OSwxOTIsMjE0LDMxLDE4MSwxOTksMTA2LDE1NywxODQsODQsMjA0LDE3NiwxMTUsMTIxLDUwLDQ1LDEyNyw0LDE1MCwyNTQsMTM4LDIzNiwyMDUsOTMsMjIyLDExNCw2NywyOSwyNCw3MiwyNDMsMTQxLDEyOCwxOTUsNzgsNjYsMjE1LDYxLDE1NiwxODAsMTUxLDE2MCwxMzcsOTEsOTAsMTUsMTMxLDEzLDIwMSw5NSw5Niw1MywxOTQsMjMzLDcsMjI1LDE0MCwzNiwxMDMsMzAsNjksMTQyLDgsOTksMzcsMjQwLDIxLDEwLDIzLDE5MCw2LDE0OCwyNDcsMTIwLDIzNCw3NSwwLDI2LDE5Nyw2Miw5NCwyNTIsMjE5LDIwMywxMTcsMzUsMTEsMzIsNTcsMTc3LDMzLDg4LDIzNywxNDksNTYsODcsMTc0LDIwLDEyNSwxMzYsMTcxLDE2OCw2OCwxNzUsNzQsMTY1LDcxLDEzNCwxMzksNDgsMjcsMTY2LDc3LDE0NiwxNTgsMjMxLDgzLDExMSwyMjksMTIyLDYwLDIxMSwxMzMsMjMwLDIyMCwxMDUsOTIsNDEsNTUsNDYsMjQ1LDQwLDI0NCwxMDIsMTQzLDU0LDY1LDI1LDYzLDE2MSwxLDIxNiw4MCw3MywyMDksNzYsMTMyLDE4NywyMDgsODksMTgsMTY5LDIwMCwxOTYsMTM1LDEzMCwxMTYsMTg4LDE1OSw4NiwxNjQsMTAwLDEwOSwxOTgsMTczLDE4NiwzLDY0LDUyLDIxNywyMjYsMjUwLDEyNCwxMjMsNSwyMDIsMzgsMTQ3LDExOCwxMjYsMjU1LDgyLDg1LDIxMiwyMDcsMjA2LDU5LDIyNyw0NywxNiw1OCwxNywxODIsMTg5LDI4LDQyLDIyMywxODMsMTcwLDIxMywxMTksMjQ4LDE1MiwyLDQ0LDE1NCwxNjMsNzAsMjIxLDE1MywxMDEsMTU1LDE2Nyw0MywxNzIsOSwxMjksMjIsMzksMjUzLDE5LDk4LDEwOCwxMTAsNzksMTEzLDIyNCwyMzIsMTc4LDE4NSwxMTIsMTA0LDIxOCwyNDYsOTcsMjI4LDI1MSwzNCwyNDIsMTkzLDIzOCwyMTAsMTQ0LDEyLDE5MSwxNzksMTYyLDI0MSw4MSw1MSwxNDUsMjM1LDI0OSwxNCwyMzksMTA3LDQ5LDE5MiwyMTQsMzEsMTgxLDE5OSwxMDYsMTU3LDE4NCw4NCwyMDQsMTc2LDExNSwxMjEsNTAsNDUsMTI3LDQsMTUwLDI1NCwxMzgsMjM2LDIwNSw5MywyMjIsMTE0LDY3LDI5LDI0LDcyLDI0MywxNDEsMTI4LDE5NSw3OCw2NiwyMTUsNjEsMTU2LDE4MF07ZnVuY3Rpb24gbW4oaSxlKXtsZXQgdD1pJjE1LHI9MSsodCY3KTtyZXR1cm4gdCY4JiYocj0tciksciplfWZ1bmN0aW9uIGdhKGksZSx0KXtsZXQgcj1pJjcscz1yPDQ/ZTp0LGE9cjw0P3Q6ZTtyZXR1cm4ociYxPy1zOnMpKyhyJjI/LTIqYToyKmEpfWZ1bmN0aW9uIG1zKGksZSx0LHIpe2xldCBzPWkmMTUsYT1zPDg/ZTp0LG49czw0P3Q6cz09MTJ8fHM9PTE0P2U6cjtyZXR1cm4ocyYxPy1hOmEpKyhzJjI/LW46bil9ZnVuY3Rpb24gYnIoaSxlLHQscixzKXtsZXQgYT1pJjMxLG49YTwyND9lOnQsbD1hPDE2P3Q6cixoPWE8OD9yOnM7cmV0dXJuKGEmMT8tbjpuKSsoYSYyPy1sOmwpKyhhJjQ/LWg6aCl9bGV0IG10PVtbMCwxLDIsM10sWzAsMSwzLDJdLFswLDAsMCwwXSxbMCwyLDMsMV0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzEsMiwzLDBdLFswLDIsMSwzXSxbMCwwLDAsMF0sWzAsMywxLDJdLFswLDMsMiwxXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMSwzLDIsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMSwyLDAsM10sWzAsMCwwLDBdLFsxLDMsMCwyXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMiwzLDAsMV0sWzIsMywxLDBdLFsxLDAsMiwzXSxbMSwwLDMsMl0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzIsMCwzLDFdLFswLDAsMCwwXSxbMiwxLDMsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMiwwLDEsM10sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzMsMCwxLDJdLFszLDAsMiwxXSxbMCwwLDAsMF0sWzMsMSwyLDBdLFsyLDEsMCwzXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMywxLDAsMl0sWzAsMCwwLDBdLFszLDIsMCwxXSxbMywyLDEsMF1dO2Z1bmN0aW9uIEJtKGkpe2xldCBlPXp0KGkpLHQ9ZSsxLHI9aS1lLHM9ci0xLGEsbixsPTEtcipyO2wqPWwsYT1sKmwqbW4oSltlJjI1NV0scik7bGV0IGg9MS1zKnM7cmV0dXJuIGgqPWgsbj1oKmgqbW4oSlt0JjI1NV0scyksLjI1KihhK24pfWZ1bmN0aW9uIFRtKGksZSl7Y29uc3QgdD0uMzY2MDI1NDAzLHI9LjIxMTMyNDg2NTtsZXQgcyxhLG4sbD0oaStlKSp0LGg9aStsLHU9ZStsLGM9enQoaCksZj16dCh1KSxkPShjK2YpKnIscD1jLWQsbT1mLWQsXz1pLXAsdj1lLW0seSxDO18+dj8oeT0xLEM9MCk6KHk9MCxDPTEpO2xldCBCPV8teStyLFQ9di1DK3IsTT1fLTErMipyLEQ9di0xKzIqcixQPWMmMjU1LEw9ZiYyNTUsST0uNS1fKl8tdip2O0k8MD9zPTA6KEkqPUkscz1JKkkqZ2EoSltQK0pbTF1dLF8sdikpO2xldCBPPS41LUIqQi1UKlQ7TzwwP2E9MDooTyo9TyxhPU8qTypnYShKW1AreStKW0wrQ11dLEIsVCkpO2xldCBrPS41LU0qTS1EKkQ7cmV0dXJuIGs8MD9uPTA6KGsqPWssbj1rKmsqZ2EoSltQKzErSltMKzFdXSxNLEQpKSw0MCoocythK24pfWZ1bmN0aW9uIE1tKGksZSx0KXtjb25zdCByPS4zMzMzMzMzMzMscz0uMTY2NjY2NjY3O2xldCBhLG4sbCxoLHU9KGkrZSt0KSpyLGM9aSt1LGY9ZSt1LGQ9dCt1LHA9enQoYyksbT16dChmKSxfPXp0KGQpLHY9KHArbStfKSpzLHk9cC12LEM9bS12LEI9Xy12LFQ9aS15LE09ZS1DLEQ9dC1CLFAsTCxJLE8sayxIO1Q+PU0/TT49RD8oUD0xLEw9MCxJPTAsTz0xLGs9MSxIPTApOlQ+PUQ/KFA9MSxMPTAsST0wLE89MSxrPTAsSD0xKTooUD0wLEw9MCxJPTEsTz0xLGs9MCxIPTEpOk08RD8oUD0wLEw9MCxJPTEsTz0wLGs9MSxIPTEpOlQ8RD8oUD0wLEw9MSxJPTAsTz0wLGs9MSxIPTEpOihQPTAsTD0xLEk9MCxPPTEsaz0xLEg9MCk7bGV0IFc9VC1QK3MsbmU9TS1MK3MsZmU9RC1JK3Msd2U9VC1PKzIqcyx6ZT1NLWsrMipzLFJlPUQtSCsyKnMsdWU9VC0xKzMqcyxkZT1NLTErMypzLEdlPUQtMSszKnMsb3Q9cCYyNTUsbnQ9bSYyNTUsRXQ9XyYyNTUsX3Q9LjYtVCpULU0qTS1EKkQ7X3Q8MD9hPTA6KF90Kj1fdCxhPV90Kl90Km1zKEpbb3QrSltudCtKW0V0XV1dLFQsTSxEKSk7bGV0IHh0PS42LVcqVy1uZSpuZS1mZSpmZTt4dDwwP249MDooeHQqPXh0LG49eHQqeHQqbXMoSltvdCtQK0pbbnQrTCtKW0V0K0ldXV0sVyxuZSxmZSkpO2xldCBxdD0uNi13ZSp3ZS16ZSp6ZS1SZSpSZTtxdDwwP2w9MDoocXQqPXF0LGw9cXQqcXQqbXMoSltvdCtPK0pbbnQraytKW0V0K0hdXV0sd2UsemUsUmUpKTtsZXQgS3Q9LjYtdWUqdWUtZGUqZGUtR2UqR2U7cmV0dXJuIEt0PDA/aD0wOihLdCo9S3QsaD1LdCpLdCptcyhKW290KzErSltudCsxK0pbRXQrMV1dXSx1ZSxkZSxHZSkpLDMyKihhK24rbCtoKX1mdW5jdGlvbiBEbShpLGUsdCxyKXtjb25zdCBzPS4zMDkwMTY5OTQsYT0uMTM4MTk2NjAxO2xldCBuLGwsaCx1LGMsZj0oaStlK3QrcikqcyxkPWkrZixwPWUrZixtPXQrZixfPXIrZix2PXp0KGQpLHk9enQocCksQz16dChtKSxCPXp0KF8pLFQ9KHYreStDK0IpKmEsTT12LVQsRD15LVQsUD1DLVQsTD1CLVQsST1pLU0sTz1lLUQsaz10LVAsSD1yLUwsVz1JPk8/MzI6MCxuZT1JPms/MTY6MCxmZT1PPms/ODowLHdlPUk+SD80OjAsemU9Tz5IPzI6MCxSZT1rPkg/MTowLHVlPVcrbmUrZmUrd2UremUrUmUsZGUsR2Usb3QsbnQsRXQsX3QseHQscXQsS3QsRWEsQmEsVGE7ZGU9bXRbdWVdWzBdPj0zPzE6MCxHZT1tdFt1ZV1bMV0+PTM/MTowLG90PW10W3VlXVsyXT49Mz8xOjAsbnQ9bXRbdWVdWzNdPj0zPzE6MCxFdD1tdFt1ZV1bMF0+PTI/MTowLF90PW10W3VlXVsxXT49Mj8xOjAseHQ9bXRbdWVdWzJdPj0yPzE6MCxxdD1tdFt1ZV1bM10+PTI/MTowLEt0PW10W3VlXVswXT49MT8xOjAsRWE9bXRbdWVdWzFdPj0xPzE6MCxCYT1tdFt1ZV1bMl0+PTE/MTowLFRhPW10W3VlXVszXT49MT8xOjA7bGV0IE1hPUktZGUrYSxEYT1PLUdlK2EsUGE9ay1vdCthLFJhPUgtbnQrYSxMYT1JLUV0KzIqYSxVYT1PLV90KzIqYSxPYT1rLXh0KzIqYSxOYT1ILXF0KzIqYSxGYT1JLUt0KzMqYSxrYT1PLUVhKzMqYSx6YT1rLUJhKzMqYSxHYT1ILVRhKzMqYSxRYT1JLTErNCphLFZhPU8tMSs0KmEsSGE9ay0xKzQqYSxZYT1ILTErNCphLFNyPXYmMjU1LElyPXkmMjU1LEVyPUMmMjU1LEJyPUImMjU1LFRyPS42LUkqSS1PKk8tayprLUgqSDtUcjwwP249MDooVHIqPVRyLG49VHIqVHIqYnIoSltTcitKW0lyK0pbRXIrSltCcl1dXV0sSSxPLGssSCkpO2xldCBNcj0uNi1NYSpNYS1EYSpEYS1QYSpQYS1SYSpSYTtNcjwwP2w9MDooTXIqPU1yLGw9TXIqTXIqYnIoSltTcitkZStKW0lyK0dlK0pbRXIrb3QrSltCcitudF1dXV0sTWEsRGEsUGEsUmEpKTtsZXQgRHI9LjYtTGEqTGEtVWEqVWEtT2EqT2EtTmEqTmE7RHI8MD9oPTA6KERyKj1EcixoPURyKkRyKmJyKEpbU3IrRXQrSltJcitfdCtKW0VyK3h0K0pbQnIrcXRdXV1dLExhLFVhLE9hLE5hKSk7bGV0IFByPS42LUZhKkZhLWthKmthLXphKnphLUdhKkdhO1ByPDA/dT0wOihQcio9UHIsdT1QcipQcipicihKW1NyK0t0K0pbSXIrRWErSltFcitCYStKW0JyK1RhXV1dXSxGYSxrYSx6YSxHYSkpO2xldCBScj0uNi1RYSpRYS1WYSpWYS1IYSpIYS1ZYSpZYTtyZXR1cm4gUnI8MD9jPTA6KFJyKj1ScixjPVJyKlJyKmJyKEpbU3IrMStKW0lyKzErSltFcisxK0pbQnIrMV1dXV0sUWEsVmEsSGEsWWEpKSwyNyoobitsK2grdStjKX1jb25zdCBrZj1jbGFzcyBleHRlbmRzIFp7Y29uc3RydWN0b3IoaT0wLGU9MCl7c3VwZXIoaSxlKSxvKHRoaXMsXCJ1XCIsMCksbyh0aGlzLFwidlwiLDApLHRoaXMudT1pLHRoaXMudj1lfWxlbmd0aCgpe3JldHVybiAwfX07bGV0IHpmPWtmO28oemYsXCJ1dl8wXCIsbmV3IGtmKTtjbGFzcyBQbSBleHRlbmRzIHR0e2NvbnN0cnVjdG9yKGU9MSx0PTEscj0xLHM9OCxhPTgsbj0hMSxsPTAsaD1NYXRoLlBJKjIpe3N1cGVyKCksbyh0aGlzLFwicmFkaXVzVG9wXCIpLG8odGhpcyxcInJhZGl1c0JvdHRvbVwiKSxvKHRoaXMsXCJoZWlnaHRcIiksbyh0aGlzLFwicmFkaWFsU2VnbWVudHNcIiksbyh0aGlzLFwiaGVpZ2h0U2VnbWVudHNcIiksbyh0aGlzLFwib3BlbkVuZGVkXCIpLG8odGhpcyxcInRoZXRhU3RhcnRcIiksbyh0aGlzLFwidGhldGFMZW5ndGhcIiksdGhpcy5yYWRpdXNUb3A9ZSx0aGlzLnJhZGl1c0JvdHRvbT10LHRoaXMuaGVpZ2h0PXIsdGhpcy5yYWRpYWxTZWdtZW50cz1zLHRoaXMuaGVpZ2h0U2VnbWVudHM9YSx0aGlzLm9wZW5FbmRlZD1uLHRoaXMudGhldGFTdGFydD1sLHRoaXMudGhldGFMZW5ndGg9aCx0aGlzLmluc3RhbmNlSUQ9UHQoKSx0aGlzLmJ1aWxkR2VvbWV0cnkoKX1hZGRHcm91cChlLHQscil7dGhpcy5hZGRTdWJHZW9tZXRyeSh7aW5kZXhTdGFydDplLGluZGV4Q291bnQ6dCx2ZXJ0ZXhTdGFydDplLGluZGV4OnJ9KX1idWlsZEdlb21ldHJ5KCl7Y29uc3QgZT10aGlzO3RoaXMucmFkaWFsU2VnbWVudHM9TWF0aC5mbG9vcih0aGlzLnJhZGlhbFNlZ21lbnRzKSx0aGlzLmhlaWdodFNlZ21lbnRzPU1hdGguZmxvb3IodGhpcy5oZWlnaHRTZWdtZW50cyk7Y29uc3QgdD1bXSxyPVtdLHM9W10sYT1bXTtsZXQgbj0wO2NvbnN0IGw9W10saD10aGlzLmhlaWdodC8yO2xldCB1PTA7bSgpLHRoaXMub3BlbkVuZGVkPT09ITEmJih0aGlzLnJhZGl1c1RvcD4wJiZfKCEwKSx0aGlzLnJhZGl1c0JvdHRvbT4wJiZfKCExKSk7bGV0IGM9bmV3IEZsb2F0MzJBcnJheSh0KSxmPW5ldyBGbG9hdDMyQXJyYXkociksZD1uZXcgRmxvYXQzMkFycmF5KHMpLHA9bmV3IFVpbnQxNkFycmF5KGEpO3RoaXMuc2V0QXR0cmlidXRlKFkucG9zaXRpb24sYyksdGhpcy5zZXRBdHRyaWJ1dGUoWS5ub3JtYWwsZiksdGhpcy5zZXRBdHRyaWJ1dGUoWS51dixkKSx0aGlzLnNldEF0dHJpYnV0ZShZLlRFWENPT1JEXzEsZCksdGhpcy5zZXRJbmRpY2VzKHApO2Z1bmN0aW9uIG0oKXtjb25zdCB2PW5ldyBnLHk9bmV3IGc7bGV0IEM9MDtjb25zdCBCPShlLnJhZGl1c0JvdHRvbS1lLnJhZGl1c1RvcCkvZS5oZWlnaHQ7Zm9yKGxldCBUPTA7VDw9ZS5oZWlnaHRTZWdtZW50cztUKyspe2NvbnN0IE09W10sRD1UL2UuaGVpZ2h0U2VnbWVudHMsUD1EKihlLnJhZGl1c0JvdHRvbS1lLnJhZGl1c1RvcCkrZS5yYWRpdXNUb3A7Zm9yKGxldCBMPTA7TDw9ZS5yYWRpYWxTZWdtZW50cztMKyspe2NvbnN0IEk9TC9lLnJhZGlhbFNlZ21lbnRzLE89SSplLnRoZXRhTGVuZ3RoK2UudGhldGFTdGFydCxrPU1hdGguc2luKE8pLEg9TWF0aC5jb3MoTyk7eS54PVAqayx5Lnk9LUQqZS5oZWlnaHQraCx5Lno9UCpILHQucHVzaCh5LngseS55LHkueiksdi5zZXQoayxCLEgpLm5vcm1hbGl6ZSgpLHIucHVzaCh2Lngsdi55LHYueikscy5wdXNoKEksMS1EKSxNLnB1c2gobisrKX1sLnB1c2goTSl9Zm9yKGxldCBUPTA7VDxlLnJhZGlhbFNlZ21lbnRzO1QrKylmb3IobGV0IE09MDtNPGUuaGVpZ2h0U2VnbWVudHM7TSsrKXtjb25zdCBEPWxbTV1bVF0sUD1sW00rMV1bVF0sTD1sW00rMV1bVCsxXSxJPWxbTV1bVCsxXTthLnB1c2goRCxQLEkpLGEucHVzaChQLEwsSSksQys9Nn1lLmFkZEdyb3VwKHUsQywwKSx1Kz1DfWZ1bmN0aW9uIF8odil7Y29uc3QgeT1uLEM9bmV3IFosQj1uZXcgZztsZXQgVD0wO2NvbnN0IE09dj09PSEwP2UucmFkaXVzVG9wOmUucmFkaXVzQm90dG9tLEQ9dj09PSEwPzE6LTE7Zm9yKGxldCBMPTE7TDw9ZS5yYWRpYWxTZWdtZW50cztMKyspdC5wdXNoKDAsaCpELDApLHIucHVzaCgwLEQsMCkscy5wdXNoKC41LC41KSxuKys7Y29uc3QgUD1uO2ZvcihsZXQgTD0wO0w8PWUucmFkaWFsU2VnbWVudHM7TCsrKXtjb25zdCBPPUwvZS5yYWRpYWxTZWdtZW50cyplLnRoZXRhTGVuZ3RoK2UudGhldGFTdGFydCxrPU1hdGguY29zKE8pLEg9TWF0aC5zaW4oTyk7Qi54PU0qSCxCLnk9aCpELEIuej1NKmssdC5wdXNoKEIueCxCLnksQi56KSxyLnB1c2goMCxELDApLEMueD1rKi41Ky41LEMueT1IKi41KkQrLjUscy5wdXNoKEMueCxDLnkpLG4rK31mb3IobGV0IEw9MDtMPGUucmFkaWFsU2VnbWVudHM7TCsrKXtjb25zdCBJPXkrTCxPPVArTDt2PT09ITA/YS5wdXNoKE8sTysxLEkpOmEucHVzaChPKzEsTyxJKSxUKz0zfWUuYWRkR3JvdXAodSxULHY9PT0hMD8xOjIpLHUrPVR9fX1jbGFzcyBSbSBleHRlbmRzIHR0e2NvbnN0cnVjdG9yKGU9LjQsdD0uMSxyPTMyLHM9MzIpe3N1cGVyKCksbyh0aGlzLFwicmFkaXVzXCIpLG8odGhpcyxcInR1YmVcIiksbyh0aGlzLFwicmFkaWFsU2VnbWVudHNcIiksbyh0aGlzLFwidHVidWxhclNlZ21lbnRzXCIpLHRoaXMucmFkaXVzPWUsdGhpcy50dWJlPXQsdGhpcy5yYWRpYWxTZWdtZW50cz1yLHRoaXMudHVidWxhclNlZ21lbnRzPXMsdGhpcy5pbml0VmVydGV4KCl9aW5pdFZlcnRleCgpe2NvbnN0IGU9MipNYXRoLlBJLHQ9dGhpcy5yYWRpdXMscj10aGlzLnR1YmUscz10aGlzLnJhZGlhbFNlZ21lbnRzLGE9dGhpcy50dWJ1bGFyU2VnbWVudHM7dGhpcy5ib3VuZHM9bmV3IEJlKGcuWkVSTy5jbG9uZSgpLG5ldyBnKHQqMixyKjIsdCoyKSk7dmFyIG49KHMrMSkqKGErMSk7bGV0IGw9bmV3IEZsb2F0MzJBcnJheShuKjMpLGg9bmV3IEZsb2F0MzJBcnJheShuKjMpLHU9bmV3IEZsb2F0MzJBcnJheShuKjIpLGM9bmV3IFVpbnQxNkFycmF5KHMqYSoyKjMpLGY9MCxkPTAscD0wLG09MDtmb3IobGV0IF89MDtfPD1zO18rKylmb3IobGV0IHY9MDt2PD1hO3YrKyl7Y29uc3QgeT12L2EsQz1fL3MsQj15KmUsVD1DKk1hdGguUEkqMjtpZihsW2YrK109KHQrcipNYXRoLmNvcyhUKSkqTWF0aC5zaW4oQiksbFtmKytdPXIqTWF0aC5zaW4oVCksbFtmKytdPSh0K3IqTWF0aC5jb3MoVCkpKk1hdGguY29zKEIpLGhbZCsrXT1NYXRoLnNpbihCKSpNYXRoLmNvcyhUKSxoW2QrK109TWF0aC5zaW4oVCksaFtkKytdPU1hdGguY29zKEIpKk1hdGguY29zKFQpLHVbcCsrXT15LHVbcCsrXT1DLHY8YSYmXzxzKXtjb25zdCBNPWErMSxEPU0qXyt2LFA9TSooXysxKSt2LEw9TSooXysxKSt2KzEsST1NKl8rdisxO2NbbSsrXT1ELGNbbSsrXT1JLGNbbSsrXT1QLGNbbSsrXT1JLGNbbSsrXT1MLGNbbSsrXT1QfX10aGlzLnNldEluZGljZXMoYyksdGhpcy5zZXRBdHRyaWJ1dGUoWS5wb3NpdGlvbixsKSx0aGlzLnNldEF0dHJpYnV0ZShZLm5vcm1hbCxoKSx0aGlzLnNldEF0dHJpYnV0ZShZLnV2LHUpLHRoaXMuc2V0QXR0cmlidXRlKFkuVEVYQ09PUkRfMSx1KSx0aGlzLmFkZFN1Ykdlb21ldHJ5KHtpbmRleFN0YXJ0OjAsaW5kZXhDb3VudDpjLmxlbmd0aCx2ZXJ0ZXhTdGFydDowLGluZGV4OjB9KX19Y2xhc3MgTG0gZXh0ZW5kcyBhdHtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGUsdCw2KSxvKHRoaXMsXCJ3aWR0aFwiLDQpLG8odGhpcyxcImhlaWdodFwiLDQpLG8odGhpcyxcImRlcHRoT3JBcnJheUxheWVyc1wiLDYpLG8odGhpcyxcInZpc2liaWxpdHlcIixHUFVTaGFkZXJTdGFnZS5WRVJURVh8R1BVU2hhZGVyU3RhZ2UuRlJBR01FTlR8R1BVU2hhZGVyU3RhZ2UuQ09NUFVURSksdGhpcy5mb3JtYXQ9Ry5kZXB0aDI0cGx1cyx0aGlzLm1pcG1hcENvdW50PTEsdGhpcy5pbml0KCl9aW50ZXJuYWxDcmVhdGVCaW5kaW5nTGF5b3V0RGVzYygpe3RoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cIm5vbi1maWx0ZXJpbmdcIix0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnNhbXBsZVR5cGU9XCJ1bmZpbHRlcmFibGUtZmxvYXRcIix0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnZpZXdEaW1lbnNpb249XCJjdWJlXCJ9aW50ZXJuYWxDcmVhdGVUZXh0dXJlKCl7dGhpcy50ZXh0dXJlRGVzY3JpcHRvcj17Zm9ybWF0OlwiZGVwdGgyNHBsdXNcIixzaXplOnt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodCxkZXB0aE9yQXJyYXlMYXllcnM6Nn0sZGltZW5zaW9uOlwiMmRcIix1c2FnZTpHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1R8R1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElOR30sdGhpcy5ncHVUZXh0dXJlPVMuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGhpcy50ZXh0dXJlRGVzY3JpcHRvcil9aW50ZXJuYWxDcmVhdGVWaWV3KCl7dGhpcy52aWV3RGVzY3JpcHRvcj17ZGltZW5zaW9uOlwiY3ViZVwifSx0aGlzLnZpZXc9dGhpcy5ncHVUZXh0dXJlLmNyZWF0ZVZpZXcodGhpcy52aWV3RGVzY3JpcHRvcil9aW50ZXJuYWxDcmVhdGVTYW1wbGVyKCl7dGhpcy5ncHVTYW1wbGVyPVMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe30pLHRoaXMuZ3B1U2FtcGxlcl9jb21wYXJpc29uPVMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe2NvbXBhcmU6XCJsZXNzXCIsbGFiZWw6XCJzYW1wbGVyX2NvbXBhcmlzb25cIn0pfX1jbGFzcyBHZiBleHRlbmRzIGF0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSxvKHRoaXMsXCJ1aW50MTZBcnJheVwiKSxvKHRoaXMsXCJmbG9hdEFycmF5XCIpLG8odGhpcyxcIl9kYXRhQnVmZmVyXCIpfWNyZWF0ZShlLHQscj1udWxsLHM9ITApe2lmKHI9PW51bGwpe3I9W107Zm9yKGxldCBhPTAsbj1lKnQqNDthPG47YSsrKXJbYV09MH1yZXR1cm4gdGhpcy51cGRhdGVUZXh0dXJlKGUsdCxyLHMpLHRoaXN9dXBkYXRlVGV4dHVyZShlLHQscixzPSEwKXsoZSE9dGhpcy53aWR0aHx8dCE9dGhpcy5oZWlnaHQpJiYodGhpcy5fZGF0YUJ1ZmZlciYmdGhpcy5fZGF0YUJ1ZmZlci5kZXN0cm95KCksdGhpcy5fZGF0YUJ1ZmZlcj1udWxsLHRoaXMuZ3B1VGV4dHVyZSYmdGhpcy5ncHVUZXh0dXJlLmRlc3Ryb3koKSx0aGlzLmdwdVRleHR1cmU9bnVsbCksdGhpcy5mbG9hdEFycmF5PXI7bGV0IGE9Uy5kZXZpY2U7Y29uc3Qgbj1lKjQqMjt0aGlzLmZvcm1hdD1HLnJnYmExNmZsb2F0LHRoaXMubWlwbWFwQ291bnQ9TWF0aC5mbG9vcihzP01hdGgubG9nMihlKToxKSx0aGlzLmNyZWF0ZVRleHR1cmVEZXNjcmlwdG9yKGUsdCx0aGlzLm1pcG1hcENvdW50LHRoaXMuZm9ybWF0KSwoIXRoaXMudWludDE2QXJyYXl8fHRoaXMudWludDE2QXJyYXkubGVuZ3RoIT1yLmxlbmd0aCkmJih0aGlzLnVpbnQxNkFycmF5PW5ldyBVaW50MTZBcnJheShyLmxlbmd0aCkpO2xldCBsPXRoaXMudWludDE2QXJyYXk7Zm9yKGxldCBjPTAsZj1sLmxlbmd0aDtjPGY7YysrKWxbY109dXIocltjXSk7Y29uc3QgaD10aGlzLl9kYXRhQnVmZmVyPWEuY3JlYXRlQnVmZmVyKHtzaXplOmwuYnl0ZUxlbmd0aCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pO2EucXVldWUud3JpdGVCdWZmZXIoaCwwLGwpO2NvbnN0IHU9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCk7dS5jb3B5QnVmZmVyVG9UZXh0dXJlKHtidWZmZXI6aCxieXRlc1BlclJvdzpufSx7dGV4dHVyZTp0aGlzLmdldEdQVVRleHR1cmUoKX0se3dpZHRoOmUsaGVpZ2h0OnQsZGVwdGhPckFycmF5TGF5ZXJzOjF9KSx0aGlzLnVzZU1pcG1hcHx8KHRoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cImZpbHRlcmluZ1wiLHRoaXMudGV4dHVyZUJpbmRpbmdMYXlvdXQuc2FtcGxlVHlwZT1cImZsb2F0XCIpLHcuZW5kQ29tbWFuZEVuY29kZXIodSksdGhpcy5ncHVTYW1wbGVyPWEuY3JlYXRlU2FtcGxlcih0aGlzKSx0aGlzLmdwdVRleHR1cmU9dGhpcy5nZXRHUFVUZXh0dXJlKCksdGhpcy5taXBtYXBDb3VudD4xJiZIdC53ZWJHUFVHZW5lcmF0ZU1pcG1hcCh0aGlzKX19Y2xhc3MgVW0gZXh0ZW5kcyBhdHtjcmVhdGUoZSx0LHIscz0hMCl7bGV0IGE9Uy5kZXZpY2U7Y29uc3Qgbj1lKjQqNDt0aGlzLmZvcm1hdD1HLnJnYmEzMmZsb2F0O2xldCBsPTE7dGhpcy5jcmVhdGVUZXh0dXJlRGVzY3JpcHRvcihlLHQsbCx0aGlzLmZvcm1hdCk7Y29uc3QgaD1hLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpyLmJ5dGVMZW5ndGgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KTthLnF1ZXVlLndyaXRlQnVmZmVyKGgsMCxyKTtjb25zdCB1PXcuYmVnaW5Db21tYW5kRW5jb2RlcigpO3UuY29weUJ1ZmZlclRvVGV4dHVyZSh7YnVmZmVyOmgsYnl0ZXNQZXJSb3c6bn0se3RleHR1cmU6dGhpcy5nZXRHUFVUZXh0dXJlKCl9LHt3aWR0aDplLGhlaWdodDp0LGRlcHRoT3JBcnJheUxheWVyczoxfSksdy5lbmRDb21tYW5kRW5jb2Rlcih1KSxzJiYodGhpcy5zYW1wbGVyQmluZGluZ0xheW91dC50eXBlPVwibm9uLWZpbHRlcmluZ1wiLHRoaXMudGV4dHVyZUJpbmRpbmdMYXlvdXQuc2FtcGxlVHlwZT1cInVuZmlsdGVyYWJsZS1mbG9hdFwiKSx0aGlzLmdwdVNhbXBsZXI9YS5jcmVhdGVTYW1wbGVyKHt9KX1mcm9tQnVmZmVyKGUsdCxyKXtsZXQgcz1TLmRldmljZTtjb25zdCBhPWUqNCo0O3RoaXMuZm9ybWF0PUcucmdiYTMyZmxvYXQsdGhpcy5taXBtYXBDb3VudD0xLHRoaXMuY3JlYXRlVGV4dHVyZURlc2NyaXB0b3IoZSx0LHRoaXMubWlwbWFwQ291bnQsdGhpcy5mb3JtYXQpO2NvbnN0IG49dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCk7cmV0dXJuIG4uY29weUJ1ZmZlclRvVGV4dHVyZSh7YnVmZmVyOnIsYnl0ZXNQZXJSb3c6YX0se3RleHR1cmU6dGhpcy5nZXRHUFVUZXh0dXJlKCl9LHt3aWR0aDplLGhlaWdodDp0LGRlcHRoT3JBcnJheUxheWVyczoxfSksdy5lbmRDb21tYW5kRW5jb2RlcihuKSx0aGlzLnNhbXBsZXJCaW5kaW5nTGF5b3V0LnR5cGU9XCJub24tZmlsdGVyaW5nXCIsdGhpcy50ZXh0dXJlQmluZGluZ0xheW91dC5zYW1wbGVUeXBlPVwidW5maWx0ZXJhYmxlLWZsb2F0XCIsdGhpcy5ncHVTYW1wbGVyPXMuY3JlYXRlU2FtcGxlcih7fSksdGhpc319Y2xhc3MgT20gZXh0ZW5kcyByYXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLG8odGhpcyxcIl9pbnRlcm5hbFRleHR1cmVcIiksbyh0aGlzLFwiX21pblNpemVcIiwzMiksbyh0aGlzLFwiX3NreUNvbG9yXCIpLHRoaXMuX3NreUNvbG9yPWUsdGhpcy5faW50ZXJuYWxUZXh0dXJlPW5ldyBHZjtsZXQgdD1bXTtyZXR1cm4gQS5yZXMuZmlsbENvbG9yKHQsdGhpcy5fbWluU2l6ZSx0aGlzLl9taW5TaXplLHRoaXMuY29sb3Iucix0aGlzLmNvbG9yLmcsdGhpcy5jb2xvci5iLHRoaXMuY29sb3IuYSksdGhpcy5faW50ZXJuYWxUZXh0dXJlLmNyZWF0ZSh0aGlzLl9taW5TaXplLHRoaXMuX21pblNpemUsdCwhMSksdGhpcy5jcmVhdGVGcm9tVGV4dHVyZSh0aGlzLl9taW5TaXplLHRoaXMuX2ludGVybmFsVGV4dHVyZSksdGhpc31jaGFuZ2VDb2xvcihlKXtyZXR1cm4gdGhpcy5fc2t5Q29sb3I9ZSxBLnJlcy5maWxsQ29sb3IodGhpcy5faW50ZXJuYWxUZXh0dXJlLmZsb2F0QXJyYXksdGhpcy5fbWluU2l6ZSx0aGlzLl9taW5TaXplLHRoaXMuY29sb3Iucix0aGlzLmNvbG9yLmcsdGhpcy5jb2xvci5iLHRoaXMuY29sb3IuYSksdGhpcy5faW50ZXJuYWxUZXh0dXJlLnVwZGF0ZVRleHR1cmUodGhpcy5fbWluU2l6ZSx0aGlzLl9taW5TaXplLHRoaXMuX2ludGVybmFsVGV4dHVyZS5mbG9hdEFycmF5LCExKSx0aGlzLl9mYWNlRGF0YS51cGxvYWRUZXh0dXJlKDAsdGhpcy5faW50ZXJuYWxUZXh0dXJlKSx0aGlzfWdldCBjb2xvcigpe3JldHVybiB0aGlzLl9za3lDb2xvcn1zZXQgY29sb3IoZSl7dGhpcy5jaGFuZ2VDb2xvcihlKX19Y2xhc3MgTm0gZXh0ZW5kcyBhdHtjcmVhdGUoZSx0LHIscz0hMCl7bGV0IGE9Uy5kZXZpY2U7Y29uc3Qgbj1lKjQqNDt0aGlzLmZvcm1hdD1HLnJnYmExNmZsb2F0LHRoaXMubWlwbWFwQ291bnQ9TWF0aC5mbG9vcihzP01hdGgubG9nMihlKToxKSx0aGlzLmNyZWF0ZVRleHR1cmVEZXNjcmlwdG9yKGUsdCx0aGlzLm1pcG1hcENvdW50LHRoaXMuZm9ybWF0KTtjb25zdCBsPWEuY3JlYXRlQnVmZmVyKHtzaXplOnIuYnl0ZUxlbmd0aCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pO2EucXVldWUud3JpdGVCdWZmZXIobCwwLHIpO2NvbnN0IGg9dy5iZWdpbkNvbW1hbmRFbmNvZGVyKCk7aC5jb3B5QnVmZmVyVG9UZXh0dXJlKHtidWZmZXI6bCxieXRlc1BlclJvdzpufSx7dGV4dHVyZTp0aGlzLmdldEdQVVRleHR1cmUoKX0se3dpZHRoOmUsaGVpZ2h0OnQsZGVwdGhPckFycmF5TGF5ZXJzOjF9KSx3LmVuZENvbW1hbmRFbmNvZGVyKGgpLHRoaXMubWluRmlsdGVyPVwibmVhcmVzdFwiLHRoaXMubWFnRmlsdGVyPVwibmVhcmVzdFwiLHRoaXMubWlwbWFwRmlsdGVyPVwibmVhcmVzdFwiLHRoaXMuc2FtcGxlckJpbmRpbmdMYXlvdXQudHlwZT1cIm5vbi1maWx0ZXJpbmdcIix0aGlzLnRleHR1cmVCaW5kaW5nTGF5b3V0LnNhbXBsZVR5cGU9XCJ1bmZpbHRlcmFibGUtZmxvYXRcIix0aGlzLm1pbkZpbHRlcj1cImxpbmVhclwiLHRoaXMubWFnRmlsdGVyPVwibGluZWFyXCIsdGhpcy5taXBtYXBGaWx0ZXI9XCJuZWFyZXN0XCIsdGhpcy5zYW1wbGVyQmluZGluZ0xheW91dC50eXBlPVwiZmlsdGVyaW5nXCIsdGhpcy50ZXh0dXJlQmluZGluZ0xheW91dC5zYW1wbGVUeXBlPVwiZmxvYXRcIix0aGlzLmdwdVNhbXBsZXI9YS5jcmVhdGVTYW1wbGVyKHRoaXMpLHRoaXMubWlwbWFwQ291bnQ+MSYmSHQud2ViR1BVR2VuZXJhdGVNaXBtYXAodGhpcyl9fWNsYXNzIEZtIGV4dGVuZHMgdGV7Y29uc3RydWN0b3IoZSx0PS4xKXtzdXBlcigpLG8odGhpcyxcImxlbmd0aFwiLDEwMCksbyh0aGlzLFwidGhpY2tuZXNzXCIsLjEpLHRoaXMubGVuZ3RoPWUsdGhpcy50aGlja25lc3M9dH19Y2xhc3Mga20gZXh0ZW5kcyBEYXRhVmlld3tjb25zdHJ1Y3RvcihlLHQscil7c3VwZXIoZSx0LHIpLG8odGhpcyxcInBvc2l0aW9uXCIsMCl9fWNsYXNzIHpte3N0YXRpYyBtZXJnZShlLHQscil7fXN0YXRpYyBnZW5lcmF0ZU5vcm1hbCgpe31zdGF0aWMgZ2VuZXJhdGVUYW5nZW50KCl7fXN0YXRpYyBwYWNrVVYoKXt9fWNsYXNzIEdte3N0YXRpYyBjb2xvcl90ZW1wZXJhdHVyZV90b19yZ2IoZSl7ZTwxZTM/ZT0xZTM6ZT40ZTQmJihlPTRlNCk7bGV0IHQ9ZS8xMDAscj10aGlzLmdldF9yZWQodCkscz10aGlzLmdldF9ncmVlbih0KSxhPXRoaXMuZ2V0X2JsdWUodCk7cmV0dXJuIG5ldyB6KHIvMjU1LHMvMjU1LGEvMjU1LDEpfXN0YXRpYyBnZXRfcmVkKGUpe2lmKGU8PTY2KXJldHVybiAyNTU7bGV0IHQ9MzI5LjY5ODcyNzQ0NipNYXRoLnBvdyhlLTYwLC0uMTMzMjA0NzU5Mik7cmV0dXJuIHRoaXMuYm91bmQodCl9c3RhdGljIGdldF9ncmVlbihlKXtsZXQgdD0wO3JldHVybiBlPD02Nj90PTk5LjQ3MDgwMjU4NjEqTWF0aC5sb2coZSktMTYxLjExOTU2ODE2NjE6dD0yODguMTIyMTY5NTI4MypNYXRoLnBvdyhlLTYwLC0uMDc1NTE0ODQ5MiksdGhpcy5ib3VuZCh0KX1zdGF0aWMgZ2V0X2JsdWUoZSl7bGV0IHQ9MDtyZXR1cm4gZT49NjY/MjU1OmU8PTE5PzA6KHQ9MTM4LjUxNzczMTIyMzEqTWF0aC5sb2coZS0xMCktMzA1LjA0NDc5MjczMDcsdGhpcy5ib3VuZCh0KSl9c3RhdGljIGJvdW5kKGUsdD0wLHI9MjU1KXtsZXQgcz1NYXRoLm1heChlLHQpO3JldHVybiBNYXRoLm1pbihzLHIpfX1jbGFzcyBwYXtzdGF0aWMgaW5pdEhlYXAoKXt0aGlzLmJveEdlb3x8KHRoaXMuYm94R2VvPW5ldyB1cyksdGhpcy5zcGhlcmV8fCh0aGlzLnNwaGVyZT1uZXcgbHMoMSwzNSwzNSkpLHRoaXMubWF0ZXJpYWx8fCh0aGlzLm1hdGVyaWFsPW5ldyB5aSl9c3RhdGljIGdldCBDdWJlTWVzaCgpe3JldHVybiB0aGlzLmluaXRIZWFwKCksdGhpcy5ib3hHZW99c3RhdGljIGdldCBTcGhlcmVNZXNoKCl7cmV0dXJuIHRoaXMuaW5pdEhlYXAoKSx0aGlzLnNwaGVyZX1zdGF0aWMgR2V0Q3ViZSgpe3RoaXMuaW5pdEhlYXAoKTtsZXQgZT1uZXcgdGUsdD1lLmFkZENvbXBvbmVudChjZSk7cmV0dXJuIHQuZ2VvbWV0cnk9dGhpcy5ib3hHZW8sdC5tYXRlcmlhbD10aGlzLm1hdGVyaWFsLmNsb25lKCksdC5jYXN0U2hhZG93PSEwLGV9c3RhdGljIEdldFNpbmdsZUN1YmUoZSx0LHIscyxhLG4pe3RoaXMuaW5pdEhlYXAoKTtsZXQgbD1uZXcgeWk7bC5iYXNlQ29sb3I9bmV3IHoocyxhLG4sMSk7bGV0IGg9bmV3IHRlLHU9aC5hZGRDb21wb25lbnQoY2UpO3JldHVybiB1LmNhc3RHST0hMCx1Lmdlb21ldHJ5PW5ldyB1cyhlLHQsciksdS5tYXRlcmlhbD1sLGh9c3RhdGljIEdldFNpbmdsZVNwaGVyZShlLHQscixzKXt0aGlzLmluaXRIZWFwKCk7bGV0IGE9bmV3IHlpO2EuYmFzZUNvbG9yPW5ldyB6KHQscixzLDEpO2xldCBuPW5ldyB0ZSxsPW4uYWRkQ29tcG9uZW50KGNlKTtyZXR1cm4gbC5jYXN0R0k9ITAsbC5nZW9tZXRyeT1uZXcgbHMoZSwyMCwyMCksbC5tYXRlcmlhbD1hLG59c3RhdGljIGdldCBTcGhlcmUoKXt0aGlzLmluaXRIZWFwKCk7bGV0IGU9bmV3IHRlLHQ9ZS5hZGRDb21wb25lbnQoY2UpO3JldHVybiB0Lmdlb21ldHJ5PXRoaXMuc3BoZXJlLHQubWF0ZXJpYWw9dGhpcy5tYXRlcmlhbCxlfXN0YXRpYyBHZXRTaW5nbGVDdWJlMihlLHQ9MTApe3RoaXMuaW5pdEhlYXAoKTtsZXQgcj1uZXcgdGUscz1yLmFkZENvbXBvbmVudChjZSk7cmV0dXJuIHMuY2FzdFNoYWRvdz0hMSxzLmdlb21ldHJ5PW5ldyB1cyh0LHQsdCkscy5tYXRlcmlhbD1lLHJ9fW8ocGEsXCJib3hHZW9cIiksbyhwYSxcInNwaGVyZVwiKSxvKHBhLFwibWF0ZXJpYWxcIik7Y2xhc3MgUW0gZXh0ZW5kcyBOdW1iZXJ7fWNsYXNzIFZtIGV4dGVuZHMgTnVtYmVye31jbGFzcyBIbSBleHRlbmRzIE51bWJlcnt9Y2xhc3MgWW0gZXh0ZW5kcyB3aXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksbyh0aGlzLFwieFwiLDApLG8odGhpcyxcInlcIiwwKSxvKHRoaXMsXCJ6XCIsMCksbyh0aGlzLFwid1wiLDApfX1leHBvcnR7SGggYXMgQWNjZWxlcmF0ZURlY2VsZXJhdGVJbnRlcnBvbGF0b3IsUWggYXMgQWNjZWxlcmF0ZUludGVycG9sYXRvcixhYSBhcyBBbmltYXRpb25DdXJ2ZSxfciBhcyBBbmltYXRpb25Nb25pdG9yLGFwIGFzIEFuaW1hdG9yRXZlbnRLZXlmcmFtZSxXaCBhcyBBbnRpY2lwYXRlSW50ZXJwb2xhdG9yLFNzIGFzIEFudGljaXBhdGVPdmVyc2hvb3RJbnRlcnBvbGF0b3IsSmYgYXMgQXJyYXlIYXMsWmYgYXMgQXJyYXlJdGVtSW5kZXgsWm8gYXMgQXRsYXNQYXJzZXIsaXAgYXMgQXRtb3NwaGVyaWNDb21wb25lbnQsVGMgYXMgQXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5LEJjIGFzIEF0bW9zcGhlcmljU2NhdHRlcmluZ1NreVNldHRpbmcscm4gYXMgQXRtb3NwaGVyaWNTY2F0dGVyaW5nU2t5X3NoYWRlcixSYyBhcyBBdHRyaWJ1dGVBbmltQ3VydmUsZHAgYXMgQXVkaW9MaXN0ZW5lcixGbSBhcyBBeGlzT2JqZWN0LFBpIGFzIEIzRE1Mb2FkZXIsVXUgYXMgQjNETUxvYWRlckJhc2Usam8gYXMgQjNETVBhcnNlVXRpbCxYbyBhcyBCM0RNUGFyc2VyLFlnIGFzIEJMVVJfQ3NTaGFkZXIsR3UgYXMgQlJERkxVVCxRdSBhcyBCUkRGTFVUR2VuZXJhdGUsam4gYXMgQlJERl9mcmFnLEhvIGFzIEJhdGNoVGFibGUsSWEgYXMgQmV6aWVyMkQsVGYgYXMgQmV6aWVyM0QseXMgYXMgQmlsbGJvYXJkQ29tcG9uZW50LHhpIGFzIEJpbGxib2FyZFR5cGUsaWkgYXMgQml0bWFwVGV4dHVyZTJELFRsIGFzIEJpdG1hcFRleHR1cmUyREFycmF5LGtvIGFzIEJpdG1hcFRleHR1cmVDdWJlLERsIGFzIEJsZW5kLG5vIGFzIEJsZW5kRmFjdG9yLHhlIGFzIEJsZW5kTW9kZSxDaSBhcyBCbG9vbV9zaGFkZXIsU3UgYXMgQmx1ckVmZmVjdENyZWF0b3JCbHVyX2NzLGJ1IGFzIEJsdXJFZmZlY3RDcmVhdG9yU2FtcGxlX2NzLEl1IGFzIEJsdXJUZXh0dXJlMkRCdWZmZXJDcmVhdG9yLEF0IGFzIEJvdW5jZUludGVycG9sYXRvcixadCBhcyBCb3VuZFV0aWwsQmUgYXMgQm91bmRpbmdCb3gsU2EgYXMgQm91bmRpbmdTcGhlcmUsRGMgYXMgQm94Q29sbGlkZXJTaGFwZSx1cyBhcyBCb3hHZW9tZXRyeSxGbiBhcyBCcmRmTHV0X2ZyYWcscW4gYXMgQnhERl9mcmFnLCRuIGFzIEJ4ZGZEZWJ1Z19mcmFnLGttIGFzIEJ5dGVzU3RyZWFtLGplIGFzIENFdmVudCxoaSBhcyBDRXZlbnREaXNwYXRjaGVyLExyIGFzIENFdmVudExpc3RlbmVyLGRmIGFzIENSZXNpemVFdmVudCxsdCBhcyBDU00sWmkgYXMgQ2FtZXJhM0QscHAgYXMgQ2FtZXJhQ29udHJvbGxlckJhc2UsSWUgYXMgQ2FtZXJhVHlwZSxOZSBhcyBDYW1lcmFVdGlsLEVwIGFzIENhcHN1bGVDb2xsaWRlclNoYXBlLGJmIGFzIENhc3RQb2ludFNoYWRvd01hdGVyaWFsUGFzcyxTZiBhcyBDYXN0U2hhZG93TWF0ZXJpYWxQYXNzLEtuIGFzIENsZWFyY29hdF9mcmFnLGloIGFzIENsdXN0ZXJCb3VuZHNTb3VyY2VfY3Msa2UgYXMgQ2x1c3RlckNvbmZpZyxFbiBhcyBDbHVzdGVyRGVidWdfZnJhZyxfYyBhcyBDbHVzdGVyTGlnaHQsdGggYXMgQ2x1c3RlckxpZ2h0aW5nQnVmZmVyLHdoIGFzIENsdXN0ZXJMaWdodGluZ1JlbmRlcixyaCBhcyBDbHVzdGVyTGlnaHRpbmdfY3MsVWwgYXMgQ29sbGVjdEluZm8scnAgYXMgQ29sbGlkZXJDb21wb25lbnQsWGUgYXMgQ29sbGlkZXJTaGFwZSxtciBhcyBDb2xsaWRlclNoYXBlVHlwZSx6IGFzIENvbG9yLHdmIGFzIENvbG9yTGl0TWF0ZXJpYWwsZW4gYXMgQ29sb3JMaXRTaGFkZXIsV2EgYXMgQ29sb3JQYXNzRnJhZ21lbnRPdXRwdXQsZWggYXMgQ29sb3JQYXNzUmVuZGVyZXIsamEgYXMgQ29sb3JVdGlsLE9uIGFzIENvbW1vbl9mcmFnLE5uIGFzIENvbW1vbl92ZXJ0LEVlIGFzIENvbXBvbmVudEJhc2UsYWUgYXMgQ29tcG9uZW50Q29sbGVjdCxpciBhcyBDb21wdXRlR1BVQnVmZmVyLGJlIGFzIENvbXB1dGVTaGFkZXIsUmggYXMgQ3ViZUNhbWVyYSxCdSBhcyBDdWJlTWFwRmFjZUVudW0sVXIgYXMgQ3ViZVNreV9TaGFkZXIsY2EgYXMgQ3ViaWNCZXppZXJDdXJ2ZSxBbSBhcyBDdWJpY0JlemllclBhdGgsTWYgYXMgQ3ViaWNCZXppZXJUeXBlLGpoIGFzIEN5Y2xlSW50ZXJwb2xhdG9yLFBtIGFzIEN5bGluZGVyR2VvbWV0cnksT2ggYXMgRERHSUlycmFkaWFuY2VDb21wdXRlUGFzcyxFcyBhcyBEREdJSXJyYWRpYW5jZUdQVUJ1ZmZlclJlYWRlcixrbCBhcyBEREdJSXJyYWRpYW5jZVZvbHVtZSxVaCBhcyBEREdJSXJyYWRpYW5jZV9zaGFkZXIsemggYXMgRERHSUxpZ2h0aW5nUGFzcyxraCBhcyBEREdJTGlnaHRpbmdfc2hhZGVyLEZoIGFzIERER0lNdWx0aUJvdW5jZVBhc3MsR2ggYXMgRERHSVByb2JlUmVuZGVyZXIsX2UgYXMgREVHUkVFU19UT19SQURJQU5TLFZoIGFzIERlY2VsZXJhdGVJbnRlcnBvbGF0b3IsRWggYXMgRGVwdGgyRFRleHR1cmVBcnJheSxTaCBhcyBEZXB0aEN1YmVBcnJheVRleHR1cmUsTG0gYXMgRGVwdGhDdWJlVGV4dHVyZSxJZiBhcyBEZXB0aE1hdGVyaWFsUGFzcyxWcCBhcyBEZXB0aE9mRmllbGRQb3N0LEt1IGFzIERlcHRoT2ZWaWV3X2NzLG91IGFzIERpcmVjdExpZ2h0LFZ0IGFzIEVkaXRvckluc3BlY3RvcixBIGFzIEVuZ2luZTNELGJsIGFzIEVudGl0eSxPbCBhcyBFbnRpdHlCYXRjaENvbGxlY3QsUSBhcyBFbnRpdHlDb2xsZWN0LGtuIGFzIEVudk1hcF9mcmFnLERpIGFzIEVycEltYWdlMkN1YmVNYXAsVHUgYXMgRXJwSW1hZ2UyQ3ViZU1hcENyZWF0ZUN1YmVfY3MsTXUgYXMgRXJwSW1hZ2UyQ3ViZU1hcFJnYmUycmdiYV9jcyxQcCBhcyBFeHRydWRlR2VvbWV0cnksenQgYXMgRkFTVEZMT09SLHVvIGFzIEZYQUFQb3N0LEljIGFzIEZYQUFTaGFkZXIsR24gYXMgRmFzdE1hdGhTaGFkZXIsdGEgYXMgRmVhdHVyZVRhYmxlLGh0IGFzIEZpbGVMb2FkZXIsbXAgYXMgRmlyc3RQZXJzb25DYW1lcmFDb250cm9sbGVyLEdmIGFzIEZsb2F0MTZBcnJheVRleHR1cmUsVW0gYXMgRmxvYXQzMkFycmF5VGV4dHVyZSxBcCBhcyBGbHlDYW1lcmFDb250cm9sbGVyLFh1IGFzIEZvbnRDaGFyLEh1IGFzIEZvbnRJbmZvLFl1IGFzIEZvbnRQYWdlLEpvIGFzIEZvbnRQYXJzZXIsd28gYXMgRm9yd2FyZFJlbmRlckpvYixWbiBhcyBGcmFnbWVudFZhcnlpbmcsYW4gYXMgRnJhbWVDYWNoZSx5bCBhcyBGcnVzdHVtLENsIGFzIEZydXN0dW1DU00sV2cgYXMgRnJ1c3R1bUN1bGxpbmdfY3MsZWwgYXMgRnVsbFF1YWRfdmVydF93Z3NsLHd0IGFzIEdCdWZmZXJGcmFtZSxFZiBhcyBHQnVmZmVyUGFzcywkbyBhcyBHQnVmZmVyX3Bhc3MsWHMgYXMgR0lMaWdodGluZyxjbiBhcyBHSVByb2JlTWF0ZXJpYWwsdW4gYXMgR0lQcm9iZU1hdGVyaWFsVHlwZSx5YyBhcyBHSVByb2JlU2hhZGVyLENvIGFzIEdJUmVuZGVyQ29tcGxldGVFdmVudCxIcyBhcyBHSVJlbmRlclN0YXJ0RXZlbnQsZ3UgYXMgR0xCQ2h1bmssZHUgYXMgR0xCSGVhZGVyLHFzIGFzIEdMQlBhcnNlcixwdSBhcyBHTFNMTGV4ZXIsYXMgYXMgR0xTTExleGVyVG9rZW4sbXUgYXMgR0xTTFByZXByb2Nlc3Nvcix2dSBhcyBHTFNMU3ludGF4LEZ1IGFzIEdMVEZCaW5hcnlFeHRlbnNpb24sS2UgYXMgR0xURlBhcnNlcixqcyBhcyBHTFRGU3ViUGFyc2VyLEpoIGFzIEdMVEZTdWJQYXJzZXJDYW1lcmEsZnUgYXMgR0xURlN1YlBhcnNlckNvbnZlcnRlcixldSBhcyBHTFRGU3ViUGFyc2VyTWF0ZXJpYWwsJGggYXMgR0xURlN1YlBhcnNlck1lc2gsTG8gYXMgR0xURlN1YlBhcnNlclNrZWxldG9uLHR1IGFzIEdMVEZTdWJQYXJzZXJTa2luLGxlIGFzIEdMVEZUeXBlLENnIGFzIEdMVEZfQWNjZXNzb3JzLFlzIGFzIEdMVEZfSW5mbyxfZyBhcyBHTFRGX0xpZ2h0LHlnIGFzIEdMVEZfTWVzaCx4ZyBhcyBHTFRGX05vZGUsdmcgYXMgR0xURl9QcmltaXRpdmVzLEFnIGFzIEdMVEZfU2NlbmUsQnQgYXMgR1BVQWRkcmVzc01vZGUsV2YgYXMgR1BVQmxlbmRGYWN0b3IsSnQgYXMgR1BVQnVmZmVyQmFzZSxNdCBhcyBHUFVCdWZmZXJUeXBlLHZ0IGFzIEdQVUNvbXBhcmVGdW5jdGlvbix3IGFzIEdQVUNvbnRleHQsdWkgYXMgR1BVQ3VsbE1vZGUsTnIgYXMgR1BVRmlsdGVyTW9kZSxNcyBhcyBHUFVQcmltaXRpdmVUb3BvbG9neSxHIGFzIEdQVVRleHR1cmVGb3JtYXQsRnIgYXMgR1BVVmVydGV4Rm9ybWF0LEtmIGFzIEdQVVZlcnRleFN0ZXBNb2RlLEhwIGFzIEdUQU9Qb3N0LEp1IGFzIEdUQU9fY3MsanUgYXMgR1VJQXRsYXNUZXh0dXJlLENzIGFzIEdVSUNhbnZhcyx5ZSBhcyBHVUlDb25maWcsRmMgYXMgR1VJR2VvbWV0cnksemMgYXMgR1VJR2VvbWV0cnlSZWJ1aWxkLEdjIGFzIEdVSU1hdGVyaWFsLEhjIGFzIEdVSVBpY2ssRnQgYXMgR1VJUGlja0hlbHBlcixGaSBhcyBHVUlRdWFkLFBlIGFzIEdVSVF1YWRBdHRyRW51bSxRYyBhcyBHVUlSZW5kZXJlcixOaSBhcyBHVUlTaGFkZXIsTnQgYXMgR1VJU3BhY2UsZnIgYXMgR1VJU3ByaXRlLGRyIGFzIEdVSVRleHR1cmUsYWwgYXMgR2VuZXJheVJhbmRvbURpcix0dCBhcyBHZW9tZXRyeUJhc2UsS2wgYXMgR2VvbWV0cnlJbmRpY2VzQnVmZmVyLHptIGFzIEdlb21ldHJ5VXRpbCxqbCBhcyBHZW9tZXRyeVZlcnRleEJ1ZmZlcix0aSBhcyBHZW9tZXRyeVZlcnRleFR5cGUscWEgYXMgR2V0Q291bnRJbnN0YW5jZUlELG9kIGFzIEdldFJlcGVhdCx3biBhcyBHbGFzc01hdGVyaWFsLENjIGFzIEdsYXNzU2hhZGVyLHBlIGFzIEdsb2JhbEJpbmRHcm91cCxIciBhcyBHbG9iYWxCaW5kR3JvdXBMYXlvdXQsWXAgYXMgR2xvYmFsRm9nLEVjIGFzIEdsb2JhbEZvZ19zaGFkZXIsU3AgYXMgR2xvYmFsSWxsdW1pbmF0aW9uQ29tcG9uZW50LFRzIGFzIEdsb2JhbFVuaWZvcm0sU2wgYXMgR2xvYmFsVW5pZm9ybUdyb3VwLFhwIGFzIEdvZFJheVBvc3QsWnUgYXMgR29kUmF5X2NzLGFmIGFzIEdyYXBoaWMzRCxVcyBhcyBHcmFwaGljM0RCYXRjaFJlbmRlcmVyLHJmIGFzIEdyYXBoaWMzREZpbGxSZW5kZXJlcixMbCBhcyBHcmFwaGljM0RGaXhlZFJlbmRlclBpcGVsaW5lLHNmIGFzIEdyYXBoaWMzRExpbmVCYXRjaFJlbmRlcmVyLFJsIGFzIEdyYXBoaWMzRFNoYWRlcl9mcyxQbCBhcyBHcmFwaGljM0RTaGFkZXJfdnMsZWkgYXMgR3JhcGhpY0NvbmZpZyxsbyBhcyBHcmFwaGljczNEU2hhcGUsV3AgYXMgSERSQmxvb21Qb3N0LEdvIGFzIEhEUlRleHR1cmUsZWEgYXMgSERSVGV4dHVyZUN1YmUsTHMgYXMgSGFsdG9uU2VxLEtjIGFzIEhvcml6b250YWwsX3AgYXMgSG92ZXJDYW1lcmFDb250cm9sbGVyLHNpIGFzIEkzRE1Mb2FkZXIsa3UgYXMgSTNETUxvYWRlckJhc2UscW8gYXMgSTNETVBhcnNlcixjciBhcyBJQkxFbnZNYXBDcmVhdG9yLFJ1IGFzIElCTEVudk1hcENyZWF0b3JfY3MsQmkgYXMgSUVTUHJvZmlsZXMsWW4gYXMgSUVTUHJvZmlsZXNfZnJhZyxPcCBhcyBJS0RUcmVlVXNlckRhdGEscHIgYXMgSW1hZ2VUeXBlLHFsIGFzIEluZGljZXNHUFVCdWZmZXIsVW4gYXMgSW5saW5lX3ZlcnQsSW4gYXMgSW5wdXRTeXN0ZW0sSXAgYXMgSW5zdGFuY2VEcmF3Q29tcG9uZW50LHpuIGFzIEluc3RhbmNlVW5pZm9ybSx6dSBhcyBJbnN0YW5jZWRNZXNoLFNvIGFzIEludGVycG9sYXRvcixibyBhcyBJbnRlcnBvbGF0b3JFbnVtLEFmIGFzIElycmFkaWFuY2VEYXRhUmVhZGVyQ29tcGxldGVFdmVudCxMbiBhcyBJcnJhZGlhbmNlVm9sdW1lRGF0YV9mcmFnLFduIGFzIElycmFkaWFuY2VfZnJhZyxRZCBhcyBJc0VkaXRvckluc3BlY3RvcixHZCBhcyBJc05vblNlcmlhbGl6ZSxpdSBhcyBKb2ludCxSbyBhcyBKb2ludFBvc2UsWGggYXMgSnVtcGVySW50ZXJwb2xhdG9yLEZwIGFzIEtEVHJlZUVudGl0eSxmbiBhcyBLRFRyZWVOb2RlLGhmIGFzIEtEVHJlZVJhbmdlLHVmIGFzIEtEVHJlZVNwYWNlLGhhIGFzIEtEVHJlZVVVSUQscnMgYXMgS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24sJHAgYXMgS0hSX2xpZ2h0c19wdW5jdHVhbCxodSBhcyBLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdCx1dSBhcyBLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoLGVtIGFzIEtIUl9tYXRlcmlhbHNfaW9yLHRtIGFzIEtIUl9tYXRlcmlhbHNfc2hlZW4saW0gYXMgS0hSX21hdGVyaWFsc19zcGVjdWxhcixybSBhcyBLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbixjdSBhcyBLSFJfbWF0ZXJpYWxzX3VubGl0LHNtIGFzIEtIUl9tYXRlcmlhbHNfdmFyaWFudHMsYW0gYXMgS0hSX21hdGVyaWFsc192b2x1bWUsb20gYXMgS0hSX21lc2hfcXVhbnRpemF0aW9uLG5tIGFzIEtIUl90ZXh0dXJlX2Jhc2lzdSxsbSBhcyBLSFJfdGV4dHVyZV90cmFuc2Zvcm0sR20gYXMgS2VsdmluVXRpbCxKZSBhcyBLZXlDb2RlLFF0IGFzIEtleUV2ZW50LHNuIGFzIEtleWZyYW1lLHJhIGFzIExEUlRleHR1cmVDdWJlLEtnIGFzIExVVF9nbHNsLHBtIGFzIExhbWJlcnRNYXRlcmlhbCx3YyBhcyBMYW1iZXJ0U2hhZGVyLFdzIGFzIExpZ2h0QmFzZSxHciBhcyBMaWdodERhdGEsemwgYXMgTGlnaHRFbnRyaWVzLFFlIGFzIExpZ2h0VHlwZSxCbiBhcyBMaWdodGluZ0Z1bmN0aW9uX2ZyYWcsdnIgYXMgTGluZSxZYyBhcyBMaW5lQ2xhc3NpZmljYXRpb24sWWggYXMgTGluZWFySW50ZXJwb2xhdG9yLHlpIGFzIExpdE1hdGVyaWFsLEpuIGFzIExpdFNoYWRlcixqaSBhcyBMb2FkZXJCYXNlLGRuIGFzIExvYWRlckV2ZW50LENmIGFzIExvYWRlck1hbmFnZXIsdGQgYXMgTUFYX1ZBTFVFLGlkIGFzIE1JTl9WQUxVRSxfaSBhcyBNYXRlcmlhbCx3dSBhcyBNYXRlcmlhbERhdGFVbmlmb3JtR1BVQnVmZmVyLCRnIGFzIE1hdGVyaWFsVW5pZm9ybSxCcyBhcyBNYXRoU2hhZGVyLHN0IGFzIE1hdGhVdGlsLFFpIGFzIE1hdHJpeDMsViBhcyBNYXRyaXg0LFZsIGFzIE1hdHJpeEJpbmRHcm91cCxVcCBhcyBNYXRyaXhETyxRbCBhcyBNYXRyaXhHUFVCdWZmZXIsU2MgYXMgTWF0cml4U2hhZGVyLHpyIGFzIE1lbW9yeURPLG9sIGFzIE1lbW9yeUluZm8sa3AgYXMgTWVyZ2VSR0JBQ3JlYXRvciwkdSBhcyBNZXJnZVJHQkFfY3MsdGYgYXMgTWVzaENvbGxpZGVyU2hhcGUsY2UgYXMgTWVzaFJlbmRlcmVyLHZtIGFzIE1pbk1heEFuaW1hdGlvbkN1cnZlcyxOZiBhcyBNaW5NYXhDdXJ2ZSxPZiBhcyBNaW5NYXhDdXJ2ZVN0YXRlLHltIGFzIE1pbk1heFBvbHlDdXJ2ZXMsQ3IgYXMgTW9yZVBhc3NQYXJzZXIscGYgYXMgTW9yZVBhc3NTaGFkZXIsb3AgYXMgTW9ycGhUYXJnZXRCbGVuZGVyLFlsIGFzIE1vcnBoVGFyZ2V0RGF0YSxucCBhcyBNb3JwaFRhcmdldEZyYW1lLExlIGFzIE1vcnBoVGFyZ2V0X3NoYWRlcixnZiBhcyBNb3VzZUNvZGUsTmggYXMgTXVsdGlCb3VuY2VQYXNzX2NzLHpkIGFzIE5vblNlcmlhbGl6ZSxRbiBhcyBOb3JtYWxNYXBfZnJhZyxzdSBhcyBPQW5pbWF0aW9uRXZlbnQsRm8gYXMgT0JKUGFyc2VyLHRlIGFzIE9iamVjdDNELGZzIGFzIE9iamVjdDNERXZlbnQscGEgYXMgT2JqZWN0M0RVdGlsLExjIGFzIE9iamVjdEFuaW1DbGlwLGtzIGFzIE9jY2x1c2lvblN5c3RlbSxlciBhcyBPY3RyZWUsTWwgYXMgT2N0cmVlRW50aXR5LHhwIGFzIE9yYml0Q29udHJvbGxlcix5dCBhcyBPcmllbnRhdGlvbjNELGVjIGFzIE91dExpbmVCbGVuZENvbG9yX2NzLHRjIGFzIE91dGxpbmVDYWxjT3V0bGluZV9jcyxKZyBhcyBPdXRsaW5lUGFzcyxqcCBhcyBPdXRsaW5lUG9zdCx4ZiBhcyBPdXRsaW5lUG9zdERhdGEsdmYgYXMgT3V0bGluZVBvc3RNYW5hZ2VyLF9mIGFzIE91dGxpbmVQb3N0U2xvdCxpYyBhcyBPdXRsaW5lX2NzLHFoIGFzIE92ZXJzaG9vdEludGVycG9sYXRvcixabiBhcyBQQlJMSXRTaGFkZXIsWHQgYXMgUGFyc2VyQmFzZSxVZiBhcyBQYXJ0aWNsZVN5c3RlbUN1cnZlRXZhbE1vZGUsRGYgYXMgUGFydGljbGVTeXN0ZW1SYW5kb21uZXNzSWRzLFhyIGFzIFBhc3NHZW5lcmF0ZSxtZiBhcyBQYXNzU2hhZGVyLFpnIGFzIFBhdmVtZW50U2hhZGVyLG9zIGFzIFBoeXNpY01hdGVyaWFsLFRuIGFzIFBoeXNpY01hdGVyaWFsVW5pZm9ybV9mcmFnLG9mIGFzIFBpY2tDb21wdXRlLG5mIGFzIFBpY2tGaXJlLHlmIGFzIFBpY2tSZXN1bHQscmMgYXMgUGlja2VyX2NzLEphIGFzIFBpbmdQb25nLEpzIGFzIFBpcGVsaW5lUG9vbCxibiBhcyBQbGFuZSxabCBhcyBQbGFuZUdlb21ldHJ5LFhjIGFzIFBvaW50Q2xhc3NpZmljYXRpb24sbnUgYXMgUG9pbnRMaWdodCxJaCBhcyBQb2ludExpZ2h0U2hhZG93UmVuZGVyZXIsbW0gYXMgUG9pbnRNYXRlcmlhbCxiaCBhcyBQb2ludFNoYWRvd0N1YmVDYW1lcmEsYmMgYXMgUG9pbnRTaGFkb3dEZWJ1ZyxSIGFzIFBvaW50ZXJFdmVudDNELGp0IGFzIFBvbHlub21pYWwsZGEgYXMgUG9seW5vbWlhbEN1cnZlLHhtIGFzIFBvbHlub21pYWxzLFZjIGFzIFBvb2xOb2RlLGdwIGFzIFBvc2l0aW9uQXVkaW8sQ3QgYXMgUG9zdEJhc2UsYnAgYXMgUG9zdFByb2Nlc3NpbmdDb21wb25lbnQsRGggYXMgUG9zdFJlbmRlcmVyLFRoIGFzIFByZURlcHRoUGFzc1JlbmRlcmVyLHV0IGFzIFByZXByb2Nlc3NvcixlZiBhcyBQcm9iZSxHbCBhcyBQcm9iZUVudHJpZXMsTGggYXMgUHJvYmVHQnVmZmVyRnJhbWUsZnQgYXMgUHJvZmlsZXJVdGlsLHNwIGFzIFByb3BlcnR5QW5pbUNsaXAsVWMgYXMgUHJvcGVydHlBbmltVGFnLEFuIGFzIFByb3BlcnR5QW5pbWF0aW9uLFVpIGFzIFByb3BlcnR5QW5pbWF0aW9uRXZlbnQsV3QgYXMgUHJvcGVydHlIZWxwLHZjIGFzIFF1YWRHbHNsX2ZzLHhjIGFzIFF1YWRHbHNsX3ZzLFhmIGFzIFF1YWRfZGVwdGgyZEFycmF5X2ZyYWdfd2dzbCxybCBhcyBRdWFkX2RlcHRoMmRfZnJhZ193Z3NsLHNsIGFzIFF1YWRfZGVwdGhDdWJlX2ZyYWdfd2dzbCxpbCBhcyBRdWFkX2ZyYWdfd2dzbCx0bCBhcyBRdWFkX3ZlcnRfd2dzbCxxIGFzIFF1YXRlcm5pb24scWkgYXMgUkFESUFOU19UT19ERUdSRUVTLFB1IGFzIFJHQkVFcnJvckNvZGUsUW8gYXMgUkdCRUhlYWRlciwkcyBhcyBSR0JFUGFyc2VyLENlIGFzIFJURGVzY3JpcHRvcixaZSBhcyBSVEZyYW1lLEFlIGFzIFJUUmVzb3VyY2VDb25maWcsRmUgYXMgUlRSZXNvdXJjZU1hcCxBcyBhcyBSYW5kLG5kIGFzIFJhbmRvbVNlZWQsY2kgYXMgUmF5LHppIGFzIFJheUNhc3RNZXNoRGV0YWlsLG5yIGFzIFJlYWRlcixicyBhcyBSZWN0LHNlIGFzIFJlZmVyZW5jZSxWZCBhcyBSZWdpc3RlckNvbXBvbmVudCwkbCBhcyBSZW5kZXJDb250ZXh0LFlyIGFzIFJlbmRlckxheWVyLG9vIGFzIFJlbmRlckxheWVyVXRpbCwkdCBhcyBSZW5kZXJOb2RlLFdlIGFzIFJlbmRlclNoYWRlcixObCBhcyBSZW5kZXJTaGFkZXJDb2xsZWN0LGRpIGFzIFJlbmRlcmVyQmFzZSxQaCBhcyBSZW5kZXJlckpvYixNaCBhcyBSZW5kZXJlck1hcCxVZSBhcyBSZW5kZXJlck1hc2ssVHQgYXMgUmVuZGVyZXJNYXNrVXRpbCxXbCBhcyBSZW5kZXJlclBhc3NTdGF0ZSxyZSBhcyBSZW5kZXJlclR5cGUsWmEgYXMgUmVwZWF0U0UscXUgYXMgUmVzLElzIGFzIFNOX0FycmF5Q29uc3RhbnQsQWkgYXMgU05fQmluYXJ5T3BlcmF0aW9uLHpnIGFzIFNOX0JyZWFrLEd0IGFzIFNOX0NvZGVCbG9jayxuaSBhcyBTTl9Db25zdGFudCx2YSBhcyBTTl9Db250aW51ZSxUZSBhcyBTTl9EZWNsYXJhdGlvbixHZyBhcyBTTl9EaXNjYXJkLGtnIGFzIFNOX0RvV2hpbGVMb29wLGllIGFzIFNOX0V4cHJlc3Npb24sWWkgYXMgU05fRm9yTG9vcCxfYSBhcyBTTl9GdW5jdGlvbix4YSBhcyBTTl9GdW5jdGlvbkFyZ3MsSGkgYXMgU05fRnVuY3Rpb25DYWxsLEdpIGFzIFNOX0lGQnJhbmNoLHJpIGFzIFNOX0lkZW50aWZpZXIsV2kgYXMgU05fSW5kZXhPcGVyYXRpb24sdnMgYXMgU05fTGF5b3V0LF91IGFzIFNOX1BhcmVuRXhwcmVzc2lvbix5YSBhcyBTTl9QcmVjaXNpb24sX3MgYXMgU05fUmV0dXJuLHhzIGFzIFNOX1NlbGVjdE9wZXJhdGlvbixvaSBhcyBTTl9TdHJ1Y3QseHUgYXMgU05fVGVybmFyeU9wZXJhdGlvbixsciBhcyBTTl9VbmFyeU9wZXJhdGlvbixYaSBhcyBTTl9XaGlsZUxvb3AsWGcgYXMgU1NBT19jcyxxcCBhcyBTU1JQb3N0LHNjIGFzIFNTUl9CbGVuZENvbG9yX2NzLEtwIGFzIFNTUl9JU19LZXJuZWwsYWMgYXMgU1NSX0lTX2NzLG9jIGFzIFNTUl9SYXlUcmFjZV9jcyxUcCBhcyBTY2VuZTNELE5vIGFzIFNoYWRlckF0dHJpYnV0ZUluZm8sS2EgYXMgU2hhZGVyQmFzZSxLcyBhcyBTaGFkZXJDb252ZXJ0ZXIseXUgYXMgU2hhZGVyQ29udmVydGVyUmVzdWx0LE4gYXMgU2hhZGVyTGliLGN0IGFzIFNoYWRlclJlZmxlY3Rpb24sVXQgYXMgU2hhZGVyU3RhZ2UsQ3UgYXMgU2hhZGVyU3RhdGUsT28gYXMgU2hhZGVyVW5pZm9ybUluZm8sT3QgYXMgU2hhZGVyVXRpbCxIbiBhcyBTaGFkaW5nSW5wdXQsVmUgYXMgU2hhZG93TGlnaHRzQ29sbGVjdCxCaCBhcyBTaGFkb3dNYXBQYXNzUmVuZGVyZXIsWG4gYXMgU2hhZG93TWFwcGluZ19mcmFnLHJ1IGFzIFNrZWxldG9uLG1hIGFzIFNrZWxldG9uQW5pbWF0aW9uQ2xpcCxhdSBhcyBTa2VsZXRvbkFuaW1hdGlvbkNsaXBTdGF0ZSx2aSBhcyBTa2VsZXRvbkFuaW1hdGlvbkNvbXBvbmVudCxscCBhcyBTa2VsZXRvbkFuaW1hdGlvbkNvbXB1dGUsT3IgYXMgU2tlbGV0b25BbmltYXRpb25fc2hhZGVyLGhwIGFzIFNrZWxldG9uQmxlbmRDb21wdXRlQXJncyxzcyBhcyBTa2VsZXRvblBvc2UsdXAgYXMgU2tlbGV0b25UcmFuc2Zvcm1Db21wdXRlQXJncyxBYSBhcyBTa2lubmVkTWVzaFJlbmRlcmVyLEJmIGFzIFNreUdCdWZmZXJQYXNzLGdjIGFzIFNreUdCdWZmZXJfcGFzcyxNYyBhcyBTa3lNYXRlcmlhbCxzYSBhcyBTa3lSZW5kZXJlcixxZyBhcyBTa3lfZ2xzbF9mcyxqZyBhcyBTa3lfZ2xzbF92cyxPbSBhcyBTb2xpZENvbG9yU2t5LEJwIGFzIFNwaGVyZUNvbGxpZGVyU2hhcGUsbHMgYXMgU3BoZXJlR2VvbWV0cnksbHUgYXMgU3BvdExpZ2h0LG1lIGFzIFN0YXRlbWVudE5vZGUsT2MgYXMgU3RhdGljQXVkaW8sZ2UgYXMgU3RvcmFnZUdQVUJ1ZmZlcixpdCBhcyBTdHJpbmdVdGlsLHdpIGFzIFN0cnVjdCx6cCBhcyBTdHJ1Y3RTdG9yYWdlR1BVQnVmZmVyLEpsIGFzIFN1Ykdlb21ldHJ5LG5jIGFzIFRBQUNvcHlUZXhfY3MsSnAgYXMgVEFBUG9zdCxsYyBhcyBUQUFTaGFycFRleF9jcyxoYyBhcyBUQUFfY3MsamMgYXMgVGV4dEFuY2hvcixaYyBhcyBUZXh0RmllbGRMYXlvdXQsSmMgYXMgVGV4dEZpZWxkTGluZSxhdCBhcyBUZXh0dXJlLFpzIGFzIFRleHR1cmVDdWJlLFZvIGFzIFRleHR1cmVDdWJlRmFjZURhdGEsaHIgYXMgVGV4dHVyZUN1YmVTdGRDcmVhdG9yLHpvIGFzIFRleHR1cmVDdWJlVXRpbHMsZHMgYXMgVGV4dHVyZU1pcG1hcENvbXB1dGUsSHQgYXMgVGV4dHVyZU1pcG1hcEdlbmVyYXRvcix5cCBhcyBUaGlyZFBlcnNvbkNhbWVyYUNvbnRyb2xsZXIsaG0gYXMgVGlsZVNldCxjbSBhcyBUaWxlU2V0Q2hpbGQsZm0gYXMgVGlsZVNldENoaWxkQ29udGVudCxkbSBhcyBUaWxlU2V0Q2hpbGRDb250ZW50TWV0YURhdGEsdW0gYXMgVGlsZVNldFJvb3QsQ24gYXMgVGlsZXNSZW5kZXJlcixoZSBhcyBUaW1lLHggYXMgVG9rZW5UeXBlLFJtIGFzIFRvcnVzR2VvbWV0cnksU24gYXMgVG91Y2hEYXRhLE9lIGFzIFRyYW5zZm9ybSxVbyBhcyBUcmFuc2xhdG9yQ29udGV4dCxuYSBhcyBUcmlhbmdsZSxfbiBhcyBVSUJ1dHRvbiwkYyBhcyBVSUJ1dHRvblRyYW5zaXRpb24sbG4gYXMgVUlDb21wb25lbnRCYXNlLHVhIGFzIFVJRXZlbnQsVmkgYXMgVUlJbWFnZSx4biBhcyBVSUltYWdlR3JvdXAsYmEgYXMgVUlJbnRlcmFjdGl2ZSxEZSBhcyBVSUludGVyYWN0aXZlU3R5bGUsd3MgYXMgVUlQYW5lbCxjcyBhcyBVSVJlbmRlckFibGUsdm4gYXMgVUlTaGFkb3cseW4gYXMgVUlUZXh0RmllbGQsbGkgYXMgVUlUcmFuc2Zvcm0sUHQgYXMgVVVJRCx6ZiBhcyBVVixObSBhcyBVaW50MTZUZXh0dXJlLFZ1IGFzIFVpbnQ4QXJyYXlUZXh0dXJlLHRuIGFzIFVuTGl0LGhzIGFzIFVuTGl0TWF0ZXJpYWwsTW4gYXMgVW5MaXRNYXRlcmlhbFVuaWZvcm1fZnJhZyxEbiBhcyBVbkxpdF9mcmFnLER0IGFzIFVuaWZvcm1HUFVCdWZmZXIsJCBhcyBVbmlmb3JtTm9kZSwkZSBhcyBVbmlmb3JtVHlwZSxDbSBhcyBWYWx1ZVNwcmVhZCxaIGFzIFZlY3RvcjIsZyBhcyBWZWN0b3IzLE9pIGFzIFZlY3RvcjNFeCxZbSBhcyBWZWN0b3IzU3RydWN0LGogYXMgVmVjdG9yNCxMcCBhcyBWZXJ0ZXhBdHRyaWJ1dGUsWSBhcyBWZXJ0ZXhBdHRyaWJ1dGVOYW1lLGJpIGFzIFZlcnRleEF0dHJpYnV0ZVNpemUsbGYgYXMgVmVydGV4QXR0cmlidXRlU3RyaWRlLFBuIGFzIFZlcnRleEF0dHJpYnV0ZXMsUnAgYXMgVmVydGV4QnVmZmVyTGF5b3V0LGxsIGFzIFZlcnRleEZvcm1hdCxobyBhcyBWZXJ0ZXhHUFVCdWZmZXIscWMgYXMgVmVydGljYWwsUm4gYXMgVmlkZW9Vbmlmb3JtX2ZyYWcsTXAgYXMgVmlldzNELENhIGFzIFZpZXdQYW5lbCxOcyBhcyBWaWV3UXVhZCxvZSBhcyBWaXJ0dWFsVGV4dHVyZSxBdSBhcyBXR1NMVHJhbnNsYXRvcixIZSBhcyBXZWJHUFVEZXNjcmlwdG9yQ3JlYXRvcixYYSBhcyBXb3JsZE1hdHJpeFVuaWZvcm0sd2EgYXMgV29ybGRQYW5lbCxBciBhcyBXcmFwTW9kZSxQYyBhcyBXcmFwVGltZU1vZGUsUXAgYXMgWkN1bGxpbmdDb21wdXRlLHBjIGFzIFpQYXNzU2hhZGVyX2NzLG1jIGFzIFpQYXNzU2hhZGVyX2ZzLEFjIGFzIFpQYXNzU2hhZGVyX3ZzLElsIGFzIFpTb3J0ZXJVdGlsLHhsIGFzIGFwcGVuZCxMdSBhcyBhcnJheVRvU3RyaW5nLGpmIGFzIGJsZW5kQ29tcG9uZW50LGJtIGFzIGJ1aWxkQ3VydmVzLFNtIGFzIGNhbGN1bGF0ZUN1cnZlUmFuZ2VzVmFsdWUscHMgYXMgY2FsY3VsYXRlTWluTWF4LGNjIGFzIGNhc3RQb2ludFNoYWRvd01hcF92ZXJ0LEsgYXMgY2xhbXAsVGQgYXMgY2xhbXBSZXBlYXQsY3AgYXMgY29tcHV0ZV9za2VsZXRvbl9ibGVuZCxmcCBhcyBjb21wdXRlX3NrZWxldG9uX3RyYW5zZm9ybSx2ZCBhcyBjb3MsSWQgYXMgY3Jvc3NQcm9kdWN0LFBmIGFzIGN1YmljUG9seW5vbWlhbFJvb3QsUmYgYXMgY3ViaWNQb2x5bm9taWFsUm9vdHNHZW5lcmljLHdtIGFzIGN1cnZlc1N1cHBvcnRQcm9jZWR1cmFsLEFkIGFzIGRlZzJSYWQsZGMgYXMgZGlyZWN0aW9uU2hhZG93Q2FzdE1hcF9mcmFnLGV0IGFzIGRvdCxMZiBhcyBkb3VibGVJbnRlZ3JhdGVTZWdtZW50LFFtIGFzIGYzMixBbCBhcyBmYXN0SW52U3FydCxtbCBhcyBmbG9vcmZUb0ludFBvcyxnciBhcyBmb250cyxFZCBhcyBnZW5lcmF0ZVJhbmRvbSxCZCBhcyBnZW5lcmF0ZVJhbmRvbTMsZmwgYXMgZ2V0RmxvYXRGcm9tSW50LExnIGFzIGdldEdMVHlwZUZyb21UeXBlZEFycmF5LFJnIGFzIGdldEdMVHlwZUZyb21UeXBlZEFycmF5VHlwZSx5ZCBhcyBnZXRHbG9iYWxSYW5kb21TZWVkLFVnIGFzIGdldFR5cGVkQXJyYXksUG8gYXMgZ2V0VHlwZWRBcnJheVR5cGVGcm9tR0xUeXBlLG1uIGFzIGdyYWQxLGdhIGFzIGdyYWQyLG1zIGFzIGdyYWQzLGJyIGFzIGdyYWQ0LFZtIGFzIGkzMixwbiBhcyBpbnRlZ3JhdGVTZWdtZW50LEdwIGFzIGlycmFkaWFuY2VEYXRhUmVhZGVyLF9tIGFzIGtQSSxJaSBhcyBsZXJwLGFkIGFzIGxlcnBCeXRlLHNkIGFzIGxlcnBDb2xvcixyZCBhcyBsZXJwVmVjdG9yMyxlbyBhcyBtYWduaXR1ZGUsSGcgYXMgbWFrZUFsb25lU3ByaXRlLFd1IGFzIG1ha2VHVUlTcHJpdGUsUnMgYXMgbWFrZU1hdHJpeDQ0LHNvIGFzIG1hdHJpeE11bHRpcGx5LFJkIGFzIG1hdHJpeFJvdGF0ZSxQZCBhcyBtYXRyaXhSb3RhdGVZLF9sIGFzIG11bHRpcGx5TWF0cmljZXM0eDRSRUYsRmYgYXMgbm9ybWFsX2Rpc3RyaWJ1dGlvbixTZCBhcyBub3JtYWxpemVGYXN0LGNsIGFzIG5vcm1hbGl6ZVNhZmUsYmQgYXMgbm9ybWFsaXplZFRvQnl0ZSx3ZCBhcyBub3JtYWxpemVkVG9Xb3JkLGt0IGFzIG91dGxpbmVQb3N0RGF0YSxacCBhcyBvdXRsaW5lUG9zdE1hbmFnZXIsSiBhcyBwZXJtLGZhIGFzIHF1YWRyYXRpY1BvbHlub21pYWxSb290c0dlbmVyaWMsX2QgYXMgcmFkMkRlZyxLaSBhcyByYW5kb20wMSxtZCBhcyByYW5kb21CYXJ5Y2VudHJpY0Nvb3JkLHBkIGFzIHJhbmRvbVBvaW50QmV0d2VlbkVsbGlwc29pZCxkZCBhcyByYW5kb21Qb2ludEJldHdlZW5TcGhlcmUsY2QgYXMgcmFuZG9tUG9pbnRJbnNpZGVDdWJlLGZkIGFzIHJhbmRvbVBvaW50SW5zaWRlRWxsaXBzb2lkLGdkIGFzIHJhbmRvbVBvaW50SW5zaWRlVW5pdENpcmNsZSxnbCBhcyByYW5kb21Qb2ludEluc2lkZVVuaXRTcGhlcmUsaGQgYXMgcmFuZG9tUXVhdGVybmlvbix1ZCBhcyByYW5kb21RdWF0ZXJuaW9uVW5pZm9ybURpc3RyaWJ1dGlvbixwbCBhcyByYW5kb21TZWVkLFBzIGFzIHJhbmRvbVVuaXRWZWN0b3IsZGwgYXMgcmFuZG9tVW5pdFZlY3RvcjIscWUgYXMgcmFuZ2VkUmFuZG9tRmxvYXQsbGQgYXMgcmFuZ2VkUmFuZG9tSW50LFlvIGFzIHJlYWRNYWdpY0J5dGVzLGdtIGFzIHJlZ2lzdGVyTWF0ZXJpYWwscm8gYXMgcmVwZWF0LERkIGFzIHJvdE1hdHJpeCxlZCBhcyByb3RhdGVWZWN0b3JCeVF1YXQsdG8gYXMgcm91bmRmVG9JbnRQb3MsJGEgYXMgc2NhbGUsZmMgYXMgc2hhZG93Q2FzdE1hcF9mcmFnLHVjIGFzIHNoYWRvd0Nhc3RNYXBfdmVydCxtdCBhcyBzaW1wbGV4LHhkIGFzIHNpbixCbSBhcyBzbm9pc2UxLFRtIGFzIHNub2lzZTIsTW0gYXMgc25vaXNlMyxEbSBhcyBzbm9pc2U0LGlvIGFzIHNxck1hZ25pdHVkZSx1bCBhcyBzcXJ0SW1wbCxxZiBhcyBzdGVuY2lsU3RhdGVGYWNlLENkIGFzIHN3YXAsdXIgYXMgdG9IYWxmRmxvYXQsSG0gYXMgdTMyLEltIGFzIHVuaWZvcm1fcmVhbF9kaXN0cmlidXRpb24sRW0gYXMgdW5pZm9ybV9yZWFsX2Rpc3RyaWJ1dGlvbjIsUyBhcyB3ZWJHUFVDb250ZXh0LEVsIGFzIHpTb3J0ZXJVdGlsfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbCcpO1xudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcbnZhciBDYW5jZWxlZEVycm9yID0gcmVxdWlyZSgnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3InKTtcbnZhciBwYXJzZVByb3RvY29sID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZVByb3RvY29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcbiAgICB2YXIgcmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB2YXIgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkgJiYgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyBBeGlvc0Vycm9yLkVUSU1FRE9VVCA6IEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGZ1bmN0aW9uKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgKGNhbmNlbCAmJiBjYW5jZWwudHlwZSkgPyBuZXcgQ2FuY2VsZWRFcnJvcigpIDogY2FuY2VsKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbiAmJiBjb25maWcuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogY29uZmlnLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKGZ1bGxQYXRoKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBbICdodHRwJywgJ2h0dHBzJywgJ2ZpbGUnIF0uaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWxlZEVycm9yID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvcicpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuYXhpb3MuVkVSU0lPTiA9IHJlcXVpcmUoJy4vZW52L2RhdGEnKS52ZXJzaW9uO1xuYXhpb3MudG9Gb3JtRGF0YSA9IHJlcXVpcmUoJy4vaGVscGVycy90b0Zvcm1EYXRhJyk7XG5cbi8vIEV4cG9zZSBBeGlvc0Vycm9yIGNsYXNzXG5heGlvcy5BeGlvc0Vycm9yID0gcmVxdWlyZSgnLi4vbGliL2NvcmUvQXhpb3NFcnJvcicpO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuL0NhbmNlbGVkRXJyb3InKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuXG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHRoaXMucHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNhbmNlbCkge1xuICAgIGlmICghdG9rZW4uX2xpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIGwgPSB0b2tlbi5fbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICB9XG4gICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHRoaXMucHJvbWlzZS50aGVuID0gZnVuY3Rpb24ob25mdWxmaWxsZWQpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KS50aGVuKG9uZnVsZmlsbGVkKTtcblxuICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxlZEVycm9yKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICovXG5cbkNhbmNlbFRva2VuLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQpO1xuICB0aGlzLm5hbWUgPSAnQ2FuY2VsZWRFcnJvcic7XG59XG5cbnV0aWxzLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsZWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuL2J1aWxkRnVsbFBhdGgnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnT3JVcmwgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIVFRQTWV0aG9kKGlzRm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBodHRwTWV0aG9kKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2QgKyAnRm9ybSddID0gZ2VuZXJhdGVIVFRQTWV0aG9kKHRydWUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLm5hbWUgPSAnQXhpb3NFcnJvcic7XG4gIGNvZGUgJiYgKHRoaXMuY29kZSA9IGNvZGUpO1xuICBjb25maWcgJiYgKHRoaXMuY29uZmlnID0gY29uZmlnKTtcbiAgcmVxdWVzdCAmJiAodGhpcy5yZXF1ZXN0ID0gcmVxdWVzdCk7XG4gIHJlc3BvbnNlICYmICh0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2UpO1xufVxuXG51dGlscy5pbmhlcml0cyhBeGlvc0Vycm9yLCBFcnJvciwge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG52YXIgcHJvdG90eXBlID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG52YXIgZGVzY3JpcHRvcnMgPSB7fTtcblxuW1xuICAnRVJSX0JBRF9PUFRJT05fVkFMVUUnLFxuICAnRVJSX0JBRF9PUFRJT04nLFxuICAnRUNPTk5BQk9SVEVEJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFUlJfTkVUV09SSycsXG4gICdFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTJyxcbiAgJ0VSUl9ERVBSRUNBVEVEJyxcbiAgJ0VSUl9CQURfUkVTUE9OU0UnLFxuICAnRVJSX0JBRF9SRVFVRVNUJyxcbiAgJ0VSUl9DQU5DRUxFRCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goZnVuY3Rpb24oY29kZSkge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQXhpb3NFcnJvcicsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuQXhpb3NFcnJvci5mcm9tID0gZnVuY3Rpb24oZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSB7XG4gIHZhciBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuXG4gIHV0aWxzLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSk7XG5cbiAgQXhpb3NFcnJvci5jYWxsKGF4aW9zRXJyb3IsIGVycm9yLm1lc3NhZ2UsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UpO1xuXG4gIGF4aW9zRXJyb3IubmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkLFxuICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBDYW5jZWxlZEVycm9yID0gcmVxdWlyZSgnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3InKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cblxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgQ2FuY2VsZWRFcnJvcigpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNcbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZXJnZU1hcCA9IHtcbiAgICAndXJsJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnbWV0aG9kJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnZGF0YSc6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgJ2Jhc2VVUkwnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXF1ZXN0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndHJhbnNmb3JtUmVzcG9uc2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdwYXJhbXNTZXJpYWxpemVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RpbWVvdXRNZXNzYWdlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnd2l0aENyZWRlbnRpYWxzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnYWRhcHRlcic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3Jlc3BvbnNlVHlwZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3hzcmZDb29raWVOYW1lJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkhlYWRlck5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvblVwbG9hZFByb2dyZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnb25Eb3dubG9hZFByb2dyZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnZGVjb21wcmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdtYXhCb2R5TGVuZ3RoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnYmVmb3JlUmVkaXJlY3QnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc3BvcnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdodHRwc0FnZW50JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnY2FuY2VsVG9rZW4nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdzb2NrZXRQYXRoJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VFbmNvZGluZyc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3ZhbGlkYXRlU3RhdHVzJzogbWVyZ2VEaXJlY3RLZXlzXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhjb25maWcxKS5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpLCBmdW5jdGlvbiBjb21wdXRlQ29uZmlnVmFsdWUocHJvcCkge1xuICAgIHZhciBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgdmFyIGNvbmZpZ1ZhbHVlID0gbWVyZ2UocHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuL0F4aW9zRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIFtBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFXVtNYXRoLmZsb29yKHJlc3BvbnNlLnN0YXR1cyAvIDEwMCkgLSA0XSxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcbnZhciB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IHJlcXVpcmUoJy4vdHJhbnNpdGlvbmFsJyk7XG52YXIgdG9Gb3JtRGF0YSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdG9Gb3JtRGF0YScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4uL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHZhciBpc09iamVjdFBheWxvYWQgPSB1dGlscy5pc09iamVjdChkYXRhKTtcbiAgICB2YXIgY29udGVudFR5cGUgPSBoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuXG4gICAgdmFyIGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCAoaXNPYmplY3RQYXlsb2FkICYmIGNvbnRlbnRUeXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpKSB7XG4gICAgICB2YXIgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG4gICAgICByZXR1cm4gdG9Gb3JtRGF0YShpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLCBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0UGF5bG9hZCB8fCBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgdmFyIHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICB2YXIgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIHZhciBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHN0cmljdEpTT05QYXJzaW5nIHx8IChmb3JjZWRKU09OUGFyc2luZyAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiBkYXRhLmxlbmd0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHJlcXVpcmUoJy4vZW52L0Zvcm1EYXRhJylcbiAgfSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9LFxuXG4gIGhlYWRlcnM6IHtcbiAgICBjb21tb246IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICAgIH1cbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4yNy4yXCJcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuIHV0aWxzLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdHJpY3Rcbm1vZHVsZS5leHBvcnRzID0gbnVsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgdmFyIG1hdGNoID0gL14oWy0rXFx3XXsxLDI1fSkoOj9cXC9cXC98OikvLmV4ZWModXJsKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gRm9ybURhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBmb3JtRGF0YSA9IGZvcm1EYXRhIHx8IG5ldyBGb3JtRGF0YSgpO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHV0aWxzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKHZhbHVlKSB8fCB1dGlscy5pc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgPyBuZXcgQmxvYihbdmFsdWVdKSA6IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZChkYXRhLCBwYXJlbnRLZXkpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChkYXRhKSB8fCB1dGlscy5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihkYXRhKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCBpbiAnICsgcGFyZW50S2V5KTtcbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaChkYXRhKTtcblxuICAgICAgdXRpbHMuZm9yRWFjaChkYXRhLCBmdW5jdGlvbiBlYWNoKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICB2YXIgZnVsbEtleSA9IHBhcmVudEtleSA/IHBhcmVudEtleSArICcuJyArIGtleSA6IGtleTtcbiAgICAgICAgdmFyIGFycjtcblxuICAgICAgICBpZiAodmFsdWUgJiYgIXBhcmVudEtleSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKHV0aWxzLmVuZHNXaXRoKGtleSwgJ3t9JykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh1dGlscy5lbmRzV2l0aChrZXksICdbXScpICYmIChhcnIgPSB1dGlscy50b0FycmF5KHZhbHVlKSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAhdXRpbHMuaXNVbmRlZmluZWQoZWwpICYmIGZvcm1EYXRhLmFwcGVuZChmdWxsS2V5LCBjb252ZXJ0VmFsdWUoZWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1aWxkKHZhbHVlLCBmdWxsS2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKHBhcmVudEtleSwgY29udmVydFZhbHVlKGRhdGEpKTtcbiAgICB9XG4gIH1cblxuICBidWlsZChvYmopO1xuXG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zvcm1EYXRhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2Vudi9kYXRhJykudmVyc2lvbjtcbnZhciBBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi4vY29yZS9BeGlvc0Vycm9yJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIFZFUlNJT04gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnLCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIHZhciBvcHQgPSBrZXlzW2ldO1xuICAgIHZhciB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdF07XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRPcHRpb25zOiBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG52YXIga2luZE9mID0gKGZ1bmN0aW9uKGNhY2hlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih0aGluZykge1xuICAgIHZhciBzdHIgPSB0b1N0cmluZy5jYWxsKHRoaW5nKTtcbiAgICByZXR1cm4gY2FjaGVbc3RyXSB8fCAoY2FjaGVbc3RyXSA9IHN0ci5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSk7XG4gIH07XG59KShPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuZnVuY3Rpb24ga2luZE9mVGVzdCh0eXBlKSB7XG4gIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBmdW5jdGlvbiBpc0tpbmRPZih0aGluZykge1xuICAgIHJldHVybiBraW5kT2YodGhpbmcpID09PSB0eXBlO1xuICB9O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmIChpc0FycmF5QnVmZmVyKHZhbC5idWZmZXIpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmIChraW5kT2YodmFsKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzRGF0ZSA9IGtpbmRPZlRlc3QoJ0RhdGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0ZpbGUgPSBraW5kT2ZUZXN0KCdGaWxlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0ZpbGVMaXN0ID0ga2luZE9mVGVzdCgnRmlsZUxpc3QnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodGhpbmcpIHtcbiAgdmFyIHBhdHRlcm4gPSAnW29iamVjdCBGb3JtRGF0YV0nO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHxcbiAgICB0b1N0cmluZy5jYWxsKHRoaW5nKSA9PT0gcGF0dGVybiB8fFxuICAgIChpc0Z1bmN0aW9uKHRoaW5nLnRvU3RyaW5nKSAmJiB0aGluZy50b1N0cmluZygpID09PSBwYXR0ZXJuKVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNVUkxTZWFyY2hQYXJhbXMgPSBraW5kT2ZUZXN0KCdVUkxTZWFyY2hQYXJhbXMnKTtcblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqL1xuXG5mdW5jdGlvbiBpbmhlcml0cyhjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJdXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHRvRmxhdE9iamVjdChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlcikge1xuICB2YXIgcHJvcHM7XG4gIHZhciBpO1xuICB2YXIgcHJvcDtcbiAgdmFyIG1lcmdlZCA9IHt9O1xuXG4gIGRlc3RPYmogPSBkZXN0T2JqIHx8IHt9O1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZU9iaik7XG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcblxuICByZXR1cm4gZGVzdE9iajtcbn1cblxuLypcbiAqIGRldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBlbmRzIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYSBzcGVjaWZpZWQgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIHZhciBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KHRoaW5nKSB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICB2YXIgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKGlzVW5kZWZpbmVkKGkpKSByZXR1cm4gbnVsbDtcbiAgdmFyIGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xudmFyIGlzVHlwZWRBcnJheSA9IChmdW5jdGlvbihUeXBlZEFycmF5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBUeXBlZEFycmF5ICYmIHRoaW5nIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbiAgfTtcbn0pKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NLFxuICBpbmhlcml0czogaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdDogdG9GbGF0T2JqZWN0LFxuICBraW5kT2Y6IGtpbmRPZixcbiAga2luZE9mVGVzdDoga2luZE9mVGVzdCxcbiAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcbiAgaXNGaWxlTGlzdDogaXNGaWxlTGlzdFxufTtcbiIsIi8vIGV4cG9ydCAqIGZyb20gXCIuL2JhYnlsb25cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vb3JpbGx1c2lvblwiO1xyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9yZW5kZXJcIlxyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi90YWlncHVcIlxyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9keGZcIlxyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi91c2V0aHJlZVwiXHJcbiIsImltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcclxuaW1wb3J0ICogYXMgT3JpbGx1c2lvbiBmcm9tIFwiQG9yaWxsdXNpb24vY29yZVwiO1xyXG5jb25zdCBFbmdpbmUzRCA9IE9yaWxsdXNpb24uRW5naW5lM0Q7XHJcbkVuZ2luZTNELnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmdsb2JhbEZvZy5mb2dUeXBlID0gMDsgLy9MaW5lcjowLCBFeHA6MSwgRXhwMjoyXHJcbkVuZ2luZTNELnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmdsb2JhbEZvZy5zdGFydCA9IDQwMDtcclxuRW5naW5lM0Quc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ2xvYmFsRm9nLmVuZCA9IDA7XHJcbkVuZ2luZTNELnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmdsb2JhbEZvZy5mb2dIZWlnaHRTY2FsZSA9IDE7XHJcbkVuZ2luZTNELnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmdsb2JhbEZvZy5kZW5zaXR5ID0gMC4wMjtcclxuRW5naW5lM0Quc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ2xvYmFsRm9nLmlucyA9IDE7XHJcbkVuZ2luZTNELnNldHRpbmcucmVuZGVyLnBvc3RQcm9jZXNzaW5nLmdsb2JhbEZvZy5mb2dDb2xvciA9XHJcbiAgICBuZXcgT3JpbGx1c2lvbi5Db2xvcig4NCwgOTAsIDIzOSwgMjU1KTtcclxuRW5naW5lM0Quc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ2xvYmFsRm9nLnNreUZhY3RvciA9IDAuNTtcclxuRW5naW5lM0Quc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ2xvYmFsRm9nLnNreVJvdWdobmVzcyA9IDAuNDtcclxuRW5naW5lM0Quc2V0dGluZy5yZW5kZXIucG9zdFByb2Nlc3NpbmcuZ2xvYmFsRm9nLm92ZXJyaWRlU2t5RmFjdG9yID0gMC44O1xyXG5leHBvcnQgY2xhc3MgR2VvbWV0cnlNYWluIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucnVuKCk7XHJcbiAgICB9XHJcbiAgICBzY2VuZTtcclxuICAgIGhvdmVyQ2FtZXJhQ29udHJvbGxlcjtcclxuICAgIGxpZ2h0T2JqO1xyXG4gICAgYXN5bmMgcnVuKCkge1xyXG4gICAgICAgIGF3YWl0IE9yaWxsdXNpb24uRW5naW5lM0QuaW5pdCh7XHJcbiAgICAgICAgICAgIGNhbnZhc0NvbmZpZzogeyBkZXZpY2VQaXhlbFJhdGlvOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgT3JpbGx1c2lvbi5TY2VuZTNEKCk7XHJcbiAgICAgICAgbGV0IGNhbWVyYU9iaiA9IG5ldyBPcmlsbHVzaW9uLk9iamVjdDNEKCk7XHJcbiAgICAgICAgbGV0IG1haW5DYW1lcmEgPSBjYW1lcmFPYmouYWRkQ29tcG9uZW50KE9yaWxsdXNpb24uQ2FtZXJhM0QpO1xyXG4gICAgICAgIG1haW5DYW1lcmEucGVyc3BlY3RpdmUoMzcsIE9yaWxsdXNpb24ud2ViR1BVQ29udGV4dC5hc3BlY3QsIDEsIDEwMDAwLjApO1xyXG4gICAgICAgIHRoaXMuaG92ZXJDYW1lcmFDb250cm9sbGVyID0gbWFpbkNhbWVyYS5vYmplY3QzRC5hZGRDb21wb25lbnQoT3JpbGx1c2lvbi5Ib3ZlckNhbWVyYUNvbnRyb2xsZXIpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkQ2hpbGQoY2FtZXJhT2JqKTtcclxuICAgICAgICAvL3NldCBjYW1lcmEgZGF0YVxyXG4gICAgICAgIHRoaXMuaG92ZXJDYW1lcmFDb250cm9sbGVyLnNldENhbWVyYSgxMzAsIC0zMCwgMjAwMCk7XHJcbiAgICAgICAgdGhpcy5ob3ZlckNhbWVyYUNvbnRyb2xsZXIudGFyZ2V0ID0gbmV3IE9yaWxsdXNpb24uVmVjdG9yMygtMTA3MywgNjEgLSAxNTAsIDMxNCk7XHJcbiAgICAgICAgLy8gdGhpcy5pbml0U2NlbmUodGhpcy5zY2VuZSk7XHJcbiAgICAgICAgLy8gT3JpbGx1c2lvbi5BdG1vc3BoZXJpY0NvbXBvbmVudFxyXG4gICAgICAgIGxldCBza3kgPSB0aGlzLnNjZW5lLmdldE9yQWRkQ29tcG9uZW50KE9yaWxsdXNpb24uU2t5UmVuZGVyZXIpO1xyXG4gICAgICAgIC8vIHNreS5tYXAgPSBhd2FpdCBPcmlsbHVzaW9uLkVuZ2luZTNELnJlcy5sb2FkSERSVGV4dHVyZUN1YmUoXHJcbiAgICAgICAgLy8gICBcImh0dHA6Ly9sb2NhbGhvc3Q6OTk4OC9za3kva2xvb2ZlbmRhbF80OGRfcGFydGx5X2Nsb3VkeV9wdXJlc2t5XzhrLmhkclwiXHJcbiAgICAgICAgLy8gKTtcclxuICAgICAgICBza3kubWFwID0gYXdhaXQgT3JpbGx1c2lvbi5FbmdpbmUzRC5yZXMubG9hZFRleHR1cmVDdWJlU3RkKFwicHVibGljL3BpYy9waXp6b19wZXJuaWNlX3B1cmVza3lfOGsuanBnXCIpO1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIGJhc2ljIGN1YmVcclxuICAgICAgICAvLyB0aGlzLnNjZW5lLmFkZENoaWxkKFxyXG4gICAgICAgIC8vICAgT3JpbGx1c2lvbi5PYmplY3QzRFV0aWwuR2V0U2luZ2xlQ3ViZSgxMCwgMTAsIDEwLCAwLjYsIDAuNiwgMC42KVxyXG4gICAgICAgIC8vICk7XHJcbiAgICAgICAgLy8gYWRkIGFuIEF0bW9zcGhlcmljIHNreSBlbnZpcm9tZW50XHJcbiAgICAgICAgLy8gY29uc3Qgc3VuID0gdGhpcy5zY2VuZS5hZGRDb21wb25lbnQoT3JpbGx1c2lvbi5BdG1vc3BoZXJpY0NvbXBvbmVudCk7XHJcbiAgICAgICAgLy8gc3VuLnN1blkgPSAwLjY7XHJcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgdmlldyB3aXRoIHRhcmdldCBzY2VuZSBhbmQgY2FtZXJhXHJcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgT3JpbGx1c2lvbi5WaWV3M0QoKTtcclxuICAgICAgICB2aWV3LnNjZW5lID0gdGhpcy5zY2VuZTtcclxuICAgICAgICB2aWV3LmNhbWVyYSA9IG1haW5DYW1lcmE7XHJcbiAgICAgICAgLy8gc3RhcnQgcmVuZGVyXHJcbiAgICAgICAgbGV0IGRhdGExID0gYXdhaXQgT3JpbGx1c2lvbi5FbmdpbmUzRC5yZXMubG9hZEdsdGYoXCJwdWJsaWMvZ2xiL0wxOS04ay5nbGJcIik7XHJcbiAgICAgICAgZGF0YTEudHJhdmVyc2UoKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBjaGlsZC5nZXRDb21wb25lbnQoT3JpbGx1c2lvbi5NZXNoUmVuZGVyZXIpO1xyXG4gICAgICAgICAgICBpZiAobWVzaCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJtZXNoXCIsIG1lc2gubWF0ZXJpYWwuZW52TWFwID0gc2t5Lm1hcClcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIG1lc2gubWF0ZXJpYWwuZW52SW50ZW5zaXR5ID0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIOa3u+WKoOiHs+WcuuaZr1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkQ2hpbGQoZGF0YTEpO1xyXG4gICAgICAgIGxldCBkYXRhMiA9IGF3YWl0IE9yaWxsdXNpb24uRW5naW5lM0QucmVzLmxvYWRHbHRmKFwicHVibGljL2dsYi9kLTA5MDcuZ2xiXCIpO1xyXG4gICAgICAgIGRhdGEyLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNoID0gY2hpbGQuZ2V0Q29tcG9uZW50KE9yaWxsdXNpb24uTWVzaFJlbmRlcmVyKTtcclxuICAgICAgICAgICAgaWYgKG1lc2gpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWVzaFwiLCBtZXNoLm1hdGVyaWFsLmVudk1hcCA9IHNreS5tYXApXHJcbiAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsLmJsZW5kTW9kZSA9IE9yaWxsdXNpb24uQmxlbmRNb2RlLk5PUk1BTDtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIG1lc2gubWF0ZXJpYWwuYWxwaGFDdXRvZmYgPSAwLjE7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsLmJhc2VDb2xvci5hID0gMC4zO1xyXG4gICAgICAgICAgICAgICAgbWVzaC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsLmVudkludGVuc2l0eSA9IDAuMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRhdGEyLmxvY2FsUG9zaXRpb24gPSBuZXcgT3JpbGx1c2lvbi5WZWN0b3IzKC03NDUsIDEyLCA0MzApO1xyXG4gICAgICAgIGRhdGEyLmxvY2FsUm90YXRpb24gPSBuZXcgT3JpbGx1c2lvbi5WZWN0b3IzKDAsICgyLjYzNTQ0NzE3MDUxMTQ0ICogMTgwKSAvIE1hdGguUEksIDApO1xyXG4gICAgICAgIGRhdGEyLmxvY2FsU2NhbGUgPSBuZXcgT3JpbGx1c2lvbi5WZWN0b3IzKDEuMDQsIDEsIDEuMDQpO1xyXG4gICAgICAgIC8vIOa3u+WKoOiHs+WcuuaZr1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkQ2hpbGQoZGF0YTIpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZW52TWFwID0gc2t5Lm1hcDtcclxuICAgICAgICAvLyAgIE9yaWxsdXNpb24uRW5naW5lM0QucGF1c2UoKTtcclxuICAgICAgICAvLyAgIC8vIOaBouWkjea4suafk+W+queOr1xyXG4gICAgICAgIC8vICAgT3JpbGx1c2lvbi5FbmdpbmUzRC5yZXN1bWUoKTtcclxuICAgICAgICAvLyB9LCAxMDAwICogNCk7XHJcbiAgICAgICAgLy8gbGV0IHBvc3RQcm9jZXNzaW5nID0gdGhpcy5zY2VuZS5hZGRDb21wb25lbnQoXHJcbiAgICAgICAgLy8gICBPcmlsbHVzaW9uLlBvc3RQcm9jZXNzaW5nQ29tcG9uZW50XHJcbiAgICAgICAgLy8gKTtcclxuICAgICAgICAvLyBwb3N0UHJvY2Vzc2luZy5hZGRQb3N0KE9yaWxsdXNpb24uR2xvYmFsRm9nKTtcclxuICAgICAgICBPcmlsbHVzaW9uLkVuZ2luZTNELnN0YXJ0UmVuZGVyVmlldyh2aWV3KTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pbml0U2NlbmUodGhpcy5zY2VuZSk7XHJcbiAgICAgICAgfSwgMTAwMCAqIDAuMik7XHJcbiAgICB9XHJcbiAgICBsaWdodDtcclxuICAgIGFzeW5jIGluaXRTY2VuZShzY2VuZSkge1xyXG4gICAgICAgIGxldCBkaXJMaWdodCA9IG5ldyBPcmlsbHVzaW9uLk9iamVjdDNEKCk7XHJcbiAgICAgICAgZGlyTGlnaHQucm90YXRpb25YID0gNjA7XHJcbiAgICAgICAgZGlyTGlnaHQucm90YXRpb25ZID0gMzA7XHJcbiAgICAgICAgZGlyTGlnaHQucm90YXRpb25aID0gMzA7XHJcbiAgICAgICAgdGhpcy5saWdodCA9IGRpckxpZ2h0LmFkZENvbXBvbmVudChPcmlsbHVzaW9uLkRpcmVjdExpZ2h0KTtcclxuICAgICAgICB0aGlzLmxpZ2h0LmludGVuc2l0eSA9IDEwMDtcclxuICAgICAgICAvLyBsaWdodC5saWdodENvbG9yLnIgPSAyNTUgLyAyNTVcclxuICAgICAgICAvLyBsaWdodC5saWdodENvbG9yLmcgPSAxNTcgLyAyNTVcclxuICAgICAgICAvLyBsaWdodC5saWdodENvbG9yLmIgPSA1IC8gMjU1XHJcbiAgICAgICAgc2NlbmUuYWRkQ2hpbGQoZGlyTGlnaHQpO1xyXG4gICAgICAgIC8vIGxldCBHVUlIZWxwID0gbmV3IGRhdC5HVUkoKTtcclxuICAgICAgICAvLyBHVUlIZWxwLmFkZEZvbGRlcihcIkRpcmVjdCBMaWdodFwiKTtcclxuICAgICAgICAvLyBHVUlIZWxwLmFkZChkaXJMaWdodCwgXCJyb3RhdGlvblhcIiwgLTE4MCwgMTgwLCAxKTtcclxuICAgICAgICAvLyBHVUlIZWxwLmFkZChkaXJMaWdodCwgXCJyb3RhdGlvbllcIiwgLTE4MCwgMTgwLCAxKTtcclxuICAgICAgICAvLyBHVUlIZWxwLmFkZChkaXJMaWdodCwgXCJyb3RhdGlvblpcIiwgLTE4MCwgMTgwLCAxKTtcclxuICAgICAgICAvLyBHVUlIZWxwLmFkZENvbG9yKFxyXG4gICAgICAgIC8vICAgeyBjb2xvcjogT2JqZWN0LnZhbHVlcyh0aGlzLmxpZ2h0LmxpZ2h0Q29sb3IpLm1hcCgodikgPT4gdiAqIDI1NSkgfSxcclxuICAgICAgICAvLyAgIFwiY29sb3JcIlxyXG4gICAgICAgIC8vICkub25DaGFuZ2UoKHYpID0+IHtcclxuICAgICAgICAvLyAgIHRoaXMubGlnaHQubGlnaHRDb2xvci5jb3B5RnJvbUFycmF5KHYpO1xyXG4gICAgICAgIC8vIH0pO1xyXG4gICAgICAgIC8vIEdVSUhlbHAuYWRkKHRoaXMubGlnaHQsIFwiaW50ZW5zaXR5XCIsIDAsIDIwMCwgMSk7XHJcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAgICAgbGV0IG1hdCA9IG5ldyBPcmlsbHVzaW9uLkxpdE1hdGVyaWFsKCk7XHJcbiAgICAgICAgbWF0LmJhc2VNYXAgPSBPcmlsbHVzaW9uLkVuZ2luZTNELnJlcy5ncmF5VGV4dHVyZTtcclxuICAgICAgICBsZXQgZmxvb3IgPSBuZXcgT3JpbGx1c2lvbi5PYmplY3QzRCgpO1xyXG4gICAgICAgIGxldCBtciA9IGZsb29yLmFkZENvbXBvbmVudChPcmlsbHVzaW9uLk1lc2hSZW5kZXJlcik7XHJcbiAgICAgICAgLy8gbXIuZ2VvbWV0cnkgPSBuZXcgT3JpbGx1c2lvbi5Cb3hHZW9tZXRyeSgyMDAwLCAxLCAyMDAwKTtcclxuICAgICAgICBtci5nZW9tZXRyeSA9IG5ldyBPcmlsbHVzaW9uLkJveEdlb21ldHJ5KDI0NTAsIDEsIDQ0NTApO1xyXG4gICAgICAgIG1yLm1hdGVyaWFsID0gbWF0O1xyXG4gICAgICAgIGZsb29yLmxvY2FsUm90YXRpb24gPSBuZXcgT3JpbGx1c2lvbi5WZWN0b3IzKDAsICgtMC40ODg2OTIxOTA1NTg0MTIgKiAxODApIC8gTWF0aC5QSSwgMCk7XHJcbiAgICAgICAgZmxvb3IubG9jYWxQb3NpdGlvbiA9IG5ldyBPcmlsbHVzaW9uLlZlY3RvcjMoLTIyMTYsIDI2LCAyMTUwKTtcclxuICAgICAgICB0aGlzLnNjZW5lLmFkZENoaWxkKGZsb29yKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZmxvb3I6ICcsIGZsb29yKTtcclxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAgICAgLy8gY29uc3QgZWFzdDAgPSBhd2FpdCB0aGlzLmFkZE1lc2goXCJwdWJsaWMvanNvbi8wLmpzb25cIik7XHJcbiAgICAgICAgLy8gY29uc3QgZWFzdDExID0gYXdhaXQgdGhpcy5hZGRNZXNoKFwicHVibGljL2pzb24vMTEuanNvblwiKTtcclxuICAgICAgICBjb25zdCBlYXN0MTkgPSBhd2FpdCB0aGlzLmFkZE1lc2goXCJwdWJsaWMvanNvbi8xOS5qc29uXCIpO1xyXG4gICAgICAgIC8vIGNvbnN0IGVhc3QyNiA9IGF3YWl0IHRoaXMuYWRkTWVzaChcInB1YmxpYy9qc29uLzI2Lmpzb25cIik7XHJcbiAgICAgICAgLy8gY29uc3QgZWFzdDI4ID0gYXdhaXQgdGhpcy5hZGRNZXNoKFwicHVibGljL2pzb24vMjguanNvblwiKTtcclxuICAgICAgICAvLyBjb25zdCBlYXN0MzEgPSBhd2FpdCB0aGlzLmFkZE1lc2goXCJwdWJsaWMvanNvbi8zMS5qc29uXCIpO1xyXG4gICAgICAgIC8vIGNvbnN0IF9saXN0ID0gW2Vhc3QwLCBlYXN0MTEsIGVhc3QxOSwgZWFzdDI2LCBlYXN0MjgsIGVhc3QzMV07XHJcbiAgICAgICAgLy8gLy8gY29uc3QgX2xpc3QgPSBbZWFzdDMxXVxyXG4gICAgICAgIC8vIC8vIGVhc3QxMS5nZXRDb21wb25lbnQoT3JpbGx1c2lvbi5NZXNoUmVuZGVyZXIpLmVuYWJsZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5zY2VuZS51cGRhdGUoKTtcclxuICAgICAgICAvLyAvLyB0aGlzLnNjZW5lLnJlbW92ZUNoaWxkKGVhc3QyNik7XHJcbiAgICAgICAgLy8gX2xpc3QuZm9yRWFjaCgoX2l0ZW0pID0+IHtcclxuICAgICAgICAvLyAgIF9pdGVtLmdldENvbXBvbmVudChPcmlsbHVzaW9uLk1lc2hSZW5kZXJlcikuZW5hYmxlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgLy8gX2xpc3RbMF0uZ2V0Q29tcG9uZW50KE9yaWxsdXNpb24uTWVzaFJlbmRlcmVyKS5lbmFibGUgPSB0cnVlO1xyXG4gICAgICAgIC8vIGxldCBfaW5kZXggPSAwO1xyXG4gICAgICAgIC8vIHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAvLyAgIF9saXN0LmZvckVhY2goKF9pdGVtKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIF9pdGVtLmdldENvbXBvbmVudChPcmlsbHVzaW9uLk1lc2hSZW5kZXJlcikuZW5hYmxlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gICB9KTtcclxuICAgICAgICAvLyAgIF9saXN0W19pbmRleF0uZ2V0Q29tcG9uZW50KE9yaWxsdXNpb24uTWVzaFJlbmRlcmVyKS5lbmFibGUgPSB0cnVlO1xyXG4gICAgICAgIC8vICAgX2luZGV4Kys7XHJcbiAgICAgICAgLy8gICBfaW5kZXggPSBfaW5kZXggJSBfbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgLy8gfSwgMTAwMCAqIDAuNSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBhZGRNZXNoKHVybCA9IFwicHVibGljL2pzb24vMTEuanNvblwiKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YU1lc2ggPSAoYXdhaXQgYXhpb3MuZ2V0KHVybCkpLmRhdGE7XHJcbiAgICAgICAgbGV0IGVhc3QgPSBuZXcgT3JpbGx1c2lvbi5PYmplY3QzRCgpO1xyXG4gICAgICAgIGxldCBlYXN0TVIgPSBlYXN0LmFkZENvbXBvbmVudChPcmlsbHVzaW9uLk1lc2hSZW5kZXJlcik7XHJcbiAgICAgICAgbGV0IGVhc3RHZW8gPSBuZXcgT3JpbGx1c2lvbi5HZW9tZXRyeUJhc2UoKTtcclxuICAgICAgICBlYXN0R2VvLnNldEF0dHJpYnV0ZShPcmlsbHVzaW9uLlZlcnRleEF0dHJpYnV0ZU5hbWUucG9zaXRpb24sIG5ldyBGbG9hdDMyQXJyYXkoZGF0YU1lc2guZGF0YS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5KSk7XHJcbiAgICAgICAgZWFzdEdlby5zZXRBdHRyaWJ1dGUoXCJORUtPWVVVXCIsIG5ldyBGbG9hdDMyQXJyYXkoZGF0YU1lc2guZGF0YS5hdHRyaWJ1dGVzW1wiREVQTF9fX19ERVBMXCJdLmFycmF5KSk7XHJcbiAgICAgICAgLy8gZWFzdEdlby52ZXJ0ZXhCdWZmZXJcclxuICAgICAgICBlYXN0R2VvLnNldEluZGljZXMobmV3IFVpbnQxNkFycmF5KGRhdGFNZXNoLmRhdGEuaW5kZXguYXJyYXkpKTtcclxuICAgICAgICBlYXN0R2VvLmFkZFN1Ykdlb21ldHJ5KHtcclxuICAgICAgICAgICAgaW5kZXhTdGFydDogMCxcclxuICAgICAgICAgICAgaW5kZXhDb3VudDogZGF0YU1lc2guZGF0YS5pbmRleC5hcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHZlcnRleFN0YXJ0OiAwLFxyXG4gICAgICAgICAgICBpbmRleDogMCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBlYXN0R2VvLmNvbXB1dGVOb3JtYWxzKCk7XHJcbiAgICAgICAgZWFzdE1SLmdlb21ldHJ5ID0gZWFzdEdlbztcclxuICAgICAgICBjb25zdCBjdXN0b21NYXRlcmlhbCA9IG5ldyBPcmlsbHVzaW9uLkxhbWJlcnRNYXRlcmlhbCgpO1xyXG4gICAgICAgIGN1c3RvbU1hdGVyaWFsLmRvdWJsZVNpZGUgPSB0cnVlO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBjdXN0b21NYXRlcmlhbC5fZGVmYXVsdFBhc3MuX3NvdXJjZUZTID0gLyp3Z3NsKi8gYFxyXG4gICAgI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcclxuICAgIHN0cnVjdCBGcmFnbWVudFZhcnlpbmcge1xyXG4gICAgICBAbG9jYXRpb24oMCkgZnJhZ1VWMDogdmVjMjxmMzI+LFxyXG4gICAgICBAbG9jYXRpb24oMSkgZnJhZ1VWMTogdmVjMjxmMzI+LFxyXG4gICAgICBAbG9jYXRpb24oMikgdmlld1Bvc2l0aW9uOiB2ZWM0PGYzMj4sXHJcbiAgICAgIEBsb2NhdGlvbigzKSBmcmFnUG9zaXRpb246IHZlYzQ8ZjMyPixcclxuICAgICAgQGxvY2F0aW9uKDQpIHZXb3JsZFBvczogdmVjNDxmMzI+LFxyXG4gICAgICBAbG9jYXRpb24oNSkgdldvcmxkTm9ybWFsOiB2ZWMzPGYzMj4sXHJcbiAgICAgIEBsb2NhdGlvbig2KSBUQUk6IGYzMixcclxuICAgICAgLy8gQGxvY2F0aW9uKDYpIHZDb2xvcjogdmVjNDxmMzI+LFxyXG5cclxuICAgICAgI2lmIFVTRV9TSEFET1dNQVBJTkdcclxuICAgICAgICAgIEBsb2NhdGlvbig3KSB2U2hhZG93UG9zOiB2ZWM0PGYzMj4sXHJcbiAgICAgICNlbmRpZlxyXG5cclxuICAgICAgI2lmIFVTRV9UQU5HRU5UXHJcbiAgICAgICAgICBAbG9jYXRpb24oOCkgVEFOR0VOVDogdmVjNDxmMzI+LFxyXG4gICAgICAjZW5kaWZcclxuICAgICAgXHJcbiAgICAgIEBidWlsdGluKGZyb250X2ZhY2luZykgZmFjZTogYm9vbCxcclxuICAgICAgQGJ1aWx0aW4ocG9zaXRpb24pIGZyYWdDb29yZCA6IHZlYzQ8ZjMyPlxyXG4gIH07XHJcbiAgICAjaW5jbHVkZSBcIkNvbG9yUGFzc0ZyYWdtZW50T3V0cHV0XCJcclxuICAgICNpbmNsdWRlIFwiU2hhZGluZ0lucHV0XCJcclxuXHJcbiAgICBjb25zdCBjb2xvcmJhcjogYXJyYXk8ZjMyLCA2Mz4gPSBhcnJheTxmMzIsIDYzPigwLjAxOTYwNzg0MzEzNzI1NDksIDAuMzgwMzkyMTU2ODYyNzQ1MSwgMC45OTYwNzg0MzEzNzI1NDksIDAuMDE5NjA3ODQzMTM3MjU0OSwgMC40NzA1ODgyMzUyOTQxMTc2NCwgMC45MzMzMzMzMzMzMzMzMzMzLCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNTUyOTQxMTc2NDcwNTg4MywgMC44NjI3NDUwOTgwMzkyMTU3LCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNjI3NDUwOTgwMzkyMTU2OSwgMC43ODAzOTIxNTY4NjI3NDUxLCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNjk4MDM5MjE1Njg2Mjc0NSwgMC42ODIzNTI5NDExNzY0NzA2LCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNzcyNTQ5MDE5NjA3ODQzMiwgMC41NzY0NzA1ODgyMzUyOTQxLCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuODUwOTgwMzkyMTU2ODYyNywgMC40NTQ5MDE5NjA3ODQzMTM3LCAwLjAxNTY4NjI3NDUwOTgwMzkyLCAwLjkxNzY0NzA1ODgyMzUyOTQsIDAuMzA5ODAzOTIxNTY4NjI3NDYsIDAuNDQ3MDU4ODIzNTI5NDExOCwgMC45NTY4NjI3NDUwOTgwMzkzLCAwLjExNzY0NzA1ODgyMzUyOTQxLCAwLjc0OTAxOTYwNzg0MzEzNzMsIDAuOTgwMzkyMTU2ODYyNzQ1MSwgMC4wMzUyOTQxMTc2NDcwNTg4MiwgMC45OTYwNzg0MzEzNzI1NDksIDAuOTk2MDc4NDMxMzcyNTQ5LCAwLjAxMTc2NDcwNTg4MjM1Mjk0MSwgMC45OTYwNzg0MzEzNzI1NDksIDAuOTA1ODgyMzUyOTQxMTc2NSwgMC4xNTI5NDExNzY0NzA1ODgyNSwgMC45OTYwNzg0MzEzNzI1NDksIDAuODA3ODQzMTM3MjU0OTAyLCAwLjIxNTY4NjI3NDUwOTgwMzkzLCAwLjk5NjA3ODQzMTM3MjU0OSwgMC43MDU4ODIzNTI5NDExNzY1LCAwLjIxNTY4NjI3NDUwOTgwMzkzLCAwLjk5NjA3ODQzMTM3MjU0OSwgMC42MDM5MjE1Njg2Mjc0NTA5LCAwLjIxNTY4NjI3NDUwOTgwMzkzLCAwLjk5NjA3ODQzMTM3MjU0OSwgMC40OTAxOTYwNzg0MzEzNzI1MywgMC4yMTU2ODYyNzQ1MDk4MDM5MywgMC45OTYwNzg0MzEzNzI1NDksIDAuMzYwNzg0MzEzNzI1NDkwMiwgMC4yMTE3NjQ3MDU4ODIzNTI5NCwgMC45ODgyMzUyOTQxMTc2NDcxLCAwLjE4MDM5MjE1Njg2Mjc0NTEsIDAuMjAzOTIxNTY4NjI3NDUwOTgsIDAuOTA5ODAzOTIxNTY4NjI3NCwgMC4wODYyNzQ1MDk4MDM5MjE1NywgMC4yODIzNTI5NDExNzY0NzA2LCAwLjgwMzkyMTU2ODYyNzQ1MSwgMC4wMzkyMTU2ODYyNzQ1MDk4LCAwLjM1Mjk0MTE3NjQ3MDU4ODI2LCAwLjY4MjM1Mjk0MTE3NjQ3MDYsIDAuMDQ3MDU4ODIzNTI5NDExNzY0LCAwLjQxMTc2NDcwNTg4MjM1MjkpO1xyXG4gICAgdmFyPHByaXZhdGU+IE9SSV9GcmFnbWVudE91dHB1dDogRnJhZ21lbnRPdXRwdXQ7XHJcbiAgICB2YXI8cHJpdmF0ZT4gT1JJX1ZlcnRleFZhcnlpbmc6IEZyYWdtZW50VmFyeWluZztcclxuICAgIHZhcjxwcml2YXRlPiBPUklfU2hhZGluZ0lucHV0OiBTaGFkaW5nSW5wdXQ7XHJcbiAgICB2YXI8cHJpdmF0ZT4gdmlld0Rpcjp2ZWMzPGYzMj47XHJcbiAgICBAZnJhZ21lbnRcclxuICAgIGZuIEZyYWdNYWluKCB2ZXJ0ZXhfdmFyeWluZzpGcmFnbWVudFZhcnlpbmcgKSAtPiBGcmFnbWVudE91dHB1dCB7XHJcbiAgICAgIFxyXG4gICAgICAvLyBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4odmVydGV4X3ZhcnlpbmcudkNvbG9yLnIsIHZlcnRleF92YXJ5aW5nLnZDb2xvci5nLHZlcnRleF92YXJ5aW5nLnZDb2xvci5iLDEuKTtcclxuXHJcbiAgICAgIFxyXG4gICAgICB2YXIgbWF4VmFsdWU6IGYzMiA9IDAuMDI0MDcxNzY2MjEyNzUxNjI7XHJcbiAgICAgIHZhciBtaW5WYWx1ZTogZjMyID0gMC4wMDA1Mjg3MDM0OTY5OTk4MDI1O1xyXG4gICAgICB2YXIgc2NhbGFyID0gKHZlcnRleF92YXJ5aW5nLlRBSSAtIG1pblZhbHVlKSAvIChtYXhWYWx1ZSAtIG1pblZhbHVlKTtcclxuICAgICAgaWYoc2NhbGFyPD0wLil7XHJcbiAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KFxyXG4gICAgICAgICAgY29sb3JiYXJbMF0sIFxyXG4gICAgICAgICAgY29sb3JiYXJbMV0sIFxyXG4gICAgICAgICAgY29sb3JiYXJbMl0sIFxyXG4gICAgICAgIDEuKTtcclxuICAgICAgfWVsc2UgaWYoc2NhbGFyPj0xLil7XHJcbiAgICAgICAgT1JJX0ZyYWdtZW50T3V0cHV0LmNvbG9yID0gdmVjNDxmMzI+KFxyXG4gICAgICAgICAgY29sb3JiYXJbNjBdLCBcclxuICAgICAgICAgIGNvbG9yYmFyWzYxXSwgXHJcbiAgICAgICAgICBjb2xvcmJhcls2Ml0sIFxyXG4gICAgICAgIDEuKTtcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gaTMyKGZsb29yKHNjYWxhciogMjApKTtcclxuICAgICAgICB2YXIgaW5kZXgxID0gaW5kZXggKyAxO1xyXG4gICAgICAgIHZhciBtaXhWYWx1ZSA9IHNjYWxhciogMjAgLSBmbG9vcihzY2FsYXIqIDIwKTtcclxuICAgICAgICBPUklfRnJhZ21lbnRPdXRwdXQuY29sb3IgPSB2ZWM0PGYzMj4oXHJcbiAgICAgICAgICBjb2xvcmJhcltpbmRleDEgKiAzXSAqIG1peFZhbHVlICsgKDEuIC0gbWl4VmFsdWUpICogY29sb3JiYXJbaW5kZXggKiAzXSwgXHJcbiAgICAgICAgICBjb2xvcmJhcltpbmRleDEgKiAzICsgMV0gKiBtaXhWYWx1ZSArICgxLiAtIG1peFZhbHVlKSAqIGNvbG9yYmFyW2luZGV4ICogMyArMV0sXHJcbiAgICAgICAgICBjb2xvcmJhcltpbmRleDEgKiAzICsgMl0gKiBtaXhWYWx1ZSArICgxLiAtIG1peFZhbHVlKSAqIGNvbG9yYmFyW2luZGV4ICogMyArIDJdLFxyXG4gICAgICAgIDEuKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gT1JJX0ZyYWdtZW50T3V0cHV0IDtcclxuICAgIH1cclxuXHJcbmA7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGN1c3RvbU1hdGVyaWFsLl9kZWZhdWx0UGFzcy5fc291cmNlVlMgPVxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGN1c3RvbU1hdGVyaWFsLl9kZWZhdWx0UGFzcy5fc291cmNlVlMucmVwbGFjZSgnI2luY2x1ZGUgXCJDb21tb25fZnJhZ1wiJywgXCJcIik7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGN1c3RvbU1hdGVyaWFsLl9kZWZhdWx0UGFzcy5fc291cmNlVlMgPVxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGN1c3RvbU1hdGVyaWFsLl9kZWZhdWx0UGFzcy5fc291cmNlVlMucmVwbGFjZSgnI2luY2x1ZGUgXCJDb21tb25fdmVydFwiJywgXHJcbiAgICAgICAgICAgIC8qd2dzbCovIGBcclxuICAgICNpbmNsdWRlIFwiV29ybGRNYXRyaXhVbmlmb3JtXCJcclxuXHJcbiAgICBzdHJ1Y3QgVmVydGV4QXR0cmlidXRlc3tcclxuICAgIEBidWlsdGluKGluc3RhbmNlX2luZGV4KSBpbmRleCA6IHUzMixcclxuICAgIEBsb2NhdGlvbigwKSBwb3NpdGlvbjogdmVjMzxmMzI+LFxyXG4gICAgQGxvY2F0aW9uKDEpIG5vcm1hbDogdmVjMzxmMzI+LFxyXG4gICAgQGxvY2F0aW9uKDIpIHV2OiB2ZWMyPGYzMj4sXHJcbiAgICBAbG9jYXRpb24oMykgTkVLT1lVVTogZjMyLFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdHJ1Y3QgVmVydGV4T3V0cHV0IHtcclxuICAgIEBsb2NhdGlvbigwKSB2YXJ5aW5nX1VWMDogdmVjMjxmMzI+LFxyXG4gICAgQGxvY2F0aW9uKDEpIHZhcnlpbmdfVVYxOiB2ZWMyPGYzMj4sXHJcbiAgICBAbG9jYXRpb24oMikgdmFyeWluZ19WaWV3UG9zOiB2ZWM0PGYzMj4sXHJcbiAgICBAbG9jYXRpb24oMykgdmFyeWluZ19DbGlwOiB2ZWM0PGYzMj4sXHJcbiAgICBAbG9jYXRpb24oNCkgdmFyeWluZ19XUG9zOiB2ZWM0PGYzMj4sXHJcbiAgICBAbG9jYXRpb24oNSkgdmFyeWluZ19XTm9ybWFsOiB2ZWMzPGYzMj4sXHJcbiAgICBAbG9jYXRpb24oNikgVEFJOiBmMzIsXHJcbiAgICAvLyBAbG9jYXRpb24oNikgdmFyeWluZ19Db2xvcjogdmVjNDxmMzI+LFxyXG4gICAgQGJ1aWx0aW4ocG9zaXRpb24pIG1lbWJlcjogdmVjNDxmMzI+XHJcbiAgICB9O1xyXG5cclxuICAgIHZhcjxwcml2YXRlPiBPUklfVmVydGV4T3V0OiBWZXJ0ZXhPdXRwdXQgO1xyXG5cclxuICAgIGZuIE9SSV9WZXJ0KHZlcnRleDpWZXJ0ZXhBdHRyaWJ1dGVzKXtcclxuICAgIHZhciB2ZXJ0ZXhQb3NpdGlvbiA9IHZlcnRleC5wb3NpdGlvbjtcclxuICAgIHZhciB2ZXJ0ZXhOb3JtYWwgPSB2ZXJ0ZXgubm9ybWFsO1xyXG5cclxuXHJcbiAgICAjaWYgVVNFX1NLRUxFVE9OXHJcbiAgICAgICAgI2lmIFVTRV9KT0lOVF9WRUM4XHJcbiAgICAgICAgICAgIGxldCBza2VsZXRvbk5vcm1hbCA9IGdldFNrZWxldG9uV29ybGRNYXRyaXhfOCh2ZXJ0ZXguam9pbnRzMCwgdmVydGV4LndlaWdodHMwLCB2ZXJ0ZXguam9pbnRzMSwgdmVydGV4LndlaWdodHMxKTtcclxuICAgICAgICAgICAgT1JJX01BVFJJWF9NICo9IHNrZWxldG9uTm9ybWFsIDtcclxuICAgICAgICAjZWxzZVxyXG4gICAgICAgICAgICBsZXQgc2tlbGV0b25Ob3JtYWwgPSBnZXRTa2VsZXRvbldvcmxkTWF0cml4XzQodmVydGV4LmpvaW50czAsIHZlcnRleC53ZWlnaHRzMCk7XHJcbiAgICAgICAgICAgIE9SSV9NQVRSSVhfTSAqPSBza2VsZXRvbk5vcm1hbCA7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgVVNFX1RBTkdFTlRcclxuICAgICAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfVGFuZ2VudCA9IHZlcnRleC5UQU5HRU5UIDtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIE9SSV9OT1JNQUxNQVRSSVggPSB0cmFuc3Bvc2UoaW52ZXJzZSggbWF0M3gzPGYzMj4oT1JJX01BVFJJWF9NWzBdLnh5eixPUklfTUFUUklYX01bMV0ueHl6LE9SSV9NQVRSSVhfTVsyXS54eXopICkpO1xyXG5cclxuICAgIHZhciB3b3JsZFBvcyA9IChPUklfTUFUUklYX00gKiB2ZWM0PGYzMj4odmVydGV4UG9zaXRpb24ueHl6LCAxLjApKTtcclxuICAgIHZhciB2aWV3UG9zaXRpb24gPSBPUklfTUFUUklYX1YgKiB3b3JsZFBvcztcclxuICAgIHZhciBjbGlwUG9zaXRpb24gPSBPUklfTUFUUklYX1AgKiB2aWV3UG9zaXRpb24gO1xyXG5cclxuICAgIE9SSV9DYW1lcmFXb3JsZERpciA9IG5vcm1hbGl6ZShPUklfQ0FNRVJBTUFUUklYWzNdLnh5eiAtIHdvcmxkUG9zLnh5eikgO1xyXG5cclxuICAgIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19VVjAgPSB2ZXJ0ZXgudXYueHkgO1xyXG4gICAgT1JJX1ZlcnRleE91dC52YXJ5aW5nX1ZpZXdQb3MgPSB2aWV3UG9zaXRpb24gO1xyXG4gICAgT1JJX1ZlcnRleE91dC52YXJ5aW5nX0NsaXAgPSBjbGlwUG9zaXRpb24gO1xyXG4gICAgT1JJX1ZlcnRleE91dC52YXJ5aW5nX1dQb3MgPSB3b3JsZFBvcyA7XHJcbiAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfV1Bvcy53ID0gZjMyKHZlcnRleC5pbmRleCk7XHJcbiAgICBPUklfVmVydGV4T3V0LnZhcnlpbmdfV05vcm1hbCA9IG5vcm1hbGl6ZShPUklfTk9STUFMTUFUUklYICogdmVydGV4Tm9ybWFsLnh5eikgO1xyXG5cclxuICAgIE9SSV9WZXJ0ZXhPdXQubWVtYmVyID0gY2xpcFBvc2l0aW9uIDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb2xvcmJhcjogYXJyYXk8ZjMyLCA2Mz4gPSBhcnJheTxmMzIsIDYzPigwLjAxOTYwNzg0MzEzNzI1NDksIDAuMzgwMzkyMTU2ODYyNzQ1MSwgMC45OTYwNzg0MzEzNzI1NDksIDAuMDE5NjA3ODQzMTM3MjU0OSwgMC40NzA1ODgyMzUyOTQxMTc2NCwgMC45MzMzMzMzMzMzMzMzMzMzLCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNTUyOTQxMTc2NDcwNTg4MywgMC44NjI3NDUwOTgwMzkyMTU3LCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNjI3NDUwOTgwMzkyMTU2OSwgMC43ODAzOTIxNTY4NjI3NDUxLCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNjk4MDM5MjE1Njg2Mjc0NSwgMC42ODIzNTI5NDExNzY0NzA2LCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuNzcyNTQ5MDE5NjA3ODQzMiwgMC41NzY0NzA1ODgyMzUyOTQxLCAwLjAxOTYwNzg0MzEzNzI1NDksIDAuODUwOTgwMzkyMTU2ODYyNywgMC40NTQ5MDE5NjA3ODQzMTM3LCAwLjAxNTY4NjI3NDUwOTgwMzkyLCAwLjkxNzY0NzA1ODgyMzUyOTQsIDAuMzA5ODAzOTIxNTY4NjI3NDYsIDAuNDQ3MDU4ODIzNTI5NDExOCwgMC45NTY4NjI3NDUwOTgwMzkzLCAwLjExNzY0NzA1ODgyMzUyOTQxLCAwLjc0OTAxOTYwNzg0MzEzNzMsIDAuOTgwMzkyMTU2ODYyNzQ1MSwgMC4wMzUyOTQxMTc2NDcwNTg4MiwgMC45OTYwNzg0MzEzNzI1NDksIDAuOTk2MDc4NDMxMzcyNTQ5LCAwLjAxMTc2NDcwNTg4MjM1Mjk0MSwgMC45OTYwNzg0MzEzNzI1NDksIDAuOTA1ODgyMzUyOTQxMTc2NSwgMC4xNTI5NDExNzY0NzA1ODgyNSwgMC45OTYwNzg0MzEzNzI1NDksIDAuODA3ODQzMTM3MjU0OTAyLCAwLjIxNTY4NjI3NDUwOTgwMzkzLCAwLjk5NjA3ODQzMTM3MjU0OSwgMC43MDU4ODIzNTI5NDExNzY1LCAwLjIxNTY4NjI3NDUwOTgwMzkzLCAwLjk5NjA3ODQzMTM3MjU0OSwgMC42MDM5MjE1Njg2Mjc0NTA5LCAwLjIxNTY4NjI3NDUwOTgwMzkzLCAwLjk5NjA3ODQzMTM3MjU0OSwgMC40OTAxOTYwNzg0MzEzNzI1MywgMC4yMTU2ODYyNzQ1MDk4MDM5MywgMC45OTYwNzg0MzEzNzI1NDksIDAuMzYwNzg0MzEzNzI1NDkwMiwgMC4yMTE3NjQ3MDU4ODIzNTI5NCwgMC45ODgyMzUyOTQxMTc2NDcxLCAwLjE4MDM5MjE1Njg2Mjc0NTEsIDAuMjAzOTIxNTY4NjI3NDUwOTgsIDAuOTA5ODAzOTIxNTY4NjI3NCwgMC4wODYyNzQ1MDk4MDM5MjE1NywgMC4yODIzNTI5NDExNzY0NzA2LCAwLjgwMzkyMTU2ODYyNzQ1MSwgMC4wMzkyMTU2ODYyNzQ1MDk4LCAwLjM1Mjk0MTE3NjQ3MDU4ODI2LCAwLjY4MjM1Mjk0MTE3NjQ3MDYsIDAuMDQ3MDU4ODIzNTI5NDExNzY0LCAwLjQxMTc2NDcwNTg4MjM1MjkpO1xyXG4gICAgI2luY2x1ZGUgXCJHbG9iYWxVbmlmb3JtXCJcclxuICAgICNpbmNsdWRlIFwiSW5saW5lX3ZlcnRcIlxyXG4gICAgQHZlcnRleFxyXG4gICAgZm4gVmVydE1haW4oIHZlcnRleDpWZXJ0ZXhBdHRyaWJ1dGVzICkgLT4gVmVydGV4T3V0cHV0IHtcclxuICAgICAgICB2ZXJ0ZXhfaW5saW5lKHZlcnRleCk7XHJcbiAgICAgICAgdmVydCh2ZXJ0ZXgpO1xyXG4gICAgICAgIC8vIHZhciBtYXhWYWx1ZTogZjMyID0gMC4wMjQwNzE3NjYyMTI3NTE2MjtcclxuICAgICAgICAvLyB2YXIgbWluVmFsdWU6IGYzMiA9IDAuMDAwNTI4NzAzNDk2OTk5ODAyNTtcclxuICAgICAgICAvLyB2YXIgc2NhbGFyID0gKHZlcnRleC5ORUtPWVVVIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpO1xyXG4gICAgICAgIC8vIHZhciBpbmRleCA9IGkzMihmbG9vcihzY2FsYXIgKiAyMSkpO1xyXG4gICAgICAgIC8vIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19Db2xvciA9IHZlYzQ8ZjMyPihjb2xvcmJhcltpbmRleCAqIDNdLCBjb2xvcmJhcltpbmRleCAqIDMgKyAxXSwgY29sb3JiYXJbaW5kZXggKiAzICsgMl0sIDEpO1xyXG4gICAgICAgIE9SSV9WZXJ0ZXhPdXQuVEFJID0gdmVydGV4Lk5FS09ZVVU7XHJcbiAgICAgICAgLy8gdmFyIGluZGV4OiBpMzIgPSAxO1xyXG4gICAgICAgIC8vIE9SSV9WZXJ0ZXhPdXQudmFyeWluZ19Db2xvciA9IHZlYzQ8ZjMyPihjb2xvcmJhcltpbmRleCAqIDNdLCBjb2xvcmJhcltpbmRleCAqIDMgKyAxXSwgY29sb3JiYXJbaW5kZXggKiAzICsgMl0sIDEpO1xyXG4gICAgICAgIHJldHVybiBPUklfVmVydGV4T3V0IDtcclxuICAgIH1cclxuICAgIGApO1xyXG4gICAgICAgIC8vIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBlYXN0TVIubWF0ZXJpYWwgPSBjdXN0b21NYXRlcmlhbDtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgY3VzdG9tTWF0ZXJpYWwuX2RlZmF1bHRQYXNzLnNoYWRlclJlZmxlY3Rpb24uYXR0cmlidXRlc1s0XSA9IHtcclxuICAgICAgICAgICAgZm9ybWF0OiBcImZsb2F0MzJcIixcclxuICAgICAgICAgICAgZ3JvdXA6IDAsXHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAzLFxyXG4gICAgICAgICAgICBuYW1lOiBcIk5FS09ZVVVcIixcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogXCJsb2NhdGlvblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgdmFsdWVUeXBlOiBcImYzMlwiLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZWFzdC5sb2NhbFBvc2l0aW9uID0gbmV3IE9yaWxsdXNpb24uVmVjdG9yMygtOTgxLjc0NzcwNDI0NjgxMywgMTUuNjAzMjQzNTEyODI5MyArIDYsIDMyNi4wOTczMTc0NDI2MjEpO1xyXG4gICAgICAgIGVhc3QubG9jYWxSb3RhdGlvbiA9IG5ldyBPcmlsbHVzaW9uLlZlY3RvcjMoOTAsIC0oMS4wNjEgKiAxODApIC8gTWF0aC5QSSwgMTgwKTtcclxuICAgICAgICBlYXN0LmxvY2FsU2NhbGUgPSBuZXcgT3JpbGx1c2lvbi5WZWN0b3IzKDEuMDQsIDEuMDQsIDEuMDQpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkQ2hpbGQoZWFzdCk7XHJcbiAgICAgICAgcmV0dXJuIGVhc3Q7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gZXhwb3J0ICogZnJvbSBcIi4vSWxsdXNpb25NYWluXCI7XHJcbi8vIGV4cG9ydCAqIGZyb20gXCIuL2dsb2JhbElsbHVtaW5hdGlvblwiO1xyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9zaGFkb3dcIjtcclxuLy8gZXhwb3J0ICogZnJvbSBcIi4vbmVwaG9ncmFtXCJcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2VvbWV0cnlcIjtcclxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIGV4cG9ydCAqIGZyb20gXCIuL2NvcmVcIjtcclxuLy8gZXhwb3J0ICogZnJvbSBcIi4vZ2VvbWV0cnlcIjtcclxuLy8gZXhwb3J0ICogZnJvbSBcIi4vbWF0ZXJpYWxzXCI7XHJcbi8vIGV4cG9ydCAqIGZyb20gXCIuL21lc2hlc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi4vb3RoZXJzXCI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==